<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>数据结构与算法之查找 | Elays&#39;Blog</title>
  <meta name="author" content="Elay">
  
  <meta name="description" content="Elay">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="数据结构与算法之查找"/>
  <meta property="og:site_name" content="Elays&#39;Blog"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Elays&#39;Blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">Elays&#39;Blog</a></h1>
  <h2><a href="/">你是天地生的，美得超越人形</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-09-17T03:47:41.000Z"><a href="/2016/09/17/查找/">2016-09-17</a></time>
      
      
  
    <h1 class="title">数据结构与算法之查找</h1>
  

    </header>
    <div class="entry">
      
        <p><font size="5" color="orange">先来看几个概念</font><br><a id="more"></a></p>
<ul>
<li>查找分为静态查找和动态查找。静态查找是只做查找操作，而动态查找是在查找过程中同时进行插入或删除。</li>
<li>查找算法主要分为：</li>
</ul>
<hr>
<p><font size="5" color="orange">顺序表查找</font><br>顺序表查找就是按序从头找到尾，找到为止。时间复杂度为O(n)</p>
<hr>
<p><font size="5" color="orange">有序表查找</font></p>
<ul>
<li><font size="4" color="red">折半查找</font><br>核心思想：<strong>每次查找线性有序表(假定从小到大有序)的中间位置的记录，如果给定值小于中间记录，则在左半区查找；如果给定值大于中间记录，则在右半区查找</strong>。<br>要求查找表是有序的顺序存储的线性表。<br>代码如下：</li>
<li><font size="4" color="red">插值查找</font><br>核心思想：<strong>插值查找是折半查找的改良版，每次不再是查找正中间位置的元素，而是根据元素内容在最小值到最大值之间的比例，来查找区间里同比例的那个位置上的元素</strong>。插值计算公式如下：mid=low+(key-a[low])/(a[high]-a[low])*(high-low)。<br>同折半查找一样，要求查找表示有序的顺序存储的线性表，而且需要表内元素值分布比较均匀，这样查找效率才会比较高。<br>代码如下：</li>
<li><p><font size="4" color="red">斐波那契查找(黄金分割法查找)</font><br>斐波那契数列有如下定义：F(n)=F(n-1)+F(n-2)，该数列越往后相邻的两个数值的比例越接近于黄金比例0.618。<br>核心思想：<strong>斐波那契查找也是折半查找的改良版，每次不再是查找正中间的位置，而是先把查找序列补全成为刚好比自身长度大的斐波那契数的长度(在序列后面补序列的最后一个元素值)，再去查找序列中位置等于前一个斐波那契数上的元素</strong>。如下图：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/14772161357.png" alt=""><br>代码如下：</p>
<p>斐波那契查找最大的优点就是它只有加减法，没有除法，这在海量数据中运算时，还是有不小的性能提升。</p>
</li>
</ul>
<hr>
<p><font size="5" color="orange">线性索引查找</font><br>就像房间里面的n多东西，一样一样去找是非费劲的，也很难对他们去排序，即使排了序还要花大把时间去维护这个序列。如果我们一个小本子，里面记录着每一样东西它在房间里的位置，那找起来就相当方便了。这就是索引。<br>每个索引项至少要包含记录的关键字和记录存储的位置。上面的例子里，每件物品相当于一个记录，它有各种属性，名字就相当于它的关键字，能唯一确定它，在房间里的位置就相当于记录的存储位置。<br>线性索引表就是索引项组成的线性结构，基于线性索引表的查找就是线性索引查找。有三种重要的线性索引：稠密索引、分块索引、倒排索引。</p>
<ul>
<li><font size="4" color="red">稠密索引</font><br>稠密索引是指每一条记录都对应一个索引项。为了让索引表也可以排序，我们可以用数字来替换关键字，比如用数字去替换名字。在下图中表现为关键码：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721613624.png" alt=""><br>但是稠密索引有个很致命的缺点，当记录量很大时，比如上亿，就需要和记录量一样多的索引项，这需要反复地去访问磁盘，查找性能反而会下降。</li>
<li><font size="4" color="red">分块索引</font><br>将大量的记录分成若干块，快内无序，块间有序，再让每块对应一个索引项，这就是分块索引(快内再有序的话代价太大)。<br>在块数和快内记录数相等时，分块索引的平均查找长度最短，即性能达到最好。</li>
<li><font size="4" color="red">倒排索引</font><br>在前面的例子中，如果我想知道哪些东西是红色的，是需要一个物体一个物体地去查看它的所有属性，看看有没有红色这一项吗？或者说我想知道在n多篇文章里，哪几篇出现了hello这个单词，哪几篇出现了world这个单词，是需要一篇文章一篇文章去找吗？这样太费时了！如果我们有一张表，左侧是红色，右侧红色对应的物体，或者左侧是单词，右侧是单词出现的文章，根据这张表是不是能快很多？<br>由于这是根据记录的属性去查找记录，所以称为倒排索引。</li>
</ul>
<hr>
<p><font size="5" color="orange">二叉排序树</font><br>想要查找效率高，就应当让数据有序，但是如果采用线性顺序存储，又降低了插入和删除记录的效率。有没有什么办法能让查找、插入、删除的效率都高呢？二叉排序树可以做到。二叉排序树也叫做二叉搜索树。</p>
<p><strong>二叉排序树：左子树上所有结点值小于根结点，右子树上所有结点值大于根结点</strong>。</p>
<ul>
<li><font size="4" color="red">二叉排序树的插入和创建</font><br>现在有一堆记录{62，88，58，47，35，73，51，99，37，93}，把第一个数据作为根节点，后面每插入一个数据，先从根节点开始，小于则向左走，一直到某个结点的左儿子为空时插入，大于则向右走，一直到某个结点的右儿子为空时插入（在每个结点处都要判断是向左还是向右走）。最终构造出如下图的树：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721613677.png" alt=""><br>先把62作为根结点，接下来是88，比62大往右走，发现62结点的右儿子为空，则插入到这个位置；接下来是58，比62小往左走，发现62结点的左儿子为空，则插入；再接下来是47，比62小往左走，发现62结点的左儿子不为空，继续向左走，比58小往左走，发现58的左儿子为空，则插入；……<br>对这棵排序二叉树作中序遍历后，就能得到有序序列：{35，37，47，51，58，62，73，88，93，99}。<br>代码见后面。</li>
<li><font size="4" color="red">二叉排序树的查找</font><br>从根结点开始，小于则向左找，大于则向右找。一样的用递归实现，很简单。代码见后面。</li>
<li><font size="4" color="red">二叉排序树的删除</font><br>二叉排序树的删除分为4种情况：<ul>
<li>要删除结点为叶子结点，直接删除即可。</li>
<li>要删除结点的右子树为空，则只需要把左子树接上来即可，得到的依然是一棵排序二叉树。如下图：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/14772161373.png" alt=""></li>
<li>要删除结点的左子树为空，与上一个类似，只需要把右子树接上来即可。</li>
<li>要删除结点的左右子树都不为空，如下图：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/14772161378.png" alt=""><br>这就不能简单地把左子树或右子树接上就可以了，这样做可能就不再是一棵排序二叉树了。仔细观察，其实有37结点和48结点可以代替47结点，而它俩又恰好是47结点中序排列的前驱和后继，其中前驱肯定没有右子树，后继肯定没有左子树（由中序决定的）。比如把37结点的数据移到47结点的位置，再由35结点的右子树去接管37结点的左子树。<br>注意，如果上图中35结点(待删除结点的左儿子)没有右子树，则待删除结点47的直接前驱就应该是35结点，这时候就需要47的左子树去接管35的左子树了。所以这里应该分两种情况讨论，一种是待删除结点的前驱结点不是它的左儿子，另一种是待删除结点的前驱结点就是它的左儿子。<br>代码如下：<br>可以看出，查找某个元素的次数，等于该元素在二叉排序树中的层数。也就是说，二叉排序树的查找性能取决于二叉排序树的形状，深度太大，性能会很低。所以我们希望二叉排序树是平衡的，即它的深度与完全二叉树相同，均为[logn]+1（以2为底，向下取整）。那么查找的时间复杂度将变为O(logn)。</li>
</ul>
</li>
</ul>
<hr>
<p><font size="5" color="orange">平衡二叉树</font></p>
<ul>
<li>平衡二叉树：一种每个结点的左右子树高度差不会超过1的二叉排序树。</li>
<li>平衡因子BF：结点的左子树深度减右子树深度的值。对于平衡二叉树的BF。</li>
<li>最小不平衡子树：其根节点距离插入结点最近，且平衡因子绝对值大于1<br>应该只有三种取值：1，0，-1。非平衡二叉树的BF就多了去了。</li>
<li><font size="4" color="red">平衡二叉树的创建：</font><br>平衡二叉树只是在创建排序二叉树的基础上，每添加一个结点都去递归检查插入结点后树是不是长高了，然后去改变自己的平衡因子，如果打破了平衡（平衡因子绝对值大于1）则作相应的旋转处理（BF为2则把对应的最小不平衡子树右旋，BF为-2则把对应的最小不平衡子树左旋），重新达到平衡状态，并修改平衡因子。<br>插入节点时由于非平衡所带来的旋转处理分为以下4种：<ul>
<li>左左（给结点的左子树插入一个左孩子）：<br>分为以下两种：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721613829.png" alt=""><br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721613879.png" alt=""><br>这俩其实是一样的，都是把BF为2的分支旋转成BF为1的结点的右子树，再把BF为1的结点的原先的右子树改为BF为2的结点的左子树。</li>
<li>右右<br>分为以下两种：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721613929.png" alt=""><br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721613978.png" alt=""><br>这俩其实也是一样的，都是把BF为-2的分支旋转成BF为-1的结点的左子树，再把BF为-1的结点的原先的左子树改为BF为-2的结点的右子树。</li>
<li>左右<br>分为以下三种：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721614032.png" alt=""><br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721614139.png" alt=""><br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721614195.png" alt=""><br>这三其实也是一样的，先把不平衡分支下BF符号相反的结点（下图中BF为-1的结点2）进行左旋，结果旋转成了左左类型，后续处理和左左一致。</li>
<li>右左<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721614252.png" alt=""><br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721614313.png" alt=""><br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721614368.png" alt=""></li>
</ul>
</li>
</ul>
<hr>
<p><font size="5" color="orange">多路查找树</font><br>我们前面讲的树结构都只能一个结点存储一个元素，在元素非常多的时候，就会使得树的度非常大或者树的深度非常大，这样会造成频繁地访问外存（因为所访问的树结点很可能并不是顺序存储的），导致性能很低。所以，我们需要打破一个结点只存储一个元素的限制，于是就有了多路查找树。</p>
<p><strong>多路查找树：每个结点可以存储多个元素，且孩子不止于两个</strong></p>
<ul>
<li><font size="4" color="red">2-3树</font><br>2-3树同时具有以下特点：<ul>
<li>每个结点具有两个孩子（称为2结点）或者三个孩子（称为3结点）</li>
<li>每个2结点包含一个元素和两个孩子（或没有孩子），其左子树的元素小于该2结点的元素，其右子树的元素大于该2结点的元素</li>
<li>每个3结点包含两个元素和三个孩子（或没有孩子），其左子树的元素小于3结点中的较小元素，其中子树的元素介于3结点的两个元素之间，其右子树的元素大于3结点中的较大元素</li>
<li>2-3树的所有叶子都在同一层上</li>
</ul>
</li>
<li><font size="4" color="red">2-3-4树</font><br>2-3-4树是2-3树的扩展，增加了一个四结点，所以相比2-3树增加了以下特点：<ul>
<li>每个结点可以是2结点或者3结点或者4结点</li>
<li>每个4结点包含三个元素和4个孩子（或没有孩子），其左子树的元素小于4结点中的最小元素；第二子树的元素大于4结点的最小元素，小于4结点的第二元素；第三子树的元素大于4结点的第二元素，小于4结点的最大元素；右子树的元素大于4结点的最大元素</li>
</ul>
</li>
<li><font size="4" color="red">B树</font><br>B树是一种平衡的多路查找树，2-3树和2-3-4树都是B树的特例。结点最大的孩子数目称为B树的阶。<br>B树具有如下特点（其阶数为m）：<ul>
<li>如果<strong>根结点</strong>不是叶结点，则至少有两棵子树</li>
<li>每个<strong>非根的分支结点</strong>都有超过(m/2-1)（向下取整）个元素和m/2个孩子（孩子比元素个数多1）</li>
<li>每个叶子结点都有超过(m/2-1)个元素</li>
<li>所有叶子结点位于同一层</li>
<li>每个结点的各个子树所包含的元素的值都介于结点中孩子对应的相邻元素值之间（结点中孩子和元素相间存放，最左孩子的左边元素看作无穷小，最右孩子的右边看作无穷大）</li>
</ul>
</li>
<li><p><font size="4" color="red">B+树</font><br>虽然使用B树访问多个关键字（元素）时，由于一个结点可以存储多个关键字，会减少访问外存的次数，但是如果是访问多个结点，则需要从根结点开始去遍历树，遍历过程中的很多结点可能并不在一个内存页面上，也就是说访问B树的多个结点时，还是要频繁地访问外存。<br>而B+树则是应文件系统所需而产生的一种B树的变形树，严格来说，B+树已经不能算作树了。<br>m阶B+树和m阶B树的区别：</p>
<ul>
<li>有n棵子树的结点中包含n个关键字</li>
<li>所有分支结点可以看成是索引，分子结点中仅含有其子树中的最大（或最小）关键字</li>
<li>所有叶子结点按关键字大小从小到大链接在一起</li>
<li>所有的叶子结点加在一起一定包含了树中的全部关键字，以及指向这些关键字记录的指针</li>
<li>即使在分支结点中已经找到了要查找的关键字，但它也只是用来索引的，不能提供实际记录的访问，因为只有叶子结点中才存储着关键字对应记录的实际指针，还是需要到达包含此关键字的叶子结点才行。</li>
</ul>
<p>那么使用B+树为什么能减少外存访问次数呢？<br>因为B+树中的所有叶子结点是按大小链接在一起的，当需要访问多个结点时，可以从B+树最左端的叶子结点出发，不经过分支结点，而是沿着指向向<br>下一个叶子结点的指针就可以遍历所有的关键字，这样就省去了从根结点开始遍历所需要访问的诸多分支结点，访问的结点少了，访问外存的次数当然就少了。</p>
<p>由于所有叶子结点包含了所有关键字，且是按关键字从小到大链接在一起的，所以B+树特别适合带有范围的查找。</p>
</li>
</ul>
<hr>
<p><font size="5" color="orange">散列表查找</font><br>之前的查找都是先有关键字，然后去表中挨个查找，再根据顺序存储位置的计算方法找到关键字记录对应的内存地址。那么能不能直接根据关键字，不用去表中一个一个地比较就能知道对应记录的内存地址呢？？？<br>可以发现，关键字和内存地址是一对映射关系，如果知道它们之间是怎么映射的，不就可以直接通过关键字找到内存地址吗？也就是如下形式：<br>                                            存储位置=f(关键字)<br>所以在存储的时候，我们就可以按照关系f来存储，查找的时候也按照关系f来查找。</p>
<p>这就是<strong>散列技术：在记录的存储位置和它的关键字之间确定一个对应关系f，使得每一个关键字key对应一个存储位置f(key)</strong>。对应关系f称为散列函数或哈希函数。使用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间称为散列表或哈希表。（散列技术既是存储方法，也是对应的查找方法）。</p>
<p>但是散列技术也有很多缺点：</p>
<ol>
<li>同样的关键字对应很多记录时，不适合用散列技术。因为函数本身可以多个x对应一个y，但不能一个x对应多个y。</li>
<li>散列表不适合范围查找，比如查找一个公司18~50岁的员工，在散列技术中是没法进行这种范围查找的。</li>
<li>散列查找也不能获得记录的排序，而且像最大值、最小值等都无法通过散列查找知道。</li>
<li>散列技术还可能出现冲突，因为在散列函数中有可能会有多个x对应一个y的情况，即多个关键字通过散列函数算出来的是同一个存储地址（这多个关键字称为同义词），但是多个关键字对应的记录明显是多个不同的记录，总不能把这多个记录都存储到一个地址中把，这会产生数据覆盖的，造成后续查找错误，找不到关键字对应的正确记录。</li>
</ol>
<p>散列技术的冲突其实是由散列函数造成的，如果构造出来的散列函数只能一个x对应一个y，那当然是不会产生冲突了。同时散列函数还不能太复杂，不然计算散列函数就得花费大量时间，反而查找性能不好。所以在散列技术中如何构造散列函数f是一个关键点。</p>
<ul>
<li><p><font size="4" color="red">散列函数的构造方法</font></p>
<ul>
<li>直接定址法：<br>取关键字的某个线性函数值作为散列地址，即：f(key)=a x key+b（a、b为常数）。<br>直接定址法的优点是简单、均匀，也不会产生冲突，但是需要事先知道关键字的分布情况，因为关键字如果分布比较稀疏，就会造成散列地址很分散，可能在不同的内存页面上，导致频繁换页，性能降低。所以直接定址法只适合查找表小且连续的情况，实际中并不常用。</li>
<li>数字分析法：<br>数字分析法是抽取关键字的一部分来计算散列地址，这在散列函数中常常用到。<br>数字分析法适合处理关键字位数比较大的情况，而且如果事先知道关键字的分布且关键字中的若干位分布较均匀，就可以考虑使用数字分析法。</li>
<li>平方取中法<br>比如关键字是1234，它的平方是1522756，再抽取中间三位227来作为散列地址。这就是平方取中法。<br>平方取中法比较适合不知道关键字分布，而且关键字位数又不是很大的情况。</li>
<li>折叠法<br>折叠法是将关键字从左到右分割成位数相等的几部分（最后一部分位数不够就不够了，不管它），然后将这几部分叠加求和，并且根据散列表表长，取后几位作为散列地址。<br>比如关键字是9876543210，散列表表长为3位，将关键字分为4组：987|654|321|0，然后将它们叠加求和987+654+321+0=1962，再拿出后3位962作为散列地址。<br>折叠法适合不知道关键字分布，而且关键字位数比较多的情况。</li>
<li><p>除留余数法<br>此方法为最常用的散列函数构造方法。除留余数法就是把关键字除以某个数，取余数作为散列地址，即：f(key)=key % p<br>很显然，除留余数法是会产生冲突的，它的关键就在于选择合适的p。</p>
<p>经验表明，p应该选为小于或等于散列表长度（最好接近表长）的最小质数或不包含20以下的质因子的合数。</p>
</li>
<li>随机数法<br>随机数法就是取关键字的随机函数值作为它的散列地址，即f(key)=random(key)。<br>随机数法适合关键字长度不等的情况。</li>
</ul>
</li>
<li><p><font size="4" color="red">处理散列冲突的方法</font><br>虽然可以通过构造好的散列函数来减少冲突的发生，但是冲突总还是有的，几乎不可避免。那么应该有一些处理散列冲突的方法。</p>
<ul>
<li>开放地址法<br>就像你要去买一套房子，发现它已经被人买走了，怎么办？找别的房子呗！这就是<strong>开放地址法：发生冲突后，去寻找下一个空的地址</strong>。只要散列表足够大，空的散列地址总是能找到的。<br>那么以何种方式去找下一个空的地址呢？<ul>
<li>开放定址法之线性探测法<br>发生冲突后，一个一个往后顺序查找空的地址，即：<br> fi(key)=(f(key)+di) % p   （di=1，2，3…..p-1）<br>但是使用线性探测法，很可能会出现本来不是同义词却要争夺一个地址的情况，这种现象称为<strong>堆积</strong>。</li>
<li>开放定址法之二次探测法<br>发生冲突后，以平方跳跃的方式往前或者往后查找空的地址，即<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721614417.png" alt=""><br>使用平方是为了不让关键字算出来的散列地址都聚集在某一块区域，减少堆积现象。</li>
<li>开放地址法之随机探测法<br>发生冲突后，随机地去查找空的地址，即：<br>fi(key)=(f(key)+di) % p    （di是一个随机数列）</li>
</ul>
</li>
<li>再散列函数法<br>当发生冲突时，换个散列函数来计算散列地址。<br>这种方法不会产生堆积，但是也相应地增加了计算时间。</li>
<li>链地址法<br>发生冲突后，把同义词的记录链接到上一个同义词的后面，构成一个单链表，称之为同义词子表，而散列表中只存储所有同义词子表的头指针（有些类似于之前介绍过的树中的孩子表示法）<br>链地址法适合处理可能会造成很多冲突的散列函数，因为它提供了绝对不会出现找不到地址的保障。但是同时，也带来了查找时需要遍历单链表的性能消耗。</li>
<li>公共溢出区法<br>发生冲突后，把冲突的关键字放到一个公共的溢出区（顺序存储表）里去。查找时，先根据关键字和散列函数计算出来的地址去查找，如果关键字不匹配，则到再溢出区里去顺序查找关键字。<br>公共溢出区法适合冲突数据很少的情况，因为在溢出区里顺序查找关键字也是比较费时的。冲突数据很少时，公共溢出区法对查找性能来说是非常高的。</li>
</ul>
</li>
<li><p><font size="4" color="red">影响散列查找性能的因素</font></p>
<ul>
<li>散列函数是否均匀，即散列函数下发生冲突的可能性是否小</li>
<li>处理冲突的方法。比如线性探测法处理冲突有可能会产生堆积现象，显然性能就没有二次探测法好。</li>
<li>散列表的装填因子。<br>装填因子=填入表中的记录个数/散列表长度。<br>显然，装填因子越大，散列表中的空闲地址就越少，产生冲突的可能性就越大。所以通常把散列表的空间设置得记录集合大。无论记录集合有多大，都总可以选择一个合适的装填因子以便将平均查找长度限定在一个范围之内，这个时候查找的时间复杂度就是O(1)了。不过这是以牺牲空间为代价的，典型的用空间换时间。</li>
</ul>
</li>
</ul>

      
    </div>
    <footer>
      
        
  
  <div class="categories">
    <a href="/categories/数据结构/">数据结构</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/查找/">查找</a>
  </div>

        
  <div class="addthis addthis_toolbox addthis_default_style">
    
      <a class="addthis_button_facebook_like" fb:like:layout="button_count"></a>
    
    
      <a class="addthis_button_tweet"></a>
    
    
      <a class="addthis_button_google_plusone" g:plusone:size="medium"></a>
    
    
      <a class="addthis_button_pinterest_pinit" pi:pinit:layout="horizontal"></a>
    
    <a class="addthis_counter addthis_pill_style"></a>
  </div>
  <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js"></script>

      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


<section id="comment">
  <h1 class="title">留言</h1>

  
      <div id="fb-root"></div>
<script>
  (function(d, s, id) {
    var js, fjs = d.getElementsByTagName(s)[0];
    if (d.getElementById(id)) return;
    js = d.createElement(s); js.id = id;
    js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=123456789012345";
    fjs.parentNode.insertBefore(js, fjs);
  }(document, 'script', 'facebook-jssdk'));
</script>

<div class="fb-comments" data-href="http://yoursite.com/2016/09/17/查找/index.html" data-num-posts="5" data-width="840" data-colorscheme="light"></div>
      
  
</section>

</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:yoursite.com">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/C-语法/">C#语法</a><small>2</small></li>
  
    <li><a href="/categories/C/">C++</a><small>4</small></li>
  
    <li><a href="/categories/C语言/">C语言</a><small>1</small></li>
  
    <li><a href="/categories/OpenGL/">OpenGL</a><small>27</small></li>
  
    <li><a href="/categories/c/">c++</a><small>1</small></li>
  
    <li><a href="/categories/博客配置/">博客配置</a><small>3</small></li>
  
    <li><a href="/categories/操作系统/">操作系统</a><small>4</small></li>
  
    <li><a href="/categories/数据结构/">数据结构</a><small>15</small></li>
  
    <li><a href="/categories/毕设/">毕设</a><small>1</small></li>
  
    <li><a href="/categories/游戏开发/">游戏开发</a><small>1</small></li>
  
    <li><a href="/categories/游戏设计模式/">游戏设计模式</a><small>1</small></li>
  
    <li><a href="/categories/计算机图形学/">计算机图形学</a><small>2</small></li>
  
    <li><a href="/categories/设计模式/">设计模式</a><small>5</small></li>
  
    <li><a href="/categories/调试错误集锦/">调试错误集锦</a><small>1</small></li>
  
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/BIOS和微机启动过程/">BIOS和微机启动过程</a><small>1</small></li>
  
    <li><a href="/tags/Blinn-Phong/">Blinn-Phong</a><small>1</small></li>
  
    <li><a href="/tags/C/">C</a><small>1</small></li>
  
    <li><a href="/tags/C-容器/">C#容器</a><small>1</small></li>
  
    <li><a href="/tags/C-IO/">C++IO</a><small>1</small></li>
  
    <li><a href="/tags/Gamma校正/">Gamma校正</a><small>1</small></li>
  
    <li><a href="/tags/MarkDown/">MarkDown</a><small>1</small></li>
  
    <li><a href="/tags/Mathjax语法/">Mathjax语法</a><small>1</small></li>
  
    <li><a href="/tags/OS内核/">OS内核</a><small>1</small></li>
  
    <li><a href="/tags/OpenGL坐标系统/">OpenGL坐标系统</a><small>1</small></li>
  
    <li><a href="/tags/OpenGL摄像机/">OpenGL摄像机</a><small>1</small></li>
  
    <li><a href="/tags/OpenGL窗口/">OpenGL窗口</a><small>1</small></li>
  
    <li><a href="/tags/OpenGL配置/">OpenGL配置</a><small>1</small></li>
  
    <li><a href="/tags/c-特性/">c++特性</a><small>1</small></li>
  
    <li><a href="/tags/const/">const</a><small>1</small></li>
  
    <li><a href="/tags/timeTest/">timeTest</a><small>1</small></li>
  
    <li><a href="/tags/二叉树/">二叉树</a><small>1</small></li>
  
    <li><a href="/tags/交流/">交流</a><small>1</small></li>
  
    <li><a href="/tags/光照场景/">光照场景</a><small>1</small></li>
  
    <li><a href="/tags/光照贴图/">光照贴图</a><small>1</small></li>
  
    <li><a href="/tags/关键路径/">关键路径</a><small>1</small></li>
  
    <li><a href="/tags/冯氏光照/">冯氏光照</a><small>1</small></li>
  
    <li><a href="/tags/几何着色器/">几何着色器</a><small>1</small></li>
  
    <li><a href="/tags/反走样/">反走样</a><small>1</small></li>
  
    <li><a href="/tags/图/">图</a><small>1</small></li>
  
    <li><a href="/tags/图形学概述/">图形学概述</a><small>1</small></li>
  
    <li><a href="/tags/图形显示系统/">图形显示系统</a><small>1</small></li>
  
    <li><a href="/tags/外观-观察-者命令/">外观 观察 者命令</a><small>1</small></li>
  
    <li><a href="/tags/多说/">多说</a><small>1</small></li>
  
    <li><a href="/tags/天空盒子/">天空盒子</a><small>1</small></li>
  
    <li><a href="/tags/头结点/">头结点</a><small>1</small></li>
  
    <li><a href="/tags/实例化/">实例化</a><small>1</small></li>
  
    <li><a href="/tags/尾递归/">尾递归</a><small>1</small></li>
  
    <li><a href="/tags/工厂模式单例模式/">工厂模式单例模式</a><small>1</small></li>
  
    <li><a href="/tags/帧同步/">帧同步</a><small>1</small></li>
  
    <li><a href="/tags/帧缓冲/">帧缓冲</a><small>1</small></li>
  
    <li><a href="/tags/常见光源/">常见光源</a><small>1</small></li>
  
    <li><a href="/tags/异步传输/">异步传输</a><small>2</small></li>
  
    <li><a href="/tags/拓扑排序/">拓扑排序</a><small>1</small></li>
  
    <li><a href="/tags/操作系统概述/">操作系统概述</a><small>1</small></li>
  
    <li><a href="/tags/改进排序/">改进排序</a><small>1</small></li>
  
    <li><a href="/tags/文件IO/">文件IO</a><small>1</small></li>
  
    <li><a href="/tags/最小生成树/">最小生成树</a><small>1</small></li>
  
    <li><a href="/tags/最短路径/">最短路径</a><small>1</small></li>
  
    <li><a href="/tags/材质/">材质</a><small>1</small></li>
  
    <li><a href="/tags/查找/">查找</a><small>1</small></li>
  
    <li><a href="/tags/栈/">栈</a><small>1</small></li>
  
    <li><a href="/tags/树/">树</a><small>1</small></li>
  
    <li><a href="/tags/模型加载/">模型加载</a><small>1</small></li>
  
    <li><a href="/tags/模板测试/">模板测试</a><small>1</small></li>
  
    <li><a href="/tags/深度测试/">深度测试</a><small>1</small></li>
  
    <li><a href="/tags/混合/">混合</a><small>1</small></li>
  
    <li><a href="/tags/着色器/">着色器</a><small>1</small></li>
  
    <li><a href="/tags/着色器画三角形/">着色器画三角形</a><small>1</small></li>
  
    <li><a href="/tags/码农/">码农</a><small>1</small></li>
  
    <li><a href="/tags/简单排序/">简单排序</a><small>1</small></li>
  
    <li><a href="/tags/纹理/">纹理</a><small>1</small></li>
  
    <li><a href="/tags/缓冲对象/">缓冲对象</a><small>1</small></li>
  
    <li><a href="/tags/编译链接错误/">编译链接错误</a><small>1</small></li>
  
    <li><a href="/tags/背面剔除/">背面剔除</a><small>1</small></li>
  
    <li><a href="/tags/责任链模式适配器模式/">责任链模式适配器模式</a><small>1</small></li>
  
    <li><a href="/tags/进程的描述与控制/">进程的描述与控制</a><small>1</small></li>
  
    <li><a href="/tags/重定义错误/">重定义错误</a><small>1</small></li>
  
    <li><a href="/tags/链表/">链表</a><small>1</small></li>
  
    <li><a href="/tags/队列/">队列</a><small>1</small></li>
  
    <li><a href="/tags/面向对象设计原则/">面向对象设计原则</a><small>1</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2017 Elay
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>