<!DOCTYPE HTML>
<html>

<head><meta name="generator" content="Hexo 3.9.0">
	<link rel="bookmark" type="image/x-icon" href="/img/logo_miccall.png">
	 <link rel="shortcut icon" href="/img/logo_miccall.png">
	
			
    <title>
    Elays'Blog
    </title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
	<script>
    (function(){
        if('{{ page.password }}'){
            if (prompt('请输入文章密码') !== '{{ page.password }}'){
                alert('密码错误');
                history.back();
            }
        }
    })();
	</script>
    <link rel="stylesheet" href="/css/mic_main.css">
    <link rel="stylesheet" href="/css/dropdownMenu.css">
    
    	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css">
    </noscript>
			    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<link rel="stylesheet" href="/css/prism-dark.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>
    
		
<!-- Layouts -->


<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<!--<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">-->
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/latest.js?config=TeX-MML-AM_CHTML">
</script>

<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_undefined.css">
<link rel="stylesheet" href="/css/typo.css">
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">MICCALL</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special">
            <ul class="menu links">
			<!-- Homepage  主页  --> 
			<li>
	            <a href="/" rel="nofollow">主页</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">分类</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="/categories/C/">C#</a></li><li><a class="category-link" href="/categories/C-语法/">C#语法</a></li><li><a class="category-link" href="/categories/C/">C++</a></li><li><a class="category-link" href="/categories/C语言/">C语言</a></li><li><a class="category-link" href="/categories/Graphics/">Graphics</a></li><li><a class="category-link" href="/categories/Math/">Math</a></li><li><a class="category-link" href="/categories/OpenGL/">OpenGL</a></li><li><a class="category-link" href="/categories/Unity/">Unity</a></li><li><a class="category-link" href="/categories/博客配置/">博客配置</a></li><li><a class="category-link" href="/categories/并行计算/">并行计算</a></li><li><a class="category-link" href="/categories/操作系统/">操作系统</a></li><li><a class="category-link" href="/categories/数据结构/">数据结构</a></li><li><a class="category-link" href="/categories/毕设/">毕设</a></li><li><a class="category-link" href="/categories/游戏开发/">游戏开发</a></li><li><a class="category-link" href="/categories/计算机系统/">计算机系统</a></li><li><a class="category-link" href="/categories/设计模式/">设计模式</a></li><li><a class="category-link" href="/categories/面试/">面试</a>
	                    </li></ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/gallery/" title="图库">
		                图库
		            </a>
		        </li>
		        
		        <li>
		            <a href="/tag/" title="搜索">
		                搜索
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
		            
		                <li><a href="https://github.com/miccall" class="icon fa-github"><span class="label">GitHub</span></a></li>
		            
		            
		            
		            
			</ul>
</nav>

        <div id="main">
            <div class="post_page_title_img" style="height: 25rem;background-image: url(https://github.com/Popperelay/Photos/blob/master/Photos/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%94%B9%E8%BF%9B%E6%8E%92%E5%BA%8F_BG.jpg?raw=true);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;">
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2>数据结构与算法之改进排序</h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
				<!-- 目录 -->
				<p class="show-toc-btn" id="show-toc-btn" onclick="showToc();" style="display:none">
				<span class="btn-bg"></span>
				<span class="btn-text">文章导航</span>
				</p>
				<div id="toc-article" class="toc-article">
					<span id="toc-close" class="toc-close" title="隐藏导航" onclick="showBtn();">×</span>
					<strong class="toc-title">文章目录</strong>
					
			   </div>
			   <script type="text/javascript">
				function showToc(){
					var toc_article = document.getElementById("toc-article");
					var show_toc_btn = document.getElementById("show-toc-btn");
					toc_article.setAttribute("style","display:block");
					show_toc_btn.setAttribute("style","display:none");
					};
				function showBtn(){
					var toc_article = document.getElementById("toc-article");
					var show_toc_btn = document.getElementById("show-toc-btn");
					toc_article.setAttribute("style","display:none");
					show_toc_btn.setAttribute("style","display:block");
					};
			   </script>
				
                <p>排序算法主要分为7类：冒泡排序、简单选择排序、直接插入排序(这三种属于简单算法)、希尔排序、堆排序、归并排序、快速排序(这四种属于改进算法)<br><a id="more"></a></p>
<hr>
<p><font size="5" color="orange">希尔排序</font><br>希尔排序是直接插入排序的升级版。对于直接插入排序，原序列中待排序的元素还是比较多。每次插入时需要很多次后移操作(因为序列较长时一般后移距离也长)，有没有什么办法能够减少后移的距离呢？很容易想到的是，把原序列分组，在每一组内进行直接插入排序，由于每一组序列长度较小，再插入时移动的次数也就自然少了。<br>但是有一个问题，对{9，1，2，5，7，4，8，6，3，5}分成五组：{9，1}，{2，5}，{7，4}，{8，6}，{3，5}，即使每一分组都排好序后再合并：{1，9，2，5，4，7，6，8，3，5}，得到的这个序列依旧是杂乱无章的，如下图：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/ImprovedSort1.png?raw=true" alt><br>并没有大体上让小的元素往前走，让大的元素往后走，对下一次的直接排序几乎没有多大帮助。原因在于分组时，元素间隔太小，交换位置时，只能和附近的元素交换，如果把元素间隔设大一点，就能够和较远的元素交换位置，这就增大了小元素大幅度往前走，大元素大幅度往后走的几率。但是通常仅有一次排序是不够的，需要缩小间隔再直接插入排序多次（第一次间隔gap=n/2，后面几次的间隔减半gap=gap/2，直到gap==1。直接插入排序相当于gap=1时的希尔排序）。如下图所示：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/ImprovedSort2.png?raw=true" alt><br>希尔排序的核心：<strong>按间隔分组直接插入排序，再缩小间隔分组直接插入排序，直到间隔等于1</strong><br>代码如下：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">ShellSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> gap <span class="token operator">=</span> array<span class="token punctuation">.</span>Length <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//多次分组直接插入排序，直到gap=1</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> gap <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">;</span> gap <span class="token operator">/</span><span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>Length <span class="token operator">-</span> gap<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>i <span class="token operator">+</span> gap<span class="token punctuation">]</span> <span class="token operator">&lt;</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">int</span> temp <span class="token operator">=</span> array<span class="token punctuation">[</span>i <span class="token operator">+</span> gap<span class="token punctuation">]</span><span class="token punctuation">;</span>
                <span class="token keyword">int</span> j<span class="token punctuation">;</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> temp<span class="token punctuation">;</span> j <span class="token operator">-</span><span class="token operator">=</span> gap<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    array<span class="token punctuation">[</span>j <span class="token operator">+</span> gap<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                array<span class="token punctuation">[</span>j <span class="token operator">+</span> gap<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>【注】：</p>
<ul>
<li>由于希尔排序比直接插入排序减少了移动距离(移动次序)，所以希尔排序的效率比直接插入排序高，也就自然比简单选择排序和冒泡排序性能好了。进过分析希尔排序的平均时间复杂度是O(nlogn)。</li>
<li>由于希尔排序是将元素跳跃式分组，插入元素时也是跳跃式插入，如上图中第一轮排序里两个5在排序前后的次序发生了变化，所以希尔排序是不稳定排序。</li>
<li>大量研究表明，当间隔序列为<img src="https://github.com/Popperelay/Photos/blob/master/Photos/ImprovedSort3.png?raw=true" alt><br>时，可以获得不错的效果。但是最后一个增量值必须等于1。</li>
</ul>
<hr>
<p><font size="5" color="orange">堆排序</font><br>堆排序是对简单选择排序的一种改进。来看几个定义：</p>
<ul>
<li>堆是一棵<strong>完全二叉树</strong>，满足一下特性：所有结点比它的子结点大（大顶堆）或者所有结点比它的子结点小（小顶堆）。</li>
<li>堆可以用层序遍历的次序存入到数组中</li>
</ul>
<p><strong>把待排序的序列建成一个大顶堆的方法：</strong><br>先把待排序的序列按照层序构建成一棵完全二叉树，再从下往上、从右到左，将每个非叶结点与其左右子结点的较大值互换，直到比它的左右儿子都大为止。</p>
<p>比如有一个待排序序列：{50，10，90，30，70，40，80，60，20}，先按层序构建成完全二叉树，如下图：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/ImprovedSort4.png?raw=true" alt><br>接下来从下往上，从右到左的第一个非叶结点是30，将它与左右儿子的较大者60互换，结果如下图：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/ImprovedSort5.png?raw=true" alt><br>接着从下往上，从右到左的第二个非叶结点是10，将它与左右儿子的较大者70互换，结果如下图：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/ImprovedSort6.png?raw=true" alt><br>再接下来从下往上，从右到左的第三个非叶结点是90，因为它本身就比它的左右儿子都大，所以不用互换了。<br>再接下来从下往上，从右到左的第四个非叶结点是50，将它与左右儿子的较大者90互换，因为要一直换到比左右儿子都大为止，所以把50、90互换之后，50还要和它的左右儿子的较大者80互换，结果如下图：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/ImprovedSort7.png?raw=true" alt><br>到此，整个大顶堆就构建完成了。那么如何利用这个大顶堆来排序呢？</p>
<p><strong>利用大顶堆来排序的方法：</strong><br>把根结点元素与还未排序的最后一个元素交换位置（层序下的最后一个未排序元素），再把交换后的根结点与其左右孩子的较大者交换，直到比它的左右孩子都大。重复，直到所有结点都排序完成。</p>
<p>对上面的大顶堆排序的过程如下：<br>先把根结点90和待排序的最后一个元素20交换位置，结果如下图：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/ImprovedSort8.png?raw=true" alt><br>再把20和它的左右儿子的较大者交换位置，直到比它的左右儿子都大，结果如下图：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/ImprovedSort9.png?raw=true" alt><br>这样最大的元素90就被放到了数组的最后一个位置，是不是有点像选出了最大的元素然后把它放到最后的位置？？？所以从这里可以看出堆排序是简单选择排序的改进版。<br>接下来把根结点80和待排序的最后一个元素30交换位置，结果如下图：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/ImprovedSort10.png?raw=true" alt><br>再把30和它的左右儿子的较大者交换位置，直到比它的左右儿子都大，结果如下图：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/ImprovedSort11.png?raw=true" alt><br>后面的变化完全类似，不再赘述，如下图：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/ImprovedSort12.png?raw=true" alt><br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/ImprovedSort13.png?raw=true" alt><br>至此，便完成了堆排序的过程。<br>经过分析，堆排序的时间复杂度为O(nlogn)（堆排序对原始序列的排序状态并不敏感，所以堆排序的最好、最坏和平均时间复杂度都为O(nlogn)），空间复杂度为O(1)。但是由于它的交换是跳跃式的（不是和相邻的元素交换），所以堆排序也是一种不稳定排序。<br>【注】：</p>
<ul>
<li>由于构建堆的时候需要很多次比较，所以它并不适合待排序序列个数较少的情况，因为得不偿失嘛！</li>
</ul>
<p>代码如下：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>
using namespace std;

void HeapSort(int array[], int length);
int main()
{
    int array[] = { 65535,1,6,9,7,2,5,0,3,1 };
    int length = sizeof(array) / sizeof(int);
    HeapSort(array, length-1);

    for (int i = 1; i < length; i++) {
        cout << array[i] << ' ';
    }

    int key;
    cin >> key;
    return 0;
}

int GreaterRoot(int array[], int i, int length);
void HeapSort(int array[], int length) {  //数组从1开始存数
    //构建大顶堆
    for (int i = length / 2; i >= 1; i--) {
        int j = GreaterRoot(array, i, length);
        while (j != 0) {  //一直向下调整到比它的子结点都大
            j = GreaterRoot(array, j, length);
        }
    }
    //对大顶堆排序
    for (int i = length; i >= 2; i--) {
        //第一个位置和右下角最后一个未排序位置互换
        int temp;
        temp = array[1];
        array[1] = array[i];
        array[i] = temp;
        //将调到第一个位置的元素和它的子结点一直向下比较，直到重新调整为大顶堆
        int j = GreaterRoot(array, 1, i - 1);
        while (j != 0) {
            j = GreaterRoot(array, j, i - 1);
        }
    }
}

//如果该结点已经比子结点都大，则返回0，否则返回跟它交换的那个子结点的编号
int GreaterRoot(int array[], int i, int length) {
    if (i * 2 > length)   //叶节点
        return 0;
    if (array[i] > array[2 * i] && (2 * i + 1 > length || array[i] > array[2 * i + 1])) { //只有左儿子，但是比左二子大，或者有右儿子但是比左右儿子都大
        return 0;
    }

    if (2 * i + 1 > length || array[2 * i] > array[2 * i + 1]) {  //和子结点的较大者交换
        int temp;
        temp = array[i];
        array[i] = array[2 * i];
        array[2 * i] = temp;
        return 2 * i;
    }
    else {
        int temp;
        temp = array[i];
        array[i] = array[2 * i + 1];
        array[2 * i + 1] = temp;
        return 2 * i + 1;
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></iostream></code></pre>
<hr>
<p><font size="5" color="orange">归并排序</font><br>归并排序很简单，归并在数据结构中定义是将两个或者两个以上的有序表组合成一个新的有序表。2路归并排序就是每两个一组进行排序，再归并（合起来并同时排序），再每两个一组进行排序，再归并，直到不能再归并为止（或者得到的有序序列长度等于原始待排序序列长度为止）。如下图所示：<br>迭代图示：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/ImprovedSort14.png?raw=true" alt><br>递归图示：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/ImprovedSort15.png?raw=true" alt><br>归并排序可以用递归来实现，也可以用迭代（非递归）来实现。<br>归并排序的递归代码如下：<br>归并排序的迭代代码如下：</p>
<hr>
<p><font size="5" color="orange">快速排序</font><br>希尔排序是直接插入排序的升级版，属于插入排序类，堆排序是简单选择排序的升级版，属于选择排序类，而快速排序是冒泡排序的升级版，属于交换排序类。</p>
<p>快速排序的核心思想：<strong>随机选择一个基准数，把小于基准数的元素移到基准数左边，把大于等于基准数的元素移到基准数右边。再分别对左右两边的元素重新选择基准数，重复上诉过程，直到排序结束（从小到大排序）</strong>。</p>
<p>快速排序的具体方法（这里介绍两种：哨兵换岗法、挖坑填数法）</p>
<ul>
<li><p><strong>哨兵换岗法：</strong><br>随机选择一个基准数（一般选择待排序序列最左边的数），开始时左哨兵指向序列头，右哨兵指向序列尾。右哨兵先向左移动，直到找一个小于基准数的数，然后左哨兵向右移动，直到找到一个大于基准数的数，然后两哨兵换岗（两哨兵所在的元素交换位置，这样小的就到左边了，大的就到右边了）。重复上诉过程直到右哨兵和左哨兵相遇，再把相遇的数和基准数交换位置。这样一次排序后，比基准数小的全在它的左边，比基准数大的全在它的右边，再分别对左右两边进行上诉排序，直到排序完成（一看就是递归）。</p>
<p>例如要对{6，1，2，7，9，3，4，5，10，8}这个序列进行排序：</p>
<ul>
<li>假定选择6作为基准数，设置左哨兵i和右哨兵j，如下图：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/ImprovedSort16.png?raw=true" alt></li>
<li>然后右哨兵j向左走找到比6小的数5，左哨兵i向右走找到比6大的数7，交换5和7，如下图所示：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/ImprovedSort17.png?raw=true" alt></li>
<li>接着右哨兵继续向左走找到比6小的数4，左哨兵向右走找到比6大的数9，交换4和9，如下图所示：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/ImprovedSort18.png?raw=true" alt></li>
<li>然后右哨兵继续向左走找到比6小的数3，左哨兵向右走去找比6大的数，结果遇到右哨兵了，把左右哨兵所在的数3和基准数交换。到此第一轮排序结束了。如下图所示：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/ImprovedSort19.png?raw=true" alt></li>
<li>再对6左边的序列{3，1，2，5，4}进行上诉排序，以3为新的基准数得到的序列应该是：{2，1，3，5，4}，这样比3小的都在3左边，比3大的都在3右边。再对序列{2，1}和{5，4}进行排序，最后得到的序列应该是：{1，2，3，4，5，6，9，7，10，8}，对6右边的序列{9，7，10，8}也是同样的排序方式，最终得到的序列是：{1，2，3，4，5，6，7，8，9，10}</li>
</ul>
<p>代码如下：</p>
</li>
<li><p><strong>挖坑填数法：</strong><br>随机选择一个基准数（一般选择待排序序列最左边的数），将基准数所在的位置看作第一个坑，从右往左找第一个小于基准数的数，把它挪到坑里去（这个数原先所在的位置就形成了一个新的坑），再从左往右找第一个大于基准数的数，把它挪到新坑里去。重复上诉过程直到左右相遇，再把基准数挪到最后一个坑里去。样一次排序后，比基准数小的全在它的左边，比基准数大的全在它的右边，再分别对左右两边进行上诉排序，直到排序完成（从小到大排序。而且其实也是有哨兵的，不过为了突出挖坑，下面的图示没有画出哨兵）。</p>
<p>例如要对{6，1，2，7，9，3，4，5，10，8}这个序列进行排序：</p>
<ul>
<li>假定选择6作为基准数，则6所在的位置就是第一个坑，如下图：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/ImprovedSort20.png?raw=true" alt></li>
<li>从右往左找到小于基准数6的数5，把它挪到坑里，结果如下：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/ImprovedSort21.png?raw=true" alt></li>
<li>再从左往右找到大于基准数6的数7，把它挪到坑里，结果如下：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/ImprovedSort22.png?raw=true" alt></li>
<li>接下来继续从右往左找到小于基准数6的数4，把它坑里，如下图所示：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/ImprovedSort23.png?raw=true" alt><br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/ImprovedSort24.png?raw=true" alt></li>
<li>再从左往右找到大于基准数6的数9，把它挪到坑里，结果如下图：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/ImprovedSort25.png?raw=true" alt></li>
<li>接着继续从右向左找到小于基准数6的数3，把它挪到坑里，如下图所示：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/ImprovedSort26.png?raw=true" alt><br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/ImprovedSort27.png?raw=true" alt></li>
<li>再从左往右去找大于基准数6的数，结果发现左右相遇了，这时到第一轮排序的最后一步了，把基准数挪到坑里，结果如下图：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/ImprovedSort28.png?raw=true" alt></li>
</ul>
<p>到此，快速排序的挖坑填数法的第一轮排序就结束了，接下来再对基准数左右两边的序列重复上诉排序过程就ok了。<br>代码如下：</p>
<p>从排序过程和代码都可以看出，挖坑填数法其实是哨兵换岗法的改进版，挖坑填数法一样存在左右哨兵，但是明显交换次数少了（交换时的赋值语句少了）。</p>
</li>
</ul>
<p>快速排序的时间性能取决于快速排序递归的深度，当选择的基准数恰好接近待排序序列的中间值时，例如在哨兵换岗法中选择的基准数6恰好就接近序列中间值，此时快速排序的性能较好，时间复杂度为O(nlogn)，空间复杂度为O(logn)；但是如果待排序的序列恰好是已经有序或基本有序的，如序列{1，2，3，4，5，6，7，8，9，10}或者{10，9，8，7，6，5，4，3，2，1}，此时快速排序的深度就为n-1，性能较差，时间复杂度为O(n^2)，空间复杂度为O(n)。平均情况，快速排序的时间复杂度为O(nlogn)，空间复杂度为O(logn)。</p>
<p><strong>对快速排序的优化：</strong></p>
<ol>
<li>优化选取基准数<br>每次选择待排序序列的第一个元素作为基准数，就很有可能选中的数值太大或者太小，造成快速排序性能太低，对怎么选择基准数有以下几种方法：<ul>
<li>不再是每次选待排序序列的第一个元素作为基准数，而是随机选取一个。其实对于无序的序列来说，这种随机选取和选择第一个元素是一个意思，并不能起到优化作用，还会增加随机数生成器本身带来的开销</li>
<li>三数取中。随机取三个数，选择大小在中间的那个数，来作为快速排序的基准数。为了避免随机数带来的消耗，实际上取序列左端、右端、中间位置的三个数即可。因为这和随机是一个效果嘛。从概率上来说，取到的三个数均为序列中最小或者最大数的可能性是很小的，所以三个数中的中间数接近序列的中间数的可能性就提高了。</li>
<li>九数取中。和三数取中是一个意思，在数组中分三次取样，每次选出各组的中间数，再在这三个中数种选出一个中数作为基准数。九数取中一般用于序列长度比较大的情况下，以保证取出的基准数比较接近序列的中值。</li>
</ul>
</li>
<li>减少交换次数。在哨兵换岗法中，右哨兵和左哨兵找出的数要互相交换位置，这种swap交换需要三个赋值语句，其实可以减少。而挖坑填数法正好是哨兵换岗法的这种优化，把要调到前面或者后面的数填到坑里就行，不一定要正好调换两个哨兵的位置，只要保证把小的大致往前放，把大的大致往后放就行。比如右哨兵找到了一个比基准数小的数，左哨兵找到了一个比基准数大的数，这时候其实不需要交换左右哨兵，只需要把右哨兵填到前面的坑里（基准数那个位置），再把左哨兵填到后面的坑里（原右哨兵空出来的位置），这样就大致保证了“把小的往前挪，把大的往后挪”的原则，同时减少了交换次数（在下图中可以看到只有两次赋值，而不是三次），如下图所示：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/ImprovedSort29.png?raw=true" alt></li>
<li>小数组时使用直接插入排序（直接插入排序是简单排序中性能最好的）。对于序列元素较少时，使用快速排序反而不如直接插入排序，因为快速排序用到了递归操作，在数据量大时，相比于快排的优势递归带来的开销可以忽略，但数据量小时就无法忽略了。所以对快排的优化，可以在待排序序列长度递归到很小时，就不再继续用快排进行排序了，而换成直接插入排序。一般递归到待排序序列长度小于7（有时是50）时，改为使用直接插入排序。伪码如下：<pre class="line-numbers language-csharp"><code class="language-csharp"> <span class="token keyword">const</span> <span class="token keyword">int</span> Length_InsertSort <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">;</span>
 <span class="token keyword">void</span> <span class="token function">QuickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">,</span><span class="token keyword">int</span> low<span class="token punctuation">,</span><span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token punctuation">{</span>
     <span class="token keyword">int</span> pivot<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//基准数在序列中的位置</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">></span> Length_InsertSort<span class="token punctuation">)</span><span class="token punctuation">{</span>
         <span class="token comment" spellcheck="true">//递归待排序序列长度大于7时用快速排序</span>
         pivot <span class="token operator">=</span> <span class="token function">Partition</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//把array[low..high]一分为二，小的在左边，大的在右边，返回基准数所在的位置</span>
         <span class="token function">QuickSort</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> low<span class="token punctuation">,</span> pivot <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//对基准数左边的序列递归排序</span>
         <span class="token function">QuickSort</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> pivot <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//对基准数右边的序列递归排序</span>
     <span class="token punctuation">}</span>
     <span class="token keyword">else</span> <span class="token punctuation">{</span>
         <span class="token comment" spellcheck="true">//递归待排序序列长度小于等于7时用直接插入排序</span>
         <span class="token function">InsertSort</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>减少递归调用的次数。在上述代码中，第一个递归调用和第二个递归调用做的都是相同的Partition操作，其实可以把它俩合成一个。伪码如下：<pre class="line-numbers language-csharp"><code class="language-csharp"> <span class="token keyword">const</span> <span class="token keyword">int</span> Length_InsertSort <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">;</span>
 <span class="token keyword">void</span> <span class="token function">QuickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">,</span><span class="token keyword">int</span> low<span class="token punctuation">,</span><span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token punctuation">{</span>
     <span class="token keyword">int</span> pivot<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//基准数在序列中的位置</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">></span> Length_InsertSort<span class="token punctuation">)</span><span class="token punctuation">{</span>
         <span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;</span> high<span class="token punctuation">)</span>
         <span class="token punctuation">{</span>
             <span class="token comment" spellcheck="true">//递归待排序序列长度大于7时用快速排序</span>
             pivot <span class="token operator">=</span> <span class="token function">Partition</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//把array[low..high]一分为二，小的在左边，大的在右边，返回基准数所在的位置</span>
             <span class="token function">QuickSort</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> low<span class="token punctuation">,</span> pivot <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
             low <span class="token operator">=</span> pivot <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
         <span class="token punctuation">}</span>
     <span class="token punctuation">}</span>
     <span class="token keyword">else</span>
     <span class="token punctuation">{</span>
         <span class="token comment" spellcheck="true">//递归待排序序列长度小于等于7时用快速排序</span>
         <span class="token function">InsertSort</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
将<code>low=pivot+1</code>后，再循环来一次<code>pivot = Partition(array, low, high);</code>，其实就是<code>pivot = Partition(array, pivot+1, high);</code>，与<code>QuickSort(array, pivot + 1, high);</code>是同样的效果，因为QuickSort本来做的就是Partition操作。但是使用循环减少了一个递归调用，从而减少了堆栈带来的开销，提高了性能。</li>
</ol>
<hr>
<p><font size="5" color="orange">7种排序算法的时间复杂度和空间复杂度的比较</font><br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/ImprovedSort30.png?raw=true" alt></p>

            </div>

            <!-- Post Comments -->
            
    <!-- 使用 DISQUS_CLICK -->
<div id="disqus-comment">
    <div id="disqus_thread"></div>

<!-- add animation -->
<style>
	.disqus_click_btn {
            line-height: 30px;
            margin: 0;
            min-width: 50px;
            padding: 0 14px;
            display: inline-block;
            font-family: "Roboto", "Helvetica", "Arial", sans-serif;
            font-size: 14px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0;
            overflow: hidden;
            will-change: box-shadow;
            transition: box-shadow .2s cubic-bezier(.4, 0, 1, 1), background-color .2s cubic-bezier(.4, 0, .2, 1), color .2s cubic-bezier(.4, 0, .2, 1);
            outline: 0;
            cursor: pointer;
            text-decoration: none;
            text-align: center;
            vertical-align: middle;
            border: 0;
            background: rgba(158, 158, 158, .2);
            box-shadow: 0 2px 2px 0 rgba(0, 0, 0, .14), 0 3px 1px -2px rgba(0, 0, 0, .2), 0 1px 5px 0 rgba(0, 0, 0, .12);
            color: #fff;
            background-color: #7EC0EE;
            text-shadow: 0
        }
</style>
	
<div class="btn_click_load" id="disqus_bt"> 
    <button class="disqus_click_btn">点击查看评论</button>
</div>

<!--
<script type="text/javascript">
$('.btn_click_load').click(function() {
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'http-miccall-tech'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    document.getElementById('disqus_bt').style.display = "none";
});
</script>
-->
<script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://yoursite.com/2016/09/03/改进排序/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = 'http://yoursite.com/2016/09/03/改进排序/'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
</script>

<script type="text/javascript">
    $('.btn_click_load').click(function() {  //click to load comments
        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document;
            var s = d.createElement('script');
            s.src = '//http-miccall-tech.disqus.com/embed.js';
            s.setAttribute('data-timestamp', + new Date());
            (d.head || d.body).appendChild(s);
        })();
        $('.btn_click_load').css('display','none');
    });
</script>
</div>
<style>
    #disqus-comment{
        background-color: #eee;
        padding: 2pc;
    }
</style>


        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
                <li>Design: <a href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
            </ul>
            
            	<span id="busuanzi_container_site_pv">2019总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			
        </div>
    </div>
</body>



 	
</html>
