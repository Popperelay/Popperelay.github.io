<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>数据结构与算法之二叉树 | Elays&#39;Blog</title>
  <meta name="author" content="Elay">
  
  <meta name="description" content="Elay">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="数据结构与算法之二叉树"/>
  <meta property="og:site_name" content="Elays&#39;Blog"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Elays&#39;Blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">Elays&#39;Blog</a></h1>
  <h2><a href="/">你是天地生的，美得超越人形</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">主页</a></li>
    
      <li><a href="/archives">所有文章</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-08-31T19:14:11.000Z"><a href="/2016/09/01/二叉树/">2016-09-01</a></time>
      
      
  
    <h1 class="title">数据结构与算法之二叉树</h1>
  

    </header>
    <div class="entry">
      
        <p><font size="4" color="orange">先来看几个二叉树的特点和概念：</font><br><a id="more"></a></p>
<ul>
<li>二叉树：<ul>
<li>二叉树的左子树和右子树是有顺序的，是有序树。</li>
<li>任意一颗二叉树的：叶子数=2度结点数+1</li>
</ul>
</li>
<li>满二叉树：每个分支结点都有左儿子和右儿子，且所有叶子结点位于同一层。如下图：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721608568.png" alt=""></li>
<li>完全二叉树：按层序编号后，对应结点编号和满二叉树完全相同(完全二叉树的结点数&lt;=满二叉树的结点数)。如下图：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/14772160862.png" alt=""><ul>
<li>所以，判断某二叉树是否是完全二叉树的方法：看着树的示意图，按照完全二叉树的结构逐层按顺序编号，如果编号出现空挡，则不是完全二叉树。</li>
<li>同样结点的二叉树，完全二叉树的深度最小</li>
<li>具有n个结点的完全二叉树的深度为：<img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721608663.png" alt=""></li>
<li>对具有n个结点的完全二叉树【前提条件是2i和2i+1均小于n】：<br>左孩子跟双亲满足关系：2i&lt;=&gt;i<br>右孩子跟双亲满足关系：2i+1&lt;=&gt;i</li>
</ul>
</li>
</ul>
<hr>
<p><font size="4" color="orange">顺序二叉树</font><br>任何一颗二叉树的顺序存储都是按其对应的完全二叉树的编号来的，当出现大量空挡(比如右倾斜树)时，会浪费很多存储空间，所以顺序存储一般只用于完全二叉树。<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721608712.png" alt=""></p>
<hr>
<p><font size="4" color="orange">链表二叉树</font></p>
<ul>
<li>链表二叉树的数据结构：结点类+树(类)<br>结点类由三个数据成员组成：结点数据、左儿子、右儿子<br>树(类)主要由一个数据成员组成：根结点</li>
<li>建立二叉树<br>要建立一颗二叉树，这棵二叉树应该是已经确定好的，而且需要事先知道该二叉树的前序序列(或中序序列、后序序列)。并且为了确认每一个结点是否有左右孩子，需要将原二叉树进行扩展，也就是将每个二叉树结点内的空指针用一个虚结点代替(假定虚结点数据为#)，得到一颗扩展二叉树。由扩展二叉树得到的前序序列称为完全前序序列。如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721608763.png" alt=""><br>上图的完全前序序列为：AB#D##C##，输入已知的完全前序序列，便能通过<code>CreateBinaryTree()</code>函数来建立该二叉树。代码见后面。</li>
<li>遍历二叉树<br>二叉树的遍历是从根节点开始的。按照根结点访问次序的不同，分为三种遍历方式：前序遍历、中序遍历、后序遍历，另外还有一种层序遍历。<ul>
<li>前序遍历：先根再左再右<br>遍历规则：若结点为空，则返回，否则先访问根结点，再访问左子树，再访问右子树。如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721608816.png" alt=""><br>遍历的顺序(前序序列)为：ABDGHCEIF</li>
<li>中序遍历：先左再根再右<br>遍历规则：若结点为空，则返回，否则先访问左子树，再访问根结点，再访问右子树。如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721608869.png" alt=""><br>遍历的顺序(中序序列)为：GDHBAEICF</li>
<li>后序遍历：先左再右再根<br>遍历规则：若结点为空，则返回，否则先访问根结点，再访问左子树，再访问右子树。如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721608928.png" alt=""><br>遍历的顺序(后序序列)为：GHDBIEFCA</li>
<li>层序遍历：按层从左到右访问结点<br>如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721608989.png" alt=""><br>遍历的顺序(层序序列)为：ABCDEFGHI</li>
</ul>
</li>
</ul>
<p>上面得到的各种遍历序列可以用来创建二叉树，当然也可以根据各种遍历方法来遍历已经创建好的二叉树，前序、中序、后序遍历的代码见后面。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BinaryTreeNode</span> &#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">object</span> Data;</div><div class="line">    <span class="keyword">public</span> BinaryTreeNode LeftChild;</div><div class="line">    <span class="keyword">public</span> BinaryTreeNode RightChild;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinaryTreeNode</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        Data = <span class="literal">null</span>;</div><div class="line">        LeftChild = <span class="literal">null</span>;</div><div class="line">        RightChild = <span class="literal">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinaryTreeNode</span>(<span class="params"><span class="keyword">object</span> data</span>) </span>&#123;</div><div class="line">        Data = data;</div><div class="line">        LeftChild = <span class="literal">null</span>;</div><div class="line">        RightChild = <span class="literal">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">class</span> <span class="title">BinaryTree</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">public</span> BinaryTreeNode root;</div><div class="line"></div><div class="line">    <span class="comment">//按前序序列建立二叉树(中序、后序建立的代码类似)</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CreateBinaryTree</span>(<span class="params"><span class="keyword">ref</span> BinaryTreeNode root</span>) </span>&#123;</div><div class="line">        <span class="keyword">object</span> data;</div><div class="line">        data=Console.ReadLine();</div><div class="line">        <span class="keyword">if</span> (data.Equals(<span class="string">"#"</span>)) &#123;</div><div class="line">            root = <span class="literal">null</span>;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        root = <span class="keyword">new</span> BinaryTreeNode(data);</div><div class="line">        CreateBinaryTree(<span class="keyword">ref</span> root.LeftChild);</div><div class="line">        CreateBinaryTree(<span class="keyword">ref</span> root.RightChild);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//前序遍历二叉树(中序、后序遍历的代码类似）</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PreOrderTraverse</span>(<span class="params">BinaryTreeNode root</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        Console.Write(root.Data+<span class="string">" "</span>);</div><div class="line">        PreOrderTraverse(root.LeftChild);</div><div class="line">        PreOrderTraverse(root.RightChild);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//中序遍历二叉树</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InOrderTraverse</span>(<span class="params">BinaryTreeNode root</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        InOrderTraverse(root.LeftChild);</div><div class="line">        Console.Write(root.Data + <span class="string">" "</span>);</div><div class="line">        InOrderTraverse(root.RightChild);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//后序遍历二叉树</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PostOrderTraverse</span>(<span class="params">BinaryTreeNode root</span>)</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        PostOrderTraverse(root.LeftChild);</div><div class="line">        PostOrderTraverse(root.RightChild);</div><div class="line">        Console.Write(root.Data + <span class="string">" "</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<p><font size="4" color="orange">二叉树前序、中序、后序序列的推导</font></p>
<ul>
<li>小技巧：推导一棵树的前序、中序、后序序列时，可以想着对应的递归代码来推导，不容易出错。</li>
<li>已知前序序列和中序序列，推导后序序列：<br>把握两个关键点：前序、后序序列用于确定树或子树的根结点是谁，而中序序列用于确定哪些结点位于根节点左边，哪些结点位于根节点右边。<br>如：已知一颗二叉树前序序列为ABCDEF，中序序列为CBAEDF，求后序序列：<ol>
<li>根据前序序列ABCDEF可知，结点A为树的根结点(最前面的是根结点)，再由中序序列CBAEDF可知结点CB位于A的左边，结点EDF位于A的右边。如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721608989.png" alt=""></li>
<li>由前序序列中的BC可知，在BC子树中，B是根结点(最前面的是根节点)。又由中序序列的CB可知C应该位于B的左边。如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721609085.png" alt=""></li>
<li>由前序序列的DEF可知，在DEF子树中，D是根结点(最前面的是根结点)。又由中序序列的EDF可知E位于D的左边，F位于D的右边。如下图：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721609136.png" alt=""></li>
</ol>
</li>
<li>已知后序序列和中序序列，推导前序序列：<br>唯一的不同之处在于：如上面的第1、2、3步，在前序序列(先根再左再右)中，最前面的是根节点，而在后序序列(先左再右再根)中最后的才是根结点。</li>
<li>已知前序序列和后序序列，是无法唯一确定一颗二叉树的。原因很简单，因为没有中序序列，无法确定哪些结点位于根结点左边，哪些结点位于根结点右边。</li>
<li>【注】：不画出二叉树也可以很快推导对应序列。<strong>关键点在于：由前序或后序来确定根结点，由中序来确定哪些结点位于根结点左边，哪些结点位于根结点右边</strong>。如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147728182152.jpg" alt=""></li>
</ul>
<hr>
<p><font size="4" color="orange">线索二叉树</font></p>
<ul>
<li>在扩展二叉树里面，我们就已经看到一颗二叉树里其实还留有很多空引用(指针)，主要来源于叶子结点和单分支结点(1度结点)。</li>
<li>在链表二叉树里面，我们只能直接知道结点的左右儿子是谁，而如果要知道某个结点在对应序列中的前驱和后继是谁，就必须得重新遍历一次。</li>
<li>其实可以考虑把那些空引用用来存储结点的前驱和后继。更巧的是，一颗二叉树中的空引用数目和所有结点的前驱后继总数刚好相等。</li>
</ul>
<p>我们把这种指向前驱和后继的引用称为线索，加上线索的二叉树便成了线索二叉树。所以线索化的实质就是将链表二叉树中的空引用利用起来，去指向结点的前驱和后继。如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721609189.png" alt=""><br>将该二叉树线索化后：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148930902158.png" alt=""><br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721609243.png" alt=""><br>仔细观察会发现线索化后的二叉树其实就是一个双向链表，如下图：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721609297.png" alt=""><br>既然是双向链表，那么可以给它加上一个头结点，方便我们既可以从第一个结点沿着后继进行遍历，也可以从最后一个结点沿着前驱进行遍历。</p>
<p>还有一个问题，原来的空引用变成了前驱和后继，那么怎么和原来那些指向左右儿子的非空引用区别开来呢？这时我们需要两个标志位，来分别标识两个引用到底是指向左右儿子还是作为前驱后继：ltag为0时表示指向结点的左儿子，为1时表示指向结点的前驱；rtag为0时表示指向结点的右儿子，为1时表示指向结点的后继。如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721609351.png" alt=""><br>线索二叉树的数据结构：<br>和二叉树的数据结构类似，只是结点类增加了两个数据成员：ltag、rtag。</p>
<p>可以在前序遍历的过程中就实现线索化。<br>由于线索二叉树其实是一个双向链表，所以可以按照链表的遍历方式来遍历线索二叉树了，省去了递归的大量开销。代码中的<code>CluePreOrderTraverse()</code>函数其实是模拟了二叉树的前序遍历，先一直向左，再向右，利用RightChild访问到下一个序列结点。可参考线索二叉树标题下的第一幅图（有后继的那幅图）。<br>部分代码如下：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> <span class="title">ClueBinaryTreeNode</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">object</span> Data;</div><div class="line">    <span class="keyword">public</span> ClueBinaryTreeNode LeftChild;</div><div class="line">    <span class="keyword">public</span> ClueBinaryTreeNode RightChild;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> LeftTag;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> RightTag;</div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"><span class="keyword">class</span> <span class="title">ClueBinaryTree</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">public</span> ClueBinaryTreeNode first;</div><div class="line">    <span class="comment">//全局变量，指向刚刚访问过的结点</span></div><div class="line">    ClueBinaryTreeNode pre;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClueBinaryTree</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        first = <span class="keyword">new</span> ClueBinaryTreeNode();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//前序遍历过程中实现线索化</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraverse</span>(<span class="params">ClueBinaryTreeNode root</span>)</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        <span class="comment">//设置当前结点的前驱</span></div><div class="line">        <span class="keyword">if</span> (root.LeftChild == <span class="literal">null</span>)</div><div class="line">        &#123;</div><div class="line">            root.LeftTag = <span class="number">1</span>;</div><div class="line">            root.LeftChild = pre;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//设置前驱结点的后继为当前结点</span></div><div class="line">        <span class="keyword">if</span> (pre.RightChild == <span class="literal">null</span>) &#123;</div><div class="line">            pre.RightTag = <span class="number">1</span>;</div><div class="line">            pre.RightChild = root;</div><div class="line">        &#125;</div><div class="line">        pre = root;</div><div class="line">        PreOrderTraverse(root.LeftChild);</div><div class="line">        PreOrderTraverse(root.RightChild);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//用双向链表的方式来遍历线索二叉树</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CluePreOrderTraverse</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        ClueBinaryTreeNode current;</div><div class="line">        current = first.LeftChild;</div><div class="line">        <span class="keyword">while</span> (current != first) &#123;</div><div class="line">            <span class="keyword">while</span> (current.LeftTag == <span class="number">0</span>) &#123;</div><div class="line">                current = current.LeftChild;</div><div class="line">            &#125;</div><div class="line">            Console.WriteLine(current.Data);</div><div class="line">            <span class="keyword">while</span> (current.RightTag == <span class="number">1</span> &amp;&amp; current.RightChild != first) &#123;</div><div class="line">                current = current.RightChild;</div><div class="line">                Console.WriteLine(current.Data);</div><div class="line">            &#125;</div><div class="line">            current = current.RightChild;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<p><font size="4" color="orange">树、森林与二叉树的转换</font></p>
<ul>
<li>树转换为二叉树<ol>
<li>兄弟加线：在所有兄弟之间加一条连线</li>
<li>非长子去线：对树中每个结点，只保留它与第一个孩子结点的连线，删除它与其他孩子结点之间的连线</li>
<li>层次调整：以树和子树的根结点为轴心，将整棵树顺时针旋转一定的角度，使之结构层次分明。【注意第一个孩子是二叉树结点的左孩子，兄弟转换过来的孩子是结点的右孩子】<br>如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721609411.png" alt=""></li>
</ol>
</li>
<li><p>森林转换为二叉树：每棵树的根结点依次作为右兄弟</p>
<ol>
<li>把每个树转换为二叉树</li>
<li>把后一棵二叉树的根结点作为右孩子连到前一棵二叉树的根结点上。再调整层成层次分明的二叉树</li>
</ol>
<p>如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721609473.png" alt=""></p>
</li>
<li><p>二叉树转换为树</p>
<ol>
<li>加线：二叉树及其所有子树的根结点与它的长子的右孩子加线</li>
<li>去线：删除<strong>原</strong>二叉树中所有结点与其右孩子结点的连线</li>
<li>层次调整，使其结构层次分明</li>
</ol>
<p>如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/14772160953.png" alt=""></p>
</li>
<li><p>二叉树转换为森林(森林到二叉树的逆转换)</p>
<ol>
<li>首先要判断一棵二叉树能否转换成森林，需要看二叉树的根结点是否有右孩子，如果有则删掉与右孩子的连线。一直进行下去，直到分离的所有二叉树根结点与右孩子的连线都删除为止</li>
<li>将每棵分离的二叉树转换为树</li>
</ol>
<p>如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721609594.png" alt=""></p>
</li>
</ul>
<hr>
<p><font size="4" color="orange">二叉树的应用之哈夫曼树</font><br>树的带权路径长度WPL：树中所有叶子结点的权值乘以路径长度的和。<br>带权路径长度WPL最小的二叉树称为哈夫曼树。哈夫曼树又称带权最优二叉树。</p>
<ul>
<li>求解哈夫曼树的方法：</li>
</ul>
<ol>
<li>把所有带权值得叶子节点排成一个序列</li>
<li>取出权值最小的两个加起来，作为新结点，加入到序列中(取出的两个结点报废)，并在对应哈夫曼树的结构图作为取出的两个结点的双亲结点</li>
<li>重复第二步，直到序列中不再有结点为止</li>
</ol>
<p>假设六个字母的频率为A 27，B 8，C 15，D 15，E 30，F 5，则由它们构成的哈夫曼树如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721609648.png" alt=""><br>规定哈夫曼树的左分支代表0，右分支代表1，则从叶子结点到根结点的01序列就是对应字符的<strong>哈夫曼编码</strong>。</p>

      
    </div>
    <footer>
      
        
  
  <div class="categories">
    <a href="/categories/数据结构/">数据结构</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/二叉树/">二叉树</a>
  </div>

        
  <div class="addthis addthis_toolbox addthis_default_style">
    
      <a class="addthis_button_facebook_like" fb:like:layout="button_count"></a>
    
    
      <a class="addthis_button_tweet"></a>
    
    
      <a class="addthis_button_google_plusone" g:plusone:size="medium"></a>
    
    
      <a class="addthis_button_pinterest_pinit" pi:pinit:layout="horizontal"></a>
    
    <a class="addthis_counter addthis_pill_style"></a>
  </div>
  <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js"></script>

      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


<section id="comment">
  <h2 class="title">留言</h2>


 
  	   <!-- 多说评论框 start -->
 		<div class="ds-thread" data-thread-key="2016/09/01/二叉树/" data-title="数据结构与算法之二叉树" data-url="http://yoursite.com/2016/09/01/二叉树/"></div>
		<!-- 多说评论框 end -->
		<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
		<script type="text/javascript">
		var duoshuoQuery = {short_name:"popperelay"};   <!-- 替换这里的duoshuo_shortname为前面注册的shortname -->
			(function() {
				var ds = document.createElement('script');
				ds.type = 'text/javascript';ds.async = true;
				ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.unstable.js';
				ds.charset = 'UTF-8';
				(document.getElementsByTagName('head')[0] 
				 || document.getElementsByTagName('body')[0]).appendChild(ds);
			})();
			</script>
		<!-- 多说公共JS代码 end -->
 
  
</section>

</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:yoursite.com">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/C-语法/">C#语法</a><small>2</small></li>
  
    <li><a href="/categories/C/">C++</a><small>2</small></li>
  
    <li><a href="/categories/C语言/">C语言</a><small>1</small></li>
  
    <li><a href="/categories/OpenGL/">OpenGL</a><small>23</small></li>
  
    <li><a href="/categories/博客配置/">博客配置</a><small>3</small></li>
  
    <li><a href="/categories/操作系统/">操作系统</a><small>4</small></li>
  
    <li><a href="/categories/数据结构/">数据结构</a><small>15</small></li>
  
    <li><a href="/categories/游戏开发/">游戏开发</a><small>1</small></li>
  
    <li><a href="/categories/计算机图形学/">计算机图形学</a><small>2</small></li>
  
    <li><a href="/categories/调试错误集锦/">调试错误集锦</a><small>1</small></li>
  
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/BIOS和微机启动过程/">BIOS和微机启动过程</a><small>1</small></li>
  
    <li><a href="/tags/C/">C</a><small>1</small></li>
  
    <li><a href="/tags/C-容器/">C#容器</a><small>1</small></li>
  
    <li><a href="/tags/C-IO/">C++IO</a><small>1</small></li>
  
    <li><a href="/tags/MarkDown/">MarkDown</a><small>1</small></li>
  
    <li><a href="/tags/Mathjax语法/">Mathjax语法</a><small>1</small></li>
  
    <li><a href="/tags/OS内核/">OS内核</a><small>1</small></li>
  
    <li><a href="/tags/OpenGL坐标系统/">OpenGL坐标系统</a><small>1</small></li>
  
    <li><a href="/tags/OpenGL摄像机/">OpenGL摄像机</a><small>1</small></li>
  
    <li><a href="/tags/OpenGL窗口/">OpenGL窗口</a><small>1</small></li>
  
    <li><a href="/tags/OpenGL配置/">OpenGL配置</a><small>1</small></li>
  
    <li><a href="/tags/timeTest/">timeTest</a><small>1</small></li>
  
    <li><a href="/tags/二叉树/">二叉树</a><small>1</small></li>
  
    <li><a href="/tags/光照场景/">光照场景</a><small>1</small></li>
  
    <li><a href="/tags/光照贴图/">光照贴图</a><small>1</small></li>
  
    <li><a href="/tags/关键路径/">关键路径</a><small>1</small></li>
  
    <li><a href="/tags/冯氏光照/">冯氏光照</a><small>1</small></li>
  
    <li><a href="/tags/几何着色器/">几何着色器</a><small>1</small></li>
  
    <li><a href="/tags/反走样/">反走样</a><small>1</small></li>
  
    <li><a href="/tags/图/">图</a><small>1</small></li>
  
    <li><a href="/tags/图形学概述/">图形学概述</a><small>1</small></li>
  
    <li><a href="/tags/图形显示系统/">图形显示系统</a><small>1</small></li>
  
    <li><a href="/tags/多说/">多说</a><small>1</small></li>
  
    <li><a href="/tags/天空盒子/">天空盒子</a><small>1</small></li>
  
    <li><a href="/tags/头结点/">头结点</a><small>1</small></li>
  
    <li><a href="/tags/实例化/">实例化</a><small>1</small></li>
  
    <li><a href="/tags/尾递归/">尾递归</a><small>1</small></li>
  
    <li><a href="/tags/帧同步/">帧同步</a><small>1</small></li>
  
    <li><a href="/tags/帧缓冲/">帧缓冲</a><small>1</small></li>
  
    <li><a href="/tags/常见光源/">常见光源</a><small>1</small></li>
  
    <li><a href="/tags/拓扑排序/">拓扑排序</a><small>1</small></li>
  
    <li><a href="/tags/操作系统概述/">操作系统概述</a><small>1</small></li>
  
    <li><a href="/tags/改进排序/">改进排序</a><small>1</small></li>
  
    <li><a href="/tags/文件IO/">文件IO</a><small>1</small></li>
  
    <li><a href="/tags/最小生成树/">最小生成树</a><small>1</small></li>
  
    <li><a href="/tags/最短路径/">最短路径</a><small>1</small></li>
  
    <li><a href="/tags/材质/">材质</a><small>1</small></li>
  
    <li><a href="/tags/查找/">查找</a><small>1</small></li>
  
    <li><a href="/tags/栈/">栈</a><small>1</small></li>
  
    <li><a href="/tags/树/">树</a><small>1</small></li>
  
    <li><a href="/tags/模型加载/">模型加载</a><small>1</small></li>
  
    <li><a href="/tags/模板测试/">模板测试</a><small>1</small></li>
  
    <li><a href="/tags/深度测试/">深度测试</a><small>1</small></li>
  
    <li><a href="/tags/混合/">混合</a><small>1</small></li>
  
    <li><a href="/tags/着色器/">着色器</a><small>1</small></li>
  
    <li><a href="/tags/着色器画三角形/">着色器画三角形</a><small>1</small></li>
  
    <li><a href="/tags/简单排序/">简单排序</a><small>1</small></li>
  
    <li><a href="/tags/纹理/">纹理</a><small>1</small></li>
  
    <li><a href="/tags/缓冲对象/">缓冲对象</a><small>1</small></li>
  
    <li><a href="/tags/背面剔除/">背面剔除</a><small>1</small></li>
  
    <li><a href="/tags/进程的描述与控制/">进程的描述与控制</a><small>1</small></li>
  
    <li><a href="/tags/重定义错误/">重定义错误</a><small>1</small></li>
  
    <li><a href="/tags/链表/">链表</a><small>1</small></li>
  
    <li><a href="/tags/队列/">队列</a><small>1</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2017 Elay
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>


<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</body>
</html>