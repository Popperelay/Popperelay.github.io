<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>数据结构与算法之二叉树 | Elays&#39;Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="先来看几个二叉树的特点和概念：">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构与算法之二叉树">
<meta property="og:url" content="http://yoursite.com/2016/09/01/二叉树/index.html">
<meta property="og:site_name" content="Elays'Blog">
<meta property="og:description" content="先来看几个二叉树的特点和概念：">
<meta property="og:image" content="https://dl81.yunpan.360.cn/intf.php?method=Preview.outputPic&qid=49291271&fname=%2F%E5%9B%BE%E7%89%87%2F%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2FbinaryTree1.png&fhash=ae6af474ad05509b7500c67309d6c2cb91a45330&dt=81.389b9f48fd72ed507a0e2ecde8eb75cd&v=1.0.1&rtick=14725721226636&open_app_id=0&devtype=web&sign=4baefe68b9f382fbd377771aaad3e9af&">
<meta property="og:image" content="https://dl81.yunpan.360.cn/intf.php?method=Preview.outputPic&qid=49291271&fname=%2F%E5%9B%BE%E7%89%87%2F%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2FbinaryTree2.png&fhash=a88ea055c79a0ce6d5039347c30b5958b2c9eda7&dt=81.cba2cb3d41748322e6cee9f597c7b1b8&v=1.0.1&rtick=14725721228302&open_app_id=0&devtype=web&sign=3f3497ef115f5927c2a7ffc554afa523&">
<meta property="og:image" content="https://dl81.yunpan.360.cn/intf.php?method=Preview.outputPic&qid=49291271&fname=%2F%E5%9B%BE%E7%89%87%2F%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2FbinaryTree3.png&fhash=9dc21d54d9ff216cfd6674f77fe1102b6ec706c6&dt=81.c173a905d64d586f932708e50dd38ff8&v=1.0.1&rtick=14726427793760&open_app_id=0&devtype=web&sign=94144072204dc52b9628f51db4ae9fa0&">
<meta property="og:image" content="https://dl81.yunpan.360.cn/intf.php?method=Preview.outputPic&qid=49291271&fname=%2F%E5%9B%BE%E7%89%87%2F%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2FbinaryTree4.png&fhash=cecc26cab7d63697dcd9583d819fc89bca49a1a8&dt=81.309b5b8a3f9a983b12f0981e92ed65ad&v=1.0.1&rtick=14726445975555&open_app_id=0&devtype=web&sign=0a6bc6edb0dacb8df83b15287a4820a5&">
<meta property="og:image" content="https://dl81.yunpan.360.cn/intf.php?method=Preview.outputPic&qid=49291271&fname=%2F%E5%9B%BE%E7%89%87%2F%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2FbinaryTree5.png&fhash=66d647153088f221a0c5b7b08907d8d72a55e5d0&dt=81.a705a22a36246d98449295c6bd820c49&v=1.0.1&rtick=14726522797943&open_app_id=0&devtype=web&sign=10e0676b38b818fb11d3d71821afb7c7&">
<meta property="og:image" content="https://dl81.yunpan.360.cn/intf.php?method=Preview.outputPic&qid=49291271&fname=%2F%E5%9B%BE%E7%89%87%2F%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2FbinaryTree6.png&fhash=e81ca8766612b65dbfddf345e4f5141efbde56b6&dt=81.0971dc1e85d521523df02feaf234bc92&v=1.0.1&rtick=14726533075393&open_app_id=0&devtype=web&sign=9cef66c87c01795a095751e5da85f49c&">
<meta property="og:image" content="https://dl81.yunpan.360.cn/intf.php?method=Preview.outputPic&qid=49291271&fname=%2F%E5%9B%BE%E7%89%87%2F%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2FbinaryTree7.png&fhash=0f43440b9066a8e9992057a0f182700c82cbfbd8&dt=81.616453b2068ee277f209a8474487b934&v=1.0.1&rtick=14726533076126&open_app_id=0&devtype=web&sign=89aa0e25eec8587edcd1ef4be0d543ba&">
<meta property="og:image" content="https://dl81.yunpan.360.cn/intf.php?method=Preview.outputPic&qid=49291271&fname=%2F%E5%9B%BE%E7%89%87%2F%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2FbinaryTree8.png&fhash=b6eb8cf5e637cae837cfee62747e39f3a3b84fe6&dt=81.a8acdddfab8f241d0d753b51f3c6b971&v=1.0.1&rtick=14726533078719&open_app_id=0&devtype=web&sign=636545b41ec6b066ca10879eba505288&">
<meta property="og:image" content="https://dl81.yunpan.360.cn/intf.php?method=Preview.outputPic&qid=49291271&fname=%2F%E5%9B%BE%E7%89%87%2F%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2FbinaryTree9.png&fhash=1b9d110be40caad4ebe15c0e1f10a02692c5bacd&dt=81.0483ac2e1d2a1277204cc4d70cc55286&v=1.0.1&rtick=14726533073939&open_app_id=0&devtype=web&sign=148b9250f3faa9f4fc7d6f0cbdac082c&">
<meta property="og:image" content="https://dl81.yunpan.360.cn/intf.php?method=Preview.outputPic&qid=49291271&fname=%2F%E5%9B%BE%E7%89%87%2F%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2FbinaryTree10.png&fhash=842ade31e48226060497fce21b5201e3fc835247&dt=81.20fa9b0aefa0f380c4e8bb11785fcb8f&v=1.0.1&rtick=14726598961342&open_app_id=0&devtype=web&sign=dd3f5971c5d794b82b4368125cd00f2b&">
<meta property="og:image" content="https://dl81.yunpan.360.cn/intf.php?method=Preview.outputPic&qid=49291271&fname=%2F%E5%9B%BE%E7%89%87%2F%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2FbinaryTree11.png&fhash=84d58a1ce23c6c98f892420a209a9ab7000ce8a0&dt=81.966c97d9713adc619388c7fd72cb5e9e&v=1.0.1&rtick=14726598966773&open_app_id=0&devtype=web&sign=a74101bee1fb33ca94467b67fd8c1a83&">
<meta property="og:image" content="https://dl81.yunpan.360.cn/intf.php?method=Preview.outputPic&qid=49291271&fname=%2F%E5%9B%BE%E7%89%87%2F%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2FbinaryTree12.png&fhash=83faada51b3fae91b3721c7054f690358954e7a8&dt=81.4571adcf48c0bc03f9ef0708bee2405d&v=1.0.1&rtick=14726598968183&open_app_id=0&devtype=web&sign=11a5904fec1136937ecc8e97d092888d&">
<meta property="og:image" content="https://dl81.yunpan.360.cn/intf.php?method=Preview.outputPic&qid=49291271&fname=%2F%E5%9B%BE%E7%89%87%2F%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2FbinaryTree13.png&fhash=f7ffc4c59ed30a83237a78e898eba09393ad11f5&dt=81.9238bd2dda110d576869de6016234618&v=1.0.1&rtick=14726638311039&open_app_id=0&devtype=web&sign=e598f76f91c73c4bf72169e80ad1756f&">
<meta property="og:image" content="https://dl81.yunpan.360.cn/intf.php?method=Preview.outputPic&qid=49291271&fname=%2F%E5%9B%BE%E7%89%87%2F%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2FbinaryTree14.png&fhash=e5cda62bbd51c3132871c8362685a501e9a58411&dt=81.5101541f4c3bb6cef0d0f90b9dd04763&v=1.0.1&rtick=14726638312176&open_app_id=0&devtype=web&sign=ced08191e3481e4e1c38e150deff4027&">
<meta property="og:image" content="https://dl81.yunpan.360.cn/intf.php?method=Preview.outputPic&qid=49291271&fname=%2F%E5%9B%BE%E7%89%87%2F%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2FbinaryTree15.png&fhash=5f837d7836d15c2f48138d7adfc0d7f9a266765b&dt=81.0ece6197a1d261f4373c2a52679b4e60&v=1.0.1&rtick=14726638313932&open_app_id=0&devtype=web&sign=870e45a9e10a58d67899914d7c0b1825&">
<meta property="og:image" content="https://dl81.yunpan.360.cn/intf.php?method=Preview.outputPic&qid=49291271&fname=%2F%E5%9B%BE%E7%89%87%2F%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2FbinaryTree16.png&fhash=5d518195ef98a770701856e9004044e3b91fc893&dt=81.8032ba17646bf7d059304a0ce414a7a0&v=1.0.1&rtick=14726638319924&open_app_id=0&devtype=web&sign=d51798f5dd8d81445eee7c15ad3bbc77&">
<meta property="og:image" content="https://dl81.yunpan.360.cn/intf.php?method=Preview.outputPic&qid=49291271&fname=%2F%E5%9B%BE%E7%89%87%2F%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2FbinaryTree17.png&fhash=034921202954073c93bd35c0f66184893a09c477&dt=81.e3a159f0eec2f11f4c4161bba7328708&v=1.0.1&rtick=14726674602634&open_app_id=0&devtype=web&sign=5d47fb585d57f0decc64890d826af7fc&">
<meta property="og:image" content="https://dl81.yunpan.360.cn/intf.php?method=Preview.outputPic&qid=49291271&fname=%2F%E5%9B%BE%E7%89%87%2F%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2FbinaryTree18.png&fhash=9168be34c06a8f130cbe3ad71b4dfeeac88c6c97&dt=81.ce857814b066b30209911c45012241f1&v=1.0.1&rtick=14726678561356&open_app_id=0&devtype=web&sign=03d9bf239379d50b769d22ab627b60aa&">
<meta property="og:image" content="https://dl81.yunpan.360.cn/intf.php?method=Preview.outputPic&qid=49291271&fname=%2F%E5%9B%BE%E7%89%87%2F%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2FbinaryTree19.png&fhash=69a4b5875517a37935b2c8ccdb9fe8c81f765935&dt=81.0d48e7f804a0011eb56583be94e2ad9d&v=1.0.1&rtick=14726678569718&open_app_id=0&devtype=web&sign=bc9363d50f8cf5262fdb89059bdc7189&">
<meta property="og:image" content="https://dl81.yunpan.360.cn/intf.php?method=Preview.outputPic&qid=49291271&fname=%2F%E5%9B%BE%E7%89%87%2F%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2FbinaryTree21.png&fhash=afb5c418afb6f553b11126b22fa85b8819d66064&dt=81.2227154ed1b4b4cd17c73aec182349d3&v=1.0.1&rtick=14726704773865&open_app_id=0&devtype=web&sign=a9d2e52aa0996fbce7a617bd26fcbae5&">
<meta property="og:updated_time" content="2016-08-31T19:23:50.295Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="数据结构与算法之二叉树">
<meta name="twitter:description" content="先来看几个二叉树的特点和概念：">
<meta name="twitter:image" content="https://dl81.yunpan.360.cn/intf.php?method=Preview.outputPic&qid=49291271&fname=%2F%E5%9B%BE%E7%89%87%2F%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2FbinaryTree1.png&fhash=ae6af474ad05509b7500c67309d6c2cb91a45330&dt=81.389b9f48fd72ed507a0e2ecde8eb75cd&v=1.0.1&rtick=14725721226636&open_app_id=0&devtype=web&sign=4baefe68b9f382fbd377771aaad3e9af&">
  
    <link rel="alternate" href="/atom.xml" title="Elays&#39;Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Elays&#39;Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">你是天地生的，美得超越人形</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-二叉树" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/01/二叉树/" class="article-date">
  <time datetime="2016-08-31T19:14:11.000Z" itemprop="datePublished">2016-09-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/数据结构/">数据结构</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      数据结构与算法之二叉树
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><font size="4" color="orange">先来看几个二叉树的特点和概念：</font><br><a id="more"></a></p>
<ul>
<li>二叉树：<ul>
<li>二叉树的左子树和右子树是有顺序的，是有序树。</li>
<li>任意一颗二叉树的：叶子树=2度结点数+1</li>
</ul>
</li>
<li>满二叉树：每个分支结点都有左儿子和右儿子，且所有叶子结点位于同一层。如下图：<br><img src="https://dl81.yunpan.360.cn/intf.php?method=Preview.outputPic&amp;qid=49291271&amp;fname=%2F%E5%9B%BE%E7%89%87%2F%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2FbinaryTree1.png&amp;fhash=ae6af474ad05509b7500c67309d6c2cb91a45330&amp;dt=81.389b9f48fd72ed507a0e2ecde8eb75cd&amp;v=1.0.1&amp;rtick=14725721226636&amp;open_app_id=0&amp;devtype=web&amp;sign=4baefe68b9f382fbd377771aaad3e9af&amp;" alt=""></li>
<li>完全二叉树：按层序编号后，对应结点编号和满二叉树完全相同(完全二叉树的结点数&lt;=满二叉树的结点数)。如下图：<br><img src="https://dl81.yunpan.360.cn/intf.php?method=Preview.outputPic&amp;qid=49291271&amp;fname=%2F%E5%9B%BE%E7%89%87%2F%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2FbinaryTree2.png&amp;fhash=a88ea055c79a0ce6d5039347c30b5958b2c9eda7&amp;dt=81.cba2cb3d41748322e6cee9f597c7b1b8&amp;v=1.0.1&amp;rtick=14725721228302&amp;open_app_id=0&amp;devtype=web&amp;sign=3f3497ef115f5927c2a7ffc554afa523&amp;" alt=""><ul>
<li>所以，判断某二叉树是否是完全二叉树的方法：看着树的示意图，按照完全二叉树的结构逐层按顺序编号，如果编号出现空挡，则不是完全二叉树。</li>
<li>同样结点的二叉树，完全二叉树的深度最小</li>
<li>具有n个结点的完全二叉树的深度为：<img src="https://dl81.yunpan.360.cn/intf.php?method=Preview.outputPic&amp;qid=49291271&amp;fname=%2F%E5%9B%BE%E7%89%87%2F%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2FbinaryTree3.png&amp;fhash=9dc21d54d9ff216cfd6674f77fe1102b6ec706c6&amp;dt=81.c173a905d64d586f932708e50dd38ff8&amp;v=1.0.1&amp;rtick=14726427793760&amp;open_app_id=0&amp;devtype=web&amp;sign=94144072204dc52b9628f51db4ae9fa0&amp;" alt=""></li>
<li>对具有n个结点的完全二叉树【前提条件是2i和2i+1均小于n】：<br>左孩子跟双亲满足关系：2i&lt;=&gt;i<br>右孩子跟双亲满足关系：2i+1&lt;=&gt;i</li>
</ul>
</li>
</ul>
<hr>
<p><font size="4" color="orange">顺序二叉树</font><br>任何一颗二叉树的顺序存储都是按其对应的完全二叉树的编号来的，当出现大量空挡(比如右倾斜树)时，会浪费很多存储空间，所以顺序存储一般只用于完全二叉树。<br><img src="https://dl81.yunpan.360.cn/intf.php?method=Preview.outputPic&amp;qid=49291271&amp;fname=%2F%E5%9B%BE%E7%89%87%2F%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2FbinaryTree4.png&amp;fhash=cecc26cab7d63697dcd9583d819fc89bca49a1a8&amp;dt=81.309b5b8a3f9a983b12f0981e92ed65ad&amp;v=1.0.1&amp;rtick=14726445975555&amp;open_app_id=0&amp;devtype=web&amp;sign=0a6bc6edb0dacb8df83b15287a4820a5&amp;" alt=""></p>
<hr>
<p><font size="4" color="orange">链表二叉树</font></p>
<ul>
<li>链表二叉树的数据结构：结点类+树(类)<br>结点类由三个数据成员组成：结点数据、左儿子、右儿子<br>树(类)主要由一个数据成员组成：根结点</li>
<li>建立二叉树<br>要建立一颗二叉树，这棵二叉树应该是已经确定好的，而且需要事先知道该二叉树的前序序列(或中序序列、后序序列)。并且为了确认每一个结点是否有左右孩子，需要将原二叉树进行扩展，也就是将每个二叉树结点内的空指针用一个虚结点代替(假定虚结点数据为#)，得到一颗扩展二叉树。由扩展二叉树得到的前序序列称为完全前序序列。如下图所示：<br><img src="https://dl81.yunpan.360.cn/intf.php?method=Preview.outputPic&amp;qid=49291271&amp;fname=%2F%E5%9B%BE%E7%89%87%2F%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2FbinaryTree5.png&amp;fhash=66d647153088f221a0c5b7b08907d8d72a55e5d0&amp;dt=81.a705a22a36246d98449295c6bd820c49&amp;v=1.0.1&amp;rtick=14726522797943&amp;open_app_id=0&amp;devtype=web&amp;sign=10e0676b38b818fb11d3d71821afb7c7&amp;" alt=""><br>上图的完全前序序列为：AB#D##C##，输入已知的完全前序序列，便能通过<code>CreateBinaryTree()</code>函数来建立该二叉树。代码见后面。</li>
<li>遍历二叉树<br>二叉树的遍历是从根节点开始的。按照根结点访问次序的不同，分为三种遍历方式：前序遍历、中序遍历、后序遍历，另外还有一种层序遍历。<ul>
<li>前序遍历：先根再左再右<br>遍历规则：若结点为空，则返回，否则先访问根结点，再访问左子树，再访问右子树。如下图所示：<br><img src="https://dl81.yunpan.360.cn/intf.php?method=Preview.outputPic&amp;qid=49291271&amp;fname=%2F%E5%9B%BE%E7%89%87%2F%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2FbinaryTree6.png&amp;fhash=e81ca8766612b65dbfddf345e4f5141efbde56b6&amp;dt=81.0971dc1e85d521523df02feaf234bc92&amp;v=1.0.1&amp;rtick=14726533075393&amp;open_app_id=0&amp;devtype=web&amp;sign=9cef66c87c01795a095751e5da85f49c&amp;" alt=""><br>遍历的顺序(前序序列)为：ABDGHCEIF</li>
<li>中序遍历：先左再根再右<br>遍历规则：若结点为空，则返回，否则先访问左子树，再访问根结点，再访问右子树。如下图所示：<br><img src="https://dl81.yunpan.360.cn/intf.php?method=Preview.outputPic&amp;qid=49291271&amp;fname=%2F%E5%9B%BE%E7%89%87%2F%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2FbinaryTree7.png&amp;fhash=0f43440b9066a8e9992057a0f182700c82cbfbd8&amp;dt=81.616453b2068ee277f209a8474487b934&amp;v=1.0.1&amp;rtick=14726533076126&amp;open_app_id=0&amp;devtype=web&amp;sign=89aa0e25eec8587edcd1ef4be0d543ba&amp;" alt=""><br>遍历的顺序(中序序列)为：GDHBAEICF</li>
<li>后序遍历：先左再右再根<br>遍历规则：若结点为空，则返回，否则先访问根结点，再访问左子树，再访问右子树。如下图所示：<br><img src="https://dl81.yunpan.360.cn/intf.php?method=Preview.outputPic&amp;qid=49291271&amp;fname=%2F%E5%9B%BE%E7%89%87%2F%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2FbinaryTree8.png&amp;fhash=b6eb8cf5e637cae837cfee62747e39f3a3b84fe6&amp;dt=81.a8acdddfab8f241d0d753b51f3c6b971&amp;v=1.0.1&amp;rtick=14726533078719&amp;open_app_id=0&amp;devtype=web&amp;sign=636545b41ec6b066ca10879eba505288&amp;" alt=""><br>遍历的顺序(后序序列)为：GHDBIEFCA</li>
<li>层序遍历：按层从左到右访问结点<br>如下图所示：<br><img src="https://dl81.yunpan.360.cn/intf.php?method=Preview.outputPic&amp;qid=49291271&amp;fname=%2F%E5%9B%BE%E7%89%87%2F%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2FbinaryTree9.png&amp;fhash=1b9d110be40caad4ebe15c0e1f10a02692c5bacd&amp;dt=81.0483ac2e1d2a1277204cc4d70cc55286&amp;v=1.0.1&amp;rtick=14726533073939&amp;open_app_id=0&amp;devtype=web&amp;sign=148b9250f3faa9f4fc7d6f0cbdac082c&amp;" alt=""><br>遍历的顺序(层序序列)为：ABCDEFGHI</li>
</ul>
</li>
</ul>
<p>上面得到的各种遍历序列可以用来创建二叉树，当然也可以根据各种遍历方法来遍历已经创建好的二叉树，前序、中序、后序遍历的代码见后面。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BinaryTreeNode</span> &#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">object</span> Data;</div><div class="line">    <span class="keyword">public</span> BinaryTreeNode LeftChild;</div><div class="line">    <span class="keyword">public</span> BinaryTreeNode RightChild;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinaryTreeNode</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        Data = <span class="literal">null</span>;</div><div class="line">        LeftChild = <span class="literal">null</span>;</div><div class="line">        RightChild = <span class="literal">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinaryTreeNode</span>(<span class="params"><span class="keyword">object</span> data</span>) </span>&#123;</div><div class="line">        Data = data;</div><div class="line">        LeftChild = <span class="literal">null</span>;</div><div class="line">        RightChild = <span class="literal">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">class</span> <span class="title">BinaryTree</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">public</span> BinaryTreeNode root;</div><div class="line"></div><div class="line">    <span class="comment">//按前序序列建立二叉树(中序、后序建立的代码类似)</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CreateBinaryTree</span>(<span class="params"><span class="keyword">ref</span> BinaryTreeNode root</span>) </span>&#123;</div><div class="line">        <span class="keyword">object</span> data;</div><div class="line">        data=Console.ReadLine();</div><div class="line">        <span class="keyword">if</span> (data.Equals(<span class="string">"#"</span>)) &#123;</div><div class="line">            root = <span class="literal">null</span>;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        root = <span class="keyword">new</span> BinaryTreeNode(data);</div><div class="line">        CreateBinaryTree(<span class="keyword">ref</span> root.LeftChild);</div><div class="line">        CreateBinaryTree(<span class="keyword">ref</span> root.RightChild);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//前序遍历二叉树(中序、后序遍历的代码类似）</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PreOrderTraverse</span>(<span class="params">BinaryTreeNode root</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        Console.Write(root.Data+<span class="string">" "</span>);</div><div class="line">        PreOrderTraverse(root.LeftChild);</div><div class="line">        PreOrderTraverse(root.RightChild);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//中序遍历二叉树</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InOrderTraverse</span>(<span class="params">BinaryTreeNode root</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        InOrderTraverse(root.LeftChild);</div><div class="line">        Console.Write(root.Data + <span class="string">" "</span>);</div><div class="line">        InOrderTraverse(root.RightChild);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//后序遍历二叉树</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PostOrderTraverse</span>(<span class="params">BinaryTreeNode root</span>)</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        PostOrderTraverse(root.LeftChild);</div><div class="line">        PostOrderTraverse(root.RightChild);</div><div class="line">        Console.Write(root.Data + <span class="string">" "</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<p><font size="4" color="orange">二叉树前序、中序、后序序列的推导</font></p>
<ul>
<li>小技巧：推导一棵树的前序、中序、后序序列时，可以想着对应的递归代码来推导，不容易出错。</li>
<li>已知前序序列和中序序列，推导后序序列：<br>把握两个关键点：前序、后序序列用于确定树或子树的根结点是谁，而中序序列用于确定哪些结点位于根节点左边，哪些结点位于根节点右边。<br>如：已知一颗二叉树前序序列为ABCDEF，中序序列为CBAEDF，求后序序列：<ol>
<li>根据前序序列ABCDEF可知，结点A为树的根结点(最前面的是根结点)，再由中序序列CBAEDF可知结点CB位于A的左边，结点EDF位于A的右边。如下图所示：<br><img src="https://dl81.yunpan.360.cn/intf.php?method=Preview.outputPic&amp;qid=49291271&amp;fname=%2F%E5%9B%BE%E7%89%87%2F%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2FbinaryTree10.png&amp;fhash=842ade31e48226060497fce21b5201e3fc835247&amp;dt=81.20fa9b0aefa0f380c4e8bb11785fcb8f&amp;v=1.0.1&amp;rtick=14726598961342&amp;open_app_id=0&amp;devtype=web&amp;sign=dd3f5971c5d794b82b4368125cd00f2b&amp;" alt=""></li>
<li>由前序序列中的BC可知，在BC子树中，B是根结点(最前面的是根节点)。又由中序序列的CB可知C应该位于B的左边。如下图所示：<br><img src="https://dl81.yunpan.360.cn/intf.php?method=Preview.outputPic&amp;qid=49291271&amp;fname=%2F%E5%9B%BE%E7%89%87%2F%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2FbinaryTree11.png&amp;fhash=84d58a1ce23c6c98f892420a209a9ab7000ce8a0&amp;dt=81.966c97d9713adc619388c7fd72cb5e9e&amp;v=1.0.1&amp;rtick=14726598966773&amp;open_app_id=0&amp;devtype=web&amp;sign=a74101bee1fb33ca94467b67fd8c1a83&amp;" alt=""></li>
<li>由前序序列的DEF可知，在DEF子树中，D是根结点(最前面的是根结点)。又由中序序列的EDF可知E位于D的左边，F位于D的右边。如下图：<br><img src="https://dl81.yunpan.360.cn/intf.php?method=Preview.outputPic&amp;qid=49291271&amp;fname=%2F%E5%9B%BE%E7%89%87%2F%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2FbinaryTree12.png&amp;fhash=83faada51b3fae91b3721c7054f690358954e7a8&amp;dt=81.4571adcf48c0bc03f9ef0708bee2405d&amp;v=1.0.1&amp;rtick=14726598968183&amp;open_app_id=0&amp;devtype=web&amp;sign=11a5904fec1136937ecc8e97d092888d&amp;" alt=""></li>
</ol>
</li>
<li>已知后序序列和中序序列，推导前序序列：<br>唯一的不同之处在于：如上面的第1、2、3步，在前序序列(先根再左再右)中，最前面的是根节点，而在后序序列(先左再右再根)中最后的才是根结点。</li>
<li>已知前序序列和后序序列，是无法唯一确定一颗二叉树的。原因很简单，因为没有中序序列，无法确定哪些结点位于根结点左边，哪些结点位于根结点右边。</li>
</ul>
<hr>
<p><font size="4" color="orange">线索二叉树</font></p>
<ul>
<li>在扩展二叉树里面，我们就已经看到一颗二叉树里其实还留有很多空引用(指针)，主要来源于叶子结点和单分支结点(1度结点)。</li>
<li>在链表二叉树里面，我们只能直接知道结点的左右儿子是谁，而如果要知道某个结点在对应序列中的前驱和后继是谁，就必须得重新遍历一次。</li>
<li>其实可以考虑把那些空引用用来存储结点的前驱和后继。更巧的是，一颗二叉树中的空引用数目和所有结点的前驱后继总数刚好相等。</li>
</ul>
<p>我们把这种指向前驱和后继的引用称为线索，加上线索的二叉树便成了线索二叉树。所以线索化的实质就是将链表二叉树中的空引用利用起来，去指向结点的前驱和后继。如下图所示：<br><img src="https://dl81.yunpan.360.cn/intf.php?method=Preview.outputPic&amp;qid=49291271&amp;fname=%2F%E5%9B%BE%E7%89%87%2F%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2FbinaryTree13.png&amp;fhash=f7ffc4c59ed30a83237a78e898eba09393ad11f5&amp;dt=81.9238bd2dda110d576869de6016234618&amp;v=1.0.1&amp;rtick=14726638311039&amp;open_app_id=0&amp;devtype=web&amp;sign=e598f76f91c73c4bf72169e80ad1756f&amp;" alt=""><br>将该二叉树线索化后：<br><img src="https://dl81.yunpan.360.cn/intf.php?method=Preview.outputPic&amp;qid=49291271&amp;fname=%2F%E5%9B%BE%E7%89%87%2F%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2FbinaryTree14.png&amp;fhash=e5cda62bbd51c3132871c8362685a501e9a58411&amp;dt=81.5101541f4c3bb6cef0d0f90b9dd04763&amp;v=1.0.1&amp;rtick=14726638312176&amp;open_app_id=0&amp;devtype=web&amp;sign=ced08191e3481e4e1c38e150deff4027&amp;" alt=""><br>仔细观察会发现线索化后的二叉树其实就是一个双向链表，如下图：<br><img src="https://dl81.yunpan.360.cn/intf.php?method=Preview.outputPic&amp;qid=49291271&amp;fname=%2F%E5%9B%BE%E7%89%87%2F%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2FbinaryTree15.png&amp;fhash=5f837d7836d15c2f48138d7adfc0d7f9a266765b&amp;dt=81.0ece6197a1d261f4373c2a52679b4e60&amp;v=1.0.1&amp;rtick=14726638313932&amp;open_app_id=0&amp;devtype=web&amp;sign=870e45a9e10a58d67899914d7c0b1825&amp;" alt=""><br>既然是双向链表，那么可以给它加上一个头结点，方便我们既可以从第一个结点沿着后继进行遍历，也可以从最后一个结点沿着前驱进行遍历。</p>
<p>还有一个问题，原来的空引用变成了前驱和后继，那么怎么和原来那些指向左右儿子的非空引用区别开来呢？这时我们需要两个标志位，来分别标识两个引用到底是指向左右儿子还是作为前驱后继：ltag为0时表示指向结点的左儿子，为1时表示指向结点的前驱；rtag为0时表示指向结点的右儿子，为1时表示指向结点的后继。如下图所示：<br><img src="https://dl81.yunpan.360.cn/intf.php?method=Preview.outputPic&amp;qid=49291271&amp;fname=%2F%E5%9B%BE%E7%89%87%2F%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2FbinaryTree16.png&amp;fhash=5d518195ef98a770701856e9004044e3b91fc893&amp;dt=81.8032ba17646bf7d059304a0ce414a7a0&amp;v=1.0.1&amp;rtick=14726638319924&amp;open_app_id=0&amp;devtype=web&amp;sign=d51798f5dd8d81445eee7c15ad3bbc77&amp;" alt=""><br>线索二叉树的数据结构：<br>和二叉树的数据结构类似，只是结点类增加了两个数据成员：ltag、rtag。</p>
<p>可以在前序遍历的过程中就实现线索化。<br>由于线索二叉树其实是一个双向链表，所以可以按照链表的遍历方式来遍历线索二叉树了，省去了递归的大量开销。代码中的<code>CluePreOrderTraverse()</code>函数其实是模拟了二叉树的前序遍历，先一直向左，再向右，利用RightChild访问到下一个序列结点。<br>部分代码如下：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> <span class="title">ClueBinaryTreeNode</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">object</span> Data;</div><div class="line">    <span class="keyword">public</span> ClueBinaryTreeNode LeftChild;</div><div class="line">    <span class="keyword">public</span> ClueBinaryTreeNode RightChild;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> LeftTag;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> RightTag;</div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"><span class="keyword">class</span> <span class="title">ClueBinaryTree</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">public</span> ClueBinaryTreeNode first;</div><div class="line">    <span class="comment">//全局变量，指向刚刚访问过的结点</span></div><div class="line">    ClueBinaryTreeNode pre;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClueBinaryTree</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        first = <span class="keyword">new</span> ClueBinaryTreeNode();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//前序遍历过程中实现线索化</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraverse</span>(<span class="params">ClueBinaryTreeNode root</span>)</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        <span class="comment">//设置当前结点的前驱</span></div><div class="line">        <span class="keyword">if</span> (root.LeftChild == <span class="literal">null</span>)</div><div class="line">        &#123;</div><div class="line">            root.LeftTag = <span class="number">1</span>;</div><div class="line">            root.LeftChild = pre;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//设置前驱结点的后继为当前结点</span></div><div class="line">        <span class="keyword">if</span> (pre.RightChild == <span class="literal">null</span>) &#123;</div><div class="line">            pre.RightTag = <span class="number">1</span>;</div><div class="line">            pre.RightChild = root;</div><div class="line">        &#125;</div><div class="line">        pre = root;</div><div class="line">        PreOrderTraverse(root.LeftChild);</div><div class="line">        PreOrderTraverse(root.RightChild);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//用双向链表的方式来遍历线索二叉树</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CluePreOrderTraverse</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        ClueBinaryTreeNode current;</div><div class="line">        current = first.LeftChild;</div><div class="line">        <span class="keyword">while</span> (current != first) &#123;</div><div class="line">            <span class="keyword">while</span> (current.LeftTag == <span class="number">0</span>) &#123;</div><div class="line">                current = current.LeftChild;</div><div class="line">            &#125;</div><div class="line">            Console.WriteLine(current.Data);</div><div class="line">            <span class="keyword">while</span> (current.RightTag == <span class="number">1</span> &amp;&amp; current.RightChild != first) &#123;</div><div class="line">                current = current.RightChild;</div><div class="line">                Console.WriteLine(current.Data);</div><div class="line">            &#125;</div><div class="line">            current = current.RightChild;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<p><font size="4" color="orange">树、森林与二叉树的转换</font></p>
<ul>
<li>树转换为二叉树<ol>
<li>兄弟加线：在所有兄弟之间加一条连线</li>
<li>非长子去线：对树种每个结点，只保留它与第一个孩子结点的连线，删除它与其他孩子结点之间的连线</li>
<li>层次调整：以树和子树的根结点为轴心，将整棵树顺时针旋转一定的角度，使之结构层次分明。【注意第一个孩子是二叉树结点的左孩子，兄弟转换过来的孩子是结点的右孩子】<br>如下图所示：<br><img src="https://dl81.yunpan.360.cn/intf.php?method=Preview.outputPic&amp;qid=49291271&amp;fname=%2F%E5%9B%BE%E7%89%87%2F%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2FbinaryTree17.png&amp;fhash=034921202954073c93bd35c0f66184893a09c477&amp;dt=81.e3a159f0eec2f11f4c4161bba7328708&amp;v=1.0.1&amp;rtick=14726674602634&amp;open_app_id=0&amp;devtype=web&amp;sign=5d47fb585d57f0decc64890d826af7fc&amp;" alt=""></li>
</ol>
</li>
<li><p>森林转换为二叉树：每棵树的根结点依次作为右兄弟</p>
<ol>
<li>把每个树转换为二叉树</li>
<li>把后一棵二叉树的根结点作为右孩子连到前一棵二叉树的根结点上。再调整层成层次分明的二叉树</li>
</ol>
<p>如下图所示：<br><img src="https://dl81.yunpan.360.cn/intf.php?method=Preview.outputPic&amp;qid=49291271&amp;fname=%2F%E5%9B%BE%E7%89%87%2F%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2FbinaryTree18.png&amp;fhash=9168be34c06a8f130cbe3ad71b4dfeeac88c6c97&amp;dt=81.ce857814b066b30209911c45012241f1&amp;v=1.0.1&amp;rtick=14726678561356&amp;open_app_id=0&amp;devtype=web&amp;sign=03d9bf239379d50b769d22ab627b60aa&amp;" alt=""></p>
</li>
<li><p>二叉树转换为树</p>
<ol>
<li>加线：二叉树及其所有子树的根结点与它的长子的右孩子加线</li>
<li>去线：删除<strong>原</strong>二叉树中所有结点与其右孩子结点的连线</li>
<li>层次调整，使其结构层次分明</li>
</ol>
<p>如下图所示：<br><img src="https://dl81.yunpan.360.cn/intf.php?method=Preview.outputPic&amp;qid=49291271&amp;fname=%2F%E5%9B%BE%E7%89%87%2F%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2FbinaryTree19.png&amp;fhash=69a4b5875517a37935b2c8ccdb9fe8c81f765935&amp;dt=81.0d48e7f804a0011eb56583be94e2ad9d&amp;v=1.0.1&amp;rtick=14726678569718&amp;open_app_id=0&amp;devtype=web&amp;sign=bc9363d50f8cf5262fdb89059bdc7189&amp;" alt=""></p>
</li>
<li>二叉树转换为森林(森林到二叉树的逆转换)<ol>
<li>首先要判断一棵二叉树能否转换成森林，需要看二叉树的根结点是否有右孩子，如果有则删掉与右孩子的连线。一直进行下去，直到分离的所有二叉树根结点与右孩子的连线都删除为止</li>
<li>将每棵分离的二叉树转换为树</li>
</ol>
</li>
</ul>
<hr>
<p><font size="4" color="orange">二叉树的应用之哈夫曼树</font><br>树的带权路径长度WPL：树中所有叶子结点的权值乘以路径长度的和。<br>带权路径长度WPL最小的二叉树称为哈夫曼树。哈夫曼树又称带权最优二叉树。</p>
<ul>
<li>求解哈夫曼树的方法：</li>
</ul>
<ol>
<li>把所有带权值得叶子节点排成一个序列</li>
<li>取出权值最小的两个加起来，作为新结点，加入到序列中(取出的两个结点报废)，并在对应哈夫曼树的结构图作为取出的两个结点的双亲结点</li>
<li>重复第二步，直到序列中不再有结点为止</li>
</ol>
<p>假设六个字母的频率为A 27，B 8，C 15，D 15，E 30，F 5，则由它们构成的哈夫曼树如下图所示：<br><img src="https://dl81.yunpan.360.cn/intf.php?method=Preview.outputPic&amp;qid=49291271&amp;fname=%2F%E5%9B%BE%E7%89%87%2F%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2FbinaryTree21.png&amp;fhash=afb5c418afb6f553b11126b22fa85b8819d66064&amp;dt=81.2227154ed1b4b4cd17c73aec182349d3&amp;v=1.0.1&amp;rtick=14726704773865&amp;open_app_id=0&amp;devtype=web&amp;sign=a9d2e52aa0996fbce7a617bd26fcbae5&amp;" alt=""><br>规定哈夫曼树的左分支代表0，右分支代表1，则从叶子结点到根结点的01序列就是对应字符的<strong>哈夫曼编码</strong>。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/09/01/二叉树/" data-id="cit2x5t5x0006ocvjt56g88dh" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/二叉树/">二叉树</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/09/01/图/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          数据结构与算法之图
        
      </div>
    </a>
  
  
    <a href="/2016/08/30/C-常用容器/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">C#用容器</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C-语法/">C#语法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/博客配置/">博客配置</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构/">数据结构</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-容器/">C#容器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MarkDown/">MarkDown</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/timeTest/">timeTest</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/二叉树/">二叉树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/关键路径/">关键路径</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/图/">图</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多说/">多说</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/头结点/">头结点</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/拓扑排序/">拓扑排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/改进排序/">改进排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/最小生成树/">最小生成树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/最短路径/">最短路径</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/栈/">栈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/树/">树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/简单排序/">简单排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/链表/">链表</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/队列/">队列</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/C-容器/" style="font-size: 10px;">C#容器</a> <a href="/tags/MarkDown/" style="font-size: 10px;">MarkDown</a> <a href="/tags/timeTest/" style="font-size: 10px;">timeTest</a> <a href="/tags/二叉树/" style="font-size: 10px;">二叉树</a> <a href="/tags/关键路径/" style="font-size: 10px;">关键路径</a> <a href="/tags/图/" style="font-size: 10px;">图</a> <a href="/tags/多说/" style="font-size: 10px;">多说</a> <a href="/tags/头结点/" style="font-size: 10px;">头结点</a> <a href="/tags/拓扑排序/" style="font-size: 10px;">拓扑排序</a> <a href="/tags/改进排序/" style="font-size: 10px;">改进排序</a> <a href="/tags/最小生成树/" style="font-size: 10px;">最小生成树</a> <a href="/tags/最短路径/" style="font-size: 10px;">最短路径</a> <a href="/tags/栈/" style="font-size: 10px;">栈</a> <a href="/tags/树/" style="font-size: 10px;">树</a> <a href="/tags/简单排序/" style="font-size: 10px;">简单排序</a> <a href="/tags/链表/" style="font-size: 10px;">链表</a> <a href="/tags/队列/" style="font-size: 10px;">队列</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">九月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">八月 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/09/14/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2016/09/14/test/">test</a>
          </li>
        
          <li>
            <a href="/2016/09/09/拓扑排序/">数据结构与算法之图之拓扑排序</a>
          </li>
        
          <li>
            <a href="/2016/09/03/改进排序/">数据结构与算法之改进排序</a>
          </li>
        
          <li>
            <a href="/2016/09/03/简单排序/">数据结构与算法之简单排序</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 Elay<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>