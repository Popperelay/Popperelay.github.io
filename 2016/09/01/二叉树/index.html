<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>数据结构与算法之二叉树 | Elays&#39;Blog</title>
  <meta name="author" content="Elay">
  
  <meta name="description" content="Elay">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="数据结构与算法之二叉树"/>
  <meta property="og:site_name" content="Elays&#39;Blog"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Elays&#39;Blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">Elays&#39;Blog</a></h1>
  <h2><a href="/">你是天地生的，美得超越人形</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">主页</a></li>
    
      <li><a href="/archives">所有文章</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-08-31T19:14:11.000Z"><a href="/2016/09/01/二叉树/">2016-09-01</a></time>
      
      
  
    <h1 class="title">数据结构与算法之二叉树</h1>
  

    </header>
    <div class="entry">
      
        <p><font size="4" color="orange">先来看几个二叉树的特点和概念：</font><br><a id="more"></a></p>
<ul>
<li>二叉树：<ul>
<li>二叉树的左子树和右子树是有顺序的，是有序树。</li>
<li>任意一颗二叉树的：叶子树=2度结点数+1</li>
</ul>
</li>
<li>满二叉树：每个分支结点都有左儿子和右儿子，且所有叶子结点位于同一层。如下图：<br><img src="https://dl81.yunpan.360.cn/intf.php?method=Preview.outputPic&amp;qid=49291271&amp;fname=%2F%E5%9B%BE%E7%89%87%2F%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2FbinaryTree1.png&amp;fhash=ae6af474ad05509b7500c67309d6c2cb91a45330&amp;dt=81.389b9f48fd72ed507a0e2ecde8eb75cd&amp;v=1.0.1&amp;rtick=14725721226636&amp;open_app_id=0&amp;devtype=web&amp;sign=4baefe68b9f382fbd377771aaad3e9af&amp;" alt=""></li>
<li>完全二叉树：按层序编号后，对应结点编号和满二叉树完全相同(完全二叉树的结点数&lt;=满二叉树的结点数)。如下图：<br><img src="https://dl81.yunpan.360.cn/intf.php?method=Preview.outputPic&amp;qid=49291271&amp;fname=%2F%E5%9B%BE%E7%89%87%2F%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2FbinaryTree2.png&amp;fhash=a88ea055c79a0ce6d5039347c30b5958b2c9eda7&amp;dt=81.cba2cb3d41748322e6cee9f597c7b1b8&amp;v=1.0.1&amp;rtick=14725721228302&amp;open_app_id=0&amp;devtype=web&amp;sign=3f3497ef115f5927c2a7ffc554afa523&amp;" alt=""><ul>
<li>所以，判断某二叉树是否是完全二叉树的方法：看着树的示意图，按照完全二叉树的结构逐层按顺序编号，如果编号出现空挡，则不是完全二叉树。</li>
<li>同样结点的二叉树，完全二叉树的深度最小</li>
<li>具有n个结点的完全二叉树的深度为：<img src="https://dl81.yunpan.360.cn/intf.php?method=Preview.outputPic&amp;qid=49291271&amp;fname=%2F%E5%9B%BE%E7%89%87%2F%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2FbinaryTree3.png&amp;fhash=9dc21d54d9ff216cfd6674f77fe1102b6ec706c6&amp;dt=81.c173a905d64d586f932708e50dd38ff8&amp;v=1.0.1&amp;rtick=14726427793760&amp;open_app_id=0&amp;devtype=web&amp;sign=94144072204dc52b9628f51db4ae9fa0&amp;" alt=""></li>
<li>对具有n个结点的完全二叉树【前提条件是2i和2i+1均小于n】：<br>左孩子跟双亲满足关系：2i&lt;=&gt;i<br>右孩子跟双亲满足关系：2i+1&lt;=&gt;i</li>
</ul>
</li>
</ul>
<hr>
<p><font size="4" color="orange">顺序二叉树</font><br>任何一颗二叉树的顺序存储都是按其对应的完全二叉树的编号来的，当出现大量空挡(比如右倾斜树)时，会浪费很多存储空间，所以顺序存储一般只用于完全二叉树。<br><img src="https://dl81.yunpan.360.cn/intf.php?method=Preview.outputPic&amp;qid=49291271&amp;fname=%2F%E5%9B%BE%E7%89%87%2F%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2FbinaryTree4.png&amp;fhash=cecc26cab7d63697dcd9583d819fc89bca49a1a8&amp;dt=81.309b5b8a3f9a983b12f0981e92ed65ad&amp;v=1.0.1&amp;rtick=14726445975555&amp;open_app_id=0&amp;devtype=web&amp;sign=0a6bc6edb0dacb8df83b15287a4820a5&amp;" alt=""></p>
<hr>
<p><font size="4" color="orange">链表二叉树</font></p>
<ul>
<li>链表二叉树的数据结构：结点类+树(类)<br>结点类由三个数据成员组成：结点数据、左儿子、右儿子<br>树(类)主要由一个数据成员组成：根结点</li>
<li>建立二叉树<br>要建立一颗二叉树，这棵二叉树应该是已经确定好的，而且需要事先知道该二叉树的前序序列(或中序序列、后序序列)。并且为了确认每一个结点是否有左右孩子，需要将原二叉树进行扩展，也就是将每个二叉树结点内的空指针用一个虚结点代替(假定虚结点数据为#)，得到一颗扩展二叉树。由扩展二叉树得到的前序序列称为完全前序序列。如下图所示：<br><img src="https://dl81.yunpan.360.cn/intf.php?method=Preview.outputPic&amp;qid=49291271&amp;fname=%2F%E5%9B%BE%E7%89%87%2F%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2FbinaryTree5.png&amp;fhash=66d647153088f221a0c5b7b08907d8d72a55e5d0&amp;dt=81.a705a22a36246d98449295c6bd820c49&amp;v=1.0.1&amp;rtick=14726522797943&amp;open_app_id=0&amp;devtype=web&amp;sign=10e0676b38b818fb11d3d71821afb7c7&amp;" alt=""><br>上图的完全前序序列为：AB#D##C##，输入已知的完全前序序列，便能通过<code>CreateBinaryTree()</code>函数来建立该二叉树。代码见后面。</li>
<li>遍历二叉树<br>二叉树的遍历是从根节点开始的。按照根结点访问次序的不同，分为三种遍历方式：前序遍历、中序遍历、后序遍历，另外还有一种层序遍历。<ul>
<li>前序遍历：先根再左再右<br>遍历规则：若结点为空，则返回，否则先访问根结点，再访问左子树，再访问右子树。如下图所示：<br><img src="https://dl81.yunpan.360.cn/intf.php?method=Preview.outputPic&amp;qid=49291271&amp;fname=%2F%E5%9B%BE%E7%89%87%2F%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2FbinaryTree6.png&amp;fhash=e81ca8766612b65dbfddf345e4f5141efbde56b6&amp;dt=81.0971dc1e85d521523df02feaf234bc92&amp;v=1.0.1&amp;rtick=14726533075393&amp;open_app_id=0&amp;devtype=web&amp;sign=9cef66c87c01795a095751e5da85f49c&amp;" alt=""><br>遍历的顺序(前序序列)为：ABDGHCEIF</li>
<li>中序遍历：先左再根再右<br>遍历规则：若结点为空，则返回，否则先访问左子树，再访问根结点，再访问右子树。如下图所示：<br><img src="https://dl81.yunpan.360.cn/intf.php?method=Preview.outputPic&amp;qid=49291271&amp;fname=%2F%E5%9B%BE%E7%89%87%2F%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2FbinaryTree7.png&amp;fhash=0f43440b9066a8e9992057a0f182700c82cbfbd8&amp;dt=81.616453b2068ee277f209a8474487b934&amp;v=1.0.1&amp;rtick=14726533076126&amp;open_app_id=0&amp;devtype=web&amp;sign=89aa0e25eec8587edcd1ef4be0d543ba&amp;" alt=""><br>遍历的顺序(中序序列)为：GDHBAEICF</li>
<li>后序遍历：先左再右再根<br>遍历规则：若结点为空，则返回，否则先访问根结点，再访问左子树，再访问右子树。如下图所示：<br><img src="https://dl81.yunpan.360.cn/intf.php?method=Preview.outputPic&amp;qid=49291271&amp;fname=%2F%E5%9B%BE%E7%89%87%2F%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2FbinaryTree8.png&amp;fhash=b6eb8cf5e637cae837cfee62747e39f3a3b84fe6&amp;dt=81.a8acdddfab8f241d0d753b51f3c6b971&amp;v=1.0.1&amp;rtick=14726533078719&amp;open_app_id=0&amp;devtype=web&amp;sign=636545b41ec6b066ca10879eba505288&amp;" alt=""><br>遍历的顺序(后序序列)为：GHDBIEFCA</li>
<li>层序遍历：按层从左到右访问结点<br>如下图所示：<br><img src="https://dl81.yunpan.360.cn/intf.php?method=Preview.outputPic&amp;qid=49291271&amp;fname=%2F%E5%9B%BE%E7%89%87%2F%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2FbinaryTree9.png&amp;fhash=1b9d110be40caad4ebe15c0e1f10a02692c5bacd&amp;dt=81.0483ac2e1d2a1277204cc4d70cc55286&amp;v=1.0.1&amp;rtick=14726533073939&amp;open_app_id=0&amp;devtype=web&amp;sign=148b9250f3faa9f4fc7d6f0cbdac082c&amp;" alt=""><br>遍历的顺序(层序序列)为：ABCDEFGHI</li>
</ul>
</li>
</ul>
<p>上面得到的各种遍历序列可以用来创建二叉树，当然也可以根据各种遍历方法来遍历已经创建好的二叉树，前序、中序、后序遍历的代码见后面。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BinaryTreeNode</span> &#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">object</span> Data;</div><div class="line">    <span class="keyword">public</span> BinaryTreeNode LeftChild;</div><div class="line">    <span class="keyword">public</span> BinaryTreeNode RightChild;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinaryTreeNode</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        Data = <span class="literal">null</span>;</div><div class="line">        LeftChild = <span class="literal">null</span>;</div><div class="line">        RightChild = <span class="literal">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinaryTreeNode</span>(<span class="params"><span class="keyword">object</span> data</span>) </span>&#123;</div><div class="line">        Data = data;</div><div class="line">        LeftChild = <span class="literal">null</span>;</div><div class="line">        RightChild = <span class="literal">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">class</span> <span class="title">BinaryTree</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">public</span> BinaryTreeNode root;</div><div class="line"></div><div class="line">    <span class="comment">//按前序序列建立二叉树(中序、后序建立的代码类似)</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CreateBinaryTree</span>(<span class="params"><span class="keyword">ref</span> BinaryTreeNode root</span>) </span>&#123;</div><div class="line">        <span class="keyword">object</span> data;</div><div class="line">        data=Console.ReadLine();</div><div class="line">        <span class="keyword">if</span> (data.Equals(<span class="string">"#"</span>)) &#123;</div><div class="line">            root = <span class="literal">null</span>;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        root = <span class="keyword">new</span> BinaryTreeNode(data);</div><div class="line">        CreateBinaryTree(<span class="keyword">ref</span> root.LeftChild);</div><div class="line">        CreateBinaryTree(<span class="keyword">ref</span> root.RightChild);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//前序遍历二叉树(中序、后序遍历的代码类似）</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PreOrderTraverse</span>(<span class="params">BinaryTreeNode root</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        Console.Write(root.Data+<span class="string">" "</span>);</div><div class="line">        PreOrderTraverse(root.LeftChild);</div><div class="line">        PreOrderTraverse(root.RightChild);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//中序遍历二叉树</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InOrderTraverse</span>(<span class="params">BinaryTreeNode root</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        InOrderTraverse(root.LeftChild);</div><div class="line">        Console.Write(root.Data + <span class="string">" "</span>);</div><div class="line">        InOrderTraverse(root.RightChild);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//后序遍历二叉树</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PostOrderTraverse</span>(<span class="params">BinaryTreeNode root</span>)</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        PostOrderTraverse(root.LeftChild);</div><div class="line">        PostOrderTraverse(root.RightChild);</div><div class="line">        Console.Write(root.Data + <span class="string">" "</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<p><font size="4" color="orange">二叉树前序、中序、后序序列的推导</font></p>
<ul>
<li>小技巧：推导一棵树的前序、中序、后序序列时，可以想着对应的递归代码来推导，不容易出错。</li>
<li>已知前序序列和中序序列，推导后序序列：<br>把握两个关键点：前序、后序序列用于确定树或子树的根结点是谁，而中序序列用于确定哪些结点位于根节点左边，哪些结点位于根节点右边。<br>如：已知一颗二叉树前序序列为ABCDEF，中序序列为CBAEDF，求后序序列：<ol>
<li>根据前序序列ABCDEF可知，结点A为树的根结点(最前面的是根结点)，再由中序序列CBAEDF可知结点CB位于A的左边，结点EDF位于A的右边。如下图所示：<br><img src="https://dl81.yunpan.360.cn/intf.php?method=Preview.outputPic&amp;qid=49291271&amp;fname=%2F%E5%9B%BE%E7%89%87%2F%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2FbinaryTree10.png&amp;fhash=842ade31e48226060497fce21b5201e3fc835247&amp;dt=81.20fa9b0aefa0f380c4e8bb11785fcb8f&amp;v=1.0.1&amp;rtick=14726598961342&amp;open_app_id=0&amp;devtype=web&amp;sign=dd3f5971c5d794b82b4368125cd00f2b&amp;" alt=""></li>
<li>由前序序列中的BC可知，在BC子树中，B是根结点(最前面的是根节点)。又由中序序列的CB可知C应该位于B的左边。如下图所示：<br><img src="https://dl81.yunpan.360.cn/intf.php?method=Preview.outputPic&amp;qid=49291271&amp;fname=%2F%E5%9B%BE%E7%89%87%2F%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2FbinaryTree11.png&amp;fhash=84d58a1ce23c6c98f892420a209a9ab7000ce8a0&amp;dt=81.966c97d9713adc619388c7fd72cb5e9e&amp;v=1.0.1&amp;rtick=14726598966773&amp;open_app_id=0&amp;devtype=web&amp;sign=a74101bee1fb33ca94467b67fd8c1a83&amp;" alt=""></li>
<li>由前序序列的DEF可知，在DEF子树中，D是根结点(最前面的是根结点)。又由中序序列的EDF可知E位于D的左边，F位于D的右边。如下图：<br><img src="https://dl81.yunpan.360.cn/intf.php?method=Preview.outputPic&amp;qid=49291271&amp;fname=%2F%E5%9B%BE%E7%89%87%2F%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2FbinaryTree12.png&amp;fhash=83faada51b3fae91b3721c7054f690358954e7a8&amp;dt=81.4571adcf48c0bc03f9ef0708bee2405d&amp;v=1.0.1&amp;rtick=14726598968183&amp;open_app_id=0&amp;devtype=web&amp;sign=11a5904fec1136937ecc8e97d092888d&amp;" alt=""></li>
</ol>
</li>
<li>已知后序序列和中序序列，推导前序序列：<br>唯一的不同之处在于：如上面的第1、2、3步，在前序序列(先根再左再右)中，最前面的是根节点，而在后序序列(先左再右再根)中最后的才是根结点。</li>
<li>已知前序序列和后序序列，是无法唯一确定一颗二叉树的。原因很简单，因为没有中序序列，无法确定哪些结点位于根结点左边，哪些结点位于根结点右边。</li>
</ul>
<hr>
<p><font size="4" color="orange">线索二叉树</font></p>
<ul>
<li>在扩展二叉树里面，我们就已经看到一颗二叉树里其实还留有很多空引用(指针)，主要来源于叶子结点和单分支结点(1度结点)。</li>
<li>在链表二叉树里面，我们只能直接知道结点的左右儿子是谁，而如果要知道某个结点在对应序列中的前驱和后继是谁，就必须得重新遍历一次。</li>
<li>其实可以考虑把那些空引用用来存储结点的前驱和后继。更巧的是，一颗二叉树中的空引用数目和所有结点的前驱后继总数刚好相等。</li>
</ul>
<p>我们把这种指向前驱和后继的引用称为线索，加上线索的二叉树便成了线索二叉树。所以线索化的实质就是将链表二叉树中的空引用利用起来，去指向结点的前驱和后继。如下图所示：<br><img src="https://dl81.yunpan.360.cn/intf.php?method=Preview.outputPic&amp;qid=49291271&amp;fname=%2F%E5%9B%BE%E7%89%87%2F%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2FbinaryTree13.png&amp;fhash=f7ffc4c59ed30a83237a78e898eba09393ad11f5&amp;dt=81.9238bd2dda110d576869de6016234618&amp;v=1.0.1&amp;rtick=14726638311039&amp;open_app_id=0&amp;devtype=web&amp;sign=e598f76f91c73c4bf72169e80ad1756f&amp;" alt=""><br>将该二叉树线索化后：<br><img src="https://dl81.yunpan.360.cn/intf.php?method=Preview.outputPic&amp;qid=49291271&amp;fname=%2F%E5%9B%BE%E7%89%87%2F%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2FbinaryTree14.png&amp;fhash=e5cda62bbd51c3132871c8362685a501e9a58411&amp;dt=81.5101541f4c3bb6cef0d0f90b9dd04763&amp;v=1.0.1&amp;rtick=14726638312176&amp;open_app_id=0&amp;devtype=web&amp;sign=ced08191e3481e4e1c38e150deff4027&amp;" alt=""><br>仔细观察会发现线索化后的二叉树其实就是一个双向链表，如下图：<br><img src="https://dl81.yunpan.360.cn/intf.php?method=Preview.outputPic&amp;qid=49291271&amp;fname=%2F%E5%9B%BE%E7%89%87%2F%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2FbinaryTree15.png&amp;fhash=5f837d7836d15c2f48138d7adfc0d7f9a266765b&amp;dt=81.0ece6197a1d261f4373c2a52679b4e60&amp;v=1.0.1&amp;rtick=14726638313932&amp;open_app_id=0&amp;devtype=web&amp;sign=870e45a9e10a58d67899914d7c0b1825&amp;" alt=""><br>既然是双向链表，那么可以给它加上一个头结点，方便我们既可以从第一个结点沿着后继进行遍历，也可以从最后一个结点沿着前驱进行遍历。</p>
<p>还有一个问题，原来的空引用变成了前驱和后继，那么怎么和原来那些指向左右儿子的非空引用区别开来呢？这时我们需要两个标志位，来分别标识两个引用到底是指向左右儿子还是作为前驱后继：ltag为0时表示指向结点的左儿子，为1时表示指向结点的前驱；rtag为0时表示指向结点的右儿子，为1时表示指向结点的后继。如下图所示：<br><img src="https://dl81.yunpan.360.cn/intf.php?method=Preview.outputPic&amp;qid=49291271&amp;fname=%2F%E5%9B%BE%E7%89%87%2F%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2FbinaryTree16.png&amp;fhash=5d518195ef98a770701856e9004044e3b91fc893&amp;dt=81.8032ba17646bf7d059304a0ce414a7a0&amp;v=1.0.1&amp;rtick=14726638319924&amp;open_app_id=0&amp;devtype=web&amp;sign=d51798f5dd8d81445eee7c15ad3bbc77&amp;" alt=""><br>线索二叉树的数据结构：<br>和二叉树的数据结构类似，只是结点类增加了两个数据成员：ltag、rtag。</p>
<p>可以在前序遍历的过程中就实现线索化。<br>由于线索二叉树其实是一个双向链表，所以可以按照链表的遍历方式来遍历线索二叉树了，省去了递归的大量开销。代码中的<code>CluePreOrderTraverse()</code>函数其实是模拟了二叉树的前序遍历，先一直向左，再向右，利用RightChild访问到下一个序列结点。<br>部分代码如下：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> <span class="title">ClueBinaryTreeNode</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">object</span> Data;</div><div class="line">    <span class="keyword">public</span> ClueBinaryTreeNode LeftChild;</div><div class="line">    <span class="keyword">public</span> ClueBinaryTreeNode RightChild;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> LeftTag;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> RightTag;</div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"><span class="keyword">class</span> <span class="title">ClueBinaryTree</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">public</span> ClueBinaryTreeNode first;</div><div class="line">    <span class="comment">//全局变量，指向刚刚访问过的结点</span></div><div class="line">    ClueBinaryTreeNode pre;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClueBinaryTree</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        first = <span class="keyword">new</span> ClueBinaryTreeNode();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//前序遍历过程中实现线索化</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraverse</span>(<span class="params">ClueBinaryTreeNode root</span>)</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        <span class="comment">//设置当前结点的前驱</span></div><div class="line">        <span class="keyword">if</span> (root.LeftChild == <span class="literal">null</span>)</div><div class="line">        &#123;</div><div class="line">            root.LeftTag = <span class="number">1</span>;</div><div class="line">            root.LeftChild = pre;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//设置前驱结点的后继为当前结点</span></div><div class="line">        <span class="keyword">if</span> (pre.RightChild == <span class="literal">null</span>) &#123;</div><div class="line">            pre.RightTag = <span class="number">1</span>;</div><div class="line">            pre.RightChild = root;</div><div class="line">        &#125;</div><div class="line">        pre = root;</div><div class="line">        PreOrderTraverse(root.LeftChild);</div><div class="line">        PreOrderTraverse(root.RightChild);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//用双向链表的方式来遍历线索二叉树</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CluePreOrderTraverse</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        ClueBinaryTreeNode current;</div><div class="line">        current = first.LeftChild;</div><div class="line">        <span class="keyword">while</span> (current != first) &#123;</div><div class="line">            <span class="keyword">while</span> (current.LeftTag == <span class="number">0</span>) &#123;</div><div class="line">                current = current.LeftChild;</div><div class="line">            &#125;</div><div class="line">            Console.WriteLine(current.Data);</div><div class="line">            <span class="keyword">while</span> (current.RightTag == <span class="number">1</span> &amp;&amp; current.RightChild != first) &#123;</div><div class="line">                current = current.RightChild;</div><div class="line">                Console.WriteLine(current.Data);</div><div class="line">            &#125;</div><div class="line">            current = current.RightChild;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<p><font size="4" color="orange">树、森林与二叉树的转换</font></p>
<ul>
<li>树转换为二叉树<ol>
<li>兄弟加线：在所有兄弟之间加一条连线</li>
<li>非长子去线：对树种每个结点，只保留它与第一个孩子结点的连线，删除它与其他孩子结点之间的连线</li>
<li>层次调整：以树和子树的根结点为轴心，将整棵树顺时针旋转一定的角度，使之结构层次分明。【注意第一个孩子是二叉树结点的左孩子，兄弟转换过来的孩子是结点的右孩子】<br>如下图所示：<br><img src="https://dl81.yunpan.360.cn/intf.php?method=Preview.outputPic&amp;qid=49291271&amp;fname=%2F%E5%9B%BE%E7%89%87%2F%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2FbinaryTree17.png&amp;fhash=034921202954073c93bd35c0f66184893a09c477&amp;dt=81.e3a159f0eec2f11f4c4161bba7328708&amp;v=1.0.1&amp;rtick=14726674602634&amp;open_app_id=0&amp;devtype=web&amp;sign=5d47fb585d57f0decc64890d826af7fc&amp;" alt=""></li>
</ol>
</li>
<li><p>森林转换为二叉树：每棵树的根结点依次作为右兄弟</p>
<ol>
<li>把每个树转换为二叉树</li>
<li>把后一棵二叉树的根结点作为右孩子连到前一棵二叉树的根结点上。再调整层成层次分明的二叉树</li>
</ol>
<p>如下图所示：<br><img src="https://dl81.yunpan.360.cn/intf.php?method=Preview.outputPic&amp;qid=49291271&amp;fname=%2F%E5%9B%BE%E7%89%87%2F%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2FbinaryTree18.png&amp;fhash=9168be34c06a8f130cbe3ad71b4dfeeac88c6c97&amp;dt=81.ce857814b066b30209911c45012241f1&amp;v=1.0.1&amp;rtick=14726678561356&amp;open_app_id=0&amp;devtype=web&amp;sign=03d9bf239379d50b769d22ab627b60aa&amp;" alt=""></p>
</li>
<li><p>二叉树转换为树</p>
<ol>
<li>加线：二叉树及其所有子树的根结点与它的长子的右孩子加线</li>
<li>去线：删除<strong>原</strong>二叉树中所有结点与其右孩子结点的连线</li>
<li>层次调整，使其结构层次分明</li>
</ol>
<p>如下图所示：<br><img src="https://dl81.yunpan.360.cn/intf.php?method=Preview.outputPic&amp;qid=49291271&amp;fname=%2F%E5%9B%BE%E7%89%87%2F%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2FbinaryTree19.png&amp;fhash=69a4b5875517a37935b2c8ccdb9fe8c81f765935&amp;dt=81.0d48e7f804a0011eb56583be94e2ad9d&amp;v=1.0.1&amp;rtick=14726678569718&amp;open_app_id=0&amp;devtype=web&amp;sign=bc9363d50f8cf5262fdb89059bdc7189&amp;" alt=""></p>
</li>
<li>二叉树转换为森林(森林到二叉树的逆转换)<ol>
<li>首先要判断一棵二叉树能否转换成森林，需要看二叉树的根结点是否有右孩子，如果有则删掉与右孩子的连线。一直进行下去，直到分离的所有二叉树根结点与右孩子的连线都删除为止</li>
<li>将每棵分离的二叉树转换为树</li>
</ol>
</li>
</ul>
<hr>
<p><font size="4" color="orange">二叉树的应用之哈夫曼树</font><br>树的带权路径长度WPL：树中所有叶子结点的权值乘以路径长度的和。<br>带权路径长度WPL最小的二叉树称为哈夫曼树。哈夫曼树又称带权最优二叉树。</p>
<ul>
<li>求解哈夫曼树的方法：</li>
</ul>
<ol>
<li>把所有带权值得叶子节点排成一个序列</li>
<li>取出权值最小的两个加起来，作为新结点，加入到序列中(取出的两个结点报废)，并在对应哈夫曼树的结构图作为取出的两个结点的双亲结点</li>
<li>重复第二步，直到序列中不再有结点为止</li>
</ol>
<p>假设六个字母的频率为A 27，B 8，C 15，D 15，E 30，F 5，则由它们构成的哈夫曼树如下图所示：<br><img src="https://dl81.yunpan.360.cn/intf.php?method=Preview.outputPic&amp;qid=49291271&amp;fname=%2F%E5%9B%BE%E7%89%87%2F%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2FbinaryTree21.png&amp;fhash=afb5c418afb6f553b11126b22fa85b8819d66064&amp;dt=81.2227154ed1b4b4cd17c73aec182349d3&amp;v=1.0.1&amp;rtick=14726704773865&amp;open_app_id=0&amp;devtype=web&amp;sign=a9d2e52aa0996fbce7a617bd26fcbae5&amp;" alt=""><br>规定哈夫曼树的左分支代表0，右分支代表1，则从叶子结点到根结点的01序列就是对应字符的<strong>哈夫曼编码</strong>。</p>

      
    </div>
    <footer>
      
        
  
  <div class="categories">
    <a href="/categories/数据结构/">数据结构</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/二叉树/">二叉树</a>
  </div>

        
  <div class="addthis addthis_toolbox addthis_default_style">
    
      <a class="addthis_button_facebook_like" fb:like:layout="button_count"></a>
    
    
      <a class="addthis_button_tweet"></a>
    
    
      <a class="addthis_button_google_plusone" g:plusone:size="medium"></a>
    
    
      <a class="addthis_button_pinterest_pinit" pi:pinit:layout="horizontal"></a>
    
    <a class="addthis_counter addthis_pill_style"></a>
  </div>
  <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js"></script>

      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


<section id="comment">
  <h2 class="title">留言</h2>


 
  	   <!-- 多说评论框 start -->
 		<div class="ds-thread" data-thread-key="2016/09/01/二叉树/" data-title="数据结构与算法之二叉树" data-url="http://yoursite.com/2016/09/01/二叉树/"></div>
		<!-- 多说评论框 end -->
		<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
		<script type="text/javascript">
		var duoshuoQuery = {short_name:"popperelay"};   <!-- 替换这里的duoshuo_shortname为前面注册的shortname -->
			(function() {
				var ds = document.createElement('script');
				ds.type = 'text/javascript';ds.async = true;
				ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.unstable.js';
				ds.charset = 'UTF-8';
				(document.getElementsByTagName('head')[0] 
				 || document.getElementsByTagName('body')[0]).appendChild(ds);
			})();
			</script>
		<!-- 多说公共JS代码 end -->
 
  
</section>

</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:yoursite.com">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/C-语法/">C#语法</a><small>2</small></li>
  
    <li><a href="/categories/OpenGL/">OpenGL</a><small>1</small></li>
  
    <li><a href="/categories/博客配置/">博客配置</a><small>2</small></li>
  
    <li><a href="/categories/操作系统/">操作系统</a><small>4</small></li>
  
    <li><a href="/categories/数据结构/">数据结构</a><small>15</small></li>
  
    <li><a href="/categories/游戏开发/">游戏开发</a><small>1</small></li>
  
    <li><a href="/categories/计算机图形学/">计算机图形学</a><small>2</small></li>
  
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/BIOS和微机启动过程/">BIOS和微机启动过程</a><small>1</small></li>
  
    <li><a href="/tags/C-容器/">C#容器</a><small>1</small></li>
  
    <li><a href="/tags/MarkDown/">MarkDown</a><small>1</small></li>
  
    <li><a href="/tags/OS内核/">OS内核</a><small>1</small></li>
  
    <li><a href="/tags/OpenGL配置/">OpenGL配置</a><small>1</small></li>
  
    <li><a href="/tags/timeTest/">timeTest</a><small>1</small></li>
  
    <li><a href="/tags/二叉树/">二叉树</a><small>1</small></li>
  
    <li><a href="/tags/关键路径/">关键路径</a><small>1</small></li>
  
    <li><a href="/tags/图/">图</a><small>1</small></li>
  
    <li><a href="/tags/图形学概述/">图形学概述</a><small>1</small></li>
  
    <li><a href="/tags/图形显示系统/">图形显示系统</a><small>1</small></li>
  
    <li><a href="/tags/多说/">多说</a><small>1</small></li>
  
    <li><a href="/tags/头结点/">头结点</a><small>1</small></li>
  
    <li><a href="/tags/尾递归/">尾递归</a><small>1</small></li>
  
    <li><a href="/tags/帧同步/">帧同步</a><small>1</small></li>
  
    <li><a href="/tags/拓扑排序/">拓扑排序</a><small>1</small></li>
  
    <li><a href="/tags/操作系统概述/">操作系统概述</a><small>1</small></li>
  
    <li><a href="/tags/改进排序/">改进排序</a><small>1</small></li>
  
    <li><a href="/tags/最小生成树/">最小生成树</a><small>1</small></li>
  
    <li><a href="/tags/最短路径/">最短路径</a><small>1</small></li>
  
    <li><a href="/tags/查找/">查找</a><small>1</small></li>
  
    <li><a href="/tags/栈/">栈</a><small>1</small></li>
  
    <li><a href="/tags/树/">树</a><small>1</small></li>
  
    <li><a href="/tags/简单排序/">简单排序</a><small>1</small></li>
  
    <li><a href="/tags/进程的描述与控制/">进程的描述与控制</a><small>1</small></li>
  
    <li><a href="/tags/链表/">链表</a><small>1</small></li>
  
    <li><a href="/tags/队列/">队列</a><small>1</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2016 Elay
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>