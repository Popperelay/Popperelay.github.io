<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>进程的描述与控制 | Elays&#39;Blog</title>
  <meta name="author" content="Elay">
  
  <meta name="description" content="Elay">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="进程的描述与控制"/>
  <meta property="og:site_name" content="Elays&#39;Blog"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Elays&#39;Blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">Elays&#39;Blog</a></h1>
  <h2><a href="/">你是天地生的，美得超越人形</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">主页</a></li>
    
      <li><a href="/archives">所有文章</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-10-14T08:45:09.000Z"><a href="/2016/10/14/进程的描述与控制/">2016-10-14</a></time>
      
      
  
    <h1 class="title">进程的描述与控制</h1>
  

    </header>
    <div class="entry">
      
        <p><font size="5" color="orange">程序的并发执行</font><br><a id="more"></a><br>程序的并发执行：宏观上，用户看到多个程序同时执行，向前不间断地推进；微观上，任意时刻一个CPU上只能有一个程序在执行。<br>程序不加控制地并发执行的结果可能不是唯一的，举个例子：</p>
<ul>
<li>ex：counter是全局变量，初值为0，现进程p1和进程p2都对counter加1：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">进程p1：...;counter=counter+<span class="number">1</span>;...</div><div class="line">进程p2：...;counter=counter+<span class="number">1</span>;...</div></pre></td></tr></table></figure>
</li>
</ul>
<p>但是我们知道这只是高级语言的程序语句，计算机却是逐指令进行执行的，所以还需要把上诉高级语言转换成编译后的基本指令序列：（其中r1和r2是两个通用寄存器）<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">进程p1：</div><div class="line">r1=counter;      <span class="comment">//将counter对应内存的数据送寄存器r1</span></div><div class="line">r1=r1+<span class="number">1</span>;         <span class="comment">//累加1</span></div><div class="line">counter:=r1;     <span class="comment">//将r1中的累加结果送往counter对应的内存中</span></div></pre></td></tr></table></figure></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">进程p2：</div><div class="line">r2=counter;      <span class="comment">//将counter对应内存的数据送寄存器r1</span></div><div class="line">r2=r2+<span class="number">1</span>;         <span class="comment">//累加1</span></div><div class="line">counter:=r2;     <span class="comment">//将r1中的累加结果送往counter对应的内存中</span></div></pre></td></tr></table></figure>
<p>当进程p1和进程p2逐指令并发执行时，若指令执行顺序如下：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">r1=counter;</div><div class="line">r1=r1+<span class="number">1</span>;  </div><div class="line">r2=counter; </div><div class="line">r2=r2+<span class="number">1</span>; </div><div class="line">counter:=r2;</div><div class="line">counter:=r1;</div></pre></td></tr></table></figure></p>
<p>则执行后的结果是counter等于1，显然这不是我们想要的结果，原因就在于程序的并发执行上。<br>若指令顺序如下：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">r1=counter;</div><div class="line">r1=r1+<span class="number">1</span>;  </div><div class="line">counter:=r1;</div><div class="line">r2=counter; </div><div class="line">r2=r2+<span class="number">1</span>; </div><div class="line">counter:=r2;</div></pre></td></tr></table></figure></p>
<p>则执行后的结果是counter等于2。而程序并发执行时，两个程序的指令谁先执行谁后执行是不确定的，也就造成了程序并发执行时结果的不唯一性。</p>
<hr>
<p><font size="5" color="orange">进程的描述</font><br>因为并发执行的程序可能是同一个程序在不同数据集合上的执行，也可能是不同的程序在不同的数据集合上的执行，它们共享系统资源，所以在并发执行中，仅仅用程序来作为描述单位是不够的，还应该加上程序的数据集合。所以，进程破壳出生了。</p>
<p><font size="4" color="red">什么是进程</font></p>
<ul>
<li>简单的定义：进程是程序在一个数据集合上的运行过程。</li>
<li>详细的定义：进程是由正文段、用户数据段、系统数据段共同组成的一个执行环境（正文段存放被执行的机器指令；用户数据段存放进程在执行时直接进行操作的所有数据；系统数据段存放程序的运行环境，是进程实体最重要的一部分）。</li>
</ul>
<p><font size="4" color="red">进程和程序的比较</font></p>
<ul>
<li>程序是静态的，进程是动态的 。程序是一组二进制代码，而进程对应着程序执行的过程，程序执行过程中运行环境是不断变化的。</li>
<li>几个进程能并发地执行相同的程序代码，同一个进程也能顺序地执行几个程序（进程和程序是多对多的关系）。</li>
</ul>
<p><font size="4" color="red">进程控制块PCB</font><br>操作系统中那么多进程，用什么来唯一标识呢？答案是<strong>进程控制块</strong>（PCB，Process Control Block），一种操作系统管理进程所使用的数据结构。<br>进程控制块用于描述进程及控制进程运行所需的全部信息。每个进程都有PCB，它是操作系统感知进程存在的唯一标志。</p>
<p>那么进程控制块PCB中包含哪些内容呢？</p>
<ul>
<li>进程标识符信息PID（Process Identifier）<br>PCB之所以能够唯一标识某个进程，就是依赖于PCB中的进程标识符，它用于唯一标识一个进程。当然出于其它一些方面的性能考虑，PCB中同时存有本进程的标识符、其父进程的标识符、子进程的标识符。</li>
<li>处理机状态信息<br>所有进程共享处理机CPU，当一个进程需要被暂停执行，交出CPU使用权时，需要把当前进程CPU寄存器的值保存到内存中（即PCB中）（保存现场），以防止被覆盖，以便该进程再次获得CPU时，能从内存（PCB）中加载寄存器的值，恢复进程上次被暂停时的CPU环境，使进程能够从上次被中断处继续执行。<br>那么需要保存的CPU状态信息有哪些呢？<ul>
<li>通用寄存器。用户程序可以访问的寄存器，用于暂存信息。</li>
<li>指令计数器。里面存放了CPU要访问的<strong>下一条指令</strong>的地址。</li>
<li>程序状态字PSW。里面含有状态信息，如条件码、执行方式、中断屏蔽标志灯。</li>
<li>用户栈指针。每个用户进程都有一个或多个与之相关的系统栈，用于存放过程和系统调用参数及调用地址。栈指针指向该栈的栈顶。</li>
</ul>
</li>
<li>进程调度信息<ul>
<li>进程状态信息</li>
<li>进程优先级</li>
<li>进程调度所需的其他信息</li>
<li>事件</li>
</ul>
</li>
<li>进程控制信息<ul>
<li>程序和数据的地址</li>
<li>进程同步和通信机制</li>
<li>资源清单</li>
<li>链接指针</li>
</ul>
</li>
</ul>
<p><font size="4" color="red">进程的组织方式</font><br>系统中那么多进程，它们是如何联系在一起的呢？也就是说操作系统是通过怎样的方式把它们聚在一块的？<br>我们先来想想，需要把所有进程拿出来连在一起吗？这当然是很不划算的，因为有的进程是很大的，而且在地址空间上不一定连续，这样做会有很大的时间空间上的开销。上面讲了进程控制块PCB可以唯一标识一个进程，所以把PCB组织在一起就够了。</p>
<ul>
<li>链接方式<br>把系统中具有相同状态的进程的PCB用其中的链接字链接成一个队列，如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721600366.png" alt=""></li>
<li>索引方式<br>系统根据所有进程的状态，建立几张索引表，索引表的每一个表项指向一个PCB的物理块，如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721600412.png" alt=""></li>
</ul>
<p><font size="4" color="red">进程的三种基本状态</font></p>
<ul>
<li>就绪状态<br>就绪状态是进程一旦获得CPU就可以投入运行的状态。把多个处于就绪状态的进程组织在一起，形成一个或多个就绪队列。</li>
<li>执行状态<br>执行状态是进程获得CPU正在运行的状态。（单CPU系统中，任意时刻只会有一个进程处于执行状态）</li>
<li>阻塞状态<br>阻塞状态是进程由于<strong>等待资源或由于某个事件的发生而暂停执行</strong>的状态。把多个处于阻塞状态的进程组织在一起，形成一个或多个阻塞队列。</li>
</ul>
<p>【注】：新创建进程的状态一般被设置为就绪状态</p>
<p>三种基本状态之间的转换关系如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721600462.png" alt=""></p>
<hr>
<p><font size="5" color="orange">进程的控制</font></p>
<p><font size="4" color="red">进程的创建</font><br>创建新进程包括在主存中为进程分配地址空间、建立操作系统用于管理进程的数据结构（如进程控制块）等操作。<br>在Linux系统中，除了0号进程（swapper进程）外的其他进程都是由其父进程创建的。<br>调用创建新进程的系统调用来创建进程的一般步骤为：</p>
<ol>
<li>申请空白PCB</li>
<li>为新进程分配资源</li>
<li>初始化进程控制块</li>
<li>将新进程插入就绪队列</li>
</ol>
<p>Linux2.6.11中创建进程的常用系统调用有fork()。</p>
<p><font size="4" color="red">进程的阻塞</font><br>进程阻塞的简化过程大致如下：</p>
<ol>
<li>暂停进程的执行，将进程的状态改为阻塞状态</li>
<li>将进程插入相应的阻塞队列</li>
<li>转进程调度程序。重新进程进程调度</li>
</ol>
<p><font size="4" color="red">进程的唤醒</font><br>进程唤醒的简化过程大致如下：</p>
<ol>
<li>将进程从阻塞队列中移除</li>
<li>将进程状态由阻塞状态改为就绪状态</li>
<li>将进程插入就绪队列</li>
</ol>
<p><font size="4" color="red">进程的终止</font><br>进程终止的简化工程大致如下：</p>
<ol>
<li>从进程PCB中读进程状态</li>
<li>若进程正在执行状态，则终止进程的执行</li>
<li>若进程有子孙进程，则在大多数情况下需要终止其子孙进程</li>
<li>释放资源</li>
<li>将终止进程的PCB移出（从相应的PCB组织方式中移除）</li>
</ol>
<p>【注】：如果一个进程终止，它的所有子进程也被终止，这称为级联终止，通常是由操作系统进行的。在Unix系统中，如果父进程终止，那么其他所有子进程会把init进程作为它们新的父进程。</p>
<hr>
<p><font size="5" color="orange">线程（Thread）</font></p>
<p><font size="4" color="red">要线程何用？</font><br>由于进程所占的空间太大，并且独享它占有的所有资源，在进程创建、撤销、切换时，都有较大的时空开销，会降低并发程度。所以，引入了线程。让线程作为独立调度和分配的单位，线程不独立占有资源（少量基本资源还是要独占的，如程序计数器、寄存器组、栈等），而是与其他线程共享同一进程的资源，减小了系统时空开销，提高了操作系统的并发程度。</p>
<p><font size="4" color="red">什么是线程</font><br>线程只是比进程更小的执行单位，是被系统独立调度和分派的基本单位。线程和进程及其相似，包括状态、分类、调度切换等等都和进程是一样的。所以不再赘述。<br>【注】：</p>
<ul>
<li>CPU只能感知到内核级线程的存在，而感知不到用户级线程的存在。所以：<ul>
<li>对于用户级线程，CPU的调度单位还是进程；而对于内核级线程，CPU的调度单位是线程</li>
<li>当用户级线程被阻塞时，对应的整个用户级进程也会被阻塞；而内核级线程被阻塞时，对应的内核级进程不会被阻塞，OS内核可以去调度同一个内核级进程内的其他内核级线程</li>
<li>内核级线程进行系统调用只阻塞该线程，而用户级线程进行系统调用要阻塞线程所属的进程</li>
<li>内核级线程的CPU时间以线程为单位进行分配，每个线程独享一个CPU时间片；而用户级线程的CPU时间以进程为单位进行分配，同一进程里的多个线程共享一个CPU时间片</li>
</ul>
</li>
<li>由于用户级线程的调度与切换不需要OS内核的参与，所以用户级线程切换比较快；而内核级线程在调度和切换时需要进行用户态/内核态的切换，所以内核级线程切换比较慢</li>
<li>线程控制块TCB采用链接方式来组织，没有PCB的索引方式</li>
<li>进程之间的通信必须采用OS提供的进程间通信机制，而同一进程中的各线程间可以通过直接读写全局变量来进行通信，无需操作系统的参与</li>
<li>由于一个进程内的多个线程共享资源，所以一个线程对资源的任何修改，都会影响到同一个进程中的其他线程的执行环境。所以，需要对各种线程的活动进行同步，保证多个线程以互斥的方式访问临界资源，使它们互不干扰。如本文开头的加法例子，如果不对共享的临界资源counter加以访问控制，任由线程随意并发执行，则可能会导致错误结果。</li>
</ul>

      
    </div>
    <footer>
      
        
  
  <div class="categories">
    <a href="/categories/操作系统/">操作系统</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/进程的描述与控制/">进程的描述与控制</a>
  </div>

        
  <div class="addthis addthis_toolbox addthis_default_style">
    
      <a class="addthis_button_facebook_like" fb:like:layout="button_count"></a>
    
    
      <a class="addthis_button_tweet"></a>
    
    
      <a class="addthis_button_google_plusone" g:plusone:size="medium"></a>
    
    
      <a class="addthis_button_pinterest_pinit" pi:pinit:layout="horizontal"></a>
    
    <a class="addthis_counter addthis_pill_style"></a>
  </div>
  <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js"></script>

      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


<section id="comment">
  <h2 class="title">留言</h2>


 
  	   <!-- 多说评论框 start -->
 		<div class="ds-thread" data-thread-key="2016/10/14/进程的描述与控制/" data-title="进程的描述与控制" data-url="http://yoursite.com/2016/10/14/进程的描述与控制/"></div>
		<!-- 多说评论框 end -->
		<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
		<script type="text/javascript">
		var duoshuoQuery = {short_name:"popperelay"};   <!-- 替换这里的duoshuo_shortname为前面注册的shortname -->
			(function() {
				var ds = document.createElement('script');
				ds.type = 'text/javascript';ds.async = true;
				ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.unstable.js';
				ds.charset = 'UTF-8';
				(document.getElementsByTagName('head')[0] 
				 || document.getElementsByTagName('body')[0]).appendChild(ds);
			})();
			</script>
		<!-- 多说公共JS代码 end -->
 
  
</section>

</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:yoursite.com">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/C-语法/">C#语法</a><small>2</small></li>
  
    <li><a href="/categories/C/">C++</a><small>2</small></li>
  
    <li><a href="/categories/OpenGL/">OpenGL</a><small>18</small></li>
  
    <li><a href="/categories/博客配置/">博客配置</a><small>3</small></li>
  
    <li><a href="/categories/操作系统/">操作系统</a><small>4</small></li>
  
    <li><a href="/categories/数据结构/">数据结构</a><small>15</small></li>
  
    <li><a href="/categories/游戏开发/">游戏开发</a><small>1</small></li>
  
    <li><a href="/categories/计算机图形学/">计算机图形学</a><small>2</small></li>
  
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/BIOS和微机启动过程/">BIOS和微机启动过程</a><small>1</small></li>
  
    <li><a href="/tags/C-容器/">C#容器</a><small>1</small></li>
  
    <li><a href="/tags/C-IO/">C++IO</a><small>1</small></li>
  
    <li><a href="/tags/MarkDown/">MarkDown</a><small>1</small></li>
  
    <li><a href="/tags/Mathjax语法/">Mathjax语法</a><small>1</small></li>
  
    <li><a href="/tags/OS内核/">OS内核</a><small>1</small></li>
  
    <li><a href="/tags/OpenGL坐标系统/">OpenGL坐标系统</a><small>1</small></li>
  
    <li><a href="/tags/OpenGL摄像机/">OpenGL摄像机</a><small>1</small></li>
  
    <li><a href="/tags/OpenGL窗口/">OpenGL窗口</a><small>1</small></li>
  
    <li><a href="/tags/OpenGL配置/">OpenGL配置</a><small>1</small></li>
  
    <li><a href="/tags/timeTest/">timeTest</a><small>1</small></li>
  
    <li><a href="/tags/二叉树/">二叉树</a><small>1</small></li>
  
    <li><a href="/tags/光照场景/">光照场景</a><small>1</small></li>
  
    <li><a href="/tags/光照贴图/">光照贴图</a><small>1</small></li>
  
    <li><a href="/tags/关键路径/">关键路径</a><small>1</small></li>
  
    <li><a href="/tags/冯氏光照/">冯氏光照</a><small>1</small></li>
  
    <li><a href="/tags/图/">图</a><small>1</small></li>
  
    <li><a href="/tags/图形学概述/">图形学概述</a><small>1</small></li>
  
    <li><a href="/tags/图形显示系统/">图形显示系统</a><small>1</small></li>
  
    <li><a href="/tags/多说/">多说</a><small>1</small></li>
  
    <li><a href="/tags/头结点/">头结点</a><small>1</small></li>
  
    <li><a href="/tags/尾递归/">尾递归</a><small>1</small></li>
  
    <li><a href="/tags/帧同步/">帧同步</a><small>1</small></li>
  
    <li><a href="/tags/帧缓冲/">帧缓冲</a><small>1</small></li>
  
    <li><a href="/tags/常见光源/">常见光源</a><small>1</small></li>
  
    <li><a href="/tags/拓扑排序/">拓扑排序</a><small>1</small></li>
  
    <li><a href="/tags/操作系统概述/">操作系统概述</a><small>1</small></li>
  
    <li><a href="/tags/改进排序/">改进排序</a><small>1</small></li>
  
    <li><a href="/tags/文件IO/">文件IO</a><small>1</small></li>
  
    <li><a href="/tags/最小生成树/">最小生成树</a><small>1</small></li>
  
    <li><a href="/tags/最短路径/">最短路径</a><small>1</small></li>
  
    <li><a href="/tags/材质/">材质</a><small>1</small></li>
  
    <li><a href="/tags/查找/">查找</a><small>1</small></li>
  
    <li><a href="/tags/栈/">栈</a><small>1</small></li>
  
    <li><a href="/tags/树/">树</a><small>1</small></li>
  
    <li><a href="/tags/模型加载/">模型加载</a><small>1</small></li>
  
    <li><a href="/tags/模板测试/">模板测试</a><small>1</small></li>
  
    <li><a href="/tags/深度测试/">深度测试</a><small>1</small></li>
  
    <li><a href="/tags/混合/">混合</a><small>1</small></li>
  
    <li><a href="/tags/着色器/">着色器</a><small>1</small></li>
  
    <li><a href="/tags/着色器画三角形/">着色器画三角形</a><small>1</small></li>
  
    <li><a href="/tags/简单排序/">简单排序</a><small>1</small></li>
  
    <li><a href="/tags/纹理/">纹理</a><small>1</small></li>
  
    <li><a href="/tags/背面剔除/">背面剔除</a><small>1</small></li>
  
    <li><a href="/tags/进程的描述与控制/">进程的描述与控制</a><small>1</small></li>
  
    <li><a href="/tags/链表/">链表</a><small>1</small></li>
  
    <li><a href="/tags/队列/">队列</a><small>1</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2017 Elay
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>


<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</body>
</html>