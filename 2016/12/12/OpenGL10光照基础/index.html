<!DOCTYPE HTML>
<html>

<head><meta name="generator" content="Hexo 3.9.0">
	<link rel="bookmark" type="image/x-icon" href="/img/logo_miccall.png">
	 <link rel="shortcut icon" href="/img/logo_miccall.png">
	
			
    <title>
    Elays'Blog
    </title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <link rel="stylesheet" href="/css/mic_main.css">
    <link rel="stylesheet" href="/css/dropdownMenu.css">
    
    	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css">
    </noscript>
			    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<link rel="stylesheet" href="/css/prism-dark.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>
    
		
<!-- Layouts -->


<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<!--<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">-->
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/latest.js?config=TeX-MML-AM_CHTML">
</script>

	<script>
    (function(){
        if('{{ page.password }}'){
            if (prompt('请输入文章密码') !== '{{ page.password }}'){
                alert('密码错误');
                history.back();
            }
        }
    })();
	</script>

<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_undefined.css">
<link rel="stylesheet" href="/css/typo.css">
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">MICCALL</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special">
            <ul class="menu links">
			<!-- Homepage  主页  --> 
			<li>
	            <a href="/" rel="nofollow">主页</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">分类</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="/categories/C/">C#</a></li><li><a class="category-link" href="/categories/C-语法/">C#语法</a></li><li><a class="category-link" href="/categories/C/">C++</a></li><li><a class="category-link" href="/categories/C语言/">C语言</a></li><li><a class="category-link" href="/categories/Graphics/">Graphics</a></li><li><a class="category-link" href="/categories/Math/">Math</a></li><li><a class="category-link" href="/categories/OpenGL/">OpenGL</a></li><li><a class="category-link" href="/categories/Unity/">Unity</a></li><li><a class="category-link" href="/categories/博客配置/">博客配置</a></li><li><a class="category-link" href="/categories/并行计算/">并行计算</a></li><li><a class="category-link" href="/categories/操作系统/">操作系统</a></li><li><a class="category-link" href="/categories/数据结构/">数据结构</a></li><li><a class="category-link" href="/categories/毕设/">毕设</a></li><li><a class="category-link" href="/categories/游戏开发/">游戏开发</a></li><li><a class="category-link" href="/categories/计算机系统/">计算机系统</a></li><li><a class="category-link" href="/categories/设计模式/">设计模式</a></li><li><a class="category-link" href="/categories/面试/">面试</a>
	                    </li></ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/gallery/" title="图库">
		                图库
		            </a>
		        </li>
		        
		        <li>
		            <a href="/tag/" title="搜索">
		                搜索
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
		            
		                <li><a href="https://github.com/miccall" class="icon fa-github"><span class="label">GitHub</span></a></li>
		            
		            
		            
		            
			</ul>
</nav>

        <div id="main">
            <div class="post_page_title_img" style="height: 25rem;background-image: url(https://github.com/Popperelay/Photos/blob/master/Photos/OpenGL10_%E5%85%89%E7%85%A7%E5%9F%BA%E7%A1%80Phong%E6%A8%A1%E5%9E%8B_BG.jpg?raw=true);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;">
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2>OpenGL10：光照基础Phong模型</h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
				<!-- 目录 -->
				<p class="show-toc-btn" id="show-toc-btn" onclick="showToc();" style="display:none">
				<span class="btn-bg"></span>
				<span class="btn-text">文章导航</span>
				</p>
				<div id="toc-article" class="toc-article">
					<span id="toc-close" class="toc-close" title="隐藏导航" onclick="showBtn();">×</span>
					<strong class="toc-title">文章目录</strong>
					<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Phong模型"><span class="toc-text">Phong模型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#环境光Ambient-Lighting"><span class="toc-text">环境光Ambient Lighting</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#漫反射光Diffuse-Lighting"><span class="toc-text">漫反射光Diffuse Lighting</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#添加法向量"><span class="toc-text">添加法向量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#顶点着色器接收并调整法线数据"><span class="toc-text">顶点着色器接收并调整法线数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#在像素着色器中计算漫反射光"><span class="toc-text">在像素着色器中计算漫反射光</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#镜面反射光Specular-Lighting"><span class="toc-text">镜面反射光Specular Lighting</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#求反射光线的方向向量"><span class="toc-text">求反射光线的方向向量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#计算观察方向"><span class="toc-text">计算观察方向</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#计算镜面反射系数"><span class="toc-text">计算镜面反射系数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#加入镜面反射光"><span class="toc-text">加入镜面反射光</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#per-vertex和per-fragment实现光照的对比"><span class="toc-text">per-vertex和per-fragment实现光照的对比</span></a></li></ol>
			   </div>
			   <script type="text/javascript">
				function showToc(){
					var toc_article = document.getElementById("toc-article");
					var show_toc_btn = document.getElementById("show-toc-btn");
					toc_article.setAttribute("style","display:block");
					show_toc_btn.setAttribute("style","display:none");
					};
				function showBtn(){
					var toc_article = document.getElementById("toc-article");
					var show_toc_btn = document.getElementById("show-toc-btn");
					toc_article.setAttribute("style","display:none");
					show_toc_btn.setAttribute("style","display:block");
					};
			   </script>
				
                <p>要模拟现实的光照是很困难的<a id="more"></a>，例如实际光照中，一束光可以经过场景中若干物体反射后，照射到目标物体上，也可以是直接照射到目标物体上。其中经过其他物体反射后再次照射到目标物体上，这是一个递归的过程，将会无比复杂。因此实际模拟光照过程中，总是采用近似模型去接近实现光照。<br>&nbsp;</p>
<hr>
<h1 id="Phong模型"><a href="#Phong模型" class="headerlink" title="Phong模型"></a><font size="6" color="orange">Phong模型</font></h1><p>冯氏光照模型（Phong Lighting Model）就是其中很经典的一个光照模型，它由三部分光照组成：环境光+漫反射光+镜面光。如下图所示：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/OpenGL10%E5%85%89%E7%85%A7%E5%9F%BA%E7%A1%801.png?raw=true" alt><br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/OpenGL10%E5%85%89%E7%85%A7%E5%9F%BA%E7%A1%802.png?raw=true" alt></p>
<ul>
<li>环境光（ambient lighting）：环境光是场景中光源给定或者全局给定的一个光照常量，它一般很小，主要是为了模拟即使场景中没有光照时，也不是全黑的效果。场景中总有一点环境光，不至于使场景全部黑暗。例如远处的月亮、来自远处的光。</li>
<li>漫反射光：模拟一个发光物对另一个物体的方向性影响。比如面向光源的一面会比其他面更亮。它是Phong模型最显著的组成部分。</li>
<li>镜面光：模拟的是物体表面光滑时反射的高亮的光，效果就是光泽物体表面上出现的两点。镜面光反应的通常是光的颜色，而不是物体的颜色。<br>&nbsp;</li>
</ul>
<hr>
<h1 id="环境光Ambient-Lighting"><a href="#环境光Ambient-Lighting" class="headerlink" title="环境光Ambient Lighting"></a><font size="6" color="orange">环境光Ambient Lighting</font></h1><p>一个物体受到的光照可能是光源直射的，也可能是经过物体反射过来的，总之环境光来源有很多。如果我们同时考虑直射光线和非直射光线，这种情况下的算法叫做全局光照算法。可想而知，这种算法肯定是及其复杂而且昂贵的。</p>
<p>这里我们使用一种简化的的全局照明模型来表示环境光：将环境光颜色设定为一个恒定值，加到片元的最终颜色里。</p>
<p>实现起来很简单，用恒定环境光的颜色乘以一个很小的环境因子常量，再乘以受光物体本身的颜色，就是最终在环境光影响下的物体片元颜色：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#version 330 core
out vec4 color;
uniform vec3 lightColor;
uniform vec3 objectColor;
void main(){
    //环境因子
    float ambientStrength=0.3f;
    //环境光
    vec3 ambientColor=ambientStrength*lightColor;
    color=vec4(ambientColor*objectColor,1.0f);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其余程序不变，编译运行后的结果如下：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/OpenGL10%E5%85%89%E7%85%A7%E5%9F%BA%E7%A1%803.png?raw=true" alt><br>可以看到冯氏光照的环境光已经应用到受光物体上了，这个物体变得暗了一下，因为环境光弱了嘛！<br>&nbsp;</p>
<hr>
<h1 id="漫反射光Diffuse-Lighting"><a href="#漫反射光Diffuse-Lighting" class="headerlink" title="漫反射光Diffuse Lighting"></a><font size="6" color="orange">漫反射光Diffuse Lighting</font></h1><p>从文首的环境光照图可以看到，环境光本身不提供明显的光照效果，但是漫反射光会对物体产生显著的视觉影响。漫反射光使物体上与光线排布越近的片段越能从光源处获得更多的亮度。<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/OpenGL10%E5%85%89%E7%85%A7%E5%9F%BA%E7%A1%804.png?raw=true" alt><br>漫反射光强度与光线入射方向和物体表面的法向量之间的夹角$\theta$有关。当$\theta =0$时，光线垂直照射物体表面，这时获得的光照强度最大；当$\theta =90$时，光线与物体表面平行，此时光线照射不到物体，物体获得的光照强度最小；当$\theta &gt;90$后，物体表面转到转到光线背面了，此时物体表面接受不到光照。</p>
<p>所以，我们可以用光线入射方向的单位向量和单位法向量的点乘，来表示光对片元颜色的影响程度。其实也就是用两个向量之间的夹角余弦值，因为两个向量都需要标准化，取的是单位向量。</p>
<h2 id="添加法向量"><a href="#添加法向量" class="headerlink" title="添加法向量"></a><font size="5" color="red">添加法向量</font></h2><p>法向量是垂直于顶点表面的（单位）向量。由于顶点自身并没有表面（它只是空间中一个独立的点），所以我们利用顶点周围的顶点来计算出这个顶点的表面。我们可以使用叉乘来为立方体所有顶点计算出发现。但是由于3D立方体不是一个复杂的形状，所以我们可以简单的把法线数据手工添加到顶点数据中：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    //立方体各面顶点的坐标、法线
    GLfloat vertices[] = {
        //位置坐标           //法线  
        //立方体前面
         0.5f, 0.5f, 0.5f,   0, 0, 1,
         0.5f,-0.5f, 0.5f,   0, 0, 1,
        -0.5f,-0.5f, 0.5f,     0, 0, 1,
        -0.5f, 0.5f, 0.5f,   0, 0, 1,
        //立方体后
         0.5f, 0.5f,-0.5f,   0, 0,-1,
         0.5f,-0.5f,-0.5f,   0, 0,-1,
        -0.5f,-0.5f,-0.5f,   0, 0,-1,
        -0.5f, 0.5f,-0.5f,   0, 0,-1,
        //立方体上面
         0.5f, 0.5f, 0.5f,   0, 1, 0,
         0.5f, 0.5f,-0.5f,   0, 1, 0,
        -0.5f, 0.5f,-0.5f,   0, 1, 0,
        -0.5f, 0.5f, 0.5f,   0, 1, 0,
        //立方体下面
         0.5f,-0.5f, 0.5f,   0,-1, 0,
         0.5f,-0.5f,-0.5f,   0,-1, 0,
        -0.5f,-0.5f,-0.5f,   0,-1, 0,
        -0.5f,-0.5f, 0.5f,   0,-1, 0,
        //立方体右面
         0.5f, 0.5f, 0.5f,   1, 0, 0,
         0.5f, 0.5f,-0.5f,   1, 0, 0,
         0.5f,-0.5f,-0.5f,   1, 0, 0,
         0.5f,-0.5f, 0.5f,   1, 0, 0,
        //立方体左面
        -0.5f, 0.5f, 0.5f,  -1, 0, 0,
        -0.5f, 0.5f,-0.5f,  -1, 0, 0,
        -0.5f,-0.5f,-0.5f,  -1, 0, 0,
        -0.5f,-0.5f, 0.5f,  -1, 0, 0
    };
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们要把法线数据传递给顶点着色器，所以顶点着色器要增加一个法线属性：</p>
<pre class="line-numbers language-c++"><code class="language-c++">//顶点着色器
#version 330 core
layout (location=0) in vec3 position;  //顶点位置属性的位置值为0
layout (location=1) in vec3 normal;    //顶点法线属性的位置值为1
...
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当然，顶点数据变了，对顶点数据的解析也应该做出调整。由于光源颜色不受影响，所以法线数据对它无用，在光源的VAO中不必解析法线数据，只是把顶点位置属性解析的步长变为6个<code>GLfloat</code>就行：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(GLfloat), (GLvoid*)0);
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>对于受光物体，除此之外还需要解析法线数据：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(GLfloat), (GLvoid*)0);
    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(GLfloat), (GLvoid*)(3 * sizeof(GLfloat)));
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="顶点着色器接收并调整法线数据"><a href="#顶点着色器接收并调整法线数据" class="headerlink" title="顶点着色器接收并调整法线数据"></a><font size="5" color="red">顶点着色器接收并调整法线数据</font></h2><p>在顶点着色器中需要增加法线输入变量和法线输出变量（传递给像素着色器）：</p>
<pre class="line-numbers language-c++"><code class="language-c++">layout (location=1) in vec3 normal;    //顶点法线属性的位置值为1

out vec3 Normal;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>传进顶点着色器的法线数据是在主程序顶点数据中定义的，它们是局部坐标（模型坐标），但是我们的片元到光源的方向向量却是世界坐标，所以我们需要在顶点着色器中将输入的法线向量转化为世界坐标。</p>
<p>但是却不是简单的用模型矩阵乘以法线向量就可以，如<code>Normal=model*normal;</code>，因为当模型矩阵执行了不等比缩放时，法向量就不一定垂直于表面了，如下图所示：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/OpenGL10%E5%85%89%E7%85%A7%E5%9F%BA%E7%A1%805.png?raw=true" alt><br>为了修复这个问题，我们需要先把模型矩阵求逆矩阵，再转置，取左上角三行三列的矩阵部分，来和法向量相乘：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    Normal=mat3(transpose(inverse(model)))*normal;
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>顶点着色器的全部源码见后面。</p>
<p>法线的变换矩阵为什么是对模型矩阵先求逆再转置的证明如下：<br>设表面的法向量是$n$，表面里任意一个向量是$v$，法向量肯定垂直于表面里任意一个向量，所以有$n\cdot v=0$，即$n^Tv=0$。设模型变换矩阵是$M$，法线变换矩阵是$G$，那么变换之后的表面向量为$v_1=Mv$，变换之后的法向量为$n_1=Gn$。我们的目标是要保证变换之后的法线依然垂直于表面，即$n_1\cdot v_1=(Gn)\cdot (Mv)=(Gn)^TMv=n^TG^TMv=0$，所以只需要保证$G^TM=E$即可。即：$G^T=EM^{-1}=M^{-1}\Rightarrow G=(M^{-1})^T$。</p>
<h2 id="在像素着色器中计算漫反射光"><a href="#在像素着色器中计算漫反射光" class="headerlink" title="在像素着色器中计算漫反射光"></a><font size="5" color="red">在像素着色器中计算漫反射光</font></h2><p>现在每个顶点有了正确的法向量，但是我们还需要从片元指向光源的向量，所以还需要光源的位置坐标和顶点的世界坐标。</p>
<p>光源的位置坐标可以从主程序用uniform变量传到像素着色器：<br>在像素着色器中定义光源位置uniform变量：</p>
<pre class="line-numbers language-c++"><code class="language-c++">uniform vec3 lightPos;    //光源位置
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>然后在主程序中给该uniform变量赋值：</p>
<pre class="line-numbers language-c++"><code class="language-c++">        //设置uniform变量光源位置lightPos
        GLint lightPosLoc = glGetUniformLocation(lightObject.shaderProgram, "lightPos");
        glUniform3f(lightPosLoc, lightPos.x, lightPos.y, lightPos.z);

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们还需要顶点的世界坐标，可以在顶点着色器中让输入的顶点坐标乘以模型矩阵，就变成了顶点的世界坐标了，把结果输出到像素着色器就可以了。</p>
<p>现在顶点着色器中定义输出变量，用于把顶点的世界坐标传递给像素着色器：</p>
<pre class="line-numbers language-c++"><code class="language-c++">out vec3 positionInWorld;
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>然后在顶点着色器的main函数中，计算出顶点的世界坐标：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    positionInWorld=vec3(model*vec4(position,1.0f));
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>当然还需要在像素着色器中定义一个同名输入变量，来接收顶点的世界坐标：</p>
<pre class="line-numbers language-c++"><code class="language-c++">in vec3 positionInWorld;
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>在像素着色器中已经有了光源世界坐标、顶点世界坐标，我们可以用它们来计算从片元到光源的单位方向向量：</p>
<pre class="line-numbers language-c++"><code class="language-c++">vec3 lightDir=normalize(lightPos-positionInWorld); //光线入射方向的单位向量
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>当然，法向量也需要标准化，变成单位向量，再用法向量刚才的光线入射方向的单位向量点乘，就可以得到漫反射光的强度（就是两个向量夹角的余弦）：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    //计算漫反射光
    vec3 normal=normalize(Normal);  //单位法向量
    float diffuseFactor=max(dot(normal,lightDir),0.0); //漫反射光系数（两个向量夹角的余弦）
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>用漫反射光强度乘以光源颜色，就能得到漫反射光颜色了。再加上之前的环境光后，乘以片元本身的颜色，就能得到最终的片元颜色了：</p>
<pre class="line-numbers language-c++"><code class="language-c++">color=vec4((ambientColor+diffuseColor)*objectColor,1.0f);
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>到此，Phong模型中的环境光和漫反射光都搞定了。所有源码<a href="https://github.com/Popperelay/BlogCode/tree/master/LearnOpenGL10_PhongLighting/LearnOpenGL10_PhongLighting_1" target="_blank" rel="noopener">在这里</a>。</p>
<p><img src="https://github.com/Popperelay/Photos/blob/master/Photos/OpenGL10%E5%85%89%E7%85%A7%E5%9F%BA%E7%A1%806.png?raw=true" alt><br>&nbsp;</p>
<hr>
<h1 id="镜面反射光Specular-Lighting"><a href="#镜面反射光Specular-Lighting" class="headerlink" title="镜面反射光Specular Lighting"></a><font size="6" color="orange">镜面反射光Specular Lighting</font></h1><p>和环境光一样，镜面反射光也要依据光的入射向量和法向量，但是镜面光还会依据观察方向，例如玩家是从什么方向看着这个片元的：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/OpenGL10%E5%85%89%E7%85%A7%E5%9F%BA%E7%A1%807.png?raw=true" alt><br>当镜面反射光和观察方向夹角$\theta$越小时，人眼观察到的镜面光成分越明显。镜面反射系数定义为：$specFactor=\cos (\theta)^s$。其中s是镜面高光系数 ，它的值一般为2的整数幂，值越大高光部分越集中。下图是不同高光系数下的高光效果：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/OpenGL10%E5%85%89%E7%85%A7%E5%9F%BA%E7%A1%808.png?raw=true" alt></p>
<h2 id="求反射光线的方向向量"><a href="#求反射光线的方向向量" class="headerlink" title="求反射光线的方向向量"></a><font size="5" color="red">求反射光线的方向向量</font></h2><p>为了计算出夹角$\theta$，我们需要先求出反射光线方向。可以使用<code>reflect</code>函数求出：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    vec3 reflectDir=normalize(reflect(-lightDir,normal));   //反射光方向
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>该函数的第一个参数是从光源到片元的光线入射方向，所以需要把<code>lightDir</code>取反，因为之前求漫反射光的时候它是从片元指向光源的；第二个参数是法向量。当然求得的反射关系方向也需要标准化。</p>
<h2 id="计算观察方向"><a href="#计算观察方向" class="headerlink" title="计算观察方向"></a><font size="5" color="red">计算观察方向</font></h2><p>然后我们需要求出观察方向，我们这里在像素着色器中设置一个uniform变量来表示观察位置：</p>
<pre class="line-numbers language-c++"><code class="language-c++">uniform vec3 viewPos;     //观察位置
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>然后在主程序中把摄像机的位置赋值给该uniform变量：</p>
<pre class="line-numbers language-c++"><code class="language-c++">        //设置uniform变量观察位置viewPos
        GLint viewPosLoc = glGetUniformLocation(lightObject.shaderProgram, "viewPos");
        glUniform3f(viewPosLoc, mycamera.cameraPos.x, mycamera.cameraPos.y, mycamera.cameraPos.z);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>我们再用观察位置减去顶点的世界坐标，就能得到观察方向了：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    vec3 viewDir=normalize(viewPos-positionInWorld);  //观察方向
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="计算镜面反射系数"><a href="#计算镜面反射系数" class="headerlink" title="计算镜面反射系数"></a><font size="5" color="red">计算镜面反射系数</font></h2><p>有了观察方向和反射光方向，我们就可以用向量点乘求出夹角$\theta$了，从而求出镜面反射系数：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    float specularFactor=pow(max(dot(reflectDir,viewDir),0.0),32); //镜面反射系数
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这里为了不让镜面成分过于显眼，我们把镜面高光系数设置为32。</p>
<p><font size="4" color="red"></font><br>接下来我们还需要设置一个镜面反射强度，我们给镜面高光一个中等亮度颜色，设为0.5：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    float specularStrength=0.5f; //镜面反射强度
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>用这个镜面反射强度乘以镜面高光系数再乘以光源颜色，就能得到镜面反射光颜色了：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    vec3 specularColor=specularStrength*specularFactor*lightColor; //镜面反射光
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="加入镜面反射光"><a href="#加入镜面反射光" class="headerlink" title="加入镜面反射光"></a><font size="5" color="red">加入镜面反射光</font></h2><p>最后，我们需要加上Phong模型的最后一个成分：镜面反射光：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    color=vec4((ambientColor+diffuseColor+specularColor)*objectColor,1.0f);
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>环境光、漫反射光和镜面反射光的和构成了最终的光照颜色，再乘上物体本身的颜色，就是受光物体最终的输出颜色了。<br>&nbsp;</p>
<hr>
<p>到此，我们为Phong光照模型计算了全部光照元素。全部源码<a href="https://github.com/Popperelay/BlogCode/tree/master/LearnOpenGL10_PhongLighting/LearnOpenGL10_PhongLighting_2" target="_blank" rel="noopener">在这里</a>。</p>
<p>编译运行后的结果如下：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/OpenGL10%E5%85%89%E7%85%A7%E5%9F%BA%E7%A1%809.png?raw=true" alt><br>&nbsp;</p>
<hr>
<h1 id="per-vertex和per-fragment实现光照的对比"><a href="#per-vertex和per-fragment实现光照的对比" class="headerlink" title="per-vertex和per-fragment实现光照的对比"></a><font size="6" color="orange">per-vertex和per-fragment实现光照的对比</font></h1><p>我们上面的光照计算是在像素着色器中进行的，这种是基于片元计算的，称为Phong Shading（冯氏光照）。但是早期的光照着色器，开发者是在顶点着色器中实现这些光照的，这是基于顶点计算的，称为Gouraud Shading。因为顶点相比片元来说，顶点要少得多，光照的计算频率会更低，所以会更高效。然而，如果在顶点着色器中计算冯氏光照，那么除了顶点以外的其他片元，都只是根据顶点颜色插值得到自己的颜色，这种插值后的光照显得不是很真实，没有冯氏关照的那种平滑的光照效果：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/OpenGL10%E5%85%89%E7%85%A7%E5%9F%BA%E7%A1%8010.png?raw=true" alt><br>基于顶点这是的Gouraud Shading想要获得更平滑的效果，就得使用更多的顶点来加以完善，下面的图分别显示了少量顶点和大量顶点的基于顶点的关照计算效果：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/OpenGL10%E5%85%89%E7%85%A7%E5%9F%BA%E7%A1%8011.png?raw=true" alt><br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/OpenGL10%E5%85%89%E7%85%A7%E5%9F%BA%E7%A1%8012.png?raw=true" alt><br>&nbsp;</p>
<hr>
<p>参考文献：<a href="https://learnopengl.com/" target="_blank" rel="noopener">LearnOpenGL</a></p>

            </div>

            <!-- Post Comments -->
            
    <!-- 使用 DISQUS_CLICK -->
<div id="disqus-comment">
    <div id="disqus_thread"></div>

<!-- add animation -->
<style>
	.disqus_click_btn {
            line-height: 30px;
            margin: 0;
            min-width: 50px;
            padding: 0 14px;
            display: inline-block;
            font-family: "Roboto", "Helvetica", "Arial", sans-serif;
            font-size: 14px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0;
            overflow: hidden;
            will-change: box-shadow;
            transition: box-shadow .2s cubic-bezier(.4, 0, 1, 1), background-color .2s cubic-bezier(.4, 0, .2, 1), color .2s cubic-bezier(.4, 0, .2, 1);
            outline: 0;
            cursor: pointer;
            text-decoration: none;
            text-align: center;
            vertical-align: middle;
            border: 0;
            background: rgba(158, 158, 158, .2);
            box-shadow: 0 2px 2px 0 rgba(0, 0, 0, .14), 0 3px 1px -2px rgba(0, 0, 0, .2), 0 1px 5px 0 rgba(0, 0, 0, .12);
            color: #fff;
            background-color: #7EC0EE;
            text-shadow: 0
        }
</style>
	
<div class="btn_click_load" id="disqus_bt"> 
    <button class="disqus_click_btn">点击查看评论</button>
</div>

<!--
<script type="text/javascript">
$('.btn_click_load').click(function() {
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'http-miccall-tech'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    document.getElementById('disqus_bt').style.display = "none";
});
</script>
-->
<script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://yoursite.com/2016/12/12/OpenGL10光照基础/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = 'http://yoursite.com/2016/12/12/OpenGL10光照基础/'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
</script>

<script type="text/javascript">
    $('.btn_click_load').click(function() {  //click to load comments
        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document;
            var s = d.createElement('script');
            s.src = '//http-miccall-tech.disqus.com/embed.js';
            s.setAttribute('data-timestamp', + new Date());
            (d.head || d.body).appendChild(s);
        })();
        $('.btn_click_load').css('display','none');
    });
</script>
</div>
<style>
    #disqus-comment{
        background-color: #eee;
        padding: 2pc;
    }
</style>


        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
                <li>Design: <a href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
            </ul>
            
            	<span id="busuanzi_container_site_pv">2019总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			
        </div>
    </div>
</body>



 	
</html>
