<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>OpenGL6坐标变换 | Elays&#39;Blog</title>
  <meta name="author" content="Elay">
  
  <meta name="description" content="Elay">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="OpenGL6坐标变换"/>
  <meta property="og:site_name" content="Elays&#39;Blog"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Elays&#39;Blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">Elays&#39;Blog</a></h1>
  <h2><a href="/">你是天地生的，美得超越人形</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">主页</a></li>
    
      <li><a href="/archives">所有文章</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-12-02T12:31:16.000Z"><a href="/2016/12/02/OpenGL6坐标变换/">2016-12-02</a></time>
      
      
  
    <h1 class="title">OpenGL6坐标变换</h1>
  

    </header>
    <div class="entry">
      
        <p>在本文将会介绍利用矩阵来对图形进行坐标变化，如平移、旋转、缩放。<a id="more"></a>下面先简单介绍一些数学知识，更详细的可以参考[《几何变换》]一文。<br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">向量</font><br>向量的乘积分为点乘和叉乘。</p>
<p><font size="4" color="orange">向量点乘</font><br>两个向量的点乘等于它们的模和夹角余弦值的乘积：<br>$$<br>\vec x \cdot \vec y = || \vec x || \cdot ||\vec y|| \cdot \cos \theta<br>$$<br>当两个向量的夹角$\theta$是90度时，余弦值就为0，那么点乘结果就是0,；如果两个向量的夹角是0度，余弦值就为1，那么点乘结果就是两个向量模的乘积。所以，使用点乘可以很容易测试两个向量是否正交或平行。</p>
<p>上面的公式是点乘的一般数学计算，是根据向量模长和夹角来计算的。除此之外，还可以通过向量的坐标来计算，也就是向量的矩阵运算。举例如下：<br>$$<br>\begin{pmatrix}<br>\color{red}{0.6} \\<br>-\color{green}{0.8} \\<br>\color{blue}0<br>\end{pmatrix}<br>\cdot<br>\begin{pmatrix}<br>\color{red}0 \\<br>\color{green}1 \\<br>\color{blue}0<br>\end{pmatrix}<br>= (\color{red}{0.6} * \color{red}0) + (-\color{green}{0.8} * \color{green}1) + (\color{blue}0 * \color{blue}0) = -0.8<br>$$<br>点乘在计算光照的时候会非常有用。</p>
<p><font size="4" color="red">向量叉乘</font><br>向量的叉乘只在3D空间中有定义，它需要两个不平行的向量作为输入，生成一个正交于两个输入向量的第三个向量。如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148058188369.png" alt=""><br>向量叉乘只有一种计算方法，公式如下：<br>$$<br>\begin{pmatrix}<br>\color{red}{A_{x}} \\<br>\color{green}{A_{y}} \\<br>\color{blue}{A_{z}}<br>\end{pmatrix}<br>\times<br>\begin{pmatrix}<br>\color{red}{B_{x}} \\<br>\color{green}{B_{y}} \\<br>\color{blue}{B_{z}}<br>\end{pmatrix}<br>=<br>\begin{pmatrix}<br>\color{green}{A_{y}} \cdot \color{blue}{B_{z}} - \color{blue}{A_{z}} \cdot \color{green}{B_{y}} \\<br>\color{blue}{A_{z}} \cdot \color{red}{B_{x}} - \color{red}{A_{x}} \cdot \color{blue}{B_{z}} \\<br>\color{red}{A_{x}} \cdot \color{green}{B_{y}} - \color{green}{A_{y}} \cdot \color{red}{B_{x}}<br>\end{pmatrix}<br>$$</p>
<p><font size="5" color="orange">矩阵</font><br>向量其实就是矩阵列数为1的特例。但是矩阵乘法只有点乘，没有叉乘。</p>
<p><font size="4" color="red">矩阵点乘</font><br>直接看例子吧：<br>$$<br>\begin{bmatrix}<br>\color{red}4 &amp; \color{red}2 &amp; \color{red}0 \\<br>\color{green}0 &amp; \color{green}8 &amp; \color{green}1 \\<br>\color{blue}0 &amp; \color{blue}1 &amp; \color{blue}0<br>\end{bmatrix}<br>\cdot<br>\begin{bmatrix}<br>\color{red}4 &amp; \color{green}2 &amp; \color{blue}1 \\<br>\color{red}2 &amp; \color{green}0 &amp; \color{blue}4 \\<br>\color{red}9 &amp; \color{green}4 &amp; \color{blue}2<br>\end{bmatrix}<br>=<br>\begin{bmatrix} \color{red}4 \cdot \color{red}4 + \color{red}2 \cdot \color{red}2 + \color{red}0 \cdot \color{red}9 &amp; \color{red}4 \cdot \color{green}2 + \color{red}2 \cdot \color{green}0 + \color{red}0 \cdot \color{green}4 &amp; \color{red}4 \cdot \color{blue}1 + \color{red}2 \cdot \color{blue}4 + \color{red}0 \cdot \color{blue}2 \\<br>\color{green}0 \cdot \color{red}4 + \color{green}8 \cdot \color{red}2 + \color{green}1 \cdot \color{red}9 &amp; \color{green}0 \cdot \color{green}2 + \color{green}8 \cdot \color{green}0 + \color{green}1 \cdot \color{green}4 &amp; \color{green}0 \cdot \color{blue}1 + \color{green}8 \cdot \color{blue}4 + \color{green}1 \cdot \color{blue}2 \\<br>\color{blue}0 \cdot \color{red}4 + \color{blue}1 \cdot \color{red}2 + \color{blue}0 \cdot \color{red}9 &amp; \color{blue}0 \cdot \color{green}2 + \color{blue}1 \cdot \color{green}0 + \color{blue}0 \cdot \color{green}4 &amp; \color{blue}0 \cdot \color{blue}1 + \color{blue}1 \cdot \color{blue}4 + \color{blue}0 \cdot \color{blue}2<br>\end{bmatrix}<br>=<br>\begin{bmatrix}<br>20 &amp; 8 &amp; 12 \\<br>25 &amp; 4 &amp; 34 \\<br>2 &amp; 0 &amp; 4<br>\end{bmatrix}<br>$$<br>矩阵相乘不满足交换律。</p>
<p><font size="4" color="red">单位矩阵</font><br>单位矩阵是主对角线元素为1，其他元素全为0的矩阵：<br>$$<br>\begin{bmatrix}<br>\color{red}1 &amp; \color{red}0 &amp; \color{red}0 &amp; \color{red}0 \\<br>\color{green}0 &amp; \color{green}1 &amp; \color{green}0 &amp; \color{green}0 \\<br>\color{blue}0 &amp; \color{blue}0 &amp; \color{blue}1 &amp; \color{blue}0 \\<br>\color{purple}0 &amp; \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}1<br>\end{bmatrix}<br>\cdot<br>\begin{bmatrix}<br>1 \\<br>2 \\<br>3 \\<br>4<br>\end{bmatrix}<br>=<br>\begin{bmatrix}<br>\color{red}1 \cdot 1 \\<br>\color{green}1 \cdot 2 \\<br>\color{blue}1 \cdot 3 \\<br>\color{purple}1 \cdot 4<br>\end{bmatrix}<br>=<br>\begin{bmatrix}<br>1 \\<br>2 \\<br>3 \\<br>4<br>\end{bmatrix}<br>$$<br>上面是一个单位矩阵和另外一个向量的点乘，可以看到结果还是那个向量，没有发生变换。一个没有变换的变换矩阵有何用？其实单位矩阵是其他变换矩阵的起点，后面会看到其他变换矩阵和单位矩阵很像。<br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">平移变换</font><br>平移是把一个向量从一个位置平移到另一个位置。在数学上其实就是在原始向量的基础上乘了一个位移矩阵（齐次坐标下的矩阵，关于齐次坐标也可以参考前面链接的那篇文章）：<br>$$<br>\begin{bmatrix}<br>\color{red}1 &amp; \color{red}0 &amp; \color{red}0 &amp; \color{red}{T_x} \\<br>\color{green}0 &amp; \color{green}1 &amp; \color{green}0 &amp; \color{green}{T_y} \\<br>\color{blue}0 &amp; \color{blue}0 &amp; \color{blue}1 &amp; \color{blue}{T_z} \\<br>\color{purple}0 &amp; \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}1<br>\end{bmatrix}<br>\cdot<br>\begin{pmatrix}<br>x \\<br>y \\<br>z \\<br>1<br>\end{pmatrix}<br>=<br>\begin{pmatrix}<br>x + \color{red}{T_x} \\<br>y + \color{green}{T_y} \\<br>z + \color{blue}{T_z} \\<br>1<br>\end{pmatrix}<br>$$<br>那个4x4的矩阵就是我们的位移矩阵，在x、y、z方向上的位移量分别是$T_x、T_y、T_z$。<br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">旋转变换</font><br>在3D空间中旋转需要定义一个角和一个旋转轴。图形会沿着给定的旋转轴旋转指定角度。</p>
<p>对于不同的旋转轴，有不同的旋转矩阵：</p>
<p>沿x轴旋转：<br>$$<br>\begin{pmatrix}<br>\color{red}1 &amp; \color{red}0 &amp; \color{red}0 &amp; \color{red}0 \\<br>\color{green}0 &amp; \color{green}{\cos \theta} &amp; - \color{green}{\sin \theta} &amp; \color{green}0 \\<br>\color{blue}0 &amp; \color{blue}{\sin \theta} &amp; \color{blue}{\cos \theta} &amp; \color{blue}0 \\<br>\color{purple}0 &amp; \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}1<br>\end{pmatrix}<br>\cdot<br>\begin{pmatrix}<br>x \\<br>y \\<br>z \\<br>1<br>\end{pmatrix}<br>=<br>\begin{pmatrix}<br>x \\<br>\color{green}{\cos \theta} \cdot y - \color{green}{\sin \theta} \cdot z \\<br>\color{blue}{\sin \theta} \cdot y + \color{blue}{\cos \theta} \cdot z \\<br>1<br>\end{pmatrix}<br>$$</p>
<p>沿y轴旋转：<br>$$<br>\begin{pmatrix}<br>\color{red}{\cos \theta} &amp; \color{red}0 &amp; \color{red}{\sin \theta} &amp; \color{red}0 \\<br>\color{green}0 &amp; \color{green}1 &amp; \color{green}0 &amp; \color{green}0 \\<br>-\color{blue}{\sin \theta} &amp; \color{blue}0 &amp; \color{blue}{\cos \theta} &amp; \color{blue}0 \\<br>\color{purple}0 &amp; \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}1<br>\end{pmatrix}<br>\cdot<br>\begin{pmatrix}<br>x \\<br>y \\<br>z \\<br>1<br>\end{pmatrix}<br>=<br>\begin{pmatrix}<br>\color{red}{\cos \theta} \cdot x + \color{red}{\sin \theta} \cdot z \\<br>y \\<br>-\color{blue}{\sin \theta} \cdot x + \color{blue}{\cos \theta} \cdot z \\<br>1<br>\end{pmatrix}<br>$$</p>
<p>沿z轴旋转：<br>$$<br>\begin{bmatrix}<br>\color{red}{\cos \theta} &amp; - \color{red}{\sin \theta} &amp; \color{red}0 &amp; \color{red}0 \\<br>\color{green}{\sin \theta} &amp; \color{green}{\cos \theta} &amp; \color{green}0 &amp; \color{green}0 \\<br>\color{blue}0 &amp; \color{blue}0 &amp; \color{blue}1 &amp; \color{blue}0 \\<br>\color{purple}0 &amp; \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}1<br>\end{bmatrix}<br>\cdot<br>\begin{pmatrix}<br>x \\<br>y \\<br>z \\<br>1<br>\end{pmatrix}<br>=<br>\begin{pmatrix}<br>\color{red}{\cos \theta} \cdot x - \color{red}{\sin \theta} \cdot y  \\<br>\color{green}{\sin \theta} \cdot x + \color{green}{\cos \theta} \cdot y \\<br>z \<br>1<br>\end{pmatrix}<br>$$<br>【注】：</p>
<ul>
<li>当把多个旋转矩阵结合起来时，比如先沿着x轴旋转再沿着y轴旋转，这可能会导致万向节死锁（Gimbal Lock，当两个旋转轴位于同一平面时，图形/物体就不能再旋转到任意位置了，有些方向怎么也旋转不过去）。关于万向节死锁可以参考下面这个视频：<br><iframe height="498" width="510" src="http://player.youku.com/embed/XNzkyOTIyMTI=" frameborder="0" 'allowfullscreen'=""></iframe><br>避免万向节死锁的真正解决方案是使用四元素，它不仅安全，而且计算更加友好（之后的文章会讲）。<br>&nbsp;</li>
</ul>
<hr>
<p><font size="5" color="orange">缩放变换</font><br>对一个向量进行缩放变换就是对向量的长度进行缩放，而保持它的方向不变：<br>$$<br>\begin{bmatrix}<br>\color{red}{S_1} &amp; \color{red}0 &amp; \color{red}0 &amp; \color{red}0 \\ \color{green}0 &amp; \color{green}{S_2} &amp; \color{green}0 &amp; \color{green}0 \\<br>\color{blue}0 &amp; \color{blue}0 &amp; \color{blue}{S_3} &amp; \color{blue}0 \\ \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}1<br>\end{bmatrix}<br>\cdot<br>\begin{pmatrix}<br>x \\<br>y \\<br>z \\<br>1<br>\end{pmatrix}<br>=<br>\begin{pmatrix}<br>\color{red}{S_1} \cdot x \\<br>\color{green}{S_2} \cdot y \\<br>\color{blue}{S_3} \cdot z \\<br>1<br>\end{pmatrix}<br>$$<br>&nbsp;</p>
<hr>
<p>下面来看看在OpenGL中怎么用代码实现这些坐标变换。</p>
<p><font size="5" color="orange">GLM</font><br>由于高版本的OpenGL没有自带任何的矩阵和向量知识，低版本中的<code>glTranslate</code>、<code>glRotate</code>、<code>glScale</code>等等都不能再用了。所以现在我们使用GLM，它是专门为OpenGL量身定制的数学库，易于使用。</p>
<p>GLM（OpenGL Mathematics），是一个只有头文件的库，也就是我们只需包含对应的头文件就可以使用了（包含整个glm文件夹，方法参考<a href="http://popperelay.com/2016/10/18/OpenGL%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" target="_blank" rel="external">《OpenGL1：OpenGL概述及环境配置》</a>一文），不用链接和编译。</p>
<p><font size="4" color="red">坐标变换头文件</font><br>我们需要的GLM的大多数功能基本上都在下面3个头文件里：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//GLM</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLM/glm/glm.hpp&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLM/glm//gtc/matrix_transform.hpp&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLM/glm/gtc/type_ptr.hpp&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> glm;</div></pre></td></tr></table></figure></p>
<p><font size="4" color="red">定义变换矩阵</font><br>接下来需要定义坐标变换矩阵，使用<code>mat4</code>类型：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//定义变换矩阵（单位矩阵）</span></div><div class="line">mat4 transform;</div></pre></td></tr></table></figure></p>
<p>按这种方式定义好的变换矩阵，初始值一般都是单位矩阵。</p>
<p><font size="4" color="red">坐标变换（平移旋转缩放）</font><br>我们先对上一篇文章中的纹理，进行旋转变换：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//随着时间绕z轴旋转</span></div><div class="line">transform = rotate(transform, (GLfloat)glfwGetTime()*<span class="number">1.0f</span>, vec3(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>));</div></pre></td></tr></table></figure></p>
<p>使用glm命名空间里的<code>rotate</code>函数，第一个参数是旋转之前的变换矩阵；第二个参数是旋转角度（弧度值），这里旋转角度随着时间不断增加，图形将会一直旋转；第三个参数是旋转轴。</p>
<p>接下来对图形进行变换：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//平移（0.5，-0.5，0）</span></div><div class="line">transform = translate(transform, vec3(<span class="number">0.5f</span>, <span class="number">-0.5</span>f, <span class="number">0.0f</span>));</div></pre></td></tr></table></figure></p>
<p>使用glm命名空间里的<code>translate</code>函数，第一个参数是平移之前的变换矩阵（准备拿去平移的矩阵）；第二个参数是位移向量，指定了平移的方向和距离。</p>
<p><font size="4" color="red">发送变换矩阵给着色器</font><br>变换矩阵已经搞定了，但是怎么把矩阵传递给着色器呢？我们使用uniform变量来实现：在顶点着色器里定义一个mat4类型的uniform变量：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//顶点着色器</span></div><div class="line"><span class="meta">#version 330 core</span></div><div class="line">layout (location=<span class="number">0</span>) in vec3 position;  <span class="comment">//顶点位置变量的属性位置值为0</span></div><div class="line">layout (location=<span class="number">1</span>) in vec3 color;     <span class="comment">//顶点颜色变量的属性位置值为1</span></div><div class="line">layout (location=<span class="number">2</span>) in vec2 texCoord;  <span class="comment">//顶点纹理坐标的属性位置值为2</span></div><div class="line">out vec3 ourColor;</div><div class="line">out vec2 TexCoord;</div><div class="line"><span class="comment">//坐标变换矩阵</span></div><div class="line">uniform mat4 transform;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	gl_Position=transform*vec4(position,<span class="number">1.0f</span>);</div><div class="line">	ourColor=color;</div><div class="line">	TexCoord=vec2(texCoord.x,<span class="number">1</span>-texCoord.y);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在顶点着色器的main函数里，让内置变量<code>gl_Position</code>的值等于变换矩阵和顶点坐标向量的乘积，这样就能把图形顶点进行坐标变换了（注意变换矩阵必须<strong>左乘</strong>顶点坐标向量）。</p>
<p>接下里就需要在主函数里对这个mat4类型的uniform变量赋值了：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//获取uniform全局变量transform（变换矩阵）的位置</span></div><div class="line">GLint transformLoc = glGetUniformLocation(myshader.shaderProgram, <span class="string">"transform"</span>);</div><div class="line"><span class="comment">//给uniform变量（变换矩阵）赋矩阵值</span></div><div class="line">glUniformMatrix4fv(transformLoc, <span class="number">1</span>, GL_FALSE, value_ptr(transform));</div></pre></td></tr></table></figure></p>
<p>首先获取到这个mat4类型的uniform变量的位置，再使用<code>glUniformMatrix4fv</code>函数对它赋值，该函数的第一个参数是获取到的uniform变量的位置；第二个参数是要传递多少个矩阵，这里是1；第三个参数指明是否要对矩阵进行转置（交换矩阵的行和列），OpenGL通常使用列主序的矩阵布局，而GLM的矩阵默认就是列朱旭，所以不需要转置矩阵，我们填GL_FALSE。最后一个参数是真正的矩阵数据，但是GLM矩阵并不是OpenGL所希望接受的数据形式，所以需要先用GLM自带的函数<code>value_ptr</code>来进行转换。<br>&nbsp;</p>
<hr>
<p>到此，关于坐标变换的所有源码如下：<br>顶点着色器：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//顶点着色器</span></div><div class="line"><span class="meta">#version 330 core</span></div><div class="line">layout (location=<span class="number">0</span>) in vec3 position;  <span class="comment">//顶点位置变量的属性位置值为0</span></div><div class="line">layout (location=<span class="number">1</span>) in vec3 color;     <span class="comment">//顶点颜色变量的属性位置值为1</span></div><div class="line">layout (location=<span class="number">2</span>) in vec2 texCoord;  <span class="comment">//顶点纹理坐标的属性位置值为2</span></div><div class="line">out vec3 ourColor;</div><div class="line">out vec2 TexCoord;</div><div class="line"><span class="comment">//坐标变换矩阵</span></div><div class="line">uniform mat4 transform;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	gl_Position=transform*vec4(position,<span class="number">1.0f</span>);</div><div class="line">	ourColor=color;</div><div class="line">	TexCoord=vec2(texCoord.x,<span class="number">1</span>-texCoord.y);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>像素着色器、着色器类、纹理加载类等和上一篇文章<a href="http://popperelay.com/2016/11/29/OpenGL5%E7%BA%B9%E7%90%86/" target="_blank" rel="external">《OpenGL5：纹理》</a>一样，没有变化。</p>
<p>主程序：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"shader.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"TextureLoader.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="comment">//GLEW</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> GLEW_STATIC</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GL/glew.h&gt;</span></span></div><div class="line"><span class="comment">//GLFW</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLFW/glfw3.h&gt;</span></span></div><div class="line"><span class="comment">//SOIL</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;SOIL/SOIL.h&gt;</span></span></div><div class="line"><span class="comment">//GLM</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLM/glm/glm.hpp&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLM/glm//gtc/matrix_transform.hpp&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLM/glm/gtc/type_ptr.hpp&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> glm;</div><div class="line"><span class="comment">//窗口尺寸</span></div><div class="line"><span class="keyword">const</span> GLuint WIDTH = <span class="number">800</span>, HEIGHT = <span class="number">600</span>;</div><div class="line"><span class="comment">//函数声明</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">key_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">int</span> key, <span class="keyword">int</span> scancode, <span class="keyword">int</span> action, <span class="keyword">int</span> mode)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="comment">//初始化GLFW</span></div><div class="line">	glfwInit();</div><div class="line">	<span class="comment">//GLFW配置</span></div><div class="line">	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>); <span class="comment">//主版本号</span></div><div class="line">	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>); <span class="comment">//次版本号</span></div><div class="line">	glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE); <span class="comment">// 核心开发模式</span></div><div class="line">	glfwWindowHint(GLFW_RESIZABLE, GL_FALSE); <span class="comment">//窗口尺寸不可变</span></div><div class="line">											  <span class="comment">//创建能够使用GLFW函数的窗口对象（指针）</span></div><div class="line">	GLFWwindow* window = glfwCreateWindow(WIDTH, HEIGHT, <span class="string">"LearnOpenGL"</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</div><div class="line">	<span class="keyword">if</span> (window == <span class="literal">NULL</span>) &#123;</div><div class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Failed to create GLFW window"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">		glfwTerminate();</div><div class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//创建窗口环境</span></div><div class="line">	glfwMakeContextCurrent(window);</div><div class="line">	<span class="comment">//注册回调函数</span></div><div class="line">	glfwSetKeyCallback(window, key_callback);</div><div class="line">	<span class="comment">//初始化GLEW</span></div><div class="line">	glewExperimental = GL_TRUE; <span class="comment">//保证使用现代技术管理OpenGL机能</span></div><div class="line">	<span class="keyword">if</span> (glewInit() != GLEW_OK) &#123;</div><div class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Failed to initialize GLEW"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//设置渲染窗口位置大小</span></div><div class="line">	<span class="keyword">int</span> width, height;</div><div class="line">	glfwGetFramebufferSize(window, &amp;width, &amp;height);</div><div class="line">	glViewport(<span class="number">0</span>, <span class="number">0</span>, width, height);</div><div class="line">	<span class="comment">//三角形顶点的坐标、颜色、纹理坐标</span></div><div class="line">	GLfloat vertices[] = &#123;</div><div class="line">		<span class="comment">//位置坐标         //颜色           //纹理坐标</span></div><div class="line">		<span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>,  <span class="number">1.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>,  <span class="number">1.0f</span>,<span class="number">1.0f</span>,</div><div class="line">		<span class="number">0.5f</span>, <span class="number">-0.5</span>f,<span class="number">0.0f</span>,  <span class="number">0.0f</span>,<span class="number">1.0f</span>,<span class="number">0.0f</span>,  <span class="number">1.0f</span>,<span class="number">0.0f</span>,</div><div class="line">		<span class="number">-0.5</span>f,<span class="number">-0.5</span>f,<span class="number">0.0f</span>,  <span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">1.0f</span>,  <span class="number">0.0f</span>,<span class="number">0.0f</span>,</div><div class="line">		<span class="number">-0.5</span>f,<span class="number">0.5f</span>, <span class="number">0.0f</span>,  <span class="number">1.0f</span>,<span class="number">1.0f</span>,<span class="number">0.0f</span>,  <span class="number">0.0f</span>,<span class="number">1.0f</span></div><div class="line">	&#125;;</div><div class="line">	<span class="comment">//顶点索引</span></div><div class="line">	GLuint indices[] = &#123;</div><div class="line">		<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,  <span class="comment">//第一个三角形</span></div><div class="line">		<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>   <span class="comment">//第二个三角形</span></div><div class="line">	&#125;;</div><div class="line">	GLuint VAO, VBO, EBO;</div><div class="line">	<span class="comment">//生成顶点数组对象VAO，记录数据的存储和如何使用的细节信息</span></div><div class="line">	glGenVertexArrays(<span class="number">1</span>, &amp;VAO);</div><div class="line">	<span class="comment">//生顶点缓冲对象VBO，负责顶点数据的存储</span></div><div class="line">	glGenBuffers(<span class="number">1</span>, &amp;VBO);</div><div class="line">	<span class="comment">//生成索引缓冲对象EBO，负责索引数据的存储</span></div><div class="line">	glGenBuffers(<span class="number">1</span>, &amp;EBO);</div><div class="line">	<span class="comment">//给顶点数组对象绑定目标(顶点数组，不需要参数)</span></div><div class="line">	glBindVertexArray(VAO);</div><div class="line">	<span class="comment">//给顶点缓冲对象绑定目标（数组内存）</span></div><div class="line">	glBindBuffer(GL_ARRAY_BUFFER, VBO);</div><div class="line">	<span class="comment">//给索引缓冲对象绑定目标（索引数组内存）</span></div><div class="line">	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);</div><div class="line">	<span class="comment">//把顶点数据复制到显卡的缓冲内存中</span></div><div class="line">	glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</div><div class="line">	<span class="comment">//把索引数据复制到显卡的缓冲内存中</span></div><div class="line">	glBufferData(GL_ELEMENT_ARRAY_BUFFER, <span class="keyword">sizeof</span>(indices), indices, GL_STATIC_DRAW);</div><div class="line">	<span class="comment">//告诉OpenGL如何解析显存中的顶点位置属性数据</span></div><div class="line">	glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">8</span> * <span class="keyword">sizeof</span>(GLfloat), (GLvoid*)<span class="number">0</span>);</div><div class="line">	<span class="comment">//打开顶点位置属性数组</span></div><div class="line">	glEnableVertexAttribArray(<span class="number">0</span>);</div><div class="line">	<span class="comment">//告诉OpenGL如何解析显存中的顶点颜色属性数据</span></div><div class="line">	glVertexAttribPointer(<span class="number">1</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">8</span> * <span class="keyword">sizeof</span>(GLfloat), (GLvoid*)(<span class="number">3</span> * <span class="keyword">sizeof</span>(GLfloat)));</div><div class="line">	<span class="comment">//打开顶点颜色属性数组</span></div><div class="line">	glEnableVertexAttribArray(<span class="number">1</span>);</div><div class="line">	<span class="comment">//告诉OpenGL如何解析显存中的顶点纹理坐标属性数据</span></div><div class="line">	glVertexAttribPointer(<span class="number">2</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">8</span> * <span class="keyword">sizeof</span>(GLfloat), (GLvoid*)(<span class="number">6</span> * <span class="keyword">sizeof</span>(GLfloat)));</div><div class="line">	<span class="comment">//打开顶点纹理坐标属性数组</span></div><div class="line">	glEnableVertexAttribArray(<span class="number">2</span>);</div><div class="line">	<span class="comment">//解绑VBO、EBO</span></div><div class="line">	glBindBuffer(GL_ARRAY_BUFFER, <span class="number">0</span>);</div><div class="line">	<span class="comment">//解绑VAO</span></div><div class="line">	glBindVertexArray(<span class="number">0</span>);</div><div class="line"></div><div class="line">	TextureLoader textureLoader;</div><div class="line">	GLuint texture1 = textureLoader.LoadTexture(<span class="string">"container.jpg"</span>);</div><div class="line">	GLuint texture2 = textureLoader.LoadTexture(<span class="string">"awesomeface.png"</span>);</div><div class="line"></div><div class="line">	<span class="comment">//定义自定义着色器类shader的对象</span></div><div class="line">	<span class="function">shader <span class="title">myshader</span><span class="params">(<span class="string">"shader.vertex"</span>, <span class="string">"shader.fragment"</span>)</span></span>;</div><div class="line">	<span class="comment">//渲染循环（游戏循环）</span></div><div class="line">	<span class="keyword">while</span> (!glfwWindowShouldClose(window)) &#123;</div><div class="line">		glfwPollEvents(); <span class="comment">//检测是否有事件被触发（按键按下、鼠标移动）</span></div><div class="line">		glClearColor(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);</div><div class="line">		glClear(GL_COLOR_BUFFER_BIT);</div><div class="line">		<span class="comment">//激活着色器程序对象</span></div><div class="line">		myshader.Use();</div><div class="line">		<span class="comment">//激活纹理单元</span></div><div class="line">		glActiveTexture(GL_TEXTURE0);</div><div class="line">		<span class="comment">//获取uniform变量位置</span></div><div class="line">		GLint uniformLocation1 = glGetUniformLocation(myshader.shaderProgram, <span class="string">"ourTexture1"</span>);</div><div class="line">		<span class="comment">//设置采样器的值（对应纹理单元值）</span></div><div class="line">		glUniform1i(uniformLocation1, <span class="number">0</span>);</div><div class="line">		<span class="comment">//绑定纹理对象</span></div><div class="line">		glBindTexture(GL_TEXTURE_2D, texture1);</div><div class="line">		glActiveTexture(GL_TEXTURE1);</div><div class="line">		GLint uniformLocation2 = glGetUniformLocation(myshader.shaderProgram, <span class="string">"ourTexture2"</span>);</div><div class="line">		glUniform1i(uniformLocation2, <span class="number">1</span>);</div><div class="line">		glBindTexture(GL_TEXTURE_2D, texture2);</div><div class="line"></div><div class="line">		<span class="comment">//定义变换矩阵（单位矩阵）</span></div><div class="line">		mat4 transform;</div><div class="line">		<span class="comment">//平移（0.5，-0.5，0）</span></div><div class="line">		transform = translate(transform, vec3(<span class="number">0.5f</span>, <span class="number">-0.5</span>f, <span class="number">0.0f</span>));</div><div class="line">		<span class="comment">//随着时间绕z轴旋转</span></div><div class="line">		transform = rotate(transform, (GLfloat)glfwGetTime()*<span class="number">1.0f</span>, vec3(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>));</div><div class="line">		<span class="comment">//获取uniform全局变量transform（变换矩阵）的位置</span></div><div class="line">		GLint transformLoc = glGetUniformLocation(myshader.shaderProgram, <span class="string">"transform"</span>);</div><div class="line">		<span class="comment">//给uniform变量（变换矩阵）赋矩阵值</span></div><div class="line">		glUniformMatrix4fv(transformLoc, <span class="number">1</span>, GL_FALSE, value_ptr(transform));</div><div class="line">		<span class="comment">//绑定VAO，完成顶点输入初始化</span></div><div class="line">		glBindVertexArray(VAO);</div><div class="line">		<span class="comment">//绘图</span></div><div class="line">		glDrawElements(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="number">0</span>);</div><div class="line">		<span class="comment">//解绑VAO</span></div><div class="line">		glBindVertexArray(<span class="number">0</span>);</div><div class="line">		glfwSwapBuffers(window); <span class="comment">//交换颜色缓存</span></div><div class="line">	&#125;</div><div class="line">	<span class="comment">//删除VAO、VBO、EBO</span></div><div class="line">	glDeleteVertexArrays(<span class="number">1</span>, &amp;VAO);</div><div class="line">	glDeleteBuffers(<span class="number">1</span>, &amp;VBO);</div><div class="line">	glDeleteBuffers(<span class="number">1</span>, &amp;EBO);</div><div class="line">	<span class="comment">//结束CLFW，释放由GLFW分配的资源</span></div><div class="line">	glfwTerminate();</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//按键回调函数</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">key_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">int</span> key, <span class="keyword">int</span> scancode, <span class="keyword">int</span> action, <span class="keyword">int</span> mode)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (key == GLFW_KEY_ESCAPE&amp;&amp;action == GLFW_PRESS) &#123;</div><div class="line">		glfwSetWindowShouldClose(window, GL_TRUE);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>编译运行后，效果类似如下：</p>
<iframe height="498" width="510" src="https://learnopengl-cn.github.io/img/01/07/transformations.mp4" frameborder="0" 'allowfullscreen'=""></iframe>

<p>【注】：</p>
<ul>
<li><code>translate</code>、<code>rotate</code>等函数，单独作用的时候它们都是以原点（窗口中心）为基准的，即相对于原点进行平移、旋转。</li>
<li>越靠近渲染函数<code>glDrawElements</code>的变换越先执行，所以上诉渲染循环中应该是先指定旋转变换，再指定平移变换。<br>&nbsp;</li>
</ul>
<hr>
<p>参考文献：<a href="http://bullteacher.com/category/zh_learnopengl_com" target="_blank" rel="external">锦瑟无端五十弦</a></p>

      
    </div>
    <footer>
      
        
        
        
  <div class="addthis addthis_toolbox addthis_default_style">
    
      <a class="addthis_button_facebook_like" fb:like:layout="button_count"></a>
    
    
      <a class="addthis_button_tweet"></a>
    
    
      <a class="addthis_button_google_plusone" g:plusone:size="medium"></a>
    
    
      <a class="addthis_button_pinterest_pinit" pi:pinit:layout="horizontal"></a>
    
    <a class="addthis_counter addthis_pill_style"></a>
  </div>
  <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js"></script>

      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


<section id="comment">
  <h2 class="title">留言</h2>


 
  	   <!-- 多说评论框 start -->
 		<div class="ds-thread" data-thread-key="2016/12/02/OpenGL6坐标变换/" data-title="OpenGL6坐标变换" data-url="http://yoursite.com/2016/12/02/OpenGL6坐标变换/"></div>
		<!-- 多说评论框 end -->
		<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
		<script type="text/javascript">
		var duoshuoQuery = {short_name:"popperelay"};   <!-- 替换这里的duoshuo_shortname为前面注册的shortname -->
			(function() {
				var ds = document.createElement('script');
				ds.type = 'text/javascript';ds.async = true;
				ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.unstable.js';
				ds.charset = 'UTF-8';
				(document.getElementsByTagName('head')[0] 
				 || document.getElementsByTagName('body')[0]).appendChild(ds);
			})();
			</script>
		<!-- 多说公共JS代码 end -->
 
  
</section>

</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:yoursite.com">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/C-语法/">C#语法</a><small>2</small></li>
  
    <li><a href="/categories/C/">C++</a><small>2</small></li>
  
    <li><a href="/categories/OpenGL/">OpenGL</a><small>15</small></li>
  
    <li><a href="/categories/博客配置/">博客配置</a><small>3</small></li>
  
    <li><a href="/categories/操作系统/">操作系统</a><small>4</small></li>
  
    <li><a href="/categories/数据结构/">数据结构</a><small>15</small></li>
  
    <li><a href="/categories/游戏开发/">游戏开发</a><small>1</small></li>
  
    <li><a href="/categories/计算机图形学/">计算机图形学</a><small>2</small></li>
  
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/BIOS和微机启动过程/">BIOS和微机启动过程</a><small>1</small></li>
  
    <li><a href="/tags/C-容器/">C#容器</a><small>1</small></li>
  
    <li><a href="/tags/C-IO/">C++IO</a><small>1</small></li>
  
    <li><a href="/tags/MarkDown/">MarkDown</a><small>1</small></li>
  
    <li><a href="/tags/Mathjax语法/">Mathjax语法</a><small>1</small></li>
  
    <li><a href="/tags/OS内核/">OS内核</a><small>1</small></li>
  
    <li><a href="/tags/OpenGL坐标系统/">OpenGL坐标系统</a><small>1</small></li>
  
    <li><a href="/tags/OpenGL摄像机/">OpenGL摄像机</a><small>1</small></li>
  
    <li><a href="/tags/OpenGL窗口/">OpenGL窗口</a><small>1</small></li>
  
    <li><a href="/tags/OpenGL配置/">OpenGL配置</a><small>1</small></li>
  
    <li><a href="/tags/timeTest/">timeTest</a><small>1</small></li>
  
    <li><a href="/tags/二叉树/">二叉树</a><small>1</small></li>
  
    <li><a href="/tags/光照场景/">光照场景</a><small>1</small></li>
  
    <li><a href="/tags/光照贴图/">光照贴图</a><small>1</small></li>
  
    <li><a href="/tags/关键路径/">关键路径</a><small>1</small></li>
  
    <li><a href="/tags/冯氏光照/">冯氏光照</a><small>1</small></li>
  
    <li><a href="/tags/图/">图</a><small>1</small></li>
  
    <li><a href="/tags/图形学概述/">图形学概述</a><small>1</small></li>
  
    <li><a href="/tags/图形显示系统/">图形显示系统</a><small>1</small></li>
  
    <li><a href="/tags/多说/">多说</a><small>1</small></li>
  
    <li><a href="/tags/头结点/">头结点</a><small>1</small></li>
  
    <li><a href="/tags/尾递归/">尾递归</a><small>1</small></li>
  
    <li><a href="/tags/帧同步/">帧同步</a><small>1</small></li>
  
    <li><a href="/tags/常见光源/">常见光源</a><small>1</small></li>
  
    <li><a href="/tags/拓扑排序/">拓扑排序</a><small>1</small></li>
  
    <li><a href="/tags/操作系统概述/">操作系统概述</a><small>1</small></li>
  
    <li><a href="/tags/改进排序/">改进排序</a><small>1</small></li>
  
    <li><a href="/tags/文件IO/">文件IO</a><small>1</small></li>
  
    <li><a href="/tags/最小生成树/">最小生成树</a><small>1</small></li>
  
    <li><a href="/tags/最短路径/">最短路径</a><small>1</small></li>
  
    <li><a href="/tags/材质/">材质</a><small>1</small></li>
  
    <li><a href="/tags/查找/">查找</a><small>1</small></li>
  
    <li><a href="/tags/栈/">栈</a><small>1</small></li>
  
    <li><a href="/tags/树/">树</a><small>1</small></li>
  
    <li><a href="/tags/模型加载/">模型加载</a><small>1</small></li>
  
    <li><a href="/tags/模板测试/">模板测试</a><small>1</small></li>
  
    <li><a href="/tags/深度测试/">深度测试</a><small>1</small></li>
  
    <li><a href="/tags/着色器/">着色器</a><small>1</small></li>
  
    <li><a href="/tags/着色器画三角形/">着色器画三角形</a><small>1</small></li>
  
    <li><a href="/tags/简单排序/">简单排序</a><small>1</small></li>
  
    <li><a href="/tags/纹理/">纹理</a><small>1</small></li>
  
    <li><a href="/tags/进程的描述与控制/">进程的描述与控制</a><small>1</small></li>
  
    <li><a href="/tags/链表/">链表</a><small>1</small></li>
  
    <li><a href="/tags/队列/">队列</a><small>1</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2017 Elay
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>


<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</body>
</html>