<!DOCTYPE HTML>
<html>

<head>
	<link rel="bookmark"  type="image/x-icon"  href="/img/logo_miccall.png"/>
	 <link rel="shortcut icon" href="/img/logo_miccall.png">
	
			
    <title>
    Elays'Blog
    </title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="/css/mic_main.css" />
    <link rel="stylesheet" href="/css/dropdownMenu.css" />
    
    	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css" />
    </noscript>
			    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<link rel="stylesheet" href="/css/prism-dark.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>
    
		
<!-- Layouts -->


<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<!--<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">-->
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/latest.js?config=TeX-MML-AM_CHTML" async>
</script>

<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_undefined.css" />
<link rel="stylesheet" href="/css/typo.css" />
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">MICCALL</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special" >
            <ul class="menu links" >
			<!-- Homepage  主页  --> 
			<li >
	            <a href="/" rel="nofollow">主页</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">分类</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="/categories/Boost/">Boost</a></li><li><a class="category-link" href="/categories/C-语法/">C#语法</a></li><li><a class="category-link" href="/categories/C/">C++</a></li><li><a class="category-link" href="/categories/C语言/">C语言</a></li><li><a class="category-link" href="/categories/OpenGL/">OpenGL</a></li><li><a class="category-link" href="/categories/c/">c++</a></li><li><a class="category-link" href="/categories/全局光照/">全局光照</a></li><li><a class="category-link" href="/categories/博客配置/">博客配置</a></li><li><a class="category-link" href="/categories/并行计算/">并行计算</a></li><li><a class="category-link" href="/categories/操作系统/">操作系统</a></li><li><a class="category-link" href="/categories/数据结构/">数据结构</a></li><li><a class="category-link" href="/categories/毕设/">毕设</a></li><li><a class="category-link" href="/categories/游戏开发/">游戏开发</a></li><li><a class="category-link" href="/categories/游戏设计模式/">游戏设计模式</a></li><li><a class="category-link" href="/categories/计算机图形学/">计算机图形学</a></li><li><a class="category-link" href="/categories/计算机系统/">计算机系统</a></li><li><a class="category-link" href="/categories/设计模式/">设计模式</a></li><li><a class="category-link" href="/categories/调试错误集锦/">调试错误集锦</a>
	                    </ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/gallery/" title="图库">
		                图库
		            </a>
		        </li>
		        
		        <li>
		            <a href="/tag/" title="搜索">
		                搜索
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
		            
		                <li><a href="https://github.com/miccall" class="icon fa-github"><span class="label">GitHub</span></a></li>
		            
		            
		            
		            
			</ul>
</nav>

        <div id="main" >
            <div class ="post_page_title_img" style="height: 25rem;background-image: url(undefined);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;" >
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2 >OpenGL6坐标变换</h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
				<!-- <div id="toc" class="toc-article"> -->
					<!-- <strong class="toc-title">文章目录</strong> -->
					<!--  -->
				<!-- </div> -->
				
				<p class="show-toc-btn" id="show-toc-btn" onclick="showToc();" style="display:none">
				<span class="btn-bg"></span>
				<span class="btn-text">文章导航</span>
				</p>
				<div id="toc-article" class="toc-article">
					<span id="toc-close" class="toc-close" title="隐藏导航" onclick="showBtn();">×</span>
					<strong class="toc-title">文章目录</strong>
					
			   </div>
			   <script type="text/javascript">
				function showToc(){
					var toc_article = document.getElementById("toc-article");
					var show_toc_btn = document.getElementById("show-toc-btn");
					toc_article.setAttribute("style","display:block");
					show_toc_btn.setAttribute("style","display:none");
					};
				function showBtn(){
					var toc_article = document.getElementById("toc-article");
					var show_toc_btn = document.getElementById("show-toc-btn");
					toc_article.setAttribute("style","display:none");
					show_toc_btn.setAttribute("style","display:block");
					};
			   </script>
				
                <p>在本文将会介绍利用矩阵来对图形进行坐标变化，如平移、旋转、缩放。<a id="more"></a>下面先简单介绍一些数学知识，更详细的可以参考[《几何变换》]一文。<br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">向量</font><br>向量的乘积分为点乘和叉乘。</p>
<p><font size="4" color="orange">向量点乘</font><br>两个向量的点乘等于它们的模和夹角余弦值的乘积：<br>$$<br>\vec x \cdot \vec y = || \vec x || \cdot ||\vec y|| \cdot \cos \theta<br>$$<br>当两个向量的夹角$\theta$是90度时，余弦值就为0，那么点乘结果就是0,；如果两个向量的夹角是0度，余弦值就为1，那么点乘结果就是两个向量模的乘积。所以，使用点乘可以很容易测试两个向量是否正交或平行。</p>
<p>上面的公式是点乘的一般数学计算，是根据向量模长和夹角来计算的。除此之外，还可以通过向量的坐标来计算，也就是向量的矩阵运算。举例如下：<br>$$<br>\begin{pmatrix}<br>\color{red}{0.6} \\\ <br>-\color{green}{0.8} \\\ <br>\color{blue}0<br>\end{pmatrix}<br>\cdot<br>\begin{pmatrix}<br>\color{red}0 \\\\<br>\color{green}1 \\\ <br>\color{blue}0<br>\end{pmatrix}<br>= (\color{red}{0.6} * \color{red}0) + (-\color{green}{0.8} * \color{green}1) + (\color{blue}0 * \color{blue}0) = -0.8<br>$$<br>点乘在计算光照的时候会非常有用。</p>
<p><font size="4" color="red">向量叉乘</font><br>向量的叉乘只在3D空间中有定义，它需要两个不平行的向量作为输入，生成一个正交于两个输入向量的第三个向量。如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148058188369.png" alt=""><br>向量叉乘只有一种计算方法，公式如下：<br>$$<br>\begin{pmatrix}<br>\color{red}{A_{x}} \\\ <br>\color{green}{A_{y}} \\\ <br>\color{blue}{A_{z}}<br>\end{pmatrix}<br>\times<br>\begin{pmatrix}<br>\color{red}{B_{x}} \\\ <br>\color{green}{B_{y}} \\\ <br>\color{blue}{B_{z}}<br>\end{pmatrix}<br>=<br>\begin{pmatrix}<br>\color{green}{A_{y}} \cdot \color{blue}{B_{z}} - \color{blue}{A_{z}} \cdot \color{green}{B_{y}} \\\ <br>\color{blue}{A_{z}} \cdot \color{red}{B_{x}} - \color{red}{A_{x}} \cdot \color{blue}{B_{z}} \\\ <br>\color{red}{A_{x}} \cdot \color{green}{B_{y}} - \color{green}{A_{y}} \cdot \color{red}{B_{x}}<br>\end{pmatrix}<br>$$</p>
<p><font size="5" color="orange">矩阵</font><br>向量其实就是矩阵列数为1的特例。但是矩阵乘法只有点乘，没有叉乘。</p>
<p><font size="4" color="red">矩阵点乘</font><br>直接看例子吧：<br>$$<br>\begin{bmatrix}<br>\color{red}4 &amp; \color{red}2 &amp; \color{red}0 \\\ <br>\color{green}0 &amp; \color{green}8 &amp; \color{green}1 \\\\<br>\color{blue}0 &amp; \color{blue}1 &amp; \color{blue}0<br>\end{bmatrix}<br>\cdot<br>\begin{bmatrix}<br>\color{red}4 &amp; \color{green}2 &amp; \color{blue}1 \\\ <br>\color{red}2 &amp; \color{green}0 &amp; \color{blue}4 \\\ <br>\color{red}9 &amp; \color{green}4 &amp; \color{blue}2<br>\end{bmatrix}<br>=<br>\begin{bmatrix} \color{red}4 \cdot \color{red}4 + \color{red}2 \cdot \color{red}2 + \color{red}0 \cdot \color{red}9 &amp; \color{red}4 \cdot \color{green}2 + \color{red}2 \cdot \color{green}0 + \color{red}0 \cdot \color{green}4 &amp; \color{red}4 \cdot \color{blue}1 + \color{red}2 \cdot \color{blue}4 + \color{red}0 \cdot \color{blue}2 \\\\<br>\color{green}0 \cdot \color{red}4 + \color{green}8 \cdot \color{red}2 + \color{green}1 \cdot \color{red}9 &amp; \color{green}0 \cdot \color{green}2 + \color{green}8 \cdot \color{green}0 + \color{green}1 \cdot \color{green}4 &amp; \color{green}0 \cdot \color{blue}1 + \color{green}8 \cdot \color{blue}4 + \color{green}1 \cdot \color{blue}2 \\\\<br>\color{blue}0 \cdot \color{red}4 + \color{blue}1 \cdot \color{red}2 + \color{blue}0 \cdot \color{red}9 &amp; \color{blue}0 \cdot \color{green}2 + \color{blue}1 \cdot \color{green}0 + \color{blue}0 \cdot \color{green}4 &amp; \color{blue}0 \cdot \color{blue}1 + \color{blue}1 \cdot \color{blue}4 + \color{blue}0 \cdot \color{blue}2<br>\end{bmatrix}<br>=<br>\begin{bmatrix}<br>20 &amp; 8 &amp; 12 \\\ <br>25 &amp; 4 &amp; 34 \\\ <br>2 &amp; 0 &amp; 4<br>\end{bmatrix}<br>$$<br>矩阵相乘不满足交换律。</p>
<p><font size="4" color="red">单位矩阵</font><br>单位矩阵是主对角线元素为1，其他元素全为0的矩阵：<br>$$<br>\begin{bmatrix}<br>\color{red}1 &amp; \color{red}0 &amp; \color{red}0 &amp; \color{red}0 \\\\<br>\color{green}0 &amp; \color{green}1 &amp; \color{green}0 &amp; \color{green}0 \\\ <br>\color{blue}0 &amp; \color{blue}0 &amp; \color{blue}1 &amp; \color{blue}0 \\\\<br>\color{purple}0 &amp; \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}1<br>\end{bmatrix}<br>\cdot<br>\begin{bmatrix}<br>1 \\\\<br>2 \\\ <br>3 \\\ <br>4<br>\end{bmatrix}<br>=<br>\begin{bmatrix}<br>\color{red}1 \cdot 1 \\\ <br>\color{green}1 \cdot 2 \\\ <br>\color{blue}1 \cdot 3 \\\ <br>\color{purple}1 \cdot 4<br>\end{bmatrix}<br>=<br>\begin{bmatrix}<br>1 \\\ <br>2 \\\ <br>3 \\\ <br>4<br>\end{bmatrix}<br>$$<br>上面是一个单位矩阵和另外一个向量的点乘，可以看到结果还是那个向量，没有发生变换。一个没有变换的变换矩阵有何用？其实单位矩阵是其他变换矩阵的起点，后面会看到其他变换矩阵和单位矩阵很像。<br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">平移变换</font><br>平移是把一个向量从一个位置平移到另一个位置。在数学上其实就是在原始向量的基础上乘了一个位移矩阵（齐次坐标下的矩阵，关于齐次坐标也可以参考前面链接的那篇文章）：<br>$$<br>\begin{bmatrix}<br>\color{red}1 &amp; \color{red}0 &amp; \color{red}0 &amp; \color{red}{T_x} \\\\<br>\color{green}0 &amp; \color{green}1 &amp; \color{green}0 &amp; \color{green}{T_y} \\\ <br>\color{blue}0 &amp; \color{blue}0 &amp; \color{blue}1 &amp; \color{blue}{T_z} \\\ <br>\color{purple}0 &amp; \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}1<br>\end{bmatrix}<br>\cdot<br>\begin{pmatrix}<br>x \\\ <br>y \\\ <br>z \\\ <br>1<br>\end{pmatrix}<br>=<br>\begin{pmatrix}<br>x + \color{red}{T_x} \\\ <br>y + \color{green}{T_y} \\\ <br>z + \color{blue}{T_z} \\\ <br>1<br>\end{pmatrix}<br>$$<br>那个4x4的矩阵就是我们的位移矩阵，在x、y、z方向上的位移量分别是$T_x、T_y、T_z$。<br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">旋转变换</font><br>在3D空间中旋转需要定义一个角和一个旋转轴。图形会沿着给定的旋转轴旋转指定角度。</p>
<p>对于不同的旋转轴，有不同的旋转矩阵：</p>
<p>沿x轴旋转：<br>$$<br>\begin{pmatrix}<br>\color{red}1 &amp; \color{red}0 &amp; \color{red}0 &amp; \color{red}0 \\\\<br>\color{green}0 &amp; \color{green}{\cos \theta} &amp; - \color{green}{\sin \theta} &amp; \color{green}0 \\\ <br>\color{blue}0 &amp; \color{blue}{\sin \theta} &amp; \color{blue}{\cos \theta} &amp; \color{blue}0 \\\ <br>\color{purple}0 &amp; \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}1<br>\end{pmatrix}<br>\cdot<br>\begin{pmatrix}<br>x \\\ <br>y \\\ <br>z \\\ <br>1<br>\end{pmatrix}<br>=<br>\begin{pmatrix}<br>x \\\ <br>\color{green}{\cos \theta} \cdot y - \color{green}{\sin \theta} \cdot z \\\ <br>\color{blue}{\sin \theta} \cdot y + \color{blue}{\cos \theta} \cdot z \\\ <br>1<br>\end{pmatrix}<br>$$</p>
<p>沿y轴旋转：<br>$$<br>\begin{pmatrix}<br>\color{red}{\cos \theta} &amp; \color{red}0 &amp; \color{red}{\sin \theta} &amp; \color{red}0 \\\ <br>\color{green}0 &amp; \color{green}1 &amp; \color{green}0 &amp; \color{green}0 \\\ <br>-\color{blue}{\sin \theta} &amp; \color{blue}0 &amp; \color{blue}{\cos \theta} &amp; \color{blue}0 \\\ <br>\color{purple}0 &amp; \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}1<br>\end{pmatrix}<br>\cdot<br>\begin{pmatrix}<br>x \\\ <br>y \\\ <br>z \\\ <br>1<br>\end{pmatrix}<br>=<br>\begin{pmatrix}<br>\color{red}{\cos \theta} \cdot x + \color{red}{\sin \theta} \cdot z \\\ <br>y \\\ <br>-\color{blue}{\sin \theta} \cdot x + \color{blue}{\cos \theta} \cdot z \\\ <br>1<br>\end{pmatrix}<br>$$</p>
<p>沿z轴旋转：<br>$$<br>\begin{bmatrix}<br>\color{red}{\cos \theta} &amp; - \color{red}{\sin \theta} &amp; \color{red}0 &amp; \color{red}0 \\\ <br>\color{green}{\sin \theta} &amp; \color{green}{\cos \theta} &amp; \color{green}0 &amp; \color{green}0 \\\ <br>\color{blue}0 &amp; \color{blue}0 &amp; \color{blue}1 &amp; \color{blue}0 \\\ <br>\color{purple}0 &amp; \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}1<br>\end{bmatrix}<br>\cdot<br>\begin{pmatrix}<br>x \\\ <br>y \\\ <br>z \\\ <br>1<br>\end{pmatrix}<br>=<br>\begin{pmatrix}<br>\color{red}{\cos \theta} \cdot x - \color{red}{\sin \theta} \cdot y  \\\ <br>\color{green}{\sin \theta} \cdot x + \color{green}{\cos \theta} \cdot y \\\ <br>z \ <br>1<br>\end{pmatrix}<br>$$<br>【注】：</p>
<ul>
<li>当把多个旋转矩阵结合起来时，比如先沿着x轴旋转再沿着y轴旋转，这可能会导致万向节死锁（Gimbal Lock，当两个旋转轴位于同一平面时，图形/物体就不能再旋转到任意位置了，有些方向怎么也旋转不过去）。关于万向节死锁可以参考下面这个视频：<br><iframe height="498" width="510" src="http://player.youku.com/embed/XNzkyOTIyMTI=" frameborder="0" 'allowfullscreen'=""></iframe><br>避免万向节死锁的真正解决方案是使用四元素，它不仅安全，而且计算更加友好（之后的文章会讲）。<br>&nbsp;</li>
</ul>
<hr>
<p><font size="5" color="orange">缩放变换</font><br>对一个向量进行缩放变换就是对向量的长度进行缩放，而保持它的方向不变：<br>$$<br>\begin{bmatrix}<br>\color{red}{S_1} &amp; \color{red}0 &amp; \color{red}0 &amp; \color{red}0 \\\ \color{green}0 &amp; \color{green}{S_2} &amp; \color{green}0 &amp; \color{green}0 \\\ <br>\color{blue}0 &amp; \color{blue}0 &amp; \color{blue}{S_3} &amp; \color{blue}0 \\\ \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}1<br>\end{bmatrix}<br>\cdot<br>\begin{pmatrix}<br>x \\\ <br>y \\\ <br>z \\\ <br>1<br>\end{pmatrix}<br>=<br>\begin{pmatrix}<br>\color{red}{S_1} \cdot x \\\ <br>\color{green}{S_2} \cdot y \\\ <br>\color{blue}{S_3} \cdot z \\\ <br>1<br>\end{pmatrix}<br>$$<br>&nbsp;</p>
<hr>
<p>下面来看看在OpenGL中怎么用代码实现这些坐标变换。</p>
<p><font size="5" color="orange">GLM</font><br>由于高版本的OpenGL没有自带任何的矩阵和向量知识，低版本中的<code>glTranslate</code>、<code>glRotate</code>、<code>glScale</code>等等都不能再用了。所以现在我们使用GLM，它是专门为OpenGL量身定制的数学库，易于使用。</p>
<p>GLM（OpenGL Mathematics），是一个只有头文件的库，也就是我们只需包含对应的头文件就可以使用了（包含整个glm文件夹，方法参考<a href="http://popperelay.com/2016/10/18/OpenGL%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" target="_blank" rel="external">《OpenGL1：OpenGL概述及环境配置》</a>一文），不用链接和编译。</p>
<p><font size="4" color="red">坐标变换头文件</font><br>我们需要的GLM的大多数功能基本上都在下面3个头文件里：</p>
<pre class="line-numbers language-c++"><code class="language-c++">//GLM
#include <GLM/glm/glm.hpp>
#include <GLM/glm//gtc/matrix_transform.hpp>
#include <GLM/glm/gtc/type_ptr.hpp>
using namespace glm;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><font size="4" color="red">定义变换矩阵</font><br>接下来需要定义坐标变换矩阵，使用<code>mat4</code>类型：</p>
<pre class="line-numbers language-c++"><code class="language-c++">        //定义变换矩阵（单位矩阵）
        mat4 transform;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>按这种方式定义好的变换矩阵，初始值一般都是单位矩阵。</p>
<p><font size="4" color="red">坐标变换（平移旋转缩放）</font><br>我们先对上一篇文章中的纹理，进行旋转变换：</p>
<pre class="line-numbers language-c++"><code class="language-c++">        //随着时间绕z轴旋转
        transform = rotate(transform, (GLfloat)glfwGetTime()*1.0f, vec3(0.0f, 0.0f, 1.0f));
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>使用glm命名空间里的<code>rotate</code>函数，第一个参数是旋转之前的变换矩阵；第二个参数是旋转角度（弧度值），这里旋转角度随着时间不断增加，图形将会一直旋转；第三个参数是旋转轴。</p>
<p>接下来对图形进行变换：</p>
<pre class="line-numbers language-c++"><code class="language-c++">        //平移（0.5，-0.5，0）
        transform = translate(transform, vec3(0.5f, -0.5f, 0.0f));
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>使用glm命名空间里的<code>translate</code>函数，第一个参数是平移之前的变换矩阵（准备拿去平移的矩阵）；第二个参数是位移向量，指定了平移的方向和距离。</p>
<p><font size="4" color="red">发送变换矩阵给着色器</font><br>变换矩阵已经搞定了，但是怎么把矩阵传递给着色器呢？我们使用uniform变量来实现：在顶点着色器里定义一个mat4类型的uniform变量：</p>
<pre class="line-numbers language-c++"><code class="language-c++">//顶点着色器
#version 330 core
layout (location=0) in vec3 position;  //顶点位置变量的属性位置值为0
layout (location=1) in vec3 color;     //顶点颜色变量的属性位置值为1
layout (location=2) in vec2 texCoord;  //顶点纹理坐标的属性位置值为2
out vec3 ourColor;
out vec2 TexCoord;
//坐标变换矩阵
uniform mat4 transform;
void main(){
    gl_Position=transform*vec4(position,1.0f);
    ourColor=color;
    TexCoord=vec2(texCoord.x,1-texCoord.y);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在顶点着色器的main函数里，让内置变量<code>gl_Position</code>的值等于变换矩阵和顶点坐标向量的乘积，这样就能把图形顶点进行坐标变换了（注意变换矩阵必须<strong>左乘</strong>顶点坐标向量）。</p>
<p>接下里就需要在主函数里对这个mat4类型的uniform变量赋值了：</p>
<pre class="line-numbers language-c++"><code class="language-c++">        //获取uniform全局变量transform（变换矩阵）的位置
        GLint transformLoc = glGetUniformLocation(myshader.shaderProgram, "transform");
        //给uniform变量（变换矩阵）赋矩阵值
        glUniformMatrix4fv(transformLoc, 1, GL_FALSE, value_ptr(transform));
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>首先获取到这个mat4类型的uniform变量的位置，再使用<code>glUniformMatrix4fv</code>函数对它赋值，该函数的第一个参数是获取到的uniform变量的位置；第二个参数是要传递多少个矩阵，这里是1；第三个参数指明是否要对矩阵进行转置（交换矩阵的行和列），OpenGL通常使用列主序的矩阵布局，而GLM的矩阵默认就是列朱旭，所以不需要转置矩阵，我们填GL_FALSE。最后一个参数是真正的矩阵数据，但是GLM矩阵并不是OpenGL所希望接受的数据形式，所以需要先用GLM自带的函数<code>value_ptr</code>来进行转换。<br>&nbsp;</p>
<hr>
<p>到此，关于坐标变换的所有源码<a href="https://github.com/Popperelay/BlogCode/tree/master/LearnOpenGL6_Transform" target="_blank" rel="external">在这里</a>。</p>
<p>编译运行后，效果类似如下：</p>
<iframe height="498" width="510" src="https://learnopengl-cn.github.io/img/01/07/transformations.mp4" frameborder="0" 'allowfullscreen'=""></iframe>

<p>【注】：</p>
<ul>
<li><code>translate</code>、<code>rotate</code>等函数，单独作用的时候它们都是以原点（窗口中心）为基准的，即相对于原点进行平移、旋转。</li>
<li>越靠近渲染函数<code>glDrawElements</code>的变换越先执行，所以上诉渲染循环中应该是先指定旋转变换，再指定平移变换。<br>&nbsp;</li>
</ul>
<hr>
<p>参考文献：<a href="https://learnopengl.com/" target="_blank" rel="external">LearnOpenGL</a></p>

            </div>

            <!-- Post Comments -->
            
    <!-- 使用 DISQUS_CLICK -->
<div id="disqus-comment">
    <div id="disqus_thread"></div>

<!-- add animation -->
<style>
	.disqus_click_btn {
            line-height: 30px;
            margin: 0;
            min-width: 50px;
            padding: 0 14px;
            display: inline-block;
            font-family: "Roboto", "Helvetica", "Arial", sans-serif;
            font-size: 14px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0;
            overflow: hidden;
            will-change: box-shadow;
            transition: box-shadow .2s cubic-bezier(.4, 0, 1, 1), background-color .2s cubic-bezier(.4, 0, .2, 1), color .2s cubic-bezier(.4, 0, .2, 1);
            outline: 0;
            cursor: pointer;
            text-decoration: none;
            text-align: center;
            vertical-align: middle;
            border: 0;
            background: rgba(158, 158, 158, .2);
            box-shadow: 0 2px 2px 0 rgba(0, 0, 0, .14), 0 3px 1px -2px rgba(0, 0, 0, .2), 0 1px 5px 0 rgba(0, 0, 0, .12);
            color: #fff;
            background-color: #7EC0EE;
            text-shadow: 0
        }
</style>
	
<div class="btn_click_load" id="disqus_bt"> 
    <button class="disqus_click_btn">点击查看评论</button>
</div>

<!--
<script type="text/javascript">
$('.btn_click_load').click(function() {
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'http-miccall-tech'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    document.getElementById('disqus_bt').style.display = "none";
});
</script>
-->
<script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://yoursite.com/2016/12/02/OpenGL6坐标变换/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = 'http://yoursite.com/2016/12/02/OpenGL6坐标变换/'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
</script>

<script type="text/javascript">
    $('.btn_click_load').click(function() {  //click to load comments
        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document;
            var s = d.createElement('script');
            s.src = '//http-miccall-tech.disqus.com/embed.js';
            s.setAttribute('data-timestamp', + new Date());
            (d.head || d.body).appendChild(s);
        })();
        $('.btn_click_load').css('display','none');
    });
</script>
</div>
<style>
    #disqus-comment{
        background-color: #eee;
        padding: 2pc;
    }
</style>


        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
                <li>Design: <a href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
            </ul>
            
            	<span id="busuanzi_container_site_pv">2018总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			
        </div>
    </div>
</body>



 	
</html>
