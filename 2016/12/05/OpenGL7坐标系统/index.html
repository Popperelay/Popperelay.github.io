<!DOCTYPE HTML>
<html>

<head>
	<link rel="bookmark"  type="image/x-icon"  href="/img/logo_miccall.png"/>
	 <link rel="shortcut icon" href="/img/logo_miccall.png">
	
			
    <title>
    Elays'Blog
    </title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="/css/mic_main.css" />
    <link rel="stylesheet" href="/css/dropdownMenu.css" />
    
    	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css" />
    </noscript>

			    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<link rel="stylesheet" href="/css/prism.css" type="text/css"></head>
    
		
<!-- Layouts -->



<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_funky.css" />
<link rel="stylesheet" href="/css/typo.css" />
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">MICCALL</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special" >
            <ul class="menu links" >
			<!-- Homepage  主页  --> 
			<li >
	            <a href="/" rel="nofollow">主页</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">分类</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="/categories/C-语法/">C#语法</a></li><li><a class="category-link" href="/categories/C/">C++</a></li><li><a class="category-link" href="/categories/C语言/">C语言</a></li><li><a class="category-link" href="/categories/OpenGL/">OpenGL</a></li><li><a class="category-link" href="/categories/c/">c++</a></li><li><a class="category-link" href="/categories/博客配置/">博客配置</a></li><li><a class="category-link" href="/categories/操作系统/">操作系统</a></li><li><a class="category-link" href="/categories/数据结构/">数据结构</a></li><li><a class="category-link" href="/categories/毕设/">毕设</a></li><li><a class="category-link" href="/categories/游戏开发/">游戏开发</a></li><li><a class="category-link" href="/categories/游戏设计模式/">游戏设计模式</a></li><li><a class="category-link" href="/categories/计算机图形学/">计算机图形学</a></li><li><a class="category-link" href="/categories/设计模式/">设计模式</a></li><li><a class="category-link" href="/categories/调试错误集锦/">调试错误集锦</a>
	                    </ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/about/" title="简历">
		                简历
		            </a>
		        </li>
		        
		        <li>
		            <a href="/group/" title="团队">
		                团队
		            </a>
		        </li>
		        
		        <li>
		            <a href="/gallery/" title="图库">
		                图库
		            </a>
		        </li>
		        
		        <li>
		            <a href="/tag/" title="标签">
		                标签
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
		            
		                <li><a href="https://github.com/miccall" class="icon fa-github"><span class="label">GitHub</span></a></li>
		            
		            
		            
		            
			</ul>
</nav>

        <div id="main" >
            <div class ="post_page_title_img" style="height: 25rem;background-image: url(undefined);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;" >
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2 >OpenGL7：坐标系统</h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
                <p>OpenGL希望每次顶点着色器运行后，我们所有可见的顶点都化为标准化设备坐标（NDC，normalized device coordinate）。<a id="more"></a>也就是说，每个顶点的x、y、z坐标都应该在-1.0到1.0之间，超出这个坐标范围的顶点都将不可见。我们通常会自己设定一个可见的坐标范围，之后再顶点着色器中将这些坐标变换为标准化设备坐标，然后将这些标准化设备坐标传入光栅器（Rasterizer），把它们变换为屏幕上的二维坐标/像素。<br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">坐标转化过程</font></p>
<p><font size="4" color="red">坐标转化过程中的坐标系统</font><br>物体的顶点在最终化为屏幕坐标之前，还会被变换到多个坐标系统。这是因为，在中间的那些特定的坐标系统里，一些操作或运算更加方便和容易。其实这个过程类似现实世界的物体被我们看到的过程：最开始由物体出发，物体上可能有各种细节需要去研究，这时候是在局部空间（或称物体空间）；接着这个物体肯定是和我们身处在一个世界里，它身边可能还有其他物体，这时候是在世界空间；但是并不是世界里所有的物体都能被我们看到，只有在我们眼睛前方的物体，才能被我们看到，脑后的东西肯定看不到了，我们眼睛视角前方的世界范围都是观察空间（或称视觉空间）；但是受视力限制，在我们眼睛前方的世界（观察空间）不是都能看得到，我们只能看到目力所能及的观察空间，眼睛前方的视觉范围就是裁剪空间，即使在我们眼睛前方，但太近或者太远不在我们的视力范围内也是看不到的，处在裁剪空间里的物体会通过反射光投影到我们的视网膜上（根据是点光线/点光源还是平行光线/太阳光，可以分为透视投影和正交投影）；在视网膜上的投影最终会转换为我们脑海中的事物，在我们脑海中形成一个世界，这就是屏幕空间。</p>
<p>总之，一个顶点在被转换为屏幕像素之前需要经历5个坐标系统：</p>
<ol>
<li>局部空间（Local Space，或称物体空间Object Space）</li>
<li>世界空间（World Space）</li>
<li>观察空间（View Space，或称视觉空间Eye Space）</li>
<li>裁剪空间（Clip Space）</li>
<li>屏幕空间（Screen Space）</li>
</ol>
<p><font size="4" color="red">坐标转化过程中的变换矩阵</font><br>流程图如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148075489991.png" alt=""><br>为了将坐标从一个坐标系转化到另一个坐标系，我们需要用到几个变换矩阵，最重要的是模型矩阵（Model）、观察矩阵（View）、投影矩阵（Projection）。我们的顶点坐标起始于局部空间，在这里它们称为局部坐标；通过模型矩阵的平移旋转缩放之后，物体被放在世界里的不同位置上，变成世界坐标；接下来会把世界坐标通过观察矩阵转化为观察坐标，使得每个坐标都是从摄像机或者说观察者的角度进行观察的；接着在观察坐标会通过投影矩阵转化为裁剪坐标，只有那些在-1.0到1.0之间的裁剪坐标，才会被裁剪出来有机会出现在屏幕上；最后，需要把裁剪坐标通过视口变换（Viewport Transform）转化为屏幕坐标，视口变换将位于-1.0到1.0范围内的坐标变换到由<code>glViewport</code>函数所定义的坐标范围内。最后变换出来的坐标将会送到光栅器，将其转化为像素。</p>
<p>我们之所以将顶点转化到各个不同的空间，是因为有些操作在特定的坐标系统中才有意义且更方便。例如，当需要对物体内部进行修改时，在局部空间中来操作会更方便；当需要对一个物体做出相对于其他物体的操作时，在世界空间中会更方便，等等。当然，也可以定义一个直接从局部坐标转化到裁剪坐标的变换矩阵，但是那样会失去很多灵活性。<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148076836196.png" alt=""><br>图中左边的过程包括模型变换、观察变换、投影变换，这些变换由用户根据需要自行指定，这些变换都在顶点着色器中完成；而图中右边的过程包括透视除法、视口变换，都是由OpenGL自动执行的，在顶点着色器处理后的阶段执行。<br>&nbsp;</p>
<hr>
<p>接下里我们更详细地讨论各个坐标系统和变换矩阵。</p>
<p><font size="5" color="orange">局部空间</font><br>局部空间是指物体所在的坐标空间，即对象最开始所在的地方。比如在建模软件（如3Dmax）中创建了一个立方体，在建模软件里的这个立方体的所有顶点都是在局部空间里。<br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">世界空间</font><br>如果将我们在建模软件中创建的所有的物体，导入到我们的程序当中，它们可能会全挤在世界的原点（0,0,0）上，这可能并不是我们想要的结果。我们想要为每一个物体定义一个位置。让它们放在世界中的不同位置上。世界坐标就是顶点在（游戏）世界里的坐标。<br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">模型变换</font><br>物体的坐标从局部空间转化到世界空间，是由模型矩阵来实现的。模型矩阵是一种变换矩阵，其实说白了就是<a href="http://popperelay.com/2016/12/02/OpenGL6%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2/" target="_blank" rel="external">《OpenGL6：坐标变换》</a>一文中的变换矩阵，它通过对物体进行平移、旋转、缩放来将物体放在世界的不同位置或朝向上。可以想象现在在建模软件里创建了一个茶壶，但是它在局部空间中太大了，我们先将它缩小，把它位移到大世界里，然后围绕着旋转一下，以搭配附近的茶壶：<br>下图是在模型空间中定义的茶壶模型：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148076831958.png" alt=""><br>茶壶通过模型变换，转化到世界坐标系中：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/14807683201.png" alt=""><br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">观察空间</font><br>观察空间经常被人们称之为OpenGL的摄像机（所以也称摄像机空间Camera Space或视觉空间Eye Space）。观察空间是将世界坐标转化为用户眼睛前方空间的坐标而产生的结果，在观察空间里的物体只是留待我们去观察的，不一定能被我们看到，得在我们视觉范围内才行。</p>
<p>OpenGL中的相机默认位于原点，指向-Z轴，通常不移动相机（因为OpenGL中实际上没有摄像机，是虚构的），而是以相反的方式来调整场景中的物体，从而达到相同的效果。例如一个物体中心位于原点，照相机也位于初始位置原点，方向指向-Z轴。为了对物体的+Z面成像，一种方式是将照相机向+Z方向后退，仍指向-Z轴；另一种方式是照相机不动，让物体沿着-Z方向移动。OpenGL采用第二种方式。<br>【注】：</p>
<ul>
<li>其实无论是眼睛还是摄像机，都是假想的概念，是为了便于计算而引入的，并不真实存在。</li>
</ul>
<p>OpenGL观察空间（或者说OpenGL的照相机）采用的是右手坐标系。想象屏幕处于三个轴的中心，则z轴穿过你的屏幕指向你。坐标系画起来如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148083756886.png" alt=""><br>之所以叫做右手坐标系，看下图：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148083781285.png" alt=""><br>可以看到大拇指指向正x轴方向，食指指向正y轴方向，中指指向正z轴方向，正好符合右手坐标系（如果用左手来做这个动作，会发现z轴的方向是相反的，这个叫做左手坐标系，它被DirectX广泛使用）。<br>【注】：</p>
<ul>
<li>OpenGL提供给用户的是右手坐标系，即局部坐标系、世界坐标系、观察坐标系等是一个右手坐标系，但是标准化设备坐标系中OpenGL使用的实际上是左手坐标系，因为投影矩阵交换了左右手。<br>&nbsp;</li>
</ul>
<hr>
<p><font size="5" color="orange">观察变换</font><br>观察变换是把世界坐标变化到观察坐标。</p>
<p>在世界坐标系中指定相机的位置、指向的目标位置（相机朝向）以及相机的正上方向（viewUp）（第三个方向轴可以由前两个方向叉乘得到）可以构造出一个观察坐标系，在通过观察矩阵，就可以将物体坐标从世界坐标系转化到观察坐标系。</p>
<p>观察矩阵是一系列平移和旋转的组合，用于平移/旋转场景从而使得特定的对象被变换到摄像机的前方。</p>
<p>观察变化前后图示如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148077063103.png" alt=""><br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">裁剪空间</font><br>在一个顶点着色器运行的最后，OpenGL期望所有要显示的顶点的观察坐标都落在一个特定的范围内，任何在这个范围之外的点都不会显示，会被裁剪掉。这个范围就是裁剪空间，通常是一个视见体（简单说就是一个观察空间里的一个棱台）。</p>
<p>根据投影方式不同，裁剪空间（视见体）可分为以下两种：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148077131993.png" alt=""><br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">投影变换</font><br>投影变换将顶点坐标从观察空间变化到裁剪空间。为了实现投影变换，我们需要定义一个投影矩阵（Projection Matrix），它会把观察坐标变换为裁剪坐标。所有在视见体内的坐标被映射为裁剪坐标后，其x、y、z坐标分量的值都会在-w和w（第四个坐标分量）之间。而在视见体外的点的坐标分量不都会在-w到w之间，所以会被裁剪掉。比如投影矩阵指定的范围时-1000到1000，那么坐标（1250,500,700）将是不可见的，因为他的x坐标超出了范围，最后它被转化为了一个大于w的裁剪坐标分量，所以被裁剪掉了。<br>【注】：</p>
<ul>
<li>如果是像三角形这种基本图元，如果它的一部分超出了裁剪范围，则OpenGL会重新构建这个三角形为一个或多个三角形，让它在裁剪范围内的那部分能够显示出来。</li>
</ul>
<p>投影方式不同，就会有不同的投影矩阵。</p>
<p><font size="4" color="red">正交投影</font><br>正交投影的投影线相互平行，且正交与投影面。它的视见体是一个立方体：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148077209888.png" alt=""><br>需要指定这个视见体的宽、高、近平面和远平面，任何在视见体之外的坐标都会被裁减掉。在视见体内部的所有坐标都会被映射为标准化设备坐标。</p>
<p>使用glm命名空间里的<code>ortho</code>函数来创建一个正交投影矩阵：</p>
<pre class=" language-c++"><code class="language-c++">mat4 proj = ortho(0.0f, 800.0f, 0.0f, 600.0f, 0.1f, 100.0f);
</code></pre>
<p>前两个参数指定了视见体的最左和最右值，第三四个参数指定了视见体的最上下和最上值，第五六个参数指定了近平面和远平面的距离。这个投影矩阵会将处于这些x、y、z值范围内的坐标变换为标准化设备坐标。<br>【注】：</p>
<ul>
<li>正交投影下顶点的w坐标值是1</li>
</ul>
<p><font size="4" color="red">透视投影</font><br>透视投影的投影线汇于一点，会造成近大远小的透视效果：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148077209937.png" alt=""><br>透视投影的视见体是一个四棱台：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148077210356.png" alt=""><br>需要指定这个视见体的视野、宽高比、近平面和远平面，任何在视见体之外的坐标都会被裁减掉。在视见体内部的所有坐标都会被映射为标准化设备坐标。</p>
<p>使用glm命名空间里的<code>perspective</code>函数来创建一个透视投影矩阵：</p>
<pre class=" language-c++"><code class="language-c++">mat4 proj = perspective(45.0f, (float)width/(float)height, 0.1f, 100.0f);
</code></pre>
<p>该函数的第一个参数指定了视野fov（field of view）的值，并以此设置了观察空间的大小（如果想要一个真实的观察效果，它的值通常是45.0f，如果想要一个末日风格的结果可以把它设得稍大点）；第二个参数指定了视口的宽高比，由视口的宽除以高所得；第三四个参数指定了近平面和远平面的距离。所有在近平面和远平面内且处于视见体内的顶点都会被渲染。<br>【注】：</p>
<ul>
<li>如果把透视矩阵的近平面值设置得太大（比如10.0f），OpenGL会将靠近摄像机的坐标（在0.0f到10.0f之间）都裁减掉，这会导致一个我们在游戏中很熟悉的视觉效果：在太过靠近一个物体的时候，视线会直接穿过去。</li>
</ul>
<p>除此之外，透视投影矩阵还修改了每个顶点坐标的w值，离观察者越远的顶点啊坐标w分量越大，从而使得在做透视除法后，产生近大远小的效果。</p>
<p><font size="4" color="red">透视除法</font><br>注意透视除法不在投影变换的范畴内，它是在投影变换之后，由OpenGL自动进行透视除法和裁剪。投影变换后的坐标范围是在-w到w之间，做完透视除法之后坐标范围在-1.0到1.0之间，变为标准化设备坐标NDC。</p>
<p>一旦坐标处在裁剪空间之后，透视除法就会被应用到裁剪空间坐标上：<br>$$<br>out =<br>\begin{pmatrix}<br>x /w \\<br>y / w \\<br>z / w<br>\end{pmatrix}<br>$$<br>顶点坐标的每个分量都会除以它的w分量，透视投影时距离观察者越远顶点坐标就会越小。这也是w分量非常重要的另一个原因，它能帮助我们进行透视投影。当使用正交投影时，虽然也要进行透视除法，但是正交投影的所有顶点w分量都是1，因此除以w分量之后不会有透视效果。</p>
<p>正交投影主要用于二维渲染以及一些建筑或工程的程序，因为这些场景中更希望顶点不会被透视所干扰。透视投影看起来更真实。</p>
<p>透视投影和正交投影效果如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148083660398.png" alt=""><br>&nbsp;</p>
<hr>
<p>总之，模型矩阵针对物体在世界里的位置角度，观察矩阵针对场景移动（或者反方向摄像机移动，因为场景移动用反方向模拟了摄像机移动效果），投影矩阵针对视见体。<br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">Demo</font><br>来一个demo，把<a href="http://popperelay.com/2016/11/29/OpenGL5%E7%BA%B9%E7%90%86/" target="_blank" rel="external">《OpenGL5：纹理》</a>一文中的纹理通过模型、观察、投影矩阵，变成向后旋转45度下的透视效果，如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148084274389.png" alt=""></p>
<p><font size="4" color="red">创建模型、观察、投影矩阵</font><br>首先，我们创建一个模型矩阵。这个模型矩阵包含了平移、旋转、缩放操作，它们会在顶点着色器中被应用到所有物体顶点上，以变换它们到全局的世界空间。这里我们让纹理平面绕着x轴旋转55度，让它看起来就像放在地上一样：</p>
<pre class=" language-c++"><code class="language-c++">        //模型矩阵
        mat4 model;
        model = rotate(model, radians(-45.0f), vec3(1.0f, 0.0f, 0.0f));
</code></pre>
<p>接着我们创建一个观察矩阵。因为纹理平面默认是处在世界原点（0,0,0）的，而摄像机也是处在世界原点的，这时候摄像机照不到纹理平面，为了让纹理平面可见，我们让场景向负z轴方向移动（因为一般要让摄像机处在原点不动）：</p>
<pre class=" language-c++"><code class="language-c++">        //观察矩阵
        mat4 view;
        view = translate(view, vec3(0.0f, 0.0f, -3.0f));
</code></pre>
<p>然后在创建一个投影矩阵。我们使用透视投影：</p>
<pre class=" language-c++"><code class="language-c++">        //投影矩阵
        mat4 projection;
        projection = perspective(radians(45.0f), (GLfloat)WIDTH / (GLfloat)HEIGHT, 0.1f, 100.0f);
</code></pre>
<p><font size="4" color="red">更改顶点着色器</font><br>因为要用这三个变换矩阵去影响顶点坐标，所以我们需要先更改一下着色器，让着色器有接收这三个矩阵的变量：</p>
<pre class=" language-c++"><code class="language-c++">//顶点着色器
#version 330 core
layout (location=0) in vec3 position;  //顶点位置变量的属性位置值为0
layout (location=1) in vec3 color;     //顶点颜色变量的属性位置值为1
layout (location=2) in vec2 texCoord;  //顶点纹理坐标的属性位置值为2
out vec3 ourColor;
out vec2 TexCoord;
//模型矩阵
uniform mat4 model;
//观察矩阵
uniform mat4 view;
//投影矩阵
uniform mat4 projection;

void main(){
    gl_Position=projection * view * model * vec4(position,1.0f);
    ourColor=color;
    TexCoord=vec2(texCoord.x,1-texCoord.y);
}
</code></pre>
<p>设置了3个uniform变量，用于从主程序接收3个变换矩阵。然后在顶点着色器的main函数里，内置变量<code>gl_Position</code>的值是几个变换矩阵与顶点坐标向量的乘积。注意这里矩阵运算的顺序是相反的（我们需要从右往左阅读三个矩阵的乘法）。</p>
<p><font size="4" color="red">把变换矩阵传递给顶点着色器</font><br>我们使用给uniform变量赋值的方法，从主程序把变换矩阵传递给着色器：</p>
<pre class=" language-c++"><code class="language-c++">        GLint modelLocation = glGetUniformLocation(myshader.shaderProgram, "model");
        glUniformMatrix4fv(modelLocation, 1, GL_FALSE, value_ptr(model));
        GLint viewLocation = glGetUniformLocation(myshader.shaderProgram, "view");
        glUniformMatrix4fv(viewLocation, 1, GL_FALSE, value_ptr(view));
        GLint projectionLocation = glGetUniformLocation(myshader.shaderProgram, "projection");
        glUniformMatrix4fv(projectionLocation, 1, GL_FALSE, value_ptr(projection));
</code></pre>
<p>全部源码<a href="https://github.com/Popperelay/BlogCode/tree/master/LearnOpenGL7_CoordinateSystem/LearnOpenGL7_CoordinateSystem_1" target="_blank" rel="external">在这里</a>。<br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">3D箱子</font><br>我们的顶点坐标都是3D的，但是到目前为止，我们还是在使用一个2D平面。因为我们只渲染了一个平面，下面我们尝试渲染一个立方体箱子。</p>
<p>说到立方体，很容易想到应该设置8个顶点，但是我们的立方体每个面上都会有一张纹理，一个顶点紧邻着三个面，也就是说要让一个顶点表示3个纹理的顶点纹素，这是不可能的，因为一个顶点只对应着一个纹理坐标。所以我们需要把每个面上的纹理分开来画。一个面有4个顶点，6个面就应该设置24个顶点。每个顶点都会出现3次，但只是顶点坐标相同，对应的纹理坐标是不同的：</p>
<pre class=" language-c++"><code class="language-c++">    GLfloat vertices[] = {
        //位置坐标          //颜色           //纹理坐标
        //立方体前面
         0.5f, 0.5f, 0.5f,  1.0f,0.0f,0.0f,  1.0f,1.0f,
         0.5f,-0.5f, 0.5f,  0.0f,1.0f,0.0f,  1.0f,0.0f,
        -0.5f,-0.5f, 0.5f,  0.0f,0.0f,1.0f,  0.0f,0.0f,
        -0.5f, 0.5f, 0.5f,  1.0f,1.0f,0.0f,  0.0f,1.0f,
        //立方体后面
         0.5f, 0.5f,-0.5f,  1.0f,0.0f,0.0f,  1.0f,1.0f,
         0.5f,-0.5f,-0.5f,  0.0f,1.0f,0.0f,  1.0f,0.0f,
        -0.5f,-0.5f,-0.5f,  0.0f,0.0f,1.0f,  0.0f,0.0f,
        -0.5f, 0.5f,-0.5f,  1.0f,1.0f,0.0f,  0.0f,1.0f,
        //立方体上面
         0.5f, 0.5f, 0.5f,  1.0f,0.0f,0.0f,  1.0f,1.0f,
         0.5f, 0.5f,-0.5f,  0.0f,1.0f,0.0f,  1.0f,0.0f,
        -0.5f, 0.5f,-0.5f,  0.0f,0.0f,1.0f,  0.0f,0.0f,
        -0.5f, 0.5f, 0.5f,  1.0f,1.0f,0.0f,  0.0f,1.0f,
        //立方体下面
         0.5f,-0.5f, 0.5f,  1.0f,0.0f,0.0f,  1.0f,1.0f,
         0.5f,-0.5f,-0.5f,  0.0f,1.0f,0.0f,  1.0f,0.0f,
        -0.5f,-0.5f,-0.5f,  0.0f,0.0f,1.0f,  0.0f,0.0f,
        -0.5f,-0.5f, 0.5f,  1.0f,1.0f,0.0f,  0.0f,1.0f,
        //立方体右面
         0.5f, 0.5f, 0.5f,  1.0f,0.0f,0.0f,  1.0f,1.0f,
         0.5f, 0.5f,-0.5f,  0.0f,1.0f,0.0f,  1.0f,0.0f,
         0.5f,-0.5f,-0.5f,  0.0f,0.0f,1.0f,  0.0f,0.0f,
         0.5f,-0.5f, 0.5f,  1.0f,1.0f,0.0f,  0.0f,1.0f,
        //立方体左面
        -0.5f, 0.5f, 0.5f,  1.0f,0.0f,0.0f,  1.0f,1.0f,
        -0.5f, 0.5f,-0.5f,  0.0f,1.0f,0.0f,  1.0f,0.0f,
        -0.5f,-0.5f,-0.5f,  0.0f,0.0f,1.0f,  0.0f,0.0f,
        -0.5f,-0.5f, 0.5f,  1.0f,1.0f,0.0f,  0.0f,1.0f
    };
</code></pre>
<p>当然接下来需要对每个面指定索引了：</p>
<pre class=" language-c++"><code class="language-c++">    //顶点索引
    GLuint indices[] = {
        //立方体前面
        0,1,3,  
        1,2,3,   
        //立方体后面
        4,5,7,
        5,6,7,
        //立方体上面
        8,9,11,
        9,10,11,
        //立方体下面
        12,13,15,
        13,14,15,
        //立方体右面
        16,17,19,    
        17,18,19,
        //立方体左面
        20,21,23,
        21,22,23
    };
</code></pre>
<p>【注】：</p>
<ul>
<li>也可以不用索引，直接画组成立方体的每个三角形，这样6个面，每个面2个三角形，每个三角形3个顶点，那就应该是36个顶点了。</li>
</ul>
<p>为了有趣点，我们让立方体随着时间旋转：</p>
<pre class=" language-c++"><code class="language-c++">        //模型矩阵
        mat4 model;
        model = rotate(model, (GLfloat)glfwGetTime()*radians(55.0f), vec3(0.5f, 1.0f, 0.0f));
</code></pre>
<p>最后使用<code>glDrawElements</code>函数来绘制立方体，这次需要根据36个顶点索引来绘制36个顶点：</p>
<pre class=" language-c++"><code class="language-c++">        //绘图
        glDrawElements(GL_TRIANGLES, 36, GL_UNSIGNED_INT, 0);
</code></pre>
<p>编译运行后应该得到类似下面的效果：</p>
<iframe height="498" width="510" src="https://learnopengl-cn.github.io/img/01/08/coordinate_system_no_depth.mp4" frameborder="0" 'allowfullscreen'=""></iframe>

<p>但是这个立方体有点怪，有些面本应该被挡住的，却绘制在了这个立方体的其他面之上。这是因为OpenGL是一个三角形一个三角形来绘制我们的立方体的，后绘制的三角形会覆盖之前绘制的，它并不会到某个三角形被遮挡了不该绘制。</p>
<p>幸运的是，OpenGL把每个像素的深度信息（通常是像素的z坐标值）存储在了一个叫做Z缓冲（Z-buffer）的缓冲中，它允许OpenGL决定何时覆盖一个像素而何时不覆盖。<br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">Z缓冲</font><br>OpenGL存储窗口上所有像素的深度信息于一个Z缓冲（Z-buffer）中，也称深度缓冲（Depth Buffer）。GLFW会自动为我们生成这样一个缓冲（就像它有一个颜色缓冲来存储图像的颜色）。当一个片元（还没绘制到窗口上的像素）准备输出它的颜色时，OpenGL会将它的深度值（z值）和相应坐标上的z缓冲进行比较，如果当前的片元在窗口像素之后（片元深度值小于窗口像素深度值，它们都是负数，越大的离摄像机越近），它将会被丢弃，否则将会覆盖。这个过程称为深度测试（Depth Testing），它是由OpenGL自动完成的。</p>
<p>我们首先需要用<code>glEnable</code>函数告诉OpenGL，我们想要开启深度测试，因为它默认是关闭的：</p>
<pre class=" language-c++"><code class="language-c++">    glEnable(GL_DEPTH_TEST);
</code></pre>
<p><code>glEnable</code>和<code>glDisable</code>函数允许我们启用或禁用某个OpenGL功能。这个功能会一直保持启用/禁用状态，直到另一个调用来禁用/启用它。所以上面的那行代码就不用写到渲染循环里面了，因为一开启后就会一直开启，直到显式关闭。</p>
<p>接着还需要在每次渲染循环之前清除深度缓冲，否则前一帧的深度信息仍然保存在缓冲中。就像清除颜色缓冲一样，我们可以通过在<code>glClear</code>函数中指定<code>GL_DEPTH_BUFFER_BIT</code>位来清除深度缓冲：</p>
<pre class=" language-c++"><code class="language-c++">        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
</code></pre>
<p>添加上面的代码，编译运行后的结果类似如下：</p>
<p><iframe height="498" width="510" src="https://learnopengl-cn.github.io/img/01/08/coordinate_system_depth.mp4" frameborder="0" 'allowfullscreen'=""></iframe><br>&nbsp;</p>
<hr>
<p>到此，所有源码<a href="https://github.com/Popperelay/BlogCode/tree/master/LearnOpenGL5_Texture/LearnOpenGL5_Texture_2" target="_blank" rel="external">在这里</a>。<br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">多个立方体</font><br>因为要创建的10个立方体长得一样的，只是位置方向不同而已。所以我们只需要调用<code>glDrawElements</code>函数10次，并且每一次调用时给顶点着色器传递不同的模型矩阵就可以：</p>
<pre class=" language-c++"><code class="language-c++">        vec3 cubeTranlate[] = {
            vec3(0.0f,  0.0f,  0.0f),
            vec3(2.0f,  5.0f, -15.0f),
            vec3(-1.5f, -2.2f, -2.5f),
            vec3(-3.8f, -2.0f, -12.3f),
            vec3(2.4f, -0.4f, -3.5f),
            vec3(-1.7f,  3.0f, -7.5f),
            vec3(1.3f, -2.0f, -2.5f),
            vec3(1.5f,  2.0f, -2.5f),
            vec3(1.5f,  0.2f, -1.5f),
            vec3(-1.3f,  1.0f, -1.5f)
        };

        //绑定VAO，完成顶点输入初始化
        glBindVertexArray(VAO);
        for (int i = 0; i < 10; i++) {
            mat4 model;
            model = translate(model, cubeTranlate[i]);
            model = rotate(model, (GLfloat)glfwGetTime()*radians(50.0f), vec3(0.5f, 1.0f, 1.0f));
            glUniformMatrix4fv(modelLocation, 1, GL_FALSE, value_ptr(model));
            //绘图
            glDrawElements(GL_TRIANGLES, 36, GL_UNSIGNED_INT, 0);
        }
        //解绑VAO
        glBindVertexArray(0);
</code></pre>
<p>这样就能在不同位置上显示10个立方体了，而且它们都在转。</p>
<p>所有源码<a href="https://github.com/Popperelay/BlogCode/tree/master/LearnOpenGL5_Texture/LearnOpenGL5_Texture_3" target="_blank" rel="external">在这里</a>。</p>
<p>编译运行后结果如下：</p>
<p><iframe height="498" width="510" src="http://player.youku.com/embed/XMTg0OTk1MjY4OA==" frameborder="0" 'allowfullscreen'=""></iframe><br>&nbsp;</p>
<hr>
<p>参考文献：<a href="https://learnopengl.com/" target="_blank" rel="external">LearnOpenGL</a></p>

            </div>

            <!-- Post Comments -->
            
    <!-- 使用 DISQUS_CLICK -->
<div id="disqus-comment">
    <div id="disqus_thread"></div>

<!-- add animation -->
<style>
	.disqus_click_btn {
            line-height: 30px;
            margin: 0;
            min-width: 50px;
            padding: 0 14px;
            display: inline-block;
            font-family: "Roboto", "Helvetica", "Arial", sans-serif;
            font-size: 14px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0;
            overflow: hidden;
            will-change: box-shadow;
            transition: box-shadow .2s cubic-bezier(.4, 0, 1, 1), background-color .2s cubic-bezier(.4, 0, .2, 1), color .2s cubic-bezier(.4, 0, .2, 1);
            outline: 0;
            cursor: pointer;
            text-decoration: none;
            text-align: center;
            vertical-align: middle;
            border: 0;
            background: rgba(158, 158, 158, .2);
            box-shadow: 0 2px 2px 0 rgba(0, 0, 0, .14), 0 3px 1px -2px rgba(0, 0, 0, .2), 0 1px 5px 0 rgba(0, 0, 0, .12);
            color: #fff;
            background-color: #7EC0EE;
            text-shadow: 0
        }
</style>
	
<div class="btn_click_load" id="disqus_bt"> 
    <button class="disqus_click_btn">点击查看评论</button>
</div>

<!--
<script type="text/javascript">
$('.btn_click_load').click(function() {
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'http-miccall-tech'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    document.getElementById('disqus_bt').style.display = "none";
});
</script>
-->
<script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://yoursite.com/2016/12/05/OpenGL7坐标系统/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = 'http://yoursite.com/2016/12/05/OpenGL7坐标系统/'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
</script>

<script type="text/javascript">
    $('.btn_click_load').click(function() {  //click to load comments
        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document;
            var s = d.createElement('script');
            s.src = '//http-miccall-tech.disqus.com/embed.js';
            s.setAttribute('data-timestamp', + new Date());
            (d.head || d.body).appendChild(s);
        })();
        $('.btn_click_load').css('display','none');
    });
</script>
</div>
<style>
    #disqus-comment{
        background-color: #eee;
        padding: 2pc;
    }
</style>


        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
                <li>Design: <a href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
            </ul>
            
            	<span id="busuanzi_container_site_pv">2017总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			
        </div>
    </div>
</body>



 	
</html>
