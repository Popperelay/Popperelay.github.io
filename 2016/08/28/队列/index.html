<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>数据结构与算法之队列 | Elays&#39;Blog</title>
  <meta name="author" content="Elay">
  
  <meta name="description" content="Elay">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="数据结构与算法之队列"/>
  <meta property="og:site_name" content="Elays&#39;Blog"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Elays&#39;Blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">Elays&#39;Blog</a></h1>
  <h2><a href="/">你是天地生的，美得超越人形</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">主页</a></li>
    
      <li><a href="/archives">所有文章</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-08-28T06:46:27.000Z"><a href="/2016/08/28/队列/">2016-08-28</a></time>
      
      
  
    <h1 class="title">数据结构与算法之队列</h1>
  

    </header>
    <div class="entry">
      
        <p>队列：只允许在一端进行插入操作，在另一端进行删除操作的线性表。允许插入的一端称为队尾，允许删除的一端称为队头。<br><a id="more"></a></p>
<p><strong>顺序队列</strong></p>
<hr>
<p>最简单的顺序队列：<br>由数组构成，入队时在数组元素尾部插入新元素，出队时移去数组下标为0的元素，同时其他数组元素向前移动一个位置。就像一群人在买票，前面的人离开，后面的人就会全部向前一步，补上空位。图示如下：<br>入队列：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721611234.png" alt=""><br>出队列：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721611281.png" alt=""><br>C#的容器已经实现了这个在尾部插入数据、在头部删除数据并且自动补位的功能，用C#容器实现的队列代码如下(由于C#自带实现队头队尾的插入删除，所以不需要队头队尾节点的引用)：</p>
<pre><code>class SequenceQueue
{
    private ArrayList Data;

    public SequenceQueue() {
        Data = new ArrayList();
    }
    //入队列
    public void EnQueue(object data) {
        Data.Add(data);
    }
    //出队列
    public void DeQueue(ref object data) {
        data = Data[0];
        Data.RemoveAt(0);
    }
    //查找队列第i个元素
    public object Find(int i) {
        return Data[i];
    }
    //清除队列
    public void Clear() {
        Data.Clear();
    }
    //队列元素个数
    public int Count() {
        return Data.Count;
    }
}
</code></pre><p><strong>循环队列</strong></p>
<hr>
<p>但是上面的队列实现方式有个性能缺陷：出队列时所有元素都要移位。所以我们可以设置一个队头和队尾的引用(指针)，出队列时直接把队头引用处的结点移除，入队列时直接把元素添加到队尾引用所在的节点，而其他元素不用动，只是在入队列和出队列时修改队头引用或者队尾引用即可。<br>所以，队头引用front指向队头元素，队尾引用rear指向队尾元素的下一个位置(方便下次入队时直接添加到该位置)。<br>但是，这种方式存在下图的尴尬(针对固定容量的队列，非ArrayList这种大小可变的容器)：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721611333.png" alt=""><br>若再在rear位置入队插入新元素，则会溢出，但是明显数组前面还有空位，是可以插入新元素的。就像坐公交，前面有空位置肯定是要去座的。为了让新元素能够按次序插入到前面的空位里去，应该把队列的首尾连起来，形成循环队列，这样新元素插入到前面的空位就水到渠成了。<br>还有一个问题，如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721611379.png" alt=""><br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721611433.png" alt=""><br>如上图所示，队列空和队列满的条件都是front==rear，为了区分他俩，我们人为设定：数组中只剩下一个空闲单元时，就认为队列已经满了。即敲定队列空的条件为：front==rear，队列满的条件为(rear+1)%QueueSize==front。【因为循环队列中只剩下一个空闲单元有两种情况：rear在front左边、rear在front右边】如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721611485.png" alt=""><br>综上，循环队列数据结构：数据成员：数组、队头引用front、队尾引用rear，方法成员：入队、出队等。代码如下：</p>
<pre><code>class RoundQueue
{
    private Object[] Data;
    private int front;
    private int rear;

    private int QueueSize;

    public RoundQueue() {
        QueueSize = 3;
        front = 0;
        rear = 0; 
        Data = new object[QueueSize];
    }
    //入队列
    public void EnQueue(object data) {
        //如果队列满，则不能再入队列
        if ((rear + 1) % QueueSize == front)
            return;
        Data[rear] = data;
        rear = (rear + 1) % QueueSize;
    }
    //出队列
    public void DeQueue(ref object data) {
        //如果队列空，则不能再出队列
        if (rear == front)
            return;
        data = Data[front];
        front = (front + 1) % QueueSize;
    }
    //队列中元素个数
    public int Count() {
        return (rear - front + QueueSize) % QueueSize;
    }
}
</code></pre><p><strong>优先队列</strong></p>
<hr>
<p>优先队列不再是每次移除队头的结点元素，而是每次出队优先级最高的结点。严格来说，它已经不算是一个队列。<br>对于优先队列，需要给每一个结点都加上一个表示优先级的数据成员，可以把结点单独写成一个类，如下：</p>
<pre><code>class PriorQueueNode{
    public object Data;
    public int Priority;
}
</code></pre><p>优先队列可以继承普通的顺序队列或者循环队列，但是需要重载出队列函数，伪码如下：</p>
<pre><code>public override object DeQueue(){
    //找出优先队列里优先级最大的结点
    for(;;){
    }
    //移除优先级最大的结点
    Remove();
}
</code></pre><p><strong>链队列</strong></p>
<hr>
<p>因为顺序队列的存储空间有限且大小是固定的，插入时会有溢出，所以我们需要链队列。<br>由于链队列需要在表头(队头)删除结点，删除结点需要知道该结点的前一个结点是谁，为了统一第一个结点和中间结点，需要给链队列加上一个头结点。<br>链队列的队头引用front其实就是指向头结点，是固定不动的，队尾引用rear是一直指向表中的最后一个结点(最后一个结点有Next成员，所以rear不需要指向最后一个结点的下一个位置)。代码如下：</p>
<pre><code>public class Node{
    public object Data;
    public Node Next;

    public Node() {
        Data = null;
        Next = null;
    }
    public Node(Object data) {
        Data = data;
        Next = null;
    }
}
class LinkQueue
{
    protected Node header;
    protected Node front;
    protected Node rear;

    public LinkQueue() {
        header = new Node();
        front = header;
        rear = header;
    }
    //入队列
    public void EnQueue(object data) {
        Node newNode = new Node(data);
        rear.Next = newNode;
        rear = newNode;
    }
    //出队列，队头引用front是不动的，一直指向头结点
    public void DeQueue(ref object data) {
        //队列空，则不再出队列
        if (front == rear)
            return;
        //队头结点(头结点)的下一个结点就是队尾结点(表中只有一个元素了),则出队列后让队尾引用重新指向头结点
        if (front.Next == rear)
            rear = header;
        data = front.Next.Data;
        front.Next = front.Next.Next;
    }
}
</code></pre><p>【注】：</p>
<ul>
<li>可以确定队列容量的情况下，建议使用循环队列，如果队列长度不能确定或者需要动态变化时，则需要用链队列</li>
</ul>

      
    </div>
    <footer>
      
        
  
  <div class="categories">
    <a href="/categories/数据结构/">数据结构</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/队列/">队列</a>
  </div>

        
  <div class="addthis addthis_toolbox addthis_default_style">
    
      <a class="addthis_button_facebook_like" fb:like:layout="button_count"></a>
    
    
      <a class="addthis_button_tweet"></a>
    
    
      <a class="addthis_button_google_plusone" g:plusone:size="medium"></a>
    
    
      <a class="addthis_button_pinterest_pinit" pi:pinit:layout="horizontal"></a>
    
    <a class="addthis_counter addthis_pill_style"></a>
  </div>
  <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js"></script>

      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


<section id="comment">
  <h2 class="title">留言</h2>


 
  	   <!-- 多说评论框 start -->
 		<div class="ds-thread" data-thread-key="2016/08/28/队列/" data-title="数据结构与算法之队列" data-url="http://yoursite.com/2016/08/28/队列/"></div>
		<!-- 多说评论框 end -->
		<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
		<script type="text/javascript">
		var duoshuoQuery = {short_name:"popperelay"};   <!-- 替换这里的duoshuo_shortname为前面注册的shortname -->
			(function() {
				var ds = document.createElement('script');
				ds.type = 'text/javascript';ds.async = true;
				ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.unstable.js';
				ds.charset = 'UTF-8';
				(document.getElementsByTagName('head')[0] 
				 || document.getElementsByTagName('body')[0]).appendChild(ds);
			})();
			</script>
		<!-- 多说公共JS代码 end -->
 
  
</section>

</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:yoursite.com">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/C-语法/">C#语法</a><small>2</small></li>
  
    <li><a href="/categories/OpenGL/">OpenGL</a><small>2</small></li>
  
    <li><a href="/categories/博客配置/">博客配置</a><small>3</small></li>
  
    <li><a href="/categories/操作系统/">操作系统</a><small>4</small></li>
  
    <li><a href="/categories/数据结构/">数据结构</a><small>15</small></li>
  
    <li><a href="/categories/游戏开发/">游戏开发</a><small>1</small></li>
  
    <li><a href="/categories/计算机图形学/">计算机图形学</a><small>2</small></li>
  
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/BIOS和微机启动过程/">BIOS和微机启动过程</a><small>1</small></li>
  
    <li><a href="/tags/C-容器/">C#容器</a><small>1</small></li>
  
    <li><a href="/tags/MarkDown/">MarkDown</a><small>1</small></li>
  
    <li><a href="/tags/Mathjax语法/">Mathjax语法</a><small>1</small></li>
  
    <li><a href="/tags/OS内核/">OS内核</a><small>1</small></li>
  
    <li><a href="/tags/OpenGL窗口/">OpenGL窗口</a><small>1</small></li>
  
    <li><a href="/tags/OpenGL配置/">OpenGL配置</a><small>1</small></li>
  
    <li><a href="/tags/timeTest/">timeTest</a><small>1</small></li>
  
    <li><a href="/tags/二叉树/">二叉树</a><small>1</small></li>
  
    <li><a href="/tags/关键路径/">关键路径</a><small>1</small></li>
  
    <li><a href="/tags/图/">图</a><small>1</small></li>
  
    <li><a href="/tags/图形学概述/">图形学概述</a><small>1</small></li>
  
    <li><a href="/tags/图形显示系统/">图形显示系统</a><small>1</small></li>
  
    <li><a href="/tags/多说/">多说</a><small>1</small></li>
  
    <li><a href="/tags/头结点/">头结点</a><small>1</small></li>
  
    <li><a href="/tags/尾递归/">尾递归</a><small>1</small></li>
  
    <li><a href="/tags/帧同步/">帧同步</a><small>1</small></li>
  
    <li><a href="/tags/拓扑排序/">拓扑排序</a><small>1</small></li>
  
    <li><a href="/tags/操作系统概述/">操作系统概述</a><small>1</small></li>
  
    <li><a href="/tags/改进排序/">改进排序</a><small>1</small></li>
  
    <li><a href="/tags/最小生成树/">最小生成树</a><small>1</small></li>
  
    <li><a href="/tags/最短路径/">最短路径</a><small>1</small></li>
  
    <li><a href="/tags/查找/">查找</a><small>1</small></li>
  
    <li><a href="/tags/栈/">栈</a><small>1</small></li>
  
    <li><a href="/tags/树/">树</a><small>1</small></li>
  
    <li><a href="/tags/简单排序/">简单排序</a><small>1</small></li>
  
    <li><a href="/tags/进程的描述与控制/">进程的描述与控制</a><small>1</small></li>
  
    <li><a href="/tags/链表/">链表</a><small>1</small></li>
  
    <li><a href="/tags/队列/">队列</a><small>1</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2016 Elay
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>


<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</body>
</html>