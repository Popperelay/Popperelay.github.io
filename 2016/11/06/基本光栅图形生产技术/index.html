<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>基本光栅图形生成技术 | Elays&#39;Blog</title>
  <meta name="author" content="Elay">
  
  <meta name="description" content="Elay">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="基本光栅图形生成技术"/>
  <meta property="og:site_name" content="Elays&#39;Blog"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Elays&#39;Blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">Elays&#39;Blog</a></h1>
  <h2><a href="/">你是天地生的，美得超越人形</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">主页</a></li>
    
      <li><a href="/archives">所有文章</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-11-06T13:18:49.000Z"><a href="/2016/11/06/基本光栅图形生产技术/">2016-11-06</a></time>
      
      
  
    <h1 class="title">基本光栅图形生成技术</h1>
  

    </header>
    <div class="entry">
      
        <p>先来回顾一下图形显示的过程。<br><a id="more"></a><br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">图形显示的过程</font><br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721606272.png" alt=""><br>可以看到，视频控制器是从帧缓存中读出数据不为0的单元进行显示。但是，正如图中所示，对于三角形，我们一般存储的都只是三个顶点的坐标，那么怎么根据这三个顶点的坐标得到对应的帧缓存数据呢？其实这就是图形的生成过程，从参数形式转换为点阵形式，便于光栅扫描生成相应的图形（参数形式和点阵形式可参考<a href="http://popperelay.com/2016/10/18/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E6%A6%82%E8%BF%B0/" target="_blank" rel="external">《图形学概述》</a>一文中的计算机图形表示方法）。</p>
<p><strong>由参数形式到点阵形式的转换就称为扫描转换</strong>。<br>&nbsp;</p>
<hr>
<p>从上面可以看到，图形信息是存储在帧缓存中的，其实光栅图形显示的缓存机制并不是图示的那样简单。下面来看一下：</p>
<p><font size="5" color="orange">光栅图形生成时的缓存机制</font></p>
<ul>
<li><p>单缓存：其实光栅图形显示时的帧缓存采用两种方式：单缓存、双缓存。<br>采用单缓存时，是在帧缓存填满之后，再由视频控制器驱动电子枪扫描形成一幅图形，接着才能再去生成下一幅图形的帧缓存（否则会覆盖破环图形数据）。这样帧缓存数据（图形点阵形式）的生成和在屏幕上扫描显示图形就是串行的。这样会降低图形的显示速率。</p>
</li>
<li><p>双缓存：现在大多采用的是双缓存，即有两个帧缓存，一幅图形在帧缓存2生成点阵数据后，再交给帧缓存1，视频控制器就可以根据帧缓存1来驱动电子枪扫描形成图形。<strong>与此同时</strong>，下一幅图形就可以在帧缓存2中再生成点阵数据。这样一来，不会覆盖破环要显示的图形数据（因为它已经转储到帧缓存1了），达到了帧缓存图形数据生成和在屏幕上扫描显示图形并行的效果。大大提高了图形显示的速率。</p>
</li>
</ul>
<p>如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721606347.png" alt=""><br>&nbsp; </p>
<hr>
<p>下面我们先来看个简单的：直线段是怎么通过扫描转换画出来的？</p>
<p><font size="5" color="orange">扫描转换线画图元直线段</font><br>我们知道，屏幕上其实是一个一个的像素，如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721606401.png" alt=""><br>想要让像素全部恰好落在直线上是很难的，我们只能去选择距离直线最近的像素点，然后用它们来近似地画出直线段（像素点是很小的，稍微不在直线上一点，肉眼是看不出来的，所以我们看到的还是一条“很直”的直线段）。</p>
<p>那么我们扫描转换画直线段的方法是啥呢（假设我们要画的直线段宽度是一个像素点，<strong>斜率在[0,1]之间（即0~45度）</strong>）？主要有三种方法：直线方程法、DDA、中点算法。都是为了一个一个地找出直线附近的像素点。</p>
<p><font size="4" color="red">扫描转换直线段：直线方程法</font></p>
<ul>
<li>基本思想：<br>直接根据直线的几何方程确定直线段路径上的像素位置。x坐标的值从左端点x遍历到右端点x，对应y坐标通过直线方程算出来。描点时如果发现y坐标不是整数值，需要取为离它最近的整数（如3.4取为3，3.5取为4，程序上用了一个小技巧实现：<code>(int)(y+0.5)</code>）。</li>
<li><p>具体代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//直线段的直线方程画法。直线方程式：y=mx+b</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Equation</span>(<span class="params"><span class="keyword">int</span> x0,<span class="keyword">int</span> y0,<span class="keyword">int</span> x1,<span class="keyword">int</span> y1,<span class="keyword">int</span> red,<span class="keyword">int</span> green,<span class="keyword">int</span> blue</span>)</span>&#123;	</div><div class="line">	glBegin(GL_POINTS); </div><div class="line">	glColor3ub(red,green,blue);</div><div class="line">		<span class="comment">//计算斜率m</span></div><div class="line">		<span class="keyword">float</span> m=<span class="keyword">float</span>(y1-y0)/(x1-x0);</div><div class="line">		<span class="comment">//计算b</span></div><div class="line">		<span class="keyword">float</span> b=y0-m*x0;</div><div class="line"></div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> x=x0;x&lt;=x1;x++)&#123;</div><div class="line">			<span class="keyword">int</span> y=m*x+b;</div><div class="line">			glVertex2d(x,<span class="keyword">int</span>(y+<span class="number">0.5</span>));</div><div class="line">		&#125;</div><div class="line">	glEnd();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>用到的主要运算有：浮点运算、乘法、除法、取整、加法。</p>
</li>
</ul>
<p>有计算机基础的朋友应该知道，乘除法、浮点运算的开销是很大的。画个线就这么惨，有没有开销小一点的方法呢？请看下面。</p>
<p><font size="4" color="red">扫描转换直线段：数字差分分析法DDA（Digital Differential Analyzer）</font><br>DDA算法不再直接按照直线方程求像素点，而是打上了直线斜率的主意。在直线方程法中，是根据每个点的横坐标，按直线方程求出对应的纵坐标。这是把直线上的每个点作离散处理的，忽略了直线上点的纵坐标其实是有联系的：相邻点的纵坐标正好差一个斜率。所以纵坐标不用根据方程求解了，直接从上一个点的纵坐标加一个斜率值即可。具体描述如下：</p>
<ul>
<li>基本思想：<br><strong>纵坐标每次加一个斜率值</strong>。x坐标的值从左端点x遍历到右端点x，对应y坐标每次加一个斜率。描点时如果发现y坐标不是整数值，需要取为离它最近的整数（如3.4取为3，3.5取为4，程序上用了一个小技巧实现：<code>(int)(y+0.5)</code>）<br>【注】：只是在描点的时候描在最近的整数点上，即(int)(y+0.5)，而不能把y值变为最近的整数值，即y=int(y+0.5)是不对的。因为每次描点都应该是在其纵坐标的真实值上，进行取整描点；如果是y=int(y+0.5)这样把纵坐标作了近似处理，那么下一个点加斜率值之后，算出来的纵坐标就不是它的真实纵坐标了。</li>
<li><p>具体代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//直线段的DDA画法。直线方程式：y=mx+b</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">LineDDA</span>(<span class="params"><span class="keyword">int</span> x0,<span class="keyword">int</span> y0,<span class="keyword">int</span> x1,<span class="keyword">int</span> y1,<span class="keyword">int</span> red,<span class="keyword">int</span> green,<span class="keyword">int</span> blue</span>)</span>&#123;</div><div class="line">	glBegin(GL_POINTS); </div><div class="line">	glColor3ub(red,green,blue);</div><div class="line">		<span class="comment">//计算斜率m</span></div><div class="line">		<span class="keyword">float</span> m=<span class="keyword">float</span>(y1-y0)/(x1-x0);</div><div class="line"></div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> x=x0,y=y0; x&lt;=x1; x++)&#123;</div><div class="line">			glVertex2d(x,<span class="keyword">int</span>(y+<span class="number">0.5</span>));  <span class="comment">//四舍五入取整</span></div><div class="line">			y+=m;</div><div class="line">		&#125;</div><div class="line">	glEnd();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>用到的主要运算有：浮点运算、除法、加法、取整。</p>
</li>
</ul>
<p>看出来了吧，DDA比直线方程法少了乘法运算，加快了画线速度，但是还不够好，因为还存在浮点运算和取整运算。想要更好的算法，请看下面。</p>
<p><font size="4" color="red">扫描转换直线段：中点算法</font><br>在DDA中还是存在对浮点数的取整运算，因为要描出在y方向上离直线最近的像素点。能不能不通过取整运算，直接知道哪个像素点在y方向上离直线最近呢？画个图找点灵感（直线段斜率0~45度）：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147755946268.png" alt=""><br>图1和图2最左下角的黑点是当前已经确定的离直线最近的像素点。如果是图1这种情况，邻近的右上方（因为直线斜率0~45度）中点（图1的绿色点）在直线上方，则此时离直线最近的点应该是中点正下方的蓝色点；如果是图2这种情况，邻近的右上方中点（图2的绿色点）在直线下方，则此时离直线最近的点应该是中点正上方的蓝色点。</p>
<p>采用这种分类的方法（邻近的中点在直线上方还是下方），确实可以不再需要取整运算了，因为每种分类下应该取哪个整数点是确定的，通过简单的加法就能算出来（如果是图1的情况，则下一个应该描的像素点是x+1，y不变；如果是图2的情况，则下一个应该描的像素点是x+1，y+1）。问题又来了，怎么知道邻近的中点在直线上方还是下方呢？很简单，学过中学数学的朋友都知道，把中点坐标代入直线方程，如果算出来的结果<0，则在直线下方，如果结果>0，则在直线上方。</0，则在直线下方，如果结果></p>
<p>but，把中点坐标代入直线方程？这不又要算浮点数乘法了嘛~~~。回顾在直线方程法中，之所以会出现乘法，是因为把直线上的点作离散处理的，忽略了各个点之间的联系。这里也是这个原因，因为这些中点坐标也是有联系的。如果是图1的情况，则下一个中点应该是图1中的黄色点（即相比上一个中点x+1，y不变）；如果是图2的情况，则下一个中点应该是图2中的黄色点（即相比上一个中点x+1，y+1）。直线方程是ax+by+c=0，设把中点坐标代入直线方程得到的表达式是：$d=F(M)=ax+by+c$。如果是图1的情况，因为下一个中点相比上一个中点x+1，y不变，代入直线方程很容易得到，下一个中点$d_{i+1}$和上一个中点$d_i$的联系是：$d_{i+1}=d_i+a$；如果是图2的情况，因为下一个中点相比上一个中点x+1、y+1，代入直线方程很容易得到，下一个中点$d_{i+1}$和上一个中点$d_i$的联系是：$d_{i+1}=d_i+a+b$。而图1的情况其实就是$d_{i+1} \le 0$，图2的情况其实就是$d_{i+1}\gt 0$，所以得到如下方程组：<br>$$<br>d_{i+1}=<br>\begin{cases}<br>d_i+a,&amp; d_i \gt 0 \\<br>d_i+a+b,&amp; d_i \le 0 \\<br>\end{cases}<br>$$<br>那么最初的$d_0$是多少呢？看看$d_0$的表达式$d_0=F(M)=F(x_0+1,y_0+0.5)=F(x_0,y_0)+a+0.5b$，因为点$(x_0,y_0)$在直线上，所以$d_0=a+0.5b$。但是这里又出现了浮点数0.5，能不能把它转化成整数？其实我们一直关注的都是d是大于0还是小于0，2d和d的正负性是一样的，所以我们可以给上诉方程组等号两边同时乘以2，把所有的系数都变成整数：<br>$$<br>\begin{array}{l}<br>2d_0=2a+b \\<br>2d_{i+1}=<br>\begin{cases}<br>2d_i+2a,&amp; 2d_i \gt 0 \\<br>2d_i+2a+2b,&amp; 2d_i \le 0 \\<br>\end{cases}<br>\end{array}<br>$$<br>再把$2d_i$换成$x_i$，即$x_i=2d_i$。于是方程组变成如下：<br>$$<br>\begin{array}{l}<br>x_0=2a+b \\<br>x_{i+1}=<br>\begin{cases}<br>x_i+2a,&amp; x_i \gt 0 \\<br>x_i+2a+2b,&amp; x_i \le 0 \\<br>\end{cases}<br>\end{array}<br>$$<br>既然可以换成$x_i$，那么当然也可以换成$d_i$啊！所以方程组还可以是下面这样：<br>$$<br>\begin{array}{l}<br>d_0=2a+b \\<br>d_{i+1}=<br>\begin{cases}<br>d_i+2a,&amp; d_i \gt 0 \\<br>d_i+2a+2b,&amp; d_i \le 0 \\<br>\end{cases}<br>\end{array}<br>$$<br>而描点坐标的方程组也可以表示如下：<br>$$<br>\begin{array}{l}<br>x_{i+1}=x_i+1 \\<br>y_{i+1}=<br>\begin{cases}<br>y_i,&amp; d_i \gt 0 \\<br>y_i+1,&amp; d_i \le 0 \\<br>\end{cases}<br>\end{array}<br>$$<br>【注】：参数表示下直线段两端点坐标为($x_0,y_0$)，($x_1,y_1$)。则ax+by+c=0中的$a=y_0-y_1$、$b=x_1-x_0$。且方程组中诸如2a是可以写成a+a的。</p>
<p>从上述方程组中可以看出中点算法下的直线段扫描转换就只剩下整数加法运算了，效率得到了很大的提升。</p>
<p>总结一下：</p>
<ul>
<li>基本思想：中点算法中只存在整数加法运算。在分类情况下（下一格中点在直线上方还是下方），下一个像素点坐标可以直接通过上一个点坐标做加法得到；同时下一个中点代入方程值也可以在分类情况下，直接通过上一个中点代入方程值做加法得到。<br>【注】：上面只是研究了直线斜率0~45度的情况，其实其它斜率也是同样的研究方法。不再赘述，结论如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147783822848.png" alt=""><br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147783822974.png" alt=""></li>
<li><p>具体代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//直线段的中点算法。直线方程ax+by+c=0</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">MidPointLine</span>(<span class="params"><span class="keyword">int</span> x0,<span class="keyword">int</span> y0,<span class="keyword">int</span> x1,<span class="keyword">int</span> y1,<span class="keyword">int</span> red,<span class="keyword">int</span> green,<span class="keyword">int</span> blue</span>)</span>&#123;</div><div class="line">	glBegin(GL_POINTS); </div><div class="line">	glColor3ub(red,green,blue);</div><div class="line">	<span class="comment">//初始化线段方程中的a、b</span></div><div class="line">	<span class="keyword">int</span> a=y0-y1;</div><div class="line">	<span class="keyword">int</span> b=x1-x0;</div><div class="line">	<span class="comment">//中点公式当中的d=d+dPlusPart1</span></div><div class="line">	<span class="keyword">int</span> dPlusPart1;</div><div class="line">	<span class="keyword">int</span> dPlusPart2;</div><div class="line">	</div><div class="line">	<span class="keyword">int</span> d;</div><div class="line">	<span class="keyword">int</span> y=y0;</div><div class="line">	<span class="keyword">int</span> x=x0;</div><div class="line">	<span class="comment">//计算斜率</span></div><div class="line">	<span class="keyword">float</span> k=<span class="keyword">float</span>(y1-y0)/(x1-x0);</div><div class="line"></div><div class="line">	<span class="keyword">int</span> type=<span class="number">0</span>;</div><div class="line">	<span class="keyword">if</span>(k&gt;=<span class="number">0</span>&amp;&amp;k&lt;=<span class="number">1</span>)</div><div class="line">		type=<span class="number">1</span>;</div><div class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(k&gt;<span class="number">1</span>)</div><div class="line">		type=<span class="number">2</span>;</div><div class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(k&gt;=<span class="number">-1</span>&amp;&amp;k&lt;<span class="number">0</span>)</div><div class="line">		type=<span class="number">3</span>;</div><div class="line">	<span class="keyword">else</span></div><div class="line">		type=<span class="number">4</span>;</div><div class="line">	<span class="keyword">switch</span>(type)&#123;</div><div class="line">	<span class="comment">//斜率大于0小于1 </span></div><div class="line">	<span class="keyword">case</span> <span class="number">1</span>:</div><div class="line">		dPlusPart1=a+a;</div><div class="line">		dPlusPart2=a+a+b+b;</div><div class="line">		d=a+a+b;</div><div class="line">		<span class="keyword">for</span>(;x&lt;x1;x++)&#123;</div><div class="line">			glVertex2d(x,y);</div><div class="line">			<span class="keyword">if</span>(d&lt;<span class="number">0</span>)&#123;</div><div class="line">				y++;</div><div class="line">				d+=dPlusPart2;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">else</span>&#123;</div><div class="line">				d+=dPlusPart1;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">break</span>;</div><div class="line">    <span class="comment">//斜率大于1</span></div><div class="line">	<span class="keyword">case</span> <span class="number">2</span>:</div><div class="line">		d=a+b+b;</div><div class="line">		dPlusPart1=a+a+b+b;</div><div class="line">		dPlusPart2=b+b;</div><div class="line">		<span class="keyword">for</span>(;y&lt;y1;y++)&#123;</div><div class="line">			glVertex2d(x,y);</div><div class="line">			<span class="keyword">if</span>(d&gt;<span class="number">0</span>)&#123;</div><div class="line">				x++;</div><div class="line">				d+=dPlusPart1;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">else</span>&#123;</div><div class="line">				d+=dPlusPart2;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">break</span>;</div><div class="line">	<span class="comment">//斜率大于-1小于0</span></div><div class="line">	<span class="keyword">case</span> <span class="number">3</span>:</div><div class="line">		d=a+a-b;</div><div class="line">		dPlusPart1=a+a-b-b;</div><div class="line">		dPlusPart2=a+a;</div><div class="line">		<span class="keyword">for</span>(;x&lt;x1;x++)&#123;</div><div class="line">			glVertex2d(x,y);</div><div class="line">			<span class="keyword">if</span>(d&gt;<span class="number">0</span>)&#123;</div><div class="line">				y--;</div><div class="line">				d+=dPlusPart1;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">else</span>&#123;</div><div class="line">				d+=dPlusPart2;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">break</span>;</div><div class="line">	<span class="comment">//斜率小于-1</span></div><div class="line">	<span class="keyword">case</span> <span class="number">4</span>:</div><div class="line">		d=a-b-b;</div><div class="line">		dPlusPart1=a+a-b-b;</div><div class="line">		dPlusPart2=-b-b;</div><div class="line">		<span class="keyword">for</span>(;x&lt;x1;x++)&#123;</div><div class="line">			glVertex2d(x,y);</div><div class="line">			<span class="keyword">if</span>(d&gt;<span class="number">0</span>)&#123;</div><div class="line">				y--;</div><div class="line">				d+=dPlusPart1;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">else</span>&#123;</div><div class="line">				d+=dPlusPart2;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">break</span>;</div><div class="line">	<span class="keyword">default</span>:</div><div class="line">		<span class="keyword">break</span>;</div><div class="line">	&#125;</div><div class="line">	glEnd();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>用到的主要运算有：整数加法。</p>
</li>
</ul>
<p>为了方便理解，举例如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147783439402.png" alt=""></p>
<hr>
<p>再来看个稍微复杂点的：圆弧是怎么通过扫描转换画出来的？</p>
<p><font size="5" color="orange">扫描转换线画图元圆弧</font><br>扫描转换圆弧也是把圆弧的参数方程转换为一个一个的像素点。不过对于圆这种东西，已经对称得不能再对称了，不利用它的对称性不浪费嘛~-~。利用圆的对称性，我们只需要画出1/8圆弧（一般研究逆时针45~90度的圆弧）就可以了，剩下的7/8都可以通过x对称或y对称得到。既然说到了对称，那肯定是要把圆心放在原点才好对称啊！那如果要画的圆心不再原点怎么办？平移到原点呗（平移会在《图形几何变换》一文中讲到）。<br>那如何扫描转换这段圆弧呢？主要有三种方法：方程法、中点算法、多边形逼近法。</p>
<p><font size="4" color="red">扫描转换圆弧：方程法</font><br>和直线扫描转换方程法原理一致，把(x,y)一个一个算出来。根据圆方程不同，大致分为以下两种方式：</p>
<ol>
<li><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147789990105.png" alt=""></li>
</ol>
<ul>
<li><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147789990162.png" alt=""></li>
</ul>
<p>这方法不说了，效率很着急！</p>
<p><font size="4" color="red">扫描转换圆弧：中点算法</font><br>和直线段扫描转换的中点算法原理一致。先画个图找点思路：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147791765983.png" alt=""><br>哪个点离圆弧最近呢？如果是图中黑色圆弧的情况，即中点M在圆弧外面，则M的竖直方向上，离圆弧最近的点是正下方的SE点；如果是图中红色圆弧的情况，即中点M在圆弧里面，则离圆弧最近的点是正上方的E点。而中点在圆弧外面其实就是中点代入圆方程值d大于0，中点在里面就是中点代入方程值d小于0。那么圆弧是不是和直线段一样，中点代入方程值d也可以由上一个值加一个常量得到呢？</p>
<p>答案是当然的。看上图（圆方程：$x^2+y^2-R^2=0$）如果是红色圆弧的情况，那么下一个中点坐标x+1，y不变，即d增量是$2x_M+1$，但是这里$x_M$是中点的坐标，应该把它换算成圆弧上点的坐标（因为中点算法的目的就是避开中点坐标，并没有求出中点坐标具体是多少，而只是关注中点代入方程的结果值。也就是说在整个过程里中点坐标$(x_M,y_M)$是多少不得而知，所以就得把它换算成$x_i$，即上一个圆弧上点的坐标，这个我们是知道的。具体可以参考程序进行理解），如果点P的坐标是(x,y)，那么$x_M=x+1$，所以d的增量是2x+3；如果是黑色圆弧的情况，那么下一个中点坐标x+1，y-1，即d增量是$2x_M-2y_M+2$，同样的道理，$x_M=x+1，y_M=y-0.5$，所以d的增量是2x-2y+5。那么d的初始值$d_0$是多少呢？因为$d_0=(x_0+1)^2+(y_0-0.5)^2-R^2$且点($x_0,y_0$)=(0,R)，所以$d_0=1.25-R$。整理一下，有如下方程式：<br>$$<br>\begin{array}{l}<br>x_{i+1}=x_i+1 \\<br>y_{i+1}=<br>\begin{cases}<br>y_i,&amp; d \le 0 \\<br>y_i-1,&amp; d \gt 0 \\<br>\end{cases} \\<br>d_{i+1}=<br>\begin{cases}<br>d_i+2x_i+3,&amp; d_i \le 0 \\<br>d_i+2x_i-2y_i+5,&amp; d_i \gt 0 \\<br>\end{cases} \\<br>d_0=1.25-R \\<br>\end{array}<br>$$<br>但是很可恨啊，上面存在1.25这个浮点数，所以仿照前文直线段的中点算法中对浮点数的处理，可以把上诉有关d的方程都在等号两端乘以4，转换为整数。再令$a_i=4d_i$，再令$d_i=a_i$，得到如下方程组：<br>$$<br>\begin{array}{l}<br>x_{i+1}=x_i+1 \\<br>y_{i+1}=<br>\begin{cases}<br>y_i,&amp; d \le 0 \\<br>y_i-1,&amp; d \gt 0 \\<br>\end{cases} \\<br>d_{i+1}=<br>\begin{cases}<br>d_i+8x_i+12,&amp; d_i \le 0 \\<br>d_i+8x_i-8y_i+20,&amp; d_i \gt 0 \\<br>\end{cases} \\<br>d_0=5-4R \\<br>\end{array}<br>$$<br>but，上面又出现了$8x_i$这些乘法，不过由于这是像素点的坐标，相邻点之间具有很明显的常量联系，所以可以仿照上面的原理，把它们转化为加法。令$E_i=8x_i+12，SE_i=8x_i-8y_i+20$，与$d_i$同样的推理过程（不再赘述），会得到如下方程组：<br>$$<br>\begin{array}{l}<br>x_{i+1}=x_i+1 \\<br>y_{i+1}=<br>\begin{cases}<br>y_i,&amp; d \le 0 \\<br>y_i-1,&amp; d \gt 0 \\<br>\end{cases} \\<br>d_{i+1}=<br>\begin{cases}<br>d_i+E_i,&amp; d_i \le 0 \\<br>d_i+SE_i,&amp; d_i \gt 0 \\<br>\end{cases} \\<br>E_i=8x_i+12 \\<br>SE_i=8x_i-8y_i+20 \\<br>E_{i+1}=E_i+8 \\<br>SE_{i+1}=<br>\begin{cases}<br>SE_i+8,&amp; d_i \le 0 \\<br>SE_i+16,&amp; d_i \gt 0 \\<br>\end{cases} \\<br>d_0=5-4R \\<br>E_0=8x_0+12=12 \\<br>SE_0=8x_0-8y_0+20=20-8R \\<br>\end{array}<br>$$</p>
<p>总结一下：</p>
<ul>
<li>基本思想：圆弧扫描转换的中点算法也只存在整数加法运算。在分类情况下（下一格中点在圆弧里面还是外面），下一个像素点坐标可以直接通过上一个点坐标做加法得到；同时下一个中点代入方程值也可以在分类情况下，直接通过上一个中点代入方程值做加法得到。<br>【注】：上面只是研究了逆时针45度到90度的圆弧，其他圆弧可以通过坐标对称得到。</li>
<li>具体代码如下：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//圆弧的中点算法</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">MidPointCircle</span>(<span class="params"><span class="keyword">int</span> R,<span class="keyword">int</span> red,<span class="keyword">int</span> green,<span class="keyword">int</span> blue,<span class="keyword">int</span> centre_x=<span class="number">0</span>,<span class="keyword">int</span> centre_y=<span class="number">0</span></span>)</span>&#123;</div><div class="line">	glBegin(GL_POINTS); </div><div class="line">	glColor3f(red,green,blue);</div><div class="line">	<span class="comment">//初始化中点算法的d,即d</span></div><div class="line">	<span class="keyword">int</span> d=<span class="number">5</span><span class="number">-4</span>*R;</div><div class="line">	<span class="keyword">int</span> x=<span class="number">0</span>;</div><div class="line">	<span class="keyword">int</span> y=R;</div><div class="line">	<span class="comment">//初始化E和SE</span></div><div class="line">	<span class="keyword">int</span> E=<span class="number">12</span>;</div><div class="line">	<span class="keyword">int</span> SE=<span class="number">20</span><span class="number">-8</span>*R;</div><div class="line">	<span class="comment">//定义八分之一圆弧x的最大值</span></div><div class="line">	<span class="keyword">float</span> xMax=R*<span class="number">1.414</span>/<span class="number">2</span>;</div><div class="line">	<span class="keyword">for</span>(;x&lt;=xMax;x++)&#123;</div><div class="line">        glVertex2d(x+centre_x,y+centre_x);</div><div class="line">		glVertex2d(-x+centre_x,y+centre_x);</div><div class="line">		glVertex2d(x+centre_x,-y+centre_x);</div><div class="line">		glVertex2d(-x+centre_x,-y+centre_x);</div><div class="line">		glVertex2d(y+centre_x,x+centre_x);</div><div class="line">		glVertex2d(-y+centre_x,x+centre_x);</div><div class="line">		glVertex2d(y+centre_x,-x+centre_x);</div><div class="line">		glVertex2d(-y+centre_x,-x+centre_x);</div><div class="line">		<span class="keyword">if</span>(d&lt;=<span class="number">0</span>)&#123;</div><div class="line">			d+=E;</div><div class="line">			E+=<span class="number">8</span>;</div><div class="line">			SE+=<span class="number">8</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span>&#123;</div><div class="line">			y--;</div><div class="line">			d+=SE;</div><div class="line">			E+=<span class="number">8</span>;</div><div class="line">			SE+=<span class="number">16</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	glEnd();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p><font size="4" color="red">扫描转换圆弧：多边形逼近法</font><br>平时生活学习中，我们都知道正多边形边数越多，就会越像一个圆。多边形逼近法就是源自于此：根据已知的圆半径（圆心在原点），求出多边形的各个顶点，再依次连起来就像一个圆了。</p>
<p>那么根据什么规则来求多边形顶点呢？主要有两种，一种是把多边形作为圆的内接正多边形，另一种是把多边形作为与圆等面积且圆心重合的正多边形。如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147792454828.png" alt=""></p>
<ul>
<li><p>内接正多边形逼近法：<br>点$P_i$的坐标如下：<br>$$<br>\begin{array}{l}<br>x_i=R \cos \theta_i \\<br>y_i=R \sin \theta_i \\<br>\end{array}<br>$$<br>点$P_{i+1}$的坐标如下：<br>$$<br>\begin{array}{l}<br>x_{i+1}=R \cos (\theta_i+\alpha) \\<br>y_{i+1}=R \sin (\theta_i+\alpha) \\<br>\end{array}<br>$$<br>用三角变化可以得到如下矩阵方程式：<br>$$<br>\begin{array}{c c c c}<br>\begin{pmatrix}<br>x_{i+1} \\<br>y_{i+1} \\<br>\end{pmatrix}<br>&amp;<br>=<br>&amp;<br>\begin{pmatrix}<br>\cos \alpha &amp; -\sin \alpha \\<br>\sin \alpha &amp; \cos \alpha \\<br>\end{pmatrix}<br>&amp;<br>\begin{pmatrix}<br>x_i \\<br>y_i \\<br>\end{pmatrix}<br>\end{array}<br>$$<br>其中，$\alpha$是正多边形对应的圆心角，是一个常数（为什么是常数后文会讲到）。所以$\sin \alpha，\cos \alpha$只需要在开始时计算一次，之后的每一个顶点坐标都只需要4次乘法即可。</p>
<p>那么圆心角到底是多少呢？也就是正多边形多少条边合适？当然是边数越多越好，越像圆。但是计算机计算能力有限，不可能边数搞得特别特别大，而且在实际问题中经常也不需要那么圆，有时候可能稍微像圆一点就可以，有时候可能需要再圆一点。到底要多圆就根据实际问题能够接受的多大的误差而定了。我们经常用最大逼近误差d来表示这个能接受的最大误差。</p>
<p>最大逼近误差d是什么玩意？词穷了，我也不知道咋描述能简单通俗易懂，所以直接看图吧！<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147798894595.png" alt=""><br>d就是边中点到另一点（其半径与圆弧交点）的距离。<br>也就是说这个d通常是已知的，那么圆心角就能算出来了（计算过程不再赘述了~），即$\alpha=2\arccos(R-d)/R$。<br>总结一下：</p>
<ul>
<li>基本思想：根据最大逼近误差d求出圆心角，再由圆心角和半径求出多边形各顶点的坐标，把各顶点依次连接起来（使用OpenGl画多边形的方法），就成了一个近似圆。</li>
<li>具体代码如下：</li>
</ul>
</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//圆弧的正内接多边形逼近法</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">CircleIn</span>(<span class="params"><span class="keyword">float</span> MaxError,<span class="keyword">float</span> R,<span class="keyword">int</span> red,<span class="keyword">int</span> green,<span class="keyword">int</span> blue,<span class="keyword">int</span> centre_x=<span class="number">0</span>,<span class="keyword">int</span> centre_y=<span class="number">0</span></span>)</span>&#123;</div><div class="line">	glBegin(GL_LINE_LOOP); </div><div class="line">	glColor3f(red,green,blue);</div><div class="line">	<span class="comment">//初始化正内接多边形对应圆心角</span></div><div class="line">	<span class="keyword">float</span> alpha=<span class="number">2</span>*acos((R-MaxError)/R);</div><div class="line">	<span class="comment">//初始化边数，即顶点个数</span></div><div class="line">	<span class="keyword">int</span> n=<span class="number">2</span>*<span class="number">3.14</span>/alpha;</div><div class="line">	</div><div class="line">	<span class="keyword">float</span> cosAlpha=cos(alpha);</div><div class="line">	<span class="keyword">float</span> sinAlpha=sin(alpha);	</div><div class="line">	<span class="keyword">float</span> x=<span class="number">0</span>;</div><div class="line">	<span class="keyword">float</span> y=R;</div><div class="line">	<span class="keyword">float</span> xTemp;</div><div class="line">	<span class="keyword">float</span> yTemp;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</div><div class="line">		glVertex2d(x+centre_x,y+centre_y);</div><div class="line">		xTemp=x;</div><div class="line">		yTemp=y;</div><div class="line">		x=cosAlpha*xTemp-sinAlpha*yTemp;</div><div class="line">		y=sinAlpha*xTemp+cosAlpha*yTemp;</div><div class="line">	&#125;</div><div class="line">	glEnd();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>等面积正多边形逼近法：<br>在圆内接正多边形逼近法中，正多边形是内接于圆的，总感觉上面画出来的正多边形比圆要小，毕竟是内接嘛~那么有没有和圆差不多大的？减少一点这种差距。那干脆找一个面积和圆一样大，且圆心重合的正多边形把，这就是等面积正多边形逼近法（参见前面的“等面积多边形”一图）。</p>
<p>由于圆面积和正多边形面积相等，所以相同圆心角对应的扇形（圆的一部分）和三角形（正多边形的一部分）面积应该相等，如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147808731637.png" alt=""><br>图中的扇形ODCE和三角形$OP_iP_{i+1}$面积应该相等，再结合给定（在圆的参数方程中给定的）的圆半径R和最大逼近误差d，可以算出圆心角$\alpha$和正多边形半径$OP_i$的长度。知道了正多边形的圆心角和半径长度，自然就能算出正多边形个顶点的坐标了（求法和内接正多边形一致）。</p>
<p>基本原理和具体代码和内接正多边形逼近法类似，不再赘述了。</p>
</li>
</ul>
<p>【注】：可以看出，中点算法是基本线画图元的高效扫面转换算法，因为算法中只用到了整数加法运算，但中点算法是有条件的：所要画的图元必须具有正负划分性，像在直线上方就是正，下方就是负；在圆外面就是正，里面就是负。像Bezier曲线这种可以自交没有正负划分性的曲线，是无法用中点算法画出来的。<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147808824303.png" alt=""><br>&nbsp;</p>
<hr>
<p>上面研究的都是直线、圆弧这些线画图元，那么那些填充图元（包括边界和其内部的图形）又是怎么画出来的呢？主要有两种方法：扫描转换（参数→点阵）、填充（点阵→点阵）。先来看个最简单的：扫描转换矩形。<br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">扫描转换填充图元矩形</font><br>既然是扫描转换，那填充图元——矩形的参数形式提供了哪些参数呢？有两个：左下角坐标、右上角坐标。这足以定义一个填充的矩形了。</p>
<p>扫描转换时，只需要从左下角开始向右（x增大）、向上（y增大）一个一个描像素点，知道右上脚为止。代码就是x和y增大的两重循环，这里不再赘述了。<br>&nbsp;</p>
<hr>
<p>矩形可以这么画，但是其它多边形呢？当然要另寻他法了~~~那矩形也是多边形，为何不归为多边形画法，而要单独分出来呢？这是因为矩形的画法相当简单，没有必要去用其他多边形的那些复杂画法，而且矩形在计算机中相当常见，所以需要把这简单的单独分出来，不能把简单的搞复杂了~-~。下面来看看除了矩形以外的其他多边形是怎么画出来的。</p>
<p><font size="5" color="orange">扫描转换填充图元多边形</font><br>扫描转换多边形其实就是把多边形的顶点表示形式转换成点阵表示形式。在介绍画法之前，先来看看几个问题：</p>
<ul>
<li>共享边界如何处理？<br>如下图：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147809048081.png" alt=""><br>那个共享边界应该属于哪个矩形？介于此，对共享边界有个处理原则：左闭右开、下闭上开。所以上图那个共享边界应该是属于黑色矩形。</li>
<li><p>在扫描转换中，经常会提到多边形的凹凸性。所以做个解释（只考虑简单多边形，即不会自交）：</p>
<ul>
<li>凸多边形：所有内角小于180度。</li>
<li>凹多边形：存在内角大于180度。</li>
</ul>
<p><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147809147096.png" alt=""><br>那么如何区分多边形的凹凸性呢？主要有两种方法：</p>
<ul>
<li>顶点同侧异侧法：对于多边形的每条边，所有顶点都在这条边所在直线的同侧，则是凸多边形；如果存在异侧的，就是凹多边形。</li>
<li>向量叉积法：沿顺时针或逆时针，把每条边看作一个向量，如果所有相邻边向量叉积同号，则是凸多边形，否则是凹多边形。</li>
</ul>
</li>
</ul>
<p>说了这么多，到底怎么扫描转换多边形呢？主要有三种方法： 逐点判断法、扫描线算法、种子填充法。</p>
<p><font size="4" color="red">扫描转换填充多边形：逐点判断法</font><br>逐点判断法就是在绘图窗口内，一个一个地去判断像素是否位于多边形内，若是，则用指定颜色绘制该像素。</p>
<p>那么如何判断一个像素是否位于多边形内呢？第一感觉可能是用数学计算来判断，好吧，那先来一个粗暴的。这里主要介绍射线法。来画个图找点灵感：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147809441075.png" alt=""><br>从上图会发现一个规律：从像素点作一条水平向右的射线，如果与多边形的交点个数是偶数，则该像素点位于多边形外边，如果交点个数是奇数，则该像素点位于多边形里面。</p>
<p>是吗？反例来了~如下图：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147809530882.png" alt=""><br>~居然有出格的~那给个规定：</p>
<ol>
<li>如果射线与边重合，则视为无数个交点，这时直接判断像素点是否在边上。</li>
<li>如果交点为顶点，以此顶点为端点的两条边在射线同侧，则视为两个交点；如果在射线异侧，则视为1个交点。</li>
</ol>
<p>这样应该是没有反例了~根据上诉规律，即可判断一个像素点是否在多边形内。However，交点怎么求？用射线去和多边形的所有边通过方程求交点~不言而喻，射线法的效率低、花费大。</p>
<p>射线法为何效率低？主要是它忽略了多边形内部点的连续性，把它们离散处理了。当一个点在多边形内部时，通常它周围的点也会在多边形内部，这就是这里点的连续性。</p>
<p><font size="4" color="red">扫描转换填充多边形：扫描线算法</font><br>同样，画个图找点灵感：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147817739477.png" alt=""><br>图中的水平虚线就是一条一条的扫描线（一般扫描线都是平行于x轴的，图中每条扫面线之间画的比较远，而实际扫描时扫描线都是以像素为单位，也就是y方向上每个像素都会有一条水平扫描线穿过），我们需要画出图中的多边形。</p>
<p>一条一条来看吧~。y=1的扫描线与多边形交于两点（水平线不参与交点计算）：P1(5，1)、P2(7，1)；y=2的扫描线也与多边形交于两点：(4，2)、(8.25，2)；……而且多边形在这些扫描线上要填充的像素点，也恰好是在扫面与多边形的两个交点之间。比如在y=1时，就把交点P1、P2之间的所有像素点描出来；在y=2时，就把交点(4，2)、(8.25，2)之间的所有像素点描出来…….直到y=7的扫描线时，我们应该已经画出了如下填充图形（不要纠结扫描线宽度，当做扫描线宽度为一个像素来理解就可以了）：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147817896328.png" alt=""><br>但是当y=7时，扫描线与多边形有3个交点，当y=7.5时，扫描线又与多边形有4个交点（扫描线当然不会是小数，不过整数扫描线与多边形有4个交点的情况确实存在，只是这幅图找不出来，所以用7.5冒充了~-~），而且应该填充的像素点在头两个交点之间和后两个交点之间。结合之前只有两个交点的情况，好像有一个规律：把交点两两配对后，要填充的像素就在每一对交点之间。但是y=7却只有3个交点，无法两两配对，回想前面射线法是把顶点P5当做两个交点来看的，正好抄过来用一下，规定：两条边都在扫描线同一侧的顶点看作两个交点。这样y=7也可以两两配对了，扫描线一直上升到y=8甚至y=11时都可以实现交点两两配对。</p>
<p>扫描线从y=1上升到y=11，把配对的交点之间的像素点描上颜色，就画出了这个不规则的填充多边形。这就是扫描线转换多边形。</p>
<p>but同样的，我们要来看看它的效率怎么样。在两个交点之间填充像素点好说，因为扫描线是水平的，两交点的y值肯定相等，只需要让x坐标从左交点一直增大到右交点即可。但是交点怎么办？扫描线虽然是水平的，都是x=？的水平直线，那把它代入多边形边的直线方程求交？显然这又增加了一堆乘除法运算，效率很低。那有没有效率好点的求交点算法？恩~用方程求点，前面我们是不是看到过，扫描转换直线的第一个方法就是方程法，因为每个点都有一堆计算，所以放弃了方程法，效率太低，改为研究DDA算法了。那么这里能不能借用DDA的思想？其实原理是一致的，之前求扫描线与多边形的交点，忽略了扫描线上升时，多条扫描线与同一条边的交点之间其实是有联系的（因为在同一条直线上嘛）：同一条边上相邻交点的y值差1，x值正好差一个斜率的倒数。比如y=1时与边e0的交点P1（5,1）和y=2时与边e0的交点（4,2），第二个交点比第一个交点y+1（因为扫描线上升了一个像素），而第二个交点比第一个交点x-1（因为边e0的斜率为-1）；再比如y=1时与边e2的交点P2（7,1）和y=2时与边e2的交点（8.25,2），第二个交点比第一个交点y+1（因为扫描线上升了一个像素），而第二个交点比第一个交点x+1.25（因为边e2的斜率倒数是1.25）。</p>
<p>这样一来，我们只需要知道多边形中每条边的斜率倒数和其下端点x坐标就行，因为在同一条边上的其他交点都可以通过该边的下端点x坐标和斜率倒数做加法求出来。比如知道了边e0的和边e2的斜率倒数和其下端点坐标P1、P2，那后面边e0在y=2、3、4时的交点都可以求出来了，边e2在y=2、3、4、5时的交点也可以求出来了。但是到了y=4时，边e0变成了边e6；到y=5时，边e2也变成了边e3；到y=7时，又增加了边e5和边e4；到y=8时，边e5、e6都没了；到y=11时，仅剩的边e4和e3也没了，一条边也没了。在这过程中，有些边会加进来，有些边会删除，那什么时候加边？什么时候删除边？在回顾一下上面的过程，我们就会发现当扫描线上升到边的下端点时（扫描线y值达到了边下端点的y值），该边就会加进来配对；当扫描线上升到边的上端点时（扫描线y值达到了边上端点的y值），该边就会被删除，退出配对。所以除了边的斜率和其下端点x坐标，还需要下端点的y坐标、上端点的y坐标。</p>
<p>有这么多边，自然在数据结构中应该设置一个容器来存储这些边（包括边的下端点x坐标、上端点y坐标和斜率倒数，这些是已知的参数，由用户输入），那用什么容器来存储呢？第一反应当然是用数组去存储所有边，当扫描线y=1时，去遍历这个边数组，看哪条边下端点y=1就把该边加入配对队伍里，看哪条边上端点y=1就把该边从配对队伍里剔除。这个配对队伍和存储所有边的数组是同一个容器吗？当然不是~否则剔除之后到哪去遍历所有边，所以还需要另一个容器来存储那些需要去配对的边（给需要去配对的起个名字吧，叫：活性边）。那应该用什么容器来存储这些活性边呢？由于需要频繁插入、删除，而且扫描过程中，活性边容器中有多少边是不确定的，可能一会多一会少，用固定大小的数组无疑很浪费空间，而且不易于插入删除，鉴于此，存储活性边的容器选链表比较合适（可参考<a href="http://popperelay.com/2016/08/24/%E9%93%BE%E8%A1%A8/" target="_blank" rel="external">《数据结构与算法之链表》</a>）一文。</p>
<p>那链表中的活性边如何配对呢？看看上图，比如在y=7.5的扫描线，此时的活性边是e6、e5、e4、e3，应该是e6和e5配对、e4和e3配对，放到图中刚好是从左至右两两配对。从左至右？这不就是x从小到大嘛！e6在e5左边，可见应该是下端点x小的在左边，即活性边按照下端点x坐标从小到大排序；but边e5和e4下端点x相等，e5在e4左边，可见当下端点x相等时，按照上端点x从小到大排序。</p>
<p>故活性边链表中的边，应该是按照下端点x值由小到大排序的，如果下端点x值相等再按照上端点x值由小到大排序（边表中每条链表里的边都是按上端点x值由小到大排序的，所以从边表里依次插入到活性边表后，下端点x值相等的边肯定是按照上端点x值由小到大排序的，所以边结构体中也就不需要上端点x坐标这个数据成员了，可参考代码进行理解）。不管怎么说，这些活性边需要按x值排序，那么采用哪种排序算法呢？因为多边形的活性边数据量不是很大，没有必要采用那些改进排序，用简单排序就好；而这些活性边应该是随着扫描线上升，动态地从链表中加入或删除，并不是一开始就全部在链表中的，所以采用冒泡排序和选择排序都不大适合，而且在简单排序中插入排序效率是最高的，所以这里对活性边的排序应该选择插入排序（关于排序可参考<a href="http://popperelay.com/2016/09/03/%E7%AE%80%E5%8D%95%E6%8E%92%E5%BA%8F/" target="_blank" rel="external">《数据结构与算法之简单排序》</a>和<a href="http://popperelay.com/2016/09/03/%E6%94%B9%E8%BF%9B%E6%8E%92%E5%BA%8F/" target="_blank" rel="external">《数据结构与算法之改进排序》</a>）。<br>活性边表AEL（Active Edge List）中的结点存储着边的相关信息，即边的斜率（用于求同一条边上下一个交点坐标）、当前扫描线与边的交点的x坐标（初始值为其下端点x坐标，由边表复制而来，用于求同一条边上下一个交点坐标）、上端点y坐标（用于从活性边表中删除不再参与配对的边）。活性边表结构如下图：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147823109648.png" alt=""><br>结点中的4个数据成员依次是：上端点y坐标、<strong>当前交点</strong>的x坐标、斜率倒数、指向下一个结点的指针</p>
<p>存储活性边的容器选定为采用插入排序的链表了，再回过头来看看最初存储所有边的容器数组，难道扫描线每上升一次都要去遍历整个数组，找出哪些边该插入哪些边该删除~~~看图中，y=7时，应该把哪些边加入活性边表中？很显然是e5和e4，这是我们根据规律肉眼看出来的。那有没有办法当y=7时，计算机也能直接知道应该加入哪些边？把y=7时应该加入的边事先列出来存储在某一个地方不就好了么~-~就好像今天是星期天，我们应该上哪些课？通常我们是直接去查课表（课表中只有星期几和这天该上的课，不包括诸如8点到10点这些具体时间），因为课表里存储着星期几和该上哪些课。我们这里的y=？（y=几）也就相当于星期几，我们需要另一个类似课表的容器去存储y=？时应该加入活性边表的边。想想如果你要存储上面的课表，你会选用哪种容器。第一反应肯定还是最简单的数组，用数组的下标表示星期几，数组的内容表示当天应该上哪些课。但是每天上的课都不是一样多的啊，数组的内容应该取为多大才好？下标为0的数组元素可以存储2个课程结构体（因为可能想要知道课名、上课老师…等等相关内容，课程就对于多边形的边，需要知道边的斜率、下端点x坐标、上端点y坐标等），还是5个课程结构体，还是其他个数的课程结构体？这显然是不确定的，如果把数组元素内容大小设为最大长度（如一天最多上10节课），这无疑会浪费很多存储空间（可能某一天要上10节课，但另一天一节课也不上，不就浪费了10个存储空间~），所以定容的数组是不适合的，每个数组元素应该采用不定长的链表。注意是每个数组元素，就是说一周有7天是固定的，可以用大小为7的数组来表示这7天，但是每一个数组元素（每一天）能装下的课程数量是不定的，需要用链表来表示。也就是说每一个数组元素应该装一个不定长的链表，但是数组元素的容量是固定的，比如int a[7]，每个数组元素只能存放4个字节，总不能把一整条链表都装到数组元素里去吧！但是既然是链表，我们可以在数组元素里装一个指向链表第一个结点的指针啊，指针的大小是固定的（常见的是4个字节）。</p>
<p>这样，就解决了存储所有边应该用哪种容器：用一个大小等于扫描线条数（其实大小这里可以改进，毕竟不是每一条扫描线都有边会加入到活性边表中去，只存储那些需要加边的扫描线也是可以的）的数组表示扫描线的y=几，每个数组元素里存储着一个指向链表的指针；这个链表中存储着y=？时应该加入活性边表中的边。如下图所示（ET表示边表（Edge Table），即我们这个容器的名字）：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147823109698.png" alt=""><br>如此，当扫描线上升到某个y值时，就可以直接从边表ET中读出需要加入活性边表AET的边。</p>
<p>边表中链表结点是什么样呢？链表中存储着应该加入活性边表的边，也就是这些链表中的每一个结点就表示了多边形的一个边，所以这些结点应该存储着边的相关信息，即边的斜率（用于求同一条边上下一个交点坐标）、其下端点x坐标（用于求同一条边上下一个交点坐标）、上端点y坐标（用于从），而且每条链表中存储的边（即结点）对应到图中都应该是从左到右排序的，即每条链表中的结点是按照边上端点x值由小到大排序的（这种顺序是在建立边表时人为就排好的，一般不需要再使用排序算法让计算机去排序）。因为边表中每一条链表中存储的边，都是按上端点x有序排列的，所以依次复制插入到活性边表后，下端点相同的边也就按照上端点x值由小到大排序好了。省去了到活性边表中按照上端点x再排一次，节省了很多花费。</p>
<p>弄清了边表中结点的数据成员和链接次序后，对图中多边形建立的完整边表如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147824486021.png" alt=""></p>
<ul>
<li>回顾多边形扫描过程结合需要建立的数据结构，扫描线算法总结如下：<ol>
<li>建立边表ET</li>
<li>将扫描线纵坐标y的初始值置为ET中非空元素的最小序号，如图中，y=1</li>
<li>置活性边表AEL为空（初始化活性边表头结点）</li>
<li>执行下列步骤直到ET和AET都为空<br>4.1. 如果ET中的第y类非空，则将其中的所有边取出并复制插入到AEL中<br>4.2. 如果有新边要插入AEL，则对AEL各边进行插入排序<br>4.3. 对AEL中的边两两配对（第1个和第2个为一对，第3个和第4个为一对……），将每队边中x坐标按规则取整，获得有效的填充区段，再填充<br>4.4. 将当前扫描线纵坐标y值加1<br>4.5. 将AEL中满足y=ymax（扫描线达到了某边上端点）的边删去（每条边是被看作下闭上开的，即下端点属于该边，但上端点不属于该边）<br>4.6. 对AEL中剩下的每条边的x加斜率倒数delta，即x=x+delta</li>
</ol>
</li>
</ul>
<p>【注】：由于边的斜率倒数可能是小数，如e2的斜率倒数是1.25，所以每次算出来的交点是一个小数，但是描点的时候只能是整数值，所以4.3中，描点时需要对配对的交点的x坐标取整（这样也能在填充时减少浮点数的出现），取整规则是：让取整后的交点坐标都落在多边形内。即配对的交点中，左边的交点向右取整（通常采用int(…)+1），右边的交点向左取整（通常采用int(…)）。</p>
<ul>
<li>用扫描线算法来扫描转换多边形的具体代码如下（代码里的多边形坐标比前面多边形图中扩大了10倍）：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#include&lt;iostream&gt;</span></div><div class="line"><span class="meta">#include&lt;math.h&gt;</span></div><div class="line"><span class="meta">#include&lt;gl/glut.h&gt;</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="title">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> infinity=<span class="number">65535</span>; <span class="comment">//表示一个不可能的数</span></div><div class="line"></div><div class="line"><span class="comment">//建立边表ET中的链表结点（边结点）数据结构</span></div><div class="line"><span class="keyword">class</span> <span class="title">ETListNode</span>&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="keyword">float</span> xBottom;        <span class="comment">//边的下端点x坐标</span></div><div class="line">	<span class="keyword">float</span> delta;          <span class="comment">//边的斜率倒数</span></div><div class="line">	<span class="keyword">int</span> yTop;             <span class="comment">//边的上端点y坐标</span></div><div class="line">	ETListNode* nextEdge; <span class="comment">//指向下一个链表结点的指针</span></div><div class="line"></div><div class="line">	ETListNode()&#123;</div><div class="line">		xBottom=infinity;</div><div class="line">		delta=infinity;</div><div class="line">		yTop=infinity;</div><div class="line">		nextEdge=NULL;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//建立边表ET中的数组元素的结构</span></div><div class="line"><span class="keyword">class</span> <span class="title">ETArray</span>&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	ETListNode* ToETList;   <span class="comment">//指向链表的指针</span></div><div class="line">	</div><div class="line">	ETArray()&#123;</div><div class="line">		ToETList=NULL;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//边表</span></div><div class="line"><span class="keyword">class</span> <span class="title">ET</span>&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	ETArray etArray[<span class="number">110</span>];</div><div class="line">	ETListNode edges[<span class="number">6</span>];</div><div class="line"></div><div class="line">	ET()&#123;</div><div class="line">		edges[<span class="number">0</span>].yTop=<span class="number">40</span>;</div><div class="line">		edges[<span class="number">0</span>].xBottom=<span class="number">50</span>;</div><div class="line">		edges[<span class="number">0</span>].delta=<span class="number">-1</span>;</div><div class="line">		edges[<span class="number">1</span>].yTop=<span class="number">50</span>;</div><div class="line">		edges[<span class="number">1</span>].xBottom=<span class="number">70</span>;</div><div class="line">		edges[<span class="number">1</span>].delta=<span class="number">5.0</span>/<span class="number">4</span>;</div><div class="line">		edges[<span class="number">2</span>].yTop=<span class="number">80</span>;</div><div class="line">		edges[<span class="number">2</span>].xBottom=<span class="number">20</span>;</div><div class="line">		edges[<span class="number">2</span>].delta=<span class="number">0</span>;</div><div class="line">		edges[<span class="number">3</span>].yTop=<span class="number">110</span>;</div><div class="line">		edges[<span class="number">3</span>].xBottom=<span class="number">120</span>;</div><div class="line">		edges[<span class="number">3</span>].delta=<span class="number">0</span>;</div><div class="line">		edges[<span class="number">4</span>].yTop=<span class="number">80</span>;</div><div class="line">		edges[<span class="number">4</span>].xBottom=<span class="number">70</span>;</div><div class="line">		edges[<span class="number">4</span>].delta=<span class="number">-5</span>;</div><div class="line">		edges[<span class="number">5</span>].yTop=<span class="number">110</span>;</div><div class="line">		edges[<span class="number">5</span>].xBottom=<span class="number">70</span>;</div><div class="line">		edges[<span class="number">5</span>].delta=<span class="number">5.0</span>/<span class="number">4</span>;</div><div class="line"></div><div class="line">		edges[<span class="number">0</span>].nextEdge=&amp;edges[<span class="number">1</span>];</div><div class="line">		edges[<span class="number">4</span>].nextEdge=&amp;edges[<span class="number">5</span>];</div><div class="line">		etArray[<span class="number">10</span>].ToETList=&amp;edges[<span class="number">0</span>];</div><div class="line">		etArray[<span class="number">40</span>].ToETList=&amp;edges[<span class="number">2</span>];</div><div class="line">		etArray[<span class="number">50</span>].ToETList=&amp;edges[<span class="number">3</span>];</div><div class="line">		etArray[<span class="number">70</span>].ToETList=&amp;edges[<span class="number">4</span>];</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//建立活性边表AET的结点结构</span></div><div class="line"><span class="keyword">class</span> <span class="title">AETListNode</span>&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="keyword">float</span> xIntersection;  <span class="comment">//当前扫描线与活性边的交点的x坐标</span></div><div class="line">	<span class="keyword">float</span> delta;          <span class="comment">//边的斜率倒数</span></div><div class="line">	<span class="keyword">int</span> yTop;             <span class="comment">//边的上端点y坐标</span></div><div class="line">	AETListNode* nextEdge; <span class="comment">//指向下一个链表结点的指针 </span></div><div class="line">	</div><div class="line">	AETListNode()&#123;</div><div class="line">		xIntersection=infinity;</div><div class="line">		delta=infinity;</div><div class="line">		yTop=infinity;</div><div class="line">		nextEdge=NULL;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//活性边表</span></div><div class="line"><span class="keyword">class</span> <span class="title">AET</span>&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	AETListNode* first;           <span class="comment">//活性边表头结点</span></div><div class="line">	</div><div class="line">	AET()&#123;</div><div class="line">		first=<span class="keyword">new</span> AETListNode();  <span class="comment">//初始化头结点</span></div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//扫描线算法画多边形</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Scan</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	ET et;</div><div class="line">	AET aet;</div><div class="line">	<span class="keyword">bool</span> etEmpty=<span class="literal">false</span>;</div><div class="line">	<span class="keyword">bool</span> aetEmpty=<span class="literal">false</span>;</div><div class="line"></div><div class="line">	<span class="keyword">int</span> y=<span class="number">0</span>;                      <span class="comment">//扫描线y值</span></div><div class="line">	<span class="keyword">while</span>(et.etArray[y].ToETList==NULL)&#123;</div><div class="line">			y++;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">while</span>(y&lt;<span class="number">110</span>)&#123;</div><div class="line">		ETListNode* currentETNode=et.etArray[y].ToETList;</div><div class="line">		<span class="keyword">while</span>(currentETNode!=NULL)&#123;</div><div class="line">			AETListNode* tempAETNode=<span class="keyword">new</span> AETListNode();</div><div class="line">			tempAETNode-&gt;yTop=currentETNode-&gt;yTop;</div><div class="line">			tempAETNode-&gt;xIntersection=currentETNode-&gt;xBottom;</div><div class="line">			tempAETNode-&gt;delta=currentETNode-&gt;delta;</div><div class="line">			</div><div class="line">			AETListNode* currentAETNode=aet.first;</div><div class="line">			<span class="keyword">while</span>(currentAETNode-&gt;nextEdge!=NULL &amp;&amp; tempAETNode-&gt;xIntersection&gt;=currentAETNode-&gt;nextEdge-&gt;xIntersection)&#123;</div><div class="line">				currentAETNode=currentAETNode-&gt;nextEdge;</div><div class="line">			&#125;</div><div class="line">			<span class="comment">//插入新边（新结点）</span></div><div class="line">			tempAETNode-&gt;nextEdge=currentAETNode-&gt;nextEdge;</div><div class="line">			currentAETNode-&gt;nextEdge=tempAETNode;</div><div class="line"></div><div class="line">			currentETNode=currentETNode-&gt;nextEdge;</div><div class="line">		&#125;</div><div class="line">		AETListNode* currentAETNode=aet.first;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;currentAETNode-&gt;nextEdge!=NULL;i++)&#123;</div><div class="line">			currentAETNode=currentAETNode-&gt;nextEdge;</div><div class="line">			<span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">1</span> )&#123;</div><div class="line">				<span class="keyword">int</span> xStart=<span class="keyword">int</span>(currentAETNode-&gt;xIntersection)+<span class="number">1</span>;</div><div class="line">				<span class="keyword">int</span> xEnd=<span class="keyword">int</span>(currentAETNode-&gt;nextEdge-&gt;xIntersection);</div><div class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> x=xStart;x&lt;=xEnd;x++)&#123;</div><div class="line">					glVertex2d(x,y);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		y++;</div><div class="line">		currentAETNode=aet.first;</div><div class="line">		<span class="keyword">while</span>(currentAETNode-&gt;nextEdge!=NULL)&#123;</div><div class="line">			<span class="keyword">if</span>(currentAETNode-&gt;nextEdge-&gt;yTop==y)&#123;</div><div class="line">				currentAETNode-&gt;nextEdge=currentAETNode-&gt;nextEdge-&gt;nextEdge;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">else</span>&#123;</div><div class="line">				currentAETNode=currentAETNode-&gt;nextEdge;</div><div class="line">				currentAETNode-&gt;xIntersection+=currentAETNode-&gt;delta;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Draw</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	gluOrtho2D(<span class="number">0</span>,<span class="number">700</span>,<span class="number">0</span>,<span class="number">600</span>);</div><div class="line">	glClearColor(<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>);</div><div class="line">	glClear(GL_COLOR_BUFFER_BIT);</div><div class="line">	glBegin(GL_POINTS);</div><div class="line">	glColor3ub(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>);</div><div class="line">	Scan();</div><div class="line">	glEnd();</div><div class="line">	glFlush();</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">mydisplay</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	Draw();</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	glutInitWindowSize(<span class="number">400</span>,<span class="number">600</span>);</div><div class="line">	glutCreateWindow(<span class="string">"扫描转换多边形"</span>);</div><div class="line">	glutDisplayFunc(mydisplay);</div><div class="line">	glutMainLoop();</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>&nbsp;</p>
<hr>
<p>在扫描线算法中用到了交点（相邻扫描线与多边形某一条边的交点）之间的连续性，即同一条边上相邻交点是有固定代数联系的。也就是说扫描线算法是从多边形的轮廓下手的，先找出多边形轮廓上的点，再去填充这些轮廓点之间的像素点。那么能不能直接从多边形内部的点下手呢？毕竟多边形内部的点连续性更明显啊：多边形内部的点通常它周围的点都会在多边形里。下面的这个算法就是利用了这点。</p>
<p><font size="4" color="red">扫描转换填充多边形：种子填充法</font><br>种子填充法是利用了多边形内部点的连续性。有两种填充方式：</p>
<ul>
<li>边界填充：首先用一种颜色（取名边界色）画出多边形轮廓，再从多边形内部任意一点开始，查看它的周围像素点（一般是上下左右）<strong>是否是边界色或者已填充色</strong>，如果都不是，则说明该点是多边形内部且暂时没有被描色的点，接下来给该点描色即可。一般采用递归的方式，让每个已描色的点都去重复上诉过程。</li>
<li><p>内点填充：依然是首先用一种不同于背景色的颜色，画出多边形轮廓，再从多边形内部任意一点开始，查看它的周围像素点（一般是上下左右）<strong>是否是背景色</strong>，如果是则说明该点是多边形内部且暂时没有被描色的点，接下来用一种不同于背景色的颜色给该点描色即可。同样采用递归的方式，让每个以描色的点都去重复上诉过程。</p>
<p>使用内点填充画五角星的代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div></pre></td><td class="code"><pre><div class="line"> <span class="meta">#include&lt;math.h&gt;</span></div><div class="line"> <span class="meta">#include&lt;gl/glut.h&gt;</span></div><div class="line"> <span class="meta">#include&lt;iostream&gt;</span></div><div class="line"> <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="title">std</span>;</div><div class="line">        </div><div class="line"> <span class="meta">#<span class="meta-keyword">define</span> PI 3.14</span></div><div class="line">        </div><div class="line"> <span class="comment">//读像素颜色</span></div><div class="line"> unsigned <span class="keyword">char</span>* GetPixel(<span class="keyword">float</span> x,<span class="keyword">float</span> y)&#123;</div><div class="line">unsigned <span class="keyword">char</span>* color=<span class="keyword">new</span> unsigned <span class="keyword">char</span>[<span class="number">3</span>];</div><div class="line">glReadPixels(x,y,<span class="number">1</span>,<span class="number">1</span>,GL_RGB,GL_BYTE,color);	<span class="comment">//调用opengl函数读取像素颜色</span></div><div class="line"><span class="keyword">return</span> color;</div><div class="line"> &#125;</div><div class="line"> <span class="comment">//写像素颜色</span></div><div class="line"> <span class="function"><span class="keyword">void</span> <span class="title">SetPixel</span>(<span class="params"><span class="keyword">float</span> x,<span class="keyword">float</span> y,<span class="keyword">int</span>* BoundaryColor</span>)</span>&#123;</div><div class="line">glBegin(GL_POINTS);	</div><div class="line">glColor3ub(BoundaryColor[<span class="number">0</span>],BoundaryColor[<span class="number">1</span>],BoundaryColor[<span class="number">2</span>]);</div><div class="line">glVertex2f(x,y);</div><div class="line">glEnd();</div><div class="line">glFlush();</div><div class="line"> &#125;</div><div class="line"> <span class="comment">//内点填充（递归）</span></div><div class="line"> <span class="comment">//参数BoundaryColor为边界色或者填充色，二者等色</span></div><div class="line"> <span class="function"><span class="keyword">void</span> <span class="title">FloodFill</span>(<span class="params"><span class="keyword">float</span> x,<span class="keyword">float</span> y,<span class="keyword">int</span>* BoundaryColor</span>)</span>&#123;</div><div class="line">unsigned <span class="keyword">char</span>* color=GetPixel(x,y);</div><div class="line"><span class="comment">//像素颜色是否等于原背景色:绿色，如果是则填为边界色</span></div><div class="line"><span class="keyword">if</span>(color[<span class="number">0</span>]==<span class="number">0</span>&amp;&amp;color[<span class="number">1</span>]==<span class="number">127</span>&amp;&amp;color[<span class="number">2</span>]==<span class="number">0</span>)&#123;</div><div class="line">	SetPixel(x,y,BoundaryColor);</div><div class="line">	FloodFill(x,y+<span class="number">1</span>,BoundaryColor);</div><div class="line">	FloodFill(x,y<span class="number">-1</span>,BoundaryColor);</div><div class="line">	FloodFill(x+<span class="number">1</span>,y,BoundaryColor);</div><div class="line">	FloodFill(x<span class="number">-1</span>,y,BoundaryColor);</div><div class="line">&#125;</div><div class="line"> &#125;</div><div class="line"> <span class="comment">//填充五角星</span></div><div class="line"> <span class="function"><span class="keyword">void</span> <span class="title">FillPentagram</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="keyword">int</span>* BoundaryColor=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];	<span class="comment">//设置边界色/已填充色</span></div><div class="line">BoundaryColor[<span class="number">0</span>]=<span class="number">255</span>;</div><div class="line">BoundaryColor[<span class="number">1</span>]=<span class="number">0</span>;</div><div class="line">BoundaryColor[<span class="number">2</span>]=<span class="number">0</span>;</div><div class="line">glColor3ub(BoundaryColor[<span class="number">0</span>],BoundaryColor[<span class="number">1</span>],BoundaryColor[<span class="number">2</span>]);</div><div class="line"><span class="comment">//指定一个种子坐标</span></div><div class="line"><span class="keyword">float</span> x0=<span class="number">0</span>;</div><div class="line"><span class="keyword">float</span> y0=<span class="number">10</span>;</div><div class="line"><span class="keyword">float</span> theta;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</div><div class="line">	<span class="comment">//旋转种子点，每次36度</span></div><div class="line">	theta=<span class="number">0.2</span>*PI*i;</div><div class="line">	<span class="keyword">float</span> x=cos(theta)*x0-sin(theta)*y0+<span class="number">300</span>;</div><div class="line">  		<span class="keyword">float</span> y=sin(theta)*x0+cos(theta)*y0+<span class="number">300</span>;</div><div class="line">	<span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)&#123;</div><div class="line">		BoundaryColor[<span class="number">0</span>]=<span class="number">255</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span>&#123;</div><div class="line">		BoundaryColor[<span class="number">0</span>]=<span class="number">127</span>;</div><div class="line">	&#125;</div><div class="line">	FloodFill(x,y,BoundaryColor);</div><div class="line">&#125;</div><div class="line"> &#125;</div><div class="line"> <span class="comment">//画五角星轮廓</span></div><div class="line"> <span class="function"><span class="keyword">void</span> <span class="title">DrawPentagramOutline</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="keyword">float</span> R=<span class="number">100</span>;	<span class="comment">//五角星外圆半径</span></div><div class="line"><span class="keyword">float</span> r=R*<span class="number">0.415</span>f;  <span class="comment">//五角星内圆半径</span></div><div class="line"><span class="keyword">float</span> point[<span class="number">10</span>][<span class="number">2</span>];</div><div class="line"><span class="keyword">float</span> point_original[<span class="number">1</span>][<span class="number">2</span>];</div><div class="line">point_original[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">300</span>;</div><div class="line">point_original[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">300</span>;</div><div class="line"></div><div class="line">glBegin(GL_LINE_LOOP);</div><div class="line">	glColor3ub(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>);</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</div><div class="line">		<span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)&#123;</div><div class="line">			point[i][<span class="number">0</span>]=r*cos(<span class="number">0.2</span>*i*PI);</div><div class="line">			point[i][<span class="number">1</span>]=r*sin(<span class="number">0.2</span>*i*PI);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span>&#123;</div><div class="line">			point[i][<span class="number">0</span>]=R*cos(<span class="number">0.2</span>*i*PI);</div><div class="line">			point[i][<span class="number">1</span>]=R*sin(<span class="number">0.2</span>*i*PI);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</div><div class="line">		glVertex2d(point_original[<span class="number">0</span>][<span class="number">0</span>]+point[i][<span class="number">0</span>],point_original[<span class="number">0</span>][<span class="number">1</span>]+point[i][<span class="number">1</span>]);</div><div class="line">	&#125;</div><div class="line">glEnd();</div><div class="line">glBegin(GL_LINES);</div><div class="line">	glColor3ub(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>);</div><div class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</div><div class="line">		glVertex2d(point_original[<span class="number">0</span>][<span class="number">0</span>]+point[i][<span class="number">0</span>],point_original[<span class="number">0</span>][<span class="number">1</span>]+point[i][<span class="number">1</span>]);</div><div class="line">		glVertex2d(point_original[<span class="number">0</span>][<span class="number">0</span>],point_original[<span class="number">0</span>][<span class="number">1</span>]);</div><div class="line">	&#125;</div><div class="line">glEnd();</div><div class="line">glFlush();</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> <span class="function"><span class="keyword">void</span> <span class="title">mydisplay</span>(<span class="params"></span>)</span>&#123;</div><div class="line">glClearColor(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>);</div><div class="line">glClear(GL_COLOR_BUFFER_BIT);</div><div class="line">glMatrixMode(GL_PROJECTION);</div><div class="line">glLoadIdentity();</div><div class="line">gluOrtho2D(<span class="number">0</span>,<span class="number">500</span>,<span class="number">0</span>,<span class="number">600</span>);</div><div class="line">DrawPentagramOutline();</div><div class="line">FillPentagram();</div><div class="line"> &#125;</div><div class="line"> <span class="function"><span class="keyword">void</span> <span class="title">main</span>(<span class="params"></span>)</span>&#123;</div><div class="line">glutInitWindowSize(<span class="number">500</span>,<span class="number">600</span>);</div><div class="line">glutCreateWindow(<span class="string">"种子填充"</span>);</div><div class="line">glutDisplayFunc(mydisplay);</div><div class="line">glutMainLoop();</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>效果如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147876876527.png" alt=""></p>
</li>
</ul>
<p>可以看出，无论哪种方法，其实都需要先画出多边形轮廓的点阵信息，再根据屏幕上像素点的颜色来进行填充，所以其实是点阵到点阵的转换，已经不是严格意义上的扫描转换了。但是那些事先的轮廓点阵信息一般都是由参数形式转换而来，所以才把种子填充勉强地归为扫描转换。<br>&nbsp;</p>
<hr>
<p>到此，已经介绍完了画基本填充图元的扫描转换法。下面是另一个画法：填充法。</p>
<p><font size="5" color="orange">画填充图形：填充法</font><br>扫描转换法是把图形的参数形式转换为点阵形式，再进行显示。但是并不是每一幅图形都能用参数表示出来啊~~比如相机照出来的照片，要用参数这种数学形式表示出照片这种复杂图形估计有点难度！那就没有参数形式，只有点阵形式了，比如要在计算机上显示一幅照片，就得需要这幅照片的点阵形式，这幅照片的点阵形式是什么？当然是每一个像素点的颜色啊，所以如果知道图形每一个像素点的颜色值，则交给计算机按颜色值逐像素点描色，即可在电脑上画出这张照片。</p>
<p>所以填充法就是：按照事先知道的图形像素点颜色值，在计算机上逐点描色，从而画出图形。</p>
<p>至于怎么事先知道一幅图形的所有像素点颜色值，就得靠其它方法了，比如数码摄像机会通过电子传感器把光学影像转换成电子数据，再传输给计算机。</p>

      
    </div>
    <footer>
      
        
        
        
  <div class="addthis addthis_toolbox addthis_default_style">
    
      <a class="addthis_button_facebook_like" fb:like:layout="button_count"></a>
    
    
      <a class="addthis_button_tweet"></a>
    
    
      <a class="addthis_button_google_plusone" g:plusone:size="medium"></a>
    
    
      <a class="addthis_button_pinterest_pinit" pi:pinit:layout="horizontal"></a>
    
    <a class="addthis_counter addthis_pill_style"></a>
  </div>
  <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js"></script>

      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


<section id="comment">
  <h2 class="title">留言</h2>


 
  	   <!-- 多说评论框 start -->
 		<div class="ds-thread" data-thread-key="2016/11/06/基本光栅图形生产技术/" data-title="基本光栅图形生成技术" data-url="http://yoursite.com/2016/11/06/基本光栅图形生产技术/"></div>
		<!-- 多说评论框 end -->
		<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
		<script type="text/javascript">
		var duoshuoQuery = {short_name:"popperelay"};   <!-- 替换这里的duoshuo_shortname为前面注册的shortname -->
			(function() {
				var ds = document.createElement('script');
				ds.type = 'text/javascript';ds.async = true;
				ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.unstable.js';
				ds.charset = 'UTF-8';
				(document.getElementsByTagName('head')[0] 
				 || document.getElementsByTagName('body')[0]).appendChild(ds);
			})();
			</script>
		<!-- 多说公共JS代码 end -->
 
  
</section>

</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:yoursite.com">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/C-语法/">C#语法</a><small>2</small></li>
  
    <li><a href="/categories/C/">C++</a><small>4</small></li>
  
    <li><a href="/categories/C语言/">C语言</a><small>1</small></li>
  
    <li><a href="/categories/OpenGL/">OpenGL</a><small>28</small></li>
  
    <li><a href="/categories/c/">c++</a><small>1</small></li>
  
    <li><a href="/categories/博客配置/">博客配置</a><small>3</small></li>
  
    <li><a href="/categories/操作系统/">操作系统</a><small>4</small></li>
  
    <li><a href="/categories/数据结构/">数据结构</a><small>15</small></li>
  
    <li><a href="/categories/毕设/">毕设</a><small>1</small></li>
  
    <li><a href="/categories/游戏开发/">游戏开发</a><small>1</small></li>
  
    <li><a href="/categories/游戏设计模式/">游戏设计模式</a><small>1</small></li>
  
    <li><a href="/categories/计算机图形学/">计算机图形学</a><small>2</small></li>
  
    <li><a href="/categories/设计模式/">设计模式</a><small>5</small></li>
  
    <li><a href="/categories/调试错误集锦/">调试错误集锦</a><small>1</small></li>
  
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/BIOS和微机启动过程/">BIOS和微机启动过程</a><small>1</small></li>
  
    <li><a href="/tags/Blinn-Phong/">Blinn-Phong</a><small>1</small></li>
  
    <li><a href="/tags/C/">C</a><small>1</small></li>
  
    <li><a href="/tags/C-容器/">C#容器</a><small>1</small></li>
  
    <li><a href="/tags/C-IO/">C++IO</a><small>1</small></li>
  
    <li><a href="/tags/Gamma校正/">Gamma校正</a><small>1</small></li>
  
    <li><a href="/tags/MarkDown/">MarkDown</a><small>1</small></li>
  
    <li><a href="/tags/Mathjax语法/">Mathjax语法</a><small>1</small></li>
  
    <li><a href="/tags/OS内核/">OS内核</a><small>1</small></li>
  
    <li><a href="/tags/OpenGL坐标系统/">OpenGL坐标系统</a><small>1</small></li>
  
    <li><a href="/tags/OpenGL摄像机/">OpenGL摄像机</a><small>1</small></li>
  
    <li><a href="/tags/OpenGL窗口/">OpenGL窗口</a><small>1</small></li>
  
    <li><a href="/tags/OpenGL配置/">OpenGL配置</a><small>1</small></li>
  
    <li><a href="/tags/ShadowMap/">ShadowMap</a><small>1</small></li>
  
    <li><a href="/tags/c-特性/">c++特性</a><small>1</small></li>
  
    <li><a href="/tags/const/">const</a><small>1</small></li>
  
    <li><a href="/tags/timeTest/">timeTest</a><small>1</small></li>
  
    <li><a href="/tags/二叉树/">二叉树</a><small>1</small></li>
  
    <li><a href="/tags/交流/">交流</a><small>1</small></li>
  
    <li><a href="/tags/光照场景/">光照场景</a><small>1</small></li>
  
    <li><a href="/tags/光照贴图/">光照贴图</a><small>1</small></li>
  
    <li><a href="/tags/关键路径/">关键路径</a><small>1</small></li>
  
    <li><a href="/tags/冯氏光照/">冯氏光照</a><small>1</small></li>
  
    <li><a href="/tags/几何着色器/">几何着色器</a><small>1</small></li>
  
    <li><a href="/tags/反走样/">反走样</a><small>1</small></li>
  
    <li><a href="/tags/图/">图</a><small>1</small></li>
  
    <li><a href="/tags/图形学概述/">图形学概述</a><small>1</small></li>
  
    <li><a href="/tags/图形显示系统/">图形显示系统</a><small>1</small></li>
  
    <li><a href="/tags/外观-观察-者命令/">外观 观察 者命令</a><small>1</small></li>
  
    <li><a href="/tags/多说/">多说</a><small>1</small></li>
  
    <li><a href="/tags/天空盒子/">天空盒子</a><small>1</small></li>
  
    <li><a href="/tags/头结点/">头结点</a><small>1</small></li>
  
    <li><a href="/tags/实例化/">实例化</a><small>1</small></li>
  
    <li><a href="/tags/尾递归/">尾递归</a><small>1</small></li>
  
    <li><a href="/tags/工厂模式单例模式/">工厂模式单例模式</a><small>1</small></li>
  
    <li><a href="/tags/帧同步/">帧同步</a><small>1</small></li>
  
    <li><a href="/tags/帧缓冲/">帧缓冲</a><small>1</small></li>
  
    <li><a href="/tags/常见光源/">常见光源</a><small>1</small></li>
  
    <li><a href="/tags/异步传输/">异步传输</a><small>2</small></li>
  
    <li><a href="/tags/拓扑排序/">拓扑排序</a><small>1</small></li>
  
    <li><a href="/tags/操作系统概述/">操作系统概述</a><small>1</small></li>
  
    <li><a href="/tags/改进排序/">改进排序</a><small>1</small></li>
  
    <li><a href="/tags/文件IO/">文件IO</a><small>1</small></li>
  
    <li><a href="/tags/最小生成树/">最小生成树</a><small>1</small></li>
  
    <li><a href="/tags/最短路径/">最短路径</a><small>1</small></li>
  
    <li><a href="/tags/材质/">材质</a><small>1</small></li>
  
    <li><a href="/tags/查找/">查找</a><small>1</small></li>
  
    <li><a href="/tags/栈/">栈</a><small>1</small></li>
  
    <li><a href="/tags/树/">树</a><small>1</small></li>
  
    <li><a href="/tags/模型加载/">模型加载</a><small>1</small></li>
  
    <li><a href="/tags/模板测试/">模板测试</a><small>1</small></li>
  
    <li><a href="/tags/深度测试/">深度测试</a><small>1</small></li>
  
    <li><a href="/tags/混合/">混合</a><small>1</small></li>
  
    <li><a href="/tags/着色器/">着色器</a><small>1</small></li>
  
    <li><a href="/tags/着色器画三角形/">着色器画三角形</a><small>1</small></li>
  
    <li><a href="/tags/码农/">码农</a><small>1</small></li>
  
    <li><a href="/tags/简单排序/">简单排序</a><small>1</small></li>
  
    <li><a href="/tags/纹理/">纹理</a><small>1</small></li>
  
    <li><a href="/tags/缓冲对象/">缓冲对象</a><small>1</small></li>
  
    <li><a href="/tags/编译链接错误/">编译链接错误</a><small>1</small></li>
  
    <li><a href="/tags/背面剔除/">背面剔除</a><small>1</small></li>
  
    <li><a href="/tags/责任链模式适配器模式/">责任链模式适配器模式</a><small>1</small></li>
  
    <li><a href="/tags/进程的描述与控制/">进程的描述与控制</a><small>1</small></li>
  
    <li><a href="/tags/重定义错误/">重定义错误</a><small>1</small></li>
  
    <li><a href="/tags/链表/">链表</a><small>1</small></li>
  
    <li><a href="/tags/队列/">队列</a><small>1</small></li>
  
    <li><a href="/tags/面向对象设计原则/">面向对象设计原则</a><small>1</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2017 Elay
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




  <link rel="stylesheet" href="http://apps.bdimg.com/libs/fancybox/2.1.5/jquery.fancybox.css">




</body>
</html>