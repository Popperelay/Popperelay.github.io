<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>OpenGL3：着色器画三角形 | Elays&#39;Blog</title>
  <meta name="author" content="Elay">
  
  <meta name="description" content="Elay">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="OpenGL3：着色器画三角形"/>
  <meta property="og:site_name" content="Elays&#39;Blog"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Elays&#39;Blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">Elays&#39;Blog</a></h1>
  <h2><a href="/">你是天地生的，美得超越人形</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">主页</a></li>
    
      <li><a href="/archives">所有文章</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-11-19T08:57:47.000Z"><a href="/2016/11/19/OpenGL3着色器画三角形/">2016-11-19</a></time>
      
      
  
    <h1 class="title">OpenGL3：着色器画三角形</h1>
  

    </header>
    <div class="entry">
      
        <p>在高版本的OpenGL中绘制图形，这个过程主要是由OpenGL的<strong>图形输送管道</strong>来完成的。<br><a id="more"></a><br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">图形输送管道</font><br>图形输送管段（pipeline，管线）接收一组3D坐标，然后把它们转变为屏幕上的有色2D像素。图形输送管道可以被划分为几个阶段，每个阶段的输出都是下一个阶段的输入。所有这些阶段都是高度专门化的，它们能够简单地并行执行。由于它们的可并行执行的特征，当今大多数显卡都有成千上万的小处理核心，在GPU上为管线上的每个阶段运行各自的小程序，从而在图形输送管道中快速处理这些它的以及几何运算。这些小程序就叫做着色器（如今CPU最多只有8核，而GPU却有很多很多简单的核，可以大量并行执行那些不是很复杂的计算，比如绘制图形所用的几何运算。关于GPU可以参考这下面这个视频）。</p>
<iframe height="498" width="510" src="http://player.youku.com/embed/XMTYyMzg0MDUzMg==" frameborder="0" 'allowfullscreen'=""></iframe>

<p>有些着色器允许开发者自己配置，用我们自己写的着色器替换默认存在的。这样我们就可以更细致地控制输送管道的特定部分了。因为它们运行在GPU上，所以会节约宝贵的CPU时间。着色器是用OpenGL着色器语言GLSL（OpenGL Shading Language）写的。</p>
<p>图形输送管道的每个阶段如下（蓝色部分代表的是我们可以自定义的着色器）：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147936366377.png" alt=""><br>如你所见，图形输送管道包含很多部分，从最初的顶点数据转变为最终的有色像素。</p>
<p>现在我们用数组的形式传递3个3D坐标作为图形输送管道的输入，它们用来表示一个三角形，这个数组叫做这个三角形的顶点数据（Vertex Data）。除此之外，简单的顶点数据还通常包括顶点的颜色值。</p>
<p>【注】：</p>
<ul>
<li>为了让OpenGL知道我们的坐标和颜色值到底构成了什么，OpenGL需要我们去给出提示，希望这些数据所表示的是什么类型，是一些列的点？一些列的三角形？还是一条线？做出的这些提示叫做基本图形（primitives）。任何一个绘制命令的调用都必须把基本图形类型传递给OpenGL。这是基本图形类型中的几个：GL_POINTS（点）、GL_TRIANGLES（三角形）、GL_LINE_STRIP（连续折线）。</li>
</ul>
<p>下面简单介绍一下图形输送管道的每个部分：</p>
<p>顶点着色器（vertex shader）阶段把一个单独的顶点作为输入。主要目的是把3D坐标转换为另一种3D坐标（后续文章会与解释），同时允许我们队顶点属性进行一些基本处理。顶点着色器阶段会把表示基本图形的所有顶点输出到基本图形组装阶段，作为它的输入。</p>
<p>基本图形组装（primitive assembly）阶段把所有输入的点作组装为特定的基本图形的形状（本文例子是一个三角形）。基本图形组装阶段的输出会传递给几何着色器。</p>
<p>几何着色器（geometry shader）可以通过产生新顶点构造出新的（或是其他的）基本图形，来生成其他形状。</p>
<p>细分着色器（tessellation shader）可以把给定的基本图形细分成更多小基本图形。这样我们就能在物体更接近玩家的时候通过创建更多的三角形，用这种方式创建出更平滑的视觉效果。</p>
<p>像素化（rasterization，也叫光栅化） 阶段会把基本图形映射为屏幕上相应的像素，生成供像素着色器使用的fragment。并且在像素着色器允许之前，会执行裁剪（clipping）。裁剪会丢弃超出视图以外的那些像素，来提升执行效率。</p>
<p>【注】：</p>
<ul>
<li>OpenGL中的一个fragment是OpenGL渲染一个独立像素所需的所有数据。其实就是带有一些额外信息的像素，由于带有额外信息，OpenGL就没有给它取名叫像素。</li>
</ul>
<p>像素着色器的主要目的是计算一个像素的最终颜色，这也是OpenGL高级效果最终产生的地方。通常，像素着色器包含用来计算像素最终颜色的3D场景的一些数据（比如关照、阴影、关的颜色等等）。在所有颜色值确定后，最终它会传到下一个alpha测试和混合（blending）阶段。</p>
<p>alpha测试和混合阶段检测像素的深度值和stencil值，来检查一个像素是否被遮挡了，从而做出取舍（即如果被遮住了就不画这个像素了）。还会查看alpha值（透明度）和物体之间的混合。所以即使在像素着色器中计算出来了一个像素将要输出的颜色，最后的像素颜色在渲染多个三角形的时候也可能会再发生变化，因为有遮挡和alpha混合存在。</p>
<p>应该说这个图形输送管道还是挺复杂的，包含很多要配置的部分。但是大多数场合，我们必须做的只是顶点和像素着色器。几何着色器和细分着色器是可选的，通常使用默认的着色器就行了。<br>&nbsp;</p>
<hr>
<p>在开始绘制之前，我们必须给OpenGL输入一些顶点数据。</p>
<p><font size="5" color="orange">顶点输入</font><br>OpenGL是一个3D图形库，所以我们在OpenGL中指定的坐标都是3D的，即包括x、y、z坐标。因为我们想要渲染一个三角形，所以我们需要指定三角形的3个顶点的3D坐标。为了简单起见，这里我们直接使用标准化设备坐标（x、y、z都在-1到1之间），存储在GLfloat数组中：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//三角形顶点坐标</span></div><div class="line">GLfloat vertices[] = &#123;</div><div class="line">	<span class="number">-0.5</span>f,<span class="number">-0.5</span>f,<span class="number">0.0</span>f,</div><div class="line">	<span class="number">0.5</span>f,<span class="number">-0.5</span>f,<span class="number">0.0</span>f,</div><div class="line">	<span class="number">0.0</span>f,<span class="number">0.5</span>f,<span class="number">0.0</span>f</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>由于我们要画的是一个2D的三角形，所以就把3个顶点的z坐标都设为0了，即每个顶点的深度（depth）都是一样的，看上去就像是2D的。</p>
<p>【注】：</p>
<ul>
<li>标准化设备坐标会通过glViewport函数提供的数据，进行视口变换，最后转换为屏幕空间坐标。这通常都是在顶点着色器中进行的，这些屏幕空间坐标最终会作为像素属性输入到像素着色器。</li>
</ul>
<p>现在有了这样的顶点数据，我们需要把它输入发送给GPU，从而进入顶点着色器阶段。</p>
<p>在发送顶点数据之间，我们需要建立一个顶点数组对象VAO（vertex array object），用于记录顶点数据的存储和如何使用的细节信息。后面我们会告示OpenGL这些顶点数据是怎么存储的以及GPU应该怎么读出来，当我们需要用相同的顶点数据画多个三角形时，就不用每次都去指定这些顶点数据的存储方式和使用方式了，很节省效率：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//生成顶点数组对象VAO，记录数据的存储和如何使用的细节信息</span></div><div class="line">GLuint VAO; </div><div class="line">glGenVertexArrays(<span class="number">1</span>, &amp;VAO);</div></pre></td></tr></table></figure></p>
<p>由于CPU把数据发送到显卡相对较慢，但是GPU中顶点着色器却能很快获得顶点。如果从CPU一个顶点一个顶点地发送到显卡，无疑会造成GPU等待，浪费资源。所以我们希望把多个顶点数据一起从CPU发送到显存，这里我们使用顶点缓存对象VBO（vertex buffer object）来实际负责这些顶点数据的存储（包括存储空间和存储过程），它会在<strong>GPU</strong>内存上存储大批顶点：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//生顶点缓冲对象VBO，负责实际数据的存储</span></div><div class="line">GLuint VBO;</div><div class="line">glGenBuffers(<span class="number">1</span>, &amp;VBO);</div></pre></td></tr></table></figure></p>
<p>正如<a href="http://popperelay.com/2016/10/18/OpenGL%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" target="_blank" rel="external">《OpenGL1：OpenGL概述及环境配置》</a>一文里“OpenGL中的对象”中所诉，接下来要做的就是给顶点数组对象绑定目标（顶点数组）：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//给顶点数组对象绑定目标(顶点数组，不需要参数)</span></div><div class="line">glBindVertexArray(VAO);</div></pre></td></tr></table></figure></p>
<p>再给顶点缓冲对象绑定目标（数组内存）：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//给顶点缓冲对象绑定目标（数组内存）</span></div><div class="line">glBindBuffer(GL_ARRAY_BUFFER, VBO);</div></pre></td></tr></table></figure></p>
<p>已经在显卡上开辟好存储这些顶点的空间了，接下来我们需要顶点数据复制到显存缓冲中：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//把顶点数据复制到显卡的缓冲内存中</span></div><div class="line">glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</div></pre></td></tr></table></figure></p>
<p>glBufferData函数用来把用户定义的数据复制到当前绑定缓冲里。它的第一个参数是我们希望复制到上面的缓冲类型，这里是数组缓冲这种类型GL_ARRAY_BUFFER；第二个参数是我们希望传递给缓冲的数据大小（字节）；第三个参数是我们希望发送的真实数据；第四个参数指定了我们希望显卡如何管理给定的数据，有三种形式：</p>
<ul>
<li>GL_STATIC_DRAW：数据不会或几乎不会改变。</li>
<li>GL_DYNAMIC_DRAW：数据会被改变很多。</li>
<li>GL_STREAM_DRAW：数据每次绘制时都会改变</li>
</ul>
<p>我们要画的三角形的位置数据不会改变，每次渲染调用时都保持原样，所以它使用的类型最好是GL_STATIC_DRAW。如果一个缓冲中的数据将频繁被改变，那么使用的类型就是GL_DYNAMIC_DRAW或GL_STREAM_DRAW，因为这样能确保图形卡把数据放在高速写入的内存部分。<br>&nbsp; </p>
<hr>
<p><font size="5" color="orange">告诉OpenGL如何读取顶点数据</font><br>到现在我们只是把一堆顶点数据放到了显存的缓冲区中了，但是显卡并不知道这些顶点数据是怎么存放的，该连续多少个字节的数据才表示一个顶点坐标？不知道这些信息就无法用OpenGL函数一个一个地分开读出顶点数据。</p>
<p>下面我们使用    <code>glVertexAttribPointer</code>函数来告知OpenGL如何识别解析显存缓冲中的顶点数据：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//告诉OpenGL如何识别显存中的顶点数据</span></div><div class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(GLfloat), (GLvoid*)<span class="number">0</span>);</div></pre></td></tr></table></figure></p>
<ul>
<li>它的第一个参数指定我们要配置哪一个顶点属性。因为我们在后面的顶点着色器中使用了<code>layout (location=0)</code>来定义顶点属性的位置值为0，所以这里要把这个参数设为0。</li>
<li>第二个参数指定每个属性数据由几个分量组成。因为在本例中，顶点着色器中就一个坐标属性，由3个float组成，所以这个参数设为3（这个参数的值只能是1、2、3、4中的一个）。</li>
<li>第三个参数指定属性分量的数据类型。由于本例中每个顶点位置由3个float组成，所以该参数设为float。</li>
<li>第四个参数指定是否希望数据被规格化。如果设置为GL_TRUE，所有有符号型数据会被映射到-1到1之间，无符号型数据会被映射到0到1之间。这里我们把它设为GL_FLASE。</li>
<li>第五个参数叫做步长，表示相同属性每隔多少字节出现一次。当顶点属性紧密排列时，可以填0，由OpenGL代替我们计算出该值。本例中每隔3*sizeof(GLfloat)字节属性就会重复出现了，即又是x、y、z了。</li>
<li>最后一个参数表示当前绑定到GL_ARRAY_BUFFER缓冲对象的缓冲区中，顶点对应属性的第一个分量距离缓冲起点的偏移量，以字节为单位计算。因为最后一个参数的类型是GLvoid*，而我们的顶点数据就是从数据起点开始的，所以这里设为（GLvoid*）0。</li>
</ul>
<p>现在已经告诉OpenGL应该怎么从缓冲中解析顶点数据了，接着需要使用<code>glEnableVertexAttribArray</code>函数打开顶点属性数组，让这些顶点数据可以用于渲染图形。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//打开顶点属性数组</span></div><div class="line">glEnableVertexAttribArray(<span class="number">0</span>);</div></pre></td></tr></table></figure></p>
<p>当然，最后不要忘了解绑VBO和VAO。解绑了之后才能让它们脱离具体的目标，从而再去复用，绑定别的目标：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//解绑VBO</span></div><div class="line">glBindBuffer(GL_ARRAY_BUFFER, <span class="number">0</span>);</div><div class="line"><span class="comment">//解绑VAO</span></div><div class="line">glBindVertexArray(<span class="number">0</span>);</div></pre></td></tr></table></figure></p>
<p>&nbsp; </p>
<hr>
<p><font size="5" color="orange">顶点着色器源码</font><br>顶点着色器是几个着色器中的一个，它是可编程的。现代OpenGL需要我们至少设置一个顶点着色器和一个像素着色器。</p>
<p>我们需要做的第一件事是用着色器语言GLSL写顶点着色器，然后编译这个着色器，这样我们就可以在接下来的程序中使用这个顶点着色器了。下面是一个非常基础的顶点着色器源码：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//顶点着色器</span></div><div class="line"><span class="keyword">const</span> GLchar* vertexShaderSource = </div><div class="line">	<span class="string">"#version 330 core\n"</span></div><div class="line">	<span class="string">"layout (location=0) in vec3 position;\n"</span></div><div class="line">	<span class="string">"void main()&#123;\n"</span></div><div class="line">	<span class="string">"gl_Position=vec4(position.x,position.y,position.z,1.0);\n"</span></div><div class="line">	<span class="string">"&#125;\0"</span>;</div></pre></td></tr></table></figure></p>
<p>在引号中的就是我们的顶点着色器源码，现在把它存储在一个字符串中，方便后面用着色器名字直接使用着色器。每个着色器都起始于一个版本声明，这是因为要让高版本的GLSL和OpenGL相匹配（GLSL330对应OpenGL3.3）。我们同样在后面显示地表示我们会用core profile功能。</p>
<p>然后就是在顶点着色器中使用in关键字声明所有的<strong>输入</strong>属性。因为现在我们只关心位置数据（position），所以我们使用<code>in vec3 position</code>，同时需要指定属性的索引，即<code>layout (location = 0)</code>，何在一起就是<code>layout (location=0) in vec3 position;</code>。</p>
<p>接下来在着色器的main函数（注意是着色器的main函数）中，我们设置顶点着色器的输出，gl_Position为内置变量（以gl前缀开头的变量一般都表示内置变量），表示顶点输出位置。我们必须把输入的位置数据赋值给预定义的gl_Position（该变量是vec4类型）：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    gl_Position = vec4(position.x, position.y, position.z, <span class="number">1.0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>gl_Position会作为顶点着色器的输出发送到图形输送管道的下一阶段。在后续文章会解释vec4的第4个参数为什么是1.0f。</p>
<p>【注】：</p>
<ul>
<li>向量：在GLSL中一个向量最多可以有4个元素：x、y、z、w。但是z元素不是用作表达空间位置的，而是用在透视除法上。后续文章会介绍到。</li>
</ul>
<p>这个顶点着色器应该是能想到的最简单的了，因为我们直接输入的就是标准化设备坐标，在顶点着色器里面什么都没有处理就把输入数据输出了。但是在真是应用里输入数据通常都没有在标准化设备坐标中，所以在顶点着色器中通常都需要把它们转化为标准化设备坐标，放进OpenGL的可视区域内。<br>&nbsp; </p>
<hr>
<p><font size="5" color="orange">编译着色器</font><br>上面我们已经写了一个顶点着色器源码，但是为了让OpenGL能够使用它，我们必须在运行时动态编译它的源码。</p>
<p>通常的流程都是：创建着色器对象 → 把着色器源码附加到着色器对象 → 编译着色器 → 检测编译是否成功。</p>
<p><font size="4" color="red">创建着色器对象</font><br>使用<code>glCreateShader</code>函数创建着色器，参数是着色器类型：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//创建顶点着色器对象</span></div><div class="line">GLuint vertexShader = glCreateShader(GL_VERTEX_SHADER);</div></pre></td></tr></table></figure></p>
<p><font size="4" color="red">附加着色器源码到着色器对象</font><br>使用<code>glShaderSource</code>函数把着色器源码添加到新创建的着色器对象上：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//把着色器源码附加到着色器对象</span></div><div class="line">glShaderSource(vertexShader, <span class="number">1</span>, &amp;vertexShaderSource, NULL);</div></pre></td></tr></table></figure></p>
<p>第一个参数是着色器对象；第二个参数指定了源码中有多少个字符串，这里只有一个；第三个参数是顶点着色器真正的源码；第四个参数可以设置为NULL，表示每个字符串都没有终止，直到遇到’\0’。</p>
<p><font size="4" color="red">编译着色器</font><br>使用<code>glCompileShader</code>函数来编译着色器，参数是着色器对象：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//编译顶点着色器</span></div><div class="line">glCompileShader(vertexShader);</div></pre></td></tr></table></figure></p>
<p><font size="4" color="red">检测编译是否成功</font><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//检测编译是否成功</div><div class="line">GLint success; //编译结果</div><div class="line">GLchar infoLog[512]; //错误信息</div><div class="line">glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success);</div><div class="line">if (!success) &#123;</div><div class="line">	glGetShaderInfoLog(vertexShader, 512, NULL, infoLog);</div><div class="line">	std::cout &lt;&lt; "ERROR::SHADER::VERTEX::COMPILATION_FAILED\n" &lt;&lt; infoLog &lt;&lt; std::endl;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先定义一个整型success来表示是否成功编译，还需要一个存储错误消息的容器infoLog（如果有错误的话），然后用<code>glGetShaderiv</code>函数来检查是否编译成功了。如果编译失败，用<code>glGetShaderInfoLog</code>函数来获取错误信息，然后打印它。</p>
<p>函数<code>glGetShaderInfoLog</code>的第一个参数是编译失败的着色器，第二个参数是存储错误信息的数组大小，第三个参数是返回的错误信息字符串的长度，如果不需要可以为NULL，第四个参数是存储错误信息的字符数组。<br>&nbsp; </p>
<hr>
<p><font size="5" color="orange">像素着色器源码</font><br>像素着色器是最终我们打算创建的用于渲染三角形的着色器。像素着色器的全部，都是用来计算像素的最后颜色输出。为了简单点，我们的像素着色器只输出橘黄色（每个颜色的强度都是在0到1之间的浮点数，三种颜色可以调配处1600万中不同颜色，颜色值的第4个参数表示alpha透明度）：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//像素着色器</span></div><div class="line"><span class="keyword">const</span> GLchar* fragmentShaderSource =</div><div class="line">	<span class="string">"#version 330 core\n"</span></div><div class="line">	<span class="string">"out vec4 color;\n"</span></div><div class="line">	<span class="string">"void main()&#123;\n"</span></div><div class="line">	<span class="string">"color=vec4(1.0,0.5f,0.2f,1.0f);\n"</span></div><div class="line">	<span class="string">"&#125;\0"</span>;</div></pre></td></tr></table></figure></p>
<p>像素着色器只需要一个输出变量，这个变量是一个表示最终输出颜色的vec4向量。可以用out关键字来声明输出变量，命名为color，即<code>out vec4 color;</code>。然后在像素着色器的main函数中给输出变量color指定橘黄色，透明度为1（不透明），即<code>color = vec4(1.0f, 0.5f, 0.2f, 1.0f);</code>。<br>&nbsp; </p>
<hr>
<p><font size="5" color="orange">编译像素着色器</font><br>编译像素着色器的过程与顶点着色器一致，如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//创建像素着色器对象</div><div class="line">	GLuint fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);</div><div class="line">	//把像素着色器源码附加到像素着色器对象</div><div class="line">	glShaderSource(fragmentShader, 1, &amp;fragmentShaderSource, NULL);</div><div class="line">	//编译像素着色器源码</div><div class="line">	glCompileShader(fragmentShader);</div><div class="line">	//检测是否编译成功</div><div class="line">	glGetShaderiv(fragmentShader, GL_COMPILE_STATUS, &amp;success);</div><div class="line">	if (!success) &#123;</div><div class="line">		glGetShaderInfoLog(fragmentShader, 512, NULL, infoLog);</div><div class="line">		std::cout &lt;&lt; "ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\n" &lt;&lt; infoLog &lt;&lt; std::endl;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>&nbsp; </p>
<hr>
<p>顶点着色器和像素着色器都已经编译了，剩下的事情就是把两个着色器对象链接到一个着色器程序中，它是用来渲染的。</p>
<p><font size="5" color="orange">着色器程序</font><br>着色器程序对象（shader program object）是多个着色器最后链接的版本。如果要使用刚才编译好的着色器我们必须把它们链接为一个着色器程序对象，然后当渲染物体的时候激活这个着色器程序，才能进行利用着色器进行渲染。</p>
<p>把着色器链接为一个程序就等于把每个着色器的输出链接到下一个着色器的输入。当然，如果你的输出和输入不匹配，那么将得到一个链接错误。</p>
<p><font size="4" color="red">创建着色器程序对象</font><br>首先需要使用glCreateShader函数创建着色器程序对象：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//创建着色器程序对象</span></div><div class="line">GLuint shaderProgram = glCreateProgram();</div></pre></td></tr></table></figure></p>
<p><font size="4" color="red">附加链接</font><br>然后需要把着色器附加到着色器程序对象上，然后链接起来：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//把着色器附加到着色器程序对象上，然后链接起来</span></div><div class="line">glAttachShader(shaderProgram, vertexShader);</div><div class="line">glAttachShader(shaderProgram, fragmentShader);</div><div class="line">glLinkProgram(shaderProgram);</div></pre></td></tr></table></figure></p>
<p><font size="4" color="red">检测是否链接成功</font><br>接下来是需要检测一下链接是否成功，和检测是否成功编译类似：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//检查是否链接成功</div><div class="line">glGetProgramiv(shaderProgram, GL_LINK_STATUS, &amp;success);</div><div class="line">if (!success) &#123;</div><div class="line">	glGetProgramInfoLog(shaderProgram, 512, NULL, infoLog);</div><div class="line">	std::cout &lt;&lt; "ERROR::PROGRAM::LINKING_FAILED\n" &lt;&lt; std::endl;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><font size="4" color="red">删除着色器对象</font><br>最后是删除着色器对象，因为它们已经被成功链接到着色器程序对象了，不再需要着色器对象了，应该释放它们：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//删除着色器对象</span></div><div class="line">glDeleteShader(vertexShader);</div><div class="line">glDeleteShader(fragmentShader);</div></pre></td></tr></table></figure></p>
<p>&nbsp; </p>
<hr>
<p><font size="5" color="orange">在游戏循环中渲染三角形</font><br>在顶点输入、顶点着色器、像素着色器、着色器程序对象等过程都完成后，迎来了最终的三角形渲染。</p>
<p>OpenGL的glDrawArrays函数为我们提供了绘制物体的能力，它使用当前激活的着色器、前面定义的顶点属性和顶点数组对象VAO来绘制基本图形。</p>
<p>所以我们需要先激活着色器程序对象，再绑定VAO完成顶点输入初始化，接着使用<code>glDrawArrays</code>函数来画三角形，最后解绑VAO：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//激活着色器程序对象</span></div><div class="line">		glUseProgram(shaderProgram);</div><div class="line">		<span class="comment">//绑定VAO，完成顶点输入初始化</span></div><div class="line">		glBindVertexArray(VAO);</div><div class="line">		<span class="comment">//绘图</span></div><div class="line">		glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</div><div class="line">		<span class="comment">//解绑VAO</span></div><div class="line">		glBindVertexArray(<span class="number">0</span>);</div></pre></td></tr></table></figure></p>
<p>glDrawArrays函数的第一个参数是我们打算绘制的OpenGL基本图形的类型，这里是三角形GL_TRIANGLES；第二个参数是我们打算绘制的那个顶点数组的起始位置的索引；最后一个参数是我们打算绘制多少个顶点。</p>
<p>当然，在退出渲染后，不要忘了清除掉顶点数组对象VAO和顶点缓冲对象VBO：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//删除VAO、VBO</span></div><div class="line">glDeleteVertexArrays(<span class="number">1</span>, &amp;VAO);</div><div class="line">glDeleteBuffers(<span class="number">1</span>, &amp;VBO);</div></pre></td></tr></table></figure></p>
<p>&nbsp;  </p>
<hr>
<p>到此为止，我们已经完成了一个三角形的绘制，全部源码<a href="https://github.com/Popperelay/BlogCode/blob/master/LearnOpenGL3_CreateTriangle/main1.cpp" target="_blank" rel="external">在这里</a>。<br>编译运行后的结果如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147939271602.png" alt=""><br>&nbsp;  </p>
<hr>
<p>下面我们再来看一个，画矩形该怎么画？我们可以绘制两个三角形来组成一个矩形，事实上OpenGL主要就是绘制三角形，我们看到的很多复杂图形，包括3D图形，都是很多个小的三角形拼凑起来的。</p>
<p>画两个三角形的时候，如果直接用顶点去画，将需要2个三角形6个顶点：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">GLfloat vertices[] = &#123;</div><div class="line">    <span class="comment">// 第一个三角形</span></div><div class="line">    <span class="number">0.5</span>f, <span class="number">0.5</span>f, <span class="number">0.0</span>f,   <span class="comment">// 右上角</span></div><div class="line">    <span class="number">0.5</span>f, <span class="number">-0.5</span>f, <span class="number">0.0</span>f,  <span class="comment">// 右下角</span></div><div class="line">    <span class="number">-0.5</span>f, <span class="number">0.5</span>f, <span class="number">0.0</span>f,  <span class="comment">// 左上角 </span></div><div class="line">    <span class="comment">// 第二个三角形</span></div><div class="line">    <span class="number">0.5</span>f, <span class="number">-0.5</span>f, <span class="number">0.0</span>f,  <span class="comment">// 右下角</span></div><div class="line">    <span class="number">-0.5</span>f, <span class="number">-0.5</span>f, <span class="number">0.0</span>f, <span class="comment">// 左下角</span></div><div class="line">    <span class="number">-0.5</span>f, <span class="number">0.5</span>f, <span class="number">0.0</span>f   <span class="comment">// 左上角</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>但是这两个三角形其实有两个顶点是重合的，指定了右下角和左上角的顶点两次！一个矩形应该只有4个顶点而不是6个，这样就产生了50%的额外开销。如果我们有一个模型是大量的三角形拼凑起来的，这将会产生更大的浪费。最好的解决方案当然是每个顶点只存储一次，而在绘制的时候只需要指定打算绘制的那个顶点的索引就可以了。<br>&nbsp; </p>
<hr>
<p><font size="5" color="orange">用索引缓冲对象绘制矩形</font><br>恰巧的是，OpenGL提供了用索引缓冲进行绘制的工作方式。用索引缓冲对象EBO（elements buffer object）是一个像VBO一样的缓冲，专门存储索引，OpenGL调用这些顶点的索引来绘制。</p>
<p><font size="4" color="red">索引数组</font><br>首先我们需要定义一个浮点型数组，来存储矩形的四个顶点坐标；再定义一个整型数组，来存储组成矩形的两个三角形的顶点索引：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//三角形顶点坐标</span></div><div class="line">GLfloat vertices[] = &#123;</div><div class="line">	<span class="number">0.5</span>f,<span class="number">0.5</span>f,<span class="number">0.0</span>f,</div><div class="line">	<span class="number">0.5</span>f,<span class="number">-0.5</span>f,<span class="number">0.0</span>f,</div><div class="line">	<span class="number">-0.5</span>f,<span class="number">-0.5</span>f,<span class="number">0.0</span>f,</div><div class="line">	<span class="number">-0.5</span>f,<span class="number">0.5</span>f,<span class="number">0.0</span>f</div><div class="line">&#125;;</div><div class="line"><span class="comment">//顶点索引</span></div><div class="line">GLuint indices[] = &#123;</div><div class="line">	<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,  <span class="comment">//第一个三角形</span></div><div class="line">	<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>   <span class="comment">//第二个三角形</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><font size="4" color="red">索引缓冲对象</font><br>接下来就是在主函数中生成索引缓冲对象EBO，负责索引数据的存储：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//生成索引缓冲对象EBO，负责索引数据的存储</span></div><div class="line">GLuint EBO;</div><div class="line">glGenBuffers(<span class="number">1</span>, &amp;EBO);</div></pre></td></tr></table></figure></p>
<p>和VBO一样，接着需要给EBO绑定目标：索引数组内存：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//给索引缓冲对象绑定目标（索引数组缓冲）</span></div><div class="line">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);</div></pre></td></tr></table></figure></p>
<p>然后就是把索引数据复制到显卡的索引数组缓冲中了：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//把索引数据复制到显卡的缓冲内存中</span></div><div class="line">glBufferData(GL_ELEMENT_ARRAY_BUFFER, <span class="keyword">sizeof</span>(indices), indices, GL_STATIC_DRAW);</div></pre></td></tr></table></figure></p>
<p>【注】：</p>
<ul>
<li>对EBO的操作还是应该在VAO绑定和解绑之间的，因为需要让VAO记录下来EBO的存储过程和细节。这样在用索引进行绘制时，还是只需要绑定VAO即可，不用再去对EBO进行一些列的绑定、复制数据等操作。</li>
</ul>
<p><font size="4" color="red">更改绘制方式</font><br>因为现在是改用索引缓冲进行渲染了，所以需要把<code>glDrawArrays</code>函数改为<code>glDrawElements</code>函数：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//绘图</span></div><div class="line">glDrawElements(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="number">0</span>);</div></pre></td></tr></table></figure></p>
<p>第一个参数指定了绘制模式；第二个参数是我们打算绘制的顶点数；第三个参数是索引的类型；最后一个参数指定索引被存储的位置（或者说是起始索引在EBO中的偏移量；如果没有使用EBO但是还想使用索引进行绘制，这里可以传递一个索引数组）。</p>
<p><font size="4" color="red">渲染后删除EBO</font><br>当然，绘制完后不要忘了删除索引缓冲对象EBO：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">glDeleteBuffers(<span class="number">1</span>, &amp;EBO);</div></pre></td></tr></table></figure></p>
<p>&nbsp; </p>
<hr>
<p>到此，我们已经绘制了一个由两个三角形组成的矩形，全部源码<a href="https://github.com/Popperelay/BlogCode/blob/master/LearnOpenGL3_CreateTriangle/main2.cpp" target="_blank" rel="external">在这里</a>。<br>编译运行后的结果如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/14795454835.png" alt=""><br>&nbsp;</p>
<hr>
<p>参考文献：<a href="https://learnopengl.com/" target="_blank" rel="external">LearnOpenGL</a></p>

      
    </div>
    <footer>
      
        
  
  <div class="categories">
    <a href="/categories/OpenGL/">OpenGL</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/着色器画三角形/">着色器画三角形</a>
  </div>

        
  <div class="addthis addthis_toolbox addthis_default_style">
    
      <a class="addthis_button_facebook_like" fb:like:layout="button_count"></a>
    
    
      <a class="addthis_button_tweet"></a>
    
    
      <a class="addthis_button_google_plusone" g:plusone:size="medium"></a>
    
    
      <a class="addthis_button_pinterest_pinit" pi:pinit:layout="horizontal"></a>
    
    <a class="addthis_counter addthis_pill_style"></a>
  </div>
  <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js"></script>

      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


<section id="comment">
  <h2 class="title">留言</h2>


 
  	   <!-- 多说评论框 start -->
 		<div class="ds-thread" data-thread-key="2016/11/19/OpenGL3着色器画三角形/" data-title="OpenGL3：着色器画三角形" data-url="http://yoursite.com/2016/11/19/OpenGL3着色器画三角形/"></div>
		<!-- 多说评论框 end -->
		<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
		<script type="text/javascript">
		var duoshuoQuery = {short_name:"popperelay"};   <!-- 替换这里的duoshuo_shortname为前面注册的shortname -->
			(function() {
				var ds = document.createElement('script');
				ds.type = 'text/javascript';ds.async = true;
				ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.unstable.js';
				ds.charset = 'UTF-8';
				(document.getElementsByTagName('head')[0] 
				 || document.getElementsByTagName('body')[0]).appendChild(ds);
			})();
			</script>
		<!-- 多说公共JS代码 end -->
 
  
</section>

</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:yoursite.com">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/C-语法/">C#语法</a><small>2</small></li>
  
    <li><a href="/categories/C/">C++</a><small>5</small></li>
  
    <li><a href="/categories/C语言/">C语言</a><small>1</small></li>
  
    <li><a href="/categories/OpenGL/">OpenGL</a><small>28</small></li>
  
    <li><a href="/categories/c/">c++</a><small>1</small></li>
  
    <li><a href="/categories/博客配置/">博客配置</a><small>3</small></li>
  
    <li><a href="/categories/操作系统/">操作系统</a><small>4</small></li>
  
    <li><a href="/categories/数据结构/">数据结构</a><small>15</small></li>
  
    <li><a href="/categories/毕设/">毕设</a><small>1</small></li>
  
    <li><a href="/categories/游戏开发/">游戏开发</a><small>1</small></li>
  
    <li><a href="/categories/游戏设计模式/">游戏设计模式</a><small>1</small></li>
  
    <li><a href="/categories/计算机图形学/">计算机图形学</a><small>2</small></li>
  
    <li><a href="/categories/设计模式/">设计模式</a><small>5</small></li>
  
    <li><a href="/categories/调试错误集锦/">调试错误集锦</a><small>1</small></li>
  
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/BIOS和微机启动过程/">BIOS和微机启动过程</a><small>1</small></li>
  
    <li><a href="/tags/Blinn-Phong/">Blinn-Phong</a><small>1</small></li>
  
    <li><a href="/tags/C/">C</a><small>1</small></li>
  
    <li><a href="/tags/C-容器/">C#容器</a><small>1</small></li>
  
    <li><a href="/tags/C-IO/">C++IO</a><small>1</small></li>
  
    <li><a href="/tags/C-Primer/">C++Primer</a><small>1</small></li>
  
    <li><a href="/tags/Gamma校正/">Gamma校正</a><small>1</small></li>
  
    <li><a href="/tags/MarkDown/">MarkDown</a><small>1</small></li>
  
    <li><a href="/tags/Mathjax语法/">Mathjax语法</a><small>1</small></li>
  
    <li><a href="/tags/OS内核/">OS内核</a><small>1</small></li>
  
    <li><a href="/tags/OpenGL坐标系统/">OpenGL坐标系统</a><small>1</small></li>
  
    <li><a href="/tags/OpenGL摄像机/">OpenGL摄像机</a><small>1</small></li>
  
    <li><a href="/tags/OpenGL窗口/">OpenGL窗口</a><small>1</small></li>
  
    <li><a href="/tags/OpenGL配置/">OpenGL配置</a><small>1</small></li>
  
    <li><a href="/tags/ShadowMap/">ShadowMap</a><small>1</small></li>
  
    <li><a href="/tags/c-特性/">c++特性</a><small>1</small></li>
  
    <li><a href="/tags/const/">const</a><small>1</small></li>
  
    <li><a href="/tags/timeTest/">timeTest</a><small>1</small></li>
  
    <li><a href="/tags/二叉树/">二叉树</a><small>1</small></li>
  
    <li><a href="/tags/交流/">交流</a><small>1</small></li>
  
    <li><a href="/tags/光照场景/">光照场景</a><small>1</small></li>
  
    <li><a href="/tags/光照贴图/">光照贴图</a><small>1</small></li>
  
    <li><a href="/tags/关键路径/">关键路径</a><small>1</small></li>
  
    <li><a href="/tags/冯氏光照/">冯氏光照</a><small>1</small></li>
  
    <li><a href="/tags/几何着色器/">几何着色器</a><small>1</small></li>
  
    <li><a href="/tags/反走样/">反走样</a><small>1</small></li>
  
    <li><a href="/tags/图/">图</a><small>1</small></li>
  
    <li><a href="/tags/图形学概述/">图形学概述</a><small>1</small></li>
  
    <li><a href="/tags/图形显示系统/">图形显示系统</a><small>1</small></li>
  
    <li><a href="/tags/外观-观察-者命令/">外观 观察 者命令</a><small>1</small></li>
  
    <li><a href="/tags/多说/">多说</a><small>1</small></li>
  
    <li><a href="/tags/天空盒子/">天空盒子</a><small>1</small></li>
  
    <li><a href="/tags/头结点/">头结点</a><small>1</small></li>
  
    <li><a href="/tags/实例化/">实例化</a><small>1</small></li>
  
    <li><a href="/tags/尾递归/">尾递归</a><small>1</small></li>
  
    <li><a href="/tags/工厂模式单例模式/">工厂模式单例模式</a><small>1</small></li>
  
    <li><a href="/tags/帧同步/">帧同步</a><small>1</small></li>
  
    <li><a href="/tags/帧缓冲/">帧缓冲</a><small>1</small></li>
  
    <li><a href="/tags/常见光源/">常见光源</a><small>1</small></li>
  
    <li><a href="/tags/异步传输/">异步传输</a><small>2</small></li>
  
    <li><a href="/tags/拓扑排序/">拓扑排序</a><small>1</small></li>
  
    <li><a href="/tags/操作系统概述/">操作系统概述</a><small>1</small></li>
  
    <li><a href="/tags/改进排序/">改进排序</a><small>1</small></li>
  
    <li><a href="/tags/文件IO/">文件IO</a><small>1</small></li>
  
    <li><a href="/tags/最小生成树/">最小生成树</a><small>1</small></li>
  
    <li><a href="/tags/最短路径/">最短路径</a><small>1</small></li>
  
    <li><a href="/tags/材质/">材质</a><small>1</small></li>
  
    <li><a href="/tags/查找/">查找</a><small>1</small></li>
  
    <li><a href="/tags/栈/">栈</a><small>1</small></li>
  
    <li><a href="/tags/树/">树</a><small>1</small></li>
  
    <li><a href="/tags/模型加载/">模型加载</a><small>1</small></li>
  
    <li><a href="/tags/模板测试/">模板测试</a><small>1</small></li>
  
    <li><a href="/tags/深度测试/">深度测试</a><small>1</small></li>
  
    <li><a href="/tags/混合/">混合</a><small>1</small></li>
  
    <li><a href="/tags/着色器/">着色器</a><small>1</small></li>
  
    <li><a href="/tags/着色器画三角形/">着色器画三角形</a><small>1</small></li>
  
    <li><a href="/tags/码农/">码农</a><small>1</small></li>
  
    <li><a href="/tags/简单排序/">简单排序</a><small>1</small></li>
  
    <li><a href="/tags/纹理/">纹理</a><small>1</small></li>
  
    <li><a href="/tags/缓冲对象/">缓冲对象</a><small>1</small></li>
  
    <li><a href="/tags/编译链接错误/">编译链接错误</a><small>1</small></li>
  
    <li><a href="/tags/背面剔除/">背面剔除</a><small>1</small></li>
  
    <li><a href="/tags/责任链模式适配器模式/">责任链模式适配器模式</a><small>1</small></li>
  
    <li><a href="/tags/进程的描述与控制/">进程的描述与控制</a><small>1</small></li>
  
    <li><a href="/tags/重定义错误/">重定义错误</a><small>1</small></li>
  
    <li><a href="/tags/链表/">链表</a><small>1</small></li>
  
    <li><a href="/tags/队列/">队列</a><small>1</small></li>
  
    <li><a href="/tags/面向对象设计原则/">面向对象设计原则</a><small>1</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2017 Elay
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




  <link rel="stylesheet" href="http://apps.bdimg.com/libs/fancybox/2.1.5/jquery.fancybox.css">




</body>
</html>