<!DOCTYPE HTML>
<html>

<head><meta name="generator" content="Hexo 3.9.0">
	<link rel="bookmark" type="image/x-icon" href="/img/logo_miccall.png">
	 <link rel="shortcut icon" href="/img/logo_miccall.png">
	
			
    <title>
    Elays'Blog
    </title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
	<script>
	(function(){
		if('{{ page.password }}'){
			if (prompt('请输入博客密码') !== "elayRender"){
				alert('密码错误！');
				window.location.href='http://www.google.com'
				window.open('','_top'); 
				window.top.close(); 
				window.opener=null; 
				window.close();
			}
		}
	})();
	</script>
    <link rel="stylesheet" href="/css/mic_main.css">
    <link rel="stylesheet" href="/css/dropdownMenu.css">
    
    	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css">
    </noscript>
			    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<link rel="stylesheet" href="/css/prism-dark.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>
    
		
<!-- Layouts -->


<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<!--<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">-->
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/latest.js?config=TeX-MML-AM_CHTML">
</script>

<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_undefined.css">
<link rel="stylesheet" href="/css/typo.css">
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">MICCALL</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special">
            <ul class="menu links">
			<!-- Homepage  主页  --> 
			<li>
	            <a href="/" rel="nofollow">主页</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">分类</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="/categories/C/">C#</a></li><li><a class="category-link" href="/categories/C-语法/">C#语法</a></li><li><a class="category-link" href="/categories/C/">C++</a></li><li><a class="category-link" href="/categories/C语言/">C语言</a></li><li><a class="category-link" href="/categories/Graphics/">Graphics</a></li><li><a class="category-link" href="/categories/Math/">Math</a></li><li><a class="category-link" href="/categories/OpenGL/">OpenGL</a></li><li><a class="category-link" href="/categories/Unity/">Unity</a></li><li><a class="category-link" href="/categories/Vulkan/">Vulkan</a></li><li><a class="category-link" href="/categories/博客配置/">博客配置</a></li><li><a class="category-link" href="/categories/并行计算/">并行计算</a></li><li><a class="category-link" href="/categories/操作系统/">操作系统</a></li><li><a class="category-link" href="/categories/数据结构/">数据结构</a></li><li><a class="category-link" href="/categories/毕设/">毕设</a></li><li><a class="category-link" href="/categories/游戏开发/">游戏开发</a></li><li><a class="category-link" href="/categories/计算机系统/">计算机系统</a></li><li><a class="category-link" href="/categories/设计模式/">设计模式</a></li><li><a class="category-link" href="/categories/面试/">面试</a>
	                    </li></ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/gallery/" title="图库">
		                图库
		            </a>
		        </li>
		        
		        <li>
		            <a href="/tag/" title="搜索">
		                搜索
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
		            
		                <li><a href="https://github.com/miccall" class="icon fa-github"><span class="label">GitHub</span></a></li>
		            
		            
		            
		            
			</ul>
</nav>

        <div id="main">
            <div class="post_page_title_img" style="height: 25rem;background-image: url(https://github.com/Popperelay/Photos/blob/master/Photos/OpenGL5%E7%BA%B9%E7%90%86_BG.jpg?raw=true);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;">
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2>OpenGL5：纹理</h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
				<!-- 目录 -->
				<p class="show-toc-btn" id="show-toc-btn" onclick="showToc();" style="display:none">
				<span class="btn-bg"></span>
				<span class="btn-text">文章导航</span>
				</p>
				<div id="toc-article" class="toc-article">
					<span id="toc-close" class="toc-close" title="隐藏导航" onclick="showBtn();">×</span>
					<strong class="toc-title">文章目录</strong>
					
			   </div>
			   <script type="text/javascript">
				function showToc(){
					var toc_article = document.getElementById("toc-article");
					var show_toc_btn = document.getElementById("show-toc-btn");
					toc_article.setAttribute("style","display:block");
					show_toc_btn.setAttribute("style","display:none");
					};
				function showBtn(){
					var toc_article = document.getElementById("toc-article");
					var show_toc_btn = document.getElementById("show-toc-btn");
					toc_article.setAttribute("style","display:none");
					show_toc_btn.setAttribute("style","display:block");
					};
			   </script>
				
                <p>在前面的文章中，我们画过矩形，画过彩色三角形。<a id="more"></a>那么能不能画出现实生活中的图片呢？比如画一面砖墙，画一朵花。这样的图形无疑看起来更真实。但是这些更真实的图形也无疑很复杂，因为它们的每个像素颜色之间并没有什么明显的规律，如果要去画的话，就得一个像素一个像素的去画，要我们自己去指定大量的顶点颜色，这个开销太庞大了~~~<br>&nbsp; </p>
<hr>
<p><font size="5" color="orange">纹理概述</font><br>幸运的是，还有另一种方式。我们可以先照一张砖墙的照片，让GPU自动提取这张照片上的像素，然后画到屏幕上。这张用于GPU提取像素颜色的照片，就叫做纹理。纹理通常是一个2D图片（也有1D和3D的纹理）。可以想象纹理是一张绘有砖块的纸，无缝折叠贴合到我们的3D房子上，这样我们的房子看起来就像有砖墙外表了。这样我们就不用去一个一个地去指定纹理中每个纹素（纹理中的像素）的颜色了，只需要指定怎样把纹理贴到我们的模型（比如一个三角形、矩形甚至3D房子）上。举个例子：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/OpenGL5%E7%BA%B9%E7%90%861.png?raw=true" alt><br>为了把这张木箱纹理贴到图中红色三角形上，我们需要指定三角形的顶点对应纹理的那个位置。这个位置我们叫做纹理坐标，表示纹素在纹理上的位置，通常坐标值在0.0到1.0之间，原点通常在纹理左下角。我们把三角形左下角顶点对应纹理坐标（0,0），把三角形右下角顶点对应纹理坐标（1,0），把三角形上中顶点对应纹理坐标（0.5,1.0）。我们只要给顶点着色器传递这三个顶点纹理坐标就行了，接下来它们会被传到像素着色器中，GPU会根据三角形顶点纹理坐标，去为三角形内部点进行插值（根据内部点坐标和顶点坐标的关系，去纹理中找相应纹素颜色）。使用纹理坐标获取纹理颜色叫做采样。</p>
<p>这么说来，纹理坐标也应该是三角形顶点的一个属性，所以我们定义如下：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    //三角形顶点的坐标、颜色、纹理坐标
    GLfloat vertices[] = {
        //位置坐标         //颜色           //纹理坐标
        0.5f, 0.5f, 0.0f,  1.0f,0.0f,0.0f,  1.0f,1.0f,
        0.5f, -0.5f,0.0f,  0.0f,1.0f,0.0f,  1.0f,0.0f, 
        -0.5f,-0.5f,0.0f,  0.0f,0.0f,1.0f,  0.0f,0.0f,
        -0.5f,0.5f, 0.0f,  1.0f,1.0f,0.0f,  0.0f,1.0f
    };
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>&nbsp;</p>
<hr>
<p><font size="5" color="orange">告诉OpenGL如何解析顶点数据</font><br>由于顶点数据中增加了纹理坐标，我们需要重新设置OpenGL如何解析顶点数据：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    //告诉OpenGL如何解析显存中的顶点位置属性数据
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(GLfloat), (GLvoid*)0);
    //打开顶点位置属性数组
    glEnableVertexAttribArray(0);
    //告诉OpenGL如何解析显存中的顶点颜色属性数据
    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(GLfloat), (GLvoid*)(3 * sizeof(GLfloat)));
    //打开顶点颜色属性数组
    glEnableVertexAttribArray(1);
    //告诉OpenGL如何解析显存中的顶点纹理坐标属性数据
    glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(GLfloat), (GLvoid*)(6 * sizeof(GLfloat)));
    //打开顶点纹理坐标属性数组
    glEnableVertexAttribArray(2);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>每个顶点属性的步长都变成了<code>8*sizeof(GLfloat)</code>，起始偏移量（最后一个参数）也发生了变化。顶点纹理坐标属性对应顶点着色器中的location为2。<br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">创建纹理和绑定对象</font><br>和创建顶点数组对象VAO等一样，使用纹理前，我们需要创建和绑定纹理对象：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    GLuint texture;
    //生成纹理对象texture
    glGenTextures(1, &texture);
    //给纹理对象绑定目标（2D纹理）
    glBindTexture(GL_TEXTURE_2D, texture);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们使用的是2D纹理，所以纹理目标是GL_TEXTURE_2D。<br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">加载纹理</font><br>创建和绑定完纹理对象之后，我们把纹理从文件中加载进来。</p>
<p>纹理图像可能被存储为各种各样的格式，每种都有自己的数据结构和排列方式，那么我们如何才能把这些图像加载到应用中呢？一个解决方案是选一个需要的文件格式，比如png，然后自己写一个图像加载器，把图像转化为字节序列。但是如果要支持更多文件格式呢？就得为每种希望支持的格式写加载器了。</p>
<p>另一种解决方案就是借前人之树乘凉：使用一个支持多种流行格式的图像加载库来解决这个问题。比如我们要用的SOIL库（文末还介绍了另一种加载库）。</p>
<p><font size="4" color>简易OpenGL图像库SOIL</font><br>SOIL是简易OpenGL图像库（Simple OpenGL Image Library）的缩写，它支持大多数流行的图像格式。可以从<a href="http://www.lonesock.net/soil.html" target="_blank" rel="noopener">这里</a>下载。下载完成后用VS打开\projects\VC8目录下的SOIL.sln，生成解决方案后，从debug文件夹里取得SOIL.lib文件，将它添加到我们自己建的Libs文件夹里，再把src文件夹下的所有.h头文件添加到我们自己建的Includes文件夹里，并且在自己的VS项目中链接上SOIL.lib（具体过程和<a href="http://popperelay.com/2016/10/18/OpenGL%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" target="_blank" rel="noopener">《OpenGL1：OpenGL概述及环境配置》</a>一文中构建GLFW类似）。</p>
<p>当然，在我们的源文件中还需要包含SOIL.h头文件：<code>#include &lt;SOIL.h&gt;</code></p>
<p><font size="4" color="red">使用SOIL加载图片</font><br>下面我们加载一张<a href="https://learnopengl-cn.github.io/img/01/06/container.jpg" target="_blank" rel="noopener">木箱</a>图片。<br>首先使用SOIL库的<code>SOIL_load_image</code>函数把木箱图片数据加载到内存：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    int iamgeWidth, iamgeHeight;
    unsigned char* image = SOIL_load_image("container.jpg", &iamgeWidth, &iamgeHeight, 0, SOIL_LOAD_RGB);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>函数<code>SOIL_load_image</code>的第一个参数是需要加载的图片路径；然后需要两个int指针作为第二个和第三个参数，函数会分别返回图片的宽度和高度到其中；第4个参数指定图片的通道数量，这里设为0即可；最后一个参数告诉SOIL如何来加载图片，由于我们只关注图片的RGB值，所以设为SOIL_LOAD_RGB。函数返回一个很大的char（或者说byte）数组。<br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">生成纹理</font><br>图像数据已经有了，存储在image数组中，下面我们利用这些图形数据来在GPU上生成一张纹理：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, iamgeWidth, iamgeHeight, 0, GL_RGB, GL_UNSIGNED_BYTE, image);
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>函数<code>glTexImage2D</code>的参数都表示什么？</p>
<ul>
<li>第一个参数是纹理绑定的目标GL_TEXTURE_2D</li>
<li>第二个参数是纹理的多级渐远纹理（后面会讲）级别，这里我们设置为0，也就是原始纹理</li>
<li>第三个参数告诉OpenGL我们希望把纹理存储为何种格式。我们的图形只有RGB值，所以我们也把纹理存储为RGB</li>
<li>第四个和第五个参数设置最终的纹理宽度和高度。我们之前加载图像的时候读取到了图像的宽度和高度，现在刚好用上</li>
<li>第6个参数总是设为0（历史遗留问题）</li>
<li>第7个参数指定源图的格式</li>
<li>第8个参数指定源图的数据类型</li>
<li>最后一个参数是真正的图形数据</li>
</ul>
<p>当调用函数<code>glTexImage2D</code>时，当前绑定的纹理对象就会被附加上纹理图像。</p>
<p>使用完图像内存数据后，释放所占用的内存是个好习惯：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    SOIL_free_image_data(image);
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>&nbsp;</p>
<hr>
<p>接下来还需要对纹理进行一系列的配置，先来看对纹理环绕方式的配置。</p>
<p><font size="5" color="orange">纹理环绕方式</font><br>纹理坐标的范围通常是（0,0）到（1,1），那如果我们把纹理坐标设置在这个范围之外会发生什么？OpenGL默认是重复这个纹理图像（即忽略纹理坐标的整数部分，只有小数部分有效），除此之外，OpenGL还提供了几种环绕方式（Wrapping）：</p>
<ul>
<li>GL_REPEAT：重复纹理图像。这是默认的。</li>
<li>GL_MIRRORED_REPEAT：镜像重复纹理图像。</li>
<li>GL_CLAMP_TO_EDGE：纹理坐标会被约束在0到1之间，超出部分会重复纹理边缘，产生一种边缘被拉伸的效果。</li>
<li>GL_CLAMP_TO_BORDER：超出坐标为用户指定的边缘颜色。</li>
</ul>
<p>当纹理坐标不在0到1之间时，每个选项都有不同的视觉输出效果：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/OpenGL5%E7%BA%B9%E7%90%862.png?raw=true" alt><br>可以使用<code>glTextParameteri</code>函数来设置纹理的环绕方式：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>第一个参数指定了纹理对象所绑定的目标；第二个参数指定需要配置的选项和应用的纹理轴，因为我们打算配置的是纹理环绕方式wrap，并且需要配置S和T方向（纹理中的s、t、r轴等价于通常的x、y、z轴）的环绕方式。最后一个参数指定环绕方式，这里我们指定的都是重复纹理图像这种方式。</p>
<p>【注】：</p>
<ul>
<li>如果我们选择GL_CLAMP_TO_BORDER这种纹理环绕方式，就还需要再指定一个边缘颜色。这时就需要再使用<code>glTexParameterfv</code>函数了：<pre class="line-numbers language-c++"><code class="language-c++">  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER);
  GLfloat borderColor[] = { 1.0f,1.0f,0.0f,1.0f };
  glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, borderColor);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
函数<code>glTexParameterfv</code>的第一个参数依旧是纹理对象绑定的目标；因为要设置边缘颜色，所以第二个参数变成了<code>GL_TEXTURE_BORDER_COLOR</code>；第三个参数是表示颜色的一个float数组。<br>&nbsp;</li>
</ul>
<hr>
<p>接下来我们看看对纹理过滤方式的配置</p>
<p><font size="5" color="orange">纹理过滤</font><br>当使用顶点坐标映射相应纹素时，由于是根据位置关系进行插值计算的，所以得到的内部点的纹理坐标不一定是整数，比如说如果纹素位置（即纹理坐标）为（152.34,255,38）该怎么办呢？这种情况称为纹理过滤。</p>
<p>纹理过滤有很多种方法，这里只讨论最重要的两种：GL_NEAREST（最邻近滤波）和GL_LINEAR（线性滤波）</p>
<p><font size="4" color="red">最邻近滤波</font><br>最邻近滤波是选择中心点距离浮点数纹理坐标最近的那个纹素。图示如下：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/OpenGL5%E7%BA%B9%E7%90%863.png?raw=true" alt><br>因为图中红色纹素离纹理坐标最近，所以选择该红色作为最终的输出纹素。</p>
<p>最邻近滤波容易导致走样误差，明显有像素块的感觉。</p>
<p><font size="4" color="red">线性滤波</font><br>线性滤波是使用纹理坐标附近的一组纹素的加权平均值（插值）来确定最终的纹素值。这个权值就是纹素中心到这个纹理坐标的距离，距离越近的纹素对最终的纹素值贡献越大。如下图所示：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/OpenGL5%E7%BA%B9%E7%90%864.png?raw=true" alt></p>
<p>最邻近滤波和线性滤波的对比效果如下：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/OpenGL5%E7%BA%B9%E7%90%865.png?raw=true" alt><br>GL_NEAREST产生了颗粒状的图案，能够清晰地看到纹素，而GK_LINEAR能够产生更平滑的图案，很难看出单个的纹素。GL_LINEAR可以产生更真实的输出，不过GL_NEAREST却可以产生出8-bit风格（像素风），也有很多人喜欢。</p>
<p>还有一些其它的滤波方式，比如三线性滤波（Trilinear Filtering）等。</p>
<p><font size="4" color="red">纹素放大缩小时滤波</font><br>除了对纹理坐标取整时需要用到滤波以外，在纹素到像素时的放大和缩小时，也可能要用到滤波。</p>
<p>什么是纹素到像素的放大、缩小？</p>
<ul>
<li>一个纹素最终对应屏幕上的多个像素，称为放大（magnification）</li>
<li>一个纹素最终对应屏幕上的一个像素，这时不需要滤波</li>
<li>一个纹素最终对应少于一个像素，称为缩小</li>
</ul>
<p>放大和缩小图示如下：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/OpenGL5%E7%BA%B9%E7%90%866.png?raw=true" alt></p>
<p>我们可以使用<code>glTexParameteri</code>函数在图像放大滤波和缩小滤波选项时设置纹理滤波：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>第二个参数是放大滤波或者缩小滤波，第三个参数指定滤波方式。<br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">多级渐远纹理mipmap</font><br>一个物体，当它距离我们比较近时，需要很多像素去表现它；而当距离我们很远时，会看不大清楚，只有很少的像素需要被绘制，这时再从该物体对应的纹理中去找几个纹素来表现它，是很难的。因为它需要跨过纹理很大部分只拾取一个纹素，而且最终拾取出来的纹素凑在一起可能就面目全非了。更何况对于很远的物体去使用高分辨率的纹理无疑是浪费内存。</p>
<p>OpenGL使用多级渐远纹理Mipmap来解决这个问题。mipmap其实就是一系列纹理图像，后一个纹理图像只有前一个纹理图像的一半大小。在观察者的距离在不同的距离范围时使用不同级别的mipmap。mipmap的另一个加分点是它的性能非常好。mipmap图示如下：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/OpenGL5%E7%BA%B9%E7%90%867.png?raw=true" alt></p>
<p><font size="4" color="red">mipmap滤波</font><br>在渲染中切换不同级别的mipmap时，会产生一些很明显的边界。对纹素的滤波也可以用到这里，来消除这些很生硬的边界。由于mipmap其实也相当于是把纹理缩小，所以它的滤滤波也是通过<code>glTexParameteri</code>函数在缩小滤波<code>GL_TEXTURE_MIN_FILTER</code>选项时来实现：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST_MIPMAP_LINEAR);
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>函数的第三个参数就是要设置的mipmap滤波方式，它有一下几种选项（“mipmap”之后是mipmap滤波方式，之前是纹素滤波方式）：</p>
<ul>
<li><code>GL_NEAREST_MIPMAP_NEAREST</code>：使用最接近像素大小的mipmap，纹理内部使用最邻近滤波</li>
<li><code>GL_LINEAR_MIPMAP_NEAREST</code>：使用最接近像素大小的mipmap，纹理内部使用线性滤波</li>
<li><code>GL_NEAREST_MIPMAP_LINEAR</code>：在两个最接近像素大小的mipmap中做线性插值，纹理内部使用最邻近滤波</li>
<li><code>GL_LINEAR_MIPMAP_LINEAR</code>：在两个最接近像素大小的mipmap中线性插值，纹理内部使用线性滤波</li>
</ul>
<p>设置好mipmap的滤波之后，就可以来创建mipmap了。</p>
<p><font size="4" color="red">创建mipmap</font><br>手工为每个纹理图像创建一系列mipmap挺麻烦的，不过OpenGL有一个<code>glGenerateMipmaps</code>函数，在创建完一个纹理后调用它，OpenGL就会自动建立该纹理的一系列mipmap了：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    glGenerateMipmap(GL_TEXTURE_2D);
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>【注】：</p>
<ul>
<li>如果不需要mipmap，那关于mipmap这里的操作可以不要。<br>&nbsp;</li>
</ul>
<hr>
<p><font size="5" color="orange">解绑纹理对象</font><br>设置完纹理参数后，需要和别的对象一样，使用完之后解绑纹理对象：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    glBindTexture(GL_TEXTURE_2D, 0);
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>&nbsp;</p>
<hr>
<p><font size="5" color="orange">更改顶点着色器</font></p>
<pre class="line-numbers language-c++"><code class="language-c++">//顶点着色器
#version 330 core
layout (location=0) in vec3 position;  //顶点位置变量的属性位置值为0
layout (location=1) in vec3 color;     //顶点颜色变量的属性位置值为1
layout (location=2) in vec2 texCoord;  //顶点纹理坐标的属性位置值为2
out vec3 ourColor;
out vec2 TexCoord;
void main(){
    gl_Position=vec4(position,1.0f);
    ourColor=color;
    TexCoord=texCoord;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>顶点着色器需要增加一个纹理坐标的输入变量，由于只有s、t坐标，所以是vec2类型；还需要增加一个输出变量，用于输出纹理坐标给像素着色器。在main函数内把输入纹理坐标赋值给输出纹理坐标。<br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">更改像素着色器</font></p>
<pre class="line-numbers language-c++"><code class="language-c++">//像素着色器
#version 330 core
in vec3 ourColor;
in vec2 TexCoord;
out vec4 color;
uniform sampler2D ourTexture;

void main(){
    color = vec4(ourColor,1.0f) * texture(ourTexture,TexCoord);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>像素着色器需要增加一个纹理坐标的输入变量；只有纹理坐标还不足以在像素着色器中输出对应纹素的颜色，我们还需要一个采样器（设置为uniform变量），让它结合纹理坐标、顶点坐标、纹理图像，进行插值获得每一个像素颜色。使用texture函数来使用采样器，第一个参数是我们设置的采用器，第二个参数是纹理坐标。</p>
<p>在main函数内最终的输出颜色我们设置为顶点颜色和纹理颜色的混合。<br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">渲染时绑定纹理对象</font><br>设置完了纹理和相应的着色器，最后要做的就是在渲染循环里绑定纹理对象，这样才能渲染出纹理（这和绑定VAO是一个道理）。</p>
<pre class="line-numbers language-c++"><code class="language-c++">        //绑定纹理
        glBindTexture(GL_TEXTURE_2D, texture);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>&nbsp;</p>
<hr>
<p>自此，所有源码<a href="https://github.com/Popperelay/BlogCode/tree/master/LearnOpenGL5_Texture/LearnOpenGL5_Texture_1" target="_blank" rel="noopener">在这里</a>。</p>
<p>编译运行后，结果如下：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/OpenGL5%E7%BA%B9%E7%90%868.png?raw=true" alt><br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">使用多个纹理</font></p>
<p><font size="4" color="red">载入第二张图片</font><br>载入<a href="https://learnopengl-cn.github.io/img/01/06/awesomeface.png" target="_blank" rel="noopener">第二张图片</a>和第一张类似：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    GLuint texture1;
    //生成纹理对象texture1
    glGenTextures(1, &texture1);
    //给纹理对象绑定目标（2D纹理）
    glBindTexture(GL_TEXTURE_2D, texture1);
    int iamgeWidth, iamgeHeight;
    //加载纹理图像
    unsigned char* image = SOIL_load_image("container.jpg", &iamgeWidth, &iamgeHeight, 0, SOIL_LOAD_RGB);
    //生成2D纹理
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, iamgeWidth, iamgeHeight, 0, GL_RGB, GL_UNSIGNED_BYTE, image);
    //释放纹理数据内存
    SOIL_free_image_data(image);
    //设置纹理s和t方向的环绕方式
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
    //设置纹理放大和缩写时的过滤方式（纹素过滤、mipmap边界过滤）
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    //生成多级渐远纹理
    glGenerateMipmap(GL_TEXTURE_2D);
    //解绑纹理对象
    glBindTexture(GL_TEXTURE_2D, 0);

    GLuint texture2;
    //生成纹理对象texture2
    glGenTextures(1, &texture2);
    //给纹理对象绑定目标（2D纹理）
    glBindTexture(GL_TEXTURE_2D, texture2);
    //加载纹理图像
    image = SOIL_load_image("awesomeface.png", &iamgeWidth, &iamgeHeight, 0, SOIL_LOAD_RGB);
    //生成2D纹理
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, iamgeWidth, iamgeHeight, 0, GL_RGB, GL_UNSIGNED_BYTE, image);
    //释放纹理数据内存
    SOIL_free_image_data(image);
    //设置纹理s和t方向的环绕方式
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_LINEAR);
    //设置纹理放大和缩写时的过滤方式（纹素过滤、mipmap边界过滤）
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    //生成多级渐远纹理
    glGenerateMipmap(GL_TEXTURE_2D);
    //解绑纹理对象
    glBindTexture(GL_TEXTURE_2D, 0);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><font size="4" color="red">更改像素着色器</font><br>使用多个纹理，我们就需要在像素着色器中使用多个采样器：</p>
<pre class="line-numbers language-c++"><code class="language-c++">//像素着色器
#version 330 core
in vec3 ourColor;
in vec2 TexCoord;
out vec4 color;
//纹理采样器1
uniform sampler2D ourTexture1;
//纹理采样器2
uniform sampler2D ourTexture2;

void main(){
    color = vec4(ourColor,1.0f) * mix(texture(ourTexture1,TexCoord),texture(ourTexture2,TexCoord),0.41);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在main函数中使用mix函数来混合两个纹理，第一个参数是纹理1的纹素颜色，第二个参数是纹理2的纹素颜色，第3个参数是纹素2在最终输出颜色中所占的权重，代码中是59%的纹素1，41%的纹素2。</p>
<p><font size="4" color="red">渲染中激活纹理单元并设置相应采样器</font><br>我们可以看到我们的采样器是被uniform声明的，但是很奇怪的是之前的源程序中，渲染时并没有对uniform全局变量ourTexture赋值，但是依旧有效并没有报错。这是因为我们的ourTexture变量是个采样器，通过多个采样器我们可以使用多个纹理。</p>
<p>每个纹理都有一个位置值，称为纹理单元（有点像多个纹理叠加时的图层）。而对于纹理处在哪一层，即纹理单元是多少，就是通过使用<code>glUniform1i</code>函数来给采样器赋值，从而确定纹理单元值。但是默认情况下，当只使用一个纹理时，纹理单元<code>GL_TEXTURE0</code>总是被激活的，也就是这个采样器（或者说纹理单元）总是对应0（0图层），所以不需要显式使用<code>glUniform1i</code>函数去为采样器赋值。</p>
<p>但是有多个纹理时，就没有默认了，需要显式为每个采样器指定一个整数值，对应被激活的图层（被激活的纹理单元）：</p>
<pre class="line-numbers language-c++"><code class="language-c++">        //激活纹理单元
        glActiveTexture(GL_TEXTURE0);
        //获取uniform变量位置
        GLint uniformLocation1 = glGetUniformLocation(myshader.shaderProgram, "ourTexture1");
        //设置采样器的值（对应纹理单元值）
        glUniform1i(uniformLocation1, 0);
        //绑定纹理对象
        glBindTexture(GL_TEXTURE_2D, texture1);

        glActiveTexture(GL_TEXTURE1);
        GLint uniformLocation2 = glGetUniformLocation(myshader.shaderProgram, "ourTexture2");
        glUniform1i(uniformLocation2, 1);
        glBindTexture(GL_TEXTURE_2D, texture2);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在给采样器赋值之前，我们需要先激活纹理单元，活着说激活纹理图层，再给采样器赋以相应的被激活的纹理单元值，这样采样器才能读出纹素颜色。<br>【注】：</p>
<ul>
<li>如果采样器值对应的纹理单元没有被激活，是无法读出纹素的。因为默认纹理单元0是激活的，所以在只渲染一个纹理时，就不用去激活纹理单元并设置采样器值，默认就是用采样器0去纹理单元0（图层0）采集纹素颜色。</li>
<li>设置完采样器的值后，接下来就需要绑定纹理对象，好把相应纹理放在刚刚激活的纹理单元（图层）上。</li>
<li>OpenGL至少保证有16个纹理单元可供使用，也就是说可以激活从<code>GL_TEXTURE0</code>到<code>GL_TEXTURE15</code>。它们都是按顺序定义的，所以<code>GL_TEXTURE8=GL_TEXTURE0+8</code>，这在当我们需要循环一些纹理单元时会很有用。</li>
</ul>
<p>其余代码和之前的源程序一样，编译运行的结果如下：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/OpenGL5%E7%BA%B9%E7%90%869.png?raw=true" alt></p>
<p><font size="4" color="red">翻转图片</font><br>可以看到第二张纹理上下颠倒了！这是因为OpenGL要求y轴0.0在图片底部，但是通常图片y轴0.0在图片顶部。有一些图片加载器比如DevIL在加载的时候有选项重载y原点，但是SOIL没有。所以，为了修复这个小问题，有两个选择：</p>
<ul>
<li>改变顶点的纹理坐标属性，翻转y值（用1减去y坐标）</li>
<li>更改顶点着色器中对输出纹理坐标的赋值，也是用1减去y坐标：<pre class="line-numbers language-c++"><code class="language-c++">//顶点着色器
#version 330 core
layout (location=0) in vec3 position;  //顶点位置变量的属性位置值为0
layout (location=1) in vec3 color;     //顶点颜色变量的属性位置值为1
layout (location=2) in vec2 texCoord;  //顶点纹理坐标的属性位置值为2
out vec3 ourColor;
out vec2 TexCoord;
void main(){
  gl_Position=vec4(position,1.0f);
  ourColor=color;
  TexCoord=vec2(texCoord.x,1-texCoord.y);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
编译运行后的结果如下：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/OpenGL5%E7%BA%B9%E7%90%8610.png?raw=true" alt><br>&nbsp;</li>
</ul>
<hr>
<p>到此，使用两张纹理的全部源程序<a href="https://github.com/Popperelay/BlogCode/tree/master/LearnOpenGL5_Texture/LearnOpenGL5_Texture_2" target="_blank" rel="noopener">在这里</a>。<br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">纹理加载类</font><br>我们把上面主程序中加载纹理的部分单独封装成一个类：<br>纹理加载类的头文件：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#pragma once
#define GLEW_STATIC
#include <gl glew.h>
#include <glfw glfw3.h>
#include <soil soil.h>

class TextureLoader {
public:
    GLuint LoadTexture(GLchar* texturePath);
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></soil></glfw></gl></code></pre>
<p>纹理加载类的源文件：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#include "TextureLoader.h"

GLuint TextureLoader::LoadTexture(GLchar* texturePath) {
    GLuint texture;
    //生成纹理对象texture
    glGenTextures(1, &texture);
    //给纹理对象绑定目标（2D纹理）
    glBindTexture(GL_TEXTURE_2D, texture);
    int imageWidth, imageHeight;
    //加载纹理图像
    unsigned char* image = SOIL_load_image(texturePath, &imageWidth, &imageHeight, 0, SOIL_LOAD_RGB);
    //生成2D纹理
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, imageWidth, imageHeight, 0, GL_RGB, GL_UNSIGNED_BYTE, image);
    //释放纹理数据内存
    SOIL_free_image_data(image);
    //设置纹理s和t方向的环绕方式
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
    //设置纹理放大和缩写时的过滤方式（纹素过滤、mipmap边界过滤）
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    //生成多级渐远纹理
    glGenerateMipmap(GL_TEXTURE_2D);
    //解绑纹理对象
    glBindTexture(GL_TEXTURE_2D, 0);

    return texture;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>主程序可以直接使用该类的<code>LoadTexture</code>函数直接加载图片了。全部源码<a href="https://github.com/Popperelay/BlogCode/tree/master/LearnOpenGL5_Texture/LearnOpenGL5_Texture_3" target="_blank" rel="noopener">在这里</a>。<br>&nbsp;</p>
<hr>
<p>参考文献：<a href="https://learnopengl.com/" target="_blank" rel="noopener">LearnOpenGL</a></p>

            </div>

            <!-- Post Comments -->
            
    <!-- 使用 DISQUS_CLICK -->
<div id="disqus-comment">
    <div id="disqus_thread"></div>

<!-- add animation -->
<style>
	.disqus_click_btn {
            line-height: 30px;
            margin: 0;
            min-width: 50px;
            padding: 0 14px;
            display: inline-block;
            font-family: "Roboto", "Helvetica", "Arial", sans-serif;
            font-size: 14px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0;
            overflow: hidden;
            will-change: box-shadow;
            transition: box-shadow .2s cubic-bezier(.4, 0, 1, 1), background-color .2s cubic-bezier(.4, 0, .2, 1), color .2s cubic-bezier(.4, 0, .2, 1);
            outline: 0;
            cursor: pointer;
            text-decoration: none;
            text-align: center;
            vertical-align: middle;
            border: 0;
            background: rgba(158, 158, 158, .2);
            box-shadow: 0 2px 2px 0 rgba(0, 0, 0, .14), 0 3px 1px -2px rgba(0, 0, 0, .2), 0 1px 5px 0 rgba(0, 0, 0, .12);
            color: #fff;
            background-color: #7EC0EE;
            text-shadow: 0
        }
</style>
	
<div class="btn_click_load" id="disqus_bt"> 
    <button class="disqus_click_btn">点击查看评论</button>
</div>

<!--
<script type="text/javascript">
$('.btn_click_load').click(function() {
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'http-miccall-tech'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    document.getElementById('disqus_bt').style.display = "none";
});
</script>
-->
<script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://yoursite.com/2016/11/29/OpenGL5纹理/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = 'http://yoursite.com/2016/11/29/OpenGL5纹理/'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
</script>

<script type="text/javascript">
    $('.btn_click_load').click(function() {  //click to load comments
        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document;
            var s = d.createElement('script');
            s.src = '//http-miccall-tech.disqus.com/embed.js';
            s.setAttribute('data-timestamp', + new Date());
            (d.head || d.body).appendChild(s);
        })();
        $('.btn_click_load').css('display','none');
    });
</script>
</div>
<style>
    #disqus-comment{
        background-color: #eee;
        padding: 2pc;
    }
</style>


        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
                <li>Design: <a href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
            </ul>
            
            	<span id="busuanzi_container_site_pv">2019总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			
        </div>
    </div>
</body>



 	
</html>
