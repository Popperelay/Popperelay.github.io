<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>OpenGL2：创建一个窗口 | Elays&#39;Blog</title>
  <meta name="author" content="Elay">
  
  <meta name="description" content="Elay">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="OpenGL2：创建一个窗口"/>
  <meta property="og:site_name" content="Elays&#39;Blog"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Elays&#39;Blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">Elays&#39;Blog</a></h1>
  <h2><a href="/">你是天地生的，美得超越人形</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">主页</a></li>
    
      <li><a href="/archives">所有文章</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-11-16T09:52:13.000Z"><a href="/2016/11/16/OpenGL2创建一个窗口/">2016-11-16</a></time>
      
      
  
    <h1 class="title">OpenGL2：创建一个窗口</h1>
  

    </header>
    <div class="entry">
      
        <p>在上一篇<a href="http://popperelay.com/2016/10/18/OpenGL%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" target="_blank" rel="external">《OpenGL1：OpenGL概述及环境配置》</a>中，已经说过接下来的OpenGL项目，我们将使用GLFW和GLEW相结合的方式。<br><a id="more"></a></p>
<p><font size="5" color="orange">头文件</font><br>既然要使用GLFW和GLEW中的函数，那在我们的源文件里肯定要包含它俩的头文件：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//GLEW</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> GLEW_STATIC</span></div><div class="line"><span class="meta">#include&lt;GL/glew.h&gt;</span></div><div class="line"><span class="comment">//GLFW</span></div><div class="line"><span class="meta">#include&lt;GLFW/glfw3.h&gt;</span></div></pre></td></tr></table></figure></p>
<hr>
<p><font size="5" color="orange">初始化并配置GLFW</font><br>加入了头文件还不够，接下来还需要在main函数中初始化并配置GLFW：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="comment">//初始化GLFW</span></div><div class="line">	glfwInit(); </div><div class="line">	<span class="comment">//GLFW配置</span></div><div class="line">	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>); <span class="comment">//主版本号</span></div><div class="line">	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>); <span class="comment">//次版本号</span></div><div class="line">	glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE); <span class="comment">// 核心开发模式</span></div><div class="line">	glfwWindowHint(GLFW_RESIZABLE, GL_FALSE); <span class="comment">//窗口尺寸不可变</span></div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在main函数中我们首先使用<code>glfwInit</code>来初始化GLFW，然后可以使用glfwWindowHint来配置GLFW。glfwWindowHint的第一个参数是将要配置的选项，可以从一个枚举中选择可用的选项，这些选项带有GLFW_前缀；第二个参数是一个整数，代表我们为选项所设置的值。可用的选项和对应的值可以在<a href="http://www.glfw.org/docs/latest/group__window.html" target="_blank" rel="external">GLFW文档</a>中找到。</p>
<p>因为我用的是OpenGL3.3版本，所以把主版本和次版本都设为3，这会保证如果一个用户没有特定的OpenGL版本，GLFW就会运行失败。开发模式我们尽量用core-proflie核心模式，而且要求用户不可以调整窗口大小。显式地告诉GLFW我们希望是用core-profile，如果我们调用了一个OpenGL的遗留函数将会产生invalid operation错误，当我们意外地使用了不该使用的旧函数时它是一个很好的提醒。</p>
<hr>
<p><font size="5" color="orange">创建窗口对象</font><br>接下来就是创建窗口对象，有了这个窗口对象后，很多GLFW函数才会有意义：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//创建能够使用GLFW函数的窗口对象（指针）</div><div class="line">	GLFWwindow* window = glfwCreateWindow(800, 600, "LearnOpenGL", nullptr, nullptr);</div><div class="line">	if (window == NULL) &#123;</div><div class="line">		std::cout &lt;&lt; "Failed to create GLFW window" &lt;&lt; std::endl;</div><div class="line">		glfwTerminate();</div><div class="line">		return -1;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>函数<code>glfwCreateWIndow</code>需要窗口的宽度和高度作为它的头两个参数，第三个参数是窗口的名字，后两个参数（显示器、共享资源）可以忽略。该函数返回已创建的FLFWwindow对象的指针，在后面的其他GLFW操作会需要它。</p>
<hr>
<p><font size="5" color="orange">设置窗口环境</font><br>因为每一个窗口都必须有OpenGL或者OpenGL ES的上下文（环境），如果不给窗口指定环境，将会产生GLFW_NO_WINDIW_CONTEXT错误。这里我们使用<code>glfwMakeContextCurrent</code>函数指定窗口环境是当前线程的主环境：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//创建窗口环境</span></div><div class="line">glfwMakeContextCurrent(window);</div></pre></td></tr></table></figure></p>
<hr>
<p><font size="5" color="orange">初始化GLEW</font><br>后面要做的就是用OpenGL函数进行渲染了。不过在之前的文章里，我们已经知道GLEW管理着OpenGL的函数指针，所以需要在调用任何OpenGL函数之前初始化GLEW：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//初始化GLEW</div><div class="line">glewExperimental = GL_TRUE; //保证使用现代技术管理OpenGL机能</div><div class="line">if (glewInit() != GLEW_OK) &#123;</div><div class="line">	std::cout &lt;&lt; "Failed to initialize GLEW" &lt;&lt; std::endl;</div><div class="line">	return -1;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意，在初始化GLEW前我们把glewExperimental变量设置为GL_TRUE。这样可以保证GLEW使用更多的现代技术来管理OpenGL机能。如果不这么设置，它就会使用默认的GL_FALSE，这样当使用core profile时有可能会出问题。</p>
<hr>
<p><font size="5" color="orange">设置渲染窗口</font><br>在开始渲染前，需要告诉OpenGL渲染窗口的大小和位置：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//设置渲染窗口位置大小</span></div><div class="line">glViewport(<span class="number">0</span>, <span class="number">0</span>, <span class="number">800</span>, <span class="number">600</span>);</div></pre></td></tr></table></figure></p>
<p>前两个参数设置了渲染窗口的左下角位置，后两个参数是渲染窗口的宽度和高度。这里指定的是和GLFW窗口是一样大的。不过我们可以吧这个渲染窗口设置得比GLFW窗口尺寸小，这样OpenGL的渲染都会在一个更小的窗口（区域）进行显示，我们可以在OpenGL的渲染窗口viewport之外显示其他的元素。</p>
<p>【注】：</p>
<ul>
<li>OpenGL中处理的坐标其实是在-1到1之间，原点在显示区域正中间，比如一个被加工的点位置是（-0.5,0.5），通过glViewport后会把这种2D坐标映射为屏幕上的坐标（200,450）。</li>
</ul>
<hr>
<p><font size="5" color="orange">渲染循环（游戏循环）</font><br>因为我们不希望程序在会在一个图像之后立即退出，然后关闭窗口，这会造成渲染的结果在屏幕上一闪而过。我们想让程序持续地绘制图像，监听用户输入知道程序被明确告知停止。为了达到这个目的，我们必须建立一个while循环，每次while循环都重新绘制（渲染）一次，直到被告知结束渲染。由于程序始终处于while循环，不会自动退出（除非循环条件不满足，即被告知结束渲染），所以渲染结果也会一直于窗口上，不会一闪而过。下面的代码是一个非常简单的游戏循环（渲染循环）：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//渲染循环（游戏循环）</span></div><div class="line"><span class="keyword">while</span> (!glfwWindowShouldClose(window)) &#123;</div><div class="line">	glfwPollEvents(); <span class="comment">//检测是否有事件被触发（按键按下、鼠标移动）</span></div><div class="line">	glfwSwapBuffers(window); <span class="comment">//交换屏幕缓存</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>glfwWindowShouldClose</code>函数从开始便检验每一次循环迭代中GLFW窗口是否已经得到关闭提示。如果得到这样的提示，函数就会返回true，导致游戏循环终止。</p>
<p><code>glfwPollEvents</code>函数检验是否有任何时间被触发（比如键盘输入、鼠标移动等事件），如果有就可以调用相应函数进行处理（可以通过回调函数进行设置）。而且经常都是在循环迭代前调用事件处理函数。</p>
<p><code>glfwSwapBuffers</code>函数会交换颜色缓冲（颜色缓冲是一个GLFW窗口为每一个像素存储颜色数值的大缓存，它是在这次迭代中绘制的，也作为输出显示在屏幕上）。</p>
<p>【注】：</p>
<ul>
<li>双缓冲（Double Buffer）：当一个应用以单缓冲方式绘制的时候，图像可能会产生闪烁的问题。这是因为最后的图像输出不是被立即绘制出来的，而是一个像素一个像素绘制出来的，通常是以从左到右从上到下这样的方式。由于这些图像不是立即呈现在用户面前，而是一步一步地生成结果，这就会产生很多不真实感。为了规避这些问题，窗口应用使用双缓冲的方式进行渲染。前缓冲包含最终的输出图像，它被显示在屏幕上，<strong>与此同时</strong>，所有的渲染命令绘制后缓冲。所有的渲染命令执行结束后，我们就把后缓冲交换到前缓冲，这样图像就会立即显示到用户面前了，前面提到的闪烁问题就被解决了。</li>
</ul>
<hr>
<p><font size="5" color="orange">渲染</font><br>我们需要把所有的渲染命令都放在渲染循环里，因为我们打算每个循环迭代都执行所有的渲染命令。通常把渲染命令放在检查事件和交换缓冲之间：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//渲染循环（游戏循环）</span></div><div class="line"><span class="keyword">while</span> (!glfwWindowShouldClose(window)) &#123;</div><div class="line">	glfwPollEvents(); <span class="comment">//检测是否有事件被触发（按键按下、鼠标移动）</span></div><div class="line">	...               <span class="comment">//这里是渲染命令</span></div><div class="line">	glfwSwapBuffers(window); <span class="comment">//交换屏幕缓存</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里我们使用一个最简单的渲染命令：用指定的颜色清空屏幕。因为每个渲染迭代开始时，我们都需要清理屏幕，否则只能一直看到前一个迭代的结果：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">glClearColor(<span class="number">0.2</span>f, <span class="number">0.3</span>f, <span class="number">0.3</span>f, <span class="number">1.0</span>f);</div><div class="line">glClear(GL_COLOR_BUFFER_BIT);</div></pre></td></tr></table></figure></p>
<p>使用<code>glClearColor</code>函数来设置清空屏幕用的颜色。使用<code>glClear</code>函数清理屏幕的颜色缓冲，在这个函数中我们以缓冲位（BUFFER_BIT）指定我们希望清理哪个缓冲。可以用的位可以是GL_COLOR_BUFFER_BIT、GL_DEPTH_BUFFER_BIT和GL_STENCIL_BUFFER_BIT。因为我们现在关心的只是颜色值，所以我们只清空颜色缓冲。</p>
<p><font size="5" color="orange">响应输入</font><br>之前的while循环是会一直运行下去的，因为没有被告知停止循环。现在我们希望在GLFW中有些控制输入的方式，当用户按下某个按键后结束渲染循环。我们可以使用GLFW的回调函数做到这点。其中有一个GLFW回调函数是KeyCallback函数，它在用户使用键盘交互的时候会被GLFW自动调用。该回调函数的原型是：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> (* GLFWkeyfun)(GLFWwindow* window, <span class="keyword">int</span> key, <span class="keyword">int</span> scancode, <span class="keyword">int</span> action, <span class="keyword">int</span> mode);</div></pre></td></tr></table></figure></p>
<p>按键输入回调函数的参数是一个GLFWwindow对象指针，一个代表按下按键的整型数字，按键扫描码，一个表示按键是被按下、释放还是按住的整型数字，一个代表某个标识的整数告诉你shift、control、alt或super按键是否被同时按下。每当用户按下一个按钮，GLFW都会自动调用这个函数，为该函数填充合适的参数。我们给这个按键输入回调函数随便起个名字吧，叫key_callback：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">key_callback</span>(<span class="params">GLFWwindow* window,<span class="keyword">int</span> key,<span class="keyword">int</span> scancode,<span class="keyword">int</span> action,<span class="keyword">int</span> mode</span>) </span>&#123;</div><div class="line">	<span class="keyword">if</span> (key == GLFW_KEY_ESCAPE&amp;&amp;action == GLFW_PRESS) &#123;</div><div class="line">		glfwSetWindowShouldClose(window, GL_TRUE);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在我们（新创建）的key_callback函数中，我们检查被<strong>按下</strong>的按键是否是ESC键，如果是的话，就用glfwSetWindowShouldClose设置它的WindowShouldClose属性为true来关闭GLFW窗口。下一个主while循环条件不满足，则渲染循环就结束了。</p>
<p>还有最后一点，在使用回调函数之前，是需要先注册的，也就是得给我们的这个按键回调函数声明一下并起个名字：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//注册回调函数</span></div><div class="line">glfwSetKeyCallback(window, key_callback);</div></pre></td></tr></table></figure></p>
<p>【注】：</p>
<ul>
<li>除了按键回调函数外，还有许多GLFW回调函数可供于给注册我们自己的函数。</li>
<li>要在创建窗口之后，渲染循环之前注册回调函数。</li>
</ul>
<p>&nbsp; </p>
<hr>
<p><font size="5" color="orange">释放资源</font><br>退出渲染循环后，在程序结束之前，应该释放掉由GLFW分配的资源。使用<code>glfwTerminate</code>函数来完成：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//结束CLFW，释放由GLFW分配的资源</span></div><div class="line">glfwTerminate();</div></pre></td></tr></table></figure></p>
<p>这样会清理所有资源，并正确地退出程序。<br>&nbsp; </p>
<hr>
<p>到此为止的所有源码如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">#include&lt;iostream&gt;</div><div class="line">//GLEW</div><div class="line">#define GLEW_STATIC</div><div class="line">#include&lt;GL/glew.h&gt;</div><div class="line">//GLFW</div><div class="line">#include&lt;GLFW/glfw3.h&gt;</div><div class="line"></div><div class="line">//窗口尺寸</div><div class="line">const GLuint WIDTH = 800, HEIGHT = 600;</div><div class="line"></div><div class="line">//函数声明</div><div class="line">void key_callback(GLFWwindow* window, int key, int scancode, int action, int mode);</div><div class="line">int main() &#123;</div><div class="line">	//初始化GLFW</div><div class="line">	glfwInit(); </div><div class="line">	//GLFW配置</div><div class="line">	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); //主版本号</div><div class="line">	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); //次版本号</div><div class="line">	glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE); // 核心开发模式</div><div class="line">	glfwWindowHint(GLFW_RESIZABLE, GL_FALSE); //窗口尺寸不可变</div><div class="line">	//创建能够使用GLFW函数的窗口对象（指针）</div><div class="line">	GLFWwindow* window = glfwCreateWindow(WIDTH, HEIGHT, "LearnOpenGL", nullptr, nullptr);</div><div class="line">	if (window == NULL) &#123;</div><div class="line">		std::cout &lt;&lt; "Failed to create GLFW window" &lt;&lt; std::endl;</div><div class="line">		glfwTerminate();</div><div class="line">		return -1;</div><div class="line">	&#125;</div><div class="line">	//创建窗口环境</div><div class="line">	glfwMakeContextCurrent(window);</div><div class="line">	//注册回调函数</div><div class="line">	glfwSetKeyCallback(window, key_callback);</div><div class="line">	//初始化GLEW</div><div class="line">	glewExperimental = GL_TRUE; //保证使用现代技术管理OpenGL机能</div><div class="line">	if (glewInit() != GLEW_OK) &#123;</div><div class="line">		std::cout &lt;&lt; "Failed to initialize GLEW" &lt;&lt; std::endl;</div><div class="line">		return -1;</div><div class="line">	&#125;</div><div class="line">	//设置渲染窗口位置大小</div><div class="line">	int width, height;</div><div class="line">	glfwGetFramebufferSize(window, &amp;width, &amp;height);</div><div class="line">	glViewport(0, 0, width, height);</div><div class="line">	//渲染循环（游戏循环）</div><div class="line">	while (!glfwWindowShouldClose(window)) &#123;</div><div class="line">		glfwPollEvents(); //检测是否有事件被触发（按键按下、鼠标移动）</div><div class="line">		glClearColor(0.2f, 0.3f, 0.3f, 1.0f);</div><div class="line">		glClear(GL_COLOR_BUFFER_BIT);</div><div class="line">		glfwSwapBuffers(window); //交换屏幕缓存</div><div class="line">	&#125;</div><div class="line">	//结束CLFW，释放由GLFW分配的资源</div><div class="line">	glfwTerminate();</div><div class="line">	return 0;</div><div class="line">&#125;</div><div class="line">//按键回调函数</div><div class="line">void key_callback(GLFWwindow* window,int key,int scancode,int action,int mode) &#123;</div><div class="line">	if (key == GLFW_KEY_ESCAPE&amp;&amp;action == GLFW_PRESS) &#123;</div><div class="line">		glfwSetWindowShouldClose(window, GL_TRUE);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>编译运行后的结果是一个黑蓝绿色的窗口：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/14792896857.png" alt=""><br>按下esc键后，窗口关闭程序结束退出。<br> &nbsp;</p>
<hr>

      
    </div>
    <footer>
      
        
  
  <div class="categories">
    <a href="/categories/OpenGL/">OpenGL</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/OpenGL窗口/">OpenGL窗口</a>
  </div>

        
  <div class="addthis addthis_toolbox addthis_default_style">
    
      <a class="addthis_button_facebook_like" fb:like:layout="button_count"></a>
    
    
      <a class="addthis_button_tweet"></a>
    
    
      <a class="addthis_button_google_plusone" g:plusone:size="medium"></a>
    
    
      <a class="addthis_button_pinterest_pinit" pi:pinit:layout="horizontal"></a>
    
    <a class="addthis_counter addthis_pill_style"></a>
  </div>
  <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js"></script>

      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


<section id="comment">
  <h2 class="title">留言</h2>


 
  	   <!-- 多说评论框 start -->
 		<div class="ds-thread" data-thread-key="2016/11/16/OpenGL2创建一个窗口/" data-title="OpenGL2：创建一个窗口" data-url="http://yoursite.com/2016/11/16/OpenGL2创建一个窗口/"></div>
		<!-- 多说评论框 end -->
		<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
		<script type="text/javascript">
		var duoshuoQuery = {short_name:"popperelay"};   <!-- 替换这里的duoshuo_shortname为前面注册的shortname -->
			(function() {
				var ds = document.createElement('script');
				ds.type = 'text/javascript';ds.async = true;
				ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.unstable.js';
				ds.charset = 'UTF-8';
				(document.getElementsByTagName('head')[0] 
				 || document.getElementsByTagName('body')[0]).appendChild(ds);
			})();
			</script>
		<!-- 多说公共JS代码 end -->
 
  
</section>

</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:yoursite.com">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/C-语法/">C#语法</a><small>2</small></li>
  
    <li><a href="/categories/OpenGL/">OpenGL</a><small>2</small></li>
  
    <li><a href="/categories/博客配置/">博客配置</a><small>3</small></li>
  
    <li><a href="/categories/操作系统/">操作系统</a><small>4</small></li>
  
    <li><a href="/categories/数据结构/">数据结构</a><small>15</small></li>
  
    <li><a href="/categories/游戏开发/">游戏开发</a><small>1</small></li>
  
    <li><a href="/categories/计算机图形学/">计算机图形学</a><small>2</small></li>
  
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/BIOS和微机启动过程/">BIOS和微机启动过程</a><small>1</small></li>
  
    <li><a href="/tags/C-容器/">C#容器</a><small>1</small></li>
  
    <li><a href="/tags/MarkDown/">MarkDown</a><small>1</small></li>
  
    <li><a href="/tags/Mathjax语法/">Mathjax语法</a><small>1</small></li>
  
    <li><a href="/tags/OS内核/">OS内核</a><small>1</small></li>
  
    <li><a href="/tags/OpenGL窗口/">OpenGL窗口</a><small>1</small></li>
  
    <li><a href="/tags/OpenGL配置/">OpenGL配置</a><small>1</small></li>
  
    <li><a href="/tags/timeTest/">timeTest</a><small>1</small></li>
  
    <li><a href="/tags/二叉树/">二叉树</a><small>1</small></li>
  
    <li><a href="/tags/关键路径/">关键路径</a><small>1</small></li>
  
    <li><a href="/tags/图/">图</a><small>1</small></li>
  
    <li><a href="/tags/图形学概述/">图形学概述</a><small>1</small></li>
  
    <li><a href="/tags/图形显示系统/">图形显示系统</a><small>1</small></li>
  
    <li><a href="/tags/多说/">多说</a><small>1</small></li>
  
    <li><a href="/tags/头结点/">头结点</a><small>1</small></li>
  
    <li><a href="/tags/尾递归/">尾递归</a><small>1</small></li>
  
    <li><a href="/tags/帧同步/">帧同步</a><small>1</small></li>
  
    <li><a href="/tags/拓扑排序/">拓扑排序</a><small>1</small></li>
  
    <li><a href="/tags/操作系统概述/">操作系统概述</a><small>1</small></li>
  
    <li><a href="/tags/改进排序/">改进排序</a><small>1</small></li>
  
    <li><a href="/tags/最小生成树/">最小生成树</a><small>1</small></li>
  
    <li><a href="/tags/最短路径/">最短路径</a><small>1</small></li>
  
    <li><a href="/tags/查找/">查找</a><small>1</small></li>
  
    <li><a href="/tags/栈/">栈</a><small>1</small></li>
  
    <li><a href="/tags/树/">树</a><small>1</small></li>
  
    <li><a href="/tags/简单排序/">简单排序</a><small>1</small></li>
  
    <li><a href="/tags/进程的描述与控制/">进程的描述与控制</a><small>1</small></li>
  
    <li><a href="/tags/链表/">链表</a><small>1</small></li>
  
    <li><a href="/tags/队列/">队列</a><small>1</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2016 Elay
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>


<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</body>
</html>