<!DOCTYPE HTML>
<html>

<head>
	<link rel="bookmark"  type="image/x-icon"  href="/img/logo_miccall.png"/>
	 <link rel="shortcut icon" href="/img/logo_miccall.png">
	
			
    <title>
    Elays'Blog
    </title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="/css/mic_main.css" />
    <link rel="stylesheet" href="/css/dropdownMenu.css" />
    
    	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css" />
    </noscript>
	
	<!--  SwiftType Search  -->
	<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

			    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<link rel="stylesheet" href="/css/prism-dark.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>
    
		
<!-- Layouts -->


<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<!--<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">-->
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/latest.js?config=TeX-MML-AM_CHTML" async>
</script>

<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_undefined.css" />
<link rel="stylesheet" href="/css/typo.css" />
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">MICCALL</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special" >
            <ul class="menu links" >
			<!-- Homepage  主页  --> 
			<li >
	            <a href="/" rel="nofollow">主页</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">分类</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="/categories/Boost/">Boost</a></li><li><a class="category-link" href="/categories/C-语法/">C#语法</a></li><li><a class="category-link" href="/categories/C/">C++</a></li><li><a class="category-link" href="/categories/C语言/">C语言</a></li><li><a class="category-link" href="/categories/OpenGL/">OpenGL</a></li><li><a class="category-link" href="/categories/c/">c++</a></li><li><a class="category-link" href="/categories/全局光照/">全局光照</a></li><li><a class="category-link" href="/categories/博客配置/">博客配置</a></li><li><a class="category-link" href="/categories/并行计算/">并行计算</a></li><li><a class="category-link" href="/categories/操作系统/">操作系统</a></li><li><a class="category-link" href="/categories/数据结构/">数据结构</a></li><li><a class="category-link" href="/categories/毕设/">毕设</a></li><li><a class="category-link" href="/categories/游戏开发/">游戏开发</a></li><li><a class="category-link" href="/categories/游戏设计模式/">游戏设计模式</a></li><li><a class="category-link" href="/categories/计算机图形学/">计算机图形学</a></li><li><a class="category-link" href="/categories/计算机系统/">计算机系统</a></li><li><a class="category-link" href="/categories/设计模式/">设计模式</a></li><li><a class="category-link" href="/categories/调试错误集锦/">调试错误集锦</a>
	                    </ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/gallery/" title="图库">
		                图库
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
		            
		                <li><a href="https://github.com/miccall" class="icon fa-github"><span class="label">GitHub</span></a></li>
		            
		            
		            
		            
			</ul>
</nav>

        <div id="main" >
            <div class ="post_page_title_img" style="height: 25rem;background-image: url(undefined);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;" >
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2 >OpenGL2：创建一个窗口</h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
				<div id="toc" class="toc-article">
					<strong class="toc-title">文章目录</strong>
					
				</div>
                <p>在上一篇<a href="http://popperelay.com/2016/10/18/OpenGL%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" target="_blank" rel="external">《OpenGL1：OpenGL概述及环境配置》</a>中，已经说过接下来的OpenGL项目，我们将使用GLFW和GLEW相结合的方式。<br><a id="more"></a></p>
<p><font size="5" color="orange">头文件</font><br>既然要使用GLFW和GLEW中的函数，那在我们的源文件里肯定要包含它俩的头文件：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token comment" spellcheck="true">//GLEW</span>
<span class="token preprocessor property">#<span class="token directive keyword">define</span> GLEW_STATIC</span>
<span class="token preprocessor property">#include&lt;GL/glew.h></span>
<span class="token comment" spellcheck="true">//GLFW</span>
<span class="token preprocessor property">#include&lt;GLFW/glfw3.h></span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<hr>
<p><font size="5" color="orange">初始化并配置GLFW</font><br>加入了头文件还不够，接下来还需要在main函数中初始化并配置GLFW：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//初始化GLFW</span>
    <span class="token function">glfwInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token comment" spellcheck="true">//GLFW配置</span>
    <span class="token function">glfwWindowHint</span><span class="token punctuation">(</span>GLFW_CONTEXT_VERSION_MAJOR<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//主版本号</span>
    <span class="token function">glfwWindowHint</span><span class="token punctuation">(</span>GLFW_CONTEXT_VERSION_MINOR<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//次版本号</span>
    <span class="token function">glfwWindowHint</span><span class="token punctuation">(</span>GLFW_OPENGL_PROFILE<span class="token punctuation">,</span> GLFW_OPENGL_CORE_PROFILE<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 核心开发模式</span>
    <span class="token function">glfwWindowHint</span><span class="token punctuation">(</span>GLFW_RESIZABLE<span class="token punctuation">,</span> GL_FALSE<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//窗口尺寸不可变</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在main函数中我们首先使用<code>glfwInit</code>来初始化GLFW，然后可以使用glfwWindowHint来配置GLFW。glfwWindowHint的第一个参数是将要配置的选项，可以从一个枚举中选择可用的选项，这些选项带有GLFW_前缀；第二个参数是一个整数，代表我们为选项所设置的值。可用的选项和对应的值可以在<a href="http://www.glfw.org/docs/latest/group__window.html" target="_blank" rel="external">GLFW文档</a>中找到。</p>
<p>因为我用的是OpenGL3.3版本，所以把主版本和次版本都设为3，这会保证如果一个用户没有特定的OpenGL版本，GLFW就会运行失败。开发模式我们尽量用core-proflie核心模式，而且要求用户不可以调整窗口大小。显式地告诉GLFW我们希望是用core-profile，如果我们调用了一个OpenGL的遗留函数将会产生invalid operation错误，当我们意外地使用了不该使用的旧函数时它是一个很好的提醒。<br>&nbsp; </p>
<hr>
<p><font size="5" color="orange">创建窗口对象</font><br>接下来就是创建窗口对象，有了这个窗口对象后，很多GLFW函数才会有意义：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token comment" spellcheck="true">//创建能够使用GLFW函数的窗口对象（指针）</span>
    GLFWwindow<span class="token operator">*</span> window <span class="token operator">=</span> <span class="token function">glfwCreateWindow</span><span class="token punctuation">(</span><span class="token number">800</span><span class="token punctuation">,</span> <span class="token number">600</span><span class="token punctuation">,</span> <span class="token string">"LearnOpenGL"</span><span class="token punctuation">,</span> nullptr<span class="token punctuation">,</span> nullptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>window <span class="token operator">==</span> NULL<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token string">"Failed to create GLFW window"</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>endl<span class="token punctuation">;</span>
        <span class="token function">glfwTerminate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>函数<code>glfwCreateWIndow</code>需要窗口的宽度和高度作为它的头两个参数，第三个参数是窗口的名字，后两个参数（显示器、共享资源）可以忽略。该函数返回已创建的FLFWwindow对象的指针，在后面的其他GLFW操作会需要它。<br>&nbsp; </p>
<hr>
<p><font size="5" color="orange">设置窗口环境</font><br>因为每一个窗口都必须有OpenGL或者OpenGL ES的上下文（环境），如果不给窗口指定环境，将会产生GLFW_NO_WINDIW_CONTEXT错误。这里我们使用<code>glfwMakeContextCurrent</code>函数指定窗口环境是当前线程的主环境：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp">    <span class="token comment" spellcheck="true">//创建窗口环境</span>
    <span class="token function">glfwMakeContextCurrent</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>&nbsp; </p>
<hr>
<p><font size="5" color="orange">初始化GLEW</font><br>后面要做的就是用OpenGL函数进行渲染了。不过在之前的文章里，我们已经知道GLEW管理着OpenGL的函数指针，所以需要在调用任何OpenGL函数之前初始化GLEW：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp">    <span class="token comment" spellcheck="true">//初始化GLEW</span>
    glewExperimental <span class="token operator">=</span> GL_TRUE<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//保证使用现代技术管理OpenGL机能</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">glewInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> GLEW_OK<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token string">"Failed to initialize GLEW"</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>endl<span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注意，在初始化GLEW前我们把glewExperimental变量设置为GL_TRUE。这样可以保证GLEW使用更多的现代技术来管理OpenGL机能。如果不这么设置，它就会使用默认的GL_FALSE，这样当使用core profile时有可能会出问题。<br>&nbsp;  </p>
<hr>
<p><font size="5" color="orange">设置渲染窗口</font><br>在开始渲染前，需要告诉OpenGL渲染窗口的大小和位置：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp">    <span class="token comment" spellcheck="true">//设置渲染窗口位置大小</span>
    <span class="token function">glViewport</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">800</span><span class="token punctuation">,</span> <span class="token number">600</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>前两个参数设置了渲染窗口的左下角位置，后两个参数是渲染窗口的宽度和高度。这里指定的是和GLFW窗口是一样大的。不过我们可以吧这个渲染窗口设置得比GLFW窗口尺寸小，这样OpenGL的渲染都会在一个更小的窗口（区域）进行显示，我们可以在OpenGL的渲染窗口viewport之外显示其他的元素。</p>
<p>【注】：</p>
<ul>
<li>OpenGL中处理的坐标其实是在-1到1之间，原点在显示区域正中间，比如一个被加工的点位置是（-0.5,0.5）（标准化设备坐标），通过glViewport后会把这种2D坐标映射为屏幕上的坐标（200,450）。<br>&nbsp; </li>
</ul>
<hr>
<p><font size="5" color="orange">渲染循环（游戏循环）</font><br>因为我们不希望程序在会在一个图像之后立即退出，然后关闭窗口，这会造成渲染的结果在屏幕上一闪而过。我们想让程序持续地绘制图像，监听用户输入知道程序被明确告知停止。为了达到这个目的，我们必须建立一个while循环，每次while循环都重新绘制（渲染）一次，直到被告知结束渲染。由于程序始终处于while循环，不会自动退出（除非循环条件不满足，即被告知结束渲染），所以渲染结果也会一直于窗口上，不会一闪而过。下面的代码是一个非常简单的游戏循环（渲染循环）：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp">    <span class="token comment" spellcheck="true">//渲染循环（游戏循环）</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">glfwWindowShouldClose</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">glfwPollEvents</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//检测是否有事件被触发（按键按下、鼠标移动）</span>
        <span class="token function">glfwSwapBuffers</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//交换屏幕缓存</span>
    <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>glfwWindowShouldClose</code>函数从开始便检验每一次循环迭代中GLFW窗口是否已经得到关闭提示。如果得到这样的提示，函数就会返回true，导致游戏循环终止。</p>
<p><code>glfwPollEvents</code>函数检验是否有任何时间被触发（比如键盘输入、鼠标移动等事件），如果有就可以调用相应函数进行处理（可以通过回调函数进行设置）。而且经常都是在循环迭代前调用事件处理函数。</p>
<p><code>glfwSwapBuffers</code>函数会交换颜色缓冲（颜色缓冲是一个GLFW窗口为每一个像素存储颜色数值的大缓存，它是在这次迭代中绘制的，也作为输出显示在屏幕上）。</p>
<p>【注】：</p>
<ul>
<li>双缓冲（Double Buffer）：当一个应用以单缓冲方式绘制的时候，图像可能会产生闪烁的问题。这是因为最后的图像输出不是被立即绘制出来的，而是一个像素一个像素绘制出来的，通常是以从左到右从上到下这样的方式。由于这些图像不是立即呈现在用户面前，而是一步一步地生成结果，这就会产生很多不真实感。为了规避这些问题，窗口应用使用双缓冲的方式进行渲染。前缓冲包含最终的输出图像，它被显示在屏幕上，<strong>与此同时</strong>，所有的渲染命令绘制后缓冲。所有的渲染命令执行结束后，我们就把后缓冲交换到前缓冲，这样图像就会立即显示到用户面前了，前面提到的闪烁问题就被解决了。<br>&nbsp; </li>
</ul>
<hr>
<p><font size="5" color="orange">渲染</font><br>我们需要把所有的渲染命令都放在渲染循环里，因为我们打算每个循环迭代都执行所有的渲染命令。通常把渲染命令放在检查事件和交换缓冲之间：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp">    <span class="token comment" spellcheck="true">//渲染循环（游戏循环）</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">glfwWindowShouldClose</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">glfwPollEvents</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//检测是否有事件被触发（按键按下、鼠标移动）</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>               <span class="token comment" spellcheck="true">//这里是渲染命令</span>
        <span class="token function">glfwSwapBuffers</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//交换屏幕缓存</span>
    <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里我们使用一个最简单的渲染命令：用指定的颜色清空屏幕。因为每个渲染迭代开始时，我们都需要清理屏幕，否则只能一直看到前一个迭代的结果：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp">        <span class="token function">glClearColor</span><span class="token punctuation">(</span><span class="token number">0.2f</span><span class="token punctuation">,</span> <span class="token number">0.3f</span><span class="token punctuation">,</span> <span class="token number">0.3f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">glClear</span><span class="token punctuation">(</span>GL_COLOR_BUFFER_BIT<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>使用<code>glClearColor</code>函数来设置清空屏幕用的颜色。使用<code>glClear</code>函数清理屏幕的颜色缓冲，在这个函数中我们以缓冲位（BUFFER_BIT）指定我们希望清理哪个缓冲。可以用的位可以是GL_COLOR_BUFFER_BIT、GL_DEPTH_BUFFER_BIT和GL_STENCIL_BUFFER_BIT。因为我们现在关心的只是颜色值，所以我们只清空颜色缓冲。<br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">响应输入</font><br>之前的while循环是会一直运行下去的，因为没有被告知停止循环。现在我们希望在GLFW中有些控制输入的方式，当用户按下某个按键后结束渲染循环。我们可以使用GLFW的回调函数做到这点。其中有一个GLFW回调函数是KeyCallback函数，它在用户使用键盘交互的时候会被GLFW自动调用。该回调函数的原型是：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span> GLFWkeyfun<span class="token punctuation">)</span><span class="token punctuation">(</span>GLFWwindow<span class="token operator">*</span> window<span class="token punctuation">,</span> <span class="token keyword">int</span> key<span class="token punctuation">,</span> <span class="token keyword">int</span> scancode<span class="token punctuation">,</span> <span class="token keyword">int</span> action<span class="token punctuation">,</span> <span class="token keyword">int</span> mode<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>按键输入回调函数的参数是一个GLFWwindow对象指针，一个代表按下按键的整型数字，按键扫描码，一个表示按键是被按下、释放还是按住的整型数字，一个代表某个标识的整数告诉你shift、control、alt或super按键是否被同时按下。每当用户按下一个按钮，GLFW都会自动调用这个函数，为该函数填充合适的参数。我们给这个按键输入回调函数随便起个名字吧，叫key_callback：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">void</span> <span class="token function">key_callback</span><span class="token punctuation">(</span>GLFWwindow<span class="token operator">*</span> window<span class="token punctuation">,</span><span class="token keyword">int</span> key<span class="token punctuation">,</span><span class="token keyword">int</span> scancode<span class="token punctuation">,</span><span class="token keyword">int</span> action<span class="token punctuation">,</span><span class="token keyword">int</span> mode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> GLFW_KEY_ESCAPE<span class="token operator">&amp;&amp;</span>action <span class="token operator">==</span> GLFW_PRESS<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">glfwSetWindowShouldClose</span><span class="token punctuation">(</span>window<span class="token punctuation">,</span> GL_TRUE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在我们（新创建）的key_callback函数中，我们检查被<strong>按下</strong>的按键是否是ESC键，如果是的话，就用glfwSetWindowShouldClose设置它的WindowShouldClose属性为true来关闭GLFW窗口。下一个主while循环条件不满足，则渲染循环就结束了。</p>
<p>还有最后一点，在使用回调函数之前，是需要先注册的，也就是得给我们的这个按键回调函数声明一下并起个名字：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp">    <span class="token comment" spellcheck="true">//注册回调函数</span>
    <span class="token function">glfwSetKeyCallback</span><span class="token punctuation">(</span>window<span class="token punctuation">,</span> key_callback<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>【注】：</p>
<ul>
<li>除了按键回调函数外，还有许多GLFW回调函数可供于给注册我们自己的函数。</li>
<li>要在创建窗口之后，渲染循环之前注册回调函数。</li>
</ul>
<p>&nbsp; </p>
<hr>
<p><font size="5" color="orange">释放资源</font><br>退出渲染循环后，在程序结束之前，应该释放掉由GLFW分配的资源。使用<code>glfwTerminate</code>函数来完成：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp">    <span class="token comment" spellcheck="true">//结束CLFW，释放由GLFW分配的资源</span>
    <span class="token function">glfwTerminate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>这样会清理所有资源，并正确地退出程序。<br>&nbsp; </p>
<hr>
<p>到此为止的所有源码<a href="https://github.com/Popperelay/BlogCode/blob/master/LearnOpenGL2_CreateWindow/main.cpp" target="_blank" rel="external">在这里</a>。<br>编译运行后的结果是一个黑蓝绿色的窗口：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/14792896857.png" alt=""><br>按下esc键后，窗口关闭程序结束退出。<br>&nbsp;</p>
<hr>
<p>参考文献：<a href="https://learnopengl.com/" target="_blank" rel="external">LearnOpenGL</a></p>

            </div>

            <!-- Post Comments -->
            
    <!-- 使用 DISQUS_CLICK -->
<div id="disqus-comment">
    <div id="disqus_thread"></div>

<!-- add animation -->
<style>
	.disqus_click_btn {
            line-height: 30px;
            margin: 0;
            min-width: 50px;
            padding: 0 14px;
            display: inline-block;
            font-family: "Roboto", "Helvetica", "Arial", sans-serif;
            font-size: 14px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0;
            overflow: hidden;
            will-change: box-shadow;
            transition: box-shadow .2s cubic-bezier(.4, 0, 1, 1), background-color .2s cubic-bezier(.4, 0, .2, 1), color .2s cubic-bezier(.4, 0, .2, 1);
            outline: 0;
            cursor: pointer;
            text-decoration: none;
            text-align: center;
            vertical-align: middle;
            border: 0;
            background: rgba(158, 158, 158, .2);
            box-shadow: 0 2px 2px 0 rgba(0, 0, 0, .14), 0 3px 1px -2px rgba(0, 0, 0, .2), 0 1px 5px 0 rgba(0, 0, 0, .12);
            color: #fff;
            background-color: #7EC0EE;
            text-shadow: 0
        }
</style>
	
<div class="btn_click_load" id="disqus_bt"> 
    <button class="disqus_click_btn">点击查看评论</button>
</div>

<!--
<script type="text/javascript">
$('.btn_click_load').click(function() {
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'http-miccall-tech'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    document.getElementById('disqus_bt').style.display = "none";
});
</script>
-->
<script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://yoursite.com/2016/11/16/OpenGL2创建一个窗口/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = 'http://yoursite.com/2016/11/16/OpenGL2创建一个窗口/'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
</script>

<script type="text/javascript">
    $('.btn_click_load').click(function() {  //click to load comments
        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document;
            var s = d.createElement('script');
            s.src = '//http-miccall-tech.disqus.com/embed.js';
            s.setAttribute('data-timestamp', + new Date());
            (d.head || d.body).appendChild(s);
        })();
        $('.btn_click_load').css('display','none');
    });
</script>
</div>
<style>
    #disqus-comment{
        background-color: #eee;
        padding: 2pc;
    }
</style>


        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
                <li>Design: <a href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
            </ul>
            
            	<span id="busuanzi_container_site_pv">2018总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			
        </div>
    </div>
</body>



 	
</html>
