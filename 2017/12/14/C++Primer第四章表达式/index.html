<!DOCTYPE HTML>
<html>

<head>
	<link rel="bookmark"  type="image/x-icon"  href="/img/logo_miccall.png"/>
	 <link rel="shortcut icon" href="/img/logo_miccall.png">
	
			
    <title>
    Elays'Blog
    </title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="/css/mic_main.css" />
    <link rel="stylesheet" href="/css/dropdownMenu.css" />
    
    	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css" />
    </noscript>

			    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<link rel="stylesheet" href="/css/prism-dark.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>
    
		
<!-- Layouts -->


<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_undefined.css" />
<link rel="stylesheet" href="/css/typo.css" />
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">MICCALL</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special" >
            <ul class="menu links" >
			<!-- Homepage  主页  --> 
			<li >
	            <a href="/" rel="nofollow">主页</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">分类</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="/categories/Boost/">Boost</a></li><li><a class="category-link" href="/categories/C-语法/">C#语法</a></li><li><a class="category-link" href="/categories/C/">C++</a></li><li><a class="category-link" href="/categories/C语言/">C语言</a></li><li><a class="category-link" href="/categories/OpenGL/">OpenGL</a></li><li><a class="category-link" href="/categories/c/">c++</a></li><li><a class="category-link" href="/categories/全局光照/">全局光照</a></li><li><a class="category-link" href="/categories/博客配置/">博客配置</a></li><li><a class="category-link" href="/categories/操作系统/">操作系统</a></li><li><a class="category-link" href="/categories/数据结构/">数据结构</a></li><li><a class="category-link" href="/categories/毕设/">毕设</a></li><li><a class="category-link" href="/categories/游戏开发/">游戏开发</a></li><li><a class="category-link" href="/categories/游戏设计模式/">游戏设计模式</a></li><li><a class="category-link" href="/categories/计算机图形学/">计算机图形学</a></li><li><a class="category-link" href="/categories/设计模式/">设计模式</a></li><li><a class="category-link" href="/categories/调试错误集锦/">调试错误集锦</a>
	                    </ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/about/" title="简历">
		                简历
		            </a>
		        </li>
		        
		        <li>
		            <a href="/group/" title="团队">
		                团队
		            </a>
		        </li>
		        
		        <li>
		            <a href="/gallery/" title="图库">
		                图库
		            </a>
		        </li>
		        
		        <li>
		            <a href="/tag/" title="标签">
		                标签
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
		            
		                <li><a href="https://github.com/miccall" class="icon fa-github"><span class="label">GitHub</span></a></li>
		            
		            
		            
		            
			</ul>
</nav>

        <div id="main" >
            <div class ="post_page_title_img" style="height: 25rem;background-image: url(http://oqcvzqam1.bkt.clouddn.com/C++Primer%E7%AC%AC4%E7%AB%A0.jpg);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;" >
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2 >C++Primer第四章 表达式</h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
                <p><font size="5" color="orange">基础</font><br><a id="more"></a></p>
<hr>
<ol>
<li>小整数类型（如bool、char、short等）通常会被提升成较大的整数类型（主要是int）。</li>
<li>当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中地址）。总之，左值是用址，右值是用值。左值右值并不是等号=左侧右侧的意思。</li>
<li><p>对于如下表达式：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p> 我们无法知道到底是f1先执行还是f2先执行，这个调用顺序是不固定的。</p>
<p> 对于这种没有指定执行顺序的运算符来说，如果表达式指向并修改了同一个对象，将会引发错误并产生未定义的行为,，程序结果将是不可预知的。如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
 std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span><span class="token operator">++</span>i <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//未定义的</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p> 编译器可能先求++i的值再求i的值，此时输出结果是1 1；也可能先求i的值再求++i的值，输出结果是0 1；甚至编译器还可能做完全不同的操作。</p>
<p> 建议：</p>
<pre><code>- 拿不准的时候最好用括号来强制让表达式的组合关系符合程序逻辑的要求。
- 如果改变了某个运算对象的值，在表达式的其他地方不要再使用这个运算对象。
</code></pre></li>
</ol>
<p><font size="5" color="orange">算术运算符</font></p>
<hr>
<ol>
<li><p>对大对数运算符来说，布尔类型的运算对象将被提升为int类型。如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">bool</span> b <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
 <span class="token keyword">bool</span> b2 <span class="token operator">=</span> <span class="token operator">-</span>b<span class="token punctuation">;</span>
 std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> b2 <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//输出1，b2是ture！</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p> 参与运算时b将被提升成整数值1，对它求负后的结果是-1，将-1再转换会布尔值将其作为b2的初始值，显然这个初始值不等于0，转换成布尔值后应该为1，所以b2的值是true。</p>
<p> 再一次证明，布尔值不应该参与运算。</p>
</li>
<li>参与取余运算的运算对象必须是整数类型。余数的符号总是和余数表达式中的被除数一致。m%(-n)等于m%n，(-m)%n等于-(m%n)。</li>
</ol>
<p><font size="5" color="orange">赋值运算符</font></p>
<hr>
<ol>
<li>C++11新标准允许使用花括号括起来的初始值列表作为赋值语句的右侧运算对象：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span>
 <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">3.14</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//运行错误</span>
 std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> vi<span class="token punctuation">;</span>
 vi <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
 第一条语句运行时正常，a的值将是3，而第二条语句运行时报错：懂double转换到int需要收缩转换。这是因为使用初始值列表来进行赋值的时候，初始值列表里值所占的空间不应该大于目标类型的空间。</li>
<li>赋值运算符满足右结合律，这一点与其他二元运算符不太一样：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> ival<span class="token punctuation">,</span> jval<span class="token punctuation">,</span> <span class="token operator">*</span>pval<span class="token punctuation">;</span>
 ival <span class="token operator">=</span> jval <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//正确，相当于ival = (jval = 0);</span>
 ival <span class="token operator">=</span> pval <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//错误，相当于ival = (pval = 0);，不能把指针的值赋给int</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<p><font size="5" color="orange">递增和递减运算符</font></p>
<hr>
<ol>
<li><p>对于递增和递减运算符，其前置版本（++i）将对象本身作为左值返回，后置版本则将对象原始值的副本作为右值返回。</p>
<p> 前置版本的递增递减运算符避免了不必要的工作，它把值加1后直接返回改变了的运算对象。与之相比，后置版本需要将原始值存储下来以便于返回这个未修改的内容。如果我们不需要修改前的值，那么后置版本的操作就是一种浪费。</p>
</li>
<li>后置递增运算符的优先级高于解引用运算符，因此*pbeg++等价于*(pbeg++)。pbeg++把pbeg的值加1，然后返回pbeg的初始值的副本作为其求值结果。</li>
</ol>
<p><font size="5" color="orange">成员访问运算符</font></p>
<hr>
<ol>
<li>解引用运算符的优先级低于点运算符，所以ptr-&gt;mem等价于(*ptr).mem，而非*ptr.mem。后者会报错，因为指针没有名为mem的成员。</li>
<li>对于<code>*pval++</code>，解引用运算符的优先级低于++，所以等价于<code>*(pval++)</code>。</li>
</ol>
<p><font size="5" color="orange">条件运算符</font></p>
<hr>
<ol>
<li>&lt;&lt;运算符比一般的关系运算符、条件运算符的优先级要高（即比逻辑运算符优先级高）。所以：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> grade <span class="token operator">&lt;</span> <span class="token number">60</span> <span class="token operator">?</span> <span class="token string">"fail"</span> <span class="token operator">:</span> <span class="token string">"pass"</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//错误，试图比较cout和60</span>
 std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>grade <span class="token operator">&lt;</span> <span class="token number">60</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token string">"fail"</span> <span class="token operator">:</span> <span class="token string">"pass"</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//输出1或者0</span>
 std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>grade <span class="token operator">&lt;</span> <span class="token number">60</span> <span class="token operator">?</span> <span class="token string">"fail"</span> <span class="token operator">:</span> <span class="token string">"pass"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//输出pass或者fail</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<p><font size="5" color="orange">位运算符</font></p>
<hr>
<ol>
<li>位运算符作用于整数类型的运算对象。如果作用于类似char这种类型，会先把char类型的运算对象提升成int型。</li>
<li>由于关于符号位如何处理没有明确的规定，所以强烈建议仅将位运算符用于处理无符号类型。</li>
<li><p>左移运算符（&lt;&lt;）在右侧插入值为0的二进制位；右移运算符（&gt;&gt;）的行为则依赖于其左侧运算对象的类型，如果该运算对象是无符号类型，则在左侧插入值为0的二进制位；如果该运算符对象是带符号类型，则在左侧插入符号位的副本或值为0的二进制位，如何选择具体视环境而定。</p>
<p> 不过对于移出边界之外，两者都是直接舍弃掉。</p>
</li>
<li>移位运算符满足左结合律，所以<code>std::cout &lt;&lt; &quot;hi&quot; &lt;&lt; &quot;here&quot; &lt;&lt; std::endl</code>等价于<code>((std::cout &lt;&lt; &quot;hi&quot;) &lt;&lt; &quot;here&quot;) &lt;&lt; std::endl</code>。</li>
<li>移位运算符的优先级不高不低，介于中间：比算术运算符的优先级低，但比关系运算符、赋值运算符和条件运算符的优先级高。</li>
</ol>
<p><font size="5" color="orange">sizeof运算符</font></p>
<hr>
<ol>
<li>sizeof运算符满足右结合律，其所得的值是一个size_t类型的常量表达式，它有两种形式，都是合法的：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">sizeof</span> expr<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li>sizeof并不实际计算其运算对象的值，如：<pre class="line-numbers language-cpp"><code class="language-cpp"> CData Data<span class="token punctuation">;</span>
 <span class="token keyword">sizeof</span> Data<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//Data的类型的大小，即sizeof(CData)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li>对引用类型执行sizeof运算得到被引用对象所占空间的大小，但是对指针执行sizeof运算得到指针本身所占空间的大小。</li>
<li>对数组执行sizeof运算得到整个数组所占空间的大小，等价于对数组中所有的元素各执行一次sizeof运算并将所得结果求和。注意，sizeof运算不会把数组转换成指针来处理。</li>
<li>对string对象或vector对象执行sizeof运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间。即只计算静态数据的大小，而非对象里动态分配的数据。</li>
<li>sizeof运算的优先级低于算术运算符，但大于关系运算符等。所以<code>sizeof x + y</code>等价于<code>sizeof (x + y)</code>，<code>sizeof a &lt; b</code>等价于<code>sizeof (a) &lt; b</code>。</li>
</ol>
<p><font size="5" color="orange">逗号运算符</font></p>
<hr>
<ol>
<li>逗号运算符含有两个运算对象，按照从左向右的顺序依次求值，真正的运算结果是右侧表达式的值：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// a = 2</span>
 <span class="token keyword">int</span> b<span class="token punctuation">;</span>
 b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// b = 1</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
 逗号运算符的优先级是所有运算符中最低的，比赋值运算符还低。</li>
</ol>
<p><font size="5" color="orange">类型转换</font></p>
<ol>
<li>在大多数表达式中，比int类型小的整型值首先提升为较大的整数类型。</li>
<li>当数组被用作decltype关键字的参数，或者作为取地址符（&amp;）、sizeof及typeid等运算符的运算对象时，数组名不会被转换为指针。</li>
<li>虽然有时不得不使用强制类型转换，但这种方法本质上是非常危险的。</li>
<li>一个命名的强制类型转换具有如下形式：<pre class="line-numbers language-cpp"><code class="language-cpp"> cast<span class="token operator">-</span>name<span class="token operator">&lt;</span>type<span class="token operator">></span><span class="token punctuation">(</span>expression<span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
 type是转换的目标类型。如果type是引用类型，则结果是左值。cast-name是static_cast、dynamic_cast、const_cast和reinterpret_cast中的一种。</li>
<li>dynamic_cast支持运行时类型识别，第十九章再做详细说明。</li>
<li><p>static_cast：<br> 任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast。如：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
 <span class="token keyword">double</span> slope <span class="token operator">=</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">/</span> j<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p> 当需要把一个较大的算术类型赋值给较小的类型时，static非常有用（比如上面把double赋给int类型的i）。此时，强制类型转换告诉程序的读者和编译器，我们知道并且不在乎潜在的精度损失。一般来说，如果编译器发现一个较大的算术类型试图赋值给一个较小的类型，就会给出警告信息；但是当我们执行了显示的类型转换后，警告信息就会被关闭了。</p>
<p> static_cast对于编译器无法自动执行的类型转换也非常有用。例如，我们可以使用static_cast找回存在于void*指针中的值：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
 <span class="token keyword">void</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span>
 <span class="token keyword">int</span> <span class="token operator">*</span>ip <span class="token operator">=</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">double</span> <span class="token operator">*</span>dp <span class="token operator">=</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//dp的值不是10.0，是未定义的（本机输出是-9.25596e+61）</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p> 不过我们必须保证static_cast强制转换回原来的类型，否则将产生未定义的后果。因为由于类型不同，可能转换后的地址与原始地址不相等了，再加上由于类型大小不一样，也很可能得不到和原来相等的值。</p>
</li>
<li>const_cast：<br> const_cast只能改变运算对象的底层const。如：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
 <span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span>
 <span class="token keyword">int</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> <span class="token keyword">const_cast</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token operator">*</span>p2 <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
 std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//输出20</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
 如果对象本身不是一个常量，使用强制类型转换获得写权限是合法的行为；但是如果对象是一个常量，再使用const_cast后执行写操作将会产生未定义的后果。如下：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">const</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
 <span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span>
 <span class="token keyword">int</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> <span class="token keyword">const_cast</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token operator">*</span>p2 <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
 std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//输出10</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
 const_cast常常用于有函数重载的上下文中（第六章会有介绍），但是用于其他地方就说明有设计缺陷。</li>
<li><p>reinterpret_cast：<br> reinterpret_cast通常为运算对象的位模式提供较低层次上的重新解释。如下程序：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
 <span class="token keyword">int</span> <span class="token operator">*</span>ip <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span>
 <span class="token keyword">char</span> <span class="token operator">*</span>cp <span class="token operator">=</span> <span class="token keyword">reinterpret_cast</span><span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>ip<span class="token punctuation">)</span><span class="token punctuation">;</span>
 std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span><span class="token function">string</span><span class="token punctuation">(</span>cp<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//可能导致异常的运行时行为</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p> 我们必须牢记cp所指的真实对象是一个int而非字符，如果把cp当做普通的字符指针使用时就可能在运行时发生错误。可以看出，使用reinterpret_cast是非常危险的。</p>
<p> reinterpret_cast本质上依赖于机器，想要安全地使用reinterpret_cast必须对涉及的类型和编译器实现转换的过程都非常了解。</p>
</li>
<li>强制类型转换干扰了正常的类型检查，因此强烈建议避免使用强制类型转换，尤其是reinterpret_cast。即使是static_cast和dynamic_cast都不应该频繁使用。</li>
<li>旧式的强制类型转换形式为：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token function">type</span> <span class="token punctuation">(</span>expr<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//函数形式的强制类型转换</span>
<span class="token punctuation">(</span>type<span class="token punctuation">)</span> expr<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//C语言风格的强制类型转换</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
与命名的强制类型转换相比，旧式的强制类型转换从表现形式上来说不那么清晰明了，容易被看漏，所以一旦转换过程出现问题，追踪起来也更加困难。<br>&nbsp; </li>
</ol>
<hr>
<p>参考文献：《C++Primer第五版》</p>

            </div>

            <!-- Post Comments -->
            
    <!-- 使用 DISQUS_CLICK -->
<div id="disqus-comment">
    <div id="disqus_thread"></div>

<!-- add animation -->
<style>
	.disqus_click_btn {
            line-height: 30px;
            margin: 0;
            min-width: 50px;
            padding: 0 14px;
            display: inline-block;
            font-family: "Roboto", "Helvetica", "Arial", sans-serif;
            font-size: 14px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0;
            overflow: hidden;
            will-change: box-shadow;
            transition: box-shadow .2s cubic-bezier(.4, 0, 1, 1), background-color .2s cubic-bezier(.4, 0, .2, 1), color .2s cubic-bezier(.4, 0, .2, 1);
            outline: 0;
            cursor: pointer;
            text-decoration: none;
            text-align: center;
            vertical-align: middle;
            border: 0;
            background: rgba(158, 158, 158, .2);
            box-shadow: 0 2px 2px 0 rgba(0, 0, 0, .14), 0 3px 1px -2px rgba(0, 0, 0, .2), 0 1px 5px 0 rgba(0, 0, 0, .12);
            color: #fff;
            background-color: #7EC0EE;
            text-shadow: 0
        }
</style>
	
<div class="btn_click_load" id="disqus_bt"> 
    <button class="disqus_click_btn">点击查看评论</button>
</div>

<!--
<script type="text/javascript">
$('.btn_click_load').click(function() {
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'http-miccall-tech'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    document.getElementById('disqus_bt').style.display = "none";
});
</script>
-->
<script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://yoursite.com/2017/12/14/C++Primer第四章表达式/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = 'http://yoursite.com/2017/12/14/C++Primer第四章表达式/'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
</script>

<script type="text/javascript">
    $('.btn_click_load').click(function() {  //click to load comments
        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document;
            var s = d.createElement('script');
            s.src = '//http-miccall-tech.disqus.com/embed.js';
            s.setAttribute('data-timestamp', + new Date());
            (d.head || d.body).appendChild(s);
        })();
        $('.btn_click_load').css('display','none');
    });
</script>
</div>
<style>
    #disqus-comment{
        background-color: #eee;
        padding: 2pc;
    }
</style>


        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
                <li>Design: <a href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
            </ul>
            
            	<span id="busuanzi_container_site_pv">2018总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			
        </div>
    </div>
</body>



 	
</html>
