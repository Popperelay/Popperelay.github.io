<!DOCTYPE HTML>
<html>

<head>
	<link rel="bookmark"  type="image/x-icon"  href="/img/logo_miccall.png"/>
	 <link rel="shortcut icon" href="/img/logo_miccall.png">
	
			
    <title>
    Elays'Blog
    </title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="/css/mic_main.css" />
    <link rel="stylesheet" href="/css/dropdownMenu.css" />
    
    	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css" />
    </noscript>
			    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<link rel="stylesheet" href="/css/prism-dark.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>
    
		
<!-- Layouts -->


<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<!--<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">-->
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/latest.js?config=TeX-MML-AM_CHTML" async>
</script>

<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_undefined.css" />
<link rel="stylesheet" href="/css/typo.css" />
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">MICCALL</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special" >
            <ul class="menu links" >
			<!-- Homepage  主页  --> 
			<li >
	            <a href="/" rel="nofollow">主页</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">分类</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="/categories/Boost/">Boost</a></li><li><a class="category-link" href="/categories/C-语法/">C#语法</a></li><li><a class="category-link" href="/categories/C/">C++</a></li><li><a class="category-link" href="/categories/C语言/">C语言</a></li><li><a class="category-link" href="/categories/Math/">Math</a></li><li><a class="category-link" href="/categories/OpenGL/">OpenGL</a></li><li><a class="category-link" href="/categories/c/">c++</a></li><li><a class="category-link" href="/categories/全局光照/">全局光照</a></li><li><a class="category-link" href="/categories/博客配置/">博客配置</a></li><li><a class="category-link" href="/categories/并行计算/">并行计算</a></li><li><a class="category-link" href="/categories/操作系统/">操作系统</a></li><li><a class="category-link" href="/categories/数据结构/">数据结构</a></li><li><a class="category-link" href="/categories/毕设/">毕设</a></li><li><a class="category-link" href="/categories/游戏开发/">游戏开发</a></li><li><a class="category-link" href="/categories/游戏设计模式/">游戏设计模式</a></li><li><a class="category-link" href="/categories/计算机图形学/">计算机图形学</a></li><li><a class="category-link" href="/categories/计算机系统/">计算机系统</a></li><li><a class="category-link" href="/categories/设计模式/">设计模式</a></li><li><a class="category-link" href="/categories/调试错误集锦/">调试错误集锦</a></li><li><a class="category-link" href="/categories/面经/">面经</a>
	                    </ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/gallery/" title="图库">
		                图库
		            </a>
		        </li>
		        
		        <li>
		            <a href="/tag/" title="搜索">
		                搜索
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
		            
		                <li><a href="https://github.com/miccall" class="icon fa-github"><span class="label">GitHub</span></a></li>
		            
		            
		            
		            
			</ul>
</nav>

        <div id="main" >
            <div class ="post_page_title_img" style="height: 25rem;background-image: url(http://oqcvzqam1.bkt.clouddn.com/C++Primer%E7%AC%AC3%E7%AB%A0.jpg);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;" >
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2 >C++Primer第三章 字符串、向量和数组</h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
				<!-- 目录 -->
				<p class="show-toc-btn" id="show-toc-btn" onclick="showToc();" style="display:none">
				<span class="btn-bg"></span>
				<span class="btn-text">文章导航</span>
				</p>
				<div id="toc-article" class="toc-article">
					<span id="toc-close" class="toc-close" title="隐藏导航" onclick="showBtn();">×</span>
					<strong class="toc-title">文章目录</strong>
					
			   </div>
			   <script type="text/javascript">
				function showToc(){
					var toc_article = document.getElementById("toc-article");
					var show_toc_btn = document.getElementById("show-toc-btn");
					toc_article.setAttribute("style","display:block");
					show_toc_btn.setAttribute("style","display:none");
					};
				function showBtn(){
					var toc_article = document.getElementById("toc-article");
					var show_toc_btn = document.getElementById("show-toc-btn");
					toc_article.setAttribute("style","display:none");
					show_toc_btn.setAttribute("style","display:block");
					};
			   </script>
				
                <p><font size="5" color="orange">命名空间的using声明</font><br><a id="more"></a></p>
<hr>
<ol>
<li><p>比如我们需要在程序中用cin时，可以用using声明可以从命名空间std中获取它：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>

 <span class="token keyword">using</span> std<span class="token operator">::</span>cin<span class="token punctuation">;</span>

 <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
     <span class="token keyword">int</span> i<span class="token punctuation">;</span>
     cin <span class="token operator">>></span> i<span class="token punctuation">;</span>
     std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> i<span class="token punctuation">;</span>

     <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>头文件里不应该包含using声明。因为头文件的内容会被拷贝到所有引用它的文件中去，如果头文件里有某个using声明，那么每个使用了该头文件的文件就都会有这个声明，对于某些程序来说，由于不经意间包含了一些名字，反而可能会产生始料未及的名字冲突。</li>
</ol>
<p><font size="5" color="orange">标准库类型string</font></p>
<hr>
<ol>
<li>C++标准库在实现时已经考虑到了性能需求，所以标准库类型对于一般应用场合来说有足够的效率。</li>
<li>编译器虽然会给字符串字面值自动添加空字符，但是把这个字符串字面值赋给string对象时，却不会把空字符也赋值过去：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>string <span class="token function">str</span><span class="token punctuation">(</span><span class="token string">"Lova"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> str<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//输出4，其中str[4]是未定义的，并不是空字符</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li>虽然如下两种对string对象赋值的结果是一样的：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>string <span class="token function">s1</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//直接初始化</span>
 std<span class="token operator">::</span>string s2 <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//拷贝初始化</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
 但是，使用等号初始化一个变量，实际上执行的是拷贝初始化，编译器把等号右侧的初始值拷贝到新创建的对象中去。与之相反，如果不使用等号，则执行的是直接初始化。</li>
<li>用cin执行读取操作时，string对象会自动忽略开头的空白（即空格符、换行符、制表符等）并从第一个真正的字符开始读起，直到遇见下一处空白为止。如下程序：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>string s1<span class="token punctuation">,</span> s2<span class="token punctuation">;</span>
 std<span class="token operator">::</span>cin <span class="token operator">>></span> s1 <span class="token operator">>></span> s2<span class="token punctuation">;</span>
 std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> s1 <span class="token operator">&lt;&lt;</span> s2 <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
 如果输入“&nbsp;&nbsp;&nbsp; &nbsp;      Hello World  &nbsp;&nbsp; &nbsp;&nbsp;   ”，则输出是“HelloWorld”。</li>
<li><p>有时我们希望能在最终得到的字符串中保留输入时的空白符，这时应该用getline函数代替原来的&gt;&gt;运算符。如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>string line<span class="token punctuation">;</span>
 <span class="token function">getline</span><span class="token punctuation">(</span>std<span class="token operator">::</span>cin<span class="token punctuation">,</span> line<span class="token punctuation">)</span><span class="token punctuation">;</span>
 std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> line <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>  如果输入“&nbsp;&nbsp;&nbsp; &nbsp;      Hello World  &nbsp;&nbsp; &nbsp;&nbsp;   ”，则输出也是“&nbsp;&nbsp;&nbsp; &nbsp;      Hello World  &nbsp;&nbsp; &nbsp;&nbsp;   ”。</p>
<p> getline函数会从给定的输入流中读入内容，直到遇到换行符为止（注意换行符也被读进来了），然后把所读的内容存入到那个string对象中去（注意不存换行符）。</p>
<blockquote>
<p>触发getline函数返回的那个换行符实际上被丢弃了，得到的string对象中并不包含该换行符。</p>
</blockquote>
</li>
<li><p>如下程序：</p>
<pre class="line-numbers language-c++"><code class="language-c++"> std::string str("Hello");
 auto len = str.size();
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p> 其中size函数返回的是一个string::size_type类型的值。</p>
<p> string类及其他大多数标准库类型都定义了几种配套的类型，这些配套类型体现了标准库类型与机器无关的特性，类型size_type即是其中的一种。它是一种无符号整型值，而且能够存放下任何string对象的大小。</p>
<p> 由于size函数返回的是无符号整型，所以需要注意表达式中不要再使用int这种有符号整型了，否则可能会因为混用有符号和无符号数而产生意想不到的bug。</p>
</li>
<li>因为某些历史原因，也为了与C兼容，所以C++语言中的字符串字面值并不是标准库类型string的对象。切记，字符串字面值与string是不同的类型。</li>
<li>可以把string对象和字符串字面值相加，但不能直接把两个字符串字面值相加（因为这两个字符串字面值都不是string对象，无法使用string类中才重载的字符串相加运算符）。</li>
<li>在cctype头文件中定义了一组标准库函数可以用来处理字符：</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">isalnum(c)</td>
<td>当c是字母或数字时为真</td>
</tr>
<tr>
<td style="text-align:center">isalpha(c)</td>
<td>当c是字母时为真</td>
</tr>
<tr>
<td style="text-align:center">iscntrl(c)</td>
<td>当c是控制字符时为真</td>
</tr>
<tr>
<td style="text-align:center">isdigit(c)</td>
<td>当c是数字时为真</td>
</tr>
<tr>
<td style="text-align:center">isgraph(c)</td>
<td>当c不是空格但可以打印时为真</td>
</tr>
<tr>
<td style="text-align:center">islower(c)</td>
<td>当c是小写字母时为真</td>
</tr>
<tr>
<td style="text-align:center">isprint(c)</td>
<td>当c是可打印字符时为真（即c是空格或c具有可视形式）</td>
</tr>
<tr>
<td style="text-align:center">ispunct(c)</td>
<td>当c是标点符号时为真（即c不是控制字符、数字、字母、可打印空白中的一种）</td>
</tr>
<tr>
<td style="text-align:center">isspace(c)</td>
<td>当c是空白时为真（即c是空格、制表符、回车符、换行符、进纸符的一种）</td>
</tr>
<tr>
<td style="text-align:center">issupper(c)</td>
<td>当c是大写字母时为真</td>
</tr>
<tr>
<td style="text-align:center">isxdigit(c)</td>
<td>当c是十六进制数字时为真</td>
</tr>
<tr>
<td style="text-align:center">tolower(c)</td>
<td>如果c是大写字母，输出对应的小写字母；否则原样输出</td>
</tr>
<tr>
<td style="text-align:center">tosupper(c)</td>
<td>如果c是小写字母，输出对应的大写字母；否则原样输出</td>
</tr>
</tbody>
</table>
<ol>
<li><p>范围for语句：<br>  范围for语句遍历给定序列中的每个元素并对序列中的每个值执行某种操作，其语法形式是：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">for</span><span class="token punctuation">(</span>declaration <span class="token operator">:</span> expression<span class="token punctuation">)</span>
    statement
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>每次迭代，declaration部分的变量会被初始化为expression部分的下一个元素值。如下代码是统计给定字符串中标点符号的个数：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>string <span class="token function">s</span><span class="token punctuation">(</span><span class="token string">"this elay's blog!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> NumPunct <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> c <span class="token operator">:</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">ispunct</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">//记得添加cctype头文件</span>
        NumPunct<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> NumPunct <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果想要改变string对象中字符的值，必须把循环变量（上面的代码里是c）定义成引用类型。</p>
</li>
<li>string对象的下标运算符[ ]接收的输入参数是string::size_type类型的值，这个参数表示要访问的字符的位置；返回值是该位置上字符的引用。如果某个下标索引是带符号类型的值，讲自动转换成由string::size_type表达的无符号类型。使用下标时必须确定其大于等于0，而且小于字符串的size()的值。一种简便的方法是：总是设下标的类型为string::size_type类型，因为它是无符号类型，可以确保下标不会小于0，然后只需要再保证下标小于size()的值就可以了。</li>
</ol>
<p><font size="5" color="orange">标准库类型vector</font></p>
<hr>
<ol>
<li>标准库类型vector表示对象的集合，其中所有对象的类型都相同。</li>
<li>vector是模板而非类型，由vector生成的类型必须带尖括号声明元素的具体类型，如vector<int>。</int></li>
<li>vector能容纳绝大多数类型的对象作为其元素，但是因为引用不是对象。所以不存在包含引用的vector。</li>
<li>在早期的C++标准中，声明双重vector，需要在外层vector对象的右尖括号和其元素类型之间添加一个空格，即：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">></span> Array<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
 不过在C++11标准中，这个空格不是必须的了。</li>
<li>类似数组，C++11还提供了使用列表初始化vector的方式：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> V1 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//列表初始化</span>
 std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> V2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//错误，应该使用花括号</span>
 std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">V3</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//V3里有10个int类型的元素，每个都被初始化为0</span>
 std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> V4<span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//V4里有2个int类型的元素，值分别是10和0</span>
 std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">V5</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//V5里有10个int类型的元素，初始值都是0</span>
 std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> V6<span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">}</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//V6里有1个int类型的元素，初始值是10</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
 在初始化时，如果用的是圆括号，可以说提供的值是用来构造vector对象的；如果用的是花括号，就是用列表初始化该vector对象的。</li>
<li>其实vector对象能够高效增长，不需要在初始化时指定其大小，初始化时设定其大小可能性能反而不好，更有效的办法是先定义一个空的vector对象，再在运行时向其中添加具体值。</li>
<li>和string类似，vector也支持&lt;，&gt;等关系运算符，也是按字典顺序进行比较的，而且V1[n]也是返回V1中第n个元素的引用。</li>
<li>对于vector，要使用size_type（vector的下标的类型是size_type），需要先指定具体的vector类型：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>vector<span class="token operator">::</span>size_type        <span class="token comment" spellcheck="true">//错误</span>
 std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>size_type <span class="token comment" spellcheck="true">//正确</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
</ol>
<p><font size="5" color="orange">迭代器介绍</font></p>
<hr>
<ol>
<li>所有标准库容器都可以使用迭代器，但是其中只有少数几种才同时支持下标运算符。</li>
<li><p>像string、vector这种有迭代器的类型都拥有begin和end成员函数：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> v<span class="token punctuation">;</span>
 <span class="token keyword">auto</span> b <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> e <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p> 其中，begin函数返回指向第一个元素的迭代器；end函数返回指向容器“尾元素的下一位置”的迭代器，也就是说该迭代器指向的是容器的一个本不存在的“尾后”元素，没有什么实际含义，仅是个标记而已，表示我们已经处理完了容器中的所有元素，所以通常被称为尾后迭代器，或简称尾迭代器。</p>
<p> 如果容器为空，则begin和end返回的是同一个迭代器，都是尾后迭代器。</p>
<p>由于end返回的迭代器并不指示某个元素，所以不能对其进行递增或解引用的操作。如下代码：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>string <span class="token function">s</span><span class="token punctuation">(</span><span class="token string">"some string"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>s<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
 std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>s<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//非法，不能对尾后迭代器解引用</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li>通常我们不需要care迭代器的具体类型到底是什么，一个auto就足够了。</li>
<li>迭代器的访问方法类似指针，如<code>*iter</code>表示迭代器iter指向的元素的引用，<code>iter-&gt;mem</code>表示迭代器iter指向的对象中名为mem的成员。</li>
<li>我们通常不知道，也无须知道迭代器的精准类型，用auto就可以了。其实，迭代器的类型是iterator和const_iterator，如下：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>iterator it<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//it能读写vector&lt;int>中的元素</span>
 std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>const_iterator it2<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//it2只能读vector&lt;int>中的元素，不能写</span>
 std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> v<span class="token punctuation">;</span>
 <span class="token keyword">const</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> cv<span class="token punctuation">;</span>
 <span class="token keyword">auto</span> it3 <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">//it3的类型是vector&lt;int>::iterator</span>
 <span class="token keyword">auto</span> it4 <span class="token operator">=</span> cv<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment" spellcheck="true">//it4的类型是vector&lt;int>::const_iterator</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
 为了便于专门得到const_iterator类型的返回值，C++11引入了两个新函数，分别是cbegin和cend：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">auto</span> it5 <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment" spellcheck="true">//it5的类型是vector&lt;int>::const_iterator</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
 其中即使vector对象（或string对象）不是常量，这两个函数返回值也都是const_iterator。</li>
<li>C++语言的箭头运算符（<code>-&gt;</code>）实际上是把解引用和成员访问两个操作结合在一起，也就是说，<code>it-&gt;mem</code>和<code>(*it).mem</code>表达的意思相同。</li>
<li>谨记，但凡是使用的迭代器的循环体，都不要向迭代器所属的容器添加元素，因为这样会使迭代器失效的。</li>
<li>两个迭代器的距离，在C++中用类型difference_type来表示，它是带符号整型数（因为两个迭代器之间的距离是可正可负的）。</li>
</ol>
<p><font size="5" color="orange">数组</font></p>
<hr>
<ol>
<li>如果不清楚元素的个数，请使用vector，而非数组。</li>
<li>定义数组的时候必须指定数组的类型，不允许使用auto关键字由初始值的列表推断类型，这一点与vector不同。如下：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> v <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//合法</span>
 <span class="token keyword">auto</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">//非法</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li>使用列表初始化数组时，不够的元素一定会被默认初始化，无论是不是函数的局部变量。如下：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
 <span class="token keyword">int</span> b<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
 std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//a中的元素是未定义的</span>
 std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//b中的元素被默认初始化为0</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>想要理解数组声明的含义，最好的办法是从数组的名字开始，从内向外、从右向左的顺序阅读。如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> <span class="token operator">*</span>ptrs<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//ptrs是含有10个整型指针的数组，是指针数组</span>
 <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>pArray<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//pArray指向含有10个整型的数组，是数组指针</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p> 从右向左，ptrs右边是[10]，所以定义的是一个大小为10的数组，数组名称是ptrs；ptrs左边是int*，即数组中的所有元素都是int型指针，所以ptrs是含有10个整型指针的数组的名称，是10个指针构成的数组。</p>
<p>先从内向外，在括号内部，pArray右边没有东西，左边是*，所以知道pArray是一个指针，然后从右向左，（*pArray）右边是[10]，所以（*pArray）是一个大小为10的数组的名称，（*pArray）右边是int，说明数组中的所有元素都是int型，所以pArray是一个指向整型数组的指针。</p>
<p> 所以，对于如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arry<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> ptrs<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//arry是数组的引用，该数组含有10个整型指针</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p> 从内向外，可以知道arry是一个引用，然后从右至左，在(&amp;arry)右边是[10]，所以(&amp;arry)是一个大小为10的数组的名称，在(&amp;arry)左边是int*，即数组中的每个元素是int型指针，所以arry是在引用一个大小为10的整型指针数组。</p>
</li>
<li>在使用数组下标时，通常将其定义为<strong>size_t</strong>类型，它是一种机器相关的无符号类型，它被设计得足够大以便能表示内存中任意对象的大小。在cstddef头文件中定义了size_t类型，这个文件是C标准库stddef.h头文件的C++版本。</li>
<li><p>使用auto时，用数组名作初始值推断出来的变量类型是指针；而使用decltype时，用数组名作初始值推断出来的变量类型依然是数组：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> Array<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
 <span class="token keyword">auto</span> pArray2 <span class="token operator">=</span> Array<span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">//pArray2是一个整型指针，指向Array的第一个元素</span>

 <span class="token keyword">decltype</span><span class="token punctuation">(</span>Array<span class="token punctuation">)</span> Array3 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//Array3含有4个整数的数组</span>
 Array3<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
 <span class="token keyword">decltype</span><span class="token punctuation">(</span>Array<span class="token punctuation">)</span> Array4 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//错误，Array4必须是含有4个整数的数组</span>
 <span class="token keyword">decltype</span><span class="token punctuation">(</span>Array<span class="token punctuation">)</span> Array4 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//正确</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用auto时，编译器实际上作了类似如下的转化：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">auto</span> pArray2 <span class="token operator">=</span> <span class="token operator">&amp;</span>Array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>而在使用decltype时并没有发生这种转化，所以推断出来的依然是数组类型。值得注意的是推断出来的4个整型的数组类型，就不能给把数量比它多的初始化列表赋给它，但是可以把数量比它少的初始化列表赋给它，因为不够的元素默认被初始化为0了。</p>
</li>
<li>为了得到数组的首指针和尾后指针，C++11也为数组定义了begin和end函数，与vector这种容器不同的是，作用与数组的begin和end函数并非是其成员函数，而且返回值也是指针类型，而非迭代器类型。<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> Array<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
 <span class="token keyword">int</span> <span class="token operator">*</span>beg <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">begin</span><span class="token punctuation">(</span>Array<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li>再次特别注意，尾后指针不能执行解引用和递增操作，不过可以获取其地址（即指针存储的值）。</li>
<li>两个指针相减的结果的类型是一种名为ptrdiff_t的标准库类型。和size_t一样，ptrdiff_t也是一种定义在cstddef头文件中的机器相关的带符号类型。</li>
<li>标准库类型（如string、vector等等）限定使用的下标必须是无符号类型，而内置的下标运算无此要求。如下：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> Array<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>Array<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> j <span class="token operator">=</span> p<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//p[-2]是Array[0]表示的那个元素</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li>用char*定义的字符数组就是C风格的字符串，如下：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">char</span> cs<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"This is a C string."</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
尽管C++支持C风格字符串，但在C++程序中最好还是不要使用它们。这是因为C风格字符串不仅使用起来不太方便，而且还极易引发程序漏洞，是诸多安全问题的根本原因。<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">char</span> cs1<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token string">'C'</span><span class="token punctuation">,</span><span class="token string">'+'</span><span class="token punctuation">,</span><span class="token string">'+'</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//末尾没有空字符</span>
<span class="token keyword">const</span> <span class="token keyword">char</span> cs2<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"This is a C string."</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//末尾有空字符</span>
std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">strlen</span><span class="token punctuation">(</span>cs1<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//错误，cs1没有以空字符结束，输出的可能不是3</span>
std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">strlen</span><span class="token punctuation">(</span>cs2<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//正确</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
对大多数应用来说，使用标准库string要比使用C风格字符串更安全、高效。</li>
<li>允许使用以空字符结束的字符数组来初始化string对象或为string对象赋值，但是不能用string对象直接初始化指向字符的指针：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">char</span> cs1<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token string">'C'</span><span class="token punctuation">,</span><span class="token string">'+'</span><span class="token punctuation">,</span><span class="token string">'+'</span><span class="token punctuation">,</span><span class="token string">'\0'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
std<span class="token operator">::</span>string s1 <span class="token operator">=</span> cs1<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//正确                  </span>
<span class="token keyword">char</span> <span class="token operator">*</span>cs2 <span class="token operator">=</span> s1<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//错误，不能用string对象初始化char*指针</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
为了完成该功能，string专门提供了一个名为c_str的成员函数：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>cs2 <span class="token operator">=</span> s1<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//正确</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
顾名思义，c_str函数的返回值是一个C风格的字符串指针，结果指针的类型是const char*。由于返回的实际上是指向字符串s1的指针，所以当s1的内容改变时，cs2的内容也会随之改变。</li>
<li>不允许使用vector对象初始化数组，但是允许使用数组来初始化vector对象，只需要在初始化时指明待拷贝区域的首地址和尾后地址就可以了：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> Array<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">ivec</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">begin</span><span class="token punctuation">(</span>Array<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> std<span class="token operator">::</span><span class="token function">end</span><span class="token punctuation">(</span>Array<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//ivec的内容是2,3,4</span>
std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">ivec2</span><span class="token punctuation">(</span>Array <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> Array <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                       <span class="token comment" spellcheck="true">//ivec2的内容是2,3</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
注意第二个参数是待拷贝区域的尾后地址，所以ivec的内容是2、3、4，而不是2、3、4、5。</li>
<li>现代C++程序应当尽量使用vector和迭代器，避免使用内置数组和指针；应该尽量使用string，避免使用C风格的基于数组的字符串。</li>
</ol>
<p><font size="5" color="orange">多维数组</font></p>
<hr>
<ol>
<li>严格来说，C++没有多维数组，通常所说的多维数组其实是数组的数组。谨记！如下：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> Array<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//大小为3的数组，每个元素是含有4个整数的数组</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
 按照由内而外、由左至右的顺序阅读多维数组的定义有助于更好地理解其真实含义。</li>
<li>多维数组初始化：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> Array<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token operator">=</span>
 <span class="token punctuation">{</span>
     <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
     <span class="token punctuation">{</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
     <span class="token punctuation">{</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">}</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
 其中内层嵌套的花括号并非必需的，但是如果内层花括号中元素个数不够时，会执行默认初始化，这时有没有花括号还是有很大区别的：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> Array<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token number">8</span><span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
 <span class="token keyword">int</span> Array2<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">0</span> <span class="token punctuation">,</span> <span class="token number">4</span> <span class="token punctuation">,</span> <span class="token number">8</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
 此时的Array和Array2内容是不一样的，Array是每一行不足的用0进行默认初始化，而Array2是前三个元素分别是0、4、8，但是后面的元素都是默认初始化为0。</li>
<li><p>要使用范围for语句处理多维数组时，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型。这时最内层获取到的变量是只读的，如果要可写的话，还需要给最内层循环的控制变量加上引用。如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> Array<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
 size_t cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
 <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>row <span class="token operator">:</span> Array<span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
     <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>col <span class="token operator">:</span> row<span class="token punctuation">)</span>
     <span class="token punctuation">{</span>
         col <span class="token operator">=</span> cnt<span class="token punctuation">;</span>
         <span class="token operator">++</span>cnt<span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 上面的代码是正确的，但是下面这样就不合法了：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> Array<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
 size_t cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
 <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> row <span class="token operator">:</span> Array<span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
     <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>col <span class="token operator">:</span> row<span class="token punctuation">)</span>
     <span class="token punctuation">{</span>
         col <span class="token operator">=</span> cnt<span class="token punctuation">;</span>
         <span class="token operator">++</span>cnt<span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 因为row不是引用类型，所以编译器初始化row时会自动将这些数组形式的元素（谨记多维数组实际上是数组的数组）转换成指向该数组内首元素的指针。这样得到的row的类型就是int*，显然内层的循环就不合法了，因为编译器将试图在一个int*内进行遍历，显然和程序的初衷相去甚远。</p>
<p> 所以，谨记没有使用引用的数组名都是会被自动转换为指针的。</p>
</li>
<li>因为多维数组实际上是数组的数组，所以由多维数组名转换得来的指针实际上是指向第一个内层数组的指针。如下代码：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> Array<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
 <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> Array<span class="token punctuation">;</span>
 p <span class="token operator">=</span> <span class="token operator">&amp;</span>Array<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
 通过p的声明形式可以知道，p是一个指针，指向含有4整数的数组，而数组名Array也是指向第一个内层数组的指针，所以第二句代码是合法的。由于Array[2]表示Array的第三个元素，这个元素是一个含有4个整数的数组，所以对Array[2]取地址，再赋给p也是合法的。<br> &nbsp; </li>
</ol>
<hr>
<p>参考文献：《C++Primer第五版》</p>

            </div>

            <!-- Post Comments -->
            
    <!-- 使用 DISQUS_CLICK -->
<div id="disqus-comment">
    <div id="disqus_thread"></div>

<!-- add animation -->
<style>
	.disqus_click_btn {
            line-height: 30px;
            margin: 0;
            min-width: 50px;
            padding: 0 14px;
            display: inline-block;
            font-family: "Roboto", "Helvetica", "Arial", sans-serif;
            font-size: 14px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0;
            overflow: hidden;
            will-change: box-shadow;
            transition: box-shadow .2s cubic-bezier(.4, 0, 1, 1), background-color .2s cubic-bezier(.4, 0, .2, 1), color .2s cubic-bezier(.4, 0, .2, 1);
            outline: 0;
            cursor: pointer;
            text-decoration: none;
            text-align: center;
            vertical-align: middle;
            border: 0;
            background: rgba(158, 158, 158, .2);
            box-shadow: 0 2px 2px 0 rgba(0, 0, 0, .14), 0 3px 1px -2px rgba(0, 0, 0, .2), 0 1px 5px 0 rgba(0, 0, 0, .12);
            color: #fff;
            background-color: #7EC0EE;
            text-shadow: 0
        }
</style>
	
<div class="btn_click_load" id="disqus_bt"> 
    <button class="disqus_click_btn">点击查看评论</button>
</div>

<!--
<script type="text/javascript">
$('.btn_click_load').click(function() {
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'http-miccall-tech'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    document.getElementById('disqus_bt').style.display = "none";
});
</script>
-->
<script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://yoursite.com/2017/12/12/C++Primer第三章字符串向量和数组/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = 'http://yoursite.com/2017/12/12/C++Primer第三章字符串向量和数组/'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
</script>

<script type="text/javascript">
    $('.btn_click_load').click(function() {  //click to load comments
        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document;
            var s = d.createElement('script');
            s.src = '//http-miccall-tech.disqus.com/embed.js';
            s.setAttribute('data-timestamp', + new Date());
            (d.head || d.body).appendChild(s);
        })();
        $('.btn_click_load').css('display','none');
    });
</script>
</div>
<style>
    #disqus-comment{
        background-color: #eee;
        padding: 2pc;
    }
</style>


        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
                <li>Design: <a href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
            </ul>
            
            	<span id="busuanzi_container_site_pv">2019总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			
        </div>
    </div>
</body>



 	
</html>
