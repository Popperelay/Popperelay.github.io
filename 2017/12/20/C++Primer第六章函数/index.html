<!DOCTYPE HTML>
<html>

<head><meta name="generator" content="Hexo 3.9.0">
	<link rel="bookmark" type="image/x-icon" href="/img/logo_miccall.png">
	 <link rel="shortcut icon" href="/img/logo_miccall.png">
	
			
    <title>
    Elays'Blog
    </title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
	<script>
	(function(){
		if('{{ page.password }}'){
			if (prompt('请输入文章密码') !== "aaa"){
				alert('密码错误！');
				history.back();
			}
		}
	})();
	</script>
    <link rel="stylesheet" href="/css/mic_main.css">
    <link rel="stylesheet" href="/css/dropdownMenu.css">
    
    	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css">
    </noscript>
			    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<link rel="stylesheet" href="/css/prism-dark.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>
    
		
<!-- Layouts -->


<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<!--<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">-->
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/latest.js?config=TeX-MML-AM_CHTML">
</script>

<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_undefined.css">
<link rel="stylesheet" href="/css/typo.css">
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">MICCALL</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special">
            <ul class="menu links">
			<!-- Homepage  主页  --> 
			<li>
	            <a href="/" rel="nofollow">主页</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">分类</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="/categories/C/">C#</a></li><li><a class="category-link" href="/categories/C-语法/">C#语法</a></li><li><a class="category-link" href="/categories/C/">C++</a></li><li><a class="category-link" href="/categories/C语言/">C语言</a></li><li><a class="category-link" href="/categories/Graphics/">Graphics</a></li><li><a class="category-link" href="/categories/Math/">Math</a></li><li><a class="category-link" href="/categories/OpenGL/">OpenGL</a></li><li><a class="category-link" href="/categories/Unity/">Unity</a></li><li><a class="category-link" href="/categories/博客配置/">博客配置</a></li><li><a class="category-link" href="/categories/并行计算/">并行计算</a></li><li><a class="category-link" href="/categories/操作系统/">操作系统</a></li><li><a class="category-link" href="/categories/数据结构/">数据结构</a></li><li><a class="category-link" href="/categories/毕设/">毕设</a></li><li><a class="category-link" href="/categories/游戏开发/">游戏开发</a></li><li><a class="category-link" href="/categories/计算机系统/">计算机系统</a></li><li><a class="category-link" href="/categories/设计模式/">设计模式</a></li><li><a class="category-link" href="/categories/面试/">面试</a>
	                    </li></ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/gallery/" title="图库">
		                图库
		            </a>
		        </li>
		        
		        <li>
		            <a href="/tag/" title="搜索">
		                搜索
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
		            
		                <li><a href="https://github.com/miccall" class="icon fa-github"><span class="label">GitHub</span></a></li>
		            
		            
		            
		            
			</ul>
</nav>

        <div id="main">
            <div class="post_page_title_img" style="height: 25rem;background-image: url(https://github.com/Popperelay/Photos/blob/master/Photos/C++Primer%E7%AC%AC6%E7%AB%A0.jpg?raw=true);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;">
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2>C++Primer第六章 函数</h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
				<!-- 目录 -->
				<p class="show-toc-btn" id="show-toc-btn" onclick="showToc();" style="display:none">
				<span class="btn-bg"></span>
				<span class="btn-text">文章导航</span>
				</p>
				<div id="toc-article" class="toc-article">
					<span id="toc-close" class="toc-close" title="隐藏导航" onclick="showBtn();">×</span>
					<strong class="toc-title">文章目录</strong>
					
			   </div>
			   <script type="text/javascript">
				function showToc(){
					var toc_article = document.getElementById("toc-article");
					var show_toc_btn = document.getElementById("show-toc-btn");
					toc_article.setAttribute("style","display:block");
					show_toc_btn.setAttribute("style","display:none");
					};
				function showBtn(){
					var toc_article = document.getElementById("toc-article");
					var show_toc_btn = document.getElementById("show-toc-btn");
					toc_article.setAttribute("style","display:none");
					show_toc_btn.setAttribute("style","display:block");
					};
			   </script>
				
                <p><font size="5" color="orange">函数基础</font><br><a id="more"></a></p>
<hr>
<ol>
<li>用void作形参是C语言风格。</li>
<li>局部静态变量会被默认初始化。</li>
<li>如果我们修改了项目中的一个源文件，那么只需要重新编译那个改动了的文件。大多数编译器提供了分离式编译每个文件的机制，这一过程通常会产生一个后缀名是.obj（Windows）或.o（UNIX）的文件，后缀名的含义是该文件包含对象代码（object code）。</li>
</ol>
<p><font size="5" color="orange">参数传递</font></p>
<hr>
<ol>
<li>在C++语言中，建议使用引用类型的形参替代指针。</li>
<li>和其他初始化过程一样，当用实参初始化形参时会忽略掉形参的顶层const。即对于函数<code>void fcn(const int i){}</code>，传入的形参既能是const int，也能是int。</li>
<li><p>因为不能拷贝数组，所以我们无法以值传递的方式使用数组参数。因为数组会被转换成指针，所以当我们为函数传递一个数组时，实际上传递的是指向数组首元素的指针。</p>
<p> 如果确实像传递数组作为参数怎么办呢？有以下几种方案：</p>
<ul>
<li>在数组末尾指定一个特殊标记表示数组结束。如C风格字符串在末尾会有一个空字符’\0’，则可以按照如下方式处理C风格字符数组：<pre class="line-numbers language-cpp"><code class="language-cpp">  <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>vCP<span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>vCP<span class="token punctuation">)</span>
          <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">*</span>vCP<span class="token punctuation">)</span>
              std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>vCP<span class="token operator">++</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>传递数组的首元素指针和尾后指针：<pre class="line-numbers language-cpp"><code class="language-cpp">  <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>vBeg<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>vEnd<span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
      <span class="token keyword">while</span> <span class="token punctuation">(</span>vBeg <span class="token operator">!=</span> vEnd<span class="token punctuation">)</span>
          std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>vBeg<span class="token operator">++</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>额外传递一个表示数组大小的参数：<pre class="line-numbers language-cpp"><code class="language-cpp">  <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>vCP<span class="token punctuation">,</span> <span class="token keyword">int</span> vSize<span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">!=</span> vSize<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
          std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> vCP<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>用数组的引用作为形参：<pre class="line-numbers language-cpp"><code class="language-cpp">  <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>vArr<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> Elem <span class="token operator">:</span> vArr<span class="token punctuation">)</span>
          std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> Elem<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
这种方式虽然可以直接传递数组，但是缺点也很明显：数组大小是固定的。在后面第十六章会介绍怎样让它可以作用与任意大小数组的方式。</li>
</ul>
</li>
<li><p>数组实际上是数组的数组，所以传递多维数组作为参数的形式如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span>vMatrix<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> vRowSize<span class="token punctuation">,</span> <span class="token keyword">int</span> vColSize<span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
     <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> vRowSize<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
     <span class="token punctuation">{</span>
         <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> vColSize<span class="token punctuation">;</span> <span class="token operator">++</span>k<span class="token punctuation">)</span>
             std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> vMatrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
         std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>

 <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
     <span class="token keyword">int</span> Arr<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span>
     <span class="token punctuation">{</span>
         <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span>
         <span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span>
         <span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span>
         <span class="token number">10</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token number">12</span>
     <span class="token punctuation">}</span><span class="token punctuation">;</span>
     <span class="token function">print</span><span class="token punctuation">(</span>Arr<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

     <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>有形参的main函数形式如下：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
 第二个形参argv是一个数组，它的元素是指向C风格字符串的指针；第一个形参argv表示数组中字符串的数量。<br> 因为第二个形参是数组，所以main函数也可以是如下形式：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
 其中argv指向char*。<br> 当实参传给main函数之后，argv的第一个元素指向程序的名字或者一个空字符串，接下来的元素依次传递命令行提供的实参。最后一个指针之后的元素值保证为0。以下面的命令行为例：<pre class="line-numbers language-cpp"><code class="language-cpp"> prog <span class="token operator">-</span>d <span class="token operator">-</span>o ofile data0
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
 命令行提供的实参传入main函数之后，形参argc应该等于5，argv应该包含如下C风格字符串：<pre class="line-numbers language-cpp"><code class="language-cpp"> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"prog"</span><span class="token punctuation">;</span>
 argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"-d"</span><span class="token punctuation">;</span>
 argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"-o"</span><span class="token punctuation">;</span>
 argv<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"ofile"</span><span class="token punctuation">;</span>
 argv<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"data0"</span><span class="token punctuation">;</span>
 argv<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
 当使用argv中的实参时，一定要记得可选的实参从argv[1]开始，argv[0]保存程序的名字，而非用户输入。</li>
<li><p>为了编写能处理不同数量实参的函数，C++11新标准提供了两种主要的方法：如果所有的实参类型相同，可以传递一个名为initializer_list的标准库类型；如果实参的类型不同，我们可以编写一种特殊的函数，也就是所谓的可变参数模板，这在第16章会有详细介绍。</p>
<p> initializer_list用于表示某种特定类型的值的数组，定义在同名的头文件中。和vector类似，它也是一种模板类型；和vector不一样的是，initializer_list对象中的元素永远是常量值，所以我们无法修改initializer_list对象中元素的值。实例代码如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">void</span> <span class="token function">Msg</span><span class="token punctuation">(</span>std<span class="token operator">::</span>initializer_list<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> vIL<span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
     <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span> <span class="token operator">&amp;</span>Elem <span class="token operator">:</span> vIL<span class="token punctuation">)</span>
         std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> Elem <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
     std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>

 <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
     <span class="token function">Msg</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token string">"function"</span><span class="token punctuation">,</span><span class="token string">"okay"</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 可以看到，如果想向initializer_list形参中传递一个值的序列，则必须把序列放在一对花括号内。而且因为initializer_list由begin和end成员，所以可以使用范围for循环访问其中的元素。</p>
</li>
</ol>
<p><font size="5" color="orange">返回类型和return语句</font></p>
<hr>
<ol>
<li>不要返回局部对象的引用或指针。因为函数终止意味着局部变量的引用或指针将指向不再有效的区域，值将是未定义的（不可预知的任意值）。</li>
<li>C++11新标准规定，函数可以返回花括号包围的值的列表：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> <span class="token function">getInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
     <span class="token keyword">return</span><span class="token punctuation">{</span> <span class="token string">"function"</span><span class="token punctuation">,</span><span class="token string">"okay"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>如果程序达到了main函数的结尾处而且没有return语句，编译器将隐式地插入一条返回0的return语句。</li>
<li><p>main函数返回0表示执行成功，返回其他值表示执行失败。其中非0值得具体含义视机器而定。</p>
<p> 为了让返回值与机器无关，cstdlib头文件定义了两个预处理变量：EXIT_FAILURE、EXIT_SUCCESS，分别表示失败和成功。</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">if</span> <span class="token punctuation">(</span>Success<span class="token punctuation">)</span>
     <span class="token keyword">return</span> EXIT_SUCCESS<span class="token punctuation">;</span>
 <span class="token keyword">else</span>
     <span class="token keyword">return</span> EXIT_FAILURE<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>如果我们想定义一个返回数组指针的函数，则数组的维度必须跟在函数名字之后。形式如下：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
 我们先从内向外理解：func(int i)说明func是一个函数，参数是整型，右边的*表示函数func的返回值是一个指针，然后从右至左理解：(*func(int i))的右边是[10]，表示(*func(int i))是一个大小为10的数组的名字，左边是int，说明数组中的元素是整型。所以func函数返回的是一个指向大小为10的数组的指针。</li>
<li>可以看出，上面的定义比较繁琐，可以使用类型别名来简化：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">using</span> ArrI <span class="token operator">=</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
 ArrI <span class="token operator">*</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
 注意ArrI只代表一个大小为10的数组，想要函数返回指向数组的指针，别忘了函数名前面的*。</li>
<li>C++11还提供了另一种简化定义返回数组指针的函数的方法：使用尾置返回类型。如下：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">auto</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
 表示函数接受一个int类型的实参，返回一个指针，该指针指向含有10个整数的数组。</li>
<li>当然，如果我们明确知道函数返回的是指向哪个数组的指针，那么我们可以直接使用decltype来指定函数返回类型：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> g_Odd<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">7</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
 <span class="token keyword">int</span> g_Even<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
 <span class="token keyword">decltype</span><span class="token punctuation">(</span>g_Odd<span class="token punctuation">)</span> <span class="token operator">*</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">(</span>i <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token operator">&amp;</span>g_Odd <span class="token operator">:</span> <span class="token operator">&amp;</span>g_Even<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
 由于decltype不会把数组名转换为对应的指针，所以decltype的结果仍然是个数组，所以必须在函数名前面加上一个*符号才能表示返回的是指针。</li>
</ol>
<p><font size="5" color="orange">函数重载</font></p>
<hr>
<ol>
<li>如果形参是某种类型的指针或引用，则通过区分其指向的是常量对象还是非常量对象可以实现函数重载，此时的const是底层的：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>CData <span class="token operator">&amp;</span>vData<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">const</span> CData <span class="token operator">&amp;</span>vData<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p>const_cast和重载：<br> 如下代码：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span><span class="token function">getShorterString</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span>vS1<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span>vS2<span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
     <span class="token keyword">return</span> vS1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> vS2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> vS1 <span class="token operator">:</span> vS2<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p> 可以对这个函数传入两个非常量的string对象，但是如果我们想得到的也是非常量的返回结果呢？这时我们可以重载一个函数：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>string <span class="token operator">&amp;</span><span class="token function">getShorterString</span><span class="token punctuation">(</span>std<span class="token operator">::</span>string <span class="token operator">&amp;</span>vS1<span class="token punctuation">,</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span>vS2<span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
     <span class="token keyword">auto</span> <span class="token operator">&amp;</span>r <span class="token operator">=</span> <span class="token function">getShorterString</span><span class="token punctuation">(</span><span class="token keyword">const_cast</span><span class="token operator">&lt;</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span><span class="token operator">></span><span class="token punctuation">(</span>vS1<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">const_cast</span><span class="token operator">&lt;</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span><span class="token operator">></span><span class="token punctuation">(</span>vS2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token keyword">return</span> <span class="token keyword">const_cast</span><span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">&amp;</span><span class="token operator">></span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 这个重载的函数首先将它的实参强制转换为对const的引用，然后调用了原先的const版本的getShortString函数，最后将返回值又强制转换回非常量的string&amp;。由于返回的字符串实际上是初始时是非常量的，所以这种转换是安全的。</p>
<p> 值得注意的是，auto后面一定要有引用符&amp;，否则就是新生成了一个局部变量，然后返回了这个局部变量的引用。</p>
</li>
<li>有多余一个函数可以匹配，但是每一个都不是明显的最佳选择，此时也将发生错误，称为二义性调用。</li>
</ol>
<p><font size="5" color="orange">特殊用途语言特性</font></p>
<hr>
<ol>
<li>调用函数一般比直接求等价表达式的值要慢一些，因为调用函数时会存在保存寄存器、拷贝实参等等操作。</li>
<li>内联函数可以避免函数调用的开销。因为将函数指定为内联函数，通常就是将它在每个调用点上“内联地”展开。形式如下：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">inline</span> <span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span><span class="token function">getShorterString</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span>vS1<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span>vS2<span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
     <span class="token keyword">return</span> vS1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> vS2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> vS1 <span class="token operator">:</span> vS2<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
 一般来说，内联机制用于优化规模较小、流程直接、频繁调用的函数。</li>
<li><p>constexpr函数是指能够用于常量表达式的函数。即下面这样的函数：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">new_sz</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token number">42</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
 <span class="token keyword">constexpr</span> <span class="token keyword">int</span> foo <span class="token operator">=</span> <span class="token function">new_sz</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p> 需要注意的是，要能作用于常量表达式才能算作真正的constexpr函数。编译器在执行上述初始化过程的时候，会把对constexpr函数的调用替换成其结果值。为了能在编译过程中随时展开，constexpr函数被隐式地指定为内联函数。</p>
<p> 定义它时需要遵循几项约定：函数的返回类型及所有形参的类型都得是字面值类型（即内置的基础类型），而且函数体中必须有且只有一条return语句：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">class</span> <span class="token class-name">CData</span>
 <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
     <span class="token keyword">int</span> m_Data <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>

 <span class="token keyword">constexpr</span> CData<span class="token operator">&amp;</span> <span class="token function">getData</span><span class="token punctuation">(</span><span class="token keyword">const</span> CData <span class="token operator">&amp;</span>vData<span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>vData<span class="token punctuation">.</span>m_Data<span class="token punctuation">)</span>      <span class="token comment" spellcheck="true">//流程控制语句不允许出现在constexpr函数中，因为可能出现多个return</span>
         <span class="token keyword">return</span> vData<span class="token punctuation">;</span>
     <span class="token keyword">else</span>
         <span class="token keyword">return</span> <span class="token keyword">new</span> CData<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//只能有一个return语句</span>
 <span class="token punctuation">}</span>

 <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
     <span class="token keyword">const</span> CData Data<span class="token punctuation">;</span>
     <span class="token keyword">constexpr</span> CData Data1 <span class="token operator">=</span> <span class="token function">getData</span><span class="token punctuation">(</span>Data<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//constexpr函数的参数和返回值都必须是字面值类型</span>

     <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>    
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 虽然下面的程序可以通过，但由于它并没有把constexpr函数用于常量表达式，所以不能说明getData函数就是一个真正的constexpr函数：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">class</span> <span class="token class-name">CData</span>
 <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
     <span class="token keyword">int</span> m_Data <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>

 <span class="token keyword">constexpr</span> CData<span class="token operator">&amp;</span> <span class="token function">getData</span><span class="token punctuation">(</span><span class="token keyword">const</span> CData <span class="token operator">&amp;</span>vData<span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
     <span class="token keyword">return</span> vData<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>

 <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
     <span class="token keyword">const</span> CData Data<span class="token punctuation">;</span>
     std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">getData</span><span class="token punctuation">(</span>Data<span class="token punctuation">)</span><span class="token punctuation">.</span>m_Data <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>

     <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 还有一点需要注意的是，constexpr函数不一定返回常量表达式。</p>
</li>
<li>通常将内联函数和constexpr函数定义在头文件中。</li>
<li><p>assert是一种预处理宏，它定义在cassert头文件中。因为宏处理名字由预处理器而非编译器管理，所以使用预处理名字时可以直接使用而无须提供using声明。</p>
<p> assert的行为依赖于一个名为NDEBUG的预处理变量的状态。如果定义了NDEBUG，则assert什么也不做。默认状态下没有定义NDEBUG，此时assert将执行运行时检查。我们可以使用#define语句定义NDEBUG，从而关闭调试状态。也可以通过编译器的命令行选项来做这件事。</p>
<p> 我们可以把assert当成调试程序的一种辅助手段，但是不能用它替代真正的运行时逻辑检查，<strong>也不能替代程序本身应该包含的错误检查</strong>。</p>
</li>
<li><p>除了用于assert外，我们也可以使用NDEBUG编写自己的条件调试代码。如下程序：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
 <span class="token macro property">#<span class="token directive keyword">ifndef</span> NDEBUG</span>
     std<span class="token operator">::</span>cerr <span class="token operator">&lt;&lt;</span> __FUNCTION__ <span class="token operator">&lt;&lt;</span> <span class="token string">" To do..."</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
 <span class="token macro property">#<span class="token directive keyword">endif</span></span>
 <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 如果NDEBUG未定义，将执行#ifndef和#endif之间的代码；如果定义了NDEBUG，这些代码将被忽略掉。<br> 在VS环境下，__FUNCTION__表示当前调试的函数的名字。编译器为每个函数都定义了<strong>FUNCTION</strong>，它是const char的一个静态数组，用于存放函数的名字。</p>
<p> 除此之外，C++编译器还定义了另外4个对程序调试很有用的名字：</p>
<ul>
<li>__FILE__：存放当前文件名的字符串字面值</li>
<li>__LINE__：存放当前行号的整型字面值</li>
<li>__TIME__：存放文件编译时间的字符串字面值</li>
<li>__DATE__：存放文件编译器日期的字符串字面值</li>
</ul>
</li>
</ol>
<p><font size="5" color="orange">函数匹配</font></p>
<hr>
<ol>
<li><p>函数匹配的基本思想是：实参类型与形参类型越接近，它们匹配得越好。具体匹配标准是：如果有且只有一个函数满足最佳匹配（类型最接近），则匹配成功。</p>
<p> 如下面两个重载函数：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p> 如果调用<code>f(41,3.14);</code>，对一个实参来说，f(int,int)是其最佳匹配函数，对第二个参数来说f(double,double)是其最佳匹配函数。因为杜宇不同的实参会有不同的最佳匹配函数，编译器无法从整体上判断孰优孰劣，所以会发出二义性调用的错误。</p>
</li>
<li>调用重载函数时，实参应尽量避免强制类型转换（const_cast除外）。否则，说明我们设计的形参集合不合理。</li>
<li>对于下列重载函数调用也是有二义性的：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">3.14</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//错误，二义性调用</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
 字面值3.14的类型是double，它既能转换成long也能转换成float，所以具有二义性调用。</li>
</ol>
<p><font size="5" color="orange">函数指针</font></p>
<hr>
<ol>
<li><p>函数的类型由它的返回类型和形参共同决定，与函数名无关。对于下面的函数：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">bool</span> <span class="token function">compareLength</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p> 想要声明指向该函数的指针，只需要用指针替换函数名即可：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">bool</span> <span class="token punctuation">(</span><span class="token operator">*</span>pf<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p> pf指向一个函数，该函数具有两个const string引用类型的参数，返回值是bool。</p>
<p> 注意，*pf两端一定要加上括号，否则pf是一个返回值为bool指针的函数，而不是函数指针。</p>
<p> 对于pf的赋值，下面两种方式都可以：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> pf <span class="token operator">=</span> compareLength<span class="token punctuation">;</span>
 pf <span class="token operator">=</span> <span class="token operator">&amp;</span>compareLength<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//取地址符是可选的</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p> 对于pf的调用，下面两种方式都可以：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token punctuation">(</span><span class="token operator">*</span>pf<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">,</span> <span class="token string">"goodbye"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token function">pf</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">,</span> <span class="token string">"goodbye"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//解引用符是可选的</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li>把函数作为参数时，会自动把函数转换成指向函数的指针：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span>vS1<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span>vS2<span class="token punctuation">,</span> <span class="token keyword">bool</span> <span class="token function">compareLength</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
 其中第三个参数是函数类型，会被自动转换为函数指针。等价于下面的形式：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span>vS1<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span>vS2<span class="token punctuation">,</span> <span class="token keyword">bool</span><span class="token punctuation">(</span><span class="token operator">*</span>pf<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>可以使用别名来简化函数指针类型：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">typedef</span> <span class="token keyword">bool</span><span class="token punctuation">(</span><span class="token operator">*</span>FuncP<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">typedef</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>compareLength<span class="token punctuation">)</span> <span class="token operator">*</span>FuncP2<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//等价的类型</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p> 需要注意的是，decltype返回函数类型，它不会将函数类型自动转换成指针类型。所以需要在前面加上*才能得到指针。</p>
<p> 此时，print函数可以是如下形式：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span>vS1<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span>vS2<span class="token punctuation">,</span> FuncP<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span>vS1<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span>vS2<span class="token punctuation">,</span> FuncP2<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//等价的声明</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p>将函数类型作为形参时，会自动转换为函数指针，但将函数类型最为返回值类型时，这种转换不会发生。如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">using</span> F <span class="token operator">=</span> <span class="token keyword">bool</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//F是函数类型，不是指针</span>
 <span class="token keyword">using</span> PF <span class="token operator">=</span> <span class="token keyword">bool</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//PF是函数指针</span>

 F <span class="token function">f1</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//错误：F是函数类型，f1不能返回一个函数</span>
 F <span class="token operator">*</span><span class="token function">f2</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//正确：显式指定返回类型是指向函数的指针</span>
 PF <span class="token function">f3</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//正确：PF是函数指针，f3返回指向函数的指针</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>当然，我们也可以使用尾置返回类型的方式来声明返回函数指针的函数：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">auto</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li>而且，如果我们明确知道返回的函数是哪一个，就可以使用decltype来简化函数指针的形式：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">bool</span> <span class="token function">smallerString</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">bool</span> <span class="token function">largerString</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">decltype</span><span class="token punctuation">(</span>smallerString<span class="token punctuation">)</span> <span class="token operator">*</span><span class="token function">getFunc</span><span class="token punctuation">(</span><span class="token keyword">int</span> vFuncType<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
 牢记decltype不会把函数类型转换为函数指针，想要表示指针必须得加上*。<br>&nbsp; </li>
</ol>
<hr>
<p>参考文献：《C++Primer第五版》</p>

            </div>

            <!-- Post Comments -->
            
    <!-- 使用 DISQUS_CLICK -->
<div id="disqus-comment">
    <div id="disqus_thread"></div>

<!-- add animation -->
<style>
	.disqus_click_btn {
            line-height: 30px;
            margin: 0;
            min-width: 50px;
            padding: 0 14px;
            display: inline-block;
            font-family: "Roboto", "Helvetica", "Arial", sans-serif;
            font-size: 14px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0;
            overflow: hidden;
            will-change: box-shadow;
            transition: box-shadow .2s cubic-bezier(.4, 0, 1, 1), background-color .2s cubic-bezier(.4, 0, .2, 1), color .2s cubic-bezier(.4, 0, .2, 1);
            outline: 0;
            cursor: pointer;
            text-decoration: none;
            text-align: center;
            vertical-align: middle;
            border: 0;
            background: rgba(158, 158, 158, .2);
            box-shadow: 0 2px 2px 0 rgba(0, 0, 0, .14), 0 3px 1px -2px rgba(0, 0, 0, .2), 0 1px 5px 0 rgba(0, 0, 0, .12);
            color: #fff;
            background-color: #7EC0EE;
            text-shadow: 0
        }
</style>
	
<div class="btn_click_load" id="disqus_bt"> 
    <button class="disqus_click_btn">点击查看评论</button>
</div>

<!--
<script type="text/javascript">
$('.btn_click_load').click(function() {
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'http-miccall-tech'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    document.getElementById('disqus_bt').style.display = "none";
});
</script>
-->
<script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://yoursite.com/2017/12/20/C++Primer第六章函数/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = 'http://yoursite.com/2017/12/20/C++Primer第六章函数/'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
</script>

<script type="text/javascript">
    $('.btn_click_load').click(function() {  //click to load comments
        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document;
            var s = d.createElement('script');
            s.src = '//http-miccall-tech.disqus.com/embed.js';
            s.setAttribute('data-timestamp', + new Date());
            (d.head || d.body).appendChild(s);
        })();
        $('.btn_click_load').css('display','none');
    });
</script>
</div>
<style>
    #disqus-comment{
        background-color: #eee;
        padding: 2pc;
    }
</style>


        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
                <li>Design: <a href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
            </ul>
            
            	<span id="busuanzi_container_site_pv">2019总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			
        </div>
    </div>
</body>



 	
</html>
