<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>C++ const详解 | Elays&#39;Blog</title>
  <meta name="author" content="Elay">
  
  <meta name="description" content="Elay">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="C++ const详解"/>
  <meta property="og:site_name" content="Elays&#39;Blog"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Elays&#39;Blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">Elays&#39;Blog</a></h1>
  <h2><a href="/">你是天地生的，美得超越人形</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">主页</a></li>
    
      <li><a href="/archives">所有文章</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2017-05-30T11:58:17.000Z"><a href="/2017/05/30/C++const详解/">2017-05-30</a></time>
      
      
  
    <h1 class="title">C++ const详解</h1>
  

    </header>
    <div class="entry">
      
        <p>被const修饰的东西（包括变量、函数、返回值等等）都强制为只读的，可以防止外界意外地改动，可以提高程序的健壮性，所以我们可能经常看到一句话：“Use const whenever you need”。<br><a id="more"></a></p>
<p><font size="5" color="orange">用const修饰变量</font></p>
<hr>
<ul>
<li><p>对于<code>const int *m;</code>，const修饰的是整型变量<code>*m</code>，不是指针变量<code>m</code>，所以*m是不可变的，m是可变的，即：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> *m;</div><div class="line"><span class="keyword">int</span> *n;</div><div class="line">m = n;      <span class="comment">//合法，m所指向的对象是可变的</span></div><div class="line">*m = <span class="number">14</span>;    <span class="comment">//不合法，m指向的对象的内容是不可变的</span></div></pre></td></tr></table></figure>
<p><code>const int *m</code>和<code>int const *m</code>是一样的。</p>
</li>
<li><p>对于<code>int * const m;</code>，const修饰的是指针变量m，所以m是不可变的，但*m是可变的，即：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> p;</div><div class="line"><span class="keyword">int</span> * <span class="keyword">const</span> m = &amp;p;</div><div class="line"><span class="keyword">int</span> *n;</div><div class="line">m = n;      <span class="comment">//不合法，m所指向的对象是不可变的</span></div><div class="line">*m = <span class="number">14</span>;    <span class="comment">//合法，m指向的对象的内容是可变的</span></div></pre></td></tr></table></figure>
<p>而且<code>int * const m</code>是必须在定义时赋初值的，否则m将指向随机的内存地址，这个内存地址是可能会变的，即m会变，则不符合const修饰的只读属性，所以必须在定义时为其指定一个确切的地址，而且一经赋值就不能再变了。</p>
</li>
<li><p>对于<code>const int m</code>，const修饰的是m，m的值是不可变的，如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> n;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> m = n;</div><div class="line"><span class="keyword">int</span> p = m;      <span class="comment">//合法，因为p是m的复制，不共用地址，不是同一个变量，可以有不同的读写属性</span></div><div class="line"><span class="keyword">int</span>&amp; q = m;     <span class="comment">//不合法，因为p和m共用地址，是同一个变量，但p和m却具有不同的读写属性，不合语义</span></div></pre></td></tr></table></figure>
<p>在定义m时也是需要赋初值的，因为m的值是一经确定不能再改变的，它需要从一开始就知道自己的值是多少，不能后续再通过赋值语句来确定自己的值，即<code>m = 14;</code>是非法的。<code>int&amp; q = m</code>不合法是因为m是只读的，q是可读可写的，但是m和q共用一个地址，实际上是同一个变量，但却有不同的读写属性，即可以通过改变q来改变m的值，这是不符合const语义的，所以它不合法。而<code>int p = m</code>合法是因为p是m的复制，和m不共用地址，不是同一个变量，可以拥有不同的读写属性，改变p并不会影响到m。</p>
</li>
</ul>
<p>【注】：</p>
<ul>
<li><p>上面的<code>const int *m</code>可以不用赋初值，是因为const虽然修饰的是<code>*m</code>，<code>*m</code>是不可以直接赋值改变的，但是指针m指向的内容（即<code>*m</code>）是可以通过改变m来间接改变的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> *k;</div><div class="line"><span class="keyword">int</span> m = <span class="number">10</span>;</div><div class="line"><span class="keyword">int</span> n = <span class="number">20</span>;</div><div class="line">k = &amp;m;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; *k &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">k = &amp;n;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; *k &lt;&lt; <span class="built_in">endl</span>;</div></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">10</span></div><div class="line"><span class="number">20</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p><font size="5" color="orange">用const修饰函数参数</font></p>
<hr>
<p>如果函数参数需要作输出参数用，那么该参数就不能用const修饰，因为一旦用const修饰，该参数就无法在函数内部做任何改变，输入的是什么值，输出的将还是同样的值，强制对该参数赋值会编译报错，无法达到向函数外输出有效数据的作用。但是如果函数参数只作输入参数用，使用const修饰可以保证函数内部不会意外改动该参数，尤其是当函数参数是地址、引用等地址类型时，使用const能够起到保护作用，使函数实参不会被改变。如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">copyString</span><span class="params">(<span class="keyword">char</span>* strDest, <span class="keyword">const</span> <span class="keyword">char</span>* strSrc)</span></span>;</div></pre></td></tr></table></figure></p>
<p>strSrc是输入参数，在字符串复制时并不希望改变它，所以用const将它修饰为只读的，函数内部如果企图改变strSrc的内容，编译器将报错。strDest是输出参数，将复制过后的字符串传到函数外部的对应实参。</p>
<p>对于采用值传递的参数，由于函数会自动产生临时变量来复制实参，此时的函数参数（形参）和其实参具有不同的地址，即实参已经受到了保护，形参改变时并不会影响到其实参，所以无需加const修饰。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</div></pre></td></tr></table></figure></p>
<p>不需要用const来修饰采用值传递的形参x：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> x)</span></span>;</div></pre></td></tr></table></figure></p>
<p>同样地，无需将<code>void func(A a)</code>写为<code>void func(const A a)</code>，A为我们自定义的类、结构体等数据类型，非<a href="http://www.cnblogs.com/zrtqsk/p/4369864.html" target="_blank" rel="external">C++基本数据类型</a>。</p>
<p>对于非C++基本数据类型的参数而言，像<code>void func(A a)</code>这样直接传递对象效率会比较低，因为函数内部会再产生一个A类型的临时对象a来复制对应实参，而临时对象将会产生构造、复制、析构等时间内存开销。为了提高效率，可以将函数改为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(A&amp; a)</span></span>;</div></pre></td></tr></table></figure></p>
<p>这样函数参数将采用址传递，形参只是实参的别名，共用同一个地址空间，不会产生临时对象。但是a可能只需要做输入参数用，并不希望函数内部改变参数a的内容，这时就可以将参数a用const来修饰为只读的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> A&amp; a)</span></span>;</div></pre></td></tr></table></figure></p>
<p>这样既达到了提高效率的目的，也保护了参数a对应的实参。那么为了提高效率是否应该将<code>void func(int x);</code>改为<code>void func(int&amp; x);</code>呢？不需要的，因为C++基本数据类型在赋值/复制时没有构造、析构的过程，复制也非常快，基本类型的值传递和引用传递效率几乎一致。注：这里x只作输入参数用，如果需要作输出参数，还是要采用址传递的。</p>
<p>综上：</p>
<ul>
<li>对于非基本数据类型的输入参数，应该将“值传递”的方式改为“const 引用传递”来提高效率。例如将<code>void func(A a);</code>改为<code>void func(const A&amp; a);</code>。</li>
<li>对于基本数据类型的输入参数，不需要做上述改变，否则既不能提高效率也降低了函数的可读性。例如不要将<code>void func(int x);</code>改为<code>void func(const int&amp; x);</code>。</li>
</ul>
<p><font size="5" color="orange">用const修饰函数返回值</font></p>
<hr>
<p>如果函数返回值采用值传递方式，用const修饰是没有价值的，因为函数会把返回值复制到外部的临时变量中，对函数内部的返回变量已经起到了保护作用。如果函数返回值采用址传递方式，比如指针，用const修饰返回值，能够保证函数返回值（即指针）的内容不能被修改，<strong>该返回值只能赋给const修饰的同类型指针</strong>。</p>
<p>若返回值是非基本数据类型，将<code>A get();</code>改为<code>const A&amp; get()</code>确实可以提高效率，但是要注意函数到底是想返回一个对象的拷贝还是对象的别名，不然程序容易出错。比如外界想对get函数返回的对象值作进一步处理，但是又不想影响到A对象中的成员，那么无论使用<code>A&amp; get()</code>还是<code>const A&amp; get()</code>都达不到效果，还是得使用<code>A get()</code>。其实函数返回值采用引用传递的场合并不多，一般出现在类的赋值函数中，目的是为了实现链式表达式。如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></div><div class="line">	<span class="keyword">const</span> A&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> A&amp; other);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	A a, b, c;</div><div class="line">	a = b = c;     <span class="comment">//合法</span></div><div class="line">	(a = b) = c;   <span class="comment">//不合法</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在a=b=c时，先执行b=c，返回值是const A类型，再将它作为参数传给other，最后赋值给A类型的a；但是在(a=b)=c时，先执行a=b，返回值是const A类型，接下来会将c作为参数传给other，最后赋值给const A类型，这与const变量只读冲突，所以是不合法的。</p>
<p><font size="5" color="orange">用const修饰成员函数</font></p>
<hr>
<p>用const修饰成员函数用于保证函数内部不会修改数据成员，且不能调用其他非const成员函数（因为其他非const成员函数可能会修改数据成员）。如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">	<span class="keyword">int</span> value;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	Test() &#123;</div><div class="line">		value = <span class="number">100</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">int</span>&amp; <span class="title">GetValue</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line"></div><div class="line">&#125;;</div><div class="line"><span class="keyword">int</span>&amp; Test::GetValue() <span class="keyword">const</span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">return</span> value;   <span class="comment">//value此时具有const属性，不合法</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由于每个非static非const的成员函数都有一个隐含的this，所以用const修饰函数相当于是在修饰this，由于函数的作用域只在函数内部，所以只在函数内部时this指针是const类型的，是只读的，也就是说在const修饰的函数内部，this的任何成员变量和成员函数都是只读的。所以上面<code>GetValue</code>函数里，value（即this.value）也是const类型的，返回的是const int类型，但函数指定的返回值却是int&amp;，这与前面讲的<code>int&amp; q = m</code>是一样的道理，不合法。</p>
<p>可以这样改：</p>
<ol>
<li>把变量声明<code>int value</code>改为<code>mutable int value</code>，因为mutable修饰的变量是易变的，是const的反义词，可以在const函数中被修改。</li>
</ol>
<ul>
<li>将<code>return value</code>改为<code>return const_cast&lt;int&amp;&gt;(value)</code>，因为const_value去掉了const性质（其实是去掉了指向value指针的const性质，可以间通过前文说的间接方式来改变value的值，value自身的const属性是去不掉的）。</li>
<li>将函数改为<code>const int&amp; Test::GetValue() const</code>。</li>
<li>将函数改为<code>int Test::GetValue() const</code>。</li>
<li>将函数后面的const去掉。</li>
<li>return的不是成员变量，即如下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span>&amp; Test::GetValue() <span class="keyword">const</span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> tempValue = value;</div><div class="line">	<span class="keyword">return</span> tempValue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>对于第4种将&amp;去掉，其原理与上面讲的<code>int p = m</code>是一致的，非地址类型是直接复制的，前后不是同一个变量，可以有不同的读写属性。</p>
<p>如果将value改为指针类型，如下程序：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">	<span class="keyword">int</span> *value;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	Test() &#123;</div><div class="line">		value = <span class="keyword">new</span> <span class="keyword">int</span>();</div><div class="line">		*value = <span class="number">100</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">int</span>* <span class="title">GetValue</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line"></div><div class="line">&#125;;</div><div class="line"><span class="keyword">int</span>* Test::GetValue() <span class="keyword">const</span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">return</span> value; <span class="comment">//value此时具有const属性</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面程序是不会报错的，但是函数返回的是指针，与上文返回引用有什么不同吗？上文返回引用是报错的。这是因为这里返回的指针，而函数返回类型也是指针类型的，指针本身就相当于一个4字节的整型变量，存储着其他变量的地址，所以这里还是相当于上面第4种修改方式，是两个int型变量之间的复制。<br>如果把程序改成下面这样是会出错的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">	<span class="keyword">int</span> value;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	Test() &#123;</div><div class="line">		value = <span class="number">100</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">int</span>* <span class="title">GetValue</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line"></div><div class="line">&#125;;</div><div class="line"><span class="keyword">int</span>* Test::GetValue() <span class="keyword">const</span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">return</span> &amp;value;   <span class="comment">//value此时具有const属性，不合法</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>原理还是一样的，const int类型的返回值value和函数返回的int*类型的临时变量具有相同的地址，实际上是同一个变量，但却具有不同的读写属性，返回的临时变量是可写的，但value只读，所以是不合法的。<br>&nbsp;</p>
<hr>
<p>参考文献：<a href="http://blog.csdn.net/zheng19880607/article/details/23883437" target="_blank" rel="external">C++ const修饰成员函数</a></p>

      
    </div>
    <footer>
      
        
  
  <div class="categories">
    <a href="/categories/C/">C++</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/const/">const</a>
  </div>

        
  <div class="addthis addthis_toolbox addthis_default_style">
    
      <a class="addthis_button_facebook_like" fb:like:layout="button_count"></a>
    
    
      <a class="addthis_button_tweet"></a>
    
    
      <a class="addthis_button_google_plusone" g:plusone:size="medium"></a>
    
    
      <a class="addthis_button_pinterest_pinit" pi:pinit:layout="horizontal"></a>
    
    <a class="addthis_counter addthis_pill_style"></a>
  </div>
  <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js"></script>

      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


<section id="comment">
  <h2 class="title">留言</h2>


 
  	   <!-- 多说评论框 start -->
 		<div class="ds-thread" data-thread-key="2017/05/30/C++const详解/" data-title="C++ const详解" data-url="http://yoursite.com/2017/05/30/C++const详解/"></div>
		<!-- 多说评论框 end -->
		<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
		<script type="text/javascript">
		var duoshuoQuery = {short_name:"popperelay"};   <!-- 替换这里的duoshuo_shortname为前面注册的shortname -->
			(function() {
				var ds = document.createElement('script');
				ds.type = 'text/javascript';ds.async = true;
				ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.unstable.js';
				ds.charset = 'UTF-8';
				(document.getElementsByTagName('head')[0] 
				 || document.getElementsByTagName('body')[0]).appendChild(ds);
			})();
			</script>
		<!-- 多说公共JS代码 end -->
 
  
</section>

</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:yoursite.com">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/C-语法/">C#语法</a><small>2</small></li>
  
    <li><a href="/categories/C/">C++</a><small>4</small></li>
  
    <li><a href="/categories/C语言/">C语言</a><small>1</small></li>
  
    <li><a href="/categories/OpenGL/">OpenGL</a><small>25</small></li>
  
    <li><a href="/categories/c/">c++</a><small>1</small></li>
  
    <li><a href="/categories/博客配置/">博客配置</a><small>3</small></li>
  
    <li><a href="/categories/操作系统/">操作系统</a><small>4</small></li>
  
    <li><a href="/categories/数据结构/">数据结构</a><small>15</small></li>
  
    <li><a href="/categories/毕设/">毕设</a><small>1</small></li>
  
    <li><a href="/categories/游戏开发/">游戏开发</a><small>1</small></li>
  
    <li><a href="/categories/游戏设计模式/">游戏设计模式</a><small>1</small></li>
  
    <li><a href="/categories/计算机图形学/">计算机图形学</a><small>2</small></li>
  
    <li><a href="/categories/调试错误集锦/">调试错误集锦</a><small>1</small></li>
  
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/BIOS和微机启动过程/">BIOS和微机启动过程</a><small>1</small></li>
  
    <li><a href="/tags/Blinn-Phong/">Blinn-Phong</a><small>1</small></li>
  
    <li><a href="/tags/C/">C</a><small>1</small></li>
  
    <li><a href="/tags/C-容器/">C#容器</a><small>1</small></li>
  
    <li><a href="/tags/C-IO/">C++IO</a><small>1</small></li>
  
    <li><a href="/tags/Gamma校正/">Gamma校正</a><small>1</small></li>
  
    <li><a href="/tags/MarkDown/">MarkDown</a><small>1</small></li>
  
    <li><a href="/tags/Mathjax语法/">Mathjax语法</a><small>1</small></li>
  
    <li><a href="/tags/OS内核/">OS内核</a><small>1</small></li>
  
    <li><a href="/tags/OpenGL坐标系统/">OpenGL坐标系统</a><small>1</small></li>
  
    <li><a href="/tags/OpenGL摄像机/">OpenGL摄像机</a><small>1</small></li>
  
    <li><a href="/tags/OpenGL窗口/">OpenGL窗口</a><small>1</small></li>
  
    <li><a href="/tags/OpenGL配置/">OpenGL配置</a><small>1</small></li>
  
    <li><a href="/tags/c-特性/">c++特性</a><small>1</small></li>
  
    <li><a href="/tags/const/">const</a><small>1</small></li>
  
    <li><a href="/tags/timeTest/">timeTest</a><small>1</small></li>
  
    <li><a href="/tags/二叉树/">二叉树</a><small>1</small></li>
  
    <li><a href="/tags/交流/">交流</a><small>1</small></li>
  
    <li><a href="/tags/光照场景/">光照场景</a><small>1</small></li>
  
    <li><a href="/tags/光照贴图/">光照贴图</a><small>1</small></li>
  
    <li><a href="/tags/关键路径/">关键路径</a><small>1</small></li>
  
    <li><a href="/tags/冯氏光照/">冯氏光照</a><small>1</small></li>
  
    <li><a href="/tags/几何着色器/">几何着色器</a><small>1</small></li>
  
    <li><a href="/tags/反走样/">反走样</a><small>1</small></li>
  
    <li><a href="/tags/图/">图</a><small>1</small></li>
  
    <li><a href="/tags/图形学概述/">图形学概述</a><small>1</small></li>
  
    <li><a href="/tags/图形显示系统/">图形显示系统</a><small>1</small></li>
  
    <li><a href="/tags/多说/">多说</a><small>1</small></li>
  
    <li><a href="/tags/天空盒子/">天空盒子</a><small>1</small></li>
  
    <li><a href="/tags/头结点/">头结点</a><small>1</small></li>
  
    <li><a href="/tags/实例化/">实例化</a><small>1</small></li>
  
    <li><a href="/tags/尾递归/">尾递归</a><small>1</small></li>
  
    <li><a href="/tags/帧同步/">帧同步</a><small>1</small></li>
  
    <li><a href="/tags/帧缓冲/">帧缓冲</a><small>1</small></li>
  
    <li><a href="/tags/常见光源/">常见光源</a><small>1</small></li>
  
    <li><a href="/tags/拓扑排序/">拓扑排序</a><small>1</small></li>
  
    <li><a href="/tags/操作系统概述/">操作系统概述</a><small>1</small></li>
  
    <li><a href="/tags/改进排序/">改进排序</a><small>1</small></li>
  
    <li><a href="/tags/文件IO/">文件IO</a><small>1</small></li>
  
    <li><a href="/tags/最小生成树/">最小生成树</a><small>1</small></li>
  
    <li><a href="/tags/最短路径/">最短路径</a><small>1</small></li>
  
    <li><a href="/tags/材质/">材质</a><small>1</small></li>
  
    <li><a href="/tags/查找/">查找</a><small>1</small></li>
  
    <li><a href="/tags/栈/">栈</a><small>1</small></li>
  
    <li><a href="/tags/树/">树</a><small>1</small></li>
  
    <li><a href="/tags/模型加载/">模型加载</a><small>1</small></li>
  
    <li><a href="/tags/模板测试/">模板测试</a><small>1</small></li>
  
    <li><a href="/tags/深度测试/">深度测试</a><small>1</small></li>
  
    <li><a href="/tags/混合/">混合</a><small>1</small></li>
  
    <li><a href="/tags/着色器/">着色器</a><small>1</small></li>
  
    <li><a href="/tags/着色器画三角形/">着色器画三角形</a><small>1</small></li>
  
    <li><a href="/tags/简单排序/">简单排序</a><small>1</small></li>
  
    <li><a href="/tags/纹理/">纹理</a><small>1</small></li>
  
    <li><a href="/tags/缓冲对象/">缓冲对象</a><small>1</small></li>
  
    <li><a href="/tags/编译链接错误/">编译链接错误</a><small>1</small></li>
  
    <li><a href="/tags/背面剔除/">背面剔除</a><small>1</small></li>
  
    <li><a href="/tags/设计模式/">设计模式</a><small>1</small></li>
  
    <li><a href="/tags/进程的描述与控制/">进程的描述与控制</a><small>1</small></li>
  
    <li><a href="/tags/重定义错误/">重定义错误</a><small>1</small></li>
  
    <li><a href="/tags/链表/">链表</a><small>1</small></li>
  
    <li><a href="/tags/队列/">队列</a><small>1</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2017 Elay
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>


<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</body>
</html>