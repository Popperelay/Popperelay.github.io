<!DOCTYPE HTML>
<html>

<head><meta name="generator" content="Hexo 3.9.0">
	<link rel="bookmark" type="image/x-icon" href="/img/logo_miccall.png">
	 <link rel="shortcut icon" href="/img/logo_miccall.png">
	
			
    <title>
    Elays'Blog
    </title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
	<script>
	(function(){
		if('{{ page.password }}'){
			if (prompt('请输入博客密码') !== "elayRender"){
				alert('密码错误！');
				history.back();
			}
		}
	})();
	</script>
    <link rel="stylesheet" href="/css/mic_main.css">
    <link rel="stylesheet" href="/css/dropdownMenu.css">
    
    	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css">
    </noscript>
			    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<link rel="stylesheet" href="/css/prism-dark.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>
    
		
<!-- Layouts -->


<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<!--<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">-->
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/latest.js?config=TeX-MML-AM_CHTML">
</script>

<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_undefined.css">
<link rel="stylesheet" href="/css/typo.css">
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">MICCALL</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special">
            <ul class="menu links">
			<!-- Homepage  主页  --> 
			<li>
	            <a href="/" rel="nofollow">主页</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">分类</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="/categories/C/">C#</a></li><li><a class="category-link" href="/categories/C-语法/">C#语法</a></li><li><a class="category-link" href="/categories/C/">C++</a></li><li><a class="category-link" href="/categories/C语言/">C语言</a></li><li><a class="category-link" href="/categories/Graphics/">Graphics</a></li><li><a class="category-link" href="/categories/Math/">Math</a></li><li><a class="category-link" href="/categories/OpenGL/">OpenGL</a></li><li><a class="category-link" href="/categories/Unity/">Unity</a></li><li><a class="category-link" href="/categories/博客配置/">博客配置</a></li><li><a class="category-link" href="/categories/并行计算/">并行计算</a></li><li><a class="category-link" href="/categories/操作系统/">操作系统</a></li><li><a class="category-link" href="/categories/数据结构/">数据结构</a></li><li><a class="category-link" href="/categories/毕设/">毕设</a></li><li><a class="category-link" href="/categories/游戏开发/">游戏开发</a></li><li><a class="category-link" href="/categories/计算机系统/">计算机系统</a></li><li><a class="category-link" href="/categories/设计模式/">设计模式</a></li><li><a class="category-link" href="/categories/面试/">面试</a>
	                    </li></ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/gallery/" title="图库">
		                图库
		            </a>
		        </li>
		        
		        <li>
		            <a href="/tag/" title="搜索">
		                搜索
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
		            
		                <li><a href="https://github.com/miccall" class="icon fa-github"><span class="label">GitHub</span></a></li>
		            
		            
		            
		            
			</ul>
</nav>

        <div id="main">
            <div class="post_page_title_img" style="height: 25rem;background-image: url(https://github.com/Popperelay/Photos/blob/master/Photos/%E8%80%81%E5%BC%A05%E8%B4%A3%E4%BB%BB%E9%93%BE%E5%92%8C%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8FBG.jpg?raw=true);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;">
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2>老张培训笔记第五课责任链模式和适配器模式</h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
				<!-- 目录 -->
				<p class="show-toc-btn" id="show-toc-btn" onclick="showToc();" style="display:none">
				<span class="btn-bg"></span>
				<span class="btn-text">文章导航</span>
				</p>
				<div id="toc-article" class="toc-article">
					<span id="toc-close" class="toc-close" title="隐藏导航" onclick="showBtn();">×</span>
					<strong class="toc-title">文章目录</strong>
					
			   </div>
			   <script type="text/javascript">
				function showToc(){
					var toc_article = document.getElementById("toc-article");
					var show_toc_btn = document.getElementById("show-toc-btn");
					toc_article.setAttribute("style","display:block");
					show_toc_btn.setAttribute("style","display:none");
					};
				function showBtn(){
					var toc_article = document.getElementById("toc-article");
					var show_toc_btn = document.getElementById("show-toc-btn");
					toc_article.setAttribute("style","display:none");
					show_toc_btn.setAttribute("style","display:block");
					};
			   </script>
				
                <p>感谢老张！<br><a id="more"></a></p>
<hr>
<p>案例：实现员工请假系统，要求如下：</p>
<ul>
<li>公司有三个级别的可以批假的员工，其批假权限为：<ul>
<li>TeamLeader：可以批准10天以内的请假。</li>
<li>ProjectLeader：可以批准20天以内的请假。</li>
<li>HR：可以批准30天以内的请假。</li>
<li>30天以上的假期不能批准，只能离职。</li>
</ul>
</li>
<li>审批流程：先由TeamLeader进行审批，若权限不够则交由ProjectLeader处理，若权限还不够则交由HR处理。</li>
</ul>
<p>分析上述案列，我们需要实现如下几个功能：</p>
<ul>
<li>审批流程：TeamLeader→ProjectLeader→HR。</li>
<li>审批权限：每级都有自己独立的审批权限。</li>
<li>审批：审批动作本身。</li>
</ul>
<p><font size="5" color="orange">最常见的方式</font></p>
<hr>
<p>通常最容易想到的就是按C语言的方式在主程序里通过if-else的判断来实现这种逐级处理。</p>
<p>我们先把请假请求封装成一个类，当中有一个表示请假天数的成员变量（封装成类是为了后续需求变化考虑，因为可能请假可能不仅考虑到天数，还考虑到职位、在团队里的重要性等等）：</p>
<pre class="line-numbers language-c++"><code class="language-c++">class CLeaveRequest {
public:
    CLeaveRequest() {}
    CLeaveRequest(int vLeaveDays) : m_LeaveDays(vLeaveDays) {}

    int getLeaveDays() const { return m_LeaveDays; }

private:
    int m_LeaveDays;
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们再创建一个员工的基类（依赖倒置原则），它只有一个表示审批动作本身的函数，至于通不通过我们在主程序里通过if-else去实现：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#include "LeaveRequest.h"

class CEmployee{
public:
    virtual void approveLeaveV(const CLeaveRequest *vLeaveRequest) const = 0;
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后实现员工类的3个子类，它们各自有自己具体的审批动作：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>
#include "Employee.h"

class CTeamLeader : public CEmployee{
public:
    virtual void approveLeaveV(const CLeaveRequest *vLeaveRequest) const override {
        std::cout << "The leave request of" << vLeaveRequest->getLeaveDays() << " days has been approved by team leader." << std::endl;
    }
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></iostream></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>
#include "Employee.h"

class CProjectLeader : public CEmployee {
public:
    virtual void approveLeaveV(const CLeaveRequest *vLeaveRequest) const override {
        std::cout << "The leave request of" << vLeaveRequest->getLeaveDays() << " days has been approved by project leader." << std::endl;
    }
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></iostream></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>
#include "Employee.h"

class CHR : public CEmployee {
public:
    virtual void approveLeaveV(const CLeaveRequest *vLeaveRequest) const override {
        std::cout << "The leave request of" << vLeaveRequest->getLeaveDays() << " days has been approved by HR." << std::endl;
    }
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></iostream></code></pre>
<p>然后我们在主函数里创建请求以及三类员工的对象：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#include "TeamLeader.h"
#include "ProjectLeader.h"
#include "HR.h"

int main() {
    CTeamLeader *pTeamLeader = new CTeamLeader;
    CProjectLeader *pProjectLeader = new CProjectLeader;
    CHR *pHR = new CHR;
    CLeaveRequest *pLeaveRequest = new CLeaveRequest(25);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后从TeamLeader开始，使用if-else判断请假类里的天数是否满足他的天数限制，如果不满足，则看是否满足他的上司的天数限制，以此类推：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    if (pLeaveRequest->getLeaveDays() < 10) {
        pTeamLeader->approveLeaveV(pLeaveRequest);
    }
    else {
        if (pLeaveRequest->getLeaveDays() < 20) {
            pProjectLeader->approveLeaveV(pLeaveRequest);
        }
        else {
            if (pLeaveRequest->getLeaveDays() < 30) {
                pHR->approveLeaveV(pLeaveRequest);
            }
            else {
                std::cout << "The only way to get " << pLeaveRequest->getLeaveDays() << " leave days to quit the company." << std::endl;
            }
        }
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>程序输出的结果如下：</p>
<pre class="line-numbers language-c++"><code class="language-c++">The leave request of 25 days has been approved by HR.
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>但是这多重if-else明显不符合开闭原则，审批条件和审批流程完全在客户端实现，即客户端和审批业务耦合太紧。</p>
<p><font size="5" color="orange">责任链模式</font></p>
<hr>
<p>上面的实现不符合开闭原则，我们需要把审批条件以及审批流程移到CEmployee及其派生类中，降低客户端和业务类的耦合度。</p>
<p>怎么把审批流程移过去呢？审批是一级一级上交的，自己这级权限不够，就需要交给上级来处理，所以关键就是两点：</p>
<ul>
<li>怎么知道自己权限不够？</li>
<li>怎么知道自己上级是谁？</li>
</ul>
<p>我们先看怎么知道自己的上级，某个员工要知道自己的上级是谁，其实很简单，在员工基类里加一个表示上级的成员变量就可以了：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#include "LeaveRequest.h"

class CEmployee{
public:
    CEmployee() :m_Superior(NULL) {}

    virtual void approveLeaveV(const CLeaveRequest *vLeaveRequest) const = 0;

    void setSuperior(CEmployee *vSuperior) { m_Superior = vSuperior; }
    const CEmployee* getSuperior() const { return m_Superior; }

private:
    const CEmployee *m_Superior;
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>每级员工都知道自己的权限天数是多少，不满足则交给他的上级m_Superior来处理：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>
#include "Employee.h"

class CTeamLeader : public CEmployee{
public:
    virtual void approveLeaveV(const CLeaveRequest *vLeaveRequest) const override {
        if (vLeaveRequest->getLeaveDays() < 10)
            std::cout << "The leave request of " << vLeaveRequest->getLeaveDays() << " days has been approved by team leader." << std::endl;
        else
            if(getSuperior())
                getSuperior()->approveLeaveV(vLeaveRequest);
    }
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></iostream></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>
#include "Employee.h"

class CProjectLeader : public CEmployee {
public:
    virtual void approveLeaveV(const CLeaveRequest *vLeaveRequest) const override {
        if (vLeaveRequest->getLeaveDays() < 20)
            std::cout << "The leave request of " << vLeaveRequest->getLeaveDays() << " days has been approved by project leader." << std::endl;
        else
            if (getSuperior())
                getSuperior()->approveLeaveV(vLeaveRequest);
    }
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></iostream></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>
#include "Employee.h"

class CHR : public CEmployee {
public:
    virtual void approveLeaveV(const CLeaveRequest *vLeaveRequest) const override {
        if (vLeaveRequest->getLeaveDays() < 30)
            std::cout << "The leave request of " << vLeaveRequest->getLeaveDays() << " days has been approved by HR." << std::endl;
        else
            std::cout << "The only way to get " << vLeaveRequest->getLeaveDays() << " leave days to quit the company." << std::endl;
    }
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></iostream></code></pre>
<p>这时主函数就变得很简单了，只需要把请求交给底层的TeamLeader就行，它会自动逐级上交审批请求的：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#include "TeamLeader.h"
#include "ProjectLeader.h"
#include "HR.h"

int main() {
    CTeamLeader *pTeamLeader = new CTeamLeader;
    CProjectLeader *pProjectLeader = new CProjectLeader;
    CHR *pHR = new CHR;
    CLeaveRequest *pLeaveRequest = new CLeaveRequest(25);

    pTeamLeader->setSuperior(pProjectLeader);
    pProjectLeader->setSuperior(pHR);

    pTeamLeader->approveLeaveV(pLeaveRequest);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这就是责任链模式：在具有上下级关系的一串对象中，每一级对象都含有其直接上级对象的指针。这样就将请求的处理者组织成一条链，客户端无需关心请求的处理细节以及请求的传递，只需要将请求发送到链上，实现请求的发送者和处理者解耦。请求会沿着链向上传递。但是，很明显的，系统性能会受到一定影响。</p>
<p>但是上面代码里，三类员工的approveLeaveV函数有没有太像了？几乎只有一个10、20、30不同，外加审批通过后作出的反应不同（这里是输出的字符串不同）。这代码明显重复得太厉害了，确定写的时候没有CtrlC、CtrlV？有没有什么办法能够减少重复代码？如果能够把这段approveLeaveV函数代码移到基类CEmployee当然就可以减少每个子类重复写了，但是那两个不同的地方怎么处理？<br>先看第一个不同地方：每一级员工的权限天数不一样，我们在基类里设置一个表示权限天数的变量就可以了，子类在创建后分别给这个变量赋以不同的值就OK：</p>
<pre class="line-numbers language-c++"><code class="language-c++">class CEmployee{
public:
    ...
    void  setMaxApproveDays(int vMaxApproveDays) { m_MaxApproveDays = vMaxApproveDays; }
    int   getMaxApproveDays() const { return m_MaxApproveDays; }
    ...

private:
    const CEmployee *m_Superior;
    int m_MaxApproveDays;
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>那么第二个不同的地方：审批通过后的反应不同，这个我们可以用多态啊！在基类里设置一个表示审批通过的函数：</p>
<pre class="line-numbers language-c++"><code class="language-c++">class CEmployee{
public:
    ...
    virtual void approvePassedV(const CLeaveRequest *vLeaveRequest) const = 0;
    ...

private:
    const CEmployee *m_Superior;
    int m_MaxApproveDays;
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>把这两个不同的地方都用基类的变量或者虚函数处理掉以后，就可以把approvePassedV函数搬到基类了：</p>
<pre class="line-numbers language-c++"><code class="language-c++">Employee.h:
#include "LeaveRequest.h"

class CEmployee{
public:
    CEmployee() :m_Superior(NULL), m_MaxApproveDays(0) {}

    void approveLeave(const CLeaveRequest *vLeaveRequest) const {
        if (vLeaveRequest->getLeaveDays() < getMaxApproveDays())
            approvePassedV(vLeaveRequest);
        else
            if (getSuperior())
                getSuperior()->approveLeave(vLeaveRequest);
    }

    void  setSuperior(CEmployee *vSuperior) { m_Superior = vSuperior; }
    const CEmployee* getSuperior() const { return m_Superior; }
    void  setMaxApproveDays(int vMaxApproveDays) { m_MaxApproveDays = vMaxApproveDays; }
    int   getMaxApproveDays() const { return m_MaxApproveDays; }

    virtual void approvePassedV(const CLeaveRequest *vLeaveRequest) const = 0;

private:
    const CEmployee *m_Superior;
    int m_MaxApproveDays;
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>子类会去分别重写这个虚函数：</p>
<pre class="line-numbers language-c++"><code class="language-c++">CTeamLeader.h:
#include <iostream>
#include "Employee.h"

class CTeamLeader : public CEmployee{
public:
    virtual void approvePassedV(const CLeaveRequest *vLeaveRequest) const override {
        std::cout << "The leave request of " << vLeaveRequest->getLeaveDays() << " days has been approved by team leader." << std::endl;
    }
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></iostream></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">CProjectLeader.h:
#include <iostream>
#include "Employee.h"

class CProjectLeader : public CEmployee {
public:
    virtual void approvePassedV(const CLeaveRequest *vLeaveRequest) const override {
        std::cout << "The leave request of " << vLeaveRequest->getLeaveDays() << " days has been approved by project leader." << std::endl;
    }
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></iostream></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">CHR.h:
#include <iostream>
#include "Employee.h"

class CHR : public CEmployee {
public:
    virtual void approvePassedV(const CLeaveRequest *vLeaveRequest) const override {
        std::cout << "The leave request of " << vLeaveRequest->getLeaveDays() << " days has been approved by HR." << std::endl;
    }
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></iostream></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">main.cpp:
#include "TeamLeader.h"
#include "ProjectLeader.h"
#include "HR.h"

int main() {
    CTeamLeader *pTeamLeader = new CTeamLeader;
    CProjectLeader *pProjectLeader = new CProjectLeader;
    CHR *pHR = new CHR;
    CLeaveRequest *pLeaveRequest = new CLeaveRequest(25);

    pTeamLeader->setSuperior(pProjectLeader);
    pProjectLeader->setSuperior(pHR);
    pTeamLeader->setMaxApproveDays(10);
    pProjectLeader->setMaxApproveDays(20);
    pHR->setMaxApproveDays(30);

    pTeamLeader->approveLeave(pLeaveRequest);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这样一来，就减少了子类里重复的代码，看起来更简洁，扩展性也更好。主要是要通过这个过程了解怎样把子类的相似代码抽象到父类中，体会抽象、多态的思想，尽可能用更少的代码去实现相同的功能。</p>
<p><font size="5" color="orange">另一个案例</font></p>
<hr>
<p>案例：某公司需要实现验证客户信息的功能（姓名、地址、电话号码、社保号码等），实现了一个抽象类来完成这些功能：</p>
<pre class="line-numbers language-c++"><code class="language-c++">class CInfoValidation {
    virtual bool isValidName() = 0;
    virtual bool isValidAddress() = 0;
    virtual bool isValidPhoneNumber() = 0;
    virtual bool isValidSSN() = 0;
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>为了加快开发进度，购买了别人的产品，其中提供了类CLegacyInfoValidation，但是只完成了部分功能，而且只有动态链接库和头文件，卖方没有提供源码：</p>
<pre class="line-numbers language-c++"><code class="language-c++">class CLegacyInfoValidation {
public:
    bool isNameValid();
    bool isAddressValid();
    bool isPhoneNumberValid();
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可见少了一个严重SSN的功能，而且卖方提供的接口和已有的抽象类接口不一致，那么应该怎么复用别人已经实现好的功能呢？</p>
<p><font size="5" color="orange">最码农的做法</font></p>
<hr>
<p>最直接也是最码农的做法，就是把自己抽象类的接口改成和别人接口形式一样，让自己的抽象类CInfoValidation 派生别人的类CLegacyInfoValidation ，再增加一个验证SSN的函数：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#include "LegacyInfoValidation.h"

class CInfoValidation : public CLegacyInfoValidation {
public:
    virtual bool isSSNValid() {...}
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这样就能在自己的抽象类里复用别人实现的其他3个功能了，但是这明显不符合开闭原则，改动了已有代码，导致程序中依赖原始接口的代码必须发生相应修改：</p>
<pre class="line-numbers language-c++"><code class="language-c++">bool ValidateInfo(CInfoValidation *vValidator) {
    if (!vValidator->isValidName())            return false;
    if (!vValidator->isValidAddress())        return false;
    if (!vValidator->isValidPhoneNumber())  return false;
    if (!vValidator->isValidSSN())            return false;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中vValidator调用的函数名都要改。。。</p>
<p><font size="5" color="orange">类适配器模式</font><br>别人实现了前三个验证，公司自己实现第四个验证，想要复用别人的函数完全可以靠继承嘛！上面最码农的做法也是靠继承来复用的，但是它改变了原有的类设计，我们完全可以不改嘛，在自己原有的isValidName函数里调用别人的isNameValid函数：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#include "LegacyInfoValidation.h"

class CInfoValidation :public CLegacyInfoValidation {
    virtual bool isValidName() {
        isNameValid();
    }
    virtual bool isValidAddress() {
        isAddressValid();
    }
    virtual bool isValidPhoneNumber() {
        isPhoneNumberValid();
    }
    virtual bool isValidSSN() = 0;
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这样程序中依赖原始接口的代码就不需要改变了（比如上面ValidateInfo函数中的方法调用就不需要改动了），但是这还是或多或少改动了原有的CInfoValidation 类代码。</p>
<p>如果想一点都不改动，只是增加新代码，也就是既想用CLegacyInfoValidation 类的三个方法，又想用CInfoValidation 类的isValidSSN方法，想用到两个类的方法，我们可以多重继承啊，派生一个新的类：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#include "InfoValidation.h"
#include "LegacyInfoValidation.h"

class CInfoValidationAdapter : public CInfoValidation, private CLegacyInfoValidation{
public:
    virtual bool isValidName() override {
        isNameValid();
    }

    virtual bool isValidAddress() override {
        isAddressValid();
    }

    virtual bool isValidPhoneNumber() override {
        isPhoneNumberValid();
    }

    virtual bool isValidSSN() {
        if(...)
            return true;
    }
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">class CInfoValidation {
    virtual bool isValidName() = 0;
    virtual bool isValidAddress() = 0;
    virtual bool isValidPhoneNumber() = 0;
    virtual bool isValidSSN() = 0;
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">class CLegacyInfoValidation {
public:
    bool isNameValid();
    bool isAddressValid();
    bool isPhoneNumberValid();
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>一样的，程序中依赖原始接口的代码还是不用改，比如之前的ValidateInfo方法中的函数调用，不过传入的CInfoValidation对象指针应该是来自新的CInfoValidationAdapter 类对象了，而不是原始的CInfoValidation 类对象。但是这基本上是在客户端才做出的改动，影响很小。</p>
<p>这就是类对象适配器：通过类继承来复用别的类的函数代码。</p>
<p><font size="5" color="orange">对象适配器模式</font></p>
<hr>
<p>上面的代码有个比较麻烦的地方，新的类是通过多重继承得到的，当程序变得复杂以后，这可能会带来一些不必要的麻烦，比如野指针、类爆炸等等。</p>
<p>可以通过合成复用原则来解决这个问题，不派生CLegacyInfoValidation 类，而是使用该类对象作为新的类的成员变量，通过变量对象来使用CLegacyInfoValidation 的函数：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#include "InfoValidation.h"
#include "LegacyInfoValidation.h"

class CInfoValidationAdapter : public CInfoValidation{
public:
    virtual bool isValidName() override {
        m_LegacyValidator.isNameValid();
    }

    virtual bool isValidAddress() override {
        m_LegacyValidator.isAddressValid();
    }

    virtual bool isValidPhoneNumber() override {
        m_LegacyValidator.isPhoneNumberValid();
    }

    virtual bool isValidSSN() {
        if (...)
            return true;
    }

private:
    CLegacyInfoValidation m_LegacyValidator;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>为什么使用CLegacyInfoValidation 类对象作为成员变量，而不使用CInfoValidation类对象，这个道理很简单啊~。因为程序里原本可能会有很多依赖原有抽象类CInfoValidation的地方，我们让新类派生自CInfoValidation类，就可以使用多态了，原来存在依赖的代码不用做任何修改，只是在传入对象参数的时候，实参由原来的CInfoValidation类对象，改成了现在的CInfoValidationAdapter 子类对象而已。</p>
<p>这就是对象适配器模式：通过合成复用（对象成员），来复用别的类的函数代码。</p>

            </div>

            <!-- Post Comments -->
            
    <!-- 使用 DISQUS_CLICK -->
<div id="disqus-comment">
    <div id="disqus_thread"></div>

<!-- add animation -->
<style>
	.disqus_click_btn {
            line-height: 30px;
            margin: 0;
            min-width: 50px;
            padding: 0 14px;
            display: inline-block;
            font-family: "Roboto", "Helvetica", "Arial", sans-serif;
            font-size: 14px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0;
            overflow: hidden;
            will-change: box-shadow;
            transition: box-shadow .2s cubic-bezier(.4, 0, 1, 1), background-color .2s cubic-bezier(.4, 0, .2, 1), color .2s cubic-bezier(.4, 0, .2, 1);
            outline: 0;
            cursor: pointer;
            text-decoration: none;
            text-align: center;
            vertical-align: middle;
            border: 0;
            background: rgba(158, 158, 158, .2);
            box-shadow: 0 2px 2px 0 rgba(0, 0, 0, .14), 0 3px 1px -2px rgba(0, 0, 0, .2), 0 1px 5px 0 rgba(0, 0, 0, .12);
            color: #fff;
            background-color: #7EC0EE;
            text-shadow: 0
        }
</style>
	
<div class="btn_click_load" id="disqus_bt"> 
    <button class="disqus_click_btn">点击查看评论</button>
</div>

<!--
<script type="text/javascript">
$('.btn_click_load').click(function() {
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'http-miccall-tech'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    document.getElementById('disqus_bt').style.display = "none";
});
</script>
-->
<script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://yoursite.com/2017/08/31/老张培训笔记第五课/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = 'http://yoursite.com/2017/08/31/老张培训笔记第五课/'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
</script>

<script type="text/javascript">
    $('.btn_click_load').click(function() {  //click to load comments
        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document;
            var s = d.createElement('script');
            s.src = '//http-miccall-tech.disqus.com/embed.js';
            s.setAttribute('data-timestamp', + new Date());
            (d.head || d.body).appendChild(s);
        })();
        $('.btn_click_load').css('display','none');
    });
</script>
</div>
<style>
    #disqus-comment{
        background-color: #eee;
        padding: 2pc;
    }
</style>


        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
                <li>Design: <a href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
            </ul>
            
            	<span id="busuanzi_container_site_pv">2019总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			
        </div>
    </div>
</body>



 	
</html>
