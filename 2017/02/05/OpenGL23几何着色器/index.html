<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>OpenGL23：几何着色器 | Elays&#39;Blog</title>
  <meta name="author" content="Elay">
  
  <meta name="description" content="Elay">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="OpenGL23：几何着色器"/>
  <meta property="og:site_name" content="Elays&#39;Blog"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Elays&#39;Blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">Elays&#39;Blog</a></h1>
  <h2><a href="/">你是天地生的，美得超越人形</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">主页</a></li>
    
      <li><a href="/archives">所有文章</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2017-02-05T08:44:33.000Z"><a href="/2017/02/05/OpenGL23几何着色器/">2017-02-05</a></time>
      
      
  
    <h1 class="title">OpenGL23：几何着色器</h1>
  

    </header>
    <div class="entry">
      
        <p>在顶点和片段着色器之间有一个可选的着色器，叫做几何着色器（Geometry Shader）。<br><a id="more"></a></p>
<p><font size="5" color="orange">几何着色器</font><br>几何着色器以一个或多个基本图形的顶点作为输入，比如一个点或者三角形。几何着色器可以将这些顶点转变为完全不同的基本图形，可以生成比原来多得多的顶点，再把这些顶点发送到下一个着色器阶段。</p>
<p>我们直接来看一个几何着色器的例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#version 330 core</span></div><div class="line">layout (points) in;</div><div class="line">layout (line_strip, max_vertices = <span class="number">2</span>) out;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    gl_Position = gl_in[<span class="number">0</span>].gl_Position + vec4(<span class="number">-0.1</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);</div><div class="line">    EmitVertex();</div><div class="line"></div><div class="line">    gl_Position = gl_in[<span class="number">0</span>].gl_Position + vec4(<span class="number">0.1</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);</div><div class="line">    EmitVertex();</div><div class="line"></div><div class="line">    EndPrimitive();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在几何着色器中，我们需要声明输入的基本图形（primitive）类型，这个输入是我们从顶点着色器中接收到的。需要在in关键字前面声明一个layout标识符，括号里表示可以从一个顶点着色器接收的基本图形。可以有以下基本图形值：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148628384767.png" alt=""><br>这是我们能够给渲染函数的几乎所有的基本图形。如果我们在主程序中选择以<code>GL_TRIANGLES</code>方式绘制顶点，我们就要把这里的输入修饰符设置为triangles。括号里的数字代表对应基本图形的最少顶点数。</p>
<p>当我们需要指定几何着色器所输出的基本图形类型时，我们就在out关键字前面加一个layout标识符。和输入layout标识符一样，输出的layout标识符也可以接受以下基本图形值：</p>
<ul>
<li>points</li>
<li>line_strip</li>
<li>triangle_strip</li>
</ul>
<p>使用这三个输出修饰符，我们可以从输入的基本图形创建任何我们想要的形状。为了生成一个三角形，我们定义一个<code>triangle_strip</code>作为输出标识符，然后在其main函数里输出3个顶点，就能够输出一个三角形。同时，我们需要指定几何着色器能够输出的顶点数量的最大值（如果超出了这个数值，OpenGL就会忽略剩下的顶点），如上面的<code>line_strip, max_vertices=2</code>，表示我们将使用2个顶点输出一个line_strip。<br>【注】：</p>
<ul>
<li>line_strip就是首位相连的线条。线条是把多个点链接起来表示出一个连续的线，它最少有两个点来组成。后一个点在前一个新渲染的点后面渲染。line_strip如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148628384832.png" alt=""><br>在上面的着色器里，当然不能得到上图的线条，因为输出顶点数量的最大值被我们设置为了2，只能输出一个线段。</li>
</ul>
<p>顶点着色器的数据是通过什么传递到几何着色器的呢？GLSL为我们提供了一个内置变量<code>gl_in</code>，它的内部像这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">in gl_Vertex</div><div class="line">&#123;</div><div class="line">    vec4 gl_Position;</div><div class="line">    <span class="keyword">float</span> gl_PointSize;</div><div class="line">    <span class="keyword">float</span> gl_ClipDistance[];</div><div class="line">&#125; gl_in[];</div></pre></td></tr></table></figure></p>
<p>它被声明为一个借口块，表示从顶点着色器接收的顶点数组。其中就包含了与顶点着色器输出相似的位置向量<code>gl_Position</code>。要注意<code>gl_in</code>是一个数组，因为几何着色器一次接收一个基本图形的所有顶点来填充<code>gl_in</code>数组，作为它的输入。</p>
<p>使用来自顶点着色器的顶点数据，我们可以开始输出新的顶点数据了。这需要通过<code>EmitVertex</code>函数（输出一个顶点）和<code>EndPrimitive</code>函数（结束基本图形）来实现。<br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">使用几何着色器把点转化为线</font><br>这里我们用一个demo：在几个着色器里接收一些点的输入，转化为线条输出，来完整地使用一次几何着色器。</p>
<p>首先我们在顶点着色器里定义4个顶点的顶点数据：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">GLfloat pointsVertices[] = &#123;</div><div class="line">	<span class="comment">//位置坐标     </span></div><div class="line">	<span class="number">0.5f</span>, <span class="number">0.5f</span>,</div><div class="line">	<span class="number">0.5f</span>,<span class="number">-0.5</span>f,</div><div class="line">   <span class="number">-0.5</span>f,<span class="number">-0.5</span>f,</div><div class="line">   <span class="number">-0.5</span>f, <span class="number">0.5f</span>,</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//点的pointsVAO和数据解析</span></div><div class="line">GLuint pointsVAO, pointsVBO;</div><div class="line">glGenVertexArrays(<span class="number">1</span>, &amp;pointsVAO);</div><div class="line">glBindVertexArray(pointsVAO);</div><div class="line">glGenBuffers(<span class="number">1</span>, &amp;pointsVBO);</div><div class="line">glBindBuffer(GL_ARRAY_BUFFER, pointsVBO);</div><div class="line">glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(pointsVertices), &amp;pointsVertices, GL_STATIC_DRAW);</div><div class="line">glEnableVertexAttribArray(<span class="number">0</span>);</div><div class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">2</span> * <span class="keyword">sizeof</span>(GL_FLOAT), (GLvoid*)<span class="number">0</span>);</div><div class="line">glBindVertexArray(<span class="number">0</span>);</div></pre></td></tr></table></figure></p>
<p>然后是我们的几何着色器（写在points.geometry）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#version 330 core</span></div><div class="line">layout (points) in;</div><div class="line">layout (line_strip,max_vertices=<span class="number">2</span>) out;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	gl_Position = gl_in[<span class="number">0</span>].gl_Position + vec4(<span class="number">-0.1</span>f,<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>);</div><div class="line">	EmitVertex();</div><div class="line">	gl_Position = gl_in[<span class="number">0</span>].gl_Position + vec4(<span class="number">0.1f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>);</div><div class="line">	EmitVertex();</div><div class="line">	EndPrimitive();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在该几何着色器里，我们接收的输入是点这种基本图形的顶点，输出是线条这种基本图形，同时指定输出的图形最多由两个顶点组成。在main函数里，我们先把接收到的第一个顶点向x方向移动-0.1，把得到的新顶点用<code>EmitVertex</code>函数发送出去；接着再把第一个顶点向x方向移动0.1，把得到的新顶点用<code>EmitVertex</code>函数发送出去，两个顶点发完了，我们的线条这个基本图形到此结束。注意，由于这里几何着色器的输入基本图形是点points，所以它每次得到的来自顶点着色器的输入顶点只有1个，而不是4个，这4个顶点是分4次传到几何着色器里的；如果输入基本图形是triangles，那么几何着色器每次得到的顶点个数就是3个。</p>
<p>当然，不要忘了，我们的着色器类得改改了。得把几何着色器也加进来，编译后附加到着色器程序对象上：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> GLchar* geometryShaderSource = GetShaderSourceFromFile(geometryPath);</div><div class="line">GLuint geometryShader;</div><div class="line">geometryShader = glCreateShader(GL_GEOMETRY_SHADER);</div><div class="line">glShaderSource(geometryShader, <span class="number">1</span>, &amp;geometryShaderSource, <span class="literal">NULL</span>);</div><div class="line">glCompileShader(geometryShader);</div><div class="line">glGetShaderiv(geometryShader, GL_COMPILE_STATUS, &amp;success);</div><div class="line"><span class="keyword">if</span> (!success) &#123;</div><div class="line">	glGetShaderInfoLog(geometryShader, <span class="number">512</span>, <span class="literal">NULL</span>, infolog);</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"geometry shader compilation failed"</span> &lt;&lt; infolog &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line">glAttachShader(shaderProgram, geometryShader);</div></pre></td></tr></table></figure></p>
<p>然后在主程序里定义着色器类对象：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//定义自定义着色器类shader的对象</span></div><div class="line"><span class="function">shader <span class="title">points_shader</span><span class="params">(<span class="string">"points.vertex"</span>, <span class="string">"points.fragment"</span>, <span class="string">"points.geometry"</span>)</span></span>;</div></pre></td></tr></table></figure></p>
<p>最后我们在渲染循环里绘制4个顶点：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">points_shader.Use();</div><div class="line">glBindVertexArray(pointsVAO);</div><div class="line">glDrawArrays(GL_POINTS, <span class="number">0</span>, <span class="number">4</span>);</div><div class="line">glBindBuffer(GL_UNIFORM_BUFFER, <span class="number">0</span>);</div></pre></td></tr></table></figure></p>
<p>编译运行后的结果如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148628384876.png" alt=""><br>还是很神奇的！因为我们渲染时是用的<code>GL_POINTS</code>，但是却能够根据这些点绘制出几个线条，这都是几何着色器的功劳。<br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">使用几何着色器把点画成房子</font><br>绘制点和线好像挺枯燥的，所以我们将在每个点上使用几何着色器绘制一个房子。它是由几个三角形构成的，如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148628384921.png" alt=""><br>在OpenGL里这样挨在一起的三角形，用trangle_strip绘制起来更搞笑，因为它所需要的顶点更少。所以我们把几何着色器里的输出基本图形设置为<code>triangle_strip</code>。这个房子总共有5个顶点，使用<code>triangle_strip</code>时，每3个毗邻的顶点都会构成一个三角形，所以得到这些三角形：（1,2,3）、（2,3,4）、（3,4,5）。其实有N个顶点就能得到N-2个三角形。注意，上图的房子里只有中间的蓝色点才是来自顶点着色器的输入，而房子的5个顶点都是根据这个蓝色点，在几何着色器里生成的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#version 330 core</span></div><div class="line">layout (points) in;</div><div class="line">layout (triangle_strip,max_vertices=<span class="number">5</span>) out;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	gl_Position = gl_in[<span class="number">0</span>].gl_Position + vec4(<span class="number">-0.2</span>f, <span class="number">-0.2</span>f, <span class="number">0.0f</span>, <span class="number">0.0f</span>);<span class="comment">// 1:左下角</span></div><div class="line">    EmitVertex();</div><div class="line">    gl_Position = gl_in[<span class="number">0</span>].gl_Position + vec4( <span class="number">0.2f</span>, <span class="number">-0.2</span>f, <span class="number">0.0f</span>, <span class="number">0.0f</span>);<span class="comment">// 2:右下角</span></div><div class="line">    EmitVertex();</div><div class="line">    gl_Position = gl_in[<span class="number">0</span>].gl_Position + vec4(<span class="number">-0.2</span>f,  <span class="number">0.2f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);<span class="comment">// 3:左上</span></div><div class="line">    EmitVertex();</div><div class="line">    gl_Position = gl_in[<span class="number">0</span>].gl_Position + vec4( <span class="number">0.2f</span>,  <span class="number">0.2f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);<span class="comment">// 4:右上</span></div><div class="line">    EmitVertex();</div><div class="line">    gl_Position = gl_in[<span class="number">0</span>].gl_Position + vec4( <span class="number">0.0f</span>,  <span class="number">0.4f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);<span class="comment">// 5:屋顶</span></div><div class="line">    EmitVertex();</div><div class="line">    EndPrimitive();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>因为要从一个输入顶点变成5个顶点连线构成的房子，所以几何着色器的输出需要加上标识符<code>layout (triangle_strip, max_vertices = 5) out;</code>。</p>
<p>顶点着色器如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#version 330 core</span></div><div class="line">layout (location=<span class="number">0</span>) in vec2 position;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	gl_Position = vec4(position, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>像素着色器如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#version 330 core</span></div><div class="line">out vec4 color;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	color= vec4(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>编译运行后的结果如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148628384965.png" alt=""><br>这4个房子都一个颜色，现在我们让每个房子都有不同的颜色。我们给每个顶点再加上一个颜色属性，同时更新对顶点属性数据的解析：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">GLfloat pointsVertices[] = &#123;</div><div class="line">	<span class="comment">//位置坐标   //颜色</span></div><div class="line">	<span class="number">0.5f</span>, <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,</div><div class="line">	<span class="number">0.5f</span>,<span class="number">-0.5</span>f,  <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,</div><div class="line">   <span class="number">-0.5</span>f,<span class="number">-0.5</span>f,  <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>,</div><div class="line">   <span class="number">-0.5</span>f, <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//点的pointsVAO和数据解析</span></div><div class="line">GLuint pointsVAO, pointsVBO;</div><div class="line">glGenVertexArrays(<span class="number">1</span>, &amp;pointsVAO);</div><div class="line">glBindVertexArray(pointsVAO);</div><div class="line">glGenBuffers(<span class="number">1</span>, &amp;pointsVBO);</div><div class="line">glBindBuffer(GL_ARRAY_BUFFER, pointsVBO);</div><div class="line">glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(pointsVertices), &amp;pointsVertices, GL_STATIC_DRAW);</div><div class="line">glEnableVertexAttribArray(<span class="number">0</span>);</div><div class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">5</span> * <span class="keyword">sizeof</span>(GL_FLOAT), (GLvoid*)<span class="number">0</span>);</div><div class="line">glEnableVertexAttribArray(<span class="number">1</span>);</div><div class="line">glVertexAttribPointer(<span class="number">1</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">5</span> * <span class="keyword">sizeof</span>(GL_FLOAT), (GLvoid*)(<span class="number">2</span> * <span class="keyword">sizeof</span>(GL_FLOAT)));</div><div class="line">glBindVertexArray(<span class="number">0</span>);</div></pre></td></tr></table></figure></p>
<p>接着在顶点着色器中，增加输入变量来接收这个颜色属性，并且我们使用接口块来把顶点颜色发送给几何着色器：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#version 330 core</span></div><div class="line">layout (location=<span class="number">0</span>) in vec2 position;</div><div class="line">layout (location=<span class="number">1</span>) in vec3 color;</div><div class="line"></div><div class="line">out VS_OUT&#123;</div><div class="line">	vec3 color;</div><div class="line">&#125; vs_out;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	gl_Position = vec4(position, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</div><div class="line">	vs_out.color = color;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当然也可以不使用接口块，直接使用<code>out vec3 color</code>也是可以的。</p>
<p>接下里需要在几何着色器中声明同样的接口块（块名相同，块变量可以不同名）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">in VS_OUT&#123;</div><div class="line">	vec3 color;</div><div class="line">&#125; gs_in[];</div></pre></td></tr></table></figure></p>
<p>注意这里的块变量是一个数组，这是因为几何着色器一次接收的是组成基本图形的所有顶点，可能会有多个顶点被一次传到几何着色器里（现在我们是<code>layout (points) in;</code>，只有一个顶点被传过来，即<code>gs_in[0]</code>）。</p>
<p>我们最后需要把颜色输出给像素着色器，所以还需要在几何着色器里声明一个输出颜色向量：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">out vec3 fcolor;</div></pre></td></tr></table></figure></p>
<p>接下来我们在几何着色器的main函数里，让这个输出颜色向量等于来自顶点着色器的颜色向量：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	fcolor = gs_in[<span class="number">0</span>].color;</div><div class="line">	gl_Position = gl_in[<span class="number">0</span>].gl_Position + vec4(<span class="number">-0.2</span>f, <span class="number">-0.2</span>f, <span class="number">0.0f</span>, <span class="number">0.0f</span>);<span class="comment">// 1:左下角</span></div><div class="line">    EmitVertex();</div><div class="line">    gl_Position = gl_in[<span class="number">0</span>].gl_Position + vec4( <span class="number">0.2f</span>, <span class="number">-0.2</span>f, <span class="number">0.0f</span>, <span class="number">0.0f</span>);<span class="comment">// 2:右下角</span></div><div class="line">    EmitVertex();</div><div class="line">    gl_Position = gl_in[<span class="number">0</span>].gl_Position + vec4(<span class="number">-0.2</span>f,  <span class="number">0.2f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);<span class="comment">// 3:左上</span></div><div class="line">    EmitVertex();</div><div class="line">    gl_Position = gl_in[<span class="number">0</span>].gl_Position + vec4( <span class="number">0.2f</span>,  <span class="number">0.2f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);<span class="comment">// 4:右上</span></div><div class="line">    EmitVertex();</div><div class="line">    gl_Position = gl_in[<span class="number">0</span>].gl_Position + vec4( <span class="number">0.0f</span>,  <span class="number">0.4f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);<span class="comment">// 5:屋顶</span></div><div class="line">    EmitVertex();</div><div class="line">    EndPrimitive();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由于房子的5个顶点都是相同的颜色，都等于对应的顶点着色器的输出颜色，所以只需要做一次<code>fcolor = gs_in[0].color;</code>即可，后面几何着色器使用<code>EmitVertex</code>函数发送顶点时，都会包含最新的out变量<code>fcolor</code>的值。</p>
<p>在像素着色器里，片段颜色应该是等于接收到的顶点颜色了，房子内部的点就由像素着色器自己去插值了：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#version 330 core</span></div><div class="line">in vec3 fcolor;</div><div class="line">out vec4 color;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	color= vec4(fcolor, <span class="number">1.0f</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>编译运行后的结果如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148628385008.png" alt=""><br>如果我们还想给房子的屋顶上加点白色，就像落了雪一样，其实也就是说房子的5个顶点不是同一个颜色了，屋顶顶点变成了白色。我们只需要做如下改变即可：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	fcolor = gs_in[<span class="number">0</span>].color;</div><div class="line">	gl_Position = gl_in[<span class="number">0</span>].gl_Position + vec4(<span class="number">-0.2</span>f, <span class="number">-0.2</span>f, <span class="number">0.0f</span>, <span class="number">0.0f</span>);<span class="comment">// 1:左下角</span></div><div class="line">    EmitVertex();</div><div class="line">    gl_Position = gl_in[<span class="number">0</span>].gl_Position + vec4( <span class="number">0.2f</span>, <span class="number">-0.2</span>f, <span class="number">0.0f</span>, <span class="number">0.0f</span>);<span class="comment">// 2:右下角</span></div><div class="line">    EmitVertex();</div><div class="line">    gl_Position = gl_in[<span class="number">0</span>].gl_Position + vec4(<span class="number">-0.2</span>f,  <span class="number">0.2f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);<span class="comment">// 3:左上</span></div><div class="line">    EmitVertex();</div><div class="line">    gl_Position = gl_in[<span class="number">0</span>].gl_Position + vec4( <span class="number">0.2f</span>,  <span class="number">0.2f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);<span class="comment">// 4:右上</span></div><div class="line">    EmitVertex();</div><div class="line">    gl_Position = gl_in[<span class="number">0</span>].gl_Position + vec4( <span class="number">0.0f</span>,  <span class="number">0.4f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);<span class="comment">// 5:屋顶</span></div><div class="line">    fcolor = vec3(<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>);</div><div class="line">	EmitVertex();</div><div class="line">    EndPrimitive();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>让屋顶顶点的输出颜色等于白色即可。</p>
<p>编译运行后的结果如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148628385054.png" alt=""><br>下面给出所有源码：<br>顶点着色器（写在points.vertex中）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#version 330 core</span></div><div class="line">layout (location=<span class="number">0</span>) in vec2 position;</div><div class="line">layout (location=<span class="number">1</span>) in vec3 color;</div><div class="line"></div><div class="line">out VS_OUT&#123;</div><div class="line">	vec3 color;</div><div class="line">&#125; vs_out;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	gl_Position = vec4(position, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</div><div class="line">	vs_out.color = color;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>几何着色器（写在points.geometry中）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#version 330 core</span></div><div class="line">layout (points) in;</div><div class="line">layout (triangle_strip,max_vertices=<span class="number">5</span>) out;</div><div class="line"></div><div class="line">in VS_OUT&#123;</div><div class="line">	vec3 color;</div><div class="line">&#125; gs_in[];</div><div class="line">out vec3 fcolor;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	fcolor = gs_in[<span class="number">0</span>].color;</div><div class="line">	gl_Position = gl_in[<span class="number">0</span>].gl_Position + vec4(<span class="number">-0.2</span>f, <span class="number">-0.2</span>f, <span class="number">0.0f</span>, <span class="number">0.0f</span>);<span class="comment">// 1:左下角</span></div><div class="line">    EmitVertex();</div><div class="line">    gl_Position = gl_in[<span class="number">0</span>].gl_Position + vec4( <span class="number">0.2f</span>, <span class="number">-0.2</span>f, <span class="number">0.0f</span>, <span class="number">0.0f</span>);<span class="comment">// 2:右下角</span></div><div class="line">    EmitVertex();</div><div class="line">    gl_Position = gl_in[<span class="number">0</span>].gl_Position + vec4(<span class="number">-0.2</span>f,  <span class="number">0.2f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);<span class="comment">// 3:左上</span></div><div class="line">    EmitVertex();</div><div class="line">    gl_Position = gl_in[<span class="number">0</span>].gl_Position + vec4( <span class="number">0.2f</span>,  <span class="number">0.2f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);<span class="comment">// 4:右上</span></div><div class="line">    EmitVertex();</div><div class="line">    gl_Position = gl_in[<span class="number">0</span>].gl_Position + vec4( <span class="number">0.0f</span>,  <span class="number">0.4f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);<span class="comment">// 5:屋顶</span></div><div class="line">    fcolor = vec3(<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>);</div><div class="line">	EmitVertex();</div><div class="line">    EndPrimitive();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>像素着色器（写在points.fragment中）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#version 330 core</span></div><div class="line">in vec3 fcolor;</div><div class="line">out vec4 color;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	color= vec4(fcolor, <span class="number">1.0f</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>着色器类头文件（写在shader.h中）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> GLEW_STATIC</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GL/glew.h&gt;</span>  <span class="comment">//包含glew来获取OpenGL头文件，否则gl函数都不可用</span></span></div><div class="line"></div><div class="line"><span class="keyword">class</span> shader</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="comment">//着色器程序对象</span></div><div class="line">	GLuint shaderProgram;</div><div class="line">	<span class="comment">//构造函数，创建编译顶点着色器、像素着色器，链接着色器程序对象</span></div><div class="line">	shader(<span class="keyword">const</span> GLchar* vertexPath, <span class="keyword">const</span> GLchar* fragmentPath, <span class="keyword">const</span> GLchar* geometryPath = <span class="literal">nullptr</span>);</div><div class="line">	<span class="comment">//激活当前shader程序对象shaderProgram，供主函数调用</span></div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Use</span><span class="params">()</span></span>;</div><div class="line">	<span class="comment">//从指定路径的文件中读取着色器源码</span></div><div class="line">	<span class="function"><span class="keyword">const</span> GLchar* <span class="title">GetShaderSourceFromFile</span><span class="params">(<span class="keyword">const</span> GLchar* shaderPath)</span></span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>着色器类源文件（写在shader.cpp中）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"shader.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></div><div class="line">shader::shader(<span class="keyword">const</span> GLchar* vertexPath, <span class="keyword">const</span> GLchar* fragmentPath, <span class="keyword">const</span> GLchar* geometryPath) &#123;</div><div class="line"></div><div class="line"><span class="comment">//#define GLEW_STATIC</span></div><div class="line"><span class="comment">//#include &lt;GL/glew.h&gt;</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLFW/glfw3.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="comment">//构造函数，创建编译顶点着色器、像素着色器，链接着色器程序对象</span></div><div class="line">	<span class="keyword">const</span> GLchar* vertexShaderSource = GetShaderSourceFromFile(vertexPath);</div><div class="line">	<span class="keyword">const</span> GLchar* fragmentShaderSource = GetShaderSourceFromFile(fragmentPath);</div><div class="line"></div><div class="line">	GLuint vertexShader;</div><div class="line">	vertexShader = glCreateShader(GL_VERTEX_SHADER);</div><div class="line">	glShaderSource(vertexShader, <span class="number">1</span>, &amp;vertexShaderSource, <span class="literal">NULL</span>);</div><div class="line">	GLint success;</div><div class="line">	GLchar infolog[<span class="number">512</span>];</div><div class="line">	glCompileShader(vertexShader);</div><div class="line">	glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success);</div><div class="line">	<span class="keyword">if</span> (!success) &#123;</div><div class="line">		glGetShaderInfoLog(vertexShader, <span class="number">512</span>, <span class="literal">NULL</span>, infolog);</div><div class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"vertex shader compilation failed"</span> &lt;&lt; infolog &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	GLuint fragementShader;</div><div class="line">	fragementShader = glCreateShader(GL_FRAGMENT_SHADER);</div><div class="line">	glShaderSource(fragementShader, <span class="number">1</span>, &amp;fragmentShaderSource, <span class="literal">NULL</span>);</div><div class="line">	glCompileShader(fragementShader);</div><div class="line">	glGetShaderiv(fragementShader, GL_COMPILE_STATUS, &amp;success);</div><div class="line">	<span class="keyword">if</span> (!success) &#123;</div><div class="line">		glGetShaderInfoLog(fragementShader, <span class="number">512</span>, <span class="literal">NULL</span>, infolog);</div><div class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"fragment shader compilation failed"</span> &lt;&lt; infolog &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	shaderProgram = glCreateProgram();</div><div class="line">	glAttachShader(shaderProgram, vertexShader);</div><div class="line">	glAttachShader(shaderProgram, fragementShader);</div><div class="line">	<span class="keyword">if</span> (geometryPath != <span class="literal">nullptr</span>) &#123;</div><div class="line">		<span class="keyword">const</span> GLchar* geometryShaderSource = GetShaderSourceFromFile(geometryPath);</div><div class="line">		GLuint geometryShader;</div><div class="line">		geometryShader = glCreateShader(GL_GEOMETRY_SHADER);</div><div class="line">		glShaderSource(geometryShader, <span class="number">1</span>, &amp;geometryShaderSource, <span class="literal">NULL</span>);</div><div class="line">		glCompileShader(geometryShader);</div><div class="line">		glGetShaderiv(geometryShader, GL_COMPILE_STATUS, &amp;success);</div><div class="line">		<span class="keyword">if</span> (!success) &#123;</div><div class="line">			glGetShaderInfoLog(geometryShader, <span class="number">512</span>, <span class="literal">NULL</span>, infolog);</div><div class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"geometry shader compilation failed"</span> &lt;&lt; infolog &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">		&#125;</div><div class="line">		glAttachShader(shaderProgram, geometryShader);</div><div class="line">	&#125;</div><div class="line">	glLinkProgram(shaderProgram);</div><div class="line">	glGetProgramiv(shaderProgram, GL_LINK_STATUS, &amp;success);</div><div class="line">	<span class="keyword">if</span> (!success) &#123;</div><div class="line">		glGetProgramInfoLog(shaderProgram, <span class="number">512</span>, <span class="literal">NULL</span>, infolog);</div><div class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"shader program linking failed"</span> &lt;&lt; infolog &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">	&#125;</div><div class="line">	glDeleteShader(vertexShader);</div><div class="line">	glDeleteShader(fragementShader);</div><div class="line">&#125;</div><div class="line"><span class="comment">//激活当前shader程序对象shaderProgram，供主函数调用</span></div><div class="line"><span class="keyword">void</span> shader::Use() &#123;</div><div class="line">	glUseProgram(shaderProgram);</div><div class="line">&#125;</div><div class="line"><span class="comment">//从指定路径的文件中读取着色器源码</span></div><div class="line"><span class="keyword">const</span> GLchar* shader::GetShaderSourceFromFile(<span class="keyword">const</span> GLchar* shaderPath) &#123;</div><div class="line">	<span class="comment">//以二进制方式打开指定路径的文件</span></div><div class="line">	<span class="function">ifstream <span class="title">fin</span><span class="params">(shaderPath, ios::binary)</span></span>;</div><div class="line">	<span class="comment">//检测是否成功打开文件</span></div><div class="line">	<span class="keyword">if</span> (!fin) &#123;</div><div class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Cannot open input file"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//将读指针设置到文件尾</span></div><div class="line">	fin.seekg(<span class="number">0</span>, ios::end);</div><div class="line">	<span class="comment">//读出当前文件位置，以获取文件长度</span></div><div class="line">	<span class="keyword">int</span> length = fin.tellg();</div><div class="line">	<span class="comment">//定义长度为length+1的字符串来存储文件内容</span></div><div class="line">	<span class="keyword">char</span>* shaderSource = <span class="keyword">new</span> <span class="keyword">char</span>[length + <span class="number">1</span>];</div><div class="line">	<span class="comment">//重新将读指针设置到文件头</span></div><div class="line">	fin.seekg(<span class="number">0</span>, ios::beg);</div><div class="line">	<span class="comment">//读出整个文件</span></div><div class="line">	fin.read(shaderSource, length);</div><div class="line">	<span class="comment">//给字符串末尾加上字符串结束符'\0'</span></div><div class="line">	shaderSource[length] = <span class="string">'\0'</span>;</div><div class="line">	fin.close();</div><div class="line">	<span class="keyword">return</span> shaderSource;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>主程序：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"shader.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"TextureLoader.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cubemapLoader.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"camera.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="comment">//GLEW</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> GLEW_STATIC</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GL/glew.h&gt;</span></span></div><div class="line"><span class="comment">//GLFW</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLFW/glfw3.h&gt;</span></span></div><div class="line"><span class="comment">//SOIL</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;SOIL/SOIL.h&gt;</span></span></div><div class="line"><span class="comment">//GLM</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLM/glm/glm.hpp&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLM/glm/gtc/matrix_transform.hpp&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLM/glm/gtc/type_ptr.hpp&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> glm;</div><div class="line"><span class="comment">//窗口尺寸</span></div><div class="line"><span class="keyword">const</span> GLuint WIDTH = <span class="number">800</span>, HEIGHT = <span class="number">600</span>;</div><div class="line"><span class="keyword">bool</span> keys[<span class="number">1024</span>];</div><div class="line"><span class="comment">//当前帧与上一帧的时间差</span></div><div class="line">GLfloat deltaTime = <span class="number">0.0f</span>;</div><div class="line"><span class="comment">//上一帧开始的时间</span></div><div class="line">GLfloat lastTime = <span class="number">0.0f</span>;</div><div class="line"><span class="comment">//上一帧鼠标位置</span></div><div class="line">GLfloat lastCursorX = WIDTH / <span class="number">2</span>;</div><div class="line">GLfloat lastCursorY = HEIGHT / <span class="number">2</span>;</div><div class="line"><span class="comment">//定义摄像机类Camera的对象</span></div><div class="line">Camera mycamera;</div><div class="line"><span class="comment">//函数声明</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">key_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">int</span> key, <span class="keyword">int</span> scancode, <span class="keyword">int</span> action, <span class="keyword">int</span> mode)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_movement</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">cursor_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">double</span> xpos, <span class="keyword">double</span> ypos)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">scroll_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">double</span> xoffset, <span class="keyword">double</span> yoffser)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="comment">//初始化GLFW</span></div><div class="line">	glfwInit();</div><div class="line">	<span class="comment">//GLFW配置</span></div><div class="line">	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>); <span class="comment">//主版本号</span></div><div class="line">	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>); <span class="comment">//次版本号</span></div><div class="line">	glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE); <span class="comment">// 核心开发模式</span></div><div class="line">	glfwWindowHint(GLFW_RESIZABLE, GL_FALSE); <span class="comment">//窗口尺寸不可变</span></div><div class="line">											  <span class="comment">//创建能够使用GLFW函数的窗口对象（指针）</span></div><div class="line">	GLFWwindow* window = glfwCreateWindow(WIDTH, HEIGHT, <span class="string">"LearnOpenGL"</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</div><div class="line">	<span class="keyword">if</span> (window == <span class="literal">NULL</span>) &#123;</div><div class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Failed to create GLFW window"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">		glfwTerminate();</div><div class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//创建窗口环境</span></div><div class="line">	glfwMakeContextCurrent(window);</div><div class="line">	<span class="comment">//注册按键回调函数</span></div><div class="line">	glfwSetKeyCallback(window, key_callback);</div><div class="line">	<span class="comment">//注册鼠标位置回调函数</span></div><div class="line">	glfwSetCursorPosCallback(window, cursor_callback);</div><div class="line">	<span class="comment">//隐藏鼠标</span></div><div class="line">	<span class="comment">//glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);</span></div><div class="line">	<span class="comment">//注册鼠标滚轮回调函数</span></div><div class="line">	glfwSetScrollCallback(window, scroll_callback);</div><div class="line">	<span class="comment">//初始化GLEW</span></div><div class="line">	glewExperimental = GL_TRUE; <span class="comment">//保证使用现代技术管理OpenGL机能</span></div><div class="line">	<span class="keyword">if</span> (glewInit() != GLEW_OK) &#123;</div><div class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Failed to initialize GLEW"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//设置渲染窗口位置大小</span></div><div class="line">	<span class="keyword">int</span> width, height;</div><div class="line">	glfwGetFramebufferSize(window, &amp;width, &amp;height);</div><div class="line">	glViewport(<span class="number">0</span>, <span class="number">0</span>, width, height);</div><div class="line">	</div><div class="line">	GLfloat pointsVertices[] = &#123;</div><div class="line">		<span class="comment">//位置坐标   //颜色</span></div><div class="line">		<span class="number">0.5f</span>, <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,</div><div class="line">		<span class="number">0.5f</span>,<span class="number">-0.5</span>f,  <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,</div><div class="line">	   <span class="number">-0.5</span>f,<span class="number">-0.5</span>f,  <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>,</div><div class="line">	   <span class="number">-0.5</span>f, <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span></div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	<span class="comment">//点的pointsVAO和数据解析</span></div><div class="line">	GLuint pointsVAO, pointsVBO;</div><div class="line">	glGenVertexArrays(<span class="number">1</span>, &amp;pointsVAO);</div><div class="line">	glBindVertexArray(pointsVAO);</div><div class="line">	glGenBuffers(<span class="number">1</span>, &amp;pointsVBO);</div><div class="line">	glBindBuffer(GL_ARRAY_BUFFER, pointsVBO);</div><div class="line">	glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(pointsVertices), &amp;pointsVertices, GL_STATIC_DRAW);</div><div class="line">	glEnableVertexAttribArray(<span class="number">0</span>);</div><div class="line">	glVertexAttribPointer(<span class="number">0</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">5</span> * <span class="keyword">sizeof</span>(GL_FLOAT), (GLvoid*)<span class="number">0</span>);</div><div class="line">	glEnableVertexAttribArray(<span class="number">1</span>);</div><div class="line">	glVertexAttribPointer(<span class="number">1</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">5</span> * <span class="keyword">sizeof</span>(GL_FLOAT), (GLvoid*)(<span class="number">2</span> * <span class="keyword">sizeof</span>(GL_FLOAT)));</div><div class="line">	glBindVertexArray(<span class="number">0</span>);</div><div class="line"></div><div class="line">	<span class="comment">//定义自定义着色器类shader的对象</span></div><div class="line">	<span class="function">shader <span class="title">points_shader</span><span class="params">(<span class="string">"points.vertex"</span>, <span class="string">"points.fragment"</span>, <span class="string">"points.geometry"</span>)</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">//渲染循环（游戏循环）</span></div><div class="line">	<span class="keyword">while</span> (!glfwWindowShouldClose(window)) &#123;</div><div class="line">		<span class="comment">//计算deltaTime</span></div><div class="line">		GLfloat currentTime = glfwGetTime();</div><div class="line">		deltaTime = currentTime - lastTime;</div><div class="line">		lastTime = currentTime;</div><div class="line">		glfwPollEvents(); <span class="comment">//检测是否有事件被触发（如按键按下、鼠标移动）</span></div><div class="line">		glClearColor(<span class="number">0.3f</span>, <span class="number">0.4f</span>, <span class="number">0.5f</span>, <span class="number">1.0f</span>);</div><div class="line">		glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</div><div class="line"></div><div class="line">		<span class="comment">//mat4 view = mycamera.GetViewMatrix();</span></div><div class="line">		<span class="comment">//mat4 projection = perspective(radians(mycamera.cameraFov), (GLfloat)WIDTH / (GLfloat)HEIGHT, 0.1f, 100.0f);</span></div><div class="line">		points_shader.Use();</div><div class="line">		glBindVertexArray(pointsVAO);</div><div class="line">		glDrawArrays(GL_POINTS, <span class="number">0</span>, <span class="number">4</span>);</div><div class="line">		glBindBuffer(GL_UNIFORM_BUFFER, <span class="number">0</span>);</div><div class="line"></div><div class="line">		do_movement();</div><div class="line">		glfwSwapBuffers(window); <span class="comment">//交换颜色缓存</span></div><div class="line">	&#125;</div><div class="line">	<span class="comment">//结束CLFW，释放由GLFW分配的资源</span></div><div class="line">	glfwTerminate();</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//按键回调函数</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">key_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">int</span> key, <span class="keyword">int</span> scancode, <span class="keyword">int</span> action, <span class="keyword">int</span> mode)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (key == GLFW_KEY_ESCAPE&amp;&amp;action == GLFW_PRESS) &#123;</div><div class="line">		glfwSetWindowShouldClose(window, GL_TRUE);</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//响应键盘按键来设置相应按键状态</span></div><div class="line">	<span class="keyword">if</span> (action == GLFW_PRESS) &#123;</div><div class="line">		keys[key] = GL_TRUE;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (action == GLFW_RELEASE) &#123;</div><div class="line">		keys[key] = GL_FALSE;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//根据按键状态移动摄像机</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_movement</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (keys[GLFW_KEY_W]) &#123;</div><div class="line">		mycamera.ProcessMovemnet(mycamera.FORWARD, deltaTime);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> (keys[GLFW_KEY_S]) &#123;</div><div class="line">		mycamera.ProcessMovemnet(mycamera.BACKWARD, deltaTime);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> (keys[GLFW_KEY_D]) &#123;</div><div class="line">		mycamera.ProcessMovemnet(mycamera.RIGHT, deltaTime);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> (keys[GLFW_KEY_A]) &#123;</div><div class="line">		mycamera.ProcessMovemnet(mycamera.LEFT, deltaTime);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//鼠标位置回调函数</span></div><div class="line"><span class="keyword">bool</span> firstCursor = <span class="literal">true</span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">cursor_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">double</span> xpos, <span class="keyword">double</span> ypos)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (firstCursor) &#123;</div><div class="line">		lastCursorX = xpos;</div><div class="line">		lastCursorY = ypos;</div><div class="line">		firstCursor = <span class="literal">false</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//计算前后两帧的鼠标位移量</span></div><div class="line">	GLfloat xOffset = (xpos - lastCursorX);</div><div class="line">	GLfloat yOffset = (lastCursorY - ypos);  <span class="comment">//注意是相反的，因为鼠标坐标原点在窗口左上角</span></div><div class="line">	lastCursorX = xpos;</div><div class="line">	lastCursorY = ypos;</div><div class="line">	mycamera.ProcessRotate(xOffset, yOffset);</div><div class="line">&#125;</div><div class="line"><span class="comment">//鼠标滚轮回调函数</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">scroll_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">double</span> xoffset, <span class="keyword">double</span> yoffset)</span> </span>&#123;</div><div class="line">	mycamera.ProcessScroll(xoffset, yoffset);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到，使用几何着色器，可以使用最简单的基本图形就能获得漂亮的新玩意。因为这些形状是在GPU这种超快硬件上动态生成的，这要比使用顶点缓冲自己定义这些形状更为高效。几何缓冲在简单的经常被重复的形状（比如体素的世界和室外的草地）上，是一种非常强大的优化工具。<br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">Demo：爆破物体</font><br>下面我们使用几何着色器来实现纳米铠甲的爆破效果。其实就是在几何着色器里让每个三角形面片沿着法线向外移动了一段距离，好像纳米铠甲爆炸了一样。也就是在几何着色器里，三角形的每个顶点沿着法线向外移动了一段距离。</p>
<p>这时的几何着色器接收的基本图形应该是三角形，输出的应该也是三角形。所以：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#version 330 core</span></div><div class="line">layout (triangles) in;</div><div class="line">layout (triangle_strip, max_vertices = <span class="number">3</span>) out;</div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>由于我们要使用纳米铠甲这个模型，我们需要从顶点着色器里接收顶点的法线、世界坐标、纹理坐标等属性，在几何着色器里处理完毕后再把它们输出给像素着色器（可以参考<a href="http://popperelay.com/2017/01/12/OpenGL14%E6%A8%A1%E5%9E%8B%E5%8A%A0%E8%BD%BD/" target="_blank" rel="external">《OpenGL14：模型加载》</a>） 一文中的顶点着色器和像素着色器）。所以在几何着色器里我们用接口块VS_OUT来接收来自顶点着色器的顶点属性，并且设置对应的输出变量：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">in VS_OUT&#123;</div><div class="line">	vec3 Normal;</div><div class="line">	vec3 positionInWorld;</div><div class="line">	vec2 TexCoords;</div><div class="line">&#125; gs_in[];</div><div class="line">out vec3 Normal;</div><div class="line">out vec3 positionInWorld;</div><div class="line">out vec2 TexCoords;</div></pre></td></tr></table></figure></p>
<p>由于三角形的每个顶点需要沿着三角形的法线，向外移动一段距离，所以我们需要先算出三角形的法线，我们把它写在<code>GetNormal</code>中：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function">vec3 <span class="title">GetNormal</span><span class="params">()</span></span>&#123;</div><div class="line">	vec3 a = vec3(gl_in[<span class="number">0</span>].gl_Position) - vec3(gl_in[<span class="number">1</span>].gl_Position);</div><div class="line">	vec3 b = vec3(gl_in[<span class="number">1</span>].gl_Position) - vec3(gl_in[<span class="number">2</span>].gl_Position);</div><div class="line">	<span class="keyword">return</span> normalize(cross(a, b));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后我们用<code>explode</code>函数来计算顶点沿着法线向外移动一段距离后的位置：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function">vec4 <span class="title">explode</span><span class="params">(vec4 position, vec3 normal)</span></span>&#123;</div><div class="line">	<span class="keyword">float</span> magnitude = <span class="number">2.0f</span>;</div><div class="line">	vec3 direction = normal * magnitude * ((<span class="built_in">sin</span>(time) + <span class="number">1.0f</span>)/<span class="number">2.0f</span>);</div><div class="line">	<span class="keyword">return</span> position + vec4(direction, <span class="number">0.0f</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>它接收两个参数：顶点原来的位置和法线向量。上面我们乘了一个时间变量time，来实现动态的爆炸效果。这个time变量是个uniform变量，需要从主程序给它赋值：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">uniform <span class="keyword">float</span> time;</div></pre></td></tr></table></figure></p>
<p>在几何着色器的main函数里，只需要改变三个顶点的位置为爆炸后的位置，顶点的法线、世界坐标、纹理坐标等原样输出即可。需要在main函数里发送3次顶点：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	vec3 normal = GetNormal();</div><div class="line"></div><div class="line">	gl_Position = explode(gl_in[<span class="number">0</span>].gl_Position, normal);</div><div class="line">	Normal = gs_in[<span class="number">0</span>].Normal;</div><div class="line">	positionInWorld = gs_in[<span class="number">0</span>].positionInWorld;</div><div class="line">	TexCoords = gs_in[<span class="number">0</span>].TexCoords;</div><div class="line">	EmitVertex();</div><div class="line"></div><div class="line">	gl_Position = explode(gl_in[<span class="number">1</span>].gl_Position, normal);</div><div class="line">	Normal = gs_in[<span class="number">1</span>].Normal;</div><div class="line">	positionInWorld = gs_in[<span class="number">1</span>].positionInWorld;</div><div class="line">	TexCoords = gs_in[<span class="number">1</span>].TexCoords;</div><div class="line">	EmitVertex();</div><div class="line"></div><div class="line">	gl_Position = explode(gl_in[<span class="number">2</span>].gl_Position, normal);</div><div class="line">	Normal = gs_in[<span class="number">2</span>].Normal;</div><div class="line">	positionInWorld = gs_in[<span class="number">2</span>].positionInWorld;</div><div class="line">	TexCoords = gs_in[<span class="number">2</span>].TexCoords;</div><div class="line">	EmitVertex();</div><div class="line"></div><div class="line">    EndPrimitive();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>不要忘了在主程序中对time变量赋值，而且顶点着色器也得作出相应调整（改成接口块）。编译运行后的结果如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148628385114.png" alt=""><br>下面给出全部源码：<br>顶点着色器（写在lightObject.vertex中）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//顶点着色器</span></div><div class="line"><span class="meta">#version 330 core</span></div><div class="line">layout (location=<span class="number">0</span>) in vec3 position;  <span class="comment">//顶点位置属性的位置值为0</span></div><div class="line">layout (location=<span class="number">1</span>) in vec3 normal;    <span class="comment">//顶点法线属性的位置值为1</span></div><div class="line">layout (location=<span class="number">2</span>) in vec2 texCoords; <span class="comment">//顶点纹理坐标属性的位置值为2</span></div><div class="line">out VS_OUT&#123;</div><div class="line">	vec3 Normal;</div><div class="line">	vec3 positionInWorld;</div><div class="line">	vec2 TexCoords;</div><div class="line">&#125; vs_out;</div><div class="line"></div><div class="line"><span class="comment">//模型矩阵</span></div><div class="line">uniform mat4 model;</div><div class="line"><span class="comment">//观察矩阵</span></div><div class="line">uniform mat4 view;</div><div class="line"><span class="comment">//投影矩阵</span></div><div class="line">uniform mat4 projection;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	gl_Position = projection * view * model * vec4(position,<span class="number">1.0f</span>);</div><div class="line">	vs_out.Normal=mat3(transpose(inverse(model)))*normal;</div><div class="line">	vs_out.positionInWorld=vec3(model*vec4(position,<span class="number">1.0f</span>));</div><div class="line">	vs_out.TexCoords=texCoords;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>几何着色器（写在modelExplode.geometry中）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#version 330 core</span></div><div class="line">layout (triangles) in;</div><div class="line">layout (triangle_strip, max_vertices = <span class="number">3</span>) out;</div><div class="line"></div><div class="line">in VS_OUT&#123;</div><div class="line">	vec3 Normal;</div><div class="line">	vec3 positionInWorld;</div><div class="line">	vec2 TexCoords;</div><div class="line">&#125; gs_in[];</div><div class="line">out vec3 Normal;</div><div class="line">out vec3 positionInWorld;</div><div class="line">out vec2 TexCoords;</div><div class="line"></div><div class="line">uniform <span class="keyword">float</span> time;</div><div class="line"></div><div class="line"><span class="function">vec3 <span class="title">GetNormal</span><span class="params">()</span></span>&#123;</div><div class="line">	vec3 a = vec3(gl_in[<span class="number">0</span>].gl_Position) - vec3(gl_in[<span class="number">1</span>].gl_Position);</div><div class="line">	vec3 b = vec3(gl_in[<span class="number">1</span>].gl_Position) - vec3(gl_in[<span class="number">2</span>].gl_Position);</div><div class="line">	<span class="keyword">return</span> normalize(cross(a, b));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">vec4 <span class="title">explode</span><span class="params">(vec4 position, vec3 normal)</span></span>&#123;</div><div class="line">	<span class="keyword">float</span> magnitude = <span class="number">2.0f</span>;</div><div class="line">	vec3 direction = normal * magnitude * ((<span class="built_in">sin</span>(time) + <span class="number">1.0f</span>)/<span class="number">2.0f</span>);</div><div class="line">	<span class="keyword">return</span> position + vec4(direction, <span class="number">0.0f</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	vec3 normal = GetNormal();</div><div class="line"></div><div class="line">	gl_Position = explode(gl_in[<span class="number">0</span>].gl_Position, normal);</div><div class="line">	Normal = gs_in[<span class="number">0</span>].Normal;</div><div class="line">	positionInWorld = gs_in[<span class="number">0</span>].positionInWorld;</div><div class="line">	TexCoords = gs_in[<span class="number">0</span>].TexCoords;</div><div class="line">	EmitVertex();</div><div class="line"></div><div class="line">	gl_Position = explode(gl_in[<span class="number">1</span>].gl_Position, normal);</div><div class="line">	Normal = gs_in[<span class="number">1</span>].Normal;</div><div class="line">	positionInWorld = gs_in[<span class="number">1</span>].positionInWorld;</div><div class="line">	TexCoords = gs_in[<span class="number">1</span>].TexCoords;</div><div class="line">	EmitVertex();</div><div class="line"></div><div class="line">	gl_Position = explode(gl_in[<span class="number">2</span>].gl_Position, normal);</div><div class="line">	Normal = gs_in[<span class="number">2</span>].Normal;</div><div class="line">	positionInWorld = gs_in[<span class="number">2</span>].positionInWorld;</div><div class="line">	TexCoords = gs_in[<span class="number">2</span>].TexCoords;</div><div class="line">	EmitVertex();</div><div class="line"></div><div class="line">    EndPrimitive();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>主程序：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"shader.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"TextureLoader.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"camera.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ModelLoader.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="comment">//GLEW</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> GLEW_STATIC</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GL/glew.h&gt;</span></span></div><div class="line"><span class="comment">//GLFW</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLFW/glfw3.h&gt;</span></span></div><div class="line"><span class="comment">//SOIL</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;SOIL/SOIL.h&gt;</span></span></div><div class="line"><span class="comment">//GLM</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLM/glm/glm.hpp&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLM/glm/gtc/matrix_transform.hpp&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLM/glm/gtc/type_ptr.hpp&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> glm;</div><div class="line"><span class="comment">//窗口尺寸</span></div><div class="line"><span class="keyword">const</span> GLuint WIDTH = <span class="number">800</span>, HEIGHT = <span class="number">600</span>;</div><div class="line"><span class="keyword">bool</span> keys[<span class="number">1024</span>];</div><div class="line"><span class="comment">//当前帧与上一帧的时间差</span></div><div class="line">GLfloat deltaTime = <span class="number">0.0f</span>;</div><div class="line"><span class="comment">//上一帧开始的时间</span></div><div class="line">GLfloat lastTime = <span class="number">0.0f</span>;</div><div class="line"><span class="comment">//上一帧鼠标位置</span></div><div class="line">GLfloat lastCursorX = WIDTH / <span class="number">2</span>;</div><div class="line">GLfloat lastCursorY = HEIGHT / <span class="number">2</span>;</div><div class="line"><span class="comment">//定义摄像机类Camera的对象</span></div><div class="line">Camera mycamera;</div><div class="line"><span class="comment">//函数声明</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">key_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">int</span> key, <span class="keyword">int</span> scancode, <span class="keyword">int</span> action, <span class="keyword">int</span> mode)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_movement</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">cursor_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">double</span> xpos, <span class="keyword">double</span> ypos)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">scroll_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">double</span> xoffset, <span class="keyword">double</span> yoffser)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="comment">//初始化GLFW</span></div><div class="line">	glfwInit();</div><div class="line">	<span class="comment">//GLFW配置</span></div><div class="line">	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>); <span class="comment">//主版本号</span></div><div class="line">	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>); <span class="comment">//次版本号</span></div><div class="line">	glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE); <span class="comment">// 核心开发模式</span></div><div class="line">	glfwWindowHint(GLFW_RESIZABLE, GL_FALSE); <span class="comment">//窗口尺寸不可变</span></div><div class="line">											  <span class="comment">//创建能够使用GLFW函数的窗口对象（指针）</span></div><div class="line">	GLFWwindow* window = glfwCreateWindow(WIDTH, HEIGHT, <span class="string">"LearnOpenGL"</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</div><div class="line">	<span class="keyword">if</span> (window == <span class="literal">NULL</span>) &#123;</div><div class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Failed to create GLFW window"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">		glfwTerminate();</div><div class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//创建窗口环境</span></div><div class="line">	glfwMakeContextCurrent(window);</div><div class="line">	<span class="comment">//注册按键回调函数</span></div><div class="line">	glfwSetKeyCallback(window, key_callback);</div><div class="line">	<span class="comment">//注册鼠标位置回调函数</span></div><div class="line">	glfwSetCursorPosCallback(window, cursor_callback);</div><div class="line">	<span class="comment">//隐藏鼠标</span></div><div class="line">	<span class="comment">//	glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);</span></div><div class="line">	<span class="comment">//注册鼠标滚轮回调函数</span></div><div class="line">	glfwSetScrollCallback(window, scroll_callback);</div><div class="line">	<span class="comment">//初始化GLEW</span></div><div class="line">	glewExperimental = GL_TRUE; <span class="comment">//保证使用现代技术管理OpenGL机能</span></div><div class="line">	<span class="keyword">if</span> (glewInit() != GLEW_OK) &#123;</div><div class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Failed to initialize GLEW"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//设置渲染窗口位置大小</span></div><div class="line">	<span class="keyword">int</span> width, height;</div><div class="line">	glfwGetFramebufferSize(window, &amp;width, &amp;height);</div><div class="line">	glViewport(<span class="number">0</span>, <span class="number">0</span>, width, height);</div><div class="line">	<span class="comment">//点光源位置</span></div><div class="line">	vec3 pointLightPositions[] = &#123;</div><div class="line">		vec3(<span class="number">0.7f</span>,  <span class="number">0.2f</span>,  <span class="number">2.0f</span>),</div><div class="line">		vec3(<span class="number">2.3f</span>, <span class="number">-3.3</span>f, <span class="number">-4.0</span>f),</div><div class="line">		vec3(<span class="number">-4.0</span>f,  <span class="number">2.0f</span>, <span class="number">-12.0</span>f),</div><div class="line">		vec3(<span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">-3.0</span>f)</div><div class="line">	&#125;;</div><div class="line">	<span class="comment">//定义自定义着色器类shader的对象</span></div><div class="line">	<span class="function">shader <span class="title">lightObject</span><span class="params">(<span class="string">"lightObject.vertex"</span>, <span class="string">"lightObject.fragment"</span>, <span class="string">"modelExplode.geometry"</span>)</span></span>;</div><div class="line">	<span class="function">Model <span class="title">mymodel</span><span class="params">(<span class="string">"nanosuit/nanosuit.obj"</span>)</span></span>;</div><div class="line">	glEnable(GL_DEPTH_TEST);</div><div class="line">	<span class="comment">//渲染循环（游戏循环）</span></div><div class="line">	<span class="keyword">while</span> (!glfwWindowShouldClose(window)) &#123;</div><div class="line">		<span class="comment">//计算deltaTime</span></div><div class="line">		GLfloat currentTime = glfwGetTime();</div><div class="line">		deltaTime = currentTime - lastTime;</div><div class="line">		lastTime = currentTime;</div><div class="line">		glfwPollEvents(); <span class="comment">//检测是否有事件被触发（如按键按下、鼠标移动）</span></div><div class="line">		glClearColor(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</div><div class="line">		glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</div><div class="line">		<span class="comment">//激活受光物体着色器程序对象</span></div><div class="line">		lightObject.Use();</div><div class="line">		<span class="comment">//设置定向光源</span></div><div class="line">		glUniform3f(glGetUniformLocation(lightObject.shaderProgram, <span class="string">"dirLight.direction"</span>), <span class="number">-0.2</span>f, <span class="number">-1.0</span>f, <span class="number">-0.3</span>f);</div><div class="line">		glUniform3f(glGetUniformLocation(lightObject.shaderProgram, <span class="string">"dirLight.ambient"</span>), <span class="number">0.05f</span>, <span class="number">0.05f</span>, <span class="number">0.05f</span>);</div><div class="line">		glUniform3f(glGetUniformLocation(lightObject.shaderProgram, <span class="string">"dirLight.diffuse"</span>), <span class="number">0.4f</span>, <span class="number">0.4f</span>, <span class="number">0.4f</span>);</div><div class="line">		glUniform3f(glGetUniformLocation(lightObject.shaderProgram, <span class="string">"dirLight.specular"</span>), <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>);</div><div class="line">		<span class="comment">//设置点光源0</span></div><div class="line">		glUniform3f(glGetUniformLocation(lightObject.shaderProgram, <span class="string">"pointLights[0].position"</span>), pointLightPositions[<span class="number">0</span>].x, pointLightPositions[<span class="number">0</span>].y, pointLightPositions[<span class="number">0</span>].z);</div><div class="line">		glUniform3f(glGetUniformLocation(lightObject.shaderProgram, <span class="string">"pointLights[0].ambient"</span>), <span class="number">0.05f</span>, <span class="number">0.05f</span>, <span class="number">0.05f</span>);</div><div class="line">		glUniform3f(glGetUniformLocation(lightObject.shaderProgram, <span class="string">"pointLights[0].diffuse"</span>), <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);</div><div class="line">		glUniform3f(glGetUniformLocation(lightObject.shaderProgram, <span class="string">"pointLights[0].specular"</span>), <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>);</div><div class="line">		glUniform1f(glGetUniformLocation(lightObject.shaderProgram, <span class="string">"pointLights[0].constant"</span>), <span class="number">1.0f</span>);</div><div class="line">		glUniform1f(glGetUniformLocation(lightObject.shaderProgram, <span class="string">"pointLights[0].linear"</span>), <span class="number">0.09</span>);</div><div class="line">		glUniform1f(glGetUniformLocation(lightObject.shaderProgram, <span class="string">"pointLights[0].quadratic"</span>), <span class="number">0.032</span>);</div><div class="line">		<span class="comment">//设置聚光灯</span></div><div class="line">		glUniform3f(glGetUniformLocation(lightObject.shaderProgram, <span class="string">"spotLight.position"</span>), mycamera.cameraPos.x, mycamera.cameraPos.y, mycamera.cameraPos.z);</div><div class="line">		glUniform3f(glGetUniformLocation(lightObject.shaderProgram, <span class="string">"spotLight.lightAxis"</span>), mycamera.cameraToTarget.x, mycamera.cameraToTarget.y, mycamera.cameraToTarget.z);</div><div class="line">		glUniform1f(glGetUniformLocation(lightObject.shaderProgram, <span class="string">"spotLight.inCutOff"</span>), <span class="built_in">cos</span>(radians(<span class="number">12.5f</span>)));</div><div class="line">		glUniform1f(glGetUniformLocation(lightObject.shaderProgram, <span class="string">"spotLight.outCutOff"</span>), <span class="built_in">cos</span>(radians(<span class="number">17.5f</span>)));</div><div class="line">		glUniform1f(glGetUniformLocation(lightObject.shaderProgram, <span class="string">"spotLight.constant"</span>), <span class="number">1.0f</span>);</div><div class="line">		glUniform1f(glGetUniformLocation(lightObject.shaderProgram, <span class="string">"spotLight.linear"</span>), <span class="number">0.09</span>);</div><div class="line">		glUniform1f(glGetUniformLocation(lightObject.shaderProgram, <span class="string">"spotLight.quadratic"</span>), <span class="number">0.032</span>);</div><div class="line">		glUniform3f(glGetUniformLocation(lightObject.shaderProgram, <span class="string">"spotLight.ambient"</span>), <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);</div><div class="line">		glUniform3f(glGetUniformLocation(lightObject.shaderProgram, <span class="string">"spotLight.diffuse"</span>), <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>);</div><div class="line">		glUniform3f(glGetUniformLocation(lightObject.shaderProgram, <span class="string">"spotLight.specular"</span>), <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>);</div><div class="line">		<span class="comment">//设置uniform变量观察位置viewPos</span></div><div class="line">		glUniform3f(glGetUniformLocation(lightObject.shaderProgram, <span class="string">"viewPos"</span>), mycamera.cameraPos.x, mycamera.cameraPos.y, mycamera.cameraPos.z);</div><div class="line">		mat4 view = mycamera.GetViewMatrix();</div><div class="line">		mat4 projection = perspective(radians(mycamera.cameraFov), (GLfloat)WIDTH / (GLfloat)HEIGHT, <span class="number">0.1f</span>, <span class="number">100.0f</span>);</div><div class="line">		mat4 model;</div><div class="line">		model = translate(model, glm::vec3(<span class="number">0.0f</span>, <span class="number">-1.75</span>f, <span class="number">0.0f</span>));</div><div class="line">		model = model = glm::scale(model, glm::vec3(<span class="number">0.2f</span>, <span class="number">0.2f</span>, <span class="number">0.2f</span>));</div><div class="line">		glUniformMatrix4fv(glGetUniformLocation(lightObject.shaderProgram, <span class="string">"view"</span>), <span class="number">1</span>, GL_FALSE, value_ptr(view));</div><div class="line">		glUniformMatrix4fv(glGetUniformLocation(lightObject.shaderProgram, <span class="string">"projection"</span>), <span class="number">1</span>, GL_FALSE, value_ptr(projection));</div><div class="line">		glUniformMatrix4fv(glGetUniformLocation(lightObject.shaderProgram, <span class="string">"model"</span>), <span class="number">1</span>, GL_FALSE, value_ptr(model));</div><div class="line">		</div><div class="line">		glUniform1f(glGetUniformLocation(lightObject.shaderProgram, <span class="string">"time"</span>), glfwGetTime());</div><div class="line">		</div><div class="line">		mymodel.Draw(lightObject);</div><div class="line">		do_movement();</div><div class="line">		glfwSwapBuffers(window); <span class="comment">//交换颜色缓存</span></div><div class="line">	&#125;</div><div class="line">	<span class="comment">//结束CLFW，释放由GLFW分配的资源</span></div><div class="line">	glfwTerminate();</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//按键回调函数</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">key_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">int</span> key, <span class="keyword">int</span> scancode, <span class="keyword">int</span> action, <span class="keyword">int</span> mode)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (key == GLFW_KEY_ESCAPE&amp;&amp;action == GLFW_PRESS) &#123;</div><div class="line">		glfwSetWindowShouldClose(window, GL_TRUE);</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//响应键盘按键来设置相应按键状态</span></div><div class="line">	<span class="keyword">if</span> (action == GLFW_PRESS) &#123;</div><div class="line">		keys[key] = GL_TRUE;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (action == GLFW_RELEASE) &#123;</div><div class="line">		keys[key] = GL_FALSE;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//根据按键状态移动摄像机</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_movement</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (keys[GLFW_KEY_W]) &#123;</div><div class="line">		mycamera.ProcessMovemnet(mycamera.FORWARD, deltaTime);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> (keys[GLFW_KEY_S]) &#123;</div><div class="line">		mycamera.ProcessMovemnet(mycamera.BACKWARD, deltaTime);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> (keys[GLFW_KEY_D]) &#123;</div><div class="line">		mycamera.ProcessMovemnet(mycamera.RIGHT, deltaTime);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> (keys[GLFW_KEY_A]) &#123;</div><div class="line">		mycamera.ProcessMovemnet(mycamera.LEFT, deltaTime);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//鼠标位置回调函数</span></div><div class="line"><span class="keyword">bool</span> firstCursor = <span class="literal">true</span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">cursor_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">double</span> xpos, <span class="keyword">double</span> ypos)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (firstCursor) &#123;</div><div class="line">		lastCursorX = xpos;</div><div class="line">		lastCursorY = ypos;</div><div class="line">		firstCursor = <span class="literal">false</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//计算前后两帧的鼠标位移量</span></div><div class="line">	GLfloat xOffset = (xpos - lastCursorX);</div><div class="line">	GLfloat yOffset = (lastCursorY - ypos);  <span class="comment">//注意是相反的，因为鼠标坐标原点在窗口左上角</span></div><div class="line">	lastCursorX = xpos;</div><div class="line">	lastCursorY = ypos;</div><div class="line">	mycamera.ProcessRotate(xOffset, yOffset);</div><div class="line">&#125;</div><div class="line"><span class="comment">//鼠标滚轮回调函数</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">scroll_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">double</span> xoffset, <span class="keyword">double</span> yoffset)</span> </span>&#123;</div><div class="line">	mycamera.ProcessScroll(xoffset, yoffset);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其余所需代码和<a href="http://popperelay.com/2017/01/12/OpenGL14%E6%A8%A1%E5%9E%8B%E5%8A%A0%E8%BD%BD/" target="_blank" rel="external">《OpenGL14：模型加载》</a>一文一样，只是像素着色器里点光源数量变成了一个，并且着色器类应该和上面给出的一样，加入了对几何着色器的附加和编译。<br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">显示法向量</font><br>下面我们将使用几何着色器来显示纳米铠甲每个顶点的法线向量。当编写光照着色器的时候，经常会遇到奇怪的视频输出问题，很难分辨是哪里出了问题。通常是因为不正确地加载了顶点数据，以及给它们指定了不合理的顶点属性，或者是在着色器中不合法的管理，导致产生了不正确的法线向量。我们希望可以用某种方式检测出法线向量是否正确，而我们这里的把法向量显示出来就是一种不错的方法。</p>
<p>显示法线向量的思路：先不使用几何着色器，正常绘制物体；然后使用我们用于显示法线向量的几何着色器，再绘制一次物体，这次只绘制物体上顶点的法线，不会绘制物体的面片。看起来就像这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">lightObject.Use();</div><div class="line">mymodel.Draw(lightObject);</div><div class="line">normalDisplay.Use();</div><div class="line">mymodel.Draw(normalDisplay);</div></pre></td></tr></table></figure></p>
<p>我们先写一个显示法线的顶点着色器（写在normalDisplay.vertex中）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//顶点着色器</span></div><div class="line"><span class="meta">#version 330 core</span></div><div class="line">layout (location=<span class="number">0</span>) in vec3 position;  <span class="comment">//顶点位置属性的位置值为0</span></div><div class="line">layout (location=<span class="number">1</span>) in vec3 normal;    <span class="comment">//顶点法线属性的位置值为1</span></div><div class="line">out	VS_OUT&#123;</div><div class="line">	vec3 Normal;</div><div class="line">&#125; vs_out;</div><div class="line"></div><div class="line"><span class="comment">//模型矩阵</span></div><div class="line">uniform mat4 model;</div><div class="line"><span class="comment">//观察矩阵</span></div><div class="line">uniform mat4 view;</div><div class="line"><span class="comment">//投影矩阵</span></div><div class="line">uniform mat4 projection;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	gl_Position = projection * view * model * vec4(position,<span class="number">1.0f</span>);</div><div class="line">	vs_out.Normal = normalize(vec3(projection * view * vec4(mat3(transpose(inverse(model))) * normal, <span class="number">1.0f</span>)));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意，这里的法线向量我们将它变换到裁剪空间了，因为接下来显示法线向量也是在裁剪空间中进行的。而在对模型的光照处理时，这些法线是在世界空间下，不会乘以proection和view，因为点光源等等计算向量夹角是在世界坐标系下进行的。</p>
<p>接着我们在几何着色器里接收三角形基本图元，但是输出的是线条。在main函数里，三角形的每个顶点和它法线方向上指定距离的某个点，构成一个线段基本图元。这样进行3次<code>EndPrimitive()</code>就能产生3条线段，输出的最大顶点数就是6（写在normalDisplay.geometry中）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#version 330 core</span></div><div class="line">layout (triangles) in;</div><div class="line">layout (line_strip, max_vertices = <span class="number">6</span>) out;</div><div class="line"></div><div class="line">in VS_OUT &#123;</div><div class="line">	vec3 Normal;</div><div class="line">&#125; gs_in[];</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">float</span> MAGNITUDE = <span class="number">0.1f</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	gl_Position = gl_in[<span class="number">0</span>].gl_Position;</div><div class="line">	EmitVertex();</div><div class="line">	gl_Position = gl_in[<span class="number">0</span>].gl_Position + vec4(gs_in[<span class="number">0</span>].Normal, <span class="number">0.0f</span>) * MAGNITUDE;</div><div class="line">	EmitVertex();</div><div class="line">	EndPrimitive();</div><div class="line"></div><div class="line">	gl_Position = gl_in[<span class="number">1</span>].gl_Position;</div><div class="line">	EmitVertex();</div><div class="line">	gl_Position = gl_in[<span class="number">1</span>].gl_Position + vec4(gs_in[<span class="number">1</span>].Normal, <span class="number">0.0f</span>) * MAGNITUDE;</div><div class="line">	EmitVertex();</div><div class="line">	EndPrimitive();</div><div class="line"></div><div class="line">	gl_Position = gl_in[<span class="number">2</span>].gl_Position;</div><div class="line">	EmitVertex();</div><div class="line">	gl_Position = gl_in[<span class="number">2</span>].gl_Position + vec4(gs_in[<span class="number">2</span>].Normal, <span class="number">0.0f</span>) * MAGNITUDE;</div><div class="line">	EmitVertex();</div><div class="line">	EndPrimitive();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>MAGNITUDE</code>是为了控制绘制的法线向量的长度。</p>
<p>至于像素着色器就很简单了，让这些法线线段显示一个颜色即可（写在normalDisplay.fragment中）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#version 330 core</span></div><div class="line">out vec4 color;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	color = vec4(<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后在主程序里，两次使用着色器类对象，一次用于绘制模型物体，接着另一次用于绘制模型顶点的法线向量：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">lightObject.Use();</div><div class="line">...</div><div class="line">mymodel.Draw(lightObject);</div><div class="line">...</div><div class="line">normalDisplay.Use();</div><div class="line">...</div><div class="line">mymodel.Draw(normalDisplay);</div></pre></td></tr></table></figure></p>
<p>编译运行后的结果如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148628385163.png" alt=""></p>
<p>下面给出主程序的源码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"shader.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"TextureLoader.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"camera.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ModelLoader.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="comment">//GLEW</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> GLEW_STATIC</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GL/glew.h&gt;</span></span></div><div class="line"><span class="comment">//GLFW</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLFW/glfw3.h&gt;</span></span></div><div class="line"><span class="comment">//SOIL</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;SOIL/SOIL.h&gt;</span></span></div><div class="line"><span class="comment">//GLM</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLM/glm/glm.hpp&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLM/glm/gtc/matrix_transform.hpp&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLM/glm/gtc/type_ptr.hpp&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> glm;</div><div class="line"><span class="comment">//窗口尺寸</span></div><div class="line"><span class="keyword">const</span> GLuint WIDTH = <span class="number">800</span>, HEIGHT = <span class="number">600</span>;</div><div class="line"><span class="keyword">bool</span> keys[<span class="number">1024</span>];</div><div class="line"><span class="comment">//当前帧与上一帧的时间差</span></div><div class="line">GLfloat deltaTime = <span class="number">0.0f</span>;</div><div class="line"><span class="comment">//上一帧开始的时间</span></div><div class="line">GLfloat lastTime = <span class="number">0.0f</span>;</div><div class="line"><span class="comment">//上一帧鼠标位置</span></div><div class="line">GLfloat lastCursorX = WIDTH / <span class="number">2</span>;</div><div class="line">GLfloat lastCursorY = HEIGHT / <span class="number">2</span>;</div><div class="line"><span class="comment">//定义摄像机类Camera的对象</span></div><div class="line">Camera mycamera;</div><div class="line"><span class="comment">//函数声明</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">key_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">int</span> key, <span class="keyword">int</span> scancode, <span class="keyword">int</span> action, <span class="keyword">int</span> mode)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_movement</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">cursor_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">double</span> xpos, <span class="keyword">double</span> ypos)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">scroll_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">double</span> xoffset, <span class="keyword">double</span> yoffser)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="comment">//初始化GLFW</span></div><div class="line">	glfwInit();</div><div class="line">	<span class="comment">//GLFW配置</span></div><div class="line">	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>); <span class="comment">//主版本号</span></div><div class="line">	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>); <span class="comment">//次版本号</span></div><div class="line">	glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE); <span class="comment">// 核心开发模式</span></div><div class="line">	glfwWindowHint(GLFW_RESIZABLE, GL_FALSE); <span class="comment">//窗口尺寸不可变</span></div><div class="line">											  <span class="comment">//创建能够使用GLFW函数的窗口对象（指针）</span></div><div class="line">	GLFWwindow* window = glfwCreateWindow(WIDTH, HEIGHT, <span class="string">"LearnOpenGL"</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</div><div class="line">	<span class="keyword">if</span> (window == <span class="literal">NULL</span>) &#123;</div><div class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Failed to create GLFW window"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">		glfwTerminate();</div><div class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//创建窗口环境</span></div><div class="line">	glfwMakeContextCurrent(window);</div><div class="line">	<span class="comment">//注册按键回调函数</span></div><div class="line">	glfwSetKeyCallback(window, key_callback);</div><div class="line">	<span class="comment">//注册鼠标位置回调函数</span></div><div class="line">	glfwSetCursorPosCallback(window, cursor_callback);</div><div class="line">	<span class="comment">//隐藏鼠标</span></div><div class="line">	<span class="comment">//	glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);</span></div><div class="line">	<span class="comment">//注册鼠标滚轮回调函数</span></div><div class="line">	glfwSetScrollCallback(window, scroll_callback);</div><div class="line">	<span class="comment">//初始化GLEW</span></div><div class="line">	glewExperimental = GL_TRUE; <span class="comment">//保证使用现代技术管理OpenGL机能</span></div><div class="line">	<span class="keyword">if</span> (glewInit() != GLEW_OK) &#123;</div><div class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Failed to initialize GLEW"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//设置渲染窗口位置大小</span></div><div class="line">	<span class="keyword">int</span> width, height;</div><div class="line">	glfwGetFramebufferSize(window, &amp;width, &amp;height);</div><div class="line">	glViewport(<span class="number">0</span>, <span class="number">0</span>, width, height);</div><div class="line">	<span class="comment">//点光源位置</span></div><div class="line">	vec3 pointLightPositions[] = &#123;</div><div class="line">		vec3(<span class="number">0.7f</span>,  <span class="number">0.2f</span>,  <span class="number">2.0f</span>),</div><div class="line">		vec3(<span class="number">2.3f</span>, <span class="number">-3.3</span>f, <span class="number">-4.0</span>f),</div><div class="line">		vec3(<span class="number">-4.0</span>f,  <span class="number">2.0f</span>, <span class="number">-12.0</span>f),</div><div class="line">		vec3(<span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">-3.0</span>f)</div><div class="line">	&#125;;</div><div class="line">	<span class="comment">//定义自定义着色器类shader的对象</span></div><div class="line">	<span class="function">shader <span class="title">lightObject</span><span class="params">(<span class="string">"lightObject.vertex"</span>, <span class="string">"lightObject.fragment"</span>)</span></span>;</div><div class="line">	<span class="function">shader <span class="title">normalDisplay</span><span class="params">(<span class="string">"normalDisplay.vertex"</span>, <span class="string">"normalDisplay.fragment"</span>, <span class="string">"normalDisplay.geometry"</span>)</span></span>;</div><div class="line">	<span class="function">Model <span class="title">mymodel</span><span class="params">(<span class="string">"nanosuit/nanosuit.obj"</span>)</span></span>;</div><div class="line">	glEnable(GL_DEPTH_TEST);</div><div class="line">	<span class="comment">//渲染循环（游戏循环）</span></div><div class="line">	<span class="keyword">while</span> (!glfwWindowShouldClose(window)) &#123;</div><div class="line">		<span class="comment">//计算deltaTime</span></div><div class="line">		GLfloat currentTime = glfwGetTime();</div><div class="line">		deltaTime = currentTime - lastTime;</div><div class="line">		lastTime = currentTime;</div><div class="line">		glfwPollEvents(); <span class="comment">//检测是否有事件被触发（如按键按下、鼠标移动）</span></div><div class="line">		glClearColor(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</div><div class="line">		glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</div><div class="line">		<span class="comment">//激活受光物体着色器程序对象</span></div><div class="line">		lightObject.Use();</div><div class="line">		<span class="comment">//设置定向光源</span></div><div class="line">		glUniform3f(glGetUniformLocation(lightObject.shaderProgram, <span class="string">"dirLight.direction"</span>), <span class="number">-0.2</span>f, <span class="number">-1.0</span>f, <span class="number">-0.3</span>f);</div><div class="line">		glUniform3f(glGetUniformLocation(lightObject.shaderProgram, <span class="string">"dirLight.ambient"</span>), <span class="number">0.05f</span>, <span class="number">0.05f</span>, <span class="number">0.05f</span>);</div><div class="line">		glUniform3f(glGetUniformLocation(lightObject.shaderProgram, <span class="string">"dirLight.diffuse"</span>), <span class="number">0.4f</span>, <span class="number">0.4f</span>, <span class="number">0.4f</span>);</div><div class="line">		glUniform3f(glGetUniformLocation(lightObject.shaderProgram, <span class="string">"dirLight.specular"</span>), <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>);</div><div class="line">		<span class="comment">//设置点光源0</span></div><div class="line">		glUniform3f(glGetUniformLocation(lightObject.shaderProgram, <span class="string">"pointLights[0].position"</span>), pointLightPositions[<span class="number">0</span>].x, pointLightPositions[<span class="number">0</span>].y, pointLightPositions[<span class="number">0</span>].z);</div><div class="line">		glUniform3f(glGetUniformLocation(lightObject.shaderProgram, <span class="string">"pointLights[0].ambient"</span>), <span class="number">0.05f</span>, <span class="number">0.05f</span>, <span class="number">0.05f</span>);</div><div class="line">		glUniform3f(glGetUniformLocation(lightObject.shaderProgram, <span class="string">"pointLights[0].diffuse"</span>), <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);</div><div class="line">		glUniform3f(glGetUniformLocation(lightObject.shaderProgram, <span class="string">"pointLights[0].specular"</span>), <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>);</div><div class="line">		glUniform1f(glGetUniformLocation(lightObject.shaderProgram, <span class="string">"pointLights[0].constant"</span>), <span class="number">1.0f</span>);</div><div class="line">		glUniform1f(glGetUniformLocation(lightObject.shaderProgram, <span class="string">"pointLights[0].linear"</span>), <span class="number">0.09</span>);</div><div class="line">		glUniform1f(glGetUniformLocation(lightObject.shaderProgram, <span class="string">"pointLights[0].quadratic"</span>), <span class="number">0.032</span>);</div><div class="line">		<span class="comment">//设置聚光灯</span></div><div class="line">		glUniform3f(glGetUniformLocation(lightObject.shaderProgram, <span class="string">"spotLight.position"</span>), mycamera.cameraPos.x, mycamera.cameraPos.y, mycamera.cameraPos.z);</div><div class="line">		glUniform3f(glGetUniformLocation(lightObject.shaderProgram, <span class="string">"spotLight.lightAxis"</span>), mycamera.cameraToTarget.x, mycamera.cameraToTarget.y, mycamera.cameraToTarget.z);</div><div class="line">		glUniform1f(glGetUniformLocation(lightObject.shaderProgram, <span class="string">"spotLight.inCutOff"</span>), <span class="built_in">cos</span>(radians(<span class="number">12.5f</span>)));</div><div class="line">		glUniform1f(glGetUniformLocation(lightObject.shaderProgram, <span class="string">"spotLight.outCutOff"</span>), <span class="built_in">cos</span>(radians(<span class="number">17.5f</span>)));</div><div class="line">		glUniform1f(glGetUniformLocation(lightObject.shaderProgram, <span class="string">"spotLight.constant"</span>), <span class="number">1.0f</span>);</div><div class="line">		glUniform1f(glGetUniformLocation(lightObject.shaderProgram, <span class="string">"spotLight.linear"</span>), <span class="number">0.09</span>);</div><div class="line">		glUniform1f(glGetUniformLocation(lightObject.shaderProgram, <span class="string">"spotLight.quadratic"</span>), <span class="number">0.032</span>);</div><div class="line">		glUniform3f(glGetUniformLocation(lightObject.shaderProgram, <span class="string">"spotLight.ambient"</span>), <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);</div><div class="line">		glUniform3f(glGetUniformLocation(lightObject.shaderProgram, <span class="string">"spotLight.diffuse"</span>), <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>);</div><div class="line">		glUniform3f(glGetUniformLocation(lightObject.shaderProgram, <span class="string">"spotLight.specular"</span>), <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>);</div><div class="line">		<span class="comment">//设置uniform变量观察位置viewPos</span></div><div class="line">		glUniform3f(glGetUniformLocation(lightObject.shaderProgram, <span class="string">"viewPos"</span>), mycamera.cameraPos.x, mycamera.cameraPos.y, mycamera.cameraPos.z);</div><div class="line">		mat4 view = mycamera.GetViewMatrix();</div><div class="line">		mat4 projection = perspective(radians(mycamera.cameraFov), (GLfloat)WIDTH / (GLfloat)HEIGHT, <span class="number">0.1f</span>, <span class="number">100.0f</span>);</div><div class="line">		mat4 model;</div><div class="line">		model = translate(model, glm::vec3(<span class="number">0.0f</span>, <span class="number">-1.75</span>f, <span class="number">0.0f</span>));</div><div class="line">		model = model = glm::scale(model, glm::vec3(<span class="number">0.2f</span>, <span class="number">0.2f</span>, <span class="number">0.2f</span>));</div><div class="line">		glUniformMatrix4fv(glGetUniformLocation(lightObject.shaderProgram, <span class="string">"view"</span>), <span class="number">1</span>, GL_FALSE, value_ptr(view));</div><div class="line">		glUniformMatrix4fv(glGetUniformLocation(lightObject.shaderProgram, <span class="string">"projection"</span>), <span class="number">1</span>, GL_FALSE, value_ptr(projection));</div><div class="line">		glUniformMatrix4fv(glGetUniformLocation(lightObject.shaderProgram, <span class="string">"model"</span>), <span class="number">1</span>, GL_FALSE, value_ptr(model));		</div><div class="line">		mymodel.Draw(lightObject);</div><div class="line"></div><div class="line">		normalDisplay.Use();</div><div class="line">		glUniformMatrix4fv(glGetUniformLocation(normalDisplay.shaderProgram, <span class="string">"view"</span>), <span class="number">1</span>, GL_FALSE, value_ptr(view));</div><div class="line">		glUniformMatrix4fv(glGetUniformLocation(normalDisplay.shaderProgram, <span class="string">"projection"</span>), <span class="number">1</span>, GL_FALSE, value_ptr(projection));</div><div class="line">		glUniformMatrix4fv(glGetUniformLocation(normalDisplay.shaderProgram, <span class="string">"model"</span>), <span class="number">1</span>, GL_FALSE, value_ptr(model));</div><div class="line">		mymodel.Draw(normalDisplay);</div><div class="line"></div><div class="line">		do_movement();</div><div class="line">		glfwSwapBuffers(window); <span class="comment">//交换颜色缓存</span></div><div class="line">	&#125;</div><div class="line">	<span class="comment">//结束CLFW，释放由GLFW分配的资源</span></div><div class="line">	glfwTerminate();</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//按键回调函数</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">key_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">int</span> key, <span class="keyword">int</span> scancode, <span class="keyword">int</span> action, <span class="keyword">int</span> mode)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (key == GLFW_KEY_ESCAPE&amp;&amp;action == GLFW_PRESS) &#123;</div><div class="line">		glfwSetWindowShouldClose(window, GL_TRUE);</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//响应键盘按键来设置相应按键状态</span></div><div class="line">	<span class="keyword">if</span> (action == GLFW_PRESS) &#123;</div><div class="line">		keys[key] = GL_TRUE;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (action == GLFW_RELEASE) &#123;</div><div class="line">		keys[key] = GL_FALSE;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//根据按键状态移动摄像机</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_movement</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (keys[GLFW_KEY_W]) &#123;</div><div class="line">		mycamera.ProcessMovemnet(mycamera.FORWARD, deltaTime);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> (keys[GLFW_KEY_S]) &#123;</div><div class="line">		mycamera.ProcessMovemnet(mycamera.BACKWARD, deltaTime);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> (keys[GLFW_KEY_D]) &#123;</div><div class="line">		mycamera.ProcessMovemnet(mycamera.RIGHT, deltaTime);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> (keys[GLFW_KEY_A]) &#123;</div><div class="line">		mycamera.ProcessMovemnet(mycamera.LEFT, deltaTime);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//鼠标位置回调函数</span></div><div class="line"><span class="keyword">bool</span> firstCursor = <span class="literal">true</span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">cursor_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">double</span> xpos, <span class="keyword">double</span> ypos)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (firstCursor) &#123;</div><div class="line">		lastCursorX = xpos;</div><div class="line">		lastCursorY = ypos;</div><div class="line">		firstCursor = <span class="literal">false</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//计算前后两帧的鼠标位移量</span></div><div class="line">	GLfloat xOffset = (xpos - lastCursorX);</div><div class="line">	GLfloat yOffset = (lastCursorY - ypos);  <span class="comment">//注意是相反的，因为鼠标坐标原点在窗口左上角</span></div><div class="line">	lastCursorX = xpos;</div><div class="line">	lastCursorY = ypos;</div><div class="line">	mycamera.ProcessRotate(xOffset, yOffset);</div><div class="line">&#125;</div><div class="line"><span class="comment">//鼠标滚轮回调函数</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">scroll_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">double</span> xoffset, <span class="keyword">double</span> yoffset)</span> </span>&#123;</div><div class="line">	mycamera.ProcessScroll(xoffset, yoffset);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其余的源码（包括模型的顶点着色器和像素着色器和<a href="http://popperelay.com/2017/01/12/OpenGL14%E6%A8%A1%E5%9E%8B%E5%8A%A0%E8%BD%BD/" target="_blank" rel="external">《OpenGL14：模型加载》</a>）一样。<br>&nbsp; </p>
<hr>
<p>参考文献：<a href="http://bullteacher.com/category/zh_learnopengl_com" target="_blank" rel="external">锦瑟无端五十弦</a></p>

      
    </div>
    <footer>
      
        
  
  <div class="categories">
    <a href="/categories/OpenGL/">OpenGL</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/几何着色器/">几何着色器</a>
  </div>

        
  <div class="addthis addthis_toolbox addthis_default_style">
    
      <a class="addthis_button_facebook_like" fb:like:layout="button_count"></a>
    
    
      <a class="addthis_button_tweet"></a>
    
    
      <a class="addthis_button_google_plusone" g:plusone:size="medium"></a>
    
    
      <a class="addthis_button_pinterest_pinit" pi:pinit:layout="horizontal"></a>
    
    <a class="addthis_counter addthis_pill_style"></a>
  </div>
  <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js"></script>

      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


<section id="comment">
  <h2 class="title">留言</h2>


 
  	   <!-- 多说评论框 start -->
 		<div class="ds-thread" data-thread-key="2017/02/05/OpenGL23几何着色器/" data-title="OpenGL23：几何着色器" data-url="http://yoursite.com/2017/02/05/OpenGL23几何着色器/"></div>
		<!-- 多说评论框 end -->
		<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
		<script type="text/javascript">
		var duoshuoQuery = {short_name:"popperelay"};   <!-- 替换这里的duoshuo_shortname为前面注册的shortname -->
			(function() {
				var ds = document.createElement('script');
				ds.type = 'text/javascript';ds.async = true;
				ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.unstable.js';
				ds.charset = 'UTF-8';
				(document.getElementsByTagName('head')[0] 
				 || document.getElementsByTagName('body')[0]).appendChild(ds);
			})();
			</script>
		<!-- 多说公共JS代码 end -->
 
  
</section>

</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:yoursite.com">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/C-语法/">C#语法</a><small>2</small></li>
  
    <li><a href="/categories/C/">C++</a><small>2</small></li>
  
    <li><a href="/categories/OpenGL/">OpenGL</a><small>22</small></li>
  
    <li><a href="/categories/博客配置/">博客配置</a><small>3</small></li>
  
    <li><a href="/categories/操作系统/">操作系统</a><small>4</small></li>
  
    <li><a href="/categories/数据结构/">数据结构</a><small>15</small></li>
  
    <li><a href="/categories/游戏开发/">游戏开发</a><small>1</small></li>
  
    <li><a href="/categories/计算机图形学/">计算机图形学</a><small>2</small></li>
  
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/BIOS和微机启动过程/">BIOS和微机启动过程</a><small>1</small></li>
  
    <li><a href="/tags/C-容器/">C#容器</a><small>1</small></li>
  
    <li><a href="/tags/C-IO/">C++IO</a><small>1</small></li>
  
    <li><a href="/tags/MarkDown/">MarkDown</a><small>1</small></li>
  
    <li><a href="/tags/Mathjax语法/">Mathjax语法</a><small>1</small></li>
  
    <li><a href="/tags/OS内核/">OS内核</a><small>1</small></li>
  
    <li><a href="/tags/OpenGL坐标系统/">OpenGL坐标系统</a><small>1</small></li>
  
    <li><a href="/tags/OpenGL摄像机/">OpenGL摄像机</a><small>1</small></li>
  
    <li><a href="/tags/OpenGL窗口/">OpenGL窗口</a><small>1</small></li>
  
    <li><a href="/tags/OpenGL配置/">OpenGL配置</a><small>1</small></li>
  
    <li><a href="/tags/timeTest/">timeTest</a><small>1</small></li>
  
    <li><a href="/tags/二叉树/">二叉树</a><small>1</small></li>
  
    <li><a href="/tags/光照场景/">光照场景</a><small>1</small></li>
  
    <li><a href="/tags/光照贴图/">光照贴图</a><small>1</small></li>
  
    <li><a href="/tags/关键路径/">关键路径</a><small>1</small></li>
  
    <li><a href="/tags/冯氏光照/">冯氏光照</a><small>1</small></li>
  
    <li><a href="/tags/几何着色器/">几何着色器</a><small>1</small></li>
  
    <li><a href="/tags/图/">图</a><small>1</small></li>
  
    <li><a href="/tags/图形学概述/">图形学概述</a><small>1</small></li>
  
    <li><a href="/tags/图形显示系统/">图形显示系统</a><small>1</small></li>
  
    <li><a href="/tags/多说/">多说</a><small>1</small></li>
  
    <li><a href="/tags/天空盒子/">天空盒子</a><small>1</small></li>
  
    <li><a href="/tags/头结点/">头结点</a><small>1</small></li>
  
    <li><a href="/tags/实例化/">实例化</a><small>1</small></li>
  
    <li><a href="/tags/尾递归/">尾递归</a><small>1</small></li>
  
    <li><a href="/tags/帧同步/">帧同步</a><small>1</small></li>
  
    <li><a href="/tags/帧缓冲/">帧缓冲</a><small>1</small></li>
  
    <li><a href="/tags/常见光源/">常见光源</a><small>1</small></li>
  
    <li><a href="/tags/拓扑排序/">拓扑排序</a><small>1</small></li>
  
    <li><a href="/tags/操作系统概述/">操作系统概述</a><small>1</small></li>
  
    <li><a href="/tags/改进排序/">改进排序</a><small>1</small></li>
  
    <li><a href="/tags/文件IO/">文件IO</a><small>1</small></li>
  
    <li><a href="/tags/最小生成树/">最小生成树</a><small>1</small></li>
  
    <li><a href="/tags/最短路径/">最短路径</a><small>1</small></li>
  
    <li><a href="/tags/材质/">材质</a><small>1</small></li>
  
    <li><a href="/tags/查找/">查找</a><small>1</small></li>
  
    <li><a href="/tags/栈/">栈</a><small>1</small></li>
  
    <li><a href="/tags/树/">树</a><small>1</small></li>
  
    <li><a href="/tags/模型加载/">模型加载</a><small>1</small></li>
  
    <li><a href="/tags/模板测试/">模板测试</a><small>1</small></li>
  
    <li><a href="/tags/深度测试/">深度测试</a><small>1</small></li>
  
    <li><a href="/tags/混合/">混合</a><small>1</small></li>
  
    <li><a href="/tags/着色器/">着色器</a><small>1</small></li>
  
    <li><a href="/tags/着色器画三角形/">着色器画三角形</a><small>1</small></li>
  
    <li><a href="/tags/简单排序/">简单排序</a><small>1</small></li>
  
    <li><a href="/tags/纹理/">纹理</a><small>1</small></li>
  
    <li><a href="/tags/缓冲对象/">缓冲对象</a><small>1</small></li>
  
    <li><a href="/tags/背面剔除/">背面剔除</a><small>1</small></li>
  
    <li><a href="/tags/进程的描述与控制/">进程的描述与控制</a><small>1</small></li>
  
    <li><a href="/tags/链表/">链表</a><small>1</small></li>
  
    <li><a href="/tags/队列/">队列</a><small>1</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2017 Elay
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>


<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</body>
</html>