<!DOCTYPE HTML>
<html>

<head>
	<link rel="bookmark"  type="image/x-icon"  href="/img/logo_miccall.png"/>
	 <link rel="shortcut icon" href="/img/logo_miccall.png">
	
			
    <title>
    Elays'Blog
    </title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="/css/mic_main.css" />
    <link rel="stylesheet" href="/css/dropdownMenu.css" />
    
    	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css" />
    </noscript>

			    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<link rel="stylesheet" href="/css/prism.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>
    
		
<!-- Layouts -->



<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_twilight.css" />
<link rel="stylesheet" href="/css/typo.css" />
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">MICCALL</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special" >
            <ul class="menu links" >
			<!-- Homepage  主页  --> 
			<li >
	            <a href="/" rel="nofollow">主页</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">分类</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="/categories/C-语法/">C#语法</a></li><li><a class="category-link" href="/categories/C/">C++</a></li><li><a class="category-link" href="/categories/C语言/">C语言</a></li><li><a class="category-link" href="/categories/OpenGL/">OpenGL</a></li><li><a class="category-link" href="/categories/c/">c++</a></li><li><a class="category-link" href="/categories/博客配置/">博客配置</a></li><li><a class="category-link" href="/categories/操作系统/">操作系统</a></li><li><a class="category-link" href="/categories/数据结构/">数据结构</a></li><li><a class="category-link" href="/categories/毕设/">毕设</a></li><li><a class="category-link" href="/categories/游戏开发/">游戏开发</a></li><li><a class="category-link" href="/categories/游戏设计模式/">游戏设计模式</a></li><li><a class="category-link" href="/categories/计算机图形学/">计算机图形学</a></li><li><a class="category-link" href="/categories/设计模式/">设计模式</a></li><li><a class="category-link" href="/categories/调试错误集锦/">调试错误集锦</a>
	                    </ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/about/" title="简历">
		                简历
		            </a>
		        </li>
		        
		        <li>
		            <a href="/group/" title="团队">
		                团队
		            </a>
		        </li>
		        
		        <li>
		            <a href="/gallery/" title="图库">
		                图库
		            </a>
		        </li>
		        
		        <li>
		            <a href="/tag/" title="标签">
		                标签
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
		            
		                <li><a href="https://github.com/miccall" class="icon fa-github"><span class="label">GitHub</span></a></li>
		            
		            
		            
		            
			</ul>
</nav>

        <div id="main" >
            <div class ="post_page_title_img" style="height: 25rem;background-image: url(undefined);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;" >
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2 >OpenGL20：立方体贴图</h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
                <p><font size="5" color="orange">立方体贴图概念及采样方法</font><br><a id="more"></a><br>立方体贴图包含6个2D纹理，每个2D纹理是立方体的一个面，也就是说它是一个有贴图的立方体。使用立方体贴图可以实现很多有意思的效果，比如天空盒、环境映射等等。</p>
<p>对于2D纹理，可以通过纹素的2D坐标来采样，那么立方体纹理怎样采样呢？它的采样方式类似下图：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148508140727.png" alt=""><br>如果立方体的中心位于原点上，那么可以通过原点到立方体表面片段的向量来采样，如上图中的橘黄色向量。也就是说，我们可以直接使用片段的位置向量（或者说片段坐标）来进行采样，在顶点着色器里将片段的位置坐标直接赋值给输出变量纹理坐标：</p>
<pre class=" language-c++"><code class="language-c++">void main(){
    gl_Position = position;
    TexCoords = position;
}
</code></pre>
<p>利用(s,t,r)采样时，首先根据(s,t,r)中模最大的分量决定在哪个面采样，然后使用剩下的2个坐标在对应的面上做2D纹理采样。例如，如果(s,t,r)中s分量的模最大，且符号为正，则决定选取+x面作为采样的2D纹理，然后使用(t,r)坐标在+x面上做2D纹理采样。</p>
<p>这6个面在OpenGL中指定如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148508140813.png" alt=""><br>这几个枚举常量其实是连续的，可以循环遍历，在OpenGL中它们定义如下：</p>
<pre class=" language-c++"><code class="language-c++">#define GL_TEXTURE_CUBE_MAP_POSITIVE_X 0x8515
#define GL_TEXTURE_CUBE_MAP_NEGATIVE_X 0x8516
#define GL_TEXTURE_CUBE_MAP_POSITIVE_Y 0x8517
#define GL_TEXTURE_CUBE_MAP_NEGATIVE_Y 0x8518
#define GL_TEXTURE_CUBE_MAP_POSITIVE_Z 0x8519
#define GL_TEXTURE_CUBE_MAP_NEGATIVE_Z 0x851A
</code></pre>
<p>&nbsp; </p>
<hr>
<p><font size="5" color="orange">创建立方体贴图</font><br>既然立方体贴图有6个纹理，那么我们需要把这6张纹理都加载进来，生成一个最终的立方体纹理贴图。我们把这部分代码写入自定义类<code>CubemapLoader</code>的<code>loadCubemap</code>方法中：</p>
<p>首先，创建立方体贴图对象和创建普通纹理一样，只是绑定目标变成了<code>GL_TEXTURE_CUBE_MAP</code>：</p>
<pre class=" language-c++"><code class="language-c++">        GLuint cubemap;
        glGenTextures(1, &cubemap);
        glBindTexture(GL_TEXTURE_CUBE_MAP, cubemap);
</code></pre>
<p>接下来我们加载立方体贴图的6张纹理：</p>
<pre class=" language-c++"><code class="language-c++">        int width, height;
        unsigned char* image;
        for (int i = 0; i < facePaths.size(); i++) {
            image = SOIL_load_image(facePaths[i], &width, &height, 0, SOIL_LOAD_RGB);
            glTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, image);
        }
</code></pre>
<p>其中<code>facePaths</code>是函数<code>loadCubemap</code>的参数，指明6张纹理的路径。在使用<code>glTexImage2D</code>函数生成纹理时，目标应该是具体的立方体的某个面。由于立方体的每个面都有一个常数来表示，而且是连续的，所以我们就用<code>GL_TEXTURE_CUBE_MAP_POSITIVE_X</code>和迭代遍历i来循环遍历了。</p>
<p>接着需要设置立方体纹理贴图的参数，环绕方式和过滤方式设置如下：</p>
<pre class=" language-c++"><code class="language-c++">        glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
        glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
        glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);
        glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
        glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
</code></pre>
<p>将立方体贴图在S、T、R方向上的环绕方式设为了<code>GL_CLAMP_TO_EDGE</code>，这是指明当(s,t,r)坐标没有落在哪个面，而是落在两个面之间时，采样为边缘的纹理值。</p>
<p>完整的<code>CubemapLoader</code>类可见后面的源码。<br>&nbsp; </p>
<hr>
<p><font size="5" color="orange">立方体贴图应用之天空盒</font><br>我们之前的场景背景一直都是用的<code>glClearColor</code>，现在我们想让场景的背景是一片天空。而立方体贴图完全满足这个要求，我们在场景中绘制一个使用cubemap纹理的立方体，将这个立方体总是置于场景外围，让玩家感觉好像场景很长大，触不可及像天空一样，但是实际上他还是在一个小盒子中。我们要用到的天空盒子贴图可在<a href="https://learnopengl-cn.github.io/img/04/06/skybox.rar" target="_blank" rel="external">这里下载</a>。</p>
<p> 天空盒也是一个立方体，当然也需要为它设置顶点属性，VAO以及顶点数据解析。顶点数据如下，其它的可参考后面的主程序源码：</p>
<pre class=" language-c++"><code class="language-c++">    //天空盒的顶点坐标
    GLfloat skyboxVertices[] = {
        //位置坐标         
        //立方体前面
        1.0f, 1.0f, 1.0f,
        1.0f,-1.0f, 1.0f,
       -1.0f,-1.0f, 1.0f,
       -1.0f, 1.0f, 1.0f,
        //立方体后面
        1.0f, 1.0f,-1.0f,
        1.0f,-1.0f,-1.0f,
       -1.0f,-1.0f,-1.0f,
       -1.0f, 1.0f,-1.0f,
        //立方体上面
        1.0f, 1.0f, 1.0f,
        1.0f, 1.0f,-1.0f,
       -1.0f, 1.0f,-1.0f,
       -1.0f, 1.0f, 1.0f,
        //立方体下面
        1.0f,-1.0f, 1.0f,
        1.0f,-1.0f,-1.0f,
       -1.0f,-1.0f,-1.0f,
       -1.0f,-1.0f, 1.0f,
        //立方体右面
        1.0f, 1.0f, 1.0f,
        1.0f, 1.0f,-1.0f,
        1.0f,-1.0f,-1.0f,
        1.0f,-1.0f, 1.0f,
        //立方体左面
       -1.0f, 1.0f, 1.0f,
       -1.0f, 1.0f,-1.0f,
       -1.0f,-1.0f,-1.0f,
       -1.0f,-1.0f, 1.0f
    };
</code></pre>
<p>这里我们让这个天空盒的坐标绝对值都取为1，好让它填充满整个窗口。</p>
<p>然后我们生成天空盒的立方体贴图，需要加载6个纹理：</p>
<pre class=" language-c++"><code class="language-c++">    //立方体贴图的6个纹理的路径
    vector<const GLchar*> facePaths;
    facePaths.push_back("skybox/right.jpg");
    facePaths.push_back("skybox/left.jpg");
    facePaths.push_back("skybox/top.jpg");
    facePaths.push_back("skybox/bottom.jpg");
    facePaths.push_back("skybox/back.jpg");
    facePaths.push_back("skybox/front.jpg");
    CubemapLoader cubemapLoader;
    GLuint cubemap = cubemapLoader.loadCubemap(facePaths);
</code></pre>
<p>要画出这个天空盒，我们还需要给它写顶点着色器（写在cubemap.vertex中）和像素着色器（写在cubemap.fragment中）：</p>
<pre class=" language-c++"><code class="language-c++">#version 330 core
layout (location=0) in vec3 position;
out vec3 TexCoords;

uniform mat4 view;
uniform mat4 projection;

void main(){
    gl_Position = projection * view * vec4(position,1.0f);
    TexCoords = position;
}
</code></pre>
<p>天空盒子不需要从模型坐标系到世界坐标系的平移、旋转、缩放，所以这里就没有写model矩阵。其实OpenGL是会自动给乘上一个model单位矩阵的。我们还让纹理坐标直接等于片段的位置坐标，因为此时的天空盒子中心是在原点的，可以直接使用片段的位置向量作为采样向量。注意纹理坐标是3维的。</p>
<pre class=" language-c++"><code class="language-c++">#version 330 core
in vec3 TexCoords;
out vec4 color;

uniform samplerCube cubemap;

void main(){
    color = texture(cubemap,TexCoords);
}
</code></pre>
<p>像素着色器很简单，直接让片段最终颜色等于立方体贴图采样的纹素颜色就可以。</p>
<p>当然，肯定还需要给天空盒子定义一个着色器类对象：</p>
<pre class=" language-c++"><code class="language-c++">    shader skybox_shader("cubemap.vertex", "cubemap.fragment");
</code></pre>
<p>接下来我们在渲染循环里绘制这个天空盒子。在绘制天空盒子之前，我们需要关闭面剔除，否则天空盒子不会显示，因为我们现在是正处于天空盒子内部的，如果不关闭面剔除，它的每个面都将被剔除掉；而且还要禁用深度写入，否则场景中的其他物体都会被天空盒子覆盖掉，其他物体将不能通过深度测试而被抛弃：</p>
<pre class=" language-c++"><code class="language-c++">        //Draw skybox
        glDisable(GL_CULL_FACE);
        glDepthMask(GL_FALSE);
</code></pre>
<p>接下来就是和绘制普通立方体一样，来绘制天空盒了：</p>
<pre class=" language-c++"><code class="language-c++">        skybox_shader.Use();
        mat4 view = mycamera.GetViewMatrix();
        mat4 projection = perspective(radians(mycamera.cameraFov), (GLfloat)WIDTH / (GLfloat)HEIGHT, 0.1f, 100.0f);
        glUniformMatrix4fv(glGetUniformLocation(skybox_shader.shaderProgram, "view"), 1, GL_FALSE, value_ptr(view));
        glUniformMatrix4fv(glGetUniformLocation(skybox_shader.shaderProgram, "projection"), 1, GL_FALSE, value_ptr(projection));
        glBindVertexArray(skyboxVAO);
        glBindTexture(GL_TEXTURE_CUBE_MAP, cubemap);
        glDrawElements(GL_TRIANGLES, 36, GL_UNSIGNED_INT, 0);
        glDepthMask(GL_TRUE);
        glEnable(GL_CULL_FACE);
</code></pre>
<p>后面再照常绘制其他物体就可以了。</p>
<p>编译运行后的结果如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148508141071.png" alt=""><br>移动摄像机，会发现天空盒子也会跟着移动，给人的感觉确实就是个盒子，而不是一片浩瀚的天空。要解决这个问题，我们需要让天空盒子不会随着摄像机移动而移动。天空盒子之所以会移动，是因为在它的顶点着色器中顶点坐标乘上了观察矩阵view，这个观察矩阵是随着摄像机移动而改变的。我们可以去掉观察矩阵的平移部分，把4x4的矩阵改成3x3即可（线性代数知识）。我们在主程序中完成这个操作，然后把新的观察矩阵发送给顶点着色器：</p>
<pre class=" language-c++"><code class="language-c++">        mat4 view = mat4(mat3(mycamera.GetViewMatrix()));
        glUniformMatrix4fv(glGetUniformLocation(skybox_shader.shaderProgram, "view"), 1, GL_FALSE, value_ptr(view));
</code></pre>
<p>这样编译运行后的结果就正常了：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148508141352.png" alt=""><br>&nbsp; </p>
<hr>
<p><font size="5" color="orange">优化</font><br>上面再绘制天空包围盒时，我们首先禁用了深度缓冲写入，再绘制包围盒，让它处于场景外围，这样做虽然能正常工作，缺点是如果场景中有的物体挡住了天空，按照上面的绘制方式，这部分被挡住的天空还是被绘制了，只是后来又被其他物体（比如场景中的箱子）覆盖了，这导致了不必要的着色器调用，是一种性能上的损失。</p>
<p>所以，绘制天空盒时，我们还是得允许深度写入。但是我们想办法让天空盒的深度最大（1.0），因为它是最外围的。如果有物体挡住了它，被遮挡住的天空盒部分将无法通过深度测试，会被丢弃。那么如何让天空盒的每一个片段的深度值都等于1.0呢？我们在天空盒的顶点着色器中做如下操作：</p>
<pre class=" language-c++"><code class="language-c++">void main(){
    vec4 pos = projection * view * vec4(position,1.0f);
    gl_Position = pos.xyww;
    TexCoords = position;
}
</code></pre>
<p>我们把顶点坐标的z值改成了w。正如我们以前就知道的，z值代表了该片段的深度值。在投影变换之后OpenGL会进行透视除法，顶点的x、y、z都会去除以w，因为我们把z值变成了w，所以透视除法的结果就是每个顶点的z值都变成了1.0。</p>
<p>注意这时我们应该改变一下通过深度测试的条件：应该是小于等于时通过深度测试，而不是默认的小于，否则下一次渲染循环的天空深度值因为等于1.0，和深度缓冲的深度值里一样，将会被丢弃，导致天空无法显示出来：</p>
<pre class=" language-c++"><code class="language-c++">    //深度测试函数
    glDepthFunc(GL_LEQUAL);
</code></pre>
<p>所有源码<a href="https://github.com/Popperelay/BlogCode/tree/master/LearnOpenGL20_CubeMap/LearnOpenGL20_CubeMap_1" target="_blank" rel="external">在这里</a>。<br>&nbsp; </p>
<hr>
<p><font size="5" color="orange">环境映射</font><br>我们使用立方体贴图能够渲染的不只是天空盒，可以是任何大环境，比如一个山谷、一个空间内部等等。我们可以利用这些带有场景的立方体贴图，让物体可以反射或折射周围的环境。像这样使用了环境立方体贴图的技术叫做环境贴图技术，其中最重要的是反射和折射。由于我们着重关注怎么让物体反射和折射环境，所以我们还是使用之前的天空盒，让箱子反射和折射天空。</p>
<p><font size="4" color="red">反射</font><br>反射是一个物体（或物体的，某部分）反射（Reflect）它周围环境的属性，比如物体的颜色多少有些等于它周围的环境，这要基于观察者的角度。</p>
<p>下图展示了如何计算反射向量，然后使用这个反射向量去立方体贴图中采样：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148509525977.png" alt=""><br>计算反射向量的方法已经在<a href="http://popperelay.com/2016/12/12/OpenGL10%E5%85%89%E7%85%A7%E5%9F%BA%E7%A1%80/" target="_blank" rel="external">《OpenGL10：光照基础Phong模型》</a> 里讲过了，原理很简单，我们直接上代码：</p>
<pre class=" language-c++"><code class="language-c++">#version 330 core
in vec3 Normal;
in vec3 PositionInWorld;
out vec4 color;

uniform vec3 cameraPos;
uniform samplerCube cubemap;

void main(){
    vec3 I = normalize(PositionInWorld - cameraPos);
    vec3 R = reflect(I,normalize(Normal));
    color = texture(cubemap,R);
}
</code></pre>
<p>对应的顶点着色器为：</p>
<pre class=" language-c++"><code class="language-c++">#version 330 core
layout (location=0) in vec3 position;
layout (location=1) in vec3 normal;
out vec3 Normal;
out vec3 PositionInWorld;

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;

void main(){
    gl_Position = projection * view * model * vec4(position,1.0f);
    Normal = mat3(transpose(inverse(model))) * normal;
    PositionInWorld = vec3(model * vec4(position,1.0f));
}
</code></pre>
<p>既然要用到法线向量，那还得给立方体顶点添加法线数据：</p>
<pre class=" language-c++"><code class="language-c++">    //立方体顶点的坐标、法线向量
    GLfloat cubeVertices[] = {
        //位置坐标          //法线
        //立方体前面
        0.5f, 0.5f, 0.5f,   0, 0, 1,
        0.5f,-0.5f, 0.5f,   0, 0, 1,
        -0.5f,-0.5f, 0.5f,  0, 0, 1,
        -0.5f, 0.5f, 0.5f,  0, 0, 1,
        //立方体后面
        0.5f, 0.5f,-0.5f,   0, 0,-1,
        0.5f,-0.5f,-0.5f,   0, 0,-1,
        -0.5f,-0.5f,-0.5f,  0, 0,-1,
        -0.5f, 0.5f,-0.5f,  0, 0,-1,
        //立方体上面
        0.5f, 0.5f, 0.5f,   0, 1, 0,
        0.5f, 0.5f,-0.5f,   0, 1, 0,
        -0.5f, 0.5f,-0.5f,  0, 1, 0,
        -0.5f, 0.5f, 0.5f,  0, 1, 0,
        //立方体下面
        0.5f,-0.5f, 0.5f,   0,-1, 0,
        0.5f,-0.5f,-0.5f,   0,-1, 0,
        -0.5f,-0.5f,-0.5f,  0,-1, 0,
        -0.5f,-0.5f, 0.5f,  0,-1, 0,
        //立方体右面
        0.5f, 0.5f, 0.5f,   1, 0, 0,
        0.5f, 0.5f,-0.5f,   1, 0, 0,
        0.5f,-0.5f,-0.5f,   1, 0, 0,
        0.5f,-0.5f, 0.5f,   1, 0, 0,
        //立方体左面
        -0.5f, 0.5f, 0.5f, -1, 0, 0,
        -0.5f, 0.5f,-0.5f, -1, 0, 0,
        -0.5f,-0.5f,-0.5f, -1, 0, 0,
        -0.5f,-0.5f, 0.5f, -1, 0, 0
    };
</code></pre>
<p>当然，对应的数据解析也得作调整了，不再赘述。环境反射的所有源码<a href="https://github.com/Popperelay/BlogCode/tree/master/LearnOpenGL20_CubeMap/LearnOpenGL20_CubeMap_2" target="_blank" rel="external">在这里</a>。</p>
<p>编译运行后的结果如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148509526094.png" alt=""><br>可以看到我们得到了一个镜子一样的箱子，完美地反射了周围的天空盒。如果是球模型，会更明显：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148509526198.png" alt=""></p>
<p><font size="4" color="red">折射</font><br>环境映射的另一个形式是折射。如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148509526251.png" alt=""><br>我们可以通过折射向量R来从立方体贴图上采样。</p>
<p>折射可以通过GLSL的内置函数refract来计算，它需要3个参数：观察向量、法线向量、折射指数：</p>
<pre class=" language-c++"><code class="language-c++">void main(){
    //折射
    float ratio = 1.00/1.52;
    vec3 I = normalize(PositionInWorld - cameraPos);
    vec3 R = refract(I,normalize(Normal),ratio);
    color = texture(cubemap,R);
}
</code></pre>
<p>折射指数决定了一个材质上光线扭曲的数量，每个材质都有自己的折射指数。下表是常见的折射指数：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148509526295.png" alt=""><br>编译运行后的结果如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148509526374.png" alt=""><br>环境折射的所有源码<a href="https://github.com/Popperelay/BlogCode/tree/master/LearnOpenGL20_CubeMap/LearnOpenGL20_CubeMap_3" target="_blank" rel="external">在这里</a>。<br>&nbsp; </p>
<hr>
<p><font size="5" color="orange">动态环境贴图</font><br>现在我们的环境立方体贴图还只是静态的。但是如果我们有个镜子一样的物体，它周围有多个物体，当移动摄像机或者移动镜子物体时，它所反射/折射的环境应该是变化挺大的，用静态的立方体贴图显然不够逼真。</p>
<p>可以使用帧缓冲为镜子物体的所有6个不同角度创建一个场景的纹理，把它们每次渲染迭代存储为一个立方体贴图。之后我们可以使用这个（动态生成的）立方体贴图来创建真实的反射和折射表面。这种方法叫做动态环境映射（Dynamic Environment Mapping），因为我们动态地创建了一个物体的以其四周为参考的立方体贴图，并把它用作环境贴图。</p>
<p>这种方法看起来效果很好，但是有一个缺点：我们必须为每个物体渲染场景6次，这需要非常大的开销。我们还是应该尽量使用静态的天空盒子，尽量减少动态环境贴图的使用。想要在不降低执行效率的情况下实现动态环境贴图还需要很多巧妙的技巧。<br>&nbsp; </p>
<hr>
<p>参考文献：<a href="https://learnopengl.com/" target="_blank" rel="external">LearnOpenGL</a></p>

            </div>

            <!-- Post Comments -->
            
    <!-- 使用 DISQUS_CLICK -->
<div id="disqus-comment">
    <div id="disqus_thread"></div>

<!-- add animation -->
<style>
	.disqus_click_btn {
            line-height: 30px;
            margin: 0;
            min-width: 50px;
            padding: 0 14px;
            display: inline-block;
            font-family: "Roboto", "Helvetica", "Arial", sans-serif;
            font-size: 14px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0;
            overflow: hidden;
            will-change: box-shadow;
            transition: box-shadow .2s cubic-bezier(.4, 0, 1, 1), background-color .2s cubic-bezier(.4, 0, .2, 1), color .2s cubic-bezier(.4, 0, .2, 1);
            outline: 0;
            cursor: pointer;
            text-decoration: none;
            text-align: center;
            vertical-align: middle;
            border: 0;
            background: rgba(158, 158, 158, .2);
            box-shadow: 0 2px 2px 0 rgba(0, 0, 0, .14), 0 3px 1px -2px rgba(0, 0, 0, .2), 0 1px 5px 0 rgba(0, 0, 0, .12);
            color: #fff;
            background-color: #7EC0EE;
            text-shadow: 0
        }
</style>
	
<div class="btn_click_load" id="disqus_bt"> 
    <button class="disqus_click_btn">点击查看评论</button>
</div>

<!--
<script type="text/javascript">
$('.btn_click_load').click(function() {
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'http-miccall-tech'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    document.getElementById('disqus_bt').style.display = "none";
});
</script>
-->
<script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://yoursite.com/2017/01/22/OpenGL20立方体贴图/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = 'http://yoursite.com/2017/01/22/OpenGL20立方体贴图/'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
</script>

<script type="text/javascript">
    $('.btn_click_load').click(function() {  //click to load comments
        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document;
            var s = d.createElement('script');
            s.src = '//http-miccall-tech.disqus.com/embed.js';
            s.setAttribute('data-timestamp', + new Date());
            (d.head || d.body).appendChild(s);
        })();
        $('.btn_click_load').css('display','none');
    });
</script>
</div>
<style>
    #disqus-comment{
        background-color: #eee;
        padding: 2pc;
    }
</style>


        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
                <li>Design: <a href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
            </ul>
            
            	<span id="busuanzi_container_site_pv">2017总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			
        </div>
    </div>
</body>



 	
</html>
