<!DOCTYPE HTML>
<html>

<head>
	<link rel="bookmark"  type="image/x-icon"  href="/img/logo_miccall.png"/>
	 <link rel="shortcut icon" href="/img/logo_miccall.png">
	
			
    <title>
    Elays'Blog
    </title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="/css/mic_main.css" />
    <link rel="stylesheet" href="/css/dropdownMenu.css" />
    
    	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css" />
    </noscript>

			    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<link rel="stylesheet" href="/css/prism.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>
    
		
<!-- Layouts -->



<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_twilight.css" />
<link rel="stylesheet" href="/css/typo.css" />
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">MICCALL</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special" >
            <ul class="menu links" >
			<!-- Homepage  主页  --> 
			<li >
	            <a href="/" rel="nofollow">主页</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">分类</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="/categories/C-语法/">C#语法</a></li><li><a class="category-link" href="/categories/C/">C++</a></li><li><a class="category-link" href="/categories/C语言/">C语言</a></li><li><a class="category-link" href="/categories/OpenGL/">OpenGL</a></li><li><a class="category-link" href="/categories/c/">c++</a></li><li><a class="category-link" href="/categories/博客配置/">博客配置</a></li><li><a class="category-link" href="/categories/操作系统/">操作系统</a></li><li><a class="category-link" href="/categories/数据结构/">数据结构</a></li><li><a class="category-link" href="/categories/毕设/">毕设</a></li><li><a class="category-link" href="/categories/游戏开发/">游戏开发</a></li><li><a class="category-link" href="/categories/游戏设计模式/">游戏设计模式</a></li><li><a class="category-link" href="/categories/计算机图形学/">计算机图形学</a></li><li><a class="category-link" href="/categories/设计模式/">设计模式</a></li><li><a class="category-link" href="/categories/调试错误集锦/">调试错误集锦</a>
	                    </ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/about/" title="简历">
		                简历
		            </a>
		        </li>
		        
		        <li>
		            <a href="/group/" title="团队">
		                团队
		            </a>
		        </li>
		        
		        <li>
		            <a href="/gallery/" title="图库">
		                图库
		            </a>
		        </li>
		        
		        <li>
		            <a href="/tag/" title="标签">
		                标签
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
		            
		                <li><a href="https://github.com/miccall" class="icon fa-github"><span class="label">GitHub</span></a></li>
		            
		            
		            
		            
			</ul>
</nav>

        <div id="main" >
            <div class ="post_page_title_img" style="height: 25rem;background-image: url(undefined);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;" >
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2 >OpenGL17：混合</h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
                <p>在OpenGL中，物体透明技术通常被叫做混合（Blending）。<a id="more"></a><br>&nbsp; </p>
<hr>
<p><font size="5" color="orange">透明</font><br>透明是指物体自身颜色与它背面物体颜色不同程度的混合，而在OpenGL中就是使用混合技术来实现的，将当前要绘制的物体的颜色和颜色缓冲区中已经绘制了的物体颜色进行混合，最终决定当前物体的颜色。下图是一副全透明和半透明的窗子：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148462342512.png" alt=""><br>物体的透明度是由片段颜色的alpha值（颜色向量的第4个元素）决定的，全透明的alpha值是0.0即透明度是100%，不透明的alpha值是1.0即透明度是0%。<br>&nbsp; </p>
<hr>
<p><font size="5" color="orange">丢弃片段来实现全透明</font><br>有些纹理是纹理部分要么全透明，要么不透明，不存在半透明的部分。如下面的草纹理，它没有半透明的部分：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148463674953.png" alt=""><br>对于这种纹理，我们可以直接丢弃全透明部分的片段，没有必要将它存储到颜色缓冲中，更没有必要使用混合技术。</p>
<p>首先，我们需要更改一下SOIL加载图片的方式，我们需要以RGBA的方式去加载带有alpha值的纹理（如果某些像素没有alpha值将会被设为1.0）：</p>
<pre class=" language-c++"><code class="language-c++">    //加载纹理图像
    unsigned char* image = SOIL_load_image(texturePath, &imageWidth, &imageHeight, 0, SOIL_LOAD_RGBA);
</code></pre>
<p>不要忘记还要改变OpenGL生成纹理的方式：</p>
<pre class=" language-c++"><code class="language-c++">    //生成2D纹理
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, imageWidth, imageHeight, 0, GL_RGBA, GL_UNSIGNED_BYTE, image);
</code></pre>
<p>绘制草的着色器很简单，仅仅是让片段颜色等于纹素颜色而已，代码如下：<br>顶点着色器（写在grass.vertex中）：</p>
<pre class=" language-c++"><code class="language-c++">#version 330 core
layout (location=0) in vec3 position;
layout (location=1) in vec2 texCoords;

out vec2 TexCoords;

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;

void main(){
    gl_Position = projection * view * model * vec4(position,1.0f);
    TexCoords = vec2(texCoords.x ,1 - texCoords.y); 
}
</code></pre>
<p>像素着色器（写在grass.fragment中）：</p>
<pre class=" language-c++"><code class="language-c++">#version 330 core
in vec2 TexCoords;
out vec4 color;

uniform sampler2D texture1;

void main(){
    color = texture(texture1,TexCoords);
}
</code></pre>
<p>设置草平面的顶点属性如下：</p>
<pre class=" language-c++"><code class="language-c++">    //草平面的顶点属性（位置坐标、纹理坐标）
    GLfloat grass_vertices[] = {
        //顶点位置坐标    //纹理坐标
        0.5f, 0.5f, 0.0f, 1.0f,1.0f,
        0.5f,-0.5f, 0.0f, 1.0f,0.0f,
       -0.5f, 0.5f, 0.0f, 0.0f,1.0f,

        0.5f,-0.5f, 0.0f, 1.0f,0.0f,
       -0.5f, 0.5f, 0.0f, 0.0f,1.0f,
       -0.5f,-0.5f, 0.0f, 0.0f,0.0f,

    };
</code></pre>
<p>接下来需要对它进行VAO绑定和数据解析：</p>
<pre class=" language-c++"><code class="language-c++">    //草平面顶点数据的绑定和解析
    GLuint grassVAO, grassVBO;
    glGenVertexArrays(1, &grassVAO);
    glBindVertexArray(grassVAO);
    glGenBuffers(1, &grassVBO);
    glBindBuffer(GL_ARRAY_BUFFER, grassVBO);
    glBufferData(GL_ARRAY_BUFFER, sizeof(grass_vertices), grass_vertices, GL_STATIC_DRAW);
    glEnableVertexAttribArray(0);
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 5 * sizeof(GL_FLOAT), (GLvoid*)0);
    glEnableVertexAttribArray(1);
    glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 5 * sizeof(GL_FLOAT), (GLvoid*)(3 * sizeof(GL_FLOAT)));
    glBindVertexArray(0);
</code></pre>
<p>还需要加载草纹理：</p>
<pre class=" language-c++"><code class="language-c++">    TextureLoader texLoader;
    GLuint grassTexture = texLoader.LoadTexture("grass.png");
</code></pre>
<p>由于要绘制多株草，我们给每株草设置不同的位置：</p>
<pre class=" language-c++"><code class="language-c++">    //草的位置
    vector<vec3> grass_location;
    grass_location.push_back(vec3(-1.5f, 0.0f, -0.48f));
    grass_location.push_back(vec3(1.5f, 0.0f, 0.51f));
    grass_location.push_back(vec3(0.0f, 0.0f, 0.7f));
    grass_location.push_back(vec3(-0.3f, 0.0f, -2.3f));
    grass_location.push_back(vec3(0.5f, 0.0f, -0.6f));
</code></pre>
<p>为了绘制草所定义的着色器对象如下：</p>
<pre class=" language-c++"><code class="language-c++">    shader grass_shader("grass.vertex", "grass.fragment");
</code></pre>
<p>最后就是在渲染循环里绘制几株草了：</p>
<pre class=" language-c++"><code class="language-c++">        //绘制几株草
        glBindVertexArray(grassVAO);
        glBindTexture(GL_TEXTURE_2D, grassTexture);
        for (int i = 0; i < grass_location.size(); i++) {
            model = mat4();
            model = translate(model, grass_location[i]);
            glUniformMatrix4fv(glGetUniformLocation(grass_shader.shaderProgram, "model"), 1, GL_FALSE, value_ptr(model));
            glDrawArrays(GL_TRIANGLES, 0, 6);
        }
        glBindVertexArray(0);
</code></pre>
<p>编译运行后的结果如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/14846367522.png" alt=""><br>出现这种结果是因为OpenGL默认是不知道如何处理alpha值得，需要我们自己来设置。在像素着色器中，当片段的alpha值小于某一指定值时，就使用discard命令丢弃它。discard是GLSL为我们提供的用于丢弃片段的命令：</p>
<pre class=" language-c++"><code class="language-c++">#version 330 core
in vec2 TexCoords;
out vec4 color;

uniform sampler2D texture1;

void main(){
    vec4 texColor = texture(texture1,TexCoords);
    if(texColor.a < 0.1)
        discard;
    color=texColor;
}
</code></pre>
<p>编译运行后的结果如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148463921017.png" alt=""><br>可以看到绘制出来的每张草纹理上方会有一个白边，这是因为我们的纹理设置得是REPEAT环绕方式，在采样纹理边缘的时候，OpenGL会在该边缘和环绕的下一张重复纹理的边缘之间插值，这里上方的白边就是草纹理的透明上边缘和下边缘（绿色）插值的结果。为了防止四周这种白边的出现，我们需要把纹理环绕方式设置为<code>GL_CLAMP_TO_EDGE</code>：</p>
<pre class=" language-c++"><code class="language-c++">    //设置纹理s和t方向的环绕方式
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
</code></pre>
<p>编译运行后的结果如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148463922702.png" alt=""><br>草确实没有了白边，但是地面很诡异了，地面纹理边缘也被拉伸了。地面纹理和草纹理应该是不同的环绕方式，所以，我们给TextureLoader类的<code>LoadTexture</code>函数加一个参数，表示s和t方向上的环绕方式，函数声明如下：</p>
<pre class=" language-c++"><code class="language-c++">    GLuint LoadTexture(const GLchar* texturePath, GLint wrap_st = GL_REPEAT);
</code></pre>
<p>在<code>LoadTexture</code>函数的实现中，就用这个<code>wrap_st</code>参数来设置纹理环绕方式：</p>
<pre class=" language-c++"><code class="language-c++">    //设置纹理s和t方向的环绕方式
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, wrap_st);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, wrap_st);
</code></pre>
<p>现在加载草纹理和地面纹理应该是这样：</p>
<pre class=" language-c++"><code class="language-c++">    TextureLoader texLoader;
    GLuint grassTexture = texLoader.LoadTexture("grass.png", GL_CLAMP_TO_EDGE);
    GLuint planeTexture = texLoader.LoadTexture("container.jpg");
</code></pre>
<p>编译运行后的结果如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148463924882.png" alt=""><br>所有源码<a href="https://github.com/Popperelay/BlogCode/tree/master/LearnOpenGL17_Blend/LearnOpenGL17_Blend_1" target="_blank" rel="external">在这里</a>。<br>&nbsp; </p>
<hr>
<p><font size="5" color="orange">混合原理</font><br>上诉丢弃片段的方式，虽然可以实现全透明效果，但是不能渲染半透明图像。为了能够实现半透明，我们需要先开启混合：</p>
<pre class=" language-c++"><code class="language-c++">    //开启混合
    glEnable(GL_BLEND);
</code></pre>
<p><font size="4" color="red">混合方程</font><br>OpenGL是按照以下混合方程进行混合的：<br>$$<br>\begin{equation}<br>Result=source*sFactor+destination*dFactor<br>\end{equation}<br>$$<br>source是源颜色向量，是将要绘制的纹理的颜色向量；destination是目标颜色向量，是存储在颜色缓冲中当前位置的颜色向量。sFactor和dFactor分别是对源颜色目标颜色的影响系数。</p>
<p>系数着色器运行完成并且所有的测试都通过以后，混合方程才开始执行。方程中的源和目标颜色会自动被OpenGL设置，而源和目标颜色的影响因子是由我们来设置的。比如现在有以下两个方块（或者说放大了的片段）：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148464152063.png" alt=""><br>我们希望在红色方块上绘制绿色方块。红色方块将是目标颜色（它会先进入颜色缓冲中），绿色方块将是源颜色。如果我们把源颜色影响因子设为源颜色的alpha值0.6， 把目标颜色影响因子设为剩下（1-0.6），那么混合方程将是：<br>$$<br>\begin{equation}<br>Result =<br>\begin{pmatrix}<br>0.0 \\<br>1.0 \\<br>0.0 \\<br>0.6<br>\end{pmatrix}<br>* 0.6 +<br>\begin{pmatrix}<br>1.0 \\<br>0.0 \\<br>0.0 \\<br>1.0 \\<br>\end{pmatrix}<br>* (1 - 0.6)<br>\end{equation}<br>$$<br>最终方块将包含60%的绿色和40的红色：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/14846421609.png" alt=""></p>
<p><font size="4" color="red">设置源和目标颜色的影响因子</font><br>我们使用<code>glBlendFunc</code>函数来设置这两个影响因子，函数原型如下：</p>
<pre class=" language-c++"><code class="language-c++">void glBlendFunc(GLenum sfactor, GLenum dfactor)
</code></pre>
<p>这两个参数可以设置为下列选项：<br><img src="" alt=""><br>为了获得混合效果，把源颜色的alpha给源因子，1-alpha给目标因子：</p>
<pre class=" language-c++"><code class="language-c++">glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
</code></pre>
<p><code>glBlendFunc</code>函数是为R、G、B、A这四个分量都设置了相同的影响因子。其实我们还可以不用混合方程，直接使用<code>glBlendFuncSeperate</code>函数为最终颜色的每个分量设置一个值，例如：</p>
<pre class=" language-c++"><code class="language-c++">glBlendFuncSeperate(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA,GL_ONE, GL_ZERO);
</code></pre>
<p><font size="4" color="red">混合方程不止于加</font><br>我们之前给的混合方程是源颜色和目标颜色按比例相加，其实还可以是减、逆序减。这需要用到<code>glBlendEquation</code>函数。函数原型如下：</p>
<pre class=" language-c++"><code class="language-c++">void glBlendEquation(GLenum mode)
</code></pre>
<p>它的参数有以下选项：</p>
<ul>
<li>GL_FUNC_ADD：相加，这是默认的，$Result = Src + Dst$。</li>
<li>GL_FUNC_SUBTRACT：相减，$Result = Src - Dst$。</li>
<li>GL_FUNC_REVERSE_SUBTRACT：反过来相减，$Result = Dst - Src$。<br>通常可以省略<code>glBlendEquation</code>函数，因为大多数时候我们需要的混合效果都是相加的，这恰好是默认的。<br>&nbsp; </li>
</ul>
<hr>
<p><font size="5" color="orange">渲染半透明纹理</font><br>现在我们开始用OpenGL来渲染下面这个半透明的窗子：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/14846446012.png" alt=""></p>
<p>首先我们需要开启混合，并设置合适的混合方程：</p>
<pre class=" language-c++"><code class="language-c++">    //开启混合
    glEnable(GL_BLEND);
    //混合方程
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
</code></pre>
<p>这里是让源颜色影响因子等于源颜色的alpha值，目标颜色的影响因子等于1-源颜色的alpha。</p>
<p> 现在我们是用混合来绘制半透明窗子的，不需要丢弃片段了，将像素着色器改回来：</p>
<pre class=" language-c++"><code class="language-c++">#version 330 core
in vec2 TexCoords;
out vec4 color;

uniform sampler2D texture1;

void main(){
    /*vec4 texColor = texture(texture1,TexCoords);
    if(texColor.a < 0.1)
        discard;
    color=texColor;*/
    color = texture(texture1,TexCoords);
}
</code></pre>
<p>编译运行后的结果如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148464557355.png" alt=""><br>&nbsp; </p>
<hr>
<p>但是有个很明显的问题，前面的窗子并不能透明显示后面的窗子。这是因为深度测试并不关心alpha值，所以前面的窗子就会挡住后面的窗子，即使前面的窗子是透明的，它也会把后面窗子被挡住的片段丢弃。</p>
<p><font size="5" color="orange">由远及近地绘制透明物体</font><br>对于包含不透明和透明物体的场景，绘制顺序应该是：</p>
<ol>
<li>首先绘制不透明物体</li>
<li>先绘制离摄像机远的透明物体，再绘制近的透明物体</li>
</ol>
<p>如果由远及近地绘制透明物体，那么在绘制近一些的透明物体时，就会混合远处的透明物体，最终会产生正确的结果。</p>
<p>几个窗子的位置如下：</p>
<pre class=" language-c++"><code class="language-c++">    //窗子的位置
    vector<vec3> window_location;
    window_location.push_back(vec3(-1.5f, 0.0f, -0.48f));
    window_location.push_back(vec3(1.5f, 0.0f, 0.51f));
    window_location.push_back(vec3(0.0f, 0.0f, 0.7f));
    window_location.push_back(vec3(-0.3f, 0.0f, -2.3f));
    window_location.push_back(vec3(0.5f, 0.0f, -0.6f));
</code></pre>
<p>我们以窗子到摄像机的距离作为键，以窗子的位置作为键对应的值，会 建键值对数据结构map，map会自动对键进行排序，也就是map会自动排序窗子到摄像机的距离。<br>【注】：</p>
<ul>
<li>map是STL库中的数据结构，是键值对的集合，可以用键作为下标来访问对应的值。</li>
</ul>
<p>在渲染循环中，我们创建一个map，并且把窗子到摄像机的距离作为键，把当前窗子作为键对应的值： </p>
<pre class=" language-c++"><code class="language-c++">        //把多个窗子位置存入map数据结构中，以窗子到摄像机的距离为键
        map<float, vec3> sortedWindow;
        for (int i = 0; i < window_location.size(); i++) {
            GLfloat distance = length(mycamera.cameraPos - window_location[i]);
            sortedWindow[distance] = window_location[i];
        }
</code></pre>
<p>在绘制时，我们逆序遍历这个map，就能由远及近地绘制出每个窗子：</p>
<pre class=" language-c++"><code class="language-c++">        //逆序访问键值对map，由远及近地绘制透明窗子
        for (map<float, vec3>::reverse_iterator it = sortedWindow.rbegin(); it != sortedWindow.rend(); ++it) {
            model = mat4();
            model = translate(model, it->second);
            glUniformMatrix4fv(glGetUniformLocation(grass_shader.shaderProgram, "model"), 1, GL_FALSE, value_ptr(model));
            glDrawArrays(GL_TRIANGLES, 0, 6);
        }
</code></pre>
<p><code>reverse_iterator</code>是逆序迭代器，<code>it-&gt;second</code>是键值对中的第二个元素，这里就是键对应的值，窗子的位置。</p>
<p>编译运行后的结果如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148465013058.png" alt=""></p>
<p>全部源码<a href="https://github.com/Popperelay/BlogCode/tree/master/LearnOpenGL17_Blend/LearnOpenGL17_Blend_2" target="_blank" rel="external">在这里</a>。</p>
<p>在这个场景里，我们是按照窗子到摄像机的距离来由远及近地排序的，但是这种方法不是通用的。我们这个场景里所有的窗子都是相互平行，没有交叉折叠的，如果物体比较奇怪复杂，就需要其他排序方式了。对场景中的物体进行排序是很有难度的，完美地渲染带透明和不透明物体的场景也不那么容易，如果感兴趣可以了解一些更高级的技术，比如次序无关透明度（order independent transparency）。<br>&nbsp; </p>
<hr>
<p>参考文献：<a href="https://learnopengl.com/" target="_blank" rel="external">LearnOpenGL</a></p>

            </div>

            <!-- Post Comments -->
            
    <!-- 使用 DISQUS_CLICK -->
<div id="disqus-comment">
    <div id="disqus_thread"></div>

<!-- add animation -->
<style>
	.disqus_click_btn {
            line-height: 30px;
            margin: 0;
            min-width: 50px;
            padding: 0 14px;
            display: inline-block;
            font-family: "Roboto", "Helvetica", "Arial", sans-serif;
            font-size: 14px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0;
            overflow: hidden;
            will-change: box-shadow;
            transition: box-shadow .2s cubic-bezier(.4, 0, 1, 1), background-color .2s cubic-bezier(.4, 0, .2, 1), color .2s cubic-bezier(.4, 0, .2, 1);
            outline: 0;
            cursor: pointer;
            text-decoration: none;
            text-align: center;
            vertical-align: middle;
            border: 0;
            background: rgba(158, 158, 158, .2);
            box-shadow: 0 2px 2px 0 rgba(0, 0, 0, .14), 0 3px 1px -2px rgba(0, 0, 0, .2), 0 1px 5px 0 rgba(0, 0, 0, .12);
            color: #fff;
            background-color: #7EC0EE;
            text-shadow: 0
        }
</style>
	
<div class="btn_click_load" id="disqus_bt"> 
    <button class="disqus_click_btn">点击查看评论</button>
</div>

<!--
<script type="text/javascript">
$('.btn_click_load').click(function() {
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'http-miccall-tech'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    document.getElementById('disqus_bt').style.display = "none";
});
</script>
-->
<script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://yoursite.com/2017/01/17/OpenGL17混合/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = 'http://yoursite.com/2017/01/17/OpenGL17混合/'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
</script>

<script type="text/javascript">
    $('.btn_click_load').click(function() {  //click to load comments
        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document;
            var s = d.createElement('script');
            s.src = '//http-miccall-tech.disqus.com/embed.js';
            s.setAttribute('data-timestamp', + new Date());
            (d.head || d.body).appendChild(s);
        })();
        $('.btn_click_load').css('display','none');
    });
</script>
</div>
<style>
    #disqus-comment{
        background-color: #eee;
        padding: 2pc;
    }
</style>


        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
                <li>Design: <a href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
            </ul>
            
            	<span id="busuanzi_container_site_pv">2017总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			
        </div>
    </div>
</body>



 	
</html>
