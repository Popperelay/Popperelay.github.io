<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>OpenGL17：混合 | Elays&#39;Blog</title>
  <meta name="author" content="Elay">
  
  <meta name="description" content="Elay">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="OpenGL17：混合"/>
  <meta property="og:site_name" content="Elays&#39;Blog"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Elays&#39;Blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">Elays&#39;Blog</a></h1>
  <h2><a href="/">你是天地生的，美得超越人形</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">主页</a></li>
    
      <li><a href="/archives">所有文章</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2017-01-17T12:37:24.000Z"><a href="/2017/01/17/OpenGL17混合/">2017-01-17</a></time>
      
      
  
    <h1 class="title">OpenGL17：混合</h1>
  

    </header>
    <div class="entry">
      
        <p>在OpenGL中，物体透明技术通常被叫做混合（Blending）。<a id="more"></a><br>&nbsp; </p>
<hr>
<p><font size="5" color="orange">透明</font><br>透明是指物体自身颜色与它背面物体颜色不同程度的混合，而在OpenGL中就是使用混合技术来实现的，将当前要绘制的物体的颜色和颜色缓冲区中已经绘制了的物体颜色进行混合，最终决定当前物体的颜色。下图是一副全透明和半透明的窗子：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148462342512.png" alt=""><br>物体的透明度是由片段颜色的alpha值（颜色向量的第4个元素）决定的，全透明的alpha值是0.0即透明度是100%，不透明的alpha值是1.0即透明度是0%。<br>&nbsp; </p>
<hr>
<p><font size="5" color="orange">丢弃片段来实现全透明</font><br>有些纹理是纹理部分要么全透明，要么不透明，不存在半透明的部分。如下面的草纹理，它没有半透明的部分：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148463674953.png" alt=""><br>对于这种纹理，我们可以直接丢弃全透明部分的片段，没有必要将它存储到颜色缓冲中，更没有必要使用混合技术。</p>
<p>首先，我们需要更改一下SOIL加载图片的方式，我们需要以RGBA的方式去加载带有alpha值的纹理（如果某些像素没有alpha值将会被设为1.0）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//加载纹理图像</span></div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* image = SOIL_load_image(texturePath, &amp;imageWidth, &amp;imageHeight, <span class="number">0</span>, SOIL_LOAD_RGBA);</div></pre></td></tr></table></figure></p>
<p>不要忘记还要改变OpenGL生成纹理的方式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//生成2D纹理</span></div><div class="line">glTexImage2D(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGBA, imageWidth, imageHeight, <span class="number">0</span>, GL_RGBA, GL_UNSIGNED_BYTE, image);</div></pre></td></tr></table></figure></p>
<p>绘制草的着色器很简单，仅仅是让片段颜色等于纹素颜色而已，代码如下：<br>顶点着色器（写在grass.vertex中）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#version 330 core</span></div><div class="line">layout (location=<span class="number">0</span>) in vec3 position;</div><div class="line">layout (location=<span class="number">1</span>) in vec2 texCoords;</div><div class="line"></div><div class="line">out vec2 TexCoords;</div><div class="line"></div><div class="line">uniform mat4 model;</div><div class="line">uniform mat4 view;</div><div class="line">uniform mat4 projection;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	gl_Position = projection * view * model * vec4(position,<span class="number">1.0f</span>);</div><div class="line">	TexCoords = vec2(texCoords.x ,<span class="number">1</span> - texCoords.y); </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>像素着色器（写在grass.fragment中）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#version 330 core</span></div><div class="line">in vec2 TexCoords;</div><div class="line">out vec4 color;</div><div class="line"></div><div class="line">uniform sampler2D texture1;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	color = texture(texture1,TexCoords);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>设置草平面的顶点属性如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//草平面的顶点属性（位置坐标、纹理坐标）</span></div><div class="line">GLfloat grass_vertices[] = &#123;</div><div class="line">	<span class="comment">//顶点位置坐标    //纹理坐标</span></div><div class="line">	<span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>,<span class="number">1.0f</span>,</div><div class="line">	<span class="number">0.5f</span>,<span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>,<span class="number">0.0f</span>,</div><div class="line">   <span class="number">-0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,<span class="number">1.0f</span>,</div><div class="line"></div><div class="line">    <span class="number">0.5f</span>,<span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>,<span class="number">0.0f</span>,</div><div class="line">   <span class="number">-0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,<span class="number">1.0f</span>,</div><div class="line">   <span class="number">-0.5f</span>,<span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,<span class="number">0.0f</span>,</div><div class="line"></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>接下来需要对它进行VAO绑定和数据解析：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//草平面顶点数据的绑定和解析</span></div><div class="line">GLuint grassVAO, grassVBO;</div><div class="line">glGenVertexArrays(<span class="number">1</span>, &amp;grassVAO);</div><div class="line">glBindVertexArray(grassVAO);</div><div class="line">glGenBuffers(<span class="number">1</span>, &amp;grassVBO);</div><div class="line">glBindBuffer(GL_ARRAY_BUFFER, grassVBO);</div><div class="line">glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(grass_vertices), grass_vertices, GL_STATIC_DRAW);</div><div class="line">glEnableVertexAttribArray(<span class="number">0</span>);</div><div class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">5</span> * <span class="keyword">sizeof</span>(GL_FLOAT), (GLvoid*)<span class="number">0</span>);</div><div class="line">glEnableVertexAttribArray(<span class="number">1</span>);</div><div class="line">glVertexAttribPointer(<span class="number">1</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">5</span> * <span class="keyword">sizeof</span>(GL_FLOAT), (GLvoid*)(<span class="number">3</span> * <span class="keyword">sizeof</span>(GL_FLOAT)));</div><div class="line">glBindVertexArray(<span class="number">0</span>);</div></pre></td></tr></table></figure></p>
<p>还需要加载草纹理：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">TextureLoader texLoader;</div><div class="line">GLuint grassTexture = texLoader.LoadTexture(<span class="string">"grass.png"</span>);</div></pre></td></tr></table></figure></p>
<p>由于要绘制多株草，我们给每株草设置不同的位置：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//草的位置</span></div><div class="line"><span class="built_in">vector</span>&lt;vec3&gt; grass_location;</div><div class="line">grass_location.push_back(vec3(<span class="number">-1.5f</span>, <span class="number">0.0f</span>, <span class="number">-0.48f</span>));</div><div class="line">grass_location.push_back(vec3(<span class="number">1.5f</span>, <span class="number">0.0f</span>, <span class="number">0.51f</span>));</div><div class="line">grass_location.push_back(vec3(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.7f</span>));</div><div class="line">grass_location.push_back(vec3(<span class="number">-0.3f</span>, <span class="number">0.0f</span>, <span class="number">-2.3f</span>));</div><div class="line">grass_location.push_back(vec3(<span class="number">0.5f</span>, <span class="number">0.0f</span>, <span class="number">-0.6f</span>));</div></pre></td></tr></table></figure></p>
<p>为了绘制草所定义的着色器对象如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function">shader <span class="title">grass_shader</span><span class="params">(<span class="string">"grass.vertex"</span>, <span class="string">"grass.fragment"</span>)</span></span>;</div></pre></td></tr></table></figure></p>
<p>最后就是在渲染循环里绘制几株草了：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//绘制几株草</span></div><div class="line">glBindVertexArray(grassVAO);</div><div class="line">glBindTexture(GL_TEXTURE_2D, grassTexture);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grass_location.size(); i++) &#123;</div><div class="line">	model = mat4();</div><div class="line">	model = translate(model, grass_location[i]);</div><div class="line">	glUniformMatrix4fv(glGetUniformLocation(grass_shader.shaderProgram, <span class="string">"model"</span>), <span class="number">1</span>, GL_FALSE, value_ptr(model));</div><div class="line">	glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">6</span>);</div><div class="line">&#125;</div><div class="line">glBindVertexArray(<span class="number">0</span>);</div></pre></td></tr></table></figure></p>
<p>编译运行后的结果如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/14846367522.png" alt=""><br>出现这种结果是因为OpenGL默认是不知道如何处理alpha值得，需要我们自己来设置。在像素着色器中，当片段的alpha值小于某一指定值时，就使用discard命令丢弃它。discard是GLSL为我们提供的用于丢弃片段的命令：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#version 330 core</span></div><div class="line">in vec2 TexCoords;</div><div class="line">out vec4 color;</div><div class="line"></div><div class="line">uniform sampler2D texture1;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	vec4 texColor = texture(texture1,TexCoords);</div><div class="line">	<span class="keyword">if</span>(texColor.a &lt; <span class="number">0.1</span>)</div><div class="line">		discard;</div><div class="line">	color=texColor;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>编译运行后的结果如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148463921017.png" alt=""><br>可以看到绘制出来的每张草纹理上方会有一个白边，这是因为我们的纹理设置得是REPEAT环绕方式，在采样纹理边缘的时候，OpenGL会在该边缘和环绕的下一张重复纹理的边缘之间插值，这里上方的白边就是草纹理的透明上边缘和下边缘（绿色）插值的结果。为了防止四周这种白边的出现，我们需要把纹理环绕方式设置为<code>GL_CLAMP_TO_EDGE</code>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//设置纹理s和t方向的环绕方式</span></div><div class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);</div><div class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);</div></pre></td></tr></table></figure></p>
<p>编译运行后的结果如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148463922702.png" alt=""><br>草确实没有了白边，但是地面很诡异了，地面纹理边缘也被拉伸了。地面纹理和草纹理应该是不同的环绕方式，所以，我们给TextureLoader类的<code>LoadTexture</code>函数加一个参数，表示s和t方向上的环绕方式，函数声明如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function">GLuint <span class="title">LoadTexture</span><span class="params">(<span class="keyword">const</span> GLchar* texturePath, GLint wrap_st = GL_REPEAT)</span></span>;</div></pre></td></tr></table></figure></p>
<p>在<code>LoadTexture</code>函数的实现中，就用这个<code>wrap_st</code>参数来设置纹理环绕方式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//设置纹理s和t方向的环绕方式</span></div><div class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, wrap_st);</div><div class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, wrap_st);</div></pre></td></tr></table></figure></p>
<p>现在加载草纹理和地面纹理应该是这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">TextureLoader texLoader;</div><div class="line">GLuint grassTexture = texLoader.LoadTexture(<span class="string">"grass.png"</span>, GL_CLAMP_TO_EDGE);</div><div class="line">GLuint planeTexture = texLoader.LoadTexture(<span class="string">"container.jpg"</span>);</div></pre></td></tr></table></figure></p>
<p>编译运行后的结果如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148463924882.png" alt=""><br>所有源码<a href="https://github.com/Popperelay/BlogCode/tree/master/LearnOpenGL17_Blend/LearnOpenGL17_Blend_1" target="_blank" rel="external">在这里</a>。<br>&nbsp; </p>
<hr>
<p><font size="5" color="orange">混合原理</font><br>上诉丢弃片段的方式，虽然可以实现全透明效果，但是不能渲染半透明图像。为了能够实现半透明，我们需要先开启混合：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//开启混合</span></div><div class="line">glEnable(GL_BLEND);</div></pre></td></tr></table></figure></p>
<p><font size="4" color="red">混合方程</font><br>OpenGL是按照以下混合方程进行混合的：<br>$$<br>\begin{equation}<br>Result=source*sFactor+destination*dFactor<br>\end{equation}<br>$$<br>source是源颜色向量，是将要绘制的纹理的颜色向量；destination是目标颜色向量，是存储在颜色缓冲中当前位置的颜色向量。sFactor和dFactor分别是对源颜色目标颜色的影响系数。</p>
<p>系数着色器运行完成并且所有的测试都通过以后，混合方程才开始执行。方程中的源和目标颜色会自动被OpenGL设置，而源和目标颜色的影响因子是由我们来设置的。比如现在有以下两个方块（或者说放大了的片段）：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148464152063.png" alt=""><br>我们希望在红色方块上绘制绿色方块。红色方块将是目标颜色（它会先进入颜色缓冲中），绿色方块将是源颜色。如果我们把源颜色影响因子设为源颜色的alpha值0.6， 把目标颜色影响因子设为剩下（1-0.6），那么混合方程将是：<br>$$<br>\begin{equation}<br>Result =<br>\begin{pmatrix}<br>0.0 \\<br>1.0 \\<br>0.0 \\<br>0.6<br>\end{pmatrix}<br>* 0.6 +<br>\begin{pmatrix}<br>1.0 \\<br>0.0 \\<br>0.0 \\<br>1.0 \\<br>\end{pmatrix}<br>* (1 - 0.6)<br>\end{equation}<br>$$<br>最终方块将包含60%的绿色和40的红色：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/14846421609.png" alt=""></p>
<p><font size="4" color="red">设置源和目标颜色的影响因子</font><br>我们使用<code>glBlendFunc</code>函数来设置这两个影响因子，函数原型如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">glBlendFunc</span><span class="params">(GLenum sfactor, GLenum dfactor)</span></span></div></pre></td></tr></table></figure></p>
<p>这两个参数可以设置为下列选项：<br><img src="" alt=""><br>为了获得混合效果，把源颜色的alpha给源因子，1-alpha给目标因子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);</div></pre></td></tr></table></figure></p>
<p><code>glBlendFunc</code>函数是为R、G、B、A这四个分量都设置了相同的影响因子。其实我们还可以不用混合方程，直接使用<code>glBlendFuncSeperate</code>函数为最终颜色的每个分量设置一个值，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">glBlendFuncSeperate(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA,GL_ONE, GL_ZERO);</div></pre></td></tr></table></figure></p>
<p><font size="4" color="red">混合方程不止于加</font><br>我们之前给的混合方程是源颜色和目标颜色按比例相加，其实还可以是减、逆序减。这需要用到<code>glBlendEquation</code>函数。函数原型如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">glBlendEquation</span><span class="params">(GLenum mode)</span></span></div></pre></td></tr></table></figure></p>
<p>它的参数有以下选项：</p>
<ul>
<li>GL_FUNC_ADD：相加，这是默认的，$Result = Src + Dst$。</li>
<li>GL_FUNC_SUBTRACT：相减，$Result = Src - Dst$。</li>
<li>GL_FUNC_REVERSE_SUBTRACT：反过来相减，$Result = Dst - Src$。<br>通常可以省略<code>glBlendEquation</code>函数，因为大多数时候我们需要的混合效果都是相加的，这恰好是默认的。<br>&nbsp; </li>
</ul>
<hr>
<p><font size="5" color="orange">渲染半透明纹理</font><br>现在我们开始用OpenGL来渲染下面这个半透明的窗子：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/14846446012.png" alt=""></p>
<p>首先我们需要开启混合，并设置合适的混合方程：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//开启混合</span></div><div class="line">glEnable(GL_BLEND);</div><div class="line"><span class="comment">//混合方程</span></div><div class="line">glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);</div></pre></td></tr></table></figure></p>
<p>这里是让源颜色影响因子等于源颜色的alpha值，目标颜色的影响因子等于1-源颜色的alpha。</p>
<p> 现在我们是用混合来绘制半透明窗子的，不需要丢弃片段了，将像素着色器改回来：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#version 330 core</span></div><div class="line">in vec2 TexCoords;</div><div class="line">out vec4 color;</div><div class="line"></div><div class="line">uniform sampler2D texture1;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	<span class="comment">/*vec4 texColor = texture(texture1,TexCoords);</span></div><div class="line">	if(texColor.a &lt; 0.1)</div><div class="line">		discard;</div><div class="line">	color=texColor;*/</div><div class="line">	color = texture(texture1,TexCoords);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>编译运行后的结果如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148464557355.png" alt=""><br>&nbsp; </p>
<hr>
<p>但是有个很明显的问题，前面的窗子并不能透明显示后面的窗子。这是因为深度测试并不关心alpha值，所以前面的窗子就会挡住后面的窗子，即使前面的窗子是透明的，它也会把后面窗子被挡住的片段丢弃。</p>
<p><font size="5" color="orange">由远及近地绘制透明物体</font><br>对于包含不透明和透明物体的场景，绘制顺序应该是：</p>
<ol>
<li>首先绘制不透明物体</li>
<li>先绘制离摄像机远的透明物体，再绘制近的透明物体</li>
</ol>
<p>如果由远及近地绘制透明物体，那么在绘制近一些的透明物体时，就会混合远处的透明物体，最终会产生正确的结果。</p>
<p>几个窗子的位置如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//窗子的位置</span></div><div class="line"><span class="built_in">vector</span>&lt;vec3&gt; window_location;</div><div class="line">window_location.push_back(vec3(<span class="number">-1.5f</span>, <span class="number">0.0f</span>, <span class="number">-0.48f</span>));</div><div class="line">window_location.push_back(vec3(<span class="number">1.5f</span>, <span class="number">0.0f</span>, <span class="number">0.51f</span>));</div><div class="line">window_location.push_back(vec3(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.7f</span>));</div><div class="line">window_location.push_back(vec3(<span class="number">-0.3f</span>, <span class="number">0.0f</span>, <span class="number">-2.3f</span>));</div><div class="line">window_location.push_back(vec3(<span class="number">0.5f</span>, <span class="number">0.0f</span>, <span class="number">-0.6f</span>));</div></pre></td></tr></table></figure></p>
<p>我们以窗子到摄像机的距离作为键，以窗子的位置作为键对应的值，会 建键值对数据结构map，map会自动对键进行排序，也就是map会自动排序窗子到摄像机的距离。<br>【注】：</p>
<ul>
<li>map是STL库中的数据结构，是键值对的集合，可以用键作为下标来访问对应的值。</li>
</ul>
<p>在渲染循环中，我们创建一个map，并且把窗子到摄像机的距离作为键，把当前窗子作为键对应的值：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">		<span class="comment">//把多个窗子位置存入map数据结构中，以窗子到摄像机的距离为键</span></div><div class="line">		<span class="built_in">map</span>&lt;<span class="keyword">float</span>, vec3&gt; sortedWindow;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; window_location.size(); i++) &#123;</div><div class="line">			GLfloat distance = length(mycamera.cameraPos - window_location[i]);</div><div class="line">			sortedWindow[distance] = window_location[i];</div><div class="line">		&#125;</div><div class="line">```  </div><div class="line">在绘制时，我们逆序遍历这个<span class="built_in">map</span>，就能由远及近地绘制出每个窗子：</div><div class="line">```c++</div><div class="line">		<span class="comment">//逆序访问键值对map，由远及近地绘制透明窗子</span></div><div class="line">		<span class="keyword">for</span> (<span class="built_in">map</span>&lt;<span class="keyword">float</span>, vec3&gt;::reverse_iterator it = sortedWindow.rbegin(); it != sortedWindow.rend(); ++it) &#123;</div><div class="line">			model = mat4();</div><div class="line">			model = translate(model, it-&gt;second);</div><div class="line">			glUniformMatrix4fv(glGetUniformLocation(grass_shader.shaderProgram, <span class="string">"model"</span>), <span class="number">1</span>, GL_FALSE, value_ptr(model));</div><div class="line">			glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">6</span>);</div><div class="line">		&#125;</div></pre></td></tr></table></figure></p>
<p><code>reverse_iterator</code>是逆序迭代器，<code>it-&gt;second</code>是键值对中的第二个元素，这里就是键对应的值，窗子的位置。</p>
<p>编译运行后的结果如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148465013058.png" alt=""></p>
<p>全部源码<a href="https://github.com/Popperelay/BlogCode/tree/master/LearnOpenGL17_Blend/LearnOpenGL17_Blend_2" target="_blank" rel="external">在这里</a>。</p>
<p>在这个场景里，我们是按照窗子到摄像机的距离来由远及近地排序的，但是这种方法不是通用的。我们这个场景里所有的窗子都是相互平行，没有交叉折叠的，如果物体比较奇怪复杂，就需要其他排序方式了。对场景中的物体进行排序是很有难度的，完美地渲染带透明和不透明物体的场景也不那么容易，如果感兴趣可以了解一些更高级的技术，比如次序无关透明度（order independent transparency）。<br>&nbsp; </p>
<hr>
<p>参考文献：<a href="https://learnopengl.com/" target="_blank" rel="external">LearnOpenGL</a></p>

      
    </div>
    <footer>
      
        
  
  <div class="categories">
    <a href="/categories/OpenGL/">OpenGL</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/混合/">混合</a>
  </div>

        
  <div class="addthis addthis_toolbox addthis_default_style">
    
      <a class="addthis_button_facebook_like" fb:like:layout="button_count"></a>
    
    
      <a class="addthis_button_tweet"></a>
    
    
      <a class="addthis_button_google_plusone" g:plusone:size="medium"></a>
    
    
      <a class="addthis_button_pinterest_pinit" pi:pinit:layout="horizontal"></a>
    
    <a class="addthis_counter addthis_pill_style"></a>
  </div>
  <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js"></script>

      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


<section id="comment">
  <h2 class="title">留言</h2>


 
  	   <!-- 多说评论框 start -->
 		<div class="ds-thread" data-thread-key="2017/01/17/OpenGL17混合/" data-title="OpenGL17：混合" data-url="http://yoursite.com/2017/01/17/OpenGL17混合/"></div>
		<!-- 多说评论框 end -->
		<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
		<script type="text/javascript">
		var duoshuoQuery = {short_name:"popperelay"};   <!-- 替换这里的duoshuo_shortname为前面注册的shortname -->
			(function() {
				var ds = document.createElement('script');
				ds.type = 'text/javascript';ds.async = true;
				ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.unstable.js';
				ds.charset = 'UTF-8';
				(document.getElementsByTagName('head')[0] 
				 || document.getElementsByTagName('body')[0]).appendChild(ds);
			})();
			</script>
		<!-- 多说公共JS代码 end -->
 
  
</section>

</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:yoursite.com">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/C-语法/">C#语法</a><small>2</small></li>
  
    <li><a href="/categories/C/">C++</a><small>5</small></li>
  
    <li><a href="/categories/C语言/">C语言</a><small>1</small></li>
  
    <li><a href="/categories/OpenGL/">OpenGL</a><small>28</small></li>
  
    <li><a href="/categories/c/">c++</a><small>1</small></li>
  
    <li><a href="/categories/博客配置/">博客配置</a><small>3</small></li>
  
    <li><a href="/categories/操作系统/">操作系统</a><small>4</small></li>
  
    <li><a href="/categories/数据结构/">数据结构</a><small>15</small></li>
  
    <li><a href="/categories/毕设/">毕设</a><small>1</small></li>
  
    <li><a href="/categories/游戏开发/">游戏开发</a><small>1</small></li>
  
    <li><a href="/categories/游戏设计模式/">游戏设计模式</a><small>1</small></li>
  
    <li><a href="/categories/计算机图形学/">计算机图形学</a><small>2</small></li>
  
    <li><a href="/categories/设计模式/">设计模式</a><small>5</small></li>
  
    <li><a href="/categories/调试错误集锦/">调试错误集锦</a><small>1</small></li>
  
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/BIOS和微机启动过程/">BIOS和微机启动过程</a><small>1</small></li>
  
    <li><a href="/tags/Blinn-Phong/">Blinn-Phong</a><small>1</small></li>
  
    <li><a href="/tags/C/">C</a><small>1</small></li>
  
    <li><a href="/tags/C-容器/">C#容器</a><small>1</small></li>
  
    <li><a href="/tags/C-IO/">C++IO</a><small>1</small></li>
  
    <li><a href="/tags/C-Primer/">C++Primer</a><small>1</small></li>
  
    <li><a href="/tags/Gamma校正/">Gamma校正</a><small>1</small></li>
  
    <li><a href="/tags/MarkDown/">MarkDown</a><small>1</small></li>
  
    <li><a href="/tags/Mathjax语法/">Mathjax语法</a><small>1</small></li>
  
    <li><a href="/tags/OS内核/">OS内核</a><small>1</small></li>
  
    <li><a href="/tags/OpenGL坐标系统/">OpenGL坐标系统</a><small>1</small></li>
  
    <li><a href="/tags/OpenGL摄像机/">OpenGL摄像机</a><small>1</small></li>
  
    <li><a href="/tags/OpenGL窗口/">OpenGL窗口</a><small>1</small></li>
  
    <li><a href="/tags/OpenGL配置/">OpenGL配置</a><small>1</small></li>
  
    <li><a href="/tags/ShadowMap/">ShadowMap</a><small>1</small></li>
  
    <li><a href="/tags/c-特性/">c++特性</a><small>1</small></li>
  
    <li><a href="/tags/const/">const</a><small>1</small></li>
  
    <li><a href="/tags/timeTest/">timeTest</a><small>1</small></li>
  
    <li><a href="/tags/二叉树/">二叉树</a><small>1</small></li>
  
    <li><a href="/tags/交流/">交流</a><small>1</small></li>
  
    <li><a href="/tags/光照场景/">光照场景</a><small>1</small></li>
  
    <li><a href="/tags/光照贴图/">光照贴图</a><small>1</small></li>
  
    <li><a href="/tags/关键路径/">关键路径</a><small>1</small></li>
  
    <li><a href="/tags/冯氏光照/">冯氏光照</a><small>1</small></li>
  
    <li><a href="/tags/几何着色器/">几何着色器</a><small>1</small></li>
  
    <li><a href="/tags/反走样/">反走样</a><small>1</small></li>
  
    <li><a href="/tags/图/">图</a><small>1</small></li>
  
    <li><a href="/tags/图形学概述/">图形学概述</a><small>1</small></li>
  
    <li><a href="/tags/图形显示系统/">图形显示系统</a><small>1</small></li>
  
    <li><a href="/tags/外观-观察-者命令/">外观 观察 者命令</a><small>1</small></li>
  
    <li><a href="/tags/多说/">多说</a><small>1</small></li>
  
    <li><a href="/tags/天空盒子/">天空盒子</a><small>1</small></li>
  
    <li><a href="/tags/头结点/">头结点</a><small>1</small></li>
  
    <li><a href="/tags/实例化/">实例化</a><small>1</small></li>
  
    <li><a href="/tags/尾递归/">尾递归</a><small>1</small></li>
  
    <li><a href="/tags/工厂模式单例模式/">工厂模式单例模式</a><small>1</small></li>
  
    <li><a href="/tags/帧同步/">帧同步</a><small>1</small></li>
  
    <li><a href="/tags/帧缓冲/">帧缓冲</a><small>1</small></li>
  
    <li><a href="/tags/常见光源/">常见光源</a><small>1</small></li>
  
    <li><a href="/tags/异步传输/">异步传输</a><small>2</small></li>
  
    <li><a href="/tags/拓扑排序/">拓扑排序</a><small>1</small></li>
  
    <li><a href="/tags/操作系统概述/">操作系统概述</a><small>1</small></li>
  
    <li><a href="/tags/改进排序/">改进排序</a><small>1</small></li>
  
    <li><a href="/tags/文件IO/">文件IO</a><small>1</small></li>
  
    <li><a href="/tags/最小生成树/">最小生成树</a><small>1</small></li>
  
    <li><a href="/tags/最短路径/">最短路径</a><small>1</small></li>
  
    <li><a href="/tags/材质/">材质</a><small>1</small></li>
  
    <li><a href="/tags/查找/">查找</a><small>1</small></li>
  
    <li><a href="/tags/栈/">栈</a><small>1</small></li>
  
    <li><a href="/tags/树/">树</a><small>1</small></li>
  
    <li><a href="/tags/模型加载/">模型加载</a><small>1</small></li>
  
    <li><a href="/tags/模板测试/">模板测试</a><small>1</small></li>
  
    <li><a href="/tags/深度测试/">深度测试</a><small>1</small></li>
  
    <li><a href="/tags/混合/">混合</a><small>1</small></li>
  
    <li><a href="/tags/着色器/">着色器</a><small>1</small></li>
  
    <li><a href="/tags/着色器画三角形/">着色器画三角形</a><small>1</small></li>
  
    <li><a href="/tags/码农/">码农</a><small>1</small></li>
  
    <li><a href="/tags/简单排序/">简单排序</a><small>1</small></li>
  
    <li><a href="/tags/纹理/">纹理</a><small>1</small></li>
  
    <li><a href="/tags/缓冲对象/">缓冲对象</a><small>1</small></li>
  
    <li><a href="/tags/编译链接错误/">编译链接错误</a><small>1</small></li>
  
    <li><a href="/tags/背面剔除/">背面剔除</a><small>1</small></li>
  
    <li><a href="/tags/责任链模式适配器模式/">责任链模式适配器模式</a><small>1</small></li>
  
    <li><a href="/tags/进程的描述与控制/">进程的描述与控制</a><small>1</small></li>
  
    <li><a href="/tags/重定义错误/">重定义错误</a><small>1</small></li>
  
    <li><a href="/tags/链表/">链表</a><small>1</small></li>
  
    <li><a href="/tags/队列/">队列</a><small>1</small></li>
  
    <li><a href="/tags/面向对象设计原则/">面向对象设计原则</a><small>1</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2017 Elay
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




  <link rel="stylesheet" href="http://apps.bdimg.com/libs/fancybox/2.1.5/jquery.fancybox.css">



<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="http://mathjax.josephjctang.com/MathJax.js?config=TeX-MML-AM_HTMLorMML">
</script>


</body>
</html>