<!DOCTYPE HTML>
<html>

<head>
	<link rel="bookmark"  type="image/x-icon"  href="/img/logo_miccall.png"/>
	 <link rel="shortcut icon" href="/img/logo_miccall.png">
	
			
    <title>
    Elays'Blog
    </title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="/css/mic_main.css" />
    <link rel="stylesheet" href="/css/dropdownMenu.css" />
    
    	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css" />
    </noscript>

			    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<link rel="stylesheet" href="/css/prism-dark.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>
    
		
<!-- Layouts -->


<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_undefined.css" />
<link rel="stylesheet" href="/css/typo.css" />
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">MICCALL</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special" >
            <ul class="menu links" >
			<!-- Homepage  主页  --> 
			<li >
	            <a href="/" rel="nofollow">主页</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">分类</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="/categories/C-语法/">C#语法</a></li><li><a class="category-link" href="/categories/C/">C++</a></li><li><a class="category-link" href="/categories/C语言/">C语言</a></li><li><a class="category-link" href="/categories/OpenGL/">OpenGL</a></li><li><a class="category-link" href="/categories/c/">c++</a></li><li><a class="category-link" href="/categories/全局光照/">全局光照</a></li><li><a class="category-link" href="/categories/博客配置/">博客配置</a></li><li><a class="category-link" href="/categories/操作系统/">操作系统</a></li><li><a class="category-link" href="/categories/数据结构/">数据结构</a></li><li><a class="category-link" href="/categories/毕设/">毕设</a></li><li><a class="category-link" href="/categories/游戏开发/">游戏开发</a></li><li><a class="category-link" href="/categories/游戏设计模式/">游戏设计模式</a></li><li><a class="category-link" href="/categories/计算机图形学/">计算机图形学</a></li><li><a class="category-link" href="/categories/设计模式/">设计模式</a></li><li><a class="category-link" href="/categories/调试错误集锦/">调试错误集锦</a>
	                    </ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/about/" title="简历">
		                简历
		            </a>
		        </li>
		        
		        <li>
		            <a href="/group/" title="团队">
		                团队
		            </a>
		        </li>
		        
		        <li>
		            <a href="/gallery/" title="图库">
		                图库
		            </a>
		        </li>
		        
		        <li>
		            <a href="/tag/" title="标签">
		                标签
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
		            
		                <li><a href="https://github.com/miccall" class="icon fa-github"><span class="label">GitHub</span></a></li>
		            
		            
		            
		            
			</ul>
</nav>

        <div id="main" >
            <div class ="post_page_title_img" style="height: 25rem;background-image: url(undefined);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;" >
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2 >OpenGL14：模型加载</h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
                <p>之前我们的场景里用的全都是小方块，现在我们想要去加载一些其他模型。<a id="more"></a>我们是无法像定义小方块一样，用程序去手动地指定房子、人这些复杂模型的顶点、法线和纹理坐标。这些复杂模型通常是由美工用Blender、3DS Max和Maya这些建模软件来制作的，我们要做的只是把这些已经做好的模型打入到我们的应用程序中。在建模软件导出模型文件时，会自动生成模型的所有顶点坐标、顶点法线和纹理坐标，而我们需要去解析这些导出的模型文件，并将其中的模型数据存储为OpenGL能够使用的数据。</p>
<p>由于导出的模型文件通常有几十种格式，为每种格式都写一种解析方式是很麻烦的。这里我们直接使用市面上一个很流行的模型加载库，叫做Assimp。<br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">模型加载库Assimp</font><br>Assimp是一个常用的模型加载库，全称是Open Asset Import Library。它可以导入几十种不同格式的模型文件（也可以导出部分模型格式），并且可以把不同的模型文件都转换为一个统一的数据结构，所以无论我们导入哪种格式的模型文件，都可以用同一个方式去访问我们需要的模型数据。<br>它能读取以下格式的模型文件：</p>
<ul>
<li>Autodesk ( .fbx )</li>
<li>Collada ( .dae )</li>
<li>glTF ( .gltf, .glb )</li>
<li>Blender 3D ( .blend )</li>
<li>3ds Max 3DS ( .3ds )</li>
<li>3ds Max ASE ( .ase )</li>
<li>Wavefront Object ( .obj )</li>
<li>Industry Foundation Classes (IFC/Step) ( .ifc )</li>
<li>XGL ( .xgl,.zgl )</li>
<li>Stanford Polygon Library ( .ply )</li>
<li>AutoCAD DXF ( .dxf )</li>
<li>LightWave ( .lwo )</li>
<li>LightWave Scene ( .lws )</li>
<li>Modo ( .lxo )</li>
<li>Stereolithography ( .stl )</li>
<li>DirectX X ( .x )</li>
<li>AC3D ( .ac )</li>
<li>Milkshape 3D ( .ms3d )</li>
<li>TrueSpace ( .cob,.scn )</li>
<li>Biovision BVH ( .bvh )</li>
<li>CharacterStudio Motion ( .csm )</li>
<li>Ogre XML ( .xml )</li>
<li>Irrlicht Mesh ( .irrmesh )</li>
<li>Irrlicht Scene ( .irr )</li>
<li>Quake I ( .mdl )</li>
<li>Quake II ( .md2 )</li>
<li>Quake III Mesh ( .md3 )</li>
<li>Quake III Map/BSP ( .pk3 )</li>
<li>Return to Castle Wolfenstein ( .mdc )</li>
<li>Doom 3 ( .md5* )</li>
<li>Valve Model ( .smd,.vta )</li>
<li>Open Game Engine Exchange ( .ogex )</li>
<li>Unreal ( .3d )</li>
<li>BlitzBasic 3D ( .b3d )</li>
<li>Quick3D ( .q3d,.q3s )</li>
<li>Neutral File Format ( .nff )</li>
<li>Sense8 WorldToolKit ( .nff )</li>
<li>Object File Format ( .off )</li>
<li>PovRAY Raw ( .raw )</li>
<li>Terragen Terrain ( .ter )</li>
<li>3D GameStudio (3DGS) ( .mdl )</li>
<li>3D GameStudio (3DGS) Terrain ( .hmp )</li>
<li>Izware Nendo ( .ndo )</li>
</ul>
<p>还能导出几种常见格式的模型：</p>
<ul>
<li>Collada ( .dae )</li>
<li>Wavefront Object ( .obj )</li>
<li>Stereolithography ( .stl )</li>
<li>Stanford Polygon Library ( .ply )</li>
</ul>
<p><font size="4" color="red">Assimp生成的模型数据结构</font><br>当Assimp导入一个模型文件时，它会加载整个模型文件到一个scene对象，它包含了所有被导入的模型和场景数据（一个模型文件可能包含多个模型或场景）。Assimp会为这个模型文件中的所有场景节点、模型节点都生成一个对应的数据结构，每个节点包含着存储在scene对象中的数据的索引，有的可能还包含几个子节点。下图展示了一个简化的Assimp生成的模型数据结构：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148248044044.png" alt=""></p>
<ul>
<li>所有的模型、场景数据都包含在scene对象中，如所有的材质和Mesh。而且，场景的根节点应用也在这个scene对象中。</li>
<li>场景的根节点包含很多子节点和很多指向scene对象中的Mesh网格数据的引用。因为根节点的mMeshes数组才包含着实际的网格对象，其他节点的mMeshes数组的值都只是根节的mMeshes的索引。</li>
<li>一个mesh由顶点、边、面片组成，它包含了渲染所需的所有相关数据，比如顶点位置、法线向量、纹理坐标、面片、材质等，一个mesh是一个可绘制的独立实体，如一条手臂、一条腿。</li>
<li>一个mesh会包含多个面片Face。一个面片表示渲染中的一个最基本的图元（如点、线、三角面片、矩形面片）。一个面片记录了一个图元的顶点索引，通过这个索引，可以在mMeshes中寻找到对应的顶点位置数据。因为顶点和索引是分开的，所以我们很容易使用索引缓冲来进行高速渲染。</li>
<li>一个mesh还会包含一个材质对象，用于指定物体的一些材质属性，如颜色、纹理贴图（漫反射贴图、镜面反射贴图等）。</li>
</ul>
<p>我们后面会用上诉的数据结构来创建我们自己的Model类和Mesh类，用于加载和保存那些导入的模型。我们不需要去渲染整个模型的所有数据，而只是去渲染这个模型所包含的所有独立的Mesh。</p>
<p><font size="4" color="red">构建Assimp</font><br>要使用Assimp模型加载库，我们需要先构建它。下载地址在<a href="https://sourceforge.net/projects/assimp/files/assimp-3.1/" target="_blank" rel="external">这里</a>。最好我们自己用CMake去编译Assimp库，因为Assimp官方的已编译库不能很好地在所有平台上正常运行。具体编译、构建和链接过程可以回顾<a href="http://popperelay.com/2016/10/18/OpenGL%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" target="_blank" rel="external">《OpenGL1：OpenGL概述及环境配置》</a>。</p>
<p>下面给出一些编译Assimp时可能遇到的问题：</p>
<ul>
<li>在使用CMake进行Configure时，可能遇到如下错误：<pre class="line-numbers language-c++"><code class="language-c++">Could not locate DirecXCMake Error at cmake-modules/FindPkgMacros.cmake:110 (message):Required library DirectX not found! Install the library (including dev packages) and try again. If the library is already installed, set the missing variables manually in cmake.
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
这是因为你之前没有安装过DirectX SDK，那么<a href="https://www.microsoft.com/en-us/download/details.aspx?id=6812" target="_blank" rel="external">下载</a>安装吧！</li>
<li>在安装DirectX SDK时，可能会遇到一个错误码为S1023的错误。解决步骤如下：<ol>
<li>在命令行窗口运行下面两行命令：<pre class="line-numbers language-c++"><code class="language-c++">MsiExec.exe /passive /X{F0C3E5D1-1ADE-321E-8167-68EF0DE699A5}
MsiExec.exe /passive /X{1D8E6291-B0D5-35EC-8441-6616F567A0F7}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
删除掉Visual C++ 2010 Redistributable Package。<br>如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148250222242.png" alt=""></li>
<li>安装DirectX SDK</li>
<li>重新安装Visual C++ 2010 Redistributable Package。可以在<a href="https://www.microsoft.com/zh-CN/download/details.aspx?id=26999" target="_blank" rel="external">这里</a>下载到。注意x64系统需要安装vcredist_x86.exe和vcredist_x64.exe两个版本。</li>
</ol>
</li>
</ul>
<p>【注】：</p>
<ul>
<li>使用默认配置构建的Assimp是一个动态库，所以我们需要把编译出来的assimpd.dll文件拷贝到我们自己的源文件所在的目录里。</li>
<li>如果想要让Assimp使用多线程来提高性能，可以使用Boost库来编译Assimp。在<a href="http://assimp.sourceforge.net/lib_html/install.html" target="_blank" rel="external">Boost安装页面</a>，可以找到关于Boost的完整安装介绍。<br>&nbsp;</li>
</ul>
<hr>
<p><font size="5" color="orange">网格类Mesh</font><br>使用Assimp可以把多种不同格式的模型加载到程序中，但是一旦载入，它们就都被存储为Assimp自己的数据结构。我们需要将其转变为OpenGL可读的数据，才能用OpenGL来渲染物体。</p>
<p><font size="4" color="red">绘制网格所需数据</font><br>一个网格代表一个可绘制的实体，我们把Assimp加载的模型转变成很多个网格，分别绘出这些网格，就能绘制出整个模型。现在我们来自定义一个自己的网格类，便于转换Assimp的数据结构为OpenGL可读的数据结构。一个网格应该至少需要一组顶点，每个顶点包含一个位置向量、一个法线向量、一个纹理坐标，还需要包含顶点索引以及用纹理（漫反射贴图、镜面贴图）形式表现的材质数据。</p>
<p>那我们先来定义一个顶点：</p>
<pre class="line-numbers language-c++"><code class="language-c++">struct Vertex {
    vec3 position;
    vec3 normal;
    vec2 texCoords;
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>顶点中包含了顶点位置、法线和纹理坐标。</p>
<p>接着我们来定义绘制网格所需要的纹理：</p>
<pre class="line-numbers language-c++"><code class="language-c++">struct Texture {
    GLuint id;
    string samplerName;
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>纹理中包含了纹理加载后的ID，和在像素着色器（在文末有像素着色器代码，和上一篇文章几乎一样）中纹理所对应的采样器名称。</p>
<p><font size="4" color="red"> 建立网格类</font><br>然后，我们可以开始建立Mesh类了：</p>
<pre class="line-numbers language-c++"><code class="language-c++">class Mesh {
public:
    vector<Vertex> vertices;
    vector<GLuint> indices;
    vector<Texture> textures;
    float shininess;
    ...
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>它包含了绘制网格所需的一堆顶点、顶点索引和纹理，它们都是vector类型（使用vector需要包含vector文件<code>#include &lt;vector&gt;</code>），还包含了计算镜面光时所需要的镜面反射系数。这些顶点位置、纹理等等都是从Assimp加载后的数据里面得到的（在后面自定义的模型加载类ModelLoader里通过参数传递到Mesh类里）。</p>
<p>我们可以在Mesh类的构造函数里，用传递过来的参数初始化这些顶点、纹理：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    Mesh(vector<Vertex> vertices, vector<GLuint> indices, vector<Texture> textures, float shininess) {
        this->vertices = vertices;
        this->indices = indices;
        this->textures = textures;
        this->shininess = shininess;
        ...
    }
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>和之前的绘制流程一样，在绘制之前先对这些数据绑定VAO、VBO、EBO以及解析顶点数据，我们把它写在<code>PrepareBeforeDraw</code>函数里：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    GLuint VAO, VBO, EBO;
    //在绘制之前的绑定、发送数据、解析等准备工作
    void PrepareBeforeDraw() {
        glGenVertexArrays(1, &VAO);
        glGenBuffers(1, &VBO);
        glGenBuffers(1, &EBO);
        glBindVertexArray(VAO);
        glBindBuffer(GL_ARRAY_BUFFER, VBO);
        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);
        glBufferData(GL_ARRAY_BUFFER, vertices.size() * sizeof(Vertex), &vertices[0], GL_STATIC_DRAW);
        glBufferData(GL_ELEMENT_ARRAY_BUFFER, indices.size() * sizeof(GLuint), &indices[0], GL_STATIC_DRAW);
        glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (GLvoid*)0);
        glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (GLvoid*)offsetof(Vertex, normal));
        glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, sizeof(Vertex), (GLvoid*)offsetof(Vertex, texCoords));
        glEnableVertexAttribArray(0);
        glEnableVertexAttribArray(1);
        glEnableVertexAttribArray(2);
        glBindVertexArray(0);
    }
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后在构造函数里调用该函数：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    Mesh(vector<Vertex> vertices, vector<GLuint> indices, vector<Texture> textures, float shininess) {
        this->vertices = vertices;
        this->indices = indices;
        this->textures = textures;
        this->shininess = shininess;
        PrepareBeforeDraw();
    }
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>绘制网格所需的数据以及绑定解析好了，接下来就可以绘制网格了：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    void Draw(shader myshader) {
        for (GLuint i = 0; i < textures.size(); i++) {
            glActiveTexture(GL_TEXTURE0 + i);
            glBindTexture(GL_TEXTURE_2D, textures[i].id);
            glUniform1i(glGetUniformLocation(myshader.shaderProgram, ("material." + textures[i].samplerName).c_str()), i);
        }
        glUniform1f(glGetUniformLocation(myshader.shaderProgram, "material.shininess"), shininess);
        glBindVertexArray(VAO);
        glDrawElements(GL_TRIANGLES, indices.size(), GL_UNSIGNED_INT, 0);
        glBindVertexArray(0);
    }
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>先对每一张纹理激活纹理单元和设置对应的uniform采样器，再设置uniform镜面反射系数的值，最后再次绑定VAO调用<code>glDrawElements</code>函数就可以绘制出整个网格了。<br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">模型加载类ModelLoader</font><br>我们需要使用Assimp把模型文件加载到我们的程序里，再读出一些Assimp数据（比如顶点、索引、纹理等 ）传到Mesh里用以绘制（这里我们使用<a href="http://learnopengl.com/data/models/nanosuit.rar" target="_blank" rel="external">纳米铠甲</a>的模型）。</p>
<p><font size="4" color="red">加载模型文件</font><br>要使用Assimp，除了编译链接好以外，还需要在我们的程序中包含以下头文件：</p>
<pre class="line-numbers language-c++"><code class="language-c++">//Assimp
#include <Assimp/Importer.hpp>
#include <Assimp/scene.h>
#include <Assimp/postprocess.h>
using namespace Assimp;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后我们在自定义的LoadModel函数里使用Assimp的Importer对象的<code>ReadFile</code>函数，来把模型文件读取到场景对象中：</p>
<pre class="line-numbers language-c++"><code class="language-c++">const aiScene* scene;

void LoadModel(string path) {
        //用Assimp加载模型文件到场景对象中
        Importer importer;
        scene = importer.ReadFile(path, aiProcess_Triangulate | aiProcess_FlipUVs);
        if (!scene || !scene->mRootNode || scene->mFlags == AI_SCENE_FLAGS_INCOMPLETE) {
            cout << "Error:Assimp:" << importer.GetErrorString() << endl;
            return;
        }
        ...
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>首先定义Importer对象，Importer对象的<code>ReadFile</code>函数里第一个参数指明模型文件的路径，第二个参数是后处理选项。除了可以简单加载文件外，Assimp运行我们定义几个选项来强制Assimp去对导入的数据做一些额外的计算或操作：</p>
<ul>
<li><code>aiProcess_Triangulate</code>：告诉Assimp如果模型不是（全部）由三角形组成，应该转换所有的模型的原始几何形状为三角形。</li>
<li><code>aiProcess_FlipUVs</code>：基于y轴翻转纹理坐标（在<a href="http://popperelay.com/2016/11/29/OpenGL5%E7%BA%B9%E7%90%86/" target="_blank" rel="external">OpenGL5：纹理</a>一文中说过OpenGL会将大多数图像沿着y轴翻转，不翻转回来的话会导致画出来的图像是上下颠倒的，这里做了这个处理后顶点着色器就不用再<code>1-纹理y坐标</code>了）。</li>
<li><code>aiProcess_GenNormals</code>：如果模型没有包含法线向量，就为每个顶点创建法线。</li>
<li><code>aiProcess_SplitLargeMeshes</code>：把大的网格分成几个小的夏季网格，当渲染一个有最大数量顶点的限制或者只能处理小块网格时会很有用。</li>
<li><code>aiProcess_OptimizeMeshes</code>：和上一个选项相反，它把几个网格结合为一个更大的网格，以减少绘制函数调用次数的方式来实现优化。</li>
</ul>
<p>更多更详细的后处理内容可以在<a href="http://assimp.sourceforge.net/lib_html/postprocess_8h.html" target="_blank" rel="external">这里</a>找到。</p>
<p><code>ReadFile</code>函数返回一个aiScene指针对象，将加载的模型数据都存储在这个返回的场景对象指针中（Assimp的很多变量和方法名称都带有ai标识）。接着通过场景对象指针是否为空、场景对象的根结点是否为空和场景的加载标志flag是否为非完整加载<code>AI_SCENE_FLAGS_INCOMPLETE</code>来判断Assimp加载是否成功，如果不成功，使用加载器Importer对象的<code>GetErrorString</code>函数来返回错误报告。</p>
<p><font size="4" color="red">遍历aiMesh</font><br>现在所有的模型数据都存储在场景对象指针中，但是这些数据并不是配对的，我们不知道哪些材质（材质里有纹理）应该属于哪些mesh，就无法给每个mesh对应上正确的纹理贴图。所以我们需要去遍历每一个mesh，取出它里面的顶点、法线、纹理等等。</p>
<p>首先定义一个全局遍历meshes，用于存储遍历出来的每一个mesh：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    vector<Mesh> meshes;
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>遍历所有mesh的方法有两种，一种是直接遍历场景对象指针scene下的所有mesh：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    //遍历所有mesh
    void TraverseNode(aiNode* node) {
        //方法1：直接遍历场景对象指针scene中的所有mesh
        for (int i = 0; i < scene->mNumMeshes; i++) {
            meshes.push_back(ProcessMesh(scene->mMeshes[i]));
        }
    }
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>另外一种是从根结点开始递归遍历子结点，取出每一个结点包含的所有mesh。</p>
<pre class="line-numbers language-c++"><code class="language-c++">    //遍历所有mesh
    void TraverseNode(aiNode* node) {
        //方法2：递归每个结点
        //取出自身结点中的所有mesh
        for (GLuint i = 0; i < node->mNumMeshes; i++) {
            aiMesh* aimesh = scene->mMeshes[node->mMeshes[i]];
            meshes.push_back(ProcessMesh(aimesh));
        }
        //递归遍历子节点
        for (GLuint i = 0; i < node->mNumChildren; i++) {
            TraverseNode(node->mChildren[i]);
        }
    }
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在每一个结点中存储的mesh，都只是场景对象scene包含的mesh的一个索引。所以需要使用形如<code>scene-&gt;mMeshes[node-&gt;mMeshes[i]]</code>的方式去scene中获得真正的mesh。</p>
<p><font size="4" color="red">从aiMesh中提取数据转换为Mesh类对象</font><br>函数<code>ProcessMesh</code>是我们的自定义函数，用于从Assimp加载的aiMesh里提取出顶点、索引、纹理等，转变为Mesh类对象。</p>
<p>先在<code>ProcessMesh</code>函数里定义我们的Mesh所需要的顶点、索引和纹理：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    //把Assimp的aiMesh转换为我们自定义的Mesh
    Mesh ProcessMesh(aiMesh* aimesh) {
        vector<Vertex> vertices;
        vector<GLuint> indices;
        vector<Texture> textures;
        ...
    }
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>【注】：</p>
<ul>
<li>这里的Vertex、Texture都是在Mesh类之前定义的结构体，所以需要先包含mesh.h：<code>#include &quot;mesh.h&quot;</code></li>
</ul>
<p>接下来我们取出aiMesh中所有顶点的位置、法线、纹理坐标等顶点属性，赋值给我们自定义的顶点结构体：</p>
<pre class="line-numbers language-c++"><code class="language-c++">        //获取aiMesh中的所有顶点数据（包括顶点位置、法线向量、纹理坐标）
        for (GLuint i = 0; i < aimesh->mNumVertices; i++) {
            Vertex vertex;
            vertex.position = vec3(aimesh->mVertices[i].x, aimesh->mVertices[i].y, aimesh->mVertices[i].z);
            vertex.normal = vec3(aimesh->mNormals[i].x, aimesh->mNormals[i].y, aimesh->mNormals[i].z);
            if (aimesh->mTextureCoords[0]) {
                vertex.texCoords = vec2(aimesh->mTextureCoords[0][i].x, aimesh->mTextureCoords[0][i].y);
            }
            else {
                vertex.texCoords = vec2(0.0f, 0.0f);
            }
            vertices.push_back(vertex);
        }
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>【注】：</p>
<ul>
<li>Assimp允许一个模型的每个顶点有8个不同的纹理坐标，所以mTextureCoords是2维的，第一维指明是那组纹理坐标，第二维才指明是某组的哪一个纹理坐标。这里我们只关心顶点的第一组纹理坐标，所以第一维是0。</li>
</ul>
<p>当然，每次循环完后，不要忘记把Vertex结构体变量添加到vertices里。</p>
<p>接着我们取出aiMesh中的所有顶点索引，这些顶点索引都保存在每一个面片中：</p>
<pre class="line-numbers language-c++"><code class="language-c++">        //获取aiMesh中所有面片（这里就是三角形）的顶点索引
        for (GLuint i = 0; i < aimesh->mNumFaces; i++) {
            aiFace aiface = aimesh->mFaces[i];
            for (GLuint j = 0; j < aiface.mNumIndices; j++) {
                indices.push_back(aiface.mIndices[j]);
            }
        }
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们再来取出aiMesh的所有纹理，这些纹理都存储在材质中，所以需要先获取到材质：</p>
<pre class="line-numbers language-c++"><code class="language-c++">        //获取aiMesh的材质的所有材质纹理
        if (aimesh->mMaterialIndex >= 0) {
            aiMaterial* aimat = scene->mMaterials[aimesh->mMaterialIndex];
            ...
        }
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果某个mesh没有材质，那么它的<code>mMaterialIndex</code>属性会小于0。</p>
<p>由于Mesh类里需要纹理加载和绑定后的ID，所以我们需要aiMesh的每一个纹理的存储路径。纹理的名称可以由aiMaterial对象的<code>GetTexture</code>函数得到：</p>
<pre class="line-numbers language-c++"><code class="language-c++">            aiString str;
            //获取第i个漫反射纹理的名称
            aimat->GetTexture(aiTextureType_DIFFUSE, i, &str);
            string texRelativePath = str.C_Str();
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>GetTexture</code>函数的第一个参数是纹理类型，可以是漫反射纹理或者镜面纹理，第二个参数是第几个对应纹理，第三个参数用于存储纹理名称。注意第三个参数纹理名称是aiString类型的，需要使用<code>C_Str</code>函数转换为string类型。</p>
<p>只得到了纹理名称还不够，还应该有这个纹理所在的文件夹路径，这个我们可以用字符串自己指定。由于我们已经把纹理和模型文件nanosuit.obj放在同一个文件夹，而且在调用之前的<code>LoadModel</code>函数时，我们传入了模型文件的路径（<code>LoadModel</code>函数参数path），所以我们可以根据这个路径得到纹理所在的文件夹路径：</p>
<pre class="line-numbers language-c++"><code class="language-c++">string directory;
directory = path.substr(0, path.find_last_of('/'));
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><code>substr</code>函数的第一个参数指明截取字符串的起始位置，第二个参数指明截取字符串的终止位置。</p>
<p>但是<code>GetTexture</code>的第二个参数该怎么指定呢？我们怎么知道有多少个漫反射纹理，i应该取为多少才不会越界。可以使用aiMaterial对象的<code>GetTextureCount</code>函数来获取材质中相应纹理的数量，它只有一个参数，指明是漫反射纹理还是镜面纹理：</p>
<pre><code>        //获取aiMesh的材质的所有材质纹理
        if (aimesh-&gt;mMaterialIndex &gt;= 0) {
            aiMaterial* aimat = scene-&gt;mMaterials[aimesh-&gt;mMaterialIndex];
            //获取所有的漫反射纹理
            for (GLuint i = 0; i &lt; aimat-&gt;GetTextureCount(aiTextureType_DIFFUSE); i++) {
                aiString str;
                //获取第i个漫反射纹理的名称
                aimat-&gt;GetTexture(aiTextureType_DIFFUSE, i, &amp;str);
                string texName = str.C_Str(); //纹理名称 
                string texPath = directory + &#39;/&#39; + texName;  //纹理路径
                ...
            }
        }
</code></pre><p>纹理路径有了，接下来我们就可以用之前文章里的纹理加载类<code>TextureLoader</code>，来加载纹理了：</p>
<pre class="line-numbers language-c++"><code class="language-c++">        //获取aiMesh的材质的所有材质纹理
        if (aimesh->mMaterialIndex >= 0) {
            aiMaterial* aimat = scene->mMaterials[aimesh->mMaterialIndex];
            //获取所有的漫反射纹理
            for (GLuint i = 0; i < aimat->GetTextureCount(aiTextureType_DIFFUSE); i++) {
                aiString str;
                //获取第i个漫反射纹理的名称
                aimat->GetTexture(aiTextureType_DIFFUSE, i, &str);
                string texName = str.C_Str(); //纹理名称
                string texPath = directory + '/' + texName;  //纹理路径

                Texture texture;
                TextureLoader textureLoader;
                texture.id = textureLoader.LoadTexture(texPath.c_str());
                texture.samplerName = "diffuse_texture" + IntToString(i);
                textures.push_back(texture);
            }
        }
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>加载后的纹理ID赋值给Texture结构体变量的id属性，同时我们给Texture结构体变量的samplerName 属性赋值，对应像素着色器中的纹理采样器名称。当然不要忘了把Texture结构体变量添加到textures中。<br>【注】：</p>
<ul>
<li>由于C++没有提供把字符转换为字符串的函数，所以我们自己写了一个<code>IntToString</code>函数来实现这个功能：<pre class="line-numbers language-c++"><code class="language-c++">  //把int类型转换为string类型
  string IntToString(int number) {
      ostringstream outs;
      outs << number;
      return outs.str();
  }
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<p>对于镜面纹理的获取，和上面的漫反射纹理一样：</p>
<pre class="line-numbers language-c++"><code class="language-c++">            //获取所有的镜面纹理
            for (GLuint i = 0; i < aimat->GetTextureCount(aiTextureType_SPECULAR); i++) {
                aiString str;
                //获取第i个镜面反射纹理的存储路径
                aimat->GetTexture(aiTextureType_SPECULAR, i, &str);
                string texName = str.C_Str(); //纹理名称
                string texPath = directory + '/' + texName;  //纹理路径

                Texture texture;
                TextureLoader textureLoader;
                texture.id = textureLoader.LoadTexture(texPath.c_str());
                texture.samplerName = "specular_texture" + IntToString(i);
                textures.push_back(texture);
            }
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们再指定一下mesh的镜面反射系数，用以计算镜面反射光：</p>
<pre class="line-numbers language-c++"><code class="language-c++">        float shininess = 32;
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>最后，我们把这些顶点、索引、纹理和镜面反射系数，传递给Mesh类，Mesh类就会用它的构造函数，生成一个用于我们绘制的Mesh对象：</p>
<pre class="line-numbers language-c++"><code class="language-c++">        return Mesh(vertices, indices, textures, shininess);
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><font size="4" color="red">绘制每一个mesh</font><br>万事俱备，只欠东风。在LoadModel类里，我们已经把所有aiMesh转换为可以绘制的Mesh对象了，最后要做的就是在LoadModel类里调用所有Mesh对象的Draw函数，我们把它写在LoadModel类的Draw函数里：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    void Draw(shader myshader) {
        for (GLuint i = 0; i < meshes.size(); i++) {
            meshes[i].Draw(myshader);
        }
    }
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>&nbsp;</p>
<hr>
<p><font size="5" color="orange">绘制模型</font><br>绘制模型，只需要在主程序里定义<code>LoadModel</code>类对象，然后在渲染循环里调用它的Draw函数就可以了：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    Model mymodel("nanosuit/nanosuit.obj");
    ...
    mymodel.Draw(lightObject);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>&nbsp;</p>
<hr>
<p><font size="5" color="orange">重大优化</font><br>之前对每一个mesh的所有材质纹理，我们都会使用<code>TextureLoader</code>类去加载绑定，这个加载纹理的过程是很费时的。由于不同的mesh，它们的纹理可能是相同的，所以很有可能会出现同一张纹理加载了好几次。这无疑是浪费，需要避免。</p>
<p>怎么判断要加载的纹理已经被加载过了呢？判断要加载的纹理路径是否和已加载的纹理的路径相同即可。所以，我们需要给Texture结构体添加一个属性<code>texPath</code>来标识纹理的路径：</p>
<pre class="line-numbers language-c++"><code class="language-c++">struct Texture {
    GLuint id;
    string samplerName;
    string texPath;
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>还需要设置一个Texture结构体数组，用来存储已经加载过的纹理：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    vector<Texture> loadedTextures;  //存储已经加载过的纹理
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>在加载纹理之前，我们先判断要加载的纹理路径是否有和已加载纹理的路径相同的：</p>
<pre class="line-numbers language-c++"><code class="language-c++">                bool skip = false;  //纹理是否已经加载过
                for (int j = 0; j < loadedTextures.size(); j++) {
                    if (texPath == loadedTextures[j].texPath) {
                        skip = true;
                        textures.push_back(loadedTextures[j]);
                        break;
                    }
                }
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>用bool变量<code>skip</code>来标识纹理是否已经加载过，如果要加载的纹理路径和已加载的某一纹理的路径相同，那么textures直接添加已加载的纹理即可，不用再去加载一次纹理，并且设置<code>skip</code>为真，标识纹理已经加载过，退出循环。</p>
<p>如果纹理没有被加载过，for循环里的内容就一直不会被执行，<code>skip</code>将为假，这时就需要去加载纹理了。加载完后不要忘了把纹理路径存储到Texture结构体变量中，并且把该结构体变量添加到已加载纹理数组<code>loadedTextures</code>中：</p>
<pre class="line-numbers language-c++"><code class="language-c++">                if (!skip) {
                    Texture texture;
                    TextureLoader textureLoader;
                    texture.id = textureLoader.LoadTexture(texPath.c_str());
                    texture.samplerName = "diffuse_texture" + IntToString(i);
                    texture.texPath = texPath;
                    textures.push_back(texture);
                    loadedTextures.push_back(texture);
                }
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对于镜面纹理，也是一样的优化处理，不再赘述。</p>
<p><font size="5" color="orange">所有源码</font><br>到此，所有源码<a href="https://github.com/Popperelay/BlogCode/tree/master/LearnOpenGL14_LoadModel" target="_blank" rel="external">在这里</a></p>
<p>【注】：</p>
<ul>
<li>主程序里去掉了对光源物体的绘制。</li>
</ul>
<p>编译运行后的结果如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148421809914.png" alt=""><br>&nbsp;</p>
<hr>
<p>参考文献：<a href="https://learnopengl.com/" target="_blank" rel="external">LearnOpenGL</a></p>

            </div>

            <!-- Post Comments -->
            
    <!-- 使用 DISQUS_CLICK -->
<div id="disqus-comment">
    <div id="disqus_thread"></div>

<!-- add animation -->
<style>
	.disqus_click_btn {
            line-height: 30px;
            margin: 0;
            min-width: 50px;
            padding: 0 14px;
            display: inline-block;
            font-family: "Roboto", "Helvetica", "Arial", sans-serif;
            font-size: 14px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0;
            overflow: hidden;
            will-change: box-shadow;
            transition: box-shadow .2s cubic-bezier(.4, 0, 1, 1), background-color .2s cubic-bezier(.4, 0, .2, 1), color .2s cubic-bezier(.4, 0, .2, 1);
            outline: 0;
            cursor: pointer;
            text-decoration: none;
            text-align: center;
            vertical-align: middle;
            border: 0;
            background: rgba(158, 158, 158, .2);
            box-shadow: 0 2px 2px 0 rgba(0, 0, 0, .14), 0 3px 1px -2px rgba(0, 0, 0, .2), 0 1px 5px 0 rgba(0, 0, 0, .12);
            color: #fff;
            background-color: #7EC0EE;
            text-shadow: 0
        }
</style>
	
<div class="btn_click_load" id="disqus_bt"> 
    <button class="disqus_click_btn">点击查看评论</button>
</div>

<!--
<script type="text/javascript">
$('.btn_click_load').click(function() {
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'http-miccall-tech'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    document.getElementById('disqus_bt').style.display = "none";
});
</script>
-->
<script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://yoursite.com/2017/01/12/OpenGL14模型加载/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = 'http://yoursite.com/2017/01/12/OpenGL14模型加载/'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
</script>

<script type="text/javascript">
    $('.btn_click_load').click(function() {  //click to load comments
        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document;
            var s = d.createElement('script');
            s.src = '//http-miccall-tech.disqus.com/embed.js';
            s.setAttribute('data-timestamp', + new Date());
            (d.head || d.body).appendChild(s);
        })();
        $('.btn_click_load').css('display','none');
    });
</script>
</div>
<style>
    #disqus-comment{
        background-color: #eee;
        padding: 2pc;
    }
</style>


        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
                <li>Design: <a href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
            </ul>
            
            	<span id="busuanzi_container_site_pv">2018总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			
        </div>
    </div>
</body>



 	
</html>
