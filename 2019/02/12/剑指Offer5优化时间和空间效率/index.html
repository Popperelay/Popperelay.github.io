<!DOCTYPE HTML>
<html>

<head>
	<link rel="bookmark"  type="image/x-icon"  href="/img/logo_miccall.png"/>
	 <link rel="shortcut icon" href="/img/logo_miccall.png">
	
			
    <title>
    Elays'Blog
    </title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="/css/mic_main.css" />
    <link rel="stylesheet" href="/css/dropdownMenu.css" />
    
    	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css" />
    </noscript>
			    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<link rel="stylesheet" href="/css/prism-dark.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>
    
		
<!-- Layouts -->


<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<!--<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">-->
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/latest.js?config=TeX-MML-AM_CHTML" async>
</script>

<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_undefined.css" />
<link rel="stylesheet" href="/css/typo.css" />
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">MICCALL</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special" >
            <ul class="menu links" >
			<!-- Homepage  主页  --> 
			<li >
	            <a href="/" rel="nofollow">主页</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">分类</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="/categories/Boost/">Boost</a></li><li><a class="category-link" href="/categories/C-语法/">C#语法</a></li><li><a class="category-link" href="/categories/C/">C++</a></li><li><a class="category-link" href="/categories/C语言/">C语言</a></li><li><a class="category-link" href="/categories/Math/">Math</a></li><li><a class="category-link" href="/categories/OpenGL/">OpenGL</a></li><li><a class="category-link" href="/categories/c/">c++</a></li><li><a class="category-link" href="/categories/全局光照/">全局光照</a></li><li><a class="category-link" href="/categories/博客配置/">博客配置</a></li><li><a class="category-link" href="/categories/并行计算/">并行计算</a></li><li><a class="category-link" href="/categories/操作系统/">操作系统</a></li><li><a class="category-link" href="/categories/数据结构/">数据结构</a></li><li><a class="category-link" href="/categories/毕设/">毕设</a></li><li><a class="category-link" href="/categories/游戏开发/">游戏开发</a></li><li><a class="category-link" href="/categories/游戏设计模式/">游戏设计模式</a></li><li><a class="category-link" href="/categories/计算机图形学/">计算机图形学</a></li><li><a class="category-link" href="/categories/计算机系统/">计算机系统</a></li><li><a class="category-link" href="/categories/设计模式/">设计模式</a></li><li><a class="category-link" href="/categories/调试错误集锦/">调试错误集锦</a></li><li><a class="category-link" href="/categories/面试/">面试</a>
	                    </ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/gallery/" title="图库">
		                图库
		            </a>
		        </li>
		        
		        <li>
		            <a href="/tag/" title="搜索">
		                搜索
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
		            
		                <li><a href="https://github.com/miccall" class="icon fa-github"><span class="label">GitHub</span></a></li>
		            
		            
		            
		            
			</ul>
</nav>

        <div id="main" >
            <div class ="post_page_title_img" style="height: 25rem;background-image: url(null);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;" >
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2 >剑指Offer5优化时间和空间效率</h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
				<!-- 目录 -->
				<p class="show-toc-btn" id="show-toc-btn" onclick="showToc();" style="display:none">
				<span class="btn-bg"></span>
				<span class="btn-text">文章导航</span>
				</p>
				<div id="toc-article" class="toc-article">
					<span id="toc-close" class="toc-close" title="隐藏导航" onclick="showBtn();">×</span>
					<strong class="toc-title">文章目录</strong>
					<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#面试题39：数组中出现次数超过一半的数字"><span class="toc-text">面试题39：数组中出现次数超过一半的数字</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#面试题40：最小的k个数"><span class="toc-text">面试题40：最小的k个数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#面试题41：数据流中的中位数"><span class="toc-text">面试题41：数据流中的中位数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#面试题42：连续子数组的最大和"><span class="toc-text">面试题42：连续子数组的最大和</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#面试题43：1-n整数中1出现的次数"><span class="toc-text">面试题43：1~n整数中1出现的次数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#面试题44：数字序列中某一位的数字"><span class="toc-text">面试题44：数字序列中某一位的数字</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#面试题45：把数组排成最小的数"><span class="toc-text">面试题45：把数组排成最小的数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#面试题46：把数字翻译成字符串"><span class="toc-text">面试题46：把数字翻译成字符串</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#面试题47：礼物的最大价值"><span class="toc-text">面试题47：礼物的最大价值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#面试题48：最长不含重复字符的子字符串"><span class="toc-text">面试题48：最长不含重复字符的子字符串</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#面试题49：丑数"><span class="toc-text">面试题49：丑数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#面试题50：第一个只出现一次的字符"><span class="toc-text">面试题50：第一个只出现一次的字符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#面试题51：数组中的逆序对"><span class="toc-text">面试题51：数组中的逆序对</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#面试题52：两个链表的第一个公共节点"><span class="toc-text">面试题52：两个链表的第一个公共节点</span></a></li></ol>
			   </div>
			   <script type="text/javascript">
				function showToc(){
					var toc_article = document.getElementById("toc-article");
					var show_toc_btn = document.getElementById("show-toc-btn");
					toc_article.setAttribute("style","display:block");
					show_toc_btn.setAttribute("style","display:none");
					};
				function showBtn(){
					var toc_article = document.getElementById("toc-article");
					var show_toc_btn = document.getElementById("show-toc-btn");
					toc_article.setAttribute("style","display:none");
					show_toc_btn.setAttribute("style","display:block");
					};
			   </script>
				
                <p>如果小问题中有相互重叠的部分，那么直接用递归实现虽然代码显得很简洁，但时间效率可能会非常差。</p>
<h1 id="面试题39：数组中出现次数超过一半的数字"><a href="#面试题39：数组中出现次数超过一半的数字" class="headerlink" title="面试题39：数组中出现次数超过一半的数字"></a><font size="6" color="orange">面试题39：数组中出现次数超过一半的数字</font></h1><hr>
<p>题目：数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如，输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。</p>
<p>解法一：<br>由于有一个数字出现的次数超过了数组长度n的一半，所以排序后这个数字肯定是中位数。可以借用快排一次排序的思想，随机选择一个数字作为基准数，一次快排之后，比这个基准数小的都跑到了它左边，比这个基准数大的都跑到了它右边。所以一次快排之后，如果发现这个基准数不在中位数的位置，即下标不是n/2，那说明这个基准数不是中位数（即要找的那个出现次数超过一半的数）；如果下标大于n/2，说明中位数肯定在它左边；如果下标小于n/2，说明中位数肯定在它右边。在左边或者右边就需要再循环调用一次快排，直到发现基准数等于n/2为止。<strong>这个算法其实不仅可以用来找中位数，也可以用来找数组中任意第k大的数字</strong>。而且它的时间复杂度是O(n)。</p>
<p>完整代码如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>解法二：<br>可以根据数组中数出现的次数这个特性来解答：在遍历数组的时候保存两个值，一个是数组中一个数字，另一个是次数。当我们遍历到下一个数字的时候，如果下一个数字和我们之前保存的数字相同，则次数加1；如果下一个数字和我们之前保存的数字不同，则次数减1。如果次数变成了0，那么我们需要保存下一个数字，并把次数设为1。由于我们要找的数字出现的次数比其他所有数字出现的次数之和还要多，所以要找的数字肯定是最后一次把次数设为1时对应的数字。该算法的时间复杂度也是O(n)。</p>
<p>完整代码如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>第一种算法会改变原有数组，第二种算法不会。</p>
<h1 id="面试题40：最小的k个数"><a href="#面试题40：最小的k个数" class="headerlink" title="面试题40：最小的k个数"></a><font size="6" color="orange">面试题40：最小的k个数</font></h1><hr>
<p>题目：输入n个整数，找出其中最小的k个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p>
<p>解法一：<br>可以和上题一样，利用一次快速排序，来找第k大的数字。然后最小的k个数就是它前面的数字（时间复杂度为O(n)）。</p>
<p>完整代码如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>解法二：<br>可以用一个大小为k的最大堆来实现。当新进来一个数字时，如果大于堆顶，则不管它；如果小于堆顶，则把这个数插入最大堆里（这个算法的时间复杂度是O(nlogk)）。</p>
<p>实现一个堆在面试的十几分钟内很难完成（其实STL也提供了堆模板操作函数：<code>push_heap</code>和<code>pop_heap</code>）。如果面试官不反对用STL，那么我们可以用set、map这类红黑树容器来代替。红黑树会把节点分为红、黑两种颜色并根据一些规则确保树在一定程度上是平衡的，从而保证在红黑树中的查找、删除和插入操作的时间复杂度都是O(logk)。所以整个算法的时间复杂度是O(nlogk)。</p>
<p>第一种算法会修改输入的数据，第二种算法适合海量数据的输入（因为内存大小是有限的，有可能不能把这些海量的数据一次性全部载入内存）。</p>
<h1 id="面试题41：数据流中的中位数"><a href="#面试题41：数据流中的中位数" class="headerlink" title="面试题41：数据流中的中位数"></a><font size="6" color="orange">面试题41：数据流中的中位数</font></h1><hr>
<p>题目：如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p>
<p>由于数据是从一个数据流中读出来的，因而数据的数目随着时间的的变化而增加。如果用一个数据容器来保存从流中读出来的数据，则当有新的数据从流中读出来时，这些数据就插入数据容器。那么这个数据容器用什么数据结构定义最合适呢？</p>
<p>如果能够保证数据容器坐标的数据都小于右边的数据，那么即使左、右两边内部的数据没有排序，也可以根据左边最大的数及右边最小的数来得到中位数。可以用一个最大堆来实现左边的数据容器，用一个最小堆来实现右边的数据容器。由于要保证数据平均分配到两个堆中，即两个堆中数据的数目只差不能超过1。所以当数据总数是奇数时把新数据插入左边的最大堆，当数据总数是偶数时，为了避免新数据比最大堆中一些数据小（必须保证最小堆中的所有数据都要大于最大堆中的所有数据），所以不能直接插入最小堆里，可以先把这个新数据插入最大堆，再把最大堆中最大的数字拿出来插入最小堆。这样就能保证最小堆中所有数字都大于最大堆中的数字。</p>
<p>完整代码如下（基于STL的模板函数<code>push_heap</code>、<code>pop_heap</code>及vector实现堆）：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h1 id="面试题42：连续子数组的最大和"><a href="#面试题42：连续子数组的最大和" class="headerlink" title="面试题42：连续子数组的最大和"></a><font size="6" color="orange">面试题42：连续子数组的最大和</font></h1><hr>
<p>题目：输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为O(n)。</p>
<p>解法一：<br>在每次往后遍历数组时，保存一个之前的最大的子数组和。比如对于数组{1,-2,3,10,-4,7,2,-5}，初始化时和为0，加上第一个数1之后和为1，此时最大的和为1；加上第二个数-2之后和为-1，再往后加第三个数的话负数只会让第三个数更小，所以直接把最大和更新为第三个数；再加上第4个数10后，最大和更新为13；再加上-4之后当前和变成9，最大和还是13；再加上7之后当前和变成16，最大和也随之更新为16；再加上2之后最大和更新为18；再加上-5之后最大和还是18。</p>
<p>所以：需要在遍历的时候保存一个之前的最大的子数组和，才能确保接着往后面加会不会出现超过这个最大和的。而且加的时候，如果发现当前和是个负数，那么就应该舍弃前面的子数组，因为负数往后加只会把当前那个数变的更小，还不如令当前和直接等于当前这个数。</p>
<p>完整代码如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>解法二：应用动态规划<br>这个问题可以用下列的递归公式来表示（$f(i)表示以第i个数字结尾的子数组的最大和$）：<br>$$<br>f(i)=<br>\begin{cases}<br>pData[i], &amp;i=0或者f(i-1)\le 0 \\<br>f(i-1)+pData[i], &amp;i\ne 0并且f(i-1)&gt;0<br>\end{cases}<br>$$<br>这个公式的意义是：当以第i-1个数字结尾的子数组中所有数字的和小于0时，如果把这个负数与第i个数累加，则得到的结果比第i个数字本身还要小，所以这种情况情况下以第i个数字结尾的子数组的最大和就是第i个数本身。如果第i-1个数字结尾的子数组中所有数字的和大于0，则与第i个数字累加就得到以第i个数字结尾的子数组中的最大和。</p>
<p>这时基于递归的方式在分析动态规划的问题的，但最终都会基于循环去编码，会发现代码和上面的一样，因为$f(i)$其实就是变量<code>CurrentSum</code>，这两种思路是异曲同工的。</p>
<h1 id="面试题43：1-n整数中1出现的次数"><a href="#面试题43：1-n整数中1出现的次数" class="headerlink" title="面试题43：1~n整数中1出现的次数"></a><font size="6" color="orange">面试题43：1~n整数中1出现的次数</font></h1><hr>
<p>题目：输入一个整数n，求1~n这n个整数的十进制表示中1出现的次数。例如输入12,1~12这些整数中包含1的数字有1、10、11和12，所以1一共出现了5次。</p>
<p>可以通过每次去掉最高位来进行递归统计，递归的次数和位数相同。举例子来说：比如n=21345，把21345按最高位分成1~1345和1346~21345两个部分，会发现后一段1346~21345中1的个数，和1~20000是一样的，因为21345的后四位刚好不上1346之前的数字。而前一段1~1345中1的个数就可以用相同的方式递归求解了。</p>
<p>完整代码如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>一个数字n有O(logn)位，因此这种思路的时间复杂度是O(logn)。</p>
<h1 id="面试题44：数字序列中某一位的数字"><a href="#面试题44：数字序列中某一位的数字" class="headerlink" title="面试题44：数字序列中某一位的数字"></a><font size="6" color="orange">面试题44：数字序列中某一位的数字</font></h1><hr>
<p>题目：数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从0开始计数）是5，第13位是1，第19位是4，等等。请写一个函数，求任意第n位对应的数字。</p>
<p>可以根据0~9占了10x1=10位、10~99占了90x2=180位、100~999占了900x3=2700位……，来快速定位到第n位是在数字m里的第k位，然后对数字m求模求除法就能得到第k位上的数字了。</p>
<p>完整代码如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h1 id="面试题45：把数组排成最小的数"><a href="#面试题45：把数组排成最小的数" class="headerlink" title="面试题45：把数组排成最小的数"></a><font size="6" color="orange">面试题45：把数组排成最小的数</font></h1><hr>
<p>题目：输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印出能拼接出的所有数字中最小的一个。例如数组数组{3,32,321}，则打印出这3个数字能排成的最小数字321323。</p>
<p>一种解法当然是求出全排列，然后选出最小的数。还有更快的方法：两个数字m和n，如果拼接之后mn&lt;nm则定义为m小于n（一种新的小于关系，不是真正数值上的小于）。然后把数组中的所有数字按照这个小于关系进行排序，排序完之后从头到尾拼接起来的数字就是能够组成的最小的数字（证明过程很复杂）。</p>
<p>需要注意的是，不能直接在数值上去判断mn&lt;nm，因为单独的m或者n可能不会溢出，但是组合成的mn或者nm会溢出整型能够表示的最大范围。也就是说还隐藏了一个大数问题。解决大数问题的常用方法是把数字转换成字符串，因为mn和nm的位数是一样的，所以直接比较字符nm和字符串mn的大小得到的结果和比较数值是一样的。</p>
<p>完整代码如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h1 id="面试题46：把数字翻译成字符串"><a href="#面试题46：把数字翻译成字符串" class="headerlink" title="面试题46：把数字翻译成字符串"></a><font size="6" color="orange">面试题46：把数字翻译成字符串</font></h1><hr>
<p>题目：给定一个数字，我们按照如下规则把它翻译为字符串：0翻译成’a’，1翻译成’b’，…….，25翻译成’z’。一个数字可能有多个翻译。例如，12258有5种不同的翻译，分别是”bccfi”、”bwfi”、”bczi”、”mcfi”和”mzi”。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p>
<p>以数字12258为例，一开始有两种选择：第一种是把数字1翻译成’b’，后面剩下数字2258；第二种是把数字12翻译成’m’，后面剩下数字258。翻译后面剩下的数字也是一样的过程，都有两种选择。所以这很明显是一个递归的过程。用$f(i)$表示从第i位开始的不同翻译的数目，那么递归公式如下：<br>$$<br>f(i)=f(i+1)+g(i,i+1)f(i+2)<br>$$<br>当第i位和第i+1位两位数字拼接起来的数字在10~25的范围内时，函数$g(i,i+1)$的值为1，否则为0。</p>
<p>用递归来解的话会存在很多重复的子问题，所以还是基于递归分析问题，然后用循环来实现(即从右到左翻译)。完整代码如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h1 id="面试题47：礼物的最大价值"><a href="#面试题47：礼物的最大价值" class="headerlink" title="面试题47：礼物的最大价值"></a><font size="6" color="orange">面试题47：礼物的最大价值</font></h1><hr>
<p>题目：在一个mxn的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格，直到到达棋盘的右下角。给定一个棋盘及其上面的礼物，请计算你最多能拿到多少价值的礼物？</p>
<p>这是一个典型的能用动态规划解决的问题。先用递归的思路来分析：先定义函数$f(i,j)$表示到达坐标为(i, j)的格子时能拿到的礼物总和的最大值。有两种路径能够到达坐标为(i,j)的格子：通过格子(i-1, j)或者(i, j-1)。所以：<br>$$<br>f(i, j) = max(f(i-1, j), f(i, j-1)) + gift[i, j]<br>$$</p>
<p>$gift[i,j]$表示坐标为[i, j]的格子里礼物的价值。</p>
<p>用递归来解决会存在很多重复的子问题，所以还是用循环来实现（过程中会用一个辅助的mxn的二维数组来缓存中间的计算结果）。</p>
<p>完整代码如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>其实还可以优化：到达坐标(i, j)的格子时能够拿到的礼物的最大价值只依赖坐标为(i-1, j)和(i, j-1)的两个格子，因此第i-2行及更上面的所有格子礼物的最大价值实际上没有必要保存下来。可以用一个长度为n的一维数组来替代前面代码中的二维矩阵。优化后的代码如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h1 id="面试题48：最长不含重复字符的子字符串"><a href="#面试题48：最长不含重复字符的子字符串" class="headerlink" title="面试题48：最长不含重复字符的子字符串"></a><font size="6" color="orange">面试题48：最长不含重复字符的子字符串</font></h1><hr>
<p>题目：请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。假设字符串中只包含’a’~’z’的字符。例如，在字符串”arabcacfr”中，最长的不含重复字符的子字符串是”acfr”，长度为4。</p>
<p>该题也可以用动态规划来解决。先以递归的思路来分析：设$f(i)$表示以第i个字符为结尾的不包含重复字符的子字符串的最长长度。那么$f(i)$和$f(i-1)$的关系是什么？</p>
<ul>
<li>如果第i个字符在之前没有出现过，那么$f(i)=f(i-1)+1$；</li>
<li>如果第i个字符在之前出现过，但是距离太远不在$f(i-1)$所对应的最长子字符串中，那么还是$f(i)=f(i-1)+1$；</li>
<li>如果第i个字符在之前出现过，而且出现在$f(i-1)$对应的最长子字符串中，第i个字符到它上次出现的位置距离为d，那么此时$f(i)=d$。</li>
</ul>
<p>为了得到距离d，需要一个长度为26的整型数组来记录每个字符上次出现在字符串中位置的下标。</p>
<p>完整代码如下（用循环来实现）：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h1 id="面试题49：丑数"><a href="#面试题49：丑数" class="headerlink" title="面试题49：丑数"></a><font size="6" color="orange">面试题49：丑数</font></h1><hr>
<p>题目：我们把只包含因子2、3和5的数称作丑数（Ugly Number）。求按从小到大的顺序的第1500个丑数。例如，6、8都是丑数，但14不是，因为它包含因子7。习惯上我们把1当作第一个丑数。</p>
<p>根据丑数的定义，丑数应该是另一个丑数乘以2、3或者5的结果（1除外）。假设数组中已经有若干个排好序的丑数，那么下一个丑数应该是数组中已有的丑数乘上2、3或者5之后，得到的所有超过当前最大丑数的那些数里面最小的那个数。所以我们可以从头开始，一个一个地生成下一个丑数。比如初始时数组中是1，乘上2、3、5之后的最小数是2，数组变成[1, 2]；数组中已有的1、2这两个数乘上2、3、5之后的最小数是3，所以数组变成[1,2,3]；数组中已有的1、2、3这个三个数乘上2、3、5之后的最小数是2x2=4，所以数组变成[1,2,3,4]；接着数组中已有的1、2、3、4这个四个数乘上2、3、5之后的最小值是1x5=5，所以数组变成[1,2,3,4,5]……。</p>
<p>实际上不用对已有的数组里的所有数都去乘2、3、5，再去求超过当前最大丑数的最小值。已有的丑数里面肯定会有前面一段数即使乘上2，也不可能超过当前最大丑数，这些数是可以不用去计算的；同样的，也会有前面一段数即使乘上3也不可能超过当前最大丑数，这些数也是可以不用去计算的；对5也是一样的。需要记录下要从哪个位置的丑数开始计算才是有意义的。</p>
<p>完整代码如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h1 id="面试题50：第一个只出现一次的字符"><a href="#面试题50：第一个只出现一次的字符" class="headerlink" title="面试题50：第一个只出现一次的字符"></a><font size="6" color="orange">面试题50：第一个只出现一次的字符</font></h1><hr>
<p>题目一：字符串中第一个只出现一次的字符。在字符串中找出第一个只出现一次的字符。入输入”abaccdeff”，则输出’b’。</p>
<p>思路很简单：用哈希表来统计字符出现的次数就行了就行了。</p>
<p>完整代码如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>如果要求有统计的字符有汉字（汉字有几千个），那么前面的算法是不是有问题？该怎么解决？</p>
<p>相关题目：</p>
<ul>
<li>从第一个字符串中删除在第二个字符串中出现过的所有字符。可以用哈希表统计第二个字符串中出现的字符，然后遍历第一个字符串时就可以在O(1)时间内判断该字符是不是在第二个字符串中出现过。所以时间复杂度是O(n)。</li>
<li>删除字符串中所有重复出现的字符。也可以在遍历的时候用哈希表来记录某个字符是否出现过（哈希值是bool值）。</li>
<li>判断两个单词是不是字母及其出现的次数完全相同（字母顺序可以不一样）（称这个两个单词互为变位词），可以在遍历第一个字符串的时候，为对应字符的哈希值加1，然后再遍历第二个字符串的时候，为对应字符的哈希值减1。遍历完第二个字符串后，如果哈希表里所有的值都是0，那么这两个单词就是变位词。</li>
</ul>
<p>题目二：字符流中第一个只出现一次的字符。请实现一个函数，用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是’g’；当从该字符流中读出前6个字符”google”时，第一个只出现一次的字符是’l’。</p>
<p>也可以用哈希表来解决，只是存储的哈希值不再是bool值，而是字符在字符口中的位置。</p>
<p>当我们需要找出到目前为止从字符流里读出的所有字符中第一个不重复的字符时，只需要扫描整个数组，并从中找出最小的大于等于0的值哈希值对应的字符即可。</p>
<h1 id="面试题51：数组中的逆序对"><a href="#面试题51：数组中的逆序对" class="headerlink" title="面试题51：数组中的逆序对"></a><font size="6" color="orange">面试题51：数组中的逆序对</font></h1><hr>
<p>题目：在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。例如，在数组{7,5,6,4}中，一共存在5个逆序对，分别是(7,6)、(7,5)、(7,4)、(6,4)和(5,4)。</p>
<p>可以用归并排序的方式，来统计组内和组间的逆序对（有时间来具体分析。。。）。</p>
<p>完整代码如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h1 id="面试题52：两个链表的第一个公共节点"><a href="#面试题52：两个链表的第一个公共节点" class="headerlink" title="面试题52：两个链表的第一个公共节点"></a><font size="6" color="orange">面试题52：两个链表的第一个公共节点</font></h1><hr>
<p>题目：输入两个链表，找出它们的第一个公共节点。链表节点定义如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> SListNode
<span class="token punctuation">{</span>
    <span class="token keyword">int</span>                    m_Value<span class="token punctuation">;</span>
    SListNode<span class="token operator">*</span>            m_pNext<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>解决思路很简单：遍历两个链表，可以得到两个链表的长度之差L。一个指针在长的链表上先走L步，然后另一个指针开始从短链表的头结点出发向后走，当两个指针相同时就是第一个公共节点。</p>
<p>完整代码如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>另外一种稍微费事的方法是：使用栈来保存两个链表的节点，这样就可以从尾到头来反向遍历，找到的最后一个相同的节点，就是要求的第一个公共节点。但是需要O(m+n)的空间复杂度。</p>
<hr>
<p>参考文献：《剑指Offer》</p>

            </div>

            <!-- Post Comments -->
            
    <!-- 使用 DISQUS_CLICK -->
<div id="disqus-comment">
    <div id="disqus_thread"></div>

<!-- add animation -->
<style>
	.disqus_click_btn {
            line-height: 30px;
            margin: 0;
            min-width: 50px;
            padding: 0 14px;
            display: inline-block;
            font-family: "Roboto", "Helvetica", "Arial", sans-serif;
            font-size: 14px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0;
            overflow: hidden;
            will-change: box-shadow;
            transition: box-shadow .2s cubic-bezier(.4, 0, 1, 1), background-color .2s cubic-bezier(.4, 0, .2, 1), color .2s cubic-bezier(.4, 0, .2, 1);
            outline: 0;
            cursor: pointer;
            text-decoration: none;
            text-align: center;
            vertical-align: middle;
            border: 0;
            background: rgba(158, 158, 158, .2);
            box-shadow: 0 2px 2px 0 rgba(0, 0, 0, .14), 0 3px 1px -2px rgba(0, 0, 0, .2), 0 1px 5px 0 rgba(0, 0, 0, .12);
            color: #fff;
            background-color: #7EC0EE;
            text-shadow: 0
        }
</style>
	
<div class="btn_click_load" id="disqus_bt"> 
    <button class="disqus_click_btn">点击查看评论</button>
</div>

<!--
<script type="text/javascript">
$('.btn_click_load').click(function() {
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'http-miccall-tech'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    document.getElementById('disqus_bt').style.display = "none";
});
</script>
-->
<script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://yoursite.com/2019/02/12/剑指Offer5优化时间和空间效率/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = 'http://yoursite.com/2019/02/12/剑指Offer5优化时间和空间效率/'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
</script>

<script type="text/javascript">
    $('.btn_click_load').click(function() {  //click to load comments
        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document;
            var s = d.createElement('script');
            s.src = '//http-miccall-tech.disqus.com/embed.js';
            s.setAttribute('data-timestamp', + new Date());
            (d.head || d.body).appendChild(s);
        })();
        $('.btn_click_load').css('display','none');
    });
</script>
</div>
<style>
    #disqus-comment{
        background-color: #eee;
        padding: 2pc;
    }
</style>


        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
                <li>Design: <a href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
            </ul>
            
            	<span id="busuanzi_container_site_pv">2019总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			
        </div>
    </div>
</body>



 	
</html>
