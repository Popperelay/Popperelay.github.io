<!DOCTYPE HTML>
<html>

<head>
	<link rel="bookmark"  type="image/x-icon"  href="/img/logo_miccall.png"/>
	 <link rel="shortcut icon" href="/img/logo_miccall.png">
	
			
    <title>
    Elays'Blog
    </title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="/css/mic_main.css" />
    <link rel="stylesheet" href="/css/dropdownMenu.css" />
    
    	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css" />
    </noscript>
			    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<link rel="stylesheet" href="/css/prism-dark.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>
    
		
<!-- Layouts -->


<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<!--<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">-->
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/latest.js?config=TeX-MML-AM_CHTML" async>
</script>

<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_undefined.css" />
<link rel="stylesheet" href="/css/typo.css" />
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">MICCALL</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special" >
            <ul class="menu links" >
			<!-- Homepage  主页  --> 
			<li >
	            <a href="/" rel="nofollow">主页</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">分类</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="/categories/Boost/">Boost</a></li><li><a class="category-link" href="/categories/C-语法/">C#语法</a></li><li><a class="category-link" href="/categories/C/">C++</a></li><li><a class="category-link" href="/categories/C语言/">C语言</a></li><li><a class="category-link" href="/categories/Math/">Math</a></li><li><a class="category-link" href="/categories/OpenGL/">OpenGL</a></li><li><a class="category-link" href="/categories/c/">c++</a></li><li><a class="category-link" href="/categories/全局光照/">全局光照</a></li><li><a class="category-link" href="/categories/博客配置/">博客配置</a></li><li><a class="category-link" href="/categories/并行计算/">并行计算</a></li><li><a class="category-link" href="/categories/操作系统/">操作系统</a></li><li><a class="category-link" href="/categories/数据结构/">数据结构</a></li><li><a class="category-link" href="/categories/毕设/">毕设</a></li><li><a class="category-link" href="/categories/游戏开发/">游戏开发</a></li><li><a class="category-link" href="/categories/游戏设计模式/">游戏设计模式</a></li><li><a class="category-link" href="/categories/计算机图形学/">计算机图形学</a></li><li><a class="category-link" href="/categories/计算机系统/">计算机系统</a></li><li><a class="category-link" href="/categories/设计模式/">设计模式</a></li><li><a class="category-link" href="/categories/调试错误集锦/">调试错误集锦</a></li><li><a class="category-link" href="/categories/面试/">面试</a>
	                    </ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/gallery/" title="图库">
		                图库
		            </a>
		        </li>
		        
		        <li>
		            <a href="/tag/" title="搜索">
		                搜索
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
		            
		                <li><a href="https://github.com/miccall" class="icon fa-github"><span class="label">GitHub</span></a></li>
		            
		            
		            
		            
			</ul>
</nav>

        <div id="main" >
            <div class ="post_page_title_img" style="height: 25rem;background-image: url(null);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;" >
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2 >剑指Offer4解决面试题的思路</h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
				<!-- 目录 -->
				<p class="show-toc-btn" id="show-toc-btn" onclick="showToc();" style="display:none">
				<span class="btn-bg"></span>
				<span class="btn-text">文章导航</span>
				</p>
				<div id="toc-article" class="toc-article">
					<span id="toc-close" class="toc-close" title="隐藏导航" onclick="showBtn();">×</span>
					<strong class="toc-title">文章目录</strong>
					<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#面试题27：二叉树的镜像"><span class="toc-text">面试题27：二叉树的镜像</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#面试题28：对称的二叉树"><span class="toc-text">面试题28：对称的二叉树</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#面试题29：顺时针打印矩阵"><span class="toc-text">面试题29：顺时针打印矩阵</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#面试题30：包含min函数的栈"><span class="toc-text">面试题30：包含min函数的栈</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#面试题31：栈的压入、弹出序列"><span class="toc-text">面试题31：栈的压入、弹出序列</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#面试题32：从上到下打印二叉树"><span class="toc-text">面试题32：从上到下打印二叉树</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#面试题33：二叉搜索树的后序遍历序列"><span class="toc-text">面试题33：二叉搜索树的后序遍历序列</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#面试题34：二叉树中和为某一值的路径"><span class="toc-text">面试题34：二叉树中和为某一值的路径</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#面试题35：复杂链表的复制"><span class="toc-text">面试题35：复杂链表的复制</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#面试题36：二叉搜索树与双向链表"><span class="toc-text">面试题36：二叉搜索树与双向链表</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#面试题37：序列化二叉树"><span class="toc-text">面试题37：序列化二叉树</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#面试题38：字符串的排列"><span class="toc-text">面试题38：字符串的排列</span></a></li></ol>
			   </div>
			   <script type="text/javascript">
				function showToc(){
					var toc_article = document.getElementById("toc-article");
					var show_toc_btn = document.getElementById("show-toc-btn");
					toc_article.setAttribute("style","display:block");
					show_toc_btn.setAttribute("style","display:none");
					};
				function showBtn(){
					var toc_article = document.getElementById("toc-article");
					var show_toc_btn = document.getElementById("show-toc-btn");
					toc_article.setAttribute("style","display:none");
					show_toc_btn.setAttribute("style","display:block");
					};
			   </script>
				
                <h1 id="面试题27：二叉树的镜像"><a href="#面试题27：二叉树的镜像" class="headerlink" title="面试题27：二叉树的镜像"></a><font size="6" color="orange">面试题27：二叉树的镜像</font></h1><hr>
<p>题目：请完成一个函数，输入一棵二叉树，该函数输出它的镜像。二叉树节点的定义如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> SBinaryTreeNode
<span class="token punctuation">{</span>
    <span class="token keyword">int</span>                    m_Value<span class="token punctuation">;</span>
    SBinaryTreeNode<span class="token operator">*</span>    m_pLeft<span class="token punctuation">;</span>
    SBinaryTreeNode<span class="token operator">*</span>    m_pRight<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>画个图分析一下很简单：递归前序遍历，交换每个非叶节点的左右两个子节点。</p>
<p>完整代码如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>用循环实现的话代码如下（需要借助栈）：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h1 id="面试题28：对称的二叉树"><a href="#面试题28：对称的二叉树" class="headerlink" title="面试题28：对称的二叉树"></a><font size="6" color="orange">面试题28：对称的二叉树</font></h1><hr>
<p>题目：请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p>
<p>可以通过比较二叉树的前序遍历序列（先根再左再右）和对称前序遍历序列（先根再右再左）来判断二叉树是不是对称的。如果两个序列是一样的，那么二叉树就是对称的。</p>
<p>完整代码如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h1 id="面试题29：顺时针打印矩阵"><a href="#面试题29：顺时针打印矩阵" class="headerlink" title="面试题29：顺时针打印矩阵"></a><font size="6" color="orange">面试题29：顺时针打印矩阵</font></h1><hr>
<p>题目：输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。例如，如果输入如下矩阵：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token number">1</span>    <span class="token number">2</span>    <span class="token number">3</span>    <span class="token number">4</span>
<span class="token number">5</span>    <span class="token number">6</span>    <span class="token number">7</span>    <span class="token number">8</span>
<span class="token number">9</span>    <span class="token number">10</span>    <span class="token number">11</span>    <span class="token number">12</span>
<span class="token number">13</span>    <span class="token number">14</span>    <span class="token number">15</span>    <span class="token number">16</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10。</p>
<p>一圈一圈地（外层循环）打印，每次打印一圈的时候都是从左到右、从上到下、从右到左再从下到上（4个内层循环）。需要注意的是，如果只有一行、一列或者两行这种，可能不需要打印某一行或者某一列，要设置好内层循环的结束条件。</p>
<h1 id="面试题30：包含min函数的栈"><a href="#面试题30：包含min函数的栈" class="headerlink" title="面试题30：包含min函数的栈"></a><font size="6" color="orange">面试题30：包含min函数的栈</font></h1><hr>
<p>题目：定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的min函数。在该栈中，调用min、push及pop的时间复杂度都是O(1)。</p>
<p> 该题仅仅用一个变量来保存栈中的最小值是不行的，因为这个最小值只能记录压入的栈的元素里最小的那个值，这个值一旦被弹出栈，就无法知道当前栈中最小的元素时哪个了。<strong>可以借助一个辅助栈，每次入栈时，都把当前最小的元素压入辅助栈，出栈时也一并弹出辅助栈栈顶的元素。辅助栈栈顶一直都是最小元素</strong>。比如往栈1里压入元素3，当前最小的元素是3，将其压入辅助栈2；然后再往栈1里压入元素4，由于辅助栈里栈顶元素是3，所以栈1里最小元素还是3，所以还是把3压入辅助栈；再往栈1里压入元素2，和辅助栈栈顶比较发现最小元素是2，所以把2压入辅助栈；然后从栈1里弹出栈顶元素2，同时也从辅助栈里弹出一个元素，弹出后辅助栈栈顶元素是3，也就是说当前栈1里最小的元素是3.。</p>
<p>完整代码如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h1 id="面试题31：栈的压入、弹出序列"><a href="#面试题31：栈的压入、弹出序列" class="headerlink" title="面试题31：栈的压入、弹出序列"></a><font size="6" color="orange">面试题31：栈的压入、弹出序列</font></h1><hr>
<p>题目：输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出序列。假设压入栈的所有数字均不相等。例如，序列{1,2,3,4,5}是某栈的压栈序列，序列{4,5,3,2,1}是该压栈序列对应的一个弹出序列，但{4,3,5,1,2}就不可能是该压栈序列的弹出序列。</p>
<p>解题思路很简单：用一个栈来模拟对应的入栈和出栈即可。如果下一个弹出的数字刚好是栈顶数字，那么直接弹出；如果下一个弹出的数字不在栈顶，则把压栈序列中还没有入栈的数字压入辅助栈，直到直到把下一个需要弹出的数字压入栈顶为止；如果所有数字都压入栈后仍然没有找到下一个弹出的数字，那么该序列不可能是一个弹出序列。</p>
<p>完整代码如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h1 id="面试题32：从上到下打印二叉树"><a href="#面试题32：从上到下打印二叉树" class="headerlink" title="面试题32：从上到下打印二叉树"></a><font size="6" color="orange">面试题32：从上到下打印二叉树</font></h1><hr>
<p>题目一：不分行从上到下打印二叉树。从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。二叉树节点的定义如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> SBinaryTreeNode
<span class="token punctuation">{</span>
    <span class="token keyword">int</span>                    m_Value<span class="token punctuation">;</span>
    SBinaryTreeNode<span class="token operator">*</span>    m_pLeft<span class="token punctuation">;</span>
    SBinaryTreeNode<span class="token operator">*</span>    m_pRight<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>用队列来进行程序遍历即可：先把根节点入队列，然后每次出队列打印节点的后，把出队节点的子节点压入队列。循环直到队列为空。</p>
<p>完整代码如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>题目二：分行从上到下打印二叉树。从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p>
<p>和上题不同的是，由于需要分行，所以我们需要变量来记录每一层push了多少个节点到队列里，pop一个（打印）就减一下，减到0时就说明该层打印完了。</p>
<p>完整代码如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>题目三：之字形打印二叉树。请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p>
<p>按之字形顺序打印二叉树需要两个栈。如果当前打印的是奇数层，则先入栈左子节点再入栈右子节点到栈1里，打印时对栈1进行出栈；如果当前打印的是偶数层，则先入栈右子节点再入栈左子节点到栈2里。</p>
<p>完整代码如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h1 id="面试题33：二叉搜索树的后序遍历序列"><a href="#面试题33：二叉搜索树的后序遍历序列" class="headerlink" title="面试题33：二叉搜索树的后序遍历序列"></a><font size="6" color="orange">面试题33：二叉搜索树的后序遍历序列</font></h1><hr>
<p>题目：输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回true，否则返回false。假设输入的数组的任意两个数字都互不相同。</p>
<p>由于二叉搜索树后序遍历序列中最后一个元素是根节点的值，所以可以把整个序列分成两组，前半部分都小于根节点的值，后半部分都大于根节点的值。所以解题思路就是：序列的最后一个元素是根节点，以此把序列分成两部分，判断前半部分是不是全部都小于根节点，后半部分是不是全部都大于根节点。然后再对这两部分递归判断即可。</p>
<p>完整代码如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>如果面试题要求处理一棵二叉树的遍历序列，则可以先找到二叉树的根节点，再基于根节点把整棵树的遍历序列拆分成左子树对应的子序列和右子树对应的子序列，接下来再递归地处理这两个子序列。</p>
<h1 id="面试题34：二叉树中和为某一值的路径"><a href="#面试题34：二叉树中和为某一值的路径" class="headerlink" title="面试题34：二叉树中和为某一值的路径"></a><font size="6" color="orange">面试题34：二叉树中和为某一值的路径</font></h1><hr>
<p>题目：输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。二叉树节点的定义如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> SBinaryTreeNode
<span class="token punctuation">{</span>
    <span class="token keyword">int</span>                    m_Value<span class="token punctuation">;</span>
    SBinaryTreeNode<span class="token operator">*</span>    m_pLeft<span class="token punctuation">;</span>
    SBinaryTreeNode<span class="token operator">*</span>    m_pRight<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>解题思路：前序遍历并计算路径和即可，注意的是需要在递归遍历的同时记录路径上的节点，而且在退出函数时需要在路径上删除当前节点并减去当前节点的值。而路径节点可以用栈来保存，函数退出时出栈即可。</p>
<p>完整代码如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h1 id="面试题35：复杂链表的复制"><a href="#面试题35：复杂链表的复制" class="headerlink" title="面试题35：复杂链表的复制"></a><font size="6" color="orange">面试题35：复杂链表的复制</font></h1><hr>
<p>题目：请实现函数<code>SComplexListNode* clone(SComplexListNode* pHead)</code>，复制一个复杂链表。在复杂链表中，每个节点除了有一个<code>m_pNext</code>指针指向下一个节点，还有一个<code>m_pSibling</code>指针指向链表中的任意节点或者nullptr。节点定义如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> SComplexListNode
<span class="token punctuation">{</span>
    <span class="token keyword">int</span>                    m_Value<span class="token punctuation">;</span>
    SComplexListNode<span class="token operator">*</span>    m_pNext<span class="token punctuation">;</span>
    SComplexListNode<span class="token operator">*</span>    m_pSibling<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以先把所有节点直接复制到其后面，即原节点是A→B，复制之后变成A→A’→B→B’。同时如果A的<code>m_pSibling</code>指向B，那么复制后A’的<code>m_pSibling</code>应该指向B’。最后拆开成两条链表即可。</p>
<p>完整代码如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h1 id="面试题36：二叉搜索树与双向链表"><a href="#面试题36：二叉搜索树与双向链表" class="headerlink" title="面试题36：二叉搜索树与双向链表"></a><font size="6" color="orange">面试题36：二叉搜索树与双向链表</font></h1><hr>
<p>题目：输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。二叉树节点的定义如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> SBinaryTreeNode
<span class="token punctuation">{</span>
    <span class="token keyword">int</span>                    m_Value<span class="token punctuation">;</span>
    SBinaryTreeNode<span class="token operator">*</span>    m_pLeft<span class="token punctuation">;</span>
    SBinaryTreeNode<span class="token operator">*</span>    m_pRight<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>该题主要是用递归的思想来解决：把根节点和左子树的最右节点连在一起，再把根节点和右子树的最左节点连在一起。由于是二叉搜索树并且是排序的双向链表，所以需要用中序遍历。当遍历到根节点时，左子树已经调整为双向链表了，需要得到左子树转换的双向链表中的最后一个节点，所以在递归时除了当前节点，还需要传入另一个输入输出参数，用于记录已排序的双向链表中的最后一个节点，也用于在递归遍历右子树的时候，记录当前根节点（递归右子树的时候会一直遍历到右子树的最左节点，这时需要把这个最左节点和根节点连起来，所以就需要有一个参数保存了根节点）。所以递归函数应该声明如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">convertNode</span><span class="token punctuation">(</span>SBinaryTreeNode<span class="token operator">*</span> pNode<span class="token punctuation">,</span> SBinaryTreeNode<span class="token operator">*</span><span class="token operator">*</span> pLastNodeInList<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>第二个参数之所以要声明为双重指针，就是因为在递归遍历右子树时需要将其重置为指向当前节点（即右子树的根节点），而要改变一个函数输入指针所指向的位置，应该使用指向指针指针。第一个参数不是双重指针，是因为只需要改动到第一个指针所指向的对象的内容（即<code>p-&gt;m_pLeft=...</code>），而不是指针本身（即<code>p=...</code>）。</p>
<p>完整代码如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h1 id="面试题37：序列化二叉树"><a href="#面试题37：序列化二叉树" class="headerlink" title="面试题37：序列化二叉树"></a><font size="6" color="orange">面试题37：序列化二叉树</font></h1><hr>
<p>题目：请实现两个函数，分别用来序列化和反序列化二叉树。</p>
<p>可以使用深度遍历或者层序遍历来序列化二叉树，但是都要按照完全二叉树来序列化，即空节点nullptr也应该被序列化为一个特殊的字符，表示它代表一个空节点。这样才能反序列化出对应的二叉树。</p>
<p>完整代码如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<hr>
<p>可以看出解决上面这些复杂问题（尤其是关于树的），关键在于把一个大的问题分解成几个小问题，并递归地解决小问题。这里即是把二叉树分解成3部分：根节点、左子树和右子树。我们在处理根节点之后再分别处理它的左、右子树，这是典型的把问题递归分解然后逐个解决的过程。</p>
<hr>
<h1 id="面试题38：字符串的排列"><a href="#面试题38：字符串的排列" class="headerlink" title="面试题38：字符串的排列"></a><font size="6" color="orange">面试题38：字符串的排列</font></h1><hr>
<p>题目：输入一个字符串，打印出该字符串中字符的所有排列。例如：如数字符串abc，则打印出由字符a、b、c所能排列出来的所有字符串abc、acb、bac、bca、cab和cba。</p>
<p>考虑把这个复杂的问题分解成小的问题，我们可以把一个字符串看成由两部分组成：第一部分是它的第一个字符；第二部分是后面的所有字符。第一个字符有很多种可能的情况，即字符串中所有的字符都可能出现在第一个位置。如果从字符串中取出一个字符，求剩下的字符串，可以在原字符串中减去对应的那个字符，但是这样每次从原字符串中剔除一个字符会开辟新的空间。还有更好的方式是：把对应的字符交换到串首，然后串首地址加1就是剩下的字符串了。这样一直递归下去，每次都会让当前串首和后面的字符交换，从而会得到所有的排列情况，当递归到剩下的字符串是一个nullptr时，就说明当前字符串已经是一种排列了，打印该字符串。</p>
<p>不过需要注意的是，每次递归结束后都要把交换的字符串还原，才能进行下一次循环。（这个题其实不用递归用循环不太好做，因为字符串如果长度为3，就需要3重循环，但是字符串的长度是不固定的，导致循环很难写；可以用动态规划来做，但是需要很多额外的辅助空间来记录中间结果）。</p>
<p>完整代码如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>延伸：如果不是求字符的所有排列，而是求字符的所有组合，应该怎么办呢？比如输入abc，则它们的组合有a、b、c、ab、ac、bc、abc。而且ab和ba只能算一个组合。</p>
<p>这些组合的长度可能会1,2,…,n。所以这个问题实际上是：输入n个字符，求这n个字符能够构成多少个长度为m的组合。和之前一样，其实也可以分解成递归子问题，两部分：第一部分是第一个字符；第二部分是后面的所有字符。<strong>但是怎么保证ab和ba是相同的组合？</strong></p>
<p>还有像下列问题其实都是全排列问题：</p>
<ul>
<li>把8个数字放到正方体的8个顶点，判断有没有可能使得正方体上三组相对的面上的4个顶点的和都相等。其实这就是个全排列问题，找出满足a1+a2+a3+a4==a5+a6+a7+a8、a1+a3+a5+a7==a2+a4+a6+a8并且a1+a2+a5+a6==a3+a4+a7+a8的那些排列。</li>
<li>8皇后问题也是全排列问题。对8x8的国际象棋，设置一个a[8]的数组，每个数组的值从0~7进行全排列，然后找任意两个皇后不在同一条对象上的排列，即需要满足对于任意的两个i、j，是否有i-j==a[i]-a[j]或者j-i==a[i]-a[j]。有的话就不满足八皇后。</li>
</ul>
<p>如果面试题是按照一定要求拜访若干个数字，则可以先求出这些数字的所有排列，然后一一判断每个排列是不是满足题目给定的要求。</p>
<hr>
<p>参考文献：《剑指Offer》</p>

            </div>

            <!-- Post Comments -->
            
    <!-- 使用 DISQUS_CLICK -->
<div id="disqus-comment">
    <div id="disqus_thread"></div>

<!-- add animation -->
<style>
	.disqus_click_btn {
            line-height: 30px;
            margin: 0;
            min-width: 50px;
            padding: 0 14px;
            display: inline-block;
            font-family: "Roboto", "Helvetica", "Arial", sans-serif;
            font-size: 14px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0;
            overflow: hidden;
            will-change: box-shadow;
            transition: box-shadow .2s cubic-bezier(.4, 0, 1, 1), background-color .2s cubic-bezier(.4, 0, .2, 1), color .2s cubic-bezier(.4, 0, .2, 1);
            outline: 0;
            cursor: pointer;
            text-decoration: none;
            text-align: center;
            vertical-align: middle;
            border: 0;
            background: rgba(158, 158, 158, .2);
            box-shadow: 0 2px 2px 0 rgba(0, 0, 0, .14), 0 3px 1px -2px rgba(0, 0, 0, .2), 0 1px 5px 0 rgba(0, 0, 0, .12);
            color: #fff;
            background-color: #7EC0EE;
            text-shadow: 0
        }
</style>
	
<div class="btn_click_load" id="disqus_bt"> 
    <button class="disqus_click_btn">点击查看评论</button>
</div>

<!--
<script type="text/javascript">
$('.btn_click_load').click(function() {
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'http-miccall-tech'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    document.getElementById('disqus_bt').style.display = "none";
});
</script>
-->
<script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://yoursite.com/2019/02/12/剑指Offer4解决面试题的思路/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = 'http://yoursite.com/2019/02/12/剑指Offer4解决面试题的思路/'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
</script>

<script type="text/javascript">
    $('.btn_click_load').click(function() {  //click to load comments
        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document;
            var s = d.createElement('script');
            s.src = '//http-miccall-tech.disqus.com/embed.js';
            s.setAttribute('data-timestamp', + new Date());
            (d.head || d.body).appendChild(s);
        })();
        $('.btn_click_load').css('display','none');
    });
</script>
</div>
<style>
    #disqus-comment{
        background-color: #eee;
        padding: 2pc;
    }
</style>


        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
                <li>Design: <a href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
            </ul>
            
            	<span id="busuanzi_container_site_pv">2019总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			
        </div>
    </div>
</body>



 	
</html>
