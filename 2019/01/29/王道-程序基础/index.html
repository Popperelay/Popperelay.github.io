<!DOCTYPE HTML>
<html>

<head><meta name="generator" content="Hexo 3.9.0">
	<link rel="bookmark" type="image/x-icon" href="/img/logo_miccall.png">
	 <link rel="shortcut icon" href="/img/logo_miccall.png">
	
			
    <title>
    Elays'Blog
    </title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
	<script>
	(function(){
		if('{{ page.password }}'){
			if (prompt('请输入博客密码') !== "aaa"){
				alert('密码错误！');
				history.back();
			}
		}
	})();
	</script>
    <link rel="stylesheet" href="/css/mic_main.css">
    <link rel="stylesheet" href="/css/dropdownMenu.css">
    
    	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css">
    </noscript>
			    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<link rel="stylesheet" href="/css/prism-dark.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>
    
		
<!-- Layouts -->


<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<!--<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">-->
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/latest.js?config=TeX-MML-AM_CHTML">
</script>

<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_undefined.css">
<link rel="stylesheet" href="/css/typo.css">
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">MICCALL</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special">
            <ul class="menu links">
			<!-- Homepage  主页  --> 
			<li>
	            <a href="/" rel="nofollow">主页</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">分类</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="/categories/C/">C#</a></li><li><a class="category-link" href="/categories/C-语法/">C#语法</a></li><li><a class="category-link" href="/categories/C/">C++</a></li><li><a class="category-link" href="/categories/C语言/">C语言</a></li><li><a class="category-link" href="/categories/Graphics/">Graphics</a></li><li><a class="category-link" href="/categories/Math/">Math</a></li><li><a class="category-link" href="/categories/OpenGL/">OpenGL</a></li><li><a class="category-link" href="/categories/Unity/">Unity</a></li><li><a class="category-link" href="/categories/博客配置/">博客配置</a></li><li><a class="category-link" href="/categories/并行计算/">并行计算</a></li><li><a class="category-link" href="/categories/操作系统/">操作系统</a></li><li><a class="category-link" href="/categories/数据结构/">数据结构</a></li><li><a class="category-link" href="/categories/毕设/">毕设</a></li><li><a class="category-link" href="/categories/游戏开发/">游戏开发</a></li><li><a class="category-link" href="/categories/计算机系统/">计算机系统</a></li><li><a class="category-link" href="/categories/设计模式/">设计模式</a></li><li><a class="category-link" href="/categories/面试/">面试</a>
	                    </li></ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/gallery/" title="图库">
		                图库
		            </a>
		        </li>
		        
		        <li>
		            <a href="/tag/" title="搜索">
		                搜索
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
		            
		                <li><a href="https://github.com/miccall" class="icon fa-github"><span class="label">GitHub</span></a></li>
		            
		            
		            
		            
			</ul>
</nav>

        <div id="main">
            <div class="post_page_title_img" style="height: 25rem;background-image: url(https://github.com/Popperelay/Photos/blob/master/Photos/%E7%8E%8B%E9%81%93_%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80_BG.jpg?raw=true);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;">
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2>王道-程序基础</h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
				<!-- 目录 -->
				<p class="show-toc-btn" id="show-toc-btn" onclick="showToc();" style="display:none">
				<span class="btn-bg"></span>
				<span class="btn-text">文章导航</span>
				</p>
				<div id="toc-article" class="toc-article">
					<span id="toc-close" class="toc-close" title="隐藏导航" onclick="showBtn();">×</span>
					<strong class="toc-title">文章目录</strong>
					
			   </div>
			   <script type="text/javascript">
				function showToc(){
					var toc_article = document.getElementById("toc-article");
					var show_toc_btn = document.getElementById("show-toc-btn");
					toc_article.setAttribute("style","display:block");
					show_toc_btn.setAttribute("style","display:none");
					};
				function showBtn(){
					var toc_article = document.getElementById("toc-article");
					var show_toc_btn = document.getElementById("show-toc-btn");
					toc_article.setAttribute("style","display:none");
					show_toc_btn.setAttribute("style","display:block");
					};
			   </script>
				
                <p><font size="6" color="orange">程序设计基础及数据结构基础</font></p>
<ol>
<li>内存分区类型有：堆、栈、全局（静态）存储区、程序代码区、文字常量区。</li>
<li>全局变量和静态变量都存放在程序的全局（静态）存储区，它包括DATA段（全局初始化区）和BSS段（全局未初始化区）。其中，初始化的全局变量和静态变量存放在DATA段，未初始化的全局变量和未初始化的静态变量存放在BSS段。由于BSS段会在程序执行之前自动清0，也就是说，未初始化的全局变量与静态变量有默认初始值：0。</li>
<li>对于程序<code>char *n = &quot;hello&quot;;</code>，字符串”hello”存储于文字常量区，栈上的指针变量n指向这块内存区域；而对于<code>char a[]=&quot;hello&quot;;</code>，存在一次拷贝：文字常量区的字符串”hello”会被拷贝到栈上的数组a中（也就是说这个时候字符串”hello”拥有两份拷贝：文字常量区一份、栈上一份），a是栈上拥有6个字符元素的数组。</li>
<li>想要得到一个函数的地址，可以用：<code>&amp;func</code>，比如<code>&amp;main</code>是对main函数取址可以得到程序代码区的首地址。</li>
<li>数组引用和数组指针类似（加括号()是必须的，因为[]的优先级高于*和&amp;）：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
 <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>r<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//数组引用</span>
 <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//数组指针</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li>函数体内定义的内置类型数组，是不会被默认初始化的。但是如果显式初始化了部分元素，那其后的元素会被默认初始化为0。</li>
<li>双引号括起来的字符序列是字符串常量，C++编译器会为所有的字符串常量在末尾添加一个空字符，所以<code>&#39;A&#39;</code>表示单个字符A，而<code>&quot;A&quot;</code>表示字母A和空字符(<code>&#39;\0&#39;</code>)两个字符。</li>
<li>C风格字符末尾都有一个空字符<code>\0</code>。</li>
<li>strcpy等字符串处理函数都要求传入的字符串参数必须以空字符结尾，即<code>char ca[]={&#39;C&#39;, &#39;+&#39;, &#39;+&#39;}; cout &lt;&lt; strlen(ca) &lt;&lt; endl;</code>输出的字符长度是不可预料的，因为这些函数都是以空字符作为结束条件。</li>
<li>赋值运算符比逗号运算符优先级高，所以<code>a = ++b, c--, d+3;</code>a的最终结果是++b，而不是d+3。</li>
<li>同类型的两个指针可以相减，但不可以相加。</li>
<li>对于一个数组a：<code>int a[10];</code>，a是数组名，是指向数组中第一个元素的指针，而&amp;a指向整个数组，是一个数组指针，所以它的类型是<code>int(*)[10]</code>。</li>
<li>文字常量区是不允许被修改的，所以<code>char *p = &quot;hello&quot;; p[0]=&#39;x&#39;;</code>中第二个语句是错误的，<code>p[0]</code>是文字常量区的元素，不允许被修改。</li>
<li>数组的首地址是常量，也是不允许更改的。如<code>int a[] = { 1,2,3 }; a += 2;</code>其中的第二个语句就是错误的。</li>
<li>对于二维数组a[4][5]，因为a是数组名，是指向数组中第一个元素的指针，因为数组a[4][5]中的第一个元素是一个一维数组，所以a的类型是指向一个一维数组的指针<code>int(*)[5]</code>。又因为a[0]是一维数组的名字，所以a[0]实际上指向一个一维数组的第一个元素，所以a[0]的类型是int*，而*a和a[0]是一样的，都是一维数组的名字，所以*a的类型也是int*。</li>
<li>x86-64、x64都是指64位，而x86-32、x32都是指32位。</li>
<li>有些函数因为由ASSERT断言才在Debug版下崩溃，Release下不崩溃，比如当strcpy函数在复制时地址越界。</li>
<li>字符串匹配的KMP算法的时间复杂度是O(m+n)。原理及代码后续补上。。。。Coding…</li>
<li>判断一个字符串s2能都被字符串s1循环移位后得到的字符串包含，比如s1=AABCD，s2=CDAA，s2是s1循环移位两次后的字符串的子串。其实可以把字符串s1搞成一个循环字符串就可以了，一种方法是用数组（环形数组求模）或者链表把s1的首位两个字符连起来；另外一种做法就是把s1再复制一份追加到s1里（变成字符串s1s1），原因是在循环比较时，最多循环一轮就能得到判断结果，所以可以直接复制一份，而不用做成环形结构，这样一来用字符串匹配算法（比如KMP）来直接判断s1s1是否包含s2就可以了。</li>
<li>整数的最大值可以用0xFFFFFFFF这样的十六进制表示，也可以借助std库：<code>std::numeric_limits&lt;int&gt;::max()</code>。</li>
<li>求两个很大的正数（用字符串表示）的乘积。可以按照竖式乘法把两个正数的每一位进行两两相乘，将得到的结果保存到一个int数组里，值得注意的是用的是int数组而不是char数组来保存位相乘的结果，因为用int来表示位相乘的结果可以知道是否发生了进位，最后从右到左算一次进位就可以了。Coding…</li>
<li>对于字符串删除问题，比如在”welcome to asted”中删除模式串”aeiou”中的字符，得到”wlcm t std”。这种题巧妙的不是在字符匹配上，而是在字符删除上，可以定义两个计数器，使用<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> 
j<span class="token operator">++</span><span class="token punctuation">;</span> 
s<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//...</span>
s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">'\0'</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
的方式来实现字符串删除功能。</li>
<li>我们常用的x86结构是小端模式，而Sun的SPARC采用大端模式。</li>
<li>printf函数在传参时，是最后一个参数先入栈。所以在小端机器上，下列程序：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> c <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d %d %d\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> 
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
 long long是8个字节，所以调用printf函数时栈里的数据是（左侧栈顶右侧栈底）：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token number">0x01000000</span> <span class="token number">0x00000000</span> <span class="token number">0x02000000</span> <span class="token number">0x00000000</span> <span class="token number">0x03000000</span> <span class="token number">0x00000000</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
因为输出格式是%d，所以每次输出的应该是4个字节，从栈顶依次出栈，所以输出的三个数应该是1 0 2。</li>
<li>sizeof的计算发生在编译时刻，所以它可以被当作常量表达式使用，并且会忽略其中括号内的各种运算，比如<code>sizeof(a++)</code>中的++无论在编译还是在运行时都不会被执行。也就是说，sizeof不仅可以对类型，也可以对一个表达式求值，编译器根据表达式的最终结果类型来确定大小，但是同样的不会对表达式进行计算。</li>
<li>对结构体中的位域成员不能计算sizeof值，不过对整个结构体还是可以用sizeof的。</li>
<li>C/C++中一个汉字占两个字节。</li>
<li>对数组<code>int a[N]</code>用sizeof求值，可以求出整个数组的字节大小，但是如果数组是作为函数参数，这个时候的数组名就已经不是数组类型，而是指针类型了，对这个数组用sizeof求值得到的将是一个指针的大小。如下：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//输出4，此时a作为函数参数，不再是表示一个数组，而只是一个数组指针</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>对于结构体的空间大小计算，遵循两个原则：</p>
<ul>
<li>结构体成员在对齐时，其前面已经占用的空间大小必须是该成员类型大小的整数倍（不过在Linux+gcc环境下最大的对齐要求是4字节对齐，比如对double类型来说不需要8字节对齐，4字节就可以了）。</li>
<li>结构体整体空间时占用空间最大的成员所占字节数的整数倍（不过在Linux+gcc环境下也是最大要求4字节补齐）。</li>
</ul>
<p>其他的一些细节，比如成员是另一个结构体b的话，该成员对齐是按照b中最大的成员大小来对齐的，而不是按照整个结构体b的大小来对齐（因为毕竟是顺序存储的，结构体成员里的成员也是一个一个挨着存储的，和展开存储区别不大）。</p>
<p>同样的，在结构体中，数组是按照单个变量一个一个进行摆放，而不是视为整体，所以对齐时按一个一个的单独的变量来对齐就可以了。</p>
</li>
<li>使用伪指令<code>#pragma pack(n)</code>时，结构体成员的对齐是取原有的对齐大小和n之间的较小值，即offsetof(item) = min(n, sizeof(item))。</li>
<li>空结构体（不含数据成员）的字节大小不为0，而是1。</li>
<li>Union也需要和结构体一样考虑数据对齐，但是它没有成员对齐，只有整体补齐，即整个union的大小需要是最大成员的整数倍。比如下面的Union：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">union</span> UData
<span class="token punctuation">{</span>
    <span class="token keyword">char</span> b<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> bh<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
这个Union的大小就是12字节，而非9字节或者8字节。</li>
<li><p>枚举类型都是当作int类型存储的，所以枚举类型的sizeof值都为4。对于如下结构体：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> SWeekDay
<span class="token punctuation">{</span>
    <span class="token keyword">enum</span> EWeek
    <span class="token punctuation">{</span>
        sun<span class="token punctuation">,</span>
        mon<span class="token punctuation">,</span>
        tue
    <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//today1;</span>

    <span class="token keyword">enum</span> EDay
    <span class="token punctuation">{</span>
        morning<span class="token punctuation">,</span>
        moon<span class="token punctuation">,</span>
        aftermoon
    <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//today2;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>它的大小是1。因为它实际上是一个空结构体，里面只有枚举的声明，而没有定义变量。如果去掉注释，整个结构体大小就变成了8。</p>
</li>
<li>对于如下程序<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> d<span class="token punctuation">;</span>
a <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
b <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
c <span class="token operator">=</span> <span class="token punctuation">(</span>a<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>a<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>a<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
d <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">++</span>b<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token operator">++</span>b<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token operator">++</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d %d %d %d\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
在VS中输出结果是8 8 15 24，但是在VC++6.0以及gcc下输出结果是8 8 15 22。对于c的计算，都是先计算括号外面的加法，再计算括号里面的后缀自加运算符，所以c是3个5相加的结果，a最终是8；对于d的计算，在VS下是先计算括号里的前缀自加运算符，再计算括号外的加法，所以d是3个8相加的结果，但是在VC++6.0以及gcc下是这样来计算的：<code>d = ((++b) + (++b)) + (++b);</code>，即先计算前两个自加运算符，b变为7，再执行第一个加法运算符d的结果变成14，再执行最后一个自加运算符，b变为8，再和之前d的结果14相加，最终得到d为22。</li>
<li>前缀自加或自减运算符返回的是对象本身，但是后缀形式返回的是一个临时变量（即右值），不可以当作左值来使用：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
a<span class="token operator">++</span> <span class="token operator">=</span> b<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//编译错误，a++返回的是一个临时变量，不是可修改的左值</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p>给定一个整数n，判断它是否是2的正整数次幂？也就是说n的二进制应该是<code>100...00</code>的形式，那么我们只需要判断n的二进制里只有一个1且在最左边就可以了，最直接的方法当然就是先判断n的二进制有多少位，比如4位，那么可以判断n和1000是否相等就可以了。但是这种方法需要先求一次log才能知道n有多少位，还有另外一种方法：用<code>n&amp;(n-1)</code>会将n中最右边的1变成0，所以我们可以通过<code>(n&gt;1 &amp;&amp; (n &amp; (n-1))==0)</code>来判断n是否是2的正整数次幂。</p>
<p>我们还可以循环使用<code>n&amp;(n-1)</code>来判断n的二进制序列中有多少个1：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//计算n的二进制序列中1的个数</span>
<span class="token keyword">int</span> <span class="token function">countNumofOne</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> Count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>n <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        n <span class="token operator">=</span> n<span class="token operator">&amp;</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">++</span>Count<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> Count<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>异或运算符有两个很重要的性质：</p>
<ul>
<li>相同的数异或的结果是0，即<code>a^a=0</code></li>
<li>任何数和0异或的结果还是这个数，即<code>a^0=a</code>（0不变性）<br>通常用这两个性质来寻找数成对出现时缺失的某一个数，比如<code>A^B^C^D^A^C^B=D</code>，可以快速找到D只出现了一次，其余的都是成对出现。</li>
</ul>
<p>相似的性质还有或的0不变性，即<code>a|0=a</code>；与的1不变性，即<code>a&amp;(-1)=a</code>或<code>a&amp;(~0)=a</code>。</p>
<p>所以下题：有一个有n-1个整数组成的未排序的序列，其元素都是1到n中的不同的整数，请写出一个寻找序列中缺失整数的线性时间算法。<br>我们可以给这n-1个数的序列再加上1到n的n个数，组成新的序列，然后对这个新的序列求异或，得到的最终结果就是原序列在1到n中缺失的那个数。</p>
</li>
<li>我们还可以使用异或来交换两个变量的值：<pre class="line-numbers language-cpp"><code class="language-cpp">a <span class="token operator">=</span> a <span class="token operator">^</span> b<span class="token punctuation">;</span>
b <span class="token operator">=</span> a <span class="token operator">^</span> b<span class="token punctuation">;</span>
a <span class="token operator">=</span> a <span class="token operator">^</span> b<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
这里用的其实就是异或的可结合性以及0不变性，上面的代码其实可以理解为：<pre class="line-numbers language-cpp"><code class="language-cpp">a <span class="token operator">=</span> a <span class="token operator">^</span> b<span class="token punctuation">;</span>
b <span class="token operator">=</span> a <span class="token operator">^</span> b <span class="token operator">^</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span>
a <span class="token operator">=</span> a <span class="token operator">^</span> b <span class="token operator">^</span> a <span class="token operator">=</span> b<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li>如果规定不能使用运算符来实现两个数的加法，那么我们还可以通过异或操作和与操作来实现加法运算。类比十进制加法，对于二进制加法，当没有进位时1+1=0,1+0=1，0+1=1,0+0=0，这很类似异或的结果，所以我们可以通过对两个数求异或来得到不考虑进位时的加法结果SumWithoutCarry ；而什么时候会产生进位呢？只有1+1的时候才会产生进位1，其他的1+0、0+1、0+0都不会产生进位，即进位为0。所以我们可以通过对两个数求与操作再左移一位来得到进位的结果carry，然后把SumWithoutCarry 和carry加在一起就是最终的，由于不能使用加法，所以我们再对SumWithoutCarry 和carry这两个数递归调用当前的加法函数就可以了：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">addWithoutPlusOperator</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">//递归结束条件：没有进位时结束递归</span>
        <span class="token keyword">return</span> a<span class="token punctuation">;</span>
    <span class="token keyword">int</span> SumWithoutCarry <span class="token operator">=</span> a<span class="token operator">^</span>b<span class="token punctuation">;</span>
    <span class="token keyword">int</span> Carry <span class="token operator">=</span> <span class="token punctuation">(</span>a <span class="token operator">&amp;</span> b<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">addWithoutPlusOperator</span><span class="token punctuation">(</span>SumWithoutCarry<span class="token punctuation">,</span> Carry<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>既然都可以使用位操作来实现两个数的加法了，那么扩展一下，也可以使用位操作来求两个数的平均数。只需要在上题的基础上，分别对不考虑进位时的SumWithoutCarry和进位结果Carry分别除以2就可以了，除以2可以用右移一位来代替，所以就是<code>(a^b)&gt;&gt;1+(a&amp;b)</code>，代码可以套用上题的，很简单不赘述了。</li>
<li>将一个整数n的二进制序列中第i位到第j为替换为整数m所表示的序列（m的长度是j-i且小于n的二进制位数）。比如Input：N=10000000000，M=10101，i=2，j=6；Output：10001010100。<br>其实关键在于把n的第i位到第j位搞成0，再和m左移i位之后的结果做或操作就额可以成功换掉了，主要原理还是或的0不变性<code>a | 0 = a</code>。代码如下：<br><code>`</code>cpp<br>//将n的二进制序列中的第i位到第j位替换为m所表示的二进制序列<br>int replaceBits(int n, int m, int i, int j)<br>{<pre><code>int AllOne = ~0;
int RemainedRight = (1 &lt;&lt; i) - 1;
int RemainedLeft = AllOne - ((1 &lt;&lt; j + 1) - 1);
int Mask = RemainedLeft | RemainedRight;
return (n&amp;Mask) | (m &lt;&lt; i);
</code></pre>}</li>
</ol>
<pre><code>int main()
{
    std::bitset&lt;7&gt; n(&quot;1101010&quot;);
    std::bitset&lt;3&gt; m(&quot;111&quot;);
    int i = 2, j = 4;
    std::cout &lt;&lt; &quot;n:\t&quot; &lt;&lt; n.to_string() &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;m:\t&quot; &lt;&lt; m.to_string() &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;i: &quot; &lt;&lt; i &lt;&lt; &quot;\tj: &quot; &lt;&lt; j &lt;&lt; std::endl;
    int ReplacedN = replaceBits(n.to_ulong(), m.to_ulong(), i, j);
    std::cout &lt;&lt; &quot;re n:\t&quot; &lt;&lt; std::bitset&lt;7&gt;(ReplacedN) &lt;&lt; std::endl;

    return 0; 
}
```
程序输出如下：
```cpp
n:        1101010
m :          111
i : 2     j : 4
re n :    1111110
```
</code></pre><ol start="42">
<li>题：将一个整数n的奇偶位互换。使用1010…10的序列和0101…01的序列来分别提出整数n中的偶数位和奇数位，然后对提出来的偶数位右移1位，对提出来的奇数位左移1位，再将两者做或操作就能实现奇偶互换了（左移右移过程中移掉的都是0，所以不用担心把1移没了）。<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//将n的奇数位和偶数位互换</span>
<span class="token keyword">int</span> <span class="token function">swapOddEvenBits</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token operator">&amp;</span> <span class="token number">0xaaaaaaaa</span><span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token operator">&amp;</span> <span class="token number">0x55555555</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>~运算符的优先级&gt;移位运算符的优先级&gt;与、或、异或运算符的优先级。比如a=6, b=4，那么a^b&lt;&lt;2中会先算移位再算异或，所以结果是22。</li>
<li>整型提升：在表达式计算中，C++会将bool、char、unsigned char、signed char、short、signed short等等小于4字节的类型自动转换成int型。比如<code>signed char a = 0xe0; unsigned char c=a;</code>，这时判断<code>a==c</code>会发现它两是不等的，这是因为在<code>a==c</code>这个表达式中a、c都会被自动进行整型提升变成int，a会变成0xffffffe0，c会变成0x000000e0，所以a是不等于c的。</li>
<li>对于大于4字节的类型，提升次序如下：int →unsigned int→long→unsigned long→float→double→long double。可以看出有符号数和无符号数同时出现在表达式中时，有符号数会被转换成无符号数。</li>
<li>运算符优先级有几个简单的规则：<ul>
<li>扩号、下标、-&gt;和.（成员）运算符的优先级最高</li>
<li>单目的比双目的高；算术双目的比其他双目的高</li>
<li>移位运算高于关系运算；关系运算高于按位运算（与、或、异或）；按位运算高于逻辑运算</li>
<li>三目的只有一个条件运算，低于逻辑运算</li>
<li>赋值运算仅比“,”高，且从右向左结合。</li>
</ul>
</li>
<li>取两个数的最小值，用位运算来做的话是：<code>y^((x^y)&amp;-(x&lt;y))</code>，按x\&lt;y和x>=y来分别讨论并利用异或运算的可结合性来化简这条语句就明白了。</li>
<li>float值与0值比较的if语句：<code>if(x &gt; -0.000001 &amp;&amp; x &lt; 0.000001)</code>，之所以是0.000001是因为float型只能保证6位有效数字，double能保证10位有效数字。</li>
<li>宏定义不分配内存，变量定义才会分配内存。</li>
<li>宏替换不占运行时间，只占编译时间，函数调用占运行时间。</li>
<li><p>对于如下程序：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> Count <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> Count <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>Count <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">//这个Count是main函数里的Count</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">extern</span> <span class="token keyword">int</span> Count<span class="token punctuation">;</span>
        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> Count <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//输出3，而不是4，这个Count是全局变量的那个Count，因为上一个语句里使用了extern声明来扩展了其作用域</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>所有未加static前缀的全局变量和函数都具有全局可见性，其他的源文件也能访问；如果加了static，就会对其他源文件隐藏。static函数只在当前源文件中访问，普通函数在其他文件中都可访问到。</li>
<li>static（静态）局部变量的生存期虽然为整个源程序，但是其作用域仍与局部变量相同，即只能在定义该变量的函数内使用该变量。退出该函数后，尽管该变量还继续存在，但不能使用它。</li>
<li>C++标准规定，在同一个访问块即private、public、protected等区段中，成员的排列只需符合较晚出现的成员在类对象中有较高的地址即可。也就是说，并不一定要连续排列。什么东西可能会介于被声明的成员之间呢？比如说成员的字节对齐时需要填充的一些字节等。</li>
<li>因为static成员不是任何对象的组成部分，所以static成员函数不能被声明为const。static成员函数也不能被声明为虚函数、volatile。</li>
<li>在全局作用域里定义的非const变量，它在整个程序中都可以访问，但是在全局作用域里定义的const变量，只能在其所在的源文件里访问，不能被其他文件访问到。其他文件想要访问的话，需要再定义const对象的同时加上extern，其他文件访问时也需要加上extern：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//file1.cpp</span>
<span class="token keyword">extern</span> <span class="token keyword">const</span> <span class="token keyword">int</span> g_Counter <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//定义g_Counter</span>
<span class="token comment" spellcheck="true">//file2.cpp</span>
<span class="token keyword">extern</span> <span class="token keyword">const</span> <span class="token keyword">int</span> g_Counter<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//使用file1中的g_Counter</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
需要注意的是定义和声明的时候都要加上extern，否则会报无法解析外部符号的链接错误。这是对于const变量来说的，对于非const变量，在file1中定义时可以不加extern，也可以加上（所以编码的时候养成对非静态全局变量加上extern的习惯）。</li>
<li>在gcc下临时变量是被当作常量的。比如<code>string f(); void g(string&amp; vioStr);</code>，当调用<code>g(f());</code>时在gcc下会报错，因为它把f返回的临时变量看作常量，导致发送常量转换成非常量的错误，不过在VS下临时变量不会被当作常量，所以不会编译报错。</li>
<li>对于下列函数：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">getMemory</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> p<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
这个函数是达不到给p分配内存的效果的（暂时不考虑内存泄漏），因为p本身是一个变量，p的值就是一个地址，使用<code>p=new char[100];</code>只是给p换了一个值，但是这个值是无法传到函数外的，函数退出后，p还是会恢复原值（因为把p当作一个变量来看的话这个参数实际上是值传递而不是址传递），想要达到正确的效果，需要用双重指针或者引用指针：<br>`cpp<br>void getMemory(char** p)<br>{<pre><code>*p = new char[100];
</code></pre>}<pre><code>或者
```cpp
void getMemory(char*&amp; p)
{
    p = new char[100];
}
</code></pre></li>
<li>下列程序（出自2011年网易游戏）：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//数组未初始化</span>
<span class="token keyword">int</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//数组每个元素都被初始化为0</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li>malloc和new的区别：<ul>
<li>malloc与free是C/C++语言的标准库函数，new/delete是C++的运算符，所以malloc/free需要库文件支持，new/delete不需要；</li>
<li>new自动计算需要分配的空间，而malloc需要手动计算字节数；</li>
<li>new是类型安全的，而malloc不是。比如：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span><span class="token operator">*</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">float</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//编译时指出错误</span>
<span class="token keyword">int</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//编译时无法指出错误</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li>new调用operator new分配足够的空间，并调用相关对象的构造函数，而malloc不能调用构造函数；delete将调用该实例的析构函数，然后调用类的operator delete，以释放该实例占用的空间，而free不能调用析构函数；</li>
</ul>
</li>
<li>如何减少频繁分配内存（malloc或者new）造成的内存碎片？<br>可以使用内存池（Memory Pool），它是一种内存分配方式。通常我们习惯直接使用new、malloc等申请内存，这样做的缺点在于：由于所申请内存块的大小不定，当频繁使用时会造成大量的内存碎片并进而降低性能。内存池则是在真正使用内存之前，先申请分配一定数量的、大小相等（一般情况下）的内存块留作备用（通常是连续的比较大的内存）。当有新的内存需求时，就从内存池中分出一部分内存块，若内存块不够再继续申请新的内存。这样做的一个显著优点是尽量避免了内存碎片，使得内存分配效率得到提升。</li>
<li>什么是缓冲区溢出？<br>缓冲区溢出是指向缓冲区内填充数据位数超过了缓冲区本身的容量限制，导致溢出的数据覆盖在合法数据上的情况。理想的情况是程序检查数据长度并不允许输入超过缓冲区长度的字符。</li>
<li>宏定义与内联函数的区别：首先，宏定义是在预处理阶段进行代码替换，而内联函数是在编译阶段插入代码；其次，宏定义没有类型检查，而内联函数有类型检查。</li>
<li>对于如下模板函数：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
T <span class="token function">add</span><span class="token punctuation">(</span>T x<span class="token punctuation">,</span> T y<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
调用<code>add(5.2, 2);</code>时会报错，因为编译器无法推断出T是整型还是浮点型，为了编译通过我们可以显式指定模板类型：<code>add&lt;float&gt;(5.2, 5);</code></li>
<li>对于如下程序：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
A <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//对象a的正确定义应该是A a;这里编译器会把a当作一个函数声明</span>
a<span class="token punctuation">.</span><span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//报错</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
编译器实际上报错的是在最后一行，而不是它的上一行，因为编译器把a当作了一个函数声明，所以对一个函数名使用”.”运算符肯定是会报错的。</li>
<li>被调用的函数一定要在调用之前进行定义，这句话是错的，不是定义，而应该是声明。</li>
<li><p>在C++程序中调用被C编译器编译后的函数，为什么要加“extern C”？<br>  C++语言是一种面向对象的编程语言，为了支持重载机制，在编译生成的汇编码中，要对函数的名字进行一些处理，加入比如函数的返回类型等信息。而在C语言中，只是简单的函数名字而已，不会加入其它的信息，也就是说：C++和C语言对产生的函数名字的处理时不一样的。这样在链接阶段若是按照C++的函数名规则去查找C编译器编译的函数，就会出现链接错误。所以extern “C”是在告诉编译器该函数是用C编译器编译的，请用C的方式来链接它们，从而解决了此问题。</p>
<p>用法是在声明函数时，前面加上<code>extern &quot;C&quot;</code>：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">extern</span> <span class="token string">"C"</span> <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><code>*p++</code>和<code>(*p)++</code>是不等价的，运算符*的优先级比++高，<code>*p++</code>先做取值操作，然后对p所表示的指针地址执行++操作；而<code>(*p)++</code>是先做取值操作，然后对取出来的值进行++操作。也就是说<code>*p++</code>中++执行的对象依然是<code>p</code>，而不是<code>*p</code>，和运算符的优先级无关。</li>
<li><code>typedef char* String_t;</code>和<code>#define String_d char*</code>在使用上有什么区别？<br>前者声明一个类型的别名，在编译时处理，有类型检查；后者是一个简单的替换，在预编译时处理，无类型检查。从使用上来说，<code>String_t a, b;</code>中a和b都是<code>char*</code>类型的，但是<code>String_d a, b;</code>中只有a是<code>char*</code>类型的，b是char类型的。</li>
<li>如下程序：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">typedef</span> std<span class="token operator">::</span>string<span class="token operator">*</span> pString<span class="token punctuation">;</span>
<span class="token keyword">const</span> pString cstr<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
那么<code>cstr</code>是什么类型？答案是它是一个常量指针，即等效于<code>string *const cstr</code>，而不是指针常量，即<code>const string* cstr</code>。这是因为const实际上修饰的是<code>pString</code>类型，这是一个指针，所以声明的是一个指向string类型的const指针。</li>
<li>对于数组<code>double* (*a)[3][6];</code>，<code>*a</code>实际上是一个二维数组的名字，而这个数组中的每个元素都是double型指针，所以对<code>*a</code>作sizeof操作的结果是：<code>sizeof(*a)=72</code>。</li>
<li><p>函数也可以返回指向函数的指针，不过写起来有点麻烦：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这是声明了一个函数f，它带有一个int型的形参，它的返回类型是<code>int(*)(int, int)</code>。</p>
<p>当然使用typedef或using会简单易懂很多：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span>PF<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//using PF = int(*)(int, int);</span>
PF <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li>如果不是给函数指针起的别名，而是给函数起的别名，如下：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">int</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//函数别名</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
这个函数别名在被作为参数传递时可以自动隐式转换为对应的函数指针，但是在被作为返回类型时，是无法自动转换成指针的：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span>  <span class="token function">f1</span><span class="token punctuation">(</span>func p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//正确，func被隐式转换为对应的函数指针</span>
func  <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//错误，func作为返回类型时不能转换为指针</span>
func<span class="token operator">*</span> <span class="token function">f3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//正确</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li>引用和指针的区别：<ul>
<li>引用不能为空，当引用被创建时，它必须被初始化。而指针可以为空值，可以在任何时候被初始化，但是不可能有null引用。</li>
<li>一旦一个引用被初始化指向一个对象，它就不能改变为对另一个对象的引用。指针则可以在任何时候指向另一个对象。</li>
<li>sizeof(引用)得到的是所指向的对象的大小，而sizeof(指针)得到的是指针本身的大小。</li>
<li>引用使用时不需要解引用，而指针需要，它俩对++操作的运算意义也不一样。</li>
<li>如果返回动态分配的对象或内存，必须使用指针，引用可能引起内存泄漏。</li>
<li>当使用&amp;运算符来操作引用是，得到的所指向的对象的地址；而对指针使用&amp;运算符，得到的指针变量的地址。</li>
</ul>
</li>
<li>引用类型的数据成员不能直接在构造函数体里初始化，需要用到初始化列表，或者直接在声明的时候一起定义。</li>
<li>什么是野指针？野指针是指向不可用内存的指针（可能是指针没有被初始化，指向的地方是随机，也有可能是delete掉后没有被置位null导致它指向了不正确的内存，或者指针越界也会导致它指向不正确的内存，这些情况都统称它为野指针）。</li>
<li>在调用成员函数时，形参this初始化为调用函数的对象的地址。</li>
<li>对于类里的成员变量，如果它是内置类型，那么其初始值依赖于对象的作用域：如果类对象在局部作用域里，那么这些内置成员变量不会被初始化，是一个随机值；如果在全局作用域里，它们会被初始化为0（BSS全局未初始化区）。</li>
<li>对于类类型的数据成员，若未在初始化列表显示初始化，而是在函数体里赋值，则相当于先调用类的默认构造函数进行初始化，再在函数体中赋值，所以相比于直接利用初始化列表，它的效率较低。</li>
<li>const类型的成员变量和引用类型的成员变量，都必须在构造函数初始化列表中进行初始化（或者直接在声明时进行初始化）。</li>
<li>为什么拷贝构造函数的参数是一个引用，如下：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token function">CData</span><span class="token punctuation">(</span><span class="token keyword">const</span> CData<span class="token operator">&amp;</span> vData<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
如果不是引用的话，在参数传进来的时候是传值的方式，就会调用该类的拷贝构造函数，从而造成无穷递归地调用拷贝构造函数，所以拷贝构造函数的参数必须是一个引用。</li>
<li>当类B从类A继承而来，而类A的析构函数不是虚函数，就会发生什么？<br>当基类指针pA指向用new出来的派生类对象B时，如果delete基类指针，只会运行基类的构造函数，而不会执行派生类的析构函数，派生类部分没有释放掉从而造成释放不彻底现象。</li>
<li><p>对于类中的成员变量，会按照成员在类中声明次序来顺序构造成员，所以在析构时，会按照声明次序来逆序撤销成员（构造和析构的顺序必然是对称 的）。其实对于函数中声明的对象也是这样的，比如：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    A a<span class="token punctuation">;</span>
    B b<span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在main函数退出时，也是先析构b再析构a。</p>
</li>
<li>派生时，构造函数和析构函数、赋值运算符等等关于拷贝操作的函数都是不能继承的。</li>
<li>不能重载的运算符有4个：<code>::</code>、<code>?:</code>、<code>.</code>、<code>.*</code>，可以简记为带“点”的都不能重载。</li>
<li><p>赋值运算符的返回值应该是引用类型，如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">CData<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> CData<span class="token operator">&amp;</span> vData<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> <span class="token operator">&amp;</span>vData<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> m_pData<span class="token punctuation">;</span>
    m_pData <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
    m_pData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token function">strlen</span><span class="token punctuation">(</span>vData<span class="token punctuation">.</span>m_pData<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token function">strcpy</span><span class="token punctuation">(</span>m_pData<span class="token punctuation">,</span> vData<span class="token punctuation">.</span>m_pData<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>之所以会返回类类型，是为了让=运算可以进行连等操作。那为什么需要是引用呢？这是因为加了&amp;后可以少一次复制（从=运算符退出的时候不用先拷贝到一个临时变量里），而且如果不用&amp;，<code>(DataA = DataB) = DataC;</code>这样的对象连等会达不到效果，A的值不会和C一样（因为括号外面的那次=操作，实际上左操作符是一个临时变量而不是对象DataA）。</p>
<p>还需要注意的是，在重载=运算符的时候，应该首先判断传入的参数的地址是不是恰好等于this，这是因为如果类里有指针成员，需要先delete掉指针成员（防止内存泄漏），再访问参数对象里的指针，如果传入参数恰好等于this，直接delete掉的话后面就无法正确访问参数里面的这个指针所指向的内存了。</p>
</li>
<li>并不是出现=运算符就是调用赋值构造函数，如下：<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>string <span class="token function">Str1</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Str2<span class="token punctuation">;</span>
Str2 <span class="token operator">=</span> Str1<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//调用赋值运算符</span>
std<span class="token operator">::</span>string Str3 <span class="token operator">=</span> Str1<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//调用拷贝构造函数，不调用赋值运算符</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
如果使用=运算符后有新的对象产生，那就是调用的拷贝构造函数，否则就是调用的赋值运算符。</li>
<li>对于输出运算符”&lt;&lt;”的重载，返回类型需要是<code>ostream&amp;</code>，因为从内存输出到流会改变流的状态（从流输入到内存也会改变流的状态），所以不能是const，之所以要是引用，是因为ostream对象不能复制（它的拷贝构造函数的访问权限不是public）。</li>
<li><p>new的执行过程是：首先，调用名为operator new的标准库函数，分配足够大的原始未类型化的内存，以保存指定类型的一个对象；然后运行该类型的一个构造函数来构造对象；最后返回指向新分配并构造的对象的指针（可以看出内存分配和对象构造是分开的）。</p>
<p>delete的执行过程是：首先，对指针指向的对象运行析构函数，然后调用名为operator delete的标准库函数来释放该对象所用内存。</p>
<p>其中，operator new和operator delete是可以被重载的（它俩都是static函数）。</p>
</li>
<li>如何限制栈对象的生成？如何限制堆对象的生成？（网易）<br>限制栈对象的生成，可以把类的构造函数设为私有的，这样就不能在栈中生成对应对象了。而限制堆对象的生成，可以把operator new和operator delete重载为私有的。</li>
<li><p>成员函数的重载是同一个类中出现同名的成员函数，它和普通函数的重载是完全一致的，和成员函数是否是虚函数无关。</p>
<p> 成员函数的覆盖是：在派生类中覆盖基类中的同名函数，要求基类函数必须是虚函数。</p>
<p>成员函数的隐藏是：派生类中的函数屏蔽了基类中的同名函数（基类的该函数不是虚函数，这也是它和覆盖的区别）。</p>
<p>重载和覆盖的区别是：</p>
<ul>
<li>覆盖是子类和父类之间的关系，是垂直关系；而重载是同一个类中不同方法之间的关系，是水平关系；</li>
<li>覆盖要求参数列表相同，而重载要求参数列表不同；覆盖要求返回类型相同，重载则不要求；</li>
<li>覆盖关系中，调用方法体是根据对象的类型来决定的，而重载关系中是根据调用时的实参表与形参表来选择方法体的。</li>
</ul>
</li>
<li><p>可以定义类型转换函数来将一个类类型转换成另一个类型（比如内置类型）。如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">CData</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">operator</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//类型转换函数</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> m_IntData<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span> m_IntData <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>定义类型转换函数，需要注意以下几点：</p>
<ul>
<li>转换函数必须是成员函数，不能是友元形式；</li>
<li>转换函数不能指定返回类型，但在函数体内必须用return语句以传值方式返回一个目标类型的变量；</li>
<li>转换函数不能有参数。</li>
</ul>
</li>
<li><p>多态性是指同一个操作作用于不同的对象就会产生不通过的响应。多态性分为静态多态性和动态多态性，其中函数重载和运算符重载属于静态多态性，虚函数属于动态动态性。</p>
</li>
<li>虚函数是不可以内联的。</li>
<li>基类指针调用虚函数时，使用的是基类的默认实参，与动态绑定的对象没有关系，因为默认实参是编译时确定的。</li>
<li>编译器将对象的类型视为在构造或析构期间发生了变化，也就是说，运行构造函数或析构函数时，对象都是不完整的。所以在基类构造函数或析构函数中，会将派生类对象当作基类对象对待。如果在构造函数或析构函数中调用虚函数，运行的是为构造函数或析构函数自身类型定义的版本。</li>
<li>在C++对象模型中，虚函数会被如下处理：<ol>
<li>每一个含有虚函数的类都会产生出一堆指向虚函数的指针，把它们放在一个表格中，这个表格被称为虚表（virtual table）；</li>
<li>对应的每一个类对象，都会被添加一个指针，指向相关的虚表。通常这个指针被称为虚表指针（vptr）。vptr的设定和重置都由每一个类的构造函数、析构函数和复制构造函数自动完成。每一个类所关联的type_info信息（用以支持运行时类型识别，runtime type identification，RTTI）也经由虚表被指出来，通常是放在表格的第一个slot处（虚表的第一个位置）。</li>
</ol>
</li>
<li><p>对于如下程序：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"hello"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">void</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">f3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"hello"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span> a<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

A <span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
p1<span class="token operator">-</span><span class="token operator">></span><span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//运行成功，因为调用f1时不需要任何对象信息（非虚函数是静态绑定的，不存在与对象中）</span>
p1<span class="token operator">-</span><span class="token operator">></span><span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//运行失败，因为f2用到的成员变量只能存在于具体对象中</span>
p1<span class="token operator">-</span><span class="token operator">></span><span class="token function">f3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//运行失败，因为f3是虚函数，需要用到虚表指针，但是虚表指针只存在于具体对象中</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>只有调用f1的那句代码能够成功运行，后面两句都不能成功运行，因为都需要用到具体的对象。</p>
</li>
<li><p>如果有这样一个类：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"f1 function"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"f2 function"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">f3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"f3 function"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

A b<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 当我们执行<code>auto p = *((int*)*(int*)(&amp;b))</code>时，会强行把&amp;b转成<code>int*</code>，然后对其进行解引用操作<code>*(int*)(&amp;b)</code>就能得到对象中存储的第一个元素：虚表指针的值。这个虚表指针的值其实是虚表里的第一个虚函数指针的地址，所以将再次强转成<code>(int*)</code>后再做解引用操作，就能得到虚表里的第一个虚函数指针，而这个虚函数指针指向类A中的第一个虚函数f1。所以我们可以将这个虚函数指针转换成具体的函数指针（f1所代表的函数指针类型）：<code>typedef void(*Fun)(); Fun f = (Fun)*((int*)*(int*)(&amp;b));</code>，然后我们就可以通过调用f来调用对象b里的f1函数了。完整代码如下：<br><code>`</code>cpp<br>class A<br>{<br>public:</p>
<pre><code>virtual void f1() { std::cout &lt;&lt; &quot;f1 function&quot; &lt;&lt; std::endl; }
virtual void f2() { std::cout &lt;&lt; &quot;f2 function&quot; &lt;&lt; std::endl; }
virtual void f3() { std::cout &lt;&lt; &quot;f3 function&quot; &lt;&lt; std::endl; }
</code></pre><p>};</p>
</li>
</ol>
<pre><code>int main()
{
    typedef void(*Fun)();
    A b;
    Fun f = (Fun)*((int*)*(int*)(&amp;b));
    f();    //调用虚函数f1
    f = (Fun)*((int*)*(int*)(&amp;b) + 1);
    f();    //调用虚函数f2
    f = (Fun)*((int*)*(int*)(&amp;b) + 2);
    f();    //调用虚函数f3

    return 0; 
}
```
输出如下：
```cpp
f1 function
f2 function
f3 function
```
</code></pre><ol start="100">
<li>虚表里其实不只是存储了虚函数f1、f2、f3的地址（或者说不只是存储了指向三个虚函数的指针），其实还在虚表最后多加了一个结束结点，就像字符串的结束符’\0’一样，它标志了虚函数表的结束。这个结束标志的值在不同的编译器下是不同。在Windows+VS2010下，这个值是null。</li>
<li>多基继承时，有几个基类就有几个vptr（虚表指针）。</li>
<li><p>在虚拟继承下，基类不管在继承串链中被派生多少次，永远只会存在一个实体。在虚拟继承基类的子类中，子类会增加某种形式的指针，或者指向虚基类子对象（基类部分），或者指向一个相关的表格；表格中存放的不是虚基类子对象的地址，就是偏移量。该指针被称为bptr。如下程序：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">   <span class="token keyword">class</span> <span class="token class-name">X</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
   <span class="token keyword">class</span> <span class="token class-name">Y</span> <span class="token operator">:</span><span class="token keyword">public</span> <span class="token keyword">virtual</span> X <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
   <span class="token keyword">class</span> <span class="token class-name">Z</span> <span class="token operator">:</span><span class="token keyword">public</span> <span class="token keyword">virtual</span> X <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
   <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token operator">:</span><span class="token keyword">public</span> Y<span class="token punctuation">,</span> <span class="token keyword">public</span> Z <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

   <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
   <span class="token punctuation">{</span>
       std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"sizeof(X): "</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
       std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"sizeof(Y): "</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>Y<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
       std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"sizeof(Z): "</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>Z<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
       std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"sizeof(A): "</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>

       <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>  运行结果如下：  </p>
<pre class="line-numbers language-cpp"><code class="language-cpp">     <span class="token keyword">sizeof</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token number">1</span>
   <span class="token keyword">sizeof</span><span class="token punctuation">(</span>Y<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token number">4</span>
   <span class="token keyword">sizeof</span><span class="token punctuation">(</span>Z<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token number">4</span>
   <span class="token keyword">sizeof</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token number">8</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p> 类X是空类，它的大小是1个字节；类Y和Z都是虚拟继承基类X，需要在各自派生类里增加一个bptr来指向虚基类子对象（基类部分），所以类X和类Y都是4个字节。而类A需要两个bptr来分别指向基类X和基类Y的部分，所以类A的大小是8个字节。</p>
</li>
<li><p>对于如下程序：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">   <span class="token keyword">class</span> <span class="token class-name">A</span>
   <span class="token punctuation">{</span>
   <span class="token keyword">public</span><span class="token operator">:</span>
       <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
   <span class="token punctuation">}</span><span class="token punctuation">;</span>

   <span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token operator">:</span> <span class="token keyword">virtual</span> <span class="token keyword">public</span> A
   <span class="token punctuation">{</span>
   <span class="token keyword">public</span><span class="token operator">:</span>
       <span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
   <span class="token punctuation">}</span><span class="token punctuation">;</span>

   <span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token operator">:</span> <span class="token keyword">virtual</span> <span class="token keyword">public</span> A
   <span class="token punctuation">{</span>
   <span class="token keyword">public</span><span class="token operator">:</span>
       <span class="token function">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
   <span class="token punctuation">}</span><span class="token punctuation">;</span>

   <span class="token keyword">class</span> <span class="token class-name">D</span> <span class="token operator">:</span> <span class="token keyword">public</span> B<span class="token punctuation">,</span> <span class="token keyword">public</span> C
   <span class="token punctuation">{</span>
   <span class="token keyword">public</span><span class="token operator">:</span>
       <span class="token function">D</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
   <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 在D的构造函数里需要显式调用B和C的构造函数，但是它俩又都会去调用A的构造函数，那这样A的构造函数将被执行2次，就会在D中存在两份A的实体对象，显然是不对的。为了只让虚基类A的构造函数只被调用一次，需要在D的构造函数初始化列表里显式调用A的构造函数（这样A的构造函数就只会执行一次了）：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">   <span class="token keyword">class</span> <span class="token class-name">D</span> <span class="token operator">:</span> <span class="token keyword">public</span> B<span class="token punctuation">,</span> <span class="token keyword">public</span> C
   <span class="token punctuation">{</span>
   <span class="token keyword">public</span><span class="token operator">:</span>
       <span class="token function">D</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
   <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>只有当typeid的操作数是带虚函数的类类型的<strong>对象</strong>时，才返回动态类型信息。而对指针执行typeid，返回的永远是指针的静态的、编译时类型。如下程序：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">   <span class="token keyword">class</span> <span class="token class-name">A</span>
   <span class="token punctuation">{</span>
   <span class="token keyword">public</span><span class="token operator">:</span>
       <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
   <span class="token punctuation">}</span><span class="token punctuation">;</span>

   <span class="token keyword">class</span> <span class="token class-name">B</span><span class="token operator">:</span><span class="token keyword">public</span> A
   <span class="token punctuation">{</span>
   <span class="token punctuation">}</span><span class="token punctuation">;</span>

   B <span class="token operator">*</span>pB <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   A <span class="token operator">*</span>pA <span class="token operator">=</span> pB<span class="token punctuation">;</span>
   std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token keyword">typeid</span><span class="token punctuation">(</span>pB<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>pA<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//输出0</span>
   std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token keyword">typeid</span><span class="token punctuation">(</span><span class="token operator">*</span>pB<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span><span class="token operator">*</span>pA<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//输出1</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>C++基本类型的指针之间不能隐式转换，即不能使用static_cast来转换，需要用reinterpret_cast来转换：<pre class="line-numbers language-cpp"><code class="language-cpp">   <span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"Hello"</span><span class="token punctuation">;</span>
   <span class="token keyword">int</span> <span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//编译错误</span>
   <span class="token keyword">int</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> <span class="token keyword">reinterpret_cast</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//正确</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li>与其他强制类型转换不同，dynamic_cast设计运行时类型检查。dynamic_cast运行时类型检查需要运行时类型信息，而这个信息存储在类的虚函数表中，只有定义了虚函数的类才有虚函数表，没有定义虚函数的类是没有虚函数表的，对没有虚函数表的类使用dynamic_cast会导致编译错误。</li>
<li><p>如下程序（完美世界）：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">   <span class="token keyword">class</span> <span class="token class-name">A</span>
   <span class="token punctuation">{</span>
   <span class="token keyword">public</span><span class="token operator">:</span>
       <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
       <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

       <span class="token keyword">void</span> <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">memset</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
       <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"func"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>
   <span class="token punctuation">}</span><span class="token punctuation">;</span>

   <span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token operator">:</span> <span class="token keyword">public</span> A <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

   <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
   <span class="token punctuation">{</span>
       A a<span class="token punctuation">;</span>
       B b<span class="token punctuation">;</span>
       A<span class="token operator">*</span> pA0 <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>
       A<span class="token operator">*</span> pA1 <span class="token operator">=</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span>
       B<span class="token operator">*</span> pB <span class="token operator">=</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span>
       a<span class="token punctuation">.</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//运行正确，静态绑定</span>
       b<span class="token punctuation">.</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//运行正确，静态绑定</span>
       pA0<span class="token operator">-</span><span class="token operator">></span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//运行错误，虚表指针被clear掉了</span>
       pA1<span class="token operator">-</span><span class="token operator">></span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//运行正确，派生类B会重写虚表指针</span>
       pB<span class="token operator">-</span><span class="token operator">></span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//运行正确，派生类B会重写虚表指针</span>

       <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> 
   <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 第一个和第二个调用func函数的语句，是通过对象调用（是静态绑定），不需要使用vptr，所以可以正确调用，但是第三个语句会出错，因为类A的构造函数调用了clear函数，此函数会将A类对象的内存全部清0，导致vptr的信息丢失，而该语句需要用到vptr，所以会出错。但是第四、五两个调用都是通过派生类B的对象指针来调用的，在B的构造过程中，会先调用基类A的构造函数（有清空过程），然后会调用B的构造函数，此时将会重写vptr，故vptr的信息未丢失。</p>
</li>
<li><p>对于如下程序（腾讯）：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">   <span class="token keyword">class</span> <span class="token class-name">A</span>
   <span class="token punctuation">{</span>
   <span class="token keyword">public</span><span class="token operator">:</span>
       <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">fA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
   <span class="token punctuation">}</span><span class="token punctuation">;</span>

   <span class="token keyword">class</span> <span class="token class-name">B</span>
   <span class="token punctuation">{</span>
   <span class="token keyword">public</span><span class="token operator">:</span>
       <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">fB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
   <span class="token punctuation">}</span><span class="token punctuation">;</span>

   <span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token operator">:</span><span class="token keyword">public</span> A<span class="token punctuation">,</span> <span class="token keyword">public</span> B <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

   C c<span class="token punctuation">;</span>
   A <span class="token operator">*</span>pA <span class="token operator">=</span> <span class="token operator">&amp;</span>c<span class="token punctuation">;</span>
   B <span class="token operator">*</span>pB <span class="token operator">=</span> <span class="token operator">&amp;</span>c<span class="token punctuation">;</span>
   C <span class="token operator">*</span>pC <span class="token operator">=</span> <span class="token operator">&amp;</span>c<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>   在对象c里会包含A类子对象（A构造出来的部分）和B类子对象（B构造出来的部分），并且A先于B构造。所以pA、pC实际上指向的都是A类部分，但是pB实际上指向的是B类部分，所以pA和pB的取值是不同，pA和pC的取值相同。</p>
</li>
<li>动态规划就是递归的反用，即自底向上递推，或者是递归的变形优化：将递归过程中的中间结果保留下来，后续递归时先看子问题有没有被计算过了（目的是解决有些递归中会存在重复解决子问题的低效率）。</li>
<li><p>贪心算法是在每一步都求出当前的最优解（即局部最优解），来试图求出全局最优解。最小生成树、迪杰斯特拉求最短路径算法、哈夫曼树构造算法等都是贪心算法的应用。但是对于0-1背包问题：总共有三件物品，背包可容纳5磅的东西，物品1重1磅，价值60元，物品2重2磅，价值100元，物品3重3磅，价值120元。怎么才能最大化背包所装物品的价值？</p>
<p> 可以知道物品1每磅价值60元，物品2每磅价值50元，物品3每磅价值40元。如果按照贪心算法的话就要取物品1（但是最优解应该是取物品2和3，留下1）。不应该取1的原因在于这样无法将背包填满，空余的空间就降低了货物的每磅价值（根源还是在于物品重量是个离散值，如果物体是金粉，而不是金块这样一个物品只有一个固定重量的东西的话，就可以用贪心算法）。</p>
<p> 这个时候可以使用动态规划来解决0-1背包问题，即先求出背包容量较小时能获得的最大价值，然后根据背包容量较小时的结果求出背包容量较大时的结果，也就是一个递推的填表过程。原理很简单：</p>
<ul>
<li>如果当前物品的重量大于背包的容量，则显然不放入该物品</li>
<li>如果不放第n件物品，则问题转化为“将前n-1件物品放入背包中”。</li>
<li><p>如果放第n件物品，则问题转换为“将前n-1件物品放入背包剩下的空间中”</p>
<p>可以看出这其实是一个递归的思路，但是我们在实际解决问题时可以自底向上用递推的方法来解决问题。</p>
<p>还需要注意的是，在0-1背包问题中，要注意是否要求必须把背包装满（是或者不是会有一些不一样的初始值）。</p>
</li>
</ul>
</li>
<li><p>假设有一个没有头指针的单链表。一个指针指向此单链表中间的一个节点（不是第一个也不是最后一个节点），请将该结点从单链表中删除。</p>
<p>   也就是说无法访问到这个指针指向结点的前驱结点，我们就无法用传统方法来删除结点。这里其实可以狸猫换太子：我们可以把当前结点的内容和后继结点的内容交换，这样要删除的结点其实就成了后继结点，而当前结点变成了要删除结点的前驱结点，这样一来我们就可以用传统方法来删除后继结点了。</p>
</li>
<li>如果一个链表存在环，那么怎么寻找环的入口呢？<br> 这种链表环的问题可以使用快慢指针来解决。让慢指针从头结点开始每次向前走一步，而块指针每次向前走两步。如果链表中存在环，那么快慢指针一定会在环内相遇，此时块指针一定比慢指针多走了n圈（想象两个在操场上跑圈的人）。而块指针的速度实际上是慢指针的2倍，也就是说块指针走的路程是两个慢指针的路程，所以多出来的n圈的总长度，其实和慢指针从头结点到相遇结点的长度是相等的。也就是说，如果有一个慢指针a从头结点开始走，有另一个慢指针b从相遇结点开始走，那么当慢指针a又走到了相遇结点时，慢指针b也一定走了n圈到了相遇结点（因为前面说了这两个路程是相等的）。画个图就能知道，这两个慢指针a和b一定会在环的入口处相遇，然后一起在环上走一段路程才同时到达相遇结点（因为两个慢指针的速度是一样的，如果不在环入口处相遇的话，两个指针是肯定追不上的，不可能在环上的某个结点相遇）。所以方法有了：<ol>
<li>先让一个快指针（每次向前走2步）和一个慢指针（每次向前走1步）都从头结点出发向前走，然后它们一定会在环上的某个结点相遇，称为相遇结点p。</li>
<li>再让一个慢指针（每次向前走1步）重新从头结点开始出发向前走，同时让另一个慢指针（每次向前走一步）从相遇结点p开始出发向前走，当这两个慢指针相遇时，相遇的那个结点q就一定是环的入口结点。</li>
</ol>
</li>
<li><p>利用快慢指针还可以再有序链表中寻找中位数（相比于传统方法可以省去计数器变量）：快指针每次向前移动2步，慢指针每次向前移动1步，所以当快指针到达链表末尾时，慢指针到达中点（实际上如果链表中结点个数是奇数个，快指针到达的是倒数第二个结点）。</p>
<p> 其实像这种在链表中寻找第i个结点的问题都可以使用快慢指针来解决，比如寻找单向链表中的倒数第K个结点。</p>
</li>
<li><p>有两个单向链表，判断它们是否相交，若相交，找出它们的第一个公共结点。</p>
<p> 需要根据链表中是否有环来分情况讨论（所以需要先利用快慢指针来判断链表是否有环）：</p>
<ul>
<li>如果一个链表存在环，另一个不存在环，那么这两个链表是不可能相交的；</li>
<li>如果两个链表都没有环，那么我们可以看两个单向链表的末尾结点是不是同一个结点来判断它们是否相交。如果相交的话，怎么找出相交结点呢？可以先分别顺序遍历出两个链表的长度L1、L2（假设L1&gt;L2），然后让一个指针在长的链表上先走L1-L2步，再让另一个指针从短的链表上从头结点出发向前走，那么当这两个指针初次相等时，就是两个链表的相交结点。</li>
<li>如果两个链表都有环，如果相交的话那么这两个链表的环肯定是重合的（因为是单向链表，每个结点的走向只有一个）。我们可以先使用快慢指针在一个链表上找到对应的相遇结点，然后看这个相遇结点是否在另一个链表上，如果在则这两条链表肯定相交，否则不相交。那么相交结点是什么？其实相交结点有两个：两个链表的环入口点都是相交结点。所以只需要按照之前的方法找出这两个环入口结点就可以了。</li>
</ul>
</li>
<li>双链表的插入操作（在双链表中p所指的结点之后插入结点s）：<br> 核心在于：先将插入结点单向关联到链表里已有的结点上（即先修改插入结点的前驱\后继指针），再将链表里相对于插入结点而言的前驱结点和后继结点，单向关联到插入结点上。目的是为了不过早破坏原有结点的指向。<pre class="line-numbers language-cpp"><code class="language-cpp">   s<span class="token operator">-</span><span class="token operator">></span>next <span class="token operator">=</span> p<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>
   s<span class="token operator">-</span><span class="token operator">></span>prior <span class="token operator">=</span> p<span class="token punctuation">;</span>
   p<span class="token operator">-</span><span class="token operator">></span>next<span class="token operator">-</span><span class="token operator">></span>prior <span class="token operator">=</span> s<span class="token punctuation">;</span>
   p<span class="token operator">-</span><span class="token operator">></span>next <span class="token operator">=</span> s<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
 这个顺序不是唯一的，只要保证第1、3句在第4句之前就可以，否则先做第4句的话，p的后继结点就过早失效了。</li>
<li>双链表的删除操作（删除双链表中结点p的后继结点q）：<br> 删除操作很简单，没什么顺序需要注意的：<pre class="line-numbers language-cpp"><code class="language-cpp">   p<span class="token operator">-</span><span class="token operator">></span>next <span class="token operator">=</span> q<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>
   q<span class="token operator">-</span><span class="token operator">></span>next<span class="token operator">-</span><span class="token operator">></span>prior <span class="token operator">=</span> p<span class="token punctuation">;</span>
   <span class="token keyword">delete</span> q<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li>如果需要快速定位链表中的尾结点，除了记录下一个尾结点指针以外，还可以使用双向循环链表，利用头结点的前驱指针就能快速访问到尾结点。</li>
<li>中缀表达式向后缀表达式的转换有三种方法：<ul>
<li>使用两个栈来实现，一个用来存放运算符（称为运算符栈），一个用来存放转换的后缀表达式的结果（称为后缀栈）：从左至右扫描中缀表达式，遇到操作数则直接将其压入后缀栈，若遇到运算符，如果当前运算的优先级比运算符栈栈顶运算符的优先级高，则直接将当前运算符压入运算符栈，否则将运算符栈中的元素出栈压入到后缀栈中，直到当前运算符的优先级高于栈顶运算符的优先级为止，以便于可以把当前运算符压入运算符栈（注意若当前运算符是右括号”)”则不将其压入运算符栈）。如果扫描完运算符栈不为空，则将里面的所有运算符都压入后缀栈中。<ul>
<li>使用二叉树来实现。先将中缀表达式用二叉树表示出来，然后后序遍历该二叉树，就能得到对应的后缀表达式。</li>
<li>加括号法（这是比较快的手算的方法）：先按照运算符的优先级对中缀表达式加括号，比如把<code>a+(b-c)*d</code>变成<code>((a+(b*c))+(((d*e)+f)*g))</code>;再将运算符移到括号后面，变成<code>((a(bc)*)+(((de)*f)+g)*)+</code>；最后去掉括号得到<code>abc*+de*f+g*+</code>（实际手算的时候不用加那么多括号，每移一次运算符就用括号把该运算符和它涉及到的字母扩起来就可以了）。</li>
</ul>
</li>
</ul>
</li>
<li>用后缀表达式求值很简单：<br> 需要用到一个栈（称为求值栈）。从左至右扫描后缀表达式，遇到操作数则直接压入求值栈，若遇到运算符则从求值栈里弹出两个操作数按运算符求值，将得到的结果再压入求值栈中。扫描完后，栈顶存放的就是最终的运算结果。</li>
<li>什么是Catalan数？有2n个数，它们的值要么是1要么是-1，抽取出前k个数构成一个子序列，如果它们的和&gt;=0，那么就称这个子序列满足Catalan性质。那满足这个Catalan性质的子序列到底有多少个呢？这个个数就是Catalan数：Cn=C(2n,n)/(n+1)。其中Cn表示第n个Catalan数，它是前述2n个数构成的序列中，满足Catalan性质的子序列个数，而C(2n,n)就是我们曾经常见的排列组合。</li>
<li>有很多问题本质上就是Catalan数：<ul>
<li>一个栈（容量无穷大）的入栈序列为1,2,3,…,n，它对应的不同的出栈序列的个数就是Catalan数Cn。</li>
<li>有2n个人排成一行进入剧场。入场费5元。其中只有n个人有一张5元钞票，另外n人只有10元钞票，剧场无其他钞票，问有多少种方法使得只有有10元的人买票，售票处就有5元的钞票找零？Cn种。</li>
<li>一个人在她住所以北n个街区和以东n个街区处工作。每天她走2n个街区去上班。如果她不可以穿越从加到办公室的对角线，那么有多少条可能的道路？Cn种。</li>
<li>在圆上选择2n个点，将这些点成对连接起来使得所得到的n条线对不相交的方法数？Cn种。</li>
<li>给定n个结点，能构成多少种不同的二叉树？Cn种。</li>
<li>矩阵连乘：P=a1 x a2 x a3 x…x an，依据乘法结合律，不改变其顺序，只用括号表示成对的乘积，试问有几种括号化的方案？Cn种。</li>
</ul>
</li>
<li>队列是在队尾入队，队头出队。入队时队尾指针tail加1，出队时队头指针head加1。</li>
<li>树具有如下最基本的性质：<ul>
<li>树中的结点数等于所有结点的度数加1</li>
<li>度为m的树中第i层上至多有$m^{i-1}$个结点（$i\ge1$）</li>
<li>高度为h的m叉树至多有$(m^h-1)/(m-1)$个结点</li>
<li>具有n个结点的m叉树的最小高度为$\lceil log_m(n(m-1)+1) \rceil$</li>
</ul>
</li>
<li>对于完全二叉树，如果有度为1的结点，只可能有一个，且该结点只有左孩子而无右孩子。也就是说，完全二叉树中，度为1的结点数要么为0，要么为1。当总结点数为偶数时，度为1的结点数为1；当总结点数为奇数时，度为1的结点数为0。叶子结点数为：总结点数/2。</li>
<li>非空二叉树上叶子结点数等于度为2的结点数加1。</li>
<li>在含有n个结点的二叉链表中含有n+1个空链域。</li>
<li>可以借助栈，<strong>将二叉树的递归算法转换为非递归算法</strong>（很重要）。</li>
<li>对二叉排序树进行中序遍历，可以得到一个递增的有序序列。</li>
<li>如果二叉树中任意结点的左、右子树高度差的绝对值不超过1，并将这样的二叉树称为平衡二叉树（AVL树）。定义结点左子树与右子树的高度差为该结点的平衡因子，则平衡二叉树结点的平衡因子的值只可能是-1、0或1。</li>
<li>哈夫曼树构造的核心思想是：每次选出两个权值最小的结点来形成一个新的结点。</li>
<li>可变长度编码比固定长度编码好得多，其特点是对频率高的字符赋予短编码，而对频率较低的字符则赋予较长一些的编码，从而可以使平均编码长度减短，起到压缩数据的效果。哈夫曼编码是一种被广泛应用而且非常有效的数据压缩编码，它是可变长度编码。</li>
<li>如果没有一个编码是另一个编码的前缀，则称这样的编码为前缀编码。哈夫曼编码是前缀编码。</li>
<li>对于哈夫曼树的编码，是对每一个叶子结点进行编码，路径上指向左结点的边表示为0，指向右结点的边表示为1。</li>
<li>如果要求对一个字符串进行编码，并且还需要能够解码回原来的字符串，那么编码方法需要是前缀编码，而哈夫曼树可以设计出总长度最短的二进制前缀编码。</li>
<li>深度相同的情况下，满二叉树的叶子结点最多。</li>
<li>无向图的全部顶点的度之和等于边数的两倍，这是因为每条边和两个顶点相关联。</li>
<li>有向图的全部顶点的入度之和与出度之和相等并且等于边数。这是因为每条有向边都有一个起点和终点。</li>
<li>用邻接矩阵方法存储图，很容易确定图中任意两个顶点之间是否有边相连。但是，要确定图中有多少条，则必须按行、按列对每个元素进行检测，所花费的时间代价很大。</li>
<li>对于稀疏图，采用邻接表表示将极大地节省存储空间。</li>
<li>在邻接表中，给定一顶点，能很容易地找出它的所有邻边，因为只需要读取它的邻接表就可以了。在邻接矩阵中，相同的操作则需要扫描一行，花费的时间为O(n)。但是如果要确定给定的两个顶点是否存在边，则在邻接矩阵里可以立刻查到，在邻接表中则需要在相应结点对应的边表中查找另一结点，效率较低。</li>
<li>图的深度优先搜索（DFS）类似于树的<strong>前序遍历</strong>。</li>
<li>最小生成树算法：Prim（普里姆）算法、Kruskal（克鲁斯卡尔）算法（核心观点参见<a href="http://popperelay.cn/2016/09/01/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/" target="_blank" rel="noopener">这里</a>）。</li>
<li>最短路径算法：<a href="http://popperelay.cn/2016/09/01/最短路径/" target="_blank" rel="noopener">Dijkstr（迪杰斯特拉）算法</a>（用于求图中两个顶点之间最短路径，基于贪心算法）、Floyd-Warshall（弗洛伊德）算法（用于求图中每一对顶点间的最短路径，基于动态规划）。</li>
<li>拓扑排序的核心观点参见<a href="http://popperelay.cn/2016/09/09/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/" target="_blank" rel="noopener">这里</a>。</li>
<li>可以通过对数运算将一个乘法问题转换为加法问题（或者反之）。比如在一个图中两点之间可能会有很多条路径，要求出权值乘积最小的那条路径。这是一个路径上的乘法问题，可以借助对数运算$lg(AB)=lg(A)+lg(B)$，将问题转换为加法问题：求出权值的对数的和最小的那条路径，很显然可以用最短路径算法来做了。</li>
<li><p>关于排序可以参考<a href="http://popperelay.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" target="_blank" rel="noopener">这里</a>。</p>
<p> 快速排序的最坏情况发生在两个区域分别包含n-1个元素和0个元素时，这种最大程度的不对称性若发生在每一层递归上，即对应于<strong>初始排序序列基本有序或基本逆序时</strong>，就会得到最坏情况下的时间复杂度为$O(n^2)$。也就是说，快排不适用于那些一开就基本有序的序列。</p>
<p> 快速排序是一个不稳定的排序方法。</p>
<p> 把数列按照一个数分成大小两半的问题都可以使用一次快排来实现（即Partition函数），比如把数组中的大写字母与小写字母分开，就可以将字母<code>a</code>选作基准数，来做一次快排。</p>
</li>
<li>堆也支持删除和插入的操作。当删除堆顶元素时，需要先将堆的最后一个元素与堆顶元素交换，由于此时堆的性质被破坏，需对此时的根结点进行向下调整操作。对堆进行插入操作时，需要先将新结点放在堆的末端，再对这个新结点执行向上调整操作。堆排序也是不稳定的，时间复杂度为$O(nlog_2n)$。</li>
<li>求一组数中最小的k个数。可以使用快排的一次划分来解决，时间复杂度为O(n)，但是它需要一次性读入所有数据，并且需要修改输入的数组。我们也可以利用堆排序来解决此问题（它特别使用于处理海量数据）：首先读入k个数创建一个大小为k的大顶堆，然后依次读入剩余数据，如果当前数据比大顶堆的堆顶小，则用这个数替换当前堆顶，并调整堆使其保持大顶堆的性质；如果当前数据比堆顶大，那么这个数不可能是最小的k个整数之一，故可以抛弃此数。时间复杂度为O(nlogk)。</li>
<li>归并排序算法时一个稳定的排序算法。</li>
<li>合并两个排好序的链表，可以借助二路归并排序。</li>
<li>原地归并排序（不需要辅助数组即可归并）。</li>
<li>所有简单排序（时间复杂度为$O(n^2)$） 都是稳定排序，选择排序除外；所有时间复杂度为$O(nlog_2n)$的改进排序都是不稳定排序，归并排序除外。希尔排序是不稳定排序，基数排序是稳定排序。</li>
<li>比较次数与初始排列无关的是选择排序。</li>
<li>在初始序列基本有序的情况下，最优的是插入排序，此时的时间复杂度为$O(n)$，其次是冒泡排序，时间复杂度也为$O(n)$，快速排序在此时性能最差，时间复杂度为$O(n^2)$ 。</li>
<li>堆排序对初始数据集的排列顺序不敏感，在最好、最坏和平均情况下，堆排序的时间复杂度均为$O(nlog_2n)$。</li>
<li>基于比较的排序算法中，归并排序的空间复杂度最高，为$O(n)$，其次为快速排序，为$O(logn)$，其余的为$O(1)$。</li>
<li>基于比较的排序算法时间复杂度的下界（即最好的时间复杂度）是$O(nlog_2n)$，这一点在《算法导论》上有相关证明。</li>
<li>在具有n个数的序列中，折半查找的深度为$\lfloor log_2n+1\rfloor$或$\lceil log_2(n+1)\rceil$。</li>
<li>折半查找的树除了最后一层以外，剩下的一定是棵满二叉树。平均查找长度AVL就是每个叶结点到根结点路径上的结点数的总和，再除以总结点数就可以了。</li>
<li>哈希表也叫散列表（具体可参见<a href="http://popperelay.cn/2016/09/17/%E6%9F%A5%E6%89%BE/" target="_blank" rel="noopener">这里</a>）。</li>
<li>对哈希表的平均查找长度，是对每个元素往表里存放的试探次数之和，再除以总元素个数。</li>
<li><p>统计海量的电话号码的个数、以及在40亿个不重复整数中判断是否有某个数，都可以使用位图法来解决：用一个bit位来表示一个值。8位数的电话号码最大数为9999999，所以可以理解为0~9999999的数字，每个数字对应一个bit（每个数字到对应位的关系可以随之确定），大约需要12MB；unsigned int可以表示$2^{32}$个整数，这40亿个整数应该都可以用unsigned int来表示（每个数字到对应位的关系可以随之确定），所以使用位图的方法，每一位都表示一个无符号整数，需要申请$512M(512*2^{20}*8=2^{32})$内存。</p>
<p> 而如果是在2.5亿个整数中找出只出现一次的整数，可以使用位图法的变形：2-Bitmap，用两个位来表示一个数：00表示不存在，01表示出现一次，10表示出现多次。</p>
</li>
<li>数据库里建索引常用的数据结构是树。</li>
</ol>
<hr>
<p>参考文献：《王道程序员求职宝典》</p>

            </div>

            <!-- Post Comments -->
            
    <!-- 使用 DISQUS_CLICK -->
<div id="disqus-comment">
    <div id="disqus_thread"></div>

<!-- add animation -->
<style>
	.disqus_click_btn {
            line-height: 30px;
            margin: 0;
            min-width: 50px;
            padding: 0 14px;
            display: inline-block;
            font-family: "Roboto", "Helvetica", "Arial", sans-serif;
            font-size: 14px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0;
            overflow: hidden;
            will-change: box-shadow;
            transition: box-shadow .2s cubic-bezier(.4, 0, 1, 1), background-color .2s cubic-bezier(.4, 0, .2, 1), color .2s cubic-bezier(.4, 0, .2, 1);
            outline: 0;
            cursor: pointer;
            text-decoration: none;
            text-align: center;
            vertical-align: middle;
            border: 0;
            background: rgba(158, 158, 158, .2);
            box-shadow: 0 2px 2px 0 rgba(0, 0, 0, .14), 0 3px 1px -2px rgba(0, 0, 0, .2), 0 1px 5px 0 rgba(0, 0, 0, .12);
            color: #fff;
            background-color: #7EC0EE;
            text-shadow: 0
        }
</style>
	
<div class="btn_click_load" id="disqus_bt"> 
    <button class="disqus_click_btn">点击查看评论</button>
</div>

<!--
<script type="text/javascript">
$('.btn_click_load').click(function() {
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'http-miccall-tech'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    document.getElementById('disqus_bt').style.display = "none";
});
</script>
-->
<script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://yoursite.com/2019/01/29/王道-程序基础/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = 'http://yoursite.com/2019/01/29/王道-程序基础/'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
</script>

<script type="text/javascript">
    $('.btn_click_load').click(function() {  //click to load comments
        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document;
            var s = d.createElement('script');
            s.src = '//http-miccall-tech.disqus.com/embed.js';
            s.setAttribute('data-timestamp', + new Date());
            (d.head || d.body).appendChild(s);
        })();
        $('.btn_click_load').css('display','none');
    });
</script>
</div>
<style>
    #disqus-comment{
        background-color: #eee;
        padding: 2pc;
    }
</style>


        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
                <li>Design: <a href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
            </ul>
            
            	<span id="busuanzi_container_site_pv">2019总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			
        </div>
    </div>
</body>



 	
</html>
