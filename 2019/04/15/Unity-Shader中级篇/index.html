<!DOCTYPE HTML>
<html>

<head>
	<link rel="bookmark"  type="image/x-icon"  href="/img/logo_miccall.png"/>
	 <link rel="shortcut icon" href="/img/logo_miccall.png">
	
			
    <title>
    Elays'Blog
    </title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="/css/mic_main.css" />
    <link rel="stylesheet" href="/css/dropdownMenu.css" />
    
    	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css" />
    </noscript>
			    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<link rel="stylesheet" href="/css/prism-dark.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>
    
		
<!-- Layouts -->


<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<!--<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">-->
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/latest.js?config=TeX-MML-AM_CHTML" async>
</script>

<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_undefined.css" />
<link rel="stylesheet" href="/css/typo.css" />
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">MICCALL</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special" >
            <ul class="menu links" >
			<!-- Homepage  主页  --> 
			<li >
	            <a href="/" rel="nofollow">主页</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">分类</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="/categories/C/">C#</a></li><li><a class="category-link" href="/categories/C-语法/">C#语法</a></li><li><a class="category-link" href="/categories/C/">C++</a></li><li><a class="category-link" href="/categories/C语言/">C语言</a></li><li><a class="category-link" href="/categories/Math/">Math</a></li><li><a class="category-link" href="/categories/OpenGL/">OpenGL</a></li><li><a class="category-link" href="/categories/Unity/">Unity</a></li><li><a class="category-link" href="/categories/博客配置/">博客配置</a></li><li><a class="category-link" href="/categories/并行计算/">并行计算</a></li><li><a class="category-link" href="/categories/操作系统/">操作系统</a></li><li><a class="category-link" href="/categories/数据结构/">数据结构</a></li><li><a class="category-link" href="/categories/毕设/">毕设</a></li><li><a class="category-link" href="/categories/游戏开发/">游戏开发</a></li><li><a class="category-link" href="/categories/计算机图形学/">计算机图形学</a></li><li><a class="category-link" href="/categories/计算机系统/">计算机系统</a></li><li><a class="category-link" href="/categories/设计模式/">设计模式</a></li><li><a class="category-link" href="/categories/面试/">面试</a>
	                    </ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/gallery/" title="图库">
		                图库
		            </a>
		        </li>
		        
		        <li>
		            <a href="/tag/" title="搜索">
		                搜索
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
		            
		                <li><a href="https://github.com/miccall" class="icon fa-github"><span class="label">GitHub</span></a></li>
		            
		            
		            
		            
			</ul>
</nav>

        <div id="main" >
            <div class ="post_page_title_img" style="height: 25rem;background-image: url(https://github.com/Popperelay/Photos/blob/master/Photos/UnityShader%E4%B8%AD%E7%BA%A7%E7%AF%87_BG.png?raw=true);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;" >
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2 >Unity Shader中级篇</h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
				<!-- 目录 -->
				<p class="show-toc-btn" id="show-toc-btn" onclick="showToc();" style="display:none">
				<span class="btn-bg"></span>
				<span class="btn-text">文章导航</span>
				</p>
				<div id="toc-article" class="toc-article">
					<span id="toc-close" class="toc-close" title="隐藏导航" onclick="showBtn();">×</span>
					<strong class="toc-title">文章目录</strong>
					<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#第九章-更复杂的光照"><span class="toc-text">第九章 更复杂的光照</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Unity的渲染路径"><span class="toc-text">Unity的渲染路径</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#前向渲染路径"><span class="toc-text">前向渲染路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#顶点照明渲染路径"><span class="toc-text">顶点照明渲染路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#延迟渲染路径"><span class="toc-text">延迟渲染路径</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Unity的光源类型"><span class="toc-text">Unity的光源类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Unity的光照衰减"><span class="toc-text">Unity的光照衰减</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#使用衰减查找纹理来计算光源衰减"><span class="toc-text">使用衰减查找纹理来计算光源衰减</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用数学公式计算衰减"><span class="toc-text">使用数学公式计算衰减</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Unity的阴影"><span class="toc-text">Unity的阴影</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#不透明物体的阴影"><span class="toc-text">不透明物体的阴影</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#统一管理光照衰减和阴影"><span class="toc-text">统一管理光照衰减和阴影</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#透明物体的阴影"><span class="toc-text">透明物体的阴影</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第十章-高级纹理"><span class="toc-text">第十章 高级纹理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#立方体纹理"><span class="toc-text">立方体纹理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#天空盒子"><span class="toc-text">天空盒子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建用于环境映射的立方体纹理"><span class="toc-text">创建用于环境映射的立方体纹理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#反射"><span class="toc-text">反射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#折射"><span class="toc-text">折射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#菲涅尔反射"><span class="toc-text">菲涅尔反射</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#渲染纹理"><span class="toc-text">渲染纹理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#镜子效果"><span class="toc-text">镜子效果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#玻璃效果"><span class="toc-text">玻璃效果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#渲染纹理-vs-GrabPass"><span class="toc-text">渲染纹理 vs GrabPass</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#程序纹理"><span class="toc-text">程序纹理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#在Unity中实现简单的程序纹理"><span class="toc-text">在Unity中实现简单的程序纹理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Unity的程序材质"><span class="toc-text">Unity的程序材质</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第十一章-让画面动起来"><span class="toc-text">第十一章 让画面动起来</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#UnityShader中的内置变量"><span class="toc-text">UnityShader中的内置变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#纹理动画"><span class="toc-text">纹理动画</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#序列帧动画"><span class="toc-text">序列帧动画</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#滚动的背景"><span class="toc-text">滚动的背景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#顶点动画"><span class="toc-text">顶点动画</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#流动的河流"><span class="toc-text">流动的河流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#广告牌"><span class="toc-text">广告牌</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#注意事项"><span class="toc-text">注意事项</span></a></li></ol></li></ol></li></ol>
			   </div>
			   <script type="text/javascript">
				function showToc(){
					var toc_article = document.getElementById("toc-article");
					var show_toc_btn = document.getElementById("show-toc-btn");
					toc_article.setAttribute("style","display:block");
					show_toc_btn.setAttribute("style","display:none");
					};
				function showBtn(){
					var toc_article = document.getElementById("toc-article");
					var show_toc_btn = document.getElementById("show-toc-btn");
					toc_article.setAttribute("style","display:none");
					show_toc_btn.setAttribute("style","display:block");
					};
			   </script>
				
                <h1 id="第九章-更复杂的光照"><a href="#第九章-更复杂的光照" class="headerlink" title="第九章 更复杂的光照"></a><font size="6" color="orange">第九章 更复杂的光照</font></h1><hr>
<h2 id="Unity的渲染路径"><a href="#Unity的渲染路径" class="headerlink" title="Unity的渲染路径"></a><font size="5" color="red">Unity的渲染路径</font></h2><p>在Unity里，渲染路径（Rendering Path）决定了光照是如何应用到Unity Shader中的。因此，如果要和光源打交道，我们需要为每个Pass指定它所使用的渲染路径。Unity支持多种类型的渲染路径。在Unity5.0版本之前，主要有3种：前向渲染路径（Forward Rendering Path）、延迟渲染路径（Deferred Rendering Path）和顶点照明渲染路径（Vertex Lit Rendering Path）。但在Unity5.0版本之后，Unity做了很多改动，主要有两个变化：首先，顶点照明渲染路径已经被Unity抛弃（但目前仍然可以兼容之前使用了顶点照明渲染路径的Unity Shader）；其次，新的延迟渲染路径代替了原来的延迟渲染路径（同样，目标也提供了对较旧版本的兼容）。所以实际上现版本分为4中渲染路径：Forward、Deferred、Legacy Vertex Lit、Legacy Deferred。</p>
<p>可以在Camera的Rendering Path选项中设置对该相机使用哪种渲染路径。如果当前显卡不支持所选择的渲染路径，Unity会自动使用更低一级的渲染路径。例如，如果一个GPU不支持延迟渲染，那么Unity就会使用前向渲染。</p>
<p>其实每一个渲染路径中还包含一些子路径，可以在Shader的Pass中通过<code>LightMode</code>标签设置具体使用哪一个子路径。可以设置的渲染路径标签选项如下表所示：</p>
<table>
<thead>
<tr>
<th style="text-align:left">标签名</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Always</td>
<td style="text-align:left">不管使用哪种渲染路径，该Pass总是会被渲染，但不会计算任何光照</td>
</tr>
<tr>
<td style="text-align:left">ForwardBase</td>
<td style="text-align:left">用于前向渲染。该Pass会计算环境光、最终要的平行光、逐顶点/SH光源和Lightmaps</td>
</tr>
<tr>
<td style="text-align:left">ForwardAdd</td>
<td style="text-align:left">用于前向渲染。该Pass会计算额外的逐像素光源，每个Pass对应一个光源</td>
</tr>
<tr>
<td style="text-align:left">Deferred</td>
<td style="text-align:left">用于延迟渲染。该Pass会渲染G-buffer</td>
</tr>
<tr>
<td style="text-align:left">ShadowCaster</td>
<td style="text-align:left">把物体的深度信息渲染到阴影映射纹理（shadowmap）或一张深度纹理中</td>
</tr>
<tr>
<td style="text-align:left">PrepassBase</td>
<td style="text-align:left">用于遗留的延迟渲染。该Pass会渲染法线和高光反射的指数部分</td>
</tr>
<tr>
<td style="text-align:left">PrepassFinal</td>
<td style="text-align:left">用于遗留的延迟渲染。该Pass通过合并纹理、光照和自发光来渲染得到最后的颜色</td>
</tr>
<tr>
<td style="text-align:left">Vertex、VertexLMRGBM和VertexLM</td>
<td style="text-align:left">用于遗留的顶点照明渲染</td>
</tr>
</tbody>
</table>
<h3 id="前向渲染路径"><a href="#前向渲染路径" class="headerlink" title="前向渲染路径"></a><font size="4" color="green">前向渲染路径</font></h3><p>在Unity中，前向渲染路径有3中处理光照（即照亮物体）的方式：逐顶点光照、逐像素光照、球谐函数光照（Spherical Harmonics，SH）。而一个光源到底使用哪种光照方式，取决于光源类型和光源的渲染模式。光源类型是指点光源、平行光或者聚光源等等；而光源的渲染模式指的是该光源是否是重要的（Important）。这个可以在光源的Render Mode选项中设置。一旦把光源设置为Important，就表示告诉引擎对这个光源按逐像素光照来处理。</p>
<p>Unity判断光源光照方式的规则如下：</p>
<ul>
<li>场景中最亮的平行光总是按逐像素光照处理的</li>
<li>渲染模式被设置成Not Important的光源，会按逐顶点光照或者球谐光照来处理</li>
<li>渲染模式被设置成Important的光源，会按逐像素处理</li>
<li><p>如果根据以上规则得到的逐像素光源数量小于Quality Setting中设置的逐像素光源数量（Pixel Light Count），会有更多的光源以逐像素的方式进行渲染</p>
<p>从前面知道前向渲染路径支持两种子路径：ForwardBase和ForwardAdd，分别取名为Base Pass和Additional Pass。它们的标签设置以及对应的底层光照计算如下图所示：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/UnityShader%E4%B8%AD%E7%BA%A7%E7%AF%87_1.png?raw=true" alt=""><br>有以下几点需要说明：</p>
</li>
<li>可以发现在渲染设置中，我们除了设置了Pass的标签外，还使用了<code>#pragma multi_compile_fwdbase</code>这样的编译指令。这些编译指令会保证Unity可以为相应类型的Pass生成所有需要的Shader变种，这些变种会处理不同条件下的渲染逻辑，例如是否使用光照贴图、当前处理哪种光源类型、是否开启了阴影等，同时Unity也会在背后声明相关的内置变量并传递到Shader中。通俗来讲，只有分别为Bass Pass和Additional Pass使用这两个编译指令，我们才可以在相关的Pass中得到一些正确的光照变量，例如光照衰减值等。</li>
<li>Bass Pass中渲染的平行光默认是支持阴影的（如果开启了光源的阴影功能），而Additional Pass中渲染的光源在默认情况下是没有阴影效果的（即便我们在它的Light组间中设置了有阴影的Shadow Type）。不过可以在Additional Pass中使用<code>#pragma multi_compile_fwdadd_fullshadows</code>代替<code>#pragma multi_compile_fwdadd</code>编译指令，为点光源和聚光灯开启阴影效果。</li>
<li>在Additional Pass的渲染设置中，我们还开启和设置了混合模式。这是因为，我们希望每个Additional Pass可以与上一次的光照结果在帧缓存中进行叠加，从而得到最终的有多个光照的渲染效果。通常选择的混合模式是Blend One One。</li>
<li>对于前向渲染来说，一个Unity Shader通常会定义一个Base Pass（Base Pass也可以定义多次，例如需要双面渲染等情况）以及一个Additional Pass。一个Base Pass仅会执行一次（定义了多个Base Pass除外），而一个Additional Pass会根据影响该物体的其他逐像素光源的数目被多次调用，即每个逐像素光源会执行一次Additional Pass。</li>
</ul>
<p>实际上，渲染路径的设置用于告诉Unity该Pass在前向渲染路径中的位置，然后底层的渲染引擎会进行相关计算并填充一些内置变量（如_LightColor0等）。</p>
<p>对于前向渲染（即LightMode为ForwardBase或ForwardAdd）来说，下表给出了我们可以在Shader中访问到的光照变量：</p>
<table>
<thead>
<tr>
<th style="text-align:left">名称</th>
<th style="text-align:left">类型</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">_LightColor0</td>
<td style="text-align:left">float4</td>
<td style="text-align:left">该Pass处理的逐像素光源的颜色</td>
</tr>
<tr>
<td style="text-align:left">_WorldSpaceLightPos0</td>
<td style="text-align:left">float4</td>
<td style="text-align:left">_WorldSpaceLightPos0.xyz是该Pass处理的逐像素光源的位置。如果该光源是平行光，那么_WorldSpaceLightPos0.w是0，其他光源类型w值为1</td>
</tr>
<tr>
<td style="text-align:left">_LightMatrix0</td>
<td style="text-align:left">float4x4</td>
<td style="text-align:left">从世界空间到光源空间的变换矩阵。可以用于采样cookie和光强衰减（attenuation）纹理</td>
</tr>
<tr>
<td style="text-align:left">unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0</td>
<td style="text-align:left">float4</td>
<td style="text-align:left">仅用于Base Pass。前4个非重要的点光源在世界空间中的位置</td>
</tr>
<tr>
<td style="text-align:left">unity_4LightAtten0</td>
<td style="text-align:left">float4</td>
<td style="text-align:left">仅用于Base Pass。存储了前4个非重要的点光源的衰减因子</td>
</tr>
<tr>
<td style="text-align:left">unity_LightColor</td>
<td style="text-align:left">half4[4]</td>
<td style="text-align:left">仅用于Base Pass。存储了前4个非重要的点光源的颜色</td>
</tr>
</tbody>
</table>
<h3 id="顶点照明渲染路径"><a href="#顶点照明渲染路径" class="headerlink" title="顶点照明渲染路径"></a><font size="4" color="green">顶点照明渲染路径</font></h3><p>在Unity里，一个顶点照明的Pass中最多访问到8个逐顶点光源。顶点照明渲染路径中可以使用的内置变量如下表：</p>
<table>
<thead>
<tr>
<th style="text-align:left">名称</th>
<th style="text-align:left">类型</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">unity_LightColor</td>
<td style="text-align:left">half4[8]</td>
<td style="text-align:left">光源颜色</td>
</tr>
<tr>
<td style="text-align:left">unity_LightPosition</td>
<td style="text-align:left">float4[8]</td>
<td style="text-align:left">xyz分量是观察空间中的光源位置。如果光源是平行光，那么z分量是0，其他光源类型z分量是1</td>
</tr>
<tr>
<td style="text-align:left">unity_LightAtten</td>
<td style="text-align:left">half4[8]</td>
<td style="text-align:left">光源衰减因子。如果光源是聚光灯，x分量是cos(spotAngle/2)，y分量是1/cos(spotAngle/4)；如果是其他类型的光源，x分量是-1，y分量是1。z分量是衰减的平方，w分量是光源范围开根号的结果</td>
</tr>
<tr>
<td style="text-align:left">unity_SpotDirection</td>
<td style="text-align:left">half4[8]</td>
<td style="text-align:left">如果光源是聚光灯的话，值为观察空间的聚光灯的位置；如果是其他类型的光源，值为(0,0,1,0)</td>
</tr>
</tbody>
</table>
<p>顶点照明渲染路径中可以使用的内置函数如下表：</p>
<table>
<thead>
<tr>
<th style="text-align:left">函数名</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">float3 ShadeVertexLights(float4 vertex, float3 normal)</td>
<td style="text-align:left">输入模型空间中的顶点位置和法线，计算四个逐顶点光源的光照以及环境光。内部实现实际上调用了ShadeVertexLightsFull函数</td>
</tr>
<tr>
<td style="text-align:left">float3 ShadeVertexLightsFull(float4 vertex, float3 normal, int lightCount, bool spotLight)</td>
<td style="text-align:left">输入模型空间中的顶点位置和法线，计算lightCount个光源的光照以及环境光。如果spotLight值为true，那么这些光源会被当成聚光灯来处理，虽然结果更精确，但计算更加耗时；否则，按点光源处理</td>
</tr>
</tbody>
</table>
<p>前向渲染有两种处理方式，一个是在一遍pass里面处理多个光源，但是这样shader需要的指令数会较多，不适合低端硬件；另一个是用多遍pass处理多个光源，但是每处理一个光源时，都需要绘制该光源影响到的物体（会有很多Drawcall）。</p>
<h3 id="延迟渲染路径"><a href="#延迟渲染路径" class="headerlink" title="延迟渲染路径"></a><font size="4" color="green">延迟渲染路径</font></h3><p> 延迟渲染的原理很简单，不多说了。</p>
<p>默认的G缓冲区一般包含了以下几个渲染纹理（Render Texture，RT）：</p>
<ul>
<li>RT0：格式是ARGB32，RGB通道用于存储漫反射颜色，A通道没有被使用</li>
<li>RT1：格式是ARGB32，RGB通道用于存储高光反射颜色，A通道用于存储高光反射的指数部分</li>
<li>RT2：格式是ARGB2101010，RGB通道用于存储法线，A通道没有被使用</li>
<li>RT3：格式是ARGB32（非HDR）或ARGBHalf（HDR），用于存储自发光+lightmap+反射探针（reflection probes）</li>
<li>深度缓冲和模板缓冲</li>
</ul>
<p>延迟渲染路径中可以使用的内置变量如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">名称</th>
<th style="text-align:left">类型</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">_LightColor</td>
<td style="text-align:left">float4</td>
<td style="text-align:left">光源颜色</td>
</tr>
<tr>
<td style="text-align:left">_LightMatrix0</td>
<td style="text-align:left">float4x4</td>
<td style="text-align:left">从世界空间到光源空间的变换矩阵。可以用于采样cookie和光强衰减纹理</td>
</tr>
</tbody>
</table>
<p>在Unity的<a href="https://docs.unity3d.com/Manual/RenderingPaths.html" target="_blank" rel="external">官方文档</a>中给出了4中渲染路径的详细比较，包括它们的特性比较（是否支持逐像素光照、半透明物体、实时阴影等）、性能比较以及平台支持。</p>
<h2 id="Unity的光源类型"><a href="#Unity的光源类型" class="headerlink" title="Unity的光源类型"></a><font size="5" color="orange">Unity的光源类型</font></h2><p>下面的代码是点光源光照的shader代码：</p>
<pre class="line-numbers language-shader"><code class="language-shader">Shader "Unity Shaders Book/Chpater 9/ForwardRendering"
{
    Properties
    {
        _Diffuse("Diffuse", Color) = (1, 1, 1, 1)
        _Specular ("Specular", Color) = (1,1,1,1)
        _Gloss ("Gloss", Range(8.0, 256)) = 20
    }

    SubShader
    {
        Pass
        {
            Tags {"LightMode" = "ForwardBase"}

            CGPROGRAM

            #pragma multi_compile_fwdbase

            #pragma vertex vert
            #pragma fragment frag

            #include "Lighting.cginc"

            float4 _Diffuse;
            fixed4 _Specular;
            float  _Gloss;

            struct a2v
            {
                float4 Pos : POSITION;
                float4 Normal : NORMAL;
            };

            struct v2f
            {
                float4 Pos : SV_POSITION;
                float3 Normal : TEXCOORD0;
                float3 WorldPos : TEXCOORD1;
            };

            v2f vert(a2v v)
            {
                v2f o;
                o.Pos = UnityObjectToClipPos(v.Pos);
                o.Normal = UnityObjectToWorldNormal(v.Normal);
                o.WorldPos = mul(unity_ObjectToWorld, v.Pos).xyz;
                return o;
            }

            fixed4 frag(v2f i) : SV_Target
            {
                fixed3 Ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;

                fixed3 WorldNormal = normalize(i.Normal);
                fixed3 WorldLight = normalize(UnityWorldSpaceLightDir(i.WorldPos));
                fixed3 Diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(dot(WorldNormal, WorldLight));

                fixed3 ViewDir = normalize(UnityWorldSpaceViewDir(i.WorldPos));
                fixed3 HalfDir = normalize(WorldLight + ViewDir);
                fixed3 Specular = _LightColor0.rgb * _Specular.rgb * pow(saturate(dot(HalfDir, WorldNormal)), _Gloss);

                return fixed4(Ambient + Diffuse + Specular, 1.0);
            }

            ENDCG
        }

        Pass
        {
            Tags{"LightMode" = "ForwardAdd"}

            Blend One One

            CGPROGRAM

            #pragma multi_compile_fwdadd

            #pragma vertex vert
            #pragma fragment frag

            #include "Lighting.cginc"
            #include "AutoLight.cginc"

            float4 _Diffuse;
            fixed4 _Specular;
            float  _Gloss;

            struct a2v
            {
                float4 Pos : POSITION;
                float4 Normal : NORMAL;
            };

            struct v2f
            {
                float4 Pos : SV_POSITION;
                float3 Normal : TEXCOORD0;
                float3 WorldPos : TEXCOORD1;
            };

            v2f vert(a2v v)
            {
                v2f o;
                o.Pos = UnityObjectToClipPos(v.Pos);
                o.Normal = UnityObjectToWorldNormal(v.Normal);
                o.WorldPos = mul(unity_ObjectToWorld, v.Pos).xyz;
                return o;
            }

            fixed4 frag(v2f i) : SV_Target
            {
                fixed3 Ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;

                fixed3 WorldNormal = normalize(i.Normal);
                #ifdef USING_DIRECTIONAL_LIGHT
                    fixed3 WorldLight = normalize(_WorldSpaceLightPos0.xyz);
                #else
                    fixed3 WorldLight = normalize(_WorldSpaceLightPos0.xyz - i.WorldPos.xyz);
                #endif

                fixed3 Diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(dot(WorldNormal, WorldLight));

                fixed3 ViewDir = normalize(UnityWorldSpaceViewDir(i.WorldPos));
                fixed3 HalfDir = normalize(WorldLight + ViewDir);
                fixed3 Specular = _LightColor0.rgb * _Specular.rgb * pow(saturate(dot(HalfDir, WorldNormal)), _Gloss);

                #ifdef USING_DIRECTIONAL_LIGHT
                    fixed Atten = 1.0;
                #else
                    #if defined(POINT) 
                        float3 LightCoord = mul(unity_WorldToLight, float4(i.WorldPos, 1)).xyz;
                        fixed Atten = tex2D(_LightTexture0, dot(LightCoord, LightCoord).rr).UNITY_ATTEN_CHANNEL;
                    #elif defined(SPOT)
                        float4 LightCoord = mul(unity_WorldToLight , float4(i.WorldPos, 1));
                        fixed Atten = (LightCoord.z > 0) * tex2D(_LightTexture0, LightCoord.xy / LightCoord.w + 0.5).w * tex2D(_LightTextureB0, dot(LightCoord, LightCoord).rr).UNITY_ATTEN_CHANNEL;
                    #else
                        fixed Atten = 1.0;
                    #endif
                #endif

                return fixed4(Ambient + (Diffuse + Specular) * Atten, 1.0);
            }

            ENDCG
        }
    }

    Fallback "Specular"
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中，我们除了设置渲染路径外，还使用了#pragma编译指令。<code>#pragma multi_compile_fwdbase</code>指令可以保证我们在Shader中使用光照衰减等光照变量可以被正确赋值。</p>
<p>我们在Base Pass中处理了场景中最重要的平行光。Unity会选择最亮的平行光传递给Base Pass进行逐像素处理，其他平行光或者点光源等等会在Additional Pass中进行逐像素处理（或者直接进行逐顶点或SH光照）。所以我们需要为场景中其他逐像素光源定义Additional Pass。</p>
<p>同样的，使用<code>#pragma multi_compile_fwdadd</code>指令可以保证我们在Additional Pass中访问到正确的光照变量。由于Additional Pass计算得到的光照结果需要在帧缓存中与之前的光照结果进行叠加，所以需要使用混合<code>Blend One One</code>。我们还需要根据当前处理的光源是否是平行光、点光源、聚光灯等等，来计算出对应的光线入射方向、衰减系数等等，代码中的那些宏就是用来做这个光源类型的判断的。比如如果当前前向渲染Pass处理的光源类型是平行光，那么Unity的底层渲染引擎就会定义<code>USING_DIRECTIONAL_LIGHT</code>。</p>
<p>尽管我们可以使用数学表达式来计算给定点相对于点光源和聚光灯的衰减，但这些计算往往涉及开根号、除法等计算量相对较大的操作，因此Unity选择了使用一张纹理作为查找表（Lookup Table，LUT），以在片元着色器中得到光源的衰减（原理后面会讲到）。我们首先得到光源空间下的坐标，然后使用该坐标来对衰减纹理进行采样得到衰减值。计算该点在光源空间下的坐标需要用到世界空间到光源空间的变换矩阵<code>unity_WorldToLight</code>，该矩阵定义在AutoLight.cginc文件中。</p>
<p>而且我们发现，在Additional Pass中并没有计算环境光，这是因为环境光只需要计算一次就可以，所以把环境光的计算放在了Base Pass中。因为Base Pass只会运行一次，而Additional Pass是可能运行多次的。</p>
<p>当场景中有一个平行光和2个点光源时，平行光会在Base Pass中计算光照，而另外两个点光源如果RenderMode都是Important的（或者是Auto，但是点光源数目（这里是2）小于Edit→Project Settings→Quality→Pixel Light Count中设置的数值），那么这两个点光源都会在Additional Pass中进行逐像素光照（Additional Pass会运行两次）。下图是一个平行光和两个点光源的渲染结果：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/UnityShader%E4%B8%AD%E7%BA%A7%E7%AF%87_2.png?raw=true" alt=""><br>当场景中有一个平行光和4个点光源（它们都是Important的）时的渲染结果如下：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/UnityShader%E4%B8%AD%E7%BA%A7%E7%AF%87_3.png?raw=true" alt=""><br>使用帧调试器可以看到会有6个渲染事件：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/UnityShader%E4%B8%AD%E7%BA%A7%E7%AF%87_4.png?raw=true" alt=""><br>其中第一个是Clear（清空颜色、深度、模板缓冲等等），下一个是平行光光照渲染，后面4个都是点光源光照渲染。可以看出，Unity底层是把每个光源能影响到的物体都重新绘制了一次（对每个光源都有对应的DrawCall）。而如果场景中的一个物体不在某个光源的光照范围内，Unity是不会为这个物体调用对于的Pass来处理这个光源的。</p>
<p>如果把其中一个光源设置为Not Important，渲染结果以及帧调试器捕获结果如下图所示：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/UnityShader%E4%B8%AD%E7%BA%A7%E7%AF%87_5.png?raw=true" alt=""><br>发现渲染事件变成了5个，这是因为我们把其中一个点光源设置成了Not Important，但是我们在Shader中并没有提供顶点光照或SH光照的代码，所以这个Not Important光源实际上没有起作用，那自然不会调用DrawCall，也不会产生任何光照效果了。</p>
<p>那么如何在前向渲染路径的Base Pass中计算逐顶点和SH光照呢？可以使用之前提到的内置变量和函数来计算这些光源的效果（具体实现不赘述了）。</p>
<h2 id="Unity的光照衰减"><a href="#Unity的光照衰减" class="headerlink" title="Unity的光照衰减"></a><font size="5" color="red">Unity的光照衰减</font></h2><p>上面我们是使用一张纹理作为查找表来计算光源衰减的。这样做的好处在于节省了计算量，但是也有一些弊端：</p>
<ul>
<li>需要预处理得到采样纹理，而且纹理的大小也会影响衰减的精度</li>
<li>不直观，同时也不方便，一旦把数据存储到查找表中，我们就无法使用其他数学公式来计算衰减</li>
</ul>
<p>但由于这种方法可以在一定程度上提升性能，而且得到的效果在大部分情况下都是良好的，因此Unity默认就是使用这种纹理查找的方式来计算逐像素的点光源和聚光灯的衰减的。</p>
<h3 id="使用衰减查找纹理来计算光源衰减"><a href="#使用衰减查找纹理来计算光源衰减" class="headerlink" title="使用衰减查找纹理来计算光源衰减"></a><font size="4" color="green">使用衰减查找纹理来计算光源衰减</font></h3><p>Unity在内部使用一张名为_LightTexture0的纹理来计算光源衰减。需要注意的是，如果我们对光源使用了cookie，俺么衰减查找纹理是_LightTextureB0。在_LightTexture0对角线上的纹素值代表了光源空间中不同位置的点的衰减值，而（1,1）点表明了在光源空间中距离最远的点的衰减。通常采样衰减值的代码如下：</p>
<pre class="line-numbers language-shader"><code class="language-shader">float3 LightCoord = mul(unity_WorldToLight, float4(i.WorldPos, 1)).xyz;
fixed Atten = tex2D(_LightTexture0, dot(LightCoord, LightCoord).rr).UNITY_ATTEN_CHANNEL;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>需要先得到着色点在光源空间下的坐标，然后根据这个坐标得到着色点到光源的距离的平方（这个距离需要是在光源空间下的），再来对纹理采样。之所以没有距离值来采样是因为这种方法可以避免开方操作。然后使用宏<code>UNITY_ATTEN_CHANNEL</code>来得到衰减纹理中衰减值所在的分量，以得到最终的衰减值。</p>
<h3 id="使用数学公式计算衰减"><a href="#使用数学公式计算衰减" class="headerlink" title="使用数学公式计算衰减"></a><font size="4" color="green">使用数学公式计算衰减</font></h3><p>也可以用下面的代码使用数学公式来计算光源的线性衰减：</p>
<pre class="line-numbers language-shader"><code class="language-shader">float Distance = length(_WorldSpaceLightPos0.xyz - i.WorldPos.xyz);
fixed Atten = 1.0 / Distance;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>不过可惜的是，Unity没有在文档中给出内置衰减计算的相关说明，我们也无法在Shader中通过内置变量得到光源的范围、聚光灯的朝向、张开角度等等信息。</p>
<h2 id="Unity的阴影"><a href="#Unity的阴影" class="headerlink" title="Unity的阴影"></a><font size="5" color="red">Unity的阴影</font></h2><p>由于在Base Pass和Additional Pass中往往会涉及很多复杂的光照计算，所以Unity选择使用一个额外的Pass来专门更新光源的阴影映射纹理，这个Pass就是LightMode标签被设置为ShadowCaster的Pass。这个Pass的渲染目标不是帧缓存，而是阴影映射纹理（或深度纹理）。</p>
<p>在Unity5中，使用了一种不同于传统shadow map的方式来进行阴影投射，叫屏幕空间的阴影映射技术（Screenspace Shadow Map）。它原本是延迟渲染中产生阴影的方法。</p>
<p>使用屏幕空间的阴影映射技术时，Unity首先会通过调用LightMode为ShadowCaster的Pass来得到光源的阴影映射纹理以及摄像机的深度纹理。然后使用这两张纹理来得到屏幕空间的阴影图。原理：如果摄像机的深度纹理中记录的表面深度大于转换到阴影映射纹理中的深度值，就说明该表面虽然是可见的，但是却处于该光源的阴影中。这样一来，最终生成的阴影图就包含了屏幕空间中的所有阴影区域。所以：</p>
<ul>
<li>如果我们想要一个物体接收来自其他物体的阴影，就必须在Shader中对阴影图进行采样，把采样结果和最后的光照结果相乘来产生阴影效果。</li>
<li>如果我们想要一个物体像其他物体投射阴影，就必须把该物体加入到光源的阴影映射纹理的计算中，从而让其他物体在对阴影图采样时可以得到该物体的相关信息。在Unity中，这个过程是通过为该物体执行LightMode为ShadowCaster的Pass来实现的。同时Unity还会使用这个Pass产生一张摄像机的深度纹理。</li>
</ul>
<h3 id="不透明物体的阴影"><a href="#不透明物体的阴影" class="headerlink" title="不透明物体的阴影"></a><font size="4" color="green">不透明物体的阴影</font></h3><p>想让一个物体投射阴影（向其他物体投射阴影），需要将物体MeshRender组件里的CastShadows选项设为On，这样的话，Unity就会去该物体的材质shader里去找LightMode标签为ShadowCaster的Pass，来把该物体加入到光源的阴影映射纹理的计算中，从而让其他物体在对阴影映射纹理采样时可以得到该物体的相关信息。而这个ShadowCaster Pass通常可以通过回调Pass包含进来，比如<code>Fallback &quot;Specular&quot;</code>，如果Unity在当前Pass中找不到ShadowCaster Pass，就会去Specular中找，然后再去Specular回调的VertexLit中可以找到一个LightMode为ShadowCaster的Pass。</p>
<p>把之前的ForwardRendering这个Shader材质赋给场景中的立方体，并开启立方体的CastShadows选项，会得到下面的渲染结果：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/UnityShader%E4%B8%AD%E7%BA%A7%E7%AF%87_6.png?raw=true" alt=""><br>发现右边的平面并没有投射阴影到水平面上，这是因为在计算光源的阴影映射纹理时会剔除掉物体的背面，场景中右边平面在当前旋转角度下刚好相对于光源是背面，所以它没有被算进阴影映射纹理里，也就自然无法向其他物体投射阴影了。而这个平面只有一个面，如果想让它一直投射阴影，可以将该平面的Cast Shadows选项从on改为Two Sided。这样得到的渲染结果如下：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/UnityShader%E4%B8%AD%E7%BA%A7%E7%AF%87_7_2.png?raw=true" alt=""><br>水平面接收到右侧平面的阴影了，但是立方体上并没有接收到阴影。这是因为立方体的Shader里还没有加入接收阴影处理的相关代码，而水平面用的是Standard Shader，该Shader里面已经集成了接收阴影处理的代码。</p>
<p>为了让立方体接收阴影，我们只需要在之前的ForwardRendering这个Shader的基础上，先在Base Pass中包含一个新的内置文件：</p>
<pre class="line-numbers language-shader"><code class="language-shader">#include "AutoLight.cginc"
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>然后在v2f结构体中添加一个内置宏<code>SHADOW_COORDS</code>：</p>
<pre class="line-numbers language-shader"><code class="language-shader">struct v2f
{
    float4 pos : SV_POSITION;
    float3 Normal : TEXCOORD0;
    float3 WorldPos : TEXCOORD1;
    SHADOW_COORDS(2)
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个宏其实就是声明了一个用于对阴影纹理进行采样的坐标。它的参数是下一个可用的插值寄存器的索引值（在上面代码中就是2，因为TEXCOORD0和TEXCOORD1都已经用了）。</p>
<p>然后需要在顶点着色器里计算这个采样坐标，使用另一个宏<code>TRANSFER_SHADOW</code>来完成：</p>
<pre class="line-numbers language-shader"><code class="language-shader">v2f vert(a2v v)
{
    v2f o;
    //...
    TRANSFER_SHADOW(o);
    return o;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>最后在片元着色器里使用宏<code>SHADOW_ATTENUATION</code>来计算阴影值，并且把这个阴影值和光照值相乘来得到阴影效果：</p>
<pre class="line-numbers language-shader"><code class="language-shader">fixed Shadow = SHADOW_ATTENUATION(i);
return fixed4(Ambient + (Diffuse + Specular) * Shadow, 1.0);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>可以看到主要是用内置宏来完成阴影计算的，<strong>SHADOW_COORDS</strong>、<strong>TRANSFER_SHADOW</strong>和<strong>SHADOW_ATTENUATION</strong>是阴影计算时的“三剑客”。</p>
<p>需要注意的是，由于用到了这些内置宏，所以需要保证我们自定义的变量名和这些宏中使用的变量名相匹配。我们需要保证：a2v结构体的顶点坐标变量名必须是vertex，顶点着色器的输出结构体v2f必须命名为v，且v2f中的顶点位置变量必须命名为pos。</p>
<p>渲染结果如下图：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/UnityShader%E4%B8%AD%E7%BA%A7%E7%AF%87_8.png?raw=true" alt=""><br>可以通过帧调试器看到整个渲染过程，包括渲染摄像机的深度纹理、光源的阴影映射纹理、阴影图以及最终的光照效果等等。（可以在Base Pass中计算平行光的阴影，也可以在Additional Pass中计算其他逐像素光源的阴影）</p>
<h3 id="统一管理光照衰减和阴影"><a href="#统一管理光照衰减和阴影" class="headerlink" title="统一管理光照衰减和阴影"></a><font size="4" color="green">统一管理光照衰减和阴影</font></h3><p>Unity还提供了一个宏<code>UNITY_LIGHT_ATTENUATION</code>来在片元着色器里统一计算光照衰减和阴影值：</p>
<pre class="line-numbers language-shader"><code class="language-shader">fixed4 frag(v2f i) : SV_Target
{
    //...
    UNITY_LIGHT_ATTENUATION(atten, i, i.WorldPos);
    return fixed4(Ambient + (Diffuse + Specular) * atten, 1.0);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>宏里面的第一个参数<code>atten</code>不需要我们自己声明，因为这个宏所表示的代码里会帮我们声明这个变量，计算得到的光照衰减和阴影值相乘的结果会存储到这个变量里，第二个参数是v2f结构体对象，第三个参数是片元的世界坐标，用于计算片元在光源空间下的坐标然后采样来光照衰减纹理。</p>
<p>如果我们希望在Additional Pass中添加阴影效果，就需要使用<code>#pragma multi_compile_fwdadd_fullshadows</code>编译指令来代替原来的<code>#pragma multi_compile_fwdadd</code>指令。</p>
<h3 id="透明物体的阴影"><a href="#透明物体的阴影" class="headerlink" title="透明物体的阴影"></a><font size="4" color="green">透明物体的阴影</font></h3><p>对于使用了Alpha Test的物体来说，如果我们直接使用VertexLit、Diffuse、Specular等作为回调，往往无法得到正确的阴影。这是因为Alpha Test需要在片元着色器里舍弃某些片元，但是VertexLit里的Shadow Pass并没有对应的操作来保证生成正确的阴影投射纹理。比如为初级篇中AlphaTest这个Shader添加上阴影效果：</p>
<p>先增加需要包含的头文件：</p>
<pre class="line-numbers language-shader"><code class="language-shader">#include "AutoLight.cginc"
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>然后v2f结构体中使用内置宏SHADOW_COORDS来声明阴影纹理坐标：</p>
<pre class="line-numbers language-shader"><code class="language-shader">struct v2f
{
    float4 pos : SV_POSITION;
    float3 WorldNormal : TEXCOORD0;
    float3 WorldPos : TEXCOORD1;
    float2 UV : TEXCOORD2;
    SHADOW_COORDS(3)
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后在顶点着色器中使用宏TRANSFER_SHADOW来计算阴影纹理坐标：</p>
<pre class="line-numbers language-shader"><code class="language-shader">v2f vert(a2v v)
{
    v2f o;
    //...
    TRANSFER_SHADOW(o);
    return o;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后在片元着色器里计算阴影值并乘到光照结果上：</p>
<pre class="line-numbers language-shader"><code class="language-shader">UNITY_LIGHT_ATTENUATION(atten, i, i.WorldPos);
return fixed4(Ambient + Diffuse * atten, 1.0);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>最后把回调Shader改为：</p>
<pre class="line-numbers language-shader"><code class="language-shader">Fallback "VertexLit"
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>渲染结果如下图：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/UnityShader%E4%B8%AD%E7%BA%A7%E7%AF%87_9.png?raw=true" alt=""><br>可以看到镂空区域也出现了不应该有的阴影，看起来就像这个正方体是一个普通的不透明正方体一样。而我们是希望有些光可以通过这些镂空区域透过来的，这些区域不应该有阴影。错因在于我们使用的是内置的Vertex中提供的ShadowCaster来投射阴影，而这个Pass中并没有进行任何Alpha Test的计算，因此它会把整个物体的深度信息都渲染到深度图和阴影映射纹理中。需要提供一个有透明度测试功能的ShadowCaster Pass，而内置的Transparent/Cutout/VertexLit就是这样的。所以可以把回调改为如下：</p>
<pre class="line-numbers language-shader"><code class="language-shader">Fallback "Transparent/Cutout/VertexLit"
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>需要注意的是，由于Transparent/Cutout/VertexLit中计算透明度测试时，使用了名为_Cutoff的属性来进行透明度测试，所以，这要求我们的Shader中也必须提供名为_Cutoff的属性，否则无法得到正确的阴影结果。渲染结果如下图：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/UnityShader%E4%B8%AD%E7%BA%A7%E7%AF%87_10.png?raw=true" alt=""><br>但是这样的结果仍然有一些问题，出现了太多的无阴影区域，其中有一些区域的光线应该是被挡住的。原因是默认情况下把物体渲染到深度图和阴影映射纹理中仅考虑物体的正面，但对于上面场景里的正方体来说，由于一些面完全背对光源，导致这些面完全没有被考虑到阴影映射纹理的计算中（因为前面透明，背面不透明时，如果不考虑背面就会得到错误的阴影结果）。为了得到正确的结果，我们可以将正方体的Cast Shadows选项设置为Two Sided，强制Unity在计算阴影映射纹理时计算所有面的深度信息。正确的渲染结果如下图：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/UnityShader%E4%B8%AD%E7%BA%A7%E7%AF%87_11.png?raw=true" alt=""><br>在Unity中，对于使用透明度混合的物体来说，也即，所有内置的半透明Shader是不会产生任何阴影效果的。这是因为透明度混合需要关闭深度写入，由此带来的问题也影响了阴影的生成。总体来说，要想为这些半透明物体产生正确的阴影，需要在每个光源空间下仍然严格按照从后往前的顺序进行渲染，这会让阴影处理变得非常复杂，而且也会影响性能。所以Unity中的半透明物体不会向其他物体投射阴影，也不会接受来自其他物体的阴影，看起来就像是完全透明一样（也可以强制使用VertexLit、Diffuse这些不透明物体使用的Shader来作为回调，从而强制让半透明物体产生阴影，但这个实际上是不对的（原理和阴影效果都不对））。</p>
<p>将之前所有的法线贴图、阴影、漫反射、镜面反射、多光源等等结合起来，写到两个Shader里：BumpedDiffuse和BumpedSpecular（这两个Shader后面会用到），代码在<a href="">这里</a>。</p>
<h1 id="第十章-高级纹理"><a href="#第十章-高级纹理" class="headerlink" title="第十章 高级纹理"></a><font size="6" color="orange">第十章 高级纹理</font></h1><hr>
<h2 id="立方体纹理"><a href="#立方体纹理" class="headerlink" title="立方体纹理"></a><font size="5" color="red">立方体纹理</font></h2><h3 id="天空盒子"><a href="#天空盒子" class="headerlink" title="天空盒子"></a><font size="4" color="green">天空盒子</font></h3><p>对于天空盒材质，可以使用Unity内置的Shader：Skybox/6 sided，该材质需要6张纹理，每张纹理的Wrap Mode需要设置为Clamp，以防止在接缝处出现不匹配的现象。并且该材质还有另外3个属性：Tint Color，用于控制该材质的整体颜色；Exposure，用于调整天空盒子的亮度；Rotation，用于调整天空盒子沿+y轴方向的旋转角度。</p>
<p>为了让摄像机正常显示天空盒子，需要将其Clear Flags选项设置为Skybox。</p>
<p>在Window→Lighting→Skybox中设置的天空盒子会应用于场景中的所有摄像机。如果希望某些摄像机可以使用不同的天空盒子，可以通过向该摄像机上单击Component→Rendering→Skybox来添加Skybox组间，从而完成对场景默认天空盒子的覆盖。</p>
<p>在Unity中，天空盒子是在所有不透明物体之后渲染的，而其背后使用的网格是一个立方体或一个细分后的球体。</p>
<h3 id="创建用于环境映射的立方体纹理"><a href="#创建用于环境映射的立方体纹理" class="headerlink" title="创建用于环境映射的立方体纹理"></a><font size="4" color="green">创建用于环境映射的立方体纹理</font></h3><p>创建用于环境映射的立方体纹理有三种方法：1. 直接由全景图、立方体六面图等纹理自动生成（把纹理的Texture Type设置为Cubemap）；2. 手动创建一个Cubemap，再把6张图赋给它（在Project视图里右键Create→Legacy→Cubemap；3. 由脚本生成（使用<code>Camera.RenderToCubemap</code>函数可以把从任意位置观察到的场景图像存储到6张图像中，从而创建出该位置上对应的立方体纹理）。</p>
<p>下面看一下怎么通过脚本来在世界空间中任意位置上，渲染一个看到的周围场景的Cubemap。首先创建一个空的GameObject，我们会使用该GameObject的位置信息来渲染立方体纹理。然后创建一个用于存储的立方体纹理（Project视图里右键Create→Legacy→Cubemap，为了让脚本可以顺利将图像渲染到该立方体纹理中，需要在它的面板中勾选Readable选项）。然后通过如下代码，来创建一个菜单栏条目GameObject→Render into Cubemap：</p>
<pre class="line-numbers language-cs"><code class="language-cs">using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEditor;

public class RenderCubemapWizard : ScriptableWizard
{
    public Transform m_RenderFromPosition;
    public Cubemap m_Cubemap;

    void OnWizardUpdate()
    {
        helpString = "Select transform to render from and cubemap to render into";
        isValid = (m_RenderFromPosition != null) && (m_Cubemap != null);
    }

    void OnWizardCreate()
    {
        //创建一个临时对象并添加Camera组件，来渲染立方体纹理
        GameObject TmpObj = new GameObject("TmpObj4RenderCubemap");
        TmpObj.AddComponent<Camera>();
        //将该临时对象以及附加的摄像机的位置设为外界指定的位置
        TmpObj.transform.position = m_RenderFromPosition.position;
        //获取摄像机组件，使用Camera的RenderToCubemap成员函数来从当前位置渲染cubemap
        TmpObj.GetComponent<Camera>().RenderToCubemap(m_Cubemap);
        //销毁临时对象
        DestroyImmediate(TmpObj);
    }

    [MenuItem("GameObject/Render into cubemap")]
    static void RenderCubemap()
    {
        ScriptableWizard.DisplayWizard<RenderCubemapWizard>("Render cubemap", "Render!");
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后在Unity菜单栏中选择GameObject→Render into Cubemap，打开窗口把之前创建的空的GameObject和Cubemap拖进去，点击Render按钮后就可以把当前位置观察到的世界空间下的6张图渲染到Cubemap中，渲染结果如下图所示：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/UnityShader%E4%B8%AD%E7%BA%A7%E7%AF%87_12.png?raw=true" alt=""><br>准备好了需要的立方体纹理后，我们就可以对物体使用环境映射技术了。环境映射最常见的应用就是反射和折射。</p>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a><font size="4" color="green">反射</font></h3><p>反射的原理很简单，主要是用观察向量的反射向量去采样Cubemap环境贴图。首先需要声明一个Cubemap的属性，以便于把上一节生成的Cubemap拖曳进来：</p>
<pre class="line-numbers language-shader"><code class="language-shader">Properties
{
    _Color("Color Tint", Color) = (1,1,1,1)
    _ReflectColor("Reflection Color", Color) = (1,1,1,1)
    _ReflectAmount("Reflect Amount", Range(0, 1)) = 1
    _Cubemap("Reflection Cubemap", Cube) = "_Skybox"{}
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中，<code>_ReflectColor</code>用于控制反射颜色，<code>_ReflectAmount</code>用于控制这个材质的反射程度，而<code>_Cubemap</code>就是用于模拟反射的环境映射纹理。</p>
<p>然后在顶点着色器里使用内置CG函数<code>reflect</code>计算观察向量的反射向量（这里选择了在顶点着色器中计算反射向量，也可以选择在片元着色器中计算，这样得到的效果会更加细腻。但是，其实这种差别很小，往往是可以忽略不计的，所以出于性能考虑，这里选择了在顶点着色器里计算反射方向）：</p>
<pre class="line-numbers language-shader"><code class="language-shader">o.worldRefl = reflect(-o.worldViewDir, o.worldNormal);
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>然后在片元着色器里使用该反射向量去采样Cubemap环境贴图，并且把采出的颜色值和漫反射颜色按照反射程度<code>_ReflectAmount</code>进行线性插值：</p>
<pre class="line-numbers language-shader"><code class="language-shader">fixed3 Reflection = texCUBE(_Cubemap, i.worldRefl).rgb * _ReflectColor.rgb;
UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);
fixed3 Color = Ambient + lerp(Diffuse, Reflection, _ReflectAmount) * atten;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>要注意一点：由于我们更关注反射效果，所以需要把光源的Shadow Type选项设置为No Shadows，否则得到的反射结果会有很多地方都是黑的（或者在Shader里去掉关于阴影的代码）。</p>
<p>渲染结果如下图：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/UnityShader%E4%B8%AD%E7%BA%A7%E7%AF%87_13.png?raw=true" alt=""></p>
<h3 id="折射"><a href="#折射" class="headerlink" title="折射"></a><font size="4" color="green">折射</font></h3><p>折射也相当简单了。就是把反射光线换成了折射光线。首先是属性里需要增加一个折射率属性：</p>
<pre class="line-numbers language-shader"><code class="language-shader">Properties
{
    _Color("Color Tint", Color) = (1,1,1,1)
    _RefractColor("Refraction Color", Color) = (1,1,1,1)
    _RefractAmount("Refraction Amount", Range(0, 1)) = 1
    _RefractRatio("Refraction Ratio", Range(0.1, 1)) = 0.5
    _Cubemap("Reflection Cubemap", Cube) = "_Skybox"{}
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后在顶点着色器里使用<code>refract</code>函数来计算折射光线：</p>
<pre class="line-numbers language-shader"><code class="language-shader">o.worldRefr = refract(-normalize(o.worldViewDir), normalize(o.worldNormal), _RefractRatio);
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>其中第一个和第二个参数都需要是归一化的，第三个参数就是两种介质之间的折射率。</p>
<p>然后在片元着色器里使用折射光线来采样Cubemap环境贴图：</p>
<pre class="line-numbers language-shader"><code class="language-shader">fixed3 Refraction = texCUBE(_Cubemap, i.worldRefr).rgb * _RefractColor.rgb;
UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);
fixed3 Color = Ambient + lerp(Diffuse, Refraction, _RefractAmount) * atten;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>渲染结果如下图：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/UnityShader%E4%B8%AD%E7%BA%A7%E7%AF%87_14.png?raw=true" alt=""></p>
<h3 id="菲涅尔反射"><a href="#菲涅尔反射" class="headerlink" title="菲涅尔反射"></a><font size="4" color="green">菲涅尔反射</font></h3><p>最著名的模拟菲涅尔反射的近似公式是，Schlick菲涅尔近似等式：<br>$$<br>F_{Schlick}(v,n)=F_0+(1-F_0)(1-v\cdot n)^5<br>$$<br>其中$F_0$是一个反射系数，用于控制菲涅尔反射的强度，$v$是观察方向，$n$是表面法线。另一个应用比较广泛的等式是Empricial菲涅尔近似等式：<br>$$<br>F_{Empricial}(v,n)=max(0,min(1, bias+scale\times (1-v\cdot n)^{power}))<br>$$<br>其中$bias$、$scale$和$power$是控制项。<br>使用上面的菲涅尔近似等式，我们可以在边界处模拟反射光强和折射光强（漫反射光强）之间的变化。在许多车漆、水面等材质的渲染中，我们会经常使用菲涅尔反射来模拟更加真实的反射效果。</p>
<p>所以可以在Shader里使用该近似公式计算出来的菲涅尔系数来替换之前Reflection这个shader中的<code>_ReflectAmount</code>属性（因为菲涅尔属性算的就是反射光占入射光的比率）：</p>
<pre class="line-numbers language-shader"><code class="language-shader">Properties
{
    _Color("Color Tint", Color) = (1,1,1,1)
    _FresnelScale("Fresnel Scale", Range(0, 1)) = 0.5
    _Cubemap("Reflection Cubemap", Cube) = "_Skybox"{}
}
//...
fixed  Fresnel = _FresnelScale + (1 - _FresnelScale) * pow(1 - dot(worldViewDir, worldNormal), 5);
fixed3 Diffuse = _LightColor0.rgb * _Color.rgb * max(0, dot(worldNormal, worldLightDir));
fixed3 Reflection = texCUBE(_Cubemap, i.worldRefl).rgb;
UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);
fixed3 Color = Ambient + lerp(Diffuse, Reflection, saturate(Fresnel)) * atten;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>渲染结果如下图：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/UnityShader%E4%B8%AD%E7%BA%A7%E7%AF%87_15.png?raw=true" alt=""></p>
<h2 id="渲染纹理"><a href="#渲染纹理" class="headerlink" title="渲染纹理"></a><font size="5" color="orange">渲染纹理</font></h2><p>在Unity中使用渲染纹理通常有两种方式：</p>
<ul>
<li>在Project视图下创建一个渲染纹理，然后把某个摄像机的渲染目标设置成该渲染纹理，这样一来该摄像机的渲染结果就会实时更新到渲染纹理中，而不会显示到屏幕上</li>
<li>在屏幕后处理时使用GrabPass命令或OnRenderImage函数来获取当前屏幕图像，Unity会把这个屏幕图像放到一张和屏幕分辨率等同的渲染纹理中</li>
</ul>
<h3 id="镜子效果"><a href="#镜子效果" class="headerlink" title="镜子效果"></a><font size="4" color="green">镜子效果</font></h3><p>我们可以使用上面第一种方式来渲染到纹理，从而实现镜子的效果。首先在场景中创建一个Quad来作为镜子，然后创建一个摄像机，调整它的位置、近远裁剪平面、视角范围等等，使其近平面刚好和该Quad重合（这样就像是摄像机从镜子背后看过去），同时需要让该摄像机渲染到纹理而不是屏幕，所以需要把该摄像机的Target Texture选项设置为一张渲染纹理（该render texture需要事先在Project视图里创建好）。这样一来，render texture里就会被渲染出该摄像机所看到的景象，如下图所示：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/UnityShader%E4%B8%AD%E7%BA%A7%E7%AF%87_16.png?raw=true" alt=""><br>然后只需要把这张渲染好的render texture贴到Quad上面就可以了。贴的原理很简单，为Quad创建一个名为Mirror的Shader，其中属性里声明一张纹理，用于把渲染好的render texture拖曳进来：</p>
<pre class="line-numbers language-shader"><code class="language-shader">Properties
{
    _MainTex("Main Tex", 2D) = "white"{}
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后在顶点着色器里计算纹理坐标：由于是镜子，所以需要让uv坐标的x分量反一下，才能有镜子里图像左右相反的效果：</p>
<pre class="line-numbers language-shader"><code class="language-shader">v2f vert(a2v v)
{
    v2f o;
    o.pos = UnityObjectToClipPos(v.vertex);
    o.uv = v.texcoord;
    o.uv.x = 1 - o.uv.x;    //Mirror need to flip x
    return o;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后在片元着色器里使用uv坐标对render texture进行采样就可以了：</p>
<pre class="line-numbers language-shader"><code class="language-shader">fixed4 frag(v2f i) : SV_Target
{
    return tex2D(_MainTex, i.uv);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>渲染结果如下图：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/UnityShader%E4%B8%AD%E7%BA%A7%E7%AF%87_17.png?raw=true" alt=""><br>其中的球和立方体都是使用的之前第九章中创建好的名为BumpedDiffuse的Shader，墙面使用的是名为BumpedSpecular的Shader。</p>
<h3 id="玻璃效果"><a href="#玻璃效果" class="headerlink" title="玻璃效果"></a><font size="4" color="green">玻璃效果</font></h3><p>在Unity中，我们还可以在Unity Shader中使用一种特殊的Pass来完成获取屏幕图像的目的，这就是GrabPass。当我们在Shader中定义了一个GrabPass后，Unity会把当前屏幕的图像绘制在一张纹理中（相当于截屏），以便我们在后续的Pass中访问它。</p>
<p>需要注意的是，在使用GrabPass的时候，我们需要额外小心物体的渲染队列设置，往往需要把GrabPass所在的SubShader的渲染队列设置成透明队列（即<code>&quot;Queue&quot; = &quot;Transparent&quot;</code>）。因为这样可以保证渲染该GrabPass时，其他不透明物体都已经被绘制在屏幕上（通常都是先把其他物体绘制完了之后，然后调用GrabPass来截屏）。</p>
<p>我们可以使用GrabPass将屏幕图像截屏到render texture，然后使用该render texture来进行后处理或者实现玻璃效果等等。</p>
<p>实现玻璃效果的原理：对截屏得到的render texture进行采样来模拟得到折射颜色，采样时使用物体表面切线空间的法线来扰动采样坐标。</p>
<p>首先声明需要用到的属性：</p>
<pre class="line-numbers language-shader"><code class="language-shader">Properties
{
    _MainTex("Main Tex", 2D) = "white"{}
    _BumpMap("Normal Map", 2D) = "bump"{}
    _Cubemap("Environment Cubemap", Cube) = "_Skybox"{}
    _Distortion("Distortion", Range(0, 100)) = 10
    _RefractAmount("Refract Amount", Range(0.0, 1.0)) = 1.0
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中<code>_Distortion</code>用于控制模拟折射时图像的扭曲成都，<code>_RefractAmount</code>用于控制折射成都，当其值为0时，该玻璃只包含反射效果，当其值为1时，该玻璃只包含折射效果。</p>
<p>然后在SubShader中定义Transparent渲染队列，并使用GrabPass来获取屏幕图像：</p>
<pre class="line-numbers language-shader"><code class="language-shader">SubShader
{
    //必须定义Transparent渲染队列，以便于当前Shader在其他物体之后渲染
    Tags {"Queue" = "Transparent" "RenderType" = "Opaque"}

    GrabPass {"_RefractionTex"}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>首先在SubShader的标签中将渲染队列设置成Transparent，尽管后面的RenderType被设置为了Opaque。这两者看似矛盾，但实际上服务于不同的需求。把Queue设置成Transparent可以确保该物体渲染时，其他所有不透明物体都已经被渲染到屏幕上了，否则可能无法正确得到“透过玻璃看到的图像”。而设置RenderType则是为了在使用着色器替换（Shader Replacement）时，该物体可以在需要时被正确渲染。</p>
<p>然后我们通过关键词GrabPass定义看一个抓取屏幕图像的Pass。在这个Pass中我们定义了一个字符串，该字符串决定了抓取到的屏幕图像将会被存入哪个纹理中。</p>
<p>然后定义渲染玻璃所需的Pass，先定义属性对应的变量：</p>
<pre class="line-numbers language-shader"><code class="language-shader">Pass
{
    //...
    sampler2D _MainTex;
    float4 _MainTex_ST;
    sampler2D _BumpMap;
    float4 _BumpMap_ST;
    samplerCUBE _Cubemap;
    float  _Distortion;
    fixed  _RefractAmount;
    sampler2D _RefractionTex;
    float4 _RefractionTex_TexelSize;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到除了属性对应的变量，我们还定义了<code>_RefractionTex</code>和<code>_RefractionTex_TexelSize</code>变量，前者对应了在使用GrabPass时指定的纹理名称。后者可以让我们得到该纹理的纹素大小，例如一个大小为256x512的纹理，它的纹素大小为（1/256, 1/512）。我们在对屏幕图像的采样坐标进行偏移时会使用到该变量。</p>
<p>然后在顶点着色器里通过<code>ComputeGrabScreenPos</code>函数来得到原始的屏幕图像的采样坐标（该函数内部其实就是通过裁剪坐标来计算纹理坐标）：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> v2f
<span class="token punctuation">{</span>
    float4 pos <span class="token operator">:</span> SV_POSITION<span class="token punctuation">;</span>
    float4 scrPos <span class="token operator">:</span> TEXCOORD0<span class="token punctuation">;</span>
    float4 uv <span class="token operator">:</span> TEXCOORD1<span class="token punctuation">;</span>
    float4 tangentToWorldSpace0 <span class="token operator">:</span> TEXCOORD2<span class="token punctuation">;</span>
    float4 tangentToWorldSpace1 <span class="token operator">:</span> TEXCOORD3<span class="token punctuation">;</span>
    float4 tangentToWorldSpace2 <span class="token operator">:</span> TEXCOORD4<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

v2f <span class="token function">vert</span><span class="token punctuation">(</span>a2v v<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    v2f o<span class="token punctuation">;</span>
    o<span class="token punctuation">.</span>pos <span class="token operator">=</span> <span class="token function">UnityObjectToClipPos</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span>vertex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    o<span class="token punctuation">.</span>scrPos <span class="token operator">=</span> <span class="token function">ComputeGrabScreenPos</span><span class="token punctuation">(</span>o<span class="token punctuation">.</span>pos<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//...</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后在片元着色器里使用切线空间的法线和<code>_Distortion</code>属性以及<code>_RefractionTex_TexelSize</code>属性来对屏幕图像的采样坐标进行偏移，模拟折射效果：</p>
<pre class="line-numbers language-shader"><code class="language-shader">fixed4 frag(v2f i) : SV_Target
{
    float3 worldPos = float3(i.tangentToWorldSpace0.w, i.tangentToWorldSpace1.w, i.tangentToWorldSpace2.w);
    fixed3 viewDir = normalize(UnityWorldSpaceViewDir(worldPos));

    fixed3 unpackedNormal = UnpackNormal(tex2D(_BumpMap, i.uv.zw));

    float2 offset = unpackedNormal.xy * _Distortion * _RefractionTex_TexelSize.xy;
    i.scrPos.xy = offset + i.scrPos.xy;
    fixed3 refrColor = tex2D(_RefractionTex, i.scrPos.xy/i.scrPos.w).rgb;

    unpackedNormal = normalize(half3(dot(i.tangentToWorldSpace0.xyz, unpackedNormal), dot(i.tangentToWorldSpace1.xyz, unpackedNormal), dot(i.tangentToWorldSpace2.xyz, unpackedNormal)));

    fixed3 reflDir = reflect(-viewDir, unpackedNormal);
    fixed4 texColor = tex2D(_MainTex, i.uv.xy);
    fixed3 reflColor = texCUBE(_Cubemap, reflDir).rgb * texColor.rgb;

    fixed3 finalColor = (1 - _RefractAmount) * reflColor + _RefractAmount * refrColor;
    return fixed4(finalColor, 1);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>_Distortion</code>值越大，偏移量就越大，玻璃背后的物体看起来变形程度越大。然后需要对采样坐标<code>scrPos</code>做透视除法才能得到正在的屏幕坐标（因为<code>ComputeGrabScreenPos</code>函数内部在算采样坐标时没有做透视除法，具体可以参见UnityCG.cginc文件），再使用该坐标对抓取的屏幕图像<code>_RefractionTex</code>进行采样，得到模拟的折射颜色。反射的颜色和之前一样，使用反射向量去采样Cubemap环境贴图得到。最后使用<code>_RefractAmount</code>将反射颜色和折射颜色混合起来。</p>
<p>前面我们在GrabPass中使用一个字符串指明了被抓取的屏幕图像将会存储在哪个名称的纹理中。实际上，GrabPass支持两种形式：</p>
<ul>
<li>直接使用<code>GrabPass{ }</code>，然后在后续的Pass中直接使用<code>_GrabTexture</code>来访问屏幕图像。但是，当场景中有多个物体都使用了这样的形式来抓取屏幕时，这种方法的性能消耗比较大，因为对于每一个使用它的物体，Unity都会为它单独进行一次昂贵的屏幕抓取操作。</li>
<li>使用<code>GrabPass {&quot;TextureName&quot;}</code>，我们可以在后续的Pass中使用TextureName来访问屏幕图像。使用这种方法同样可以抓取屏幕，但Unity只会在每一帧时为第一个使用名为TextureName的纹理的物体执行一次抓取屏幕的操作，而这个纹理同样可以在其他Pass中被访问。这种方法更高效，因为不管场景中有多少物体使用了该命令，每一帧中Unity都只会执行一次抓取工作，但这也意味着所有物体都会使用同一张屏幕图像。</li>
</ul>
<p>渲染结果的玻璃效果如下图：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/UnityShader%E4%B8%AD%E7%BA%A7%E7%AF%87_18.png?raw=true" alt=""></p>
<h3 id="渲染纹理-vs-GrabPass"><a href="#渲染纹理-vs-GrabPass" class="headerlink" title="渲染纹理 vs GrabPass"></a><font size="4" color="green">渲染纹理 vs GrabPass</font></h3><p>尽管使用GrabPass和玻璃效果中使用渲染纹理+额外摄像机的方式都可以抓取屏幕图像，但它们之间还是有一些不同的。GrabPass的好处在于实现简单，我们只需要在Shader中写几行代码就可以实现抓取屏幕的目的。而要使用渲染纹理的话，我们首先需要创建一个渲染纹理和一个额外的摄像机，再把该摄像机的Render Target设置为新建的渲染纹理对象，最后把该渲染纹理传递给相应的Shader。</p>
<p>但从效率上来讲，使用渲染纹理的效率往往要好于GrabPass，尤其在移动设备上。使用渲染纹理我们可以自定义渲染纹理的大小，尽管这种方法需要把部分场景再渲染一遍，但我们可以通过调整摄像机的渲染层来减少二次渲染时的场景大小，或使用其他方法来控制摄像机是否需要开启。而使用GrabPass获取到的图像分辨率和显示屏幕是一致的，这意味着在一些高分辨率的设备上可能会造成严重的带宽影响。而且在移动设备上，GrabPass虽然不会重新渲染场景，但它往往需要CPU直接读取后缓冲（back buffer）中的数据，破坏了CPU和GPU之间的并行性，这是比较耗时的，甚至在一些移动设备上这是不支持的。</p>
<p>在Unity5中引入了命令缓冲（Command Buffers）来允许我们扩展Unity的渲染流水线。使用命令缓冲我们也可以得到类似抓屏的效果，它可以在不透明物体渲染后把当前的图像复制到一个临时的渲染目标纹理中，然后在那里进行一些额外的后处理操作（比如模糊等等），最后把图像传递给需要使用它的物体进行处理和显示。详情可参见<a href="https://docs.unity3d.com/Manual/GraphicsCommandBuffers.html" target="_blank" rel="external">Unity官方手册</a>。</p>
<h2 id="程序纹理"><a href="#程序纹理" class="headerlink" title="程序纹理"></a><font size="5" color="red">程序纹理</font></h2><p>程序纹理（Procedural Texture）指的是那些由程序生成的图像，使用程序纹理的好处在于我们可以使用各种参数来控制纹理的外观。</p>
<h3 id="在Unity中实现简单的程序纹理"><a href="#在Unity中实现简单的程序纹理" class="headerlink" title="在Unity中实现简单的程序纹理"></a><font size="4" color="green">在Unity中实现简单的程序纹理</font></h3><p>在场景中新建一个Cube，并把第七章中名为SingleTexture的Shader材质赋给它，但是不给它赋予任何纹理，因为我们要用程序来给它生成一张_MainTex纹理。</p>
<p>然后创建一个脚本ProceduralTextureGeneration.cs，并把它赋给刚创建的Cube。为了让脚本能够在编译器模式下运行（即不运行Game视图），首先在类之前添加如下代码：</p>
<pre class="line-numbers language-c#"><code class="language-c#">[ExecuteInEditMode]
public class ProceduralTextureGeneration : MonoBehaviour
{
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>然后声明一个公有的材质变量，用于把之前创建的材质拖曳进来（同时为了防止忘了把材质拖曳给该属性，在Start函数里自动获取Cube物体上的材质）：</p>
<pre class="line-numbers language-c#"><code class="language-c#">public Material material = null;

    void Start()
    {
        if (material == null)
        {
            Renderer renderer = gameObject.GetComponent<Renderer>();
            if (renderer == null)
            {
                Debug.LogWarning("Cannot find a renderer.");
                return;
            }

            material = renderer.sharedMaterial;
        }

        _UpdateMaterial();
    }
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中<code>_UpdateMaterial</code>函数用于更新材质，后面会详细说明。</p>
<p>然后声明需要用到的纹理宽度、背景颜色、圆点颜色、模糊半径（用来模糊圆形边界）等等参数：</p>
<pre class="line-numbers language-c#"><code class="language-c#">#region Material properties
[SerializeField, SetProperty("textureWidth")]
private int m_textureWidth = 512;
public int textureWidth
{
    get
    {
        return m_textureWidth;
    }
    set
    {
        m_textureWidth = value;
        _UpdateMaterial();
    }
}

[SerializeField, SetProperty("backgroundColor")]
private Color m_backgroundColor = Color.white;
public Color backgroundColor
{
    get
    {
        return m_backgroundColor;
    }
    set
    {
        m_backgroundColor = value;
        _UpdateMaterial();
    }
}

[SerializeField, SetProperty("circleColor")]
private Color m_circleColor = Color.yellow;
public Color circleColor
{
    get
    {
        return m_circleColor;
    }
    set
    {
        m_circleColor = value;
        _UpdateMaterial();
    }
}

[SerializeField, SetProperty("blurFactor")]
private float m_blurFactor = 2.0f;
public float blurFactor
{
    get
    {
        return m_blurFactor;
    }
    set
    {
        m_blurFactor = value;
        _UpdateMaterial();
    }
}
#endregion
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中<code>#region</code>和<code>#endregion</code>仅仅是为了组织代码（折叠代码），并没有其他作用。对每个属性我们都使用了<code>get/set</code>方法，为了在编辑器模式下，在面板上修改属性时也可以自动执行set函数，我们使用了一个开源插件<a href="https://github.com/LMNRY/SetProperty" target="_blank" rel="external">SetProperty</a>（需要把SetPropertyDrawer.cs文件放到Editor文件夹里，把SetPropertyAttribute.cs文件放到任意文件夹里）。这个插件可以让我们修改了材质属性时，可以自动执行<code>set</code>函数，然后在该函数里调用<code>_UpdateMaterial</code>函数来使用新的属性重新生成程序纹理。</p>
<p>然后声明一个Texture2D类型的变量来保存将要生成的程序纹理：</p>
<pre class="line-numbers language-c#"><code class="language-c#">private Texture2D m_generatedTexture = null;
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>在函数<code>_UpdateMaterial</code>里使用<code>_GenerateProceduralTexture</code>函数来生成这张程序纹理<code>m_generatedTexture</code>，同时把该纹理赋给材质的<code>_MainTex</code>属性：</p>
<pre class="line-numbers language-c#"><code class="language-c#">private void _UpdateMaterial()
{
    if (material != null)
    {
        m_generatedTexture = _GenerateProceduralTexture();
        material.SetTexture("_MainTex", m_generatedTexture);
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>下面就是<code>_GenerateProceduralTexture</code>函数：</p>
<pre class="line-numbers language-c#"><code class="language-c#">private Texture2D _GenerateProceduralTexture()
{
    Texture2D proceduralTexture = new Texture2D(textureWidth, textureWidth);

    float circleInterval = textureWidth / 4.0f; //圆之间的间距
    float radius = textureWidth / 10.0f;        //圆的半径
    float edgeBlur = 1.0f / blurFactor;         //模糊比例

    for (int w = 0; w < textureWidth; w++)
    {
        for (int h = 0; h < textureWidth; h++)
        {
            Color pixel = backgroundColor;

            for (int i = 0; i < 3; i++)         //画9个圆
            {
                for (int j = 0; j < 3; j++)
                {
                    Vector2 circleCenter = new Vector2(circleInterval * (i + 1), circleInterval * (j + 1)); //当前圆的中心
                    float dist = Vector2.Distance(new Vector2(w, h), circleCenter) - radius;                //当前像素到圆中心的距离

                    Color color = _MixColor(circleColor, new Color(pixel.r, pixel.g, pixel.b, 0.0f), Mathf.SmoothStep(0f, 1.0f, dist * edgeBlur));  //模糊圆边界

                    pixel = _MixColor(pixel, color, color.a);   //把当前颜色和之前的颜色进行混合
                }
            }

            proceduralTexture.SetPixel(w, h, pixel);
        }
    }

    proceduralTexture.Apply();

    return proceduralTexture;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个代码段里首先初始化了一张二维纹理，并且提前计算了一些生成纹理时需要的变量。然后使用了一个两层的嵌套循环遍历纹理中的每个像素，并在纹理上依次绘制9个圆形。最后调用<code>Texture2D.Apply</code>函数来强制把像素值写入纹理中，并返回该程序纹理。<br>其中<code>_MixColor</code>函数如下：</p>
<pre class="line-numbers language-c#"><code class="language-c#">private Color _MixColor(Color color0, Color color1, float mixFactor)
{
    Color mixColor = Color.white;
    mixColor.r = Mathf.Lerp(color0.r, color1.r, mixFactor);
    mixColor.g = Mathf.Lerp(color0.g, color1.g, mixFactor);
    mixColor.b = Mathf.Lerp(color0.b, color1.b, mixFactor);
    mixColor.a = Mathf.Lerp(color0.a, color1.a, mixFactor);
    return mixColor;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>渲染结果如下图：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/UnityShader%E4%B8%AD%E7%BA%A7%E7%AF%87_19.png?raw=true" alt=""></p>
<h3 id="Unity的程序材质"><a href="#Unity的程序材质" class="headerlink" title="Unity的程序材质"></a><font size="4" color="green">Unity的程序材质</font></h3><p>在Unity中，有一类专门使用程序纹理的材质，叫做程序材质（Procedural Materials）。程序材质和它使用的程序纹理并不是在Unity中创建的，而是使用了一个名为Substance Designer的软件在Unity外部生成的。Unity商店中可以下载到一些Substance材质，导入后，我们可以通过在Inspector视图里调整程序纹理的属性来控制纹理的外观，甚至可以生成看似完全不同的纹理。程序材质的自由度很高，而且可以和Shader配合得到非常出色的视觉效果，是一种非常强大的材质类型。</p>
<h1 id="第十一章-让画面动起来"><a href="#第十一章-让画面动起来" class="headerlink" title="第十一章 让画面动起来"></a><font size="6" color="orange">第十一章 让画面动起来</font></h1><hr>
<h2 id="UnityShader中的内置变量"><a href="#UnityShader中的内置变量" class="headerlink" title="UnityShader中的内置变量"></a><font size="5" color="red">UnityShader中的内置变量</font></h2><p>Unity Shader提供了一些列关于时间的内置变量来允许我们方便地在Shader中访问运行时间，实现各种动画效果：</p>
<table>
<thead>
<tr>
<th style="text-align:left">名称</th>
<th style="text-align:left">类型</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">_Time</td>
<td style="text-align:left">float4</td>
<td style="text-align:left">t是自该场景加载开始所经过的时间，4个分量的值分别是(t/20, t, 2t, 3t)</td>
</tr>
<tr>
<td style="text-align:left">_SinTime</td>
<td style="text-align:left">float4</td>
<td style="text-align:left">t是时间的正弦值，4个分量的值分别是(t/8, t/4, t/2, t)</td>
</tr>
<tr>
<td style="text-align:left"> _CosTime</td>
<td style="text-align:left">float4</td>
<td style="text-align:left">t是时间的余弦值，4个分量的值分别是(t/8, t/4, t/2, t)</td>
</tr>
<tr>
<td style="text-align:left">unity_DeltaTime</td>
<td style="text-align:left">float4</td>
<td style="text-align:left">dt是时间增量，4个分量的值分别是(dt, 1/dt, smoothDt, 1/smoothDt)</td>
</tr>
</tbody>
</table>
<h2 id="纹理动画"><a href="#纹理动画" class="headerlink" title="纹理动画"></a><font size="5" color="red">纹理动画</font></h2><h3 id="序列帧动画"><a href="#序列帧动画" class="headerlink" title="序列帧动画"></a><font size="4" color="green">序列帧动画</font></h3><p>最常见的纹理动画就是序列帧动画。在场景中新建一个Quad，然后提供一张包含了很多关键帧图像的图像：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/UnityShader%E4%B8%AD%E7%BA%A7%E7%AF%87_20.png?raw=true" alt=""><br>接下来就是把这张图片里面的关键字图像依次贴到Quad上，这样就能实现帧序列动画了。关键点就是在shader中按照当前播放的是第几帧来映射UV坐标：把原本Quad的UV坐标映射到小图（即关键字图像）里，否则不映射的话就是直接把整张图像贴到Quad上。</p>
<p>首先在Shader里声明一些属性：</p>
<pre class="line-numbers language-shader"><code class="language-shader">Properties
{
    _Color("Color Tint", Color) = (1, 1, 1, 1)
    _MainTex("Image Sequence", 2D) = "white"{}
    _HorizontalAmount("Horizontal Amount", Float) = 4
    _VerticalAmount("Vertical Amount", Float) = 4
    _Speed("Speed", Range(1, 100)) = 30
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中<code>_HorizontalAmount</code>和<code>_VerticalAmount</code>分别代表了该图像在水平和竖直方向上包含的关键帧图像的个数。而<code>_Speed</code>表示序列帧动画的播放速度，即每秒多少帧。</p>
<p>由于帧序列图像通常都是透明纹理，所以需要在Shader里把相关状态设置为透明：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">SubShader
<span class="token punctuation">{</span>
    Tags <span class="token punctuation">{</span><span class="token string">"Queue"</span> <span class="token operator">=</span> <span class="token string">"Transparent"</span> <span class="token string">"IgnoreProjector"</span> <span class="token operator">=</span> <span class="token string">"True"</span> <span class="token string">"RenderType"</span> <span class="token operator">=</span> <span class="token string">"Transparent"</span><span class="token punctuation">}</span>

    Pass
    <span class="token punctuation">{</span>
        Tags<span class="token punctuation">{</span><span class="token string">"LightMode"</span> <span class="token operator">=</span> <span class="token string">"ForwardBase"</span><span class="token punctuation">}</span>

        ZWrite Off
        Blend SrcAlpha OneMinusSrcAlpha
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>顶点着色器很简单，就是坐标变换和纹理坐标计算：</p>
<pre class="line-numbers language-shader"><code class="language-shader">v2f vert(a2v v)
{
    v2f o;
    o.pos = UnityObjectToClipPos(v.vertex);
    o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);
    return o;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在片元着色器里最重要的就是映射纹理坐标：</p>
<pre class="line-numbers language-shader"><code class="language-shader">fixed4 frag(v2f i) : SV_Target
{
    float currentFrameId = floor(_Time.y * _Speed);
    float row = floor(currentFrameId / _HorizontalAmount);
    float column = currentFrameId - row * _HorizontalAmount;

    //half2 uv = float2(i.uv.x / _HorizontalAmount, i.uv.y / _VerticalAmount);
    //uv.x += column + / _HorizontalAmount;
    //uv.y -= row / _VerticalAmount;
    half2 uv = i.uv + half2(column, -row);
    uv.x /= _HorizontalAmount;
    uv.y /= _VerticalAmount;

    fixed4 c = tex2D(_MainTex, uv);
    c.rgb *= _Color;

    return c;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中映射纹理坐标的那三行代码和注释掉的三行代码功能是一样的，只是在注释的代码的基础上，把加法和除法整合了一下而已。需要注意的是：对竖直方向的坐标偏移需要使用减法，这是因为在Unity中纹理坐标竖直方向的顺序（从下到上逐渐增大）和序列帧纹理的顺序（播放顺序是从上到下）是相反的。</p>
<p>运行之后就可以看到一个爆炸效果了。</p>
<h3 id="滚动的背景"><a href="#滚动的背景" class="headerlink" title="滚动的背景"></a><font size="4" color="green">滚动的背景</font></h3><p>在Quad上面实现一个滚动的背景图片，来模拟出游戏角色在场景中穿梭的感觉。这个实现原理相当简单：让纹理的采样坐标x分量随着时间不断增大（总是截断到0到1之间），这样就能实现出图片滚动播放的感觉了。</p>
<p>首先声明属性：</p>
<pre class="line-numbers language-shader"><code class="language-shader">Properties
{
    _MainTex("Base Layer(RGB)", 2D) = "white"{}
    _DetailTex("2nd Layer(RGB)", 2D) = "white"{}
    _ScrollX("Base layer Scroll Speed", Float) = 1.0
    _Scroll2X("2nd layer Scroll Speed", Float) = 1.0
    _Multiplier("Layer Multiplier", Float) = 1
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中<code>_MainTex</code>和<code>_DetailTex</code>分别是第一层（较远）和第二层（较近）的背景纹理，而<code>_ScrollX</code>和<code>_Scroll2X</code>对应了各自的水平滚动速度，<code>_Multiplier</code>用于控制纹理的整体亮度。</p>
<p>顶点着色器很简单，关键是对纹理坐标加了一个随时间变化的偏移量：</p>
<pre class="line-numbers language-shader"><code class="language-shader">v2f vert(a2v v)
{
    v2f o;
    o.pos = UnityObjectToClipPos(v.vertex);
    o.uv.xy = TRANSFORM_TEX(v.texcoord, _MainTex) + frac(float2(_ScrollX, 0.0) * _Time.y);
    o.uv.zw = TRANSFORM_TEX(v.texcoord, _DetailTex) + frac(float2(_Scroll2X, 0.0) * _Time.y);
    return o;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后片元着色器里对两张背景图片进行混合就可以了：</p>
<pre class="line-numbers language-shader"><code class="language-shader">fixed4 frag(v2f i) : SV_Target
{
    fixed4 firstLayer = tex2D(_MainTex, i.uv.xy);
    fixed4 secondLayer = tex2D(_DetailTex, i.uv.zw);
    float4 color = lerp(firstLayer, secondLayer, secondLayer.a);
    color.rgb *= _Multiplier;
    return color;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>运行之后就可以看到一个滚动的背景了。</p>
<h2 id="顶点动画"><a href="#顶点动画" class="headerlink" title="顶点动画"></a><font size="5" color="red">顶点动画</font></h2><h3 id="流动的河流"><a href="#流动的河流" class="headerlink" title="流动的河流"></a><font size="4" color="green">流动的河流</font></h3><p>河流的模拟是顶点动画最常见的应用之一。它的原理通常就是使用正弦函数等来改变模型原有的顶点位置，来模拟水流的波动效果。</p>
<p>由于本节要模拟的是2D河流效果，因此需要先把摄像机的投影类型设置为正交投影。然后在场景中创建多个Water模型，并为每个模型赋予一个WaterMat材质，每个WaterMat材质都使用名为Water的Shader。首先在Shader里声明需要用到的属性：</p>
<pre class="line-numbers language-shader"><code class="language-shader">Properties
{
    _MainTex("Main Tex", 2D) = "white"{}
    _Color("Color Tint", Color) = (1,1,1,1)
    _Magnitude("Distortion Magnitude", Float) = 1
    _Frequency("Distortion Frequency", Float) = 1
    _InvWaveLength("Distortion Inverse Wave Length", Float) = 10
    _Speed("Speed", Float) = 0.5
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中<code>_MainTex</code>是河流纹理，<code>_Color</code>用于控制整体颜色，<code>_Magnitude</code>用于控制水流波动的幅度，<code>_Frequency</code>用于控制波动频率，<code>_InvWaveLength</code>用于控制波长的倒数，<code>_Speed</code>用于控制河流纹理的移动速度。</p>
<p>然后在SubShader里为透明效果设置合适的SubShader标签：</p>
<pre class="line-numbers language-shader"><code class="language-shader">SubShader
{
    Tags{"Queue" = "Transparent" "IgnoreProjector" = "True" "RenderType" = "Transparent" "DisableBatching" = "True"}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>在上面的标签中，我们除了为透明效果设置Queue、IgnoreProjector和RenderType外，还设置了一个新的标签：DisableBatching。该标签用来控制是否对该SubShader使用批处理。这是因为批处理会合并所有相关的模型，而合并后这些模型各自的模型空间就会丢失，但是后面我们需要在每个单独的Water物体的模型空间下对顶点位置进行偏移，因此在这里需要取消对该Shader的批处理操作。</p>
<p>然后设置Pass的渲染状态，并在顶点着色器里对模型顶点位置用正弦函数进行偏移：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">Pass
<span class="token punctuation">{</span>
    Tags<span class="token punctuation">{</span><span class="token string">"LightMode"</span> <span class="token operator">=</span> <span class="token string">"ForwardBase"</span><span class="token punctuation">}</span>

    ZWrite Off
    Blend SrcAlpha OneMinusSrcAlpha
    Cull Off
    <span class="token comment" spellcheck="true">//...</span>
    v2f <span class="token function">vert</span><span class="token punctuation">(</span>a2v v<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        v2f o<span class="token punctuation">;</span>
        float4 offset<span class="token punctuation">;</span>
        offset<span class="token punctuation">.</span>yzw <span class="token operator">=</span> <span class="token function">float3</span><span class="token punctuation">(</span><span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        offset<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token function">sin</span><span class="token punctuation">(</span>_Frequency <span class="token operator">*</span> _Time<span class="token punctuation">.</span>y <span class="token operator">+</span> v<span class="token punctuation">.</span>vertex<span class="token punctuation">.</span>x <span class="token operator">*</span> _InvWaveLength <span class="token operator">+</span> v<span class="token punctuation">.</span>vertex<span class="token punctuation">.</span>y <span class="token operator">*</span> _InvWaveLength <span class="token operator">+</span> v<span class="token punctuation">.</span>vertex<span class="token punctuation">.</span>z <span class="token operator">*</span> _InvWaveLength<span class="token punctuation">)</span> <span class="token operator">*</span> _Magnitude<span class="token punctuation">;</span>
        o<span class="token punctuation">.</span>pos <span class="token operator">=</span> <span class="token function">UnityObjectToClipPos</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span>vertex <span class="token operator">+</span> offset<span class="token punctuation">)</span><span class="token punctuation">;</span>
        o<span class="token punctuation">.</span>uv <span class="token operator">=</span> <span class="token function">TRANSFORM_TEX</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span>texcoord<span class="token punctuation">,</span> _MainTex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        o<span class="token punctuation">.</span>uv <span class="token operator">+</span><span class="token operator">=</span> <span class="token function">float2</span><span class="token punctuation">(</span><span class="token number">0.0</span><span class="token punctuation">,</span> _Time<span class="token punctuation">.</span>y <span class="token operator">*</span> _Speed<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> o<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    fixed4 <span class="token function">frag</span><span class="token punctuation">(</span>v2f i<span class="token punctuation">)</span> <span class="token operator">:</span> SV_Target
    <span class="token punctuation">{</span>
        fixed4 c <span class="token operator">=</span> <span class="token function">tex2D</span><span class="token punctuation">(</span>_MainTex<span class="token punctuation">,</span> i<span class="token punctuation">.</span>uv<span class="token punctuation">)</span><span class="token punctuation">;</span>
        c<span class="token punctuation">.</span>rgb <span class="token operator">*</span><span class="token operator">=</span> _Color<span class="token punctuation">.</span>rgb<span class="token punctuation">;</span>
        <span class="token keyword">return</span> c<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>计算顶点位移量时，我们只希望对顶点的x方向进行位移，因此offser.yzw被设为0。然后利用<code>_Frequency</code>属性和内置的<code>_Time.y</code>变量来控制正弦函数的频率。为了让不同位置具有不同的位移，我们对上述结果加上了模型空间下的位置分量，并乘以<code>_InvWaveLength</code>来控制波长。最后，我们对结果值乘以<code>_Magnitude</code>来控制波动幅度，得到最终的位移。剩下的工作，我们只需要把位移量添加到顶点位置上，再进行正常的顶点变换就可以了。而且我们还使用<code>_Time.y</code>和<code>_Speed</code>来控制水平方向上的纹理动画。</p>
<p>通过对不同的WaterMat设置不同的参数，可以得到如下图所示的河流效果：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/UnityShader%E4%B8%AD%E7%BA%A7%E7%AF%87_21.png?raw=true" alt=""></p>
<h3 id="广告牌"><a href="#广告牌" class="headerlink" title="广告牌"></a><font size="4" color="green">广告牌</font></h3><p>另一种常见的顶点动画就是广告牌技术（Billboarding）。广告牌技术会根据视角方向来旋转一个被纹理着色的多边形，使得多边形看起来好像总是面对着摄像机。广告牌技术被用于很多应用，比如渲染烟雾、云朵、闪光效果等。广告牌技术的本质就是构建旋转矩阵。</p>
<p>首先声明需要用到的属性：</p>
<pre class="line-numbers language-shader"><code class="language-shader">Properties
{
    _MainTex("Main Tex", 2D) = "white"{}
    _Color("Color Tint", Color) = (1,1,1,1)
    _VerticalBillboarding("Vertical Restraints", Range(0, 1)) = 1
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中<code>_MainTex</code>是广告牌显示的透明纹理，<code>_Color</code>用于控制显示整体颜色，<code>_VerticalBillboarding</code>用于调整是固定法线还是固定指向上的方向，即约束垂直方向的程度。</p>
<p>然后设置合适的SubShader标签，并在顶点着色器中计算广告牌的旋转矩阵（这里设定广告牌绕着自己中心旋转，法线始终朝向观察者）：</p>
<pre class="line-numbers language-shader"><code class="language-shader">SubShader
{
    Tags{"Queue" = "Transparent" "IgnoreProjector" = "True" "RenderType" = "Transparent" "DisableBatching" = "True"}

    Pass
    {
        Tags{"LightMode" = "ForwardBase"}

        ZWrite Off
        Blend SrcAlpha OneMinusSrcAlpha
        Cull Off
        //...
        v2f vert(a2v v)
        {
            v2f o;
            float3 center = float3(0, 0, 0);
            float3 viewer = mul(unity_WorldToObject, float4(_WorldSpaceCameraPos, 1));

            float3 normalDir = viewer - center;
            normalDir.y *= _VerticalBillboarding;    //当_VerticalBillboarding为1时，意味着法线方向固定为视角方向；当_VerticalBillboarding为0时，意味着up方向固定为(0,1,0)
            normalDir = normalize(normalDir);

            float3 upDir = abs(normalDir.y) > 0.999 ? float3(0, 0, 1) : float3(0, 1, 0);
            float3 rightDir = normalize(cross(upDir, normalDir));
            upDir = normalize(cross(normalDir, rightDir));

            float3 centerOffs = v.vertex.xyz - center;
            float3 localPos = center + rightDir * centerOffs.x + upDir * centerOffs.y + normalDir * centerOffs.z;

            o.pos = UnityObjectToClipPos(localPos);
            o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);
            return o;
        }

        fixed4 frag(v2f i) : SV_Target
        {
            fixed4 c = tex2D(_MainTex, i.uv);
            c.rgb *= _Color.rgb;
            return c;
        }
        //...
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上述代码先算出模型空间下的观察向量，将其作为法线向量，然后通过叉乘算出右向量和up向量，通过这个三个正交向量构成的旋转矩阵来算旋转之后的顶点坐标<code>localPos</code>，最后将其转换为裁剪坐标。</p>
<p>其中为了防止法线方向和up方向平行（如果平行，那么叉积得到的结果将是错误的），我们对法线方向的y分量进行了判断（其实应该算法线是不是和up相等，但是因为此时法线是归一化的，并且up向量等于(0,1,0)，所以可以通过法线的y分量是不是等于1.0来等效判断），得到合适的up方向。</p>
<p>运行之后摄像机旋转时，广告牌正面永远朝向摄像机，截图如下：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/UnityShader%E4%B8%AD%E7%BA%A7%E7%AF%87_22.png?raw=true" alt=""></p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><font size="4" color="green">注意事项</font></h3><ul>
<li>如果我们在模型空间下进行了一些顶点动画，那么批处理往往就会破坏这种动画效果。我们可以通过SubShader的DisableBatching标签来强制取消对该Unity Shader的批处理。然而取消批处理会带来一定的性能下降，增加了Draw Call，因此我们应该尽量避免使用模型空间下的一些绝对位置和方向来进行计算。比如在广告牌的例子中，为了避免显式使用模型空间的中心来作为锚点，我们可以利用顶点颜色来存储每个顶点到锚点的距离值，这种做法在商业游戏中很常见。</li>
<li><p>如果我们想要对包含了顶点动画的物体添加阴影，那么如果使用内置的Diffuse等包含的阴影Pass来渲染，就得不到正确的阴影效果（这里指的是无法向其他物体正确地投射阴影）。这是因为，这些内置的ShadowCaster Pass中并没有进行相关的顶点动画，因此仍然会按照原来的顶点位置来计算阴影，当然就得不到正确的阴影。比如使用内置Shader，将之前的河流投射阴影到平面上的效果如下图：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/UnityShader%E4%B8%AD%E7%BA%A7%E7%AF%87_23.png?raw=true" alt=""><br>我们需要提供一个自定义的ShadowCasterPass，在这个Pass中我们将进行同样的顶点变换过程：</p>
<pre class="line-numbers language-shader"><code class="language-shader">  pass
  {
      Tags{"LightMode" = "ShadowCaster"}

      CGPROGRAM

      #pragma vertex vert
      #pragma fragment frag

      #pragma multi_compile_shadowcaster

      #include "UnityCG.cginc"

      float  _Magnitude;
      float  _Frequency;
      float  _InvWaveLength;
      float  _Speed;

      struct v2f
      {
          V2F_SHADOW_CASTER;
      };

      v2f vert(appdata_base v)
      {
          v2f o;
          float4 offset;
          offset.yzw = float3(0, 0, 0);
          offset.x = sin(_Frequency * _Time.y + v.vertex.x * _InvWaveLength + v.vertex.y * _InvWaveLength + v.vertex.z * _InvWaveLength) * _Magnitude;
          v.vertex += offset;
          TRANSFER_SHADOW_CASTER_NORMALOFFSET(o);
          return o;
      }

      fixed4 frag(v2f i) : SV_Target
      {
          SHADOW_CASTER_FRAGMENT(i);
      }

      ENDCG
  }
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>  渲染结果如下图：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/UnityShader%E4%B8%AD%E7%BA%A7%E7%AF%87_24.png?raw=true" alt=""><br>在上面的代码中，我们首先在v2f结构体中利用<code>V2F_SHADOW_CASTER</code>来定义阴影投射需要定义的变量。随后，在顶点着色器中，我们首先按之前对顶点的处理方法计算顶点的偏移量，不同的是，我们直接把偏移值加到顶点位置变量中，再使用<code>TRANSFER_SHADOW_CASTER_NORMALOFFSET</code>来然后Unity为我们完成剩下的事情。在片元着色器中，我们直接使用<code>SHADOW_CASTER_FRAGMENT</code>来让Unity自动完成阴影投射的部分，把结果输出到深度图和阴影映射纹理中。</p>
</li>
</ul>
<hr>
<p>参考文献：《Unity Shader入门精要》</p>

            </div>

            <!-- Post Comments -->
            
    <!-- 使用 DISQUS_CLICK -->
<div id="disqus-comment">
    <div id="disqus_thread"></div>

<!-- add animation -->
<style>
	.disqus_click_btn {
            line-height: 30px;
            margin: 0;
            min-width: 50px;
            padding: 0 14px;
            display: inline-block;
            font-family: "Roboto", "Helvetica", "Arial", sans-serif;
            font-size: 14px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0;
            overflow: hidden;
            will-change: box-shadow;
            transition: box-shadow .2s cubic-bezier(.4, 0, 1, 1), background-color .2s cubic-bezier(.4, 0, .2, 1), color .2s cubic-bezier(.4, 0, .2, 1);
            outline: 0;
            cursor: pointer;
            text-decoration: none;
            text-align: center;
            vertical-align: middle;
            border: 0;
            background: rgba(158, 158, 158, .2);
            box-shadow: 0 2px 2px 0 rgba(0, 0, 0, .14), 0 3px 1px -2px rgba(0, 0, 0, .2), 0 1px 5px 0 rgba(0, 0, 0, .12);
            color: #fff;
            background-color: #7EC0EE;
            text-shadow: 0
        }
</style>
	
<div class="btn_click_load" id="disqus_bt"> 
    <button class="disqus_click_btn">点击查看评论</button>
</div>

<!--
<script type="text/javascript">
$('.btn_click_load').click(function() {
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'http-miccall-tech'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    document.getElementById('disqus_bt').style.display = "none";
});
</script>
-->
<script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://yoursite.com/2019/04/15/Unity-Shader中级篇/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = 'http://yoursite.com/2019/04/15/Unity-Shader中级篇/'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
</script>

<script type="text/javascript">
    $('.btn_click_load').click(function() {  //click to load comments
        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document;
            var s = d.createElement('script');
            s.src = '//http-miccall-tech.disqus.com/embed.js';
            s.setAttribute('data-timestamp', + new Date());
            (d.head || d.body).appendChild(s);
        })();
        $('.btn_click_load').css('display','none');
    });
</script>
</div>
<style>
    #disqus-comment{
        background-color: #eee;
        padding: 2pc;
    }
</style>


        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
                <li>Design: <a href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
            </ul>
            
            	<span id="busuanzi_container_site_pv">2019总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			
        </div>
    </div>
</body>



 	
</html>
