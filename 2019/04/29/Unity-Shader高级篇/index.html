<!DOCTYPE HTML>
<html>

<head><meta name="generator" content="Hexo 3.9.0">
	<link rel="bookmark" type="image/x-icon" href="/img/logo_miccall.png">
	 <link rel="shortcut icon" href="/img/logo_miccall.png">
	
			
    <title>
    Elays'Blog
    </title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <link rel="stylesheet" href="/css/mic_main.css">
    <link rel="stylesheet" href="/css/dropdownMenu.css">
    
    	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css">
    </noscript>
			    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<link rel="stylesheet" href="/css/prism-dark.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>
    
		
<!-- Layouts -->


<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<!--<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">-->
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/latest.js?config=TeX-MML-AM_CHTML">
</script>

	<script>
    (function(){
        if('{{ page.password }}'){
            if (prompt('请输入文章密码') !== '{{ page.password }}'){
                alert('密码错误');
                history.back();
            }
        }
    })();
	</script>

<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_undefined.css">
<link rel="stylesheet" href="/css/typo.css">
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">MICCALL</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special">
            <ul class="menu links">
			<!-- Homepage  主页  --> 
			<li>
	            <a href="/" rel="nofollow">主页</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">分类</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="/categories/C/">C#</a></li><li><a class="category-link" href="/categories/C-语法/">C#语法</a></li><li><a class="category-link" href="/categories/C/">C++</a></li><li><a class="category-link" href="/categories/C语言/">C语言</a></li><li><a class="category-link" href="/categories/Graphics/">Graphics</a></li><li><a class="category-link" href="/categories/Math/">Math</a></li><li><a class="category-link" href="/categories/OpenGL/">OpenGL</a></li><li><a class="category-link" href="/categories/Unity/">Unity</a></li><li><a class="category-link" href="/categories/博客配置/">博客配置</a></li><li><a class="category-link" href="/categories/并行计算/">并行计算</a></li><li><a class="category-link" href="/categories/操作系统/">操作系统</a></li><li><a class="category-link" href="/categories/数据结构/">数据结构</a></li><li><a class="category-link" href="/categories/毕设/">毕设</a></li><li><a class="category-link" href="/categories/游戏开发/">游戏开发</a></li><li><a class="category-link" href="/categories/计算机系统/">计算机系统</a></li><li><a class="category-link" href="/categories/设计模式/">设计模式</a></li><li><a class="category-link" href="/categories/面试/">面试</a>
	                    </li></ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/gallery/" title="图库">
		                图库
		            </a>
		        </li>
		        
		        <li>
		            <a href="/tag/" title="搜索">
		                搜索
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
		            
		                <li><a href="https://github.com/miccall" class="icon fa-github"><span class="label">GitHub</span></a></li>
		            
		            
		            
		            
			</ul>
</nav>

        <div id="main">
            <div class="post_page_title_img" style="height: 25rem;background-image: url(https://github.com/Popperelay/Photos/blob/master/Photos/UnityShader%E9%AB%98%E7%BA%A7%E7%AF%87_BG.png?raw=true);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;">
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2>Unity Shader高级篇</h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
				<!-- 目录 -->
				<p class="show-toc-btn" id="show-toc-btn" onclick="showToc();" style="display:none">
				<span class="btn-bg"></span>
				<span class="btn-text">文章导航</span>
				</p>
				<div id="toc-article" class="toc-article">
					<span id="toc-close" class="toc-close" title="隐藏导航" onclick="showBtn();">×</span>
					<strong class="toc-title">文章目录</strong>
					<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#第十二章-屏幕后处理效果"><span class="toc-text">第十二章 屏幕后处理效果</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#建立一个基本的屏幕后处理脚本系统"><span class="toc-text">建立一个基本的屏幕后处理脚本系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#调整屏幕的亮度、饱和度和对比度"><span class="toc-text">调整屏幕的亮度、饱和度和对比度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#边缘检测"><span class="toc-text">边缘检测</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#高斯模糊"><span class="toc-text">高斯模糊</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bloom效果"><span class="toc-text">Bloom效果</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#运动模糊"><span class="toc-text">运动模糊</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第十三章-使用深度和法线纹理"><span class="toc-text">第十三章 使用深度和法线纹理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#获取深度和法线纹理"><span class="toc-text">获取深度和法线纹理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#背后的原理"><span class="toc-text">背后的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何获取"><span class="toc-text">如何获取</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#再谈运动模糊"><span class="toc-text">再谈运动模糊</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#全局雾效"><span class="toc-text">全局雾效</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#再谈边缘检测"><span class="toc-text">再谈边缘检测</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#扩展阅读"><span class="toc-text">扩展阅读</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第十四章-非真实感渲染"><span class="toc-text">第十四章 非真实感渲染</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#卡通风格的渲染"><span class="toc-text">卡通风格的渲染</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#渲染轮廓线"><span class="toc-text">渲染轮廓线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#添加高光"><span class="toc-text">添加高光</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实现"><span class="toc-text">实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#素描风格的渲染"><span class="toc-text">素描风格的渲染</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#扩展阅读-1"><span class="toc-text">扩展阅读</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第十五章-使用噪声"><span class="toc-text">第十五章 使用噪声</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#消融效果"><span class="toc-text">消融效果</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#水波效果"><span class="toc-text">水波效果</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#扩展阅读-2"><span class="toc-text">扩展阅读</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第十六章-Unity中的渲染优化技术"><span class="toc-text">第十六章 Unity中的渲染优化技术</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#移动平台的特点"><span class="toc-text">移动平台的特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#影响性能的因素"><span class="toc-text">影响性能的因素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Unity中的渲染分析工具"><span class="toc-text">Unity中的渲染分析工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#渲染统计窗口"><span class="toc-text">渲染统计窗口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#性能分析器"><span class="toc-text">性能分析器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#帧调试器"><span class="toc-text">帧调试器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#其他性能分析工具"><span class="toc-text">其他性能分析工具</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#减少draw-call数目"><span class="toc-text">减少draw call数目</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#动态批处理"><span class="toc-text">动态批处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#静态批处理"><span class="toc-text">静态批处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#共享材质"><span class="toc-text">共享材质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#批处理的注意事项"><span class="toc-text">批处理的注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#减少需要处理的顶点数目"><span class="toc-text">减少需要处理的顶点数目</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#优化几何体"><span class="toc-text">优化几何体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#模型的LOD技术"><span class="toc-text">模型的LOD技术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#遮挡剔除技术"><span class="toc-text">遮挡剔除技术</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#减少需要处理的片元数目"><span class="toc-text">减少需要处理的片元数目</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#控制绘制顺序"><span class="toc-text">控制绘制顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#时刻警惕透明物体"><span class="toc-text">时刻警惕透明物体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#减少实时光照和阴影"><span class="toc-text">减少实时光照和阴影</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#节省带宽"><span class="toc-text">节省带宽</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#减少纹理大小"><span class="toc-text">减少纹理大小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#利用分辨率缩放"><span class="toc-text">利用分辨率缩放</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#减少计算复杂度"><span class="toc-text">减少计算复杂度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Shader的LOD技术"><span class="toc-text">Shader的LOD技术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码方面的优化"><span class="toc-text">代码方面的优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#扩展阅读-3"><span class="toc-text">扩展阅读</span></a></li></ol></li></ol>
			   </div>
			   <script type="text/javascript">
				function showToc(){
					var toc_article = document.getElementById("toc-article");
					var show_toc_btn = document.getElementById("show-toc-btn");
					toc_article.setAttribute("style","display:block");
					show_toc_btn.setAttribute("style","display:none");
					};
				function showBtn(){
					var toc_article = document.getElementById("toc-article");
					var show_toc_btn = document.getElementById("show-toc-btn");
					toc_article.setAttribute("style","display:none");
					show_toc_btn.setAttribute("style","display:block");
					};
			   </script>
				
                <h1 id="第十二章-屏幕后处理效果"><a href="#第十二章-屏幕后处理效果" class="headerlink" title="第十二章 屏幕后处理效果"></a><font size="6" color="orange">第十二章 屏幕后处理效果</font></h1><hr>
<h2 id="建立一个基本的屏幕后处理脚本系统"><a href="#建立一个基本的屏幕后处理脚本系统" class="headerlink" title="建立一个基本的屏幕后处理脚本系统"></a><font size="5" color="red">建立一个基本的屏幕后处理脚本系统</font></h2><p>要在Unity中实现屏幕后处理效果，过程通常如下：我们首先需要在<strong>摄像机</strong>中添加一个用于屏幕后处理的脚本。在这个脚本中，我们会实现<code>OnRenderImage</code>函数来获取当前屏幕的渲染纹理。然后，再调用<code>Graphics.Blit</code>函数使用特定的Unity Shader来对当前图像进行处理，再把返回的渲染纹理显示到屏幕上。对于一些复杂的屏幕特效，我们可能需要多次调用Graphics.Blit函数来对上一步的输出结果进行下一步处理。</p>
<p>其中<code>OnRenderImage</code>函数声明如下：</p>
<pre class="line-numbers language-c#"><code class="language-c#">MonoBehaviour.OnRenderImage(RenderTexture src, RenderTexture dest);
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>在脚本中声明此函数后，Unity会把当前渲染得到的图像存储在第一个参数对应的源渲染纹理中，通过函数内一系列操作后，再把第二个参数对应的目标渲染纹理显示到屏幕上。</p>
<p>在<code>OnRenderImage</code>函数中，我们通常是利用<code>Graphics.Blit</code>函数来完成对渲染纹理的处理，它有3种函数声明：</p>
<pre class="line-numbers language-C#"><code class="language-C#">public static void Blit(Texture src, RenderTexture dest);
public static void Blit(Texture src, RenderTexture dest, Material mat, int pass = -1);
public static void Blit(Texture src, Material mat, int pass = -1);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>其中src这个参数通常就是当前屏幕的渲染纹理或是上一步处理后得到的渲染纹理；参数dest是目标渲染纹理，如果它的值为null就会直接将结果显示在屏幕上；参数mat是我们使用的材质，这个材质使用的Unity Shader将会进行各种屏幕后处理操作，而src纹理将会被传递给Shader中名为_MainTex的纹理属性；参数Pass的默认值是-1，表示将会依次调用Shader内的所有Pass。否则，只会调用给定索引的Pass。</p>
<p>默认情况下，<code>OnRenderImage</code>函数会在所有的不透明和透明的Pass执行完毕后被调用，以便对场景中所有游戏对象都产生影响。但有时，我们希望在不透明的Pass（即渲染队列小于等于2500的Pass，内置的Background、Geometry和AlphaTest渲染队列均在此范围内）执行完毕后立即调用<code>OnRenderImage</code>函数，从而不对透明物体产生任何影响。此时我们可以在<code>OnRenderImage</code>函数前添加<code>ImageEffectOpaque</code>属性来实现这样的目的。</p>
<p>不过在进行屏幕后处理之前，我们通常需要检查一系列条件是否满足，例如当前平台是否支持渲染纹理和平面特效，是否支持当前使用的Unity Shader等。为此，我们创建了一个用于屏幕后处理效果的基类，在实现各种屏幕特效时，只需要继承该基类，再实现派生类中不同的操作即可。下面来看一下这个基类的代码（写在PostEffectsBase.cs中）。</p>
<p>由于所有屏幕后处理效果都需要绑定在某个摄像机上，所以我们需要先检查是否有摄像机组件，并且希望脚本在编辑器状态下也可以执行，所以：</p>
<pre class="line-numbers language-c#"><code class="language-c#">[ExecuteInEditMode]
[RequireComponent(typeof(Camera))]
public class PostEffectBase : MonoBehaviour {
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>然后我们在Start函数中调用检查资源和条件是否满足的函数（主要是检查当前平台是否支持图像处理）：</p>
<pre class="line-numbers language-c#"><code class="language-c#">void Start () 
{
    CheckResources();
}

void Update () 
{
}

protected void CheckResources()
{
    bool isSupported = CheckSupport();

    if (isSupported == false)
        NotSupported();
}

protected bool CheckSupport()
{
    if (SystemInfo.supportsImageEffects == false)
    {
        Debug.LogWarning("This platform does not support image effects");
        return false;
    }
    return true;
}

protected void NotSupported()
{
    enabled = false;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>而且我们还需要检查一下是否有绑定Shader来进行后处理（如果已经有Shader对应的material，则直接返回，否则创建一个对应的material）：</p>
<pre class="line-numbers language-c#"><code class="language-c#">protected Material CheckShaderAndCreateMaterial(Shader shader, Material material)
{
    if (shader == null)
        return null;

    if (shader.isSupported && material && material.shader == shader)
        return material;

    if (!shader.isSupported)
        return null;
    else  //有Shader没有Material
    {
        material = new Material(shader);
        material.hideFlags = HideFlags.DontSave;
        if (material)
            return material;
        else
            return null;
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>第一个参数是该特效需要使用的Shader，第二个参数是用于后期处理的材质。</p>
<h2 id="调整屏幕的亮度、饱和度和对比度"><a href="#调整屏幕的亮度、饱和度和对比度" class="headerlink" title="调整屏幕的亮度、饱和度和对比度"></a><font size="5" color="red">调整屏幕的亮度、饱和度和对比度</font></h2><p>首先往场景里拖一张Sprite（纹理精灵），然后创建一个脚本，继承之前的后处理特效基类：</p>
<pre class="line-numbers language-c#"><code class="language-c#">public class BrightnessSaturationAndContrast : PostEffectsBase
{
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>然后声明需要的Shader以及材质属性：</p>
<pre class="line-numbers language-c#"><code class="language-c#">public Shader briSatConShader;
private Material briSatConMaterial;
public Material material
{
    get
    {
        briSatConMaterial = CheckShaderAndCreateMaterial(briSatConShader, briSatConMaterial);
        return briSatConMaterial;
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>briSatConShader</code>是需要的用来做屏幕图像后处理的Shader，可以从编辑器里把对应的Shader拖进来；<code>material</code>其实是一个相当于函数的变量，可以用它在其get函数里调用基类的<code>CheckShaderAndCreateMaterial</code>函数，来创建并返回一个Shader对应的材质。</p>
<p>好需要在脚本里提供亮度、饱和度、对比度等等参数：</p>
<pre class="line-numbers language-c#"><code class="language-c#">[Range(0.0f, 3.0f)]
public float brightness = 1.0f;

[Range(0.0f, 3.0f)]
public float saturation = 1.0f;

[Range(0.0f, 3.0f)]
public float contrast = 1.0f;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中利用Unity提供的Range属性为每个参数提供了合适的变化区间。</p>
<p>最后，我们定义<code>OnRenderImage</code>函数，在其中通过材质来设置对应Shader里的属性，并且该函数会自动把src纹理传给Shader里的<code>_MainTex</code>属性，最后调用<code>Blit</code>函数来把shader处理完的src纹理传给dest纹理，dest纹理会被显示到屏幕上。</p>
<pre class="line-numbers language-c#"><code class="language-c#">void OnRenderImage(RenderTexture src, RenderTexture dest)
{
    if (material != null)
    {
        material.SetFloat("_Brightness", brightness);
        material.SetFloat("_Saturation", saturation);
        material.SetFloat("_Contrast", contrast);

        Graphics.Blit(src, dest, material);
    }
    else
    {
        Graphics.Blit(src, dest);
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后我们定义用于后处理的Shader，首先在Shader里声明需要的纹理、亮度、饱和、对比度等属性：</p>
<pre class="line-numbers language-shader"><code class="language-shader">Properties
{
    _MainTex("Base (RGB)",2D) = "white"{}
    _Brightness("Brightness", Float) = 1
    _Saturation("Saturation", Float) = 1
    _Contrast("Contrast", Float) = 1
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其实这些属性也可以不用声明，因为它们的值都是通过脚本传递给Shader的（即前面脚本中的<code>SetFloat</code>等函数），不需要在材质面板上调整参数。</p>
<p>然后定义用于屏幕后处理的Pass：</p>
<pre class="line-numbers language-shader"><code class="language-shader">SubShader
{
    pass
    {
        ZTest Always Cull Off ZWrite Off
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里关闭深度写入是为了防止它“挡住”在其后面被渲染的物体。这些状态设置可以认为是用于屏幕后处理的Shader的“标配”。</p>
<p>然后声明对应的变量、顶点着色器以及片元着色器：</p>
<pre class="line-numbers language-shader"><code class="language-shader">sampler2D _MainTex;
half _Brightness;
half _Saturation;
half _Contrast;

struct v2f
{
    float4 pos : SV_POSITION;
    half2 uv : TEXCOORD;
};

v2f vert(appdata_img v)
{
    v2f o;
    o.pos = UnityObjectToClipPos(v.vertex);
    o.uv = v.texcoord;
    return o;
}

fixed4 frag(v2f i) : SV_Target
{
    fixed4 srcColor = tex2D(_MainTex, i.uv);
    //使用亮度
    fixed3 finalColor = srcColor.rgb * _Brightness;
    //使用饱和度
    fixed luminance = 0.2125 * srcColor.r + 0.7154 * srcColor.g + 0.0721 * srcColor.b;
    fixed3 luminanceColor = fixed3(luminance, luminance, luminance);    //饱和度为0的颜色
    finalColor = lerp(luminanceColor, finalColor, _Saturation);
    //使用对比度
    fixed3 avgColor = fixed3(0.5, 0.5, 0.5);                            //对比度为0的颜色
    finalColor = lerp(avgColor, finalColor, _Contrast);

    return fixed4(finalColor, srcColor.a);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在顶点着色器里使用了Unity内置的<code>appdata_img</code>结构体作为输入，它只包含了图像处理时必需的顶点坐标和纹理坐标等变量。片元着色器就只是采出源纹理的颜色值，然后乘上了亮度，并且根据饱和度和对比度作了个插值。</p>
<p>调整参数，运行结果如下图：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/UnityShader%E9%AB%98%E7%BA%A7%E7%AF%87_1.png?raw=true]" alt></p>
<h2 id="边缘检测"><a href="#边缘检测" class="headerlink" title="边缘检测"></a><font size="5" color="red">边缘检测</font></h2><p>边缘检测的原理是利用一些边缘检测算子对图像进行卷积（通俗地说，卷积就是对周围像素进行加权求和的过程）。3种常见的边缘检测算子如下：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/UnityShader%E9%AB%98%E7%BA%A7%E7%AF%87_2.png?raw=true" alt><br>我们这里使用Sobel算子来实现边缘检测。和上节类似，先创建一个名为EdgeDetection.cs的脚本，把它拖到摄像机上：</p>
<pre class="line-numbers language-c#"><code class="language-c#">public class EdgeDetection : PostEffectsBase
{
    public Shader edgeDetectionShader;
    private Material edgeDetectionMaterial = null;

    public Material material
    {
        get
        {
            edgeDetectionMaterial = CheckShaderAndCreateMaterial(edgeDetectionShader, edgeDetectionMaterial);
            return edgeDetectionMaterial;
        }
    }

    [Range(0.0f, 1.0f)]
    public float edgesOnly = 0.0f;
    public Color edgeColor = Color.black;
    public Color backgroundColor = Color.white;

    void OnRenderImage(RenderTexture src, RenderTexture dest)
    {
        if (material != null)
        {
            material.SetFloat("_EdgeOnly", edgesOnly);
            material.SetColor("_EdgeColor", edgeColor);
            material.SetColor("_backgroundColor", backgroundColor);

            Graphics.Blit(src, dest, material);
        }
        else
        {
            Graphics.Blit(src, dest);
        }
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中，那三个变量分别用于调整边缘线和背景色的混合程度、描边颜色、纯背景色。当<code>edgesOnly</code>为1时，则会只显示边缘。</p>
<p>然后我们定义用于实现边缘检测的Shader，首先设置需要用到的属性：</p>
<pre class="line-numbers language-shader"><code class="language-shader">Properties
{
    _MainTex ("Base (RGB)", 2D) = "white" {}
    _EdgeOnly("Edge Only", Float) = 1.0
    _EdgeColor("Edge Color", Color) = (0, 0, 0, 1)
    _BackgroundColor("Background Color", Color) = (1, 1, 1, 1)
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后设置Pass的渲染状态、声明变量并在顶点着色器中计算纹理坐标：</p>
<pre class="line-numbers language-shader"><code class="language-shader">SubShader
{
    pass
    {
        ZTest Always Cull Off ZWrite Off
        //...
        sampler2D _MainTex;
        half4  _MainTex_TexelSize;
        fixed  _EdgeOnly;
        fixed4 _EdgeColor;
        fixed4 _BackgroundColor;

        struct v2f
        {
            float4 pos : SV_POSITION;
            half2  uv[9] : TEXCOORD0;
        };

        v2f vert(appdata_img v)
        {
            v2f o;
            o.pos = UnityObjectToClipPos(v.vertex);
            half2 uv = v.texcoord;
            o.uv[0] = uv + _MainTex_TexelSize.xy * half2(-1, -1);
            o.uv[1] = uv + _MainTex_TexelSize.xy * half2(0, -1);
            o.uv[2] = uv + _MainTex_TexelSize.xy * half2(1, -1);
            o.uv[3] = uv + _MainTex_TexelSize.xy * half2(-1, 0);
            o.uv[4] = uv + _MainTex_TexelSize.xy * half2(0, 0);
            o.uv[5] = uv + _MainTex_TexelSize.xy * half2(1, 0);
            o.uv[6] = uv + _MainTex_TexelSize.xy * half2(-1, 1);
            o.uv[7] = uv + _MainTex_TexelSize.xy * half2(0, 1);
            o.uv[8] = uv + _MainTex_TexelSize.xy * half2(1, 1);
            return o;
        }
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中<code>_MainTex_TexelSize</code>是Unity为我们提供的访问对应纹理的纹素大小。由于卷积需要对相邻区域内的纹理进行采样，因此我们需要利用<code>_MainTex_TexelSize</code>来计算相邻区域的纹理坐标。在<code>v2f</code>结构体中定义的纹理坐标数组，用来存储使用Sobel算子采样时需要的9个领域纹理坐标。</p>
<p>然后片元着色器：</p>
<pre class="line-numbers language-shader"><code class="language-shader">fixed luminance(fixed4 color)
{
    return 0.2125 * color.r + 0.7154 * color.g + 0.0721 * color.b;
}

half Sobel(v2f i)
{
    const half Gx[9] = 
    {
        -1, -2, -1,
            0,  0,  0,
            1,  2,  1
    };
    const half Gy[9] = 
    {
        -1,  0,  1,
        -2,  0,  2,
        -1,  0,  1
    };
    half texColor;
    half edgeX = 0;
    half edgeY = 0;
    for(int j = 0; j < 9; ++j)
    {
        texColor = luminance(tex2D(_MainTex, i.uv[j]));
        edgeX += texColor * Gx[j];
        edgeY += texColor * Gy[j];
    }
    half edge = 1 - abs(edgeX) - abs(edgeY);
    return edge;
}

fixed4 frag(v2f i) : SV_Target
{
    half edge = Sobel(i);
    fixed4 withEdgeColor = lerp(_EdgeColor, tex2D(_MainTex, i.uv[4]), edge);
    fixed4 onlyEdgeColor = lerp(_EdgeColor, _BackgroundColor, edge);
    return lerp(withEdgeColor, onlyEdgeColor, _EdgeOnly);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>首先定义了水平方向和竖直方向使用的卷积核Gx和Gy，接着依次对9个像素进行采样，计算它们的亮度值，再与卷积核Gx和Gy中对应的权重相乘后，叠加到各自的梯度值上。最后用1减去水平方向和竖直方向的梯度值的绝对值，得到edge。edge值越小，表面该位置越可能是一个边缘点。然后利用edge值分别计算了背景为原图和纯色下的颜色值，然后利用<code>_EdgeOnly</code>在两者之间插值得到最终的像素值。当edgeOnly参数为1时渲染结果如下图：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/UnityShader%E9%AB%98%E7%BA%A7%E7%AF%87_3.png?raw=true" alt><br>需要注意的是，这里实现的边缘检测仅仅利用了屏幕颜色信息，而在实际应用中，物体的纹理、阴影等信息均会影响边缘检测的结果，使得结果包含许多非预期的描边。为了得到更加准确的边缘信息，我们往往会在屏幕的深度纹理和法线纹理上进行边缘检测。详见下一章。</p>
<h2 id="高斯模糊"><a href="#高斯模糊" class="headerlink" title="高斯模糊"></a><font size="5" color="red">高斯模糊</font></h2><p>首先定义GaussianBlur.cs脚本，把它拖到摄像机上：</p>
<pre class="line-numbers language-c#"><code class="language-c#">public class GuassianBlur : PostEffectsBase
{
    public Shader gaussianBlurShader;
    private Material gaussianBlurMaterial = null;

    public Material material
    {
        get
        {
            gaussianBlurMaterial = CheckShaderAndCreateMaterial(gaussianBlurShader, gaussianBlurMaterial);
            return gaussianBlurMaterial;
        }
    }

    [Range(0, 4)]
    public int iterations = 3;

    [Range(0.2f, 0.3f)]
    public float blurSpread = 0.6f;

    [Range(1, 8)]
    public int downSmaple = 2;

    void OnRenderImage(RenderTexture src, RenderTexture dest)
    {
        if (material != null)
        {
            int rtW = src.width / downSmaple;
            int rtH = src.height / downSmaple;
            RenderTexture tmpRenderTexture0 = RenderTexture.GetTemporary(rtW, rtH, 0);
            tmpRenderTexture0.filterMode = FilterMode.Bilinear;

            Graphics.Blit(src, tmpRenderTexture0);

            for (int i = 0; i < iterations; ++i)
            {
                material.SetFloat("_BlurSize", 1.0f + i * blurSpread);

                RenderTexture tmpRenderTexture1 = RenderTexture.GetTemporary(rtW, rtH, 0);

                Graphics.Blit(tmpRenderTexture0, tmpRenderTexture1, material, 0);   //render the vertical pass

                RenderTexture.ReleaseTemporary(tmpRenderTexture0);
                tmpRenderTexture0 = tmpRenderTexture1;
                tmpRenderTexture1 = RenderTexture.GetTemporary(rtW, rtH, 0);

                Graphics.Blit(tmpRenderTexture0, tmpRenderTexture1, material, 1);   //render the horizontal pass

                RenderTexture.ReleaseTemporary(tmpRenderTexture0);
                tmpRenderTexture0 = tmpRenderTexture1;
            }

            Graphics.Blit(tmpRenderTexture0, dest);
            RenderTexture.ReleaseTemporary(tmpRenderTexture0);
        }
        else
        {
            Graphics.Blit(src, dest);
        }
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中<code>iterations</code>表示高斯模糊迭代次数；<code>blurSpread</code>表示模糊范围，它和后面Shader中的<code>_BlurSize</code>对应，<code>_BlurSize</code>越大，模糊程度越高，但采样数不会受到影响，但过大的<code>_BlurSize</code>值会造成虚影；<code>downSmaple</code>表示对原图像的降采样系数（即把原图像缩小为原来的downSmaple倍），该值越大，需要处理的像素数越少，同时也能进一步提高模糊程度，但过大的downSmaple可能会使图像像素化。</p>
<p>在<code>OnRenderImage</code>函数里，我们首先使用<code>downSmaple</code>来缩放原图像大小，然后使用缩放之后的大小和<code>RenderTexture.GetTemporary</code>函数来分配一块大小匹配的临时渲染纹理（这比直接使用和原图像等大的临时渲染纹理，会减少需要高斯处理的像素个数，提高性能，而且适当的降采样往往还可以得到更好的模糊效果）。并且需要把该临时渲染纹理的滤波模式设置为双线性。然后我们把src中的图像缩放后存储到tmpRenderTexture0中。然后在循环迭代里利用两个临时渲染纹理交替进行多次高斯模糊。在迭代过程中，首先定义了第二个临时渲染纹理tmpRenderTexture1，在执行第一个Pass时，输入是tmpRenderTexture0，输出是tmpRenderTexture1，完毕后首先把tmpRenderTexture0释放，再把结果值tmpRenderTexture1存储到tmpRenderTexture0中，再重新分配tmpRenderTexture1，然后再调用第二个Pass，重复上述过程。迭代完成后，tmpRenderTexture0将存储最终的图像，最后利用<code>Graphics.Blit(tmpRenderTexture0, dest);</code>把结果显示到屏幕上，并释放缓存。</p>
<p>接下来定义高斯模糊的Shader，首先声明需要用到的属性：</p>
<pre class="line-numbers language-shader"><code class="language-shader">Properties
{
    _MainTex("Base (RGB)", 2D) = "white"{}
    _BlurSize("Blur Size", Float) = 1.0
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>由于第一个Pass（纵向高斯模糊）和第二个Pass（横向高斯模糊）的片元着色器是一模一样的，所以为了避免代码重复，我们可以先把CG代码写到类似头文件的地方：即SubShader里定义在<code>CGINCLUDE</code>和<code>ENDCG</code>之间的代码，可以被复用到各个Pass里（通过函数或者变量名字复用）：</p>
<pre class="line-numbers language-shader"><code class="language-shader">SubShader
{
    CGINCLUDE

    #include "UnityCG.cginc"

    sampler2D _MainTex;
    half4 _MainTex_TexelSize;
    float _BlurSize;

    struct v2f
    {
        float4 pos : SV_POSITION;
        half2  uv[5] : TEXCOORD0;
    };

    v2f vertBlurVertical(appdata_img v)
    {
        v2f o;
        o.pos = UnityObjectToClipPos(v.vertex);
        half2 uv = v.texcoord;
        o.uv[0] = uv;
        o.uv[1] = uv + float2(0.0, _MainTex_TexelSize.y * 1.0) * _BlurSize;
        o.uv[2] = uv - float2(0.0, _MainTex_TexelSize.y * 1.0) * _BlurSize;
        o.uv[3] = uv + float2(0.0, _MainTex_TexelSize.y * 2.0) * _BlurSize;
        o.uv[4] = uv - float2(0.0, _MainTex_TexelSize.y * 2.0) * _BlurSize;
        return o;
    }

    v2f vertBlurHorizontal(appdata_img v)
    {
        v2f o;
        o.pos = UnityObjectToClipPos(v.vertex);
        half2 uv = v.texcoord;
        o.uv[0] = uv;
        o.uv[1] = uv + float2(_MainTex_TexelSize.x * 1.0, 0.0) * _BlurSize;
        o.uv[2] = uv - float2(_MainTex_TexelSize.x * 1.0, 0.0) * _BlurSize;
        o.uv[3] = uv + float2(_MainTex_TexelSize.x * 2.0, 0.0) * _BlurSize;
        o.uv[4] = uv - float2(_MainTex_TexelSize.x * 2.0, 0.0) * _BlurSize;
        return o;
    }

    fixed4 fragBlur(v2f i) : SV_Target
    {
        float weight[3] = {0.4026, 0.2442, 0.0545};
        fixed3 sum = tex2D(_MainTex, i.uv[0]).rgb * weight[0];
        for(int j = 1; j < 3; ++j)
        {
            sum += tex2D(_MainTex, i.uv[j * 2 - 1]).rgb * weight[j];
            sum += tex2D(_MainTex, i.uv[j * 2]).rgb * weight[j];
        }
        return fixed4(sum ,1.0);
    }

    ENDCG
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面我们定义了用于横向高斯模糊和纵向高斯模糊的顶点着色器函数，以及两个Pass会共用的片元着色器函数。而且其中还对纹理坐标偏移量乘了一个属性<code>_BlurSize</code>来控制采样距离。在高斯核维数不变的情况下，<code>_BlurSize</code>越大，模糊程度越大，但采样数却不会受到影响，但过大的<code>_BlurSize</code>值会造成虚影，这可能并不是我们想要的。</p>
<p>接下来就可以在两个Pass里通过函数名复用顶点着色器函数和片元着色器函数了：</p>
<pre class="line-numbers language-shader"><code class="language-shader">ZTest Always Cull Off ZWrite Off

pass
{
    NAME "GAUSSIAN_BLUR_VERTICAL"

    CGPROGRAM

    #pragma vertex vertBlurVertical
    #pragma fragment fragBlur

    ENDCG
}

pass
{
    NAME "GAUSSIAN_BLUR_HORIZONTAL"

    CGPROGRAM

    #pragma vertex vertBlurHorizontal
    #pragma fragment fragBlur

    ENDCG
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中我们为两个Pass使用了NAME语义定义了Pass的名字，这是为了在其他Shader中可以直接通过它们的名字来使用该Pass，而不需要再重复编写代码（后面的很多屏幕特效都是基于高斯模糊的）。渲染结果如下图：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/UnityShader%E9%AB%98%E7%BA%A7%E7%AF%87_4.png?raw=true" alt></p>
<h2 id="Bloom效果"><a href="#Bloom效果" class="headerlink" title="Bloom效果"></a><font size="5" color="red">Bloom效果</font></h2><p>首先创建Bloom.cs脚本，由于Bloom效果是建立在高斯模糊的基础上的，所以相比于高斯模糊，它只是多了一个新的参数<code>luminanceThrehold</code>来控制提取较亮区域时使用的阈值大小：</p>
<pre class="line-numbers language-c#"><code class="language-c#">public class Bloom : PostEffectsBase
{
    public Shader bloomShader;
    private Material bloomMaterial = null;

    public Material material
    {
        get
        {
            bloomMaterial = CheckShaderAndCreateMaterial(bloomShader, bloomMaterial);
            return bloomMaterial;
        }
    }

    [Range(0, 4)]
    public int iterations = 3;

    [Range(0.2f, 3.0f)]
    public float blurSpread = 0.6f;

    [Range(1, 8)]
    public int downSample = 2;

    [Range(0.0f, 4.0f)]
    public float luminanceThrehold = 0.6f;

    void OnRenderImage(RenderTexture src, RenderTexture dest)
    {
        if (material != null)
        {
            material.SetFloat("_LuminanceThreshold", luminanceThrehold);

            int rtW = src.width / downSample;
            int rtH = src.height / downSample;

            RenderTexture buffer0 = RenderTexture.GetTemporary(rtW, rtH, 0);
            buffer0.filterMode = FilterMode.Bilinear;

            Graphics.Blit(src, buffer0, material, 0);

            for (int i = 0; i < iterations; ++i)
            {
                material.SetFloat("_BlurSize", 1.0f + i * blurSpread);

                RenderTexture buffer1 = RenderTexture.GetTemporary(rtW, rtH, 0);

                Graphics.Blit(buffer0, buffer1, material, 1);   // Render the vertical pass

                RenderTexture.ReleaseTemporary(buffer0);
                buffer0 = buffer1;
                buffer1 = RenderTexture.GetTemporary(rtW, rtH, 0);

                Graphics.Blit(buffer0, buffer1, material, 2);   // Render the horizontal pass

                RenderTexture.ReleaseTemporary(buffer0);
                buffer0 = buffer1;
            }

            material.SetTexture("_Bloom", buffer0);
            Graphics.Blit(src, dest, material, 3);
            RenderTexture.ReleaseTemporary(buffer0);
        }
        else
        {
            Graphics.Blit(src, dest);
        }
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个脚本和高斯模糊的只有些许不同。因为Bloom效果需要3个步骤：1. 提取图像中较亮的区域，所以第一次调用Blit时，就传入了material，使用其Shader中的第一个Pass来提取图像中的较亮区域，将提取到的较亮区域存储到buffer0中（而高斯模糊只是单纯的调用Blit函数，没有执行shader，只是做了一个图像缩小的降采样而已）；2. 然后和高斯模糊一样把较亮区域进行高斯模糊迭代处理，对应Shader中的第2个和第3个Pass，模糊后的结果会存储在buffer0中；3. 把buffer0中模糊后的渲染纹理传递给Shader中的<code>_Bloom</code>纹理属性，然后调用第4个Pass来混合原始纹理（即<code>_MainTex</code>纹理（传的是<code>src</code>））和模糊后的高亮纹理（即<code>_Bloom</code>纹理），将混合后的结果存储到dest中，并释放临时渲染纹理buffer0。</p>
<p>然后是创建用于实现Bloom效果的Shader，首先定义用于提取较亮区域的顶点着色器和片元着色器（在<code>CGINCLUDE</code>和<code>ENDCG</code>之间定义）：</p>
<pre class="line-numbers language-shader"><code class="language-shader">struct v2f
{
    float4 pos : SV_POSITION;
    half2  uv : TEXCOORD0;
};

v2f vertExtractBright(appdata_img v)
{
    v2f o;
    o.pos = UnityObjectToClipPos(v.vertex);
    o.uv = v.texcoord;
    return o;
}

fixed luminance(fixed4 color)
{
    return 0.2125 * color.r + 0.7154 * color.g + 0.0721 * color.b;
}

fixed4 fragExtractBright(v2f i) : SV_Target
{
    fixed4 c = tex2D(_MainTex, i.uv);
    fixed val = clamp(luminance(c) - _LuminanceThreshold, 0.0, 1.0);
    return c * val;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在片元着色器中，我们将采样得到的亮度值将去阈值<code>_LuminanceThreshold</code>，并把结果截取到0~1范围内。然后把该值和原像素值相乘得到提取后的亮部区域。</p>
<p>高斯模糊的顶点着色器和片元着色器可以复用之前的代码，就不重复定义了。那接下来定义混合亮部图像和原图像的顶点着色器和片元着色器（在<code>CGINCLUDE</code>和<code>ENDCG</code>之间定义）：</p>
<pre class="line-numbers language-shader"><code class="language-shader">struct v2fBloom
{
    float4 pos : SV_POSITION;
    half4 uv : TEXCOORD0;
};

v2fBloom vertBloom(appdata_img v)
{
    v2fBloom o;
    o.pos = UnityObjectToClipPos(v.vertex);
    o.uv.xy = v.texcoord;
    o.uv.zw = v.texcoord;

    #if UNITY_UV_STARTS_AT_TOP
    if(_MainTex_TexelSize.y < 0.0)
        o.uv.w = 1.0 - o.uv.w;
    #endif    

    return o;
}

fixed4 fragBloom(v2fBloom i) : SV_Target
{
    return tex2D(_MainTex, i.uv.xy) + tex2D(_Bloom, i.uv.zw);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中变量<code>uv</code>的xy分量对应了_MainTex，即原图像的纹理坐标；而它的zw分量对应_Bloom，即模糊后的较亮区域的纹理坐标。我们需要对这个纹理坐标进行平台差异化处理（这个初级篇有讲过）。</p>
<p>然后就可以用这些定义好的顶点着色器和片元着色器来定义Bloom效果需要的4个Pass了：</p>
<pre class="line-numbers language-shader"><code class="language-shader">ZTest Always Cull Off ZWrite Off

Pass
{
    CGPROGRAM

    #pragma vertex vertExtractBright
    #pragma fragment fragExtractBright

    ENDCG
}

UsePass "Unity Shaders Book/Chapter 12/GaussianBlur/GAUSSIAN_BLUR_VERTICAL"
UsePass "Unity Shaders Book/Chapter 12/GaussianBlur/GAUSSIAN_BLUR_HORIZONTAL"

pass
{
    CGPROGRAM

    #pragma vertex vertBloom
    #pragma fragment fragBloom

    ENDCG
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中，第二个和第三个Pass我们直接使用高斯模糊的Shader中定义的两个Pass，这是通过UsePass语义指明它们的Pass名来实现的。需要注意的是，由于Unity内部会把所有Pass的Name转换成大写字母表示，因此在使用UsePass命令时必须使用大写形式的名字。渲染结果如下图：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/UnityShader%E9%AB%98%E7%BA%A7%E7%AF%87_5.png?raw=true" alt></p>
<h2 id="运动模糊"><a href="#运动模糊" class="headerlink" title="运动模糊"></a><font size="5" color="red">运动模糊</font></h2><p>运动模糊的实现有多种方法：</p>
<ul>
<li>一种是使用累积缓存（accumulation buffer）来混合多张连续的图像。当物体快速移动产生多张图像后，我们取它们之间的平均值作为最后的运动模糊图像。显示，这个性能开销很大，因为一帧里要多次渲染场景。</li>
<li>另一种是使用速度缓存（velocity buffer），这个缓存中存储了各个像素当前的运动速度，然后利用该值来决定模糊的方向和大小。</li>
</ul>
<p>我们接下来使用第一种方法来实现运动模糊，不同的是：不需要在一帧中把场景渲染多次，而是保存之前的渲染结果，不断把当前的渲染图像叠加到之前的渲染图像中，从而产生一种运动轨迹的视觉效果。这种方法与原始的累积缓存的方法相比性能更好，但模糊效果可能会略有影响。</p>
<p>首先把中级篇中创建的Translating.cs脚本赋给摄像机，然后创建脚本MotionBlur.cs：</p>
<pre class="line-numbers language-c#"><code class="language-c#">public class MotionBlur : PostEffectsBase
{
    public Shader motionBlurShader;
    private Material motionBlurMaterial = null;

    public Material material
    {
        get
        {
            motionBlurMaterial = CheckShaderAndCreateMaterial(motionBlurShader, motionBlurMaterial);
            return motionBlurMaterial;
        }
    }

    [Range(0.0f, 0.9f)]
    public float blurAmount = 0.5f;

    private RenderTexture accumulationTexture;

    void OnDisable()
    {
        DestroyImmediate(accumulationTexture);
    }

    void OnRenderImage(RenderTexture src, RenderTexture dest)
    {
        if (material != null)
        {
            //创建累积缓存纹理
            if (accumulationTexture == null || accumulationTexture.width != src.width ||
                accumulationTexture.height != src.height)
            {
                DestroyImmediate(accumulationTexture);
                accumulationTexture = new RenderTexture(src.width, src.height, 0);
                accumulationTexture.hideFlags = HideFlags.HideAndDontSave;
                Graphics.Blit(src, accumulationTexture);
            }
            accumulationTexture.MarkRestoreExpected();

            material.SetFloat("_BlurAmount", 1.0f - blurAmount);

            Graphics.Blit(src, accumulationTexture, material);
            Graphics.Blit(accumulationTexture, dest);
        }
        else
        {
            Graphics.Blit(src, dest);
        }
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中<code>blurAmount</code>用于当前帧图像和累积缓存纹理的混合比例，该值越大，运动拖尾的效果就越明显，为了防止拖尾效果完全替代当前帧的渲染结果，我们把它的值截取在0.0~0.9范围内。<code>accumulationTexture</code>就是我们定义的累积缓存纹理，用来保存之前图像叠加的结果。我们设置在脚本不运行时（即调用OnDisable函数时），立即销毁<code>accumulationTexture</code>，因为我们希望在下一次开始应用运动模糊时重新叠加图像（即重新声明该累积缓存纹理）。并且由于我们自己控制它的销毁，所以可以把它的<code>hideFlags</code>设置为<code>HideFlags.HideAndDontSave</code>，这意味着这个变量不会显示在Hierarchy中，也不会保存到场景中。</p>
<p>有了有效的<code>accumulationTexture</code>后，调用了<code>accumulationTexture.MarkRestoreExpected()</code>函数是在对渲染纹理执行一个恢复操作，其实就是让<code>accumulationTexture</code>不要被清空，因为它保存了我们之前的混合结果。然后调用<code>Blit</code>在Shader里把当前帧图像src的RGB分量混合到累积缓存纹理<code>accumulationTexture</code>里，最后再把累积缓存纹理里的结果转存到dest里。</p>
<p>下面来看一下运动模糊的Shader是如何将src纹理混合到<code>accumulationTexture</code>里的：</p>
<pre class="line-numbers language-shader"><code class="language-shader">SubShader
{
    CGINCLUDE

    #include "UnityCG.cginc"

    sampler2D _MainTex;
    fixed _BlurAmount;

    struct v2f
    {
        float4 pos : SV_POSITION;
        half2 uv : TEXCOORD0;
    };

    v2f vert(appdata_img v)
    {
        v2f o;
        o.pos = UnityObjectToClipPos(v.vertex);
        o.uv = v.texcoord;
        return o;
    }

    fixed4 fragRGB(v2f i) : SV_Target
    {
        return fixed4(tex2D(_MainTex, i.uv).rgb, _BlurAmount);
    }

    fixed4 fragA(v2f i) : SV_Target
    {
        return tex2D(_MainTex, i.uv);
    }

    ENDCG    

    ZTest Always Cull Off ZWrite Off

    Pass
    {
        Blend SrcAlpha OneMinusSrcAlpha
        ColorMask RGB

        CGPROGRAM

        #pragma vertex vert
        #pragma fragment fragRGB

        ENDCG
    }

    Pass
    {
        Blend One Zero
        ColorMask A

        CGPROGRAM

        #pragma vertex vert
        #pragma fragment fragA

        ENDCG
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到主要是定义了两个Pass，一个使用<code>_BlurAmount</code>作为alpha值来混合更新目标缓存（即累积缓存纹理<code>accumulationTexture</code>）的RGB通道，另一个Pass就是用src纹理的alpha值直接覆盖目标缓存的alpha值（因为是<code>Blend One Zero</code>）。渲染结果如下图：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/UnityShader%E9%AB%98%E7%BA%A7%E7%AF%87_6.png?raw=true" alt><br>这里只是对运动模糊的一种简单实现。我们混合了连续帧之间的图像，这样得到一张具有模糊拖尾的图像。但是，当物体运动速度过快时，得不到较好的模糊效果。下一章会看到如何利用深度纹理重建速度来模拟运动模糊效果。</p>
<p>我们还可以在Unity的<a href="https://docs.unity3d.com/Manual/PostProcessingOverview.html" target="_blank" rel="noopener">Image Effect</a>包中找到更多屏幕特效的实现。<a href="https://developer.nvidia.com/gpugems/GPUGems/gpugems_pref01.html" target="_blank" rel="noopener">GPU Gems系列</a>中也介绍了很多基于图像处理的渲染技术。</p>
<h1 id="第十三章-使用深度和法线纹理"><a href="#第十三章-使用深度和法线纹理" class="headerlink" title="第十三章 使用深度和法线纹理"></a><font size="6" color="orange">第十三章 使用深度和法线纹理</font></h1><hr>
<h2 id="获取深度和法线纹理"><a href="#获取深度和法线纹理" class="headerlink" title="获取深度和法线纹理"></a><font size="5" color="red">获取深度和法线纹理</font></h2><h3 id="背后的原理"><a href="#背后的原理" class="headerlink" title="背后的原理"></a><font size="4" color="green">背后的原理</font></h3><p>当使用延迟渲染路径时，深度纹理和法线纹理可以很容易访问到，因为延迟渲染会把这些信息渲染到G-buffer中。而当无法直接获取深度缓存时，比如前向渲染，深度和法线纹理是通过一个单独的Pass渲染得到的。具体实现是，Unity会使用着色器替换（Shader Replacement）技术选择那些渲染类型（即SubShader的RenderType标签）为Opaque的物体，判断它们使用的渲染队列是否小于等于2500（内置的Background、Geometry和AlphaTest渲染队列均在此范围内），如果满足条件，就把它渲染到深度和法线纹理中。针对前向渲染，如果只是要深度纹理，Unity会把选出来的不透明物体，使用投射阴影时使用的ShadowCasterPass来渲染得到深度纹理；如果还要法线纹理，因为前向渲染默认情况下是不会创建法线缓存的，所Unity底层使用了一个单独的Pass把整个场景再次渲染一遍来得到法线纹理（这个Pass被包含在内置的built_shaders-xxx/DefaultResources/Camera-DepthNormalTexture.shader文件中）。</p>
<h3 id="如何获取"><a href="#如何获取" class="headerlink" title="如何获取"></a><font size="4" color="green">如何获取</font></h3><p>在Unity中要获取深度纹理需要两个步骤：首先在脚本里设置摄像机的<code>depthTextureMode</code>：</p>
<pre class="line-numbers language-c#"><code class="language-c#">camera.depthTextureMode = DepthTextureMode.Depth;
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>然后在Shader里声明<code>_CameraDepthTexture</code>变量来访问它。</p>
<p>类似地，如果需要获取深度法线纹理需要先在脚本里将摄像机的<code>depthTextureMode</code>设置为<code>DepthTextureMode.DepthNormals</code>，然后在Shader里声明<code>_CameraDepthNormalsTexture</code>变量来访问它。</p>
<p>对于深度纹理，大多数情况下，我们可以直接使用<code>tex2D</code>函数来直接采样，但在某些平台（例如PS3和PSP2）上，需要一些特殊处理。所以Unity为我们提供了一个统一的宏<code>SAMPLE_DEPTH_TEXTURE</code>来对深度纹理进行采样（宏内部已经处理了平台差异）。例如：</p>
<pre class="line-numbers language-shader"><code class="language-shader">float d = SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, i.uv);
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>深度纹理中存储的通常都是非线性的。Unity提供了两个辅助函数来帮助我们将深度纹理中非线性的深度值转换为观察空间下的线性深度值：<code>LinearEyeDepth</code>和<code>Linear01Depth</code>。前者得到的是观察空间下的深度值，后者得到的是观察空间深度值归一化之后的结果（范围在0~1之间）。</p>
<p>对于深度+法线纹理，由于Unity是把法线信息编码进RG通道，把深度信息编码进BA通道，我们直接使用tex2D采样得到的是编码后的法线和深度值。不过Unity为我们提供了辅助函数<code>DecodeDepthNormal</code>来对采样结果进行解码，从而得到独立的深度值和法线方向。需要注意的是，该函数解码得到的是观察空间下的法线值，以及观察空间下归一化之后的线性深度值。该函数的内部实现如下：</p>
<pre class="line-numbers language-shader"><code class="language-shader">inline void DecodeDepthNormal(float4 enc, out float depth, out float3 normal)
{
    depth = DecodeFloatRG(enc.zw);
    normal = DecodeViewNormalStereo(enc);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="再谈运动模糊"><a href="#再谈运动模糊" class="headerlink" title="再谈运动模糊"></a><font size="5" color="red">再谈运动模糊</font></h2><p>之前我们通过混合多张屏幕图像来模拟运动模糊的效果，但是由于性能和效果不是很理想。另一种应用更加广泛的技术是使用速度映射图。速度映射图中存储了每个像素的速度，然后使用这个速度来决定模糊的方向和大小。生成速度映射图的原理如下：<br>首先利用深度纹理和当前的VP逆矩阵（即$(观察矩阵\times投影矩阵)^{-1}$）来得到像素在世界空间中的顶点坐标，然后利用上一帧的VP矩阵来得到这个这个点在上一帧中的NDC坐标。然后我们就可以计算出前一帧和当前帧的NDC位置之差，从而生成该像素的速度。这种方法的优点是可以在一个屏幕后处理步骤中完成整个效果的模拟，但缺点是需要在片元着色器中进行两次矩阵乘法，对性能有所影响。</p>
<p>首先把之前创建的Translating.cs脚本赋给摄像机。然后创建MotionBlurWithDepthTexture.cs脚本：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MotionBlurWithDepthTexture</span> <span class="token operator">:</span> PostEffectsBase
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> Shader motionBlurShader<span class="token punctuation">;</span>
    <span class="token keyword">private</span> Material motionBlurMaterial <span class="token operator">=</span> null<span class="token punctuation">;</span>
    <span class="token keyword">public</span> Material material
    <span class="token punctuation">{</span>
        get
        <span class="token punctuation">{</span>
            motionBlurMaterial <span class="token operator">=</span> <span class="token function">CheckShaderAndCreateMaterial</span><span class="token punctuation">(</span>motionBlurShader<span class="token punctuation">,</span> motionBlurMaterial<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> motionBlurMaterial<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token punctuation">[</span><span class="token function">Range</span><span class="token punctuation">(</span><span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
    <span class="token keyword">public</span> <span class="token keyword">float</span> blurSize <span class="token operator">=</span> <span class="token number">0.5f</span><span class="token punctuation">;</span>

    <span class="token keyword">private</span> Camera myCamera<span class="token punctuation">;</span>
    <span class="token keyword">public</span> Camera camera
    <span class="token punctuation">{</span>
        get
        <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>myCamera <span class="token operator">==</span> null<span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                myCamera <span class="token operator">=</span> GetComponent<span class="token operator">&lt;</span>Camera<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> myCamera<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> Matrix4x4 prevViewProjectionMatrix<span class="token punctuation">;</span>

    <span class="token keyword">void</span> <span class="token function">OnEnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        camera<span class="token punctuation">.</span>depthTextureMode <span class="token operator">|</span><span class="token operator">=</span> DepthTextureMode<span class="token punctuation">.</span>Depth<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">void</span> <span class="token function">OnRenderImage</span><span class="token punctuation">(</span>RenderTexture src<span class="token punctuation">,</span> RenderTexture dest<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>material <span class="token operator">!=</span> null<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            material<span class="token punctuation">.</span><span class="token function">SetFloat</span><span class="token punctuation">(</span><span class="token string">"_BlurSize"</span><span class="token punctuation">,</span> blurSize<span class="token punctuation">)</span><span class="token punctuation">;</span>
            material<span class="token punctuation">.</span><span class="token function">SetMatrix</span><span class="token punctuation">(</span><span class="token string">"_prevViewProjectionMatrix"</span><span class="token punctuation">,</span> prevViewProjectionMatrix<span class="token punctuation">)</span><span class="token punctuation">;</span>
            Matrix4x4 currentViewProjectionMatrix <span class="token operator">=</span> camera<span class="token punctuation">.</span>projectionMatrix <span class="token operator">*</span> camera<span class="token punctuation">.</span>worldToCameraMatrix<span class="token punctuation">;</span>
            Matrix4x4 currentViewProjectionInverseMatrix <span class="token operator">=</span> currentViewProjectionMatrix<span class="token punctuation">.</span>inverse<span class="token punctuation">;</span>
            material<span class="token punctuation">.</span><span class="token function">SetMatrix</span><span class="token punctuation">(</span><span class="token string">"_currentViewProjectionInverseMatrix"</span><span class="token punctuation">,</span> currentViewProjectionInverseMatrix<span class="token punctuation">)</span><span class="token punctuation">;</span>
            prevViewProjectionMatrix <span class="token operator">=</span> currentViewProjectionMatrix<span class="token punctuation">;</span>

            Graphics<span class="token punctuation">.</span><span class="token function">Blit</span><span class="token punctuation">(</span>src<span class="token punctuation">,</span> dest<span class="token punctuation">,</span> material<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span>
        <span class="token punctuation">{</span>
            Graphics<span class="token punctuation">.</span><span class="token function">Blit</span><span class="token punctuation">(</span>src<span class="token punctuation">,</span> dest<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码很简单，先在<code>OnEnable</code>函数中设置摄像机的<code>depthTextureMode</code>，然后在<code>OnRenderImage</code>中算出摄像机的VP矩阵及其逆矩阵，然后每次保留下上一帧的VP矩阵，同时传递给Shader。</p>
<p>接下来是对应的Shader：</p>
<pre class="line-numbers language-shader"><code class="language-shader">SubShader
{
    CGINCLUDE

    #include "UnityCG.cginc"

    sampler2D _MainTex;
    half4      _MainTex_TexelSize;
    sampler2D _CameraDepthTexture;
    float4x4  _currentViewProjectionInverseMatrix;
    float4x4  _prevViewProjectionMatrix;
    half      _BlurSize;

    struct v2f
    {
        float4 pos : SV_POSITION;
        half2  uv : TEXCOORD0;
        half2  uv_depth : TEXCOORD1;
    };

    v2f vert(appdata_img v)
    {
        v2f o;
        o.pos = UnityObjectToClipPos(v.vertex);
        o.uv = v.texcoord;
        o.uv_depth = v.texcoord;

        #if UNITY_UV_STARTS_AT_TOP
        if(_MainTex_TexelSize.y < 0)
            o.uv_depth.y = 1 - o.uv_depth.y;
        #endif

        return o;
    }

    fixed4 frag(v2f i) : SV_Target
    {
        float depth = SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, i.uv_depth);
        float4 currentNDCPos = float4(i.uv.x * 2 - 1, i.uv.y * 2 - 1, depth * 2 - 1, 1);
        float4 inversePos = mul(_currentViewProjectionInverseMatrix, currentNDCPos);
        float4 worldPos = inversePos / inversePos.w;

        float4 prevNDCPos = mul(_prevViewProjectionMatrix, worldPos);
        prevNDCPos /= prevNDCPos.w;

        float2 velocity = (currentNDCPos.xy - prevNDCPos.xy) / 2.0f;

        float2 uv = i.uv;
        float4 c = tex2D(_MainTex, uv);
        uv += velocity * _BlurSize;
        for(int j = 1; j < 3; ++j, uv += velocity * _BlurSize)
        {
            float4 currentColor = tex2D(_MainTex, uv);
            c += currentColor;
        }
        c /= 3;

        return fixed4(c.rgb, 1.0);
    }

    ENDCG

    Pass
    {
        ZTest Always Cull Off ZWrite Off

        CGPROGRAM

        #pragma vertex vert
        #pragma fragment frag

        ENDCG
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中<code>_CameraDepthTexture</code>是Unity传递给我们的深度纹理。在片元着色器里，首先根据VP逆矩阵算出当前像素的世界位置（主要乘了VP逆矩阵之后还需要除以w分量），然后用上一帧的VP矩阵算出这个世界位置里的点在上一帧里的NDC坐标，然后用当前帧和上一帧的NDC坐标之差来算出当前像素的运动速度。再根据这个速度去邻域里采样，相加后取平均得到一个模糊的效果。采样时还使用了<code>_BlurSize</code>来控制采样距离。渲染结果要比上一章实现的好很多。</p>
<p>不过这里的运动模糊只适用于场景静止、摄像机快速运动的情况。因为我们在计算时只考虑了摄像机的运动。如果想要把这里的代码应用到一个物体快速移动而摄像机静止的场景，是不会有任何运动模糊效果的。因为摄像机没动的话，上一帧和下一帧的VP矩阵是不变的，对同一个世界位置算出来的NDC差值是0（这里的世界位置是指Shader代码里算出来的那个世界位置，而不是物体上的点的位置，其实这个NDC位置差值主要是靠变化的VP矩阵算出来的）。在Unity自带的ImageEffect包中能够找到更多的运动模糊的实现方法。</p>
<p>而且我们通过逆矩阵来重建每个像素在世界空间下的位置其实不够高效。下一节会介绍一种更快速的由深度纹理重建世界坐标的方法。</p>
<h2 id="全局雾效"><a href="#全局雾效" class="headerlink" title="全局雾效"></a><font size="5" color="red">全局雾效</font></h2><p>Unity内置的雾效可以产生基于距离的线性或指数雾效。但是需要给场景中所有物体的Shader都添加上相关的渲染代码（比如<code>#pragma multi_compile_fog</code>指令，还需要使用<code>UNITY_FOG_COORDS</code>、<code>UNITY_TRANSFER_FOG</code>、<code>UNITY_APPLY_FOG</code>等内置宏）。而且如果我们想要实现基于高度的雾效等等个性化的效果时，Unity的内置雾效就不再可行了。下面我们来看一下一种基于屏幕后处理的全局雾效。</p>
<p>其实原理很简单，设置一个雾效的起始高度和最终高度，然后算出像素的世界位置的y分量，用这个y分量在起始高度和最终高度之间的比例作为插值，来混合雾颜色和原像素的颜色。</p>
<p>所以还是需要算出像素对应的世界位置。用上一节乘逆矩阵的方式效率比较低，由于屏幕后处理其实画的就是一个刚好铺满摄像机视口的四边形，也就是传入顶点着色器的是4个顶点，我们可以为每个顶点计算一个从摄像机到当前顶点的向量，然后将这个向量从顶点着色器传递到片元着色器，利用光栅化插值得到四边形中间的点到摄像机的向量，然后在片元着色器里利用这个向量乘上线性深度值（实际上还要除以一个近平面距离near）来得到该点在世界空间里到摄像机的世界向量，最后用这个向量加上摄像机在世界里的位置，就能得到该点在世界里的位置（书上讲得太复杂了，可以参考<a href="https://github.com/candycat1992/Unity_Shaders_Book/issues/56" target="_blank" rel="noopener">这里</a>或者<a href="https://www.derschmale.com/2014/01/26/reconstructing-positions-from-the-depth-buffer/" target="_blank" rel="noopener">这里</a>）。</p>
<p>下面先来看FogWithDepthTexture.cs脚本：</p>
<pre class="line-numbers language-c#"><code class="language-c#">public class FogWithDepthTexture : PostEffectsBase
{
    public Shader fogShader;
    private Material fogMaterial = null;
    public Material material
    {
        get
        {
            fogMaterial = CheckShaderAndCreateMaterial(fogShader, fogMaterial);
            return fogMaterial;
        }
    }

    private Camera myCamera;
    public Camera camera
    {
        get
        {
            if (myCamera == null)
            {
                myCamera = GetComponent<camera>();
            }
            return myCamera;
        }
    }

    private Transform myCameraTransform;
    public Transform cameraTransform
    {
        get
        {
            if (myCameraTransform == null)
            {
                myCameraTransform = camera.transform;
            }
            return myCameraTransform;
        }
    }

    [Range(0.0f, 3.0f)]
    public float fogDensity = 1.0f;

    public Color fogColor = Color.white;
    public float fogStart = 0.0f;
    public float fogEnd = 2.0f;

    void OnEnable()
    {
        camera.depthTextureMode = DepthTextureMode.Depth;
    }

    void OnRenderImage(RenderTexture src, RenderTexture dest)
    {
        if (material != null)
        {
            Matrix4x4 frustumCorners = Matrix4x4.identity;
            float fov = camera.fieldOfView;
            float near = camera.nearClipPlane;
            float far = camera.farClipPlane;
            float aspect = camera.aspect;

            float halfHeight = near * Mathf.Tan(fov * 0.5f * Mathf.Deg2Rad);
            Vector3 toRight = cameraTransform.right * halfHeight * aspect;
            Vector3 toTop = cameraTransform.up * halfHeight;

            Vector3 topLeft = cameraTransform.forward * near + toTop - toRight;
            float scale = topLeft.magnitude / near;
            topLeft.Normalize();
            topLeft *= scale;

            Vector3 topRight = cameraTransform.forward * near + toTop + toRight;
            topRight.Normalize();
            topRight *= scale;

            Vector3 bottomLeft = cameraTransform.forward * near - toTop - toRight;
            bottomLeft.Normalize();
            bottomLeft *= scale;

            Vector3 bottomRight = cameraTransform.forward * near - toTop + toRight;
            bottomRight.Normalize();
            bottomRight *= scale;

            frustumCorners.SetRow(0, bottomLeft);
            frustumCorners.SetRow(1, bottomRight);
            frustumCorners.SetRow(2, topRight);
            frustumCorners.SetRow(3, topLeft);

            material.SetMatrix("_FrustumCornersRay", frustumCorners);
            material.SetFloat("_FogDensity", fogDensity);
            material.SetColor("_FogColor", fogColor);
            material.SetFloat("_FogStart", fogStart);
            material.SetFloat("_FogEnd", fogEnd);

            Graphics.Blit(src, dest, material);
        }
        else
        {
            Graphics.Blit(src, dest);
        }
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></camera></code></pre>
<p>其中<code>fogDensity</code>用于控制雾的浓度，<code>fogColor</code>用于控制雾的颜色，<code>fogStart</code>用于控制雾效的起始高度，<code>fogEnd</code>用于控制雾效的终止高度。在<code>OnRenderImage</code>算出来的摄像机到4个顶点的向量被存储到<code>frustumCorners</code>矩阵中传递给了Shader。</p>
<p>下面是对应的Shader代码：</p>
<pre class="line-numbers language-shader"><code class="language-shader">SubShader
{
    CGINCLUDE

    #include "UnityCG.cginc"

    float4x4  _FrustumCornersRay;
    sampler2D _MainTex;
    half4 _MainTex_TexelSize;
    sampler2D _CameraDepthTexture;
    half   _FogDensity;
    fixed4 _FogColor;
    float  _FogStart;
    float  _FogEnd;

    struct v2f
    {
        float4 pos : SV_POSITION;
        half2 uv : TEXCOORD0;
        half2 uv_depth : TEXCOORD1;
        float4 interpolatedRay : TEXCOORD2;
    };

    v2f vert(appdata_img v)
    {
        v2f o;
        o.pos = UnityObjectToClipPos(v.vertex);
        o.uv = v.texcoord;
        o.uv_depth = v.texcoord;

        #if UNITY_UV_STARTS_AT_TOP
        if(_MainTex_TexelSize.y < 0)
            o.uv_depth.y = 1 - o.uv_depth.y;
        #endif

        int index = 0;
        if(v.texcoord.x < 0.5 && v.texcoord.y < 0.5)
            index = 0;
        else if(v.texcoord.x > 0.5 && v.texcoord.y < 0.5)
            index = 1;
        else if(v.texcoord.x > 0.5 && v.texcoord.y > 0.5)
            index = 2;
        else
            index = 3;

        #if UNITY_UV_STARTS_AT_TOP
        if(_MainTex_TexelSize.y < 0)
            index = 3 - index;
        #endif

        o.interpolatedRay = _FrustumCornersRay[index];

        return o;
    }

    fixed4 frag(v2f i) : SV_Target
    {
        float linearDepth = LinearEyeDepth(SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, i.uv_depth));
        float3 worldPos = _WorldSpaceCameraPos + linearDepth * i.interpolatedRay.xyz;

        float fogDensity = (_FogEnd-worldPos.y) / (_FogEnd - _FogStart);
        fogDensity = saturate(fogDensity * _FogDensity);

        fixed4 finalColor = tex2D(_MainTex, i.uv);
        finalColor.rgb = lerp(finalColor.rgb, _FogColor.rgb, fogDensity);

        return finalColor;
    }

    ENDCG

    Pass
    {
        ZTest Always Cull Off ZWrite Off

        CGPROGRAM

        #pragma vertex vert
        #pragma fragment frag

        ENDCG
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中<code>interpolatedRay</code>表示摄像机到顶点的向量，在顶点着色器里会根据当前顶点的坐标去矩阵<code>_FrustumCornersRay</code>中选择对应的向量来赋给<code>interpolatedRay</code>，该向量会在光栅化中被插值，在片元着色器里根据插值之后的<code>interpolatedRay</code>乘上线性深度<code>linearDepth</code>再加上摄像机的世界位置，就能得到当前像素对应的点的世界位置。然后根据世界下的高度y值在雾效起始高度和终止高度之间的比例，来插值混合雾效颜色和像素的原颜色。渲染结果如下图：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/UnityShader%E9%AB%98%E7%BA%A7%E7%AF%87_7.png?raw=true" alt></p>
<h2 id="再谈边缘检测"><a href="#再谈边缘检测" class="headerlink" title="再谈边缘检测"></a><font size="5" color="red">再谈边缘检测</font></h2><p>之前的边缘检测是直接利用屏幕图像的颜色信息来进行的边缘检测，往往不太准。我们可以在深度和法线纹理上来进行边缘检测，这些图像不会受纹理和光照的影响，而仅仅保存了当前渲染物体的模型信息，所以检测出来的边缘更加可靠。</p>
<p>下面我们使用Roberts算子来进行边缘检测，它的本质就是计算左上角和右下角的差值，乘以右上角和左下角的差值，作为评估边缘的依据。我们会按照这样的方式，取对角方向的深度或法线值，比较它们之间的差值，如果超过某个阈值，就认为它们之间存在一条边。</p>
<p>首先创建脚本：</p>
<pre class="line-numbers language-c#"><code class="language-c#">public class EdgeDetectNormalsAndDepth : PostEffectsBase
{
    public Shader edgeDetectShader;
    private Material edgeDetectMaterial = null;

    public Material material
    {
        get
        {
            edgeDetectMaterial = CheckShaderAndCreateMaterial(edgeDetectShader, edgeDetectMaterial);
            return edgeDetectMaterial;
        }
    }

    [Range(0.0f, 1.0f)]
    public float edgesOnly = 0.0f;

    public Color edgeColor = Color.black;
    public Color backgroundColor = Color.white;
    public float sampleDistance = 1.0f;
    public float sensitivityDepth = 1.0f;
    public float sensitivityNormals = 1.0f;

    void OnEnable()
    {
        GetComponent<camera>().depthTextureMode = DepthTextureMode.DepthNormals;
    }

    [ImageEffectOpaque]
    void OnRenderImage(RenderTexture src, RenderTexture dest)
    {
        if (material != null)
        {
            material.SetFloat("_EdgeOnly", edgesOnly);
            material.SetColor("_EdgeColor", edgeColor);
            material.SetColor("_BackgroundColor", backgroundColor);
            material.SetFloat("_SampleDistance", sampleDistance);
            material.SetVector("_Sensitivity", new Vector4(sensitivityNormals, sensitivityDepth, 0.0f, 0.0f));

            Graphics.Blit(src, dest, material);
        }
        else
        {
            Graphics.Blit(src, dest);
        }
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></camera></code></pre>
<p>其中<code>edgesOnly</code>用于调整边缘线强度、<code>edgeColor</code>是描边颜色、<code>backgroundColor</code>是不混合原图时用的背景色，<code>sampleDistance</code>用于控制对深度+法线纹理的采样距离，该值越大，描边越宽；<code>sensitivityDepth</code>和<code>sensitivityNormals</code>会影响当领域的深度值或法线值相差多少时，会被认为存在一条边界，如果把灵敏度调的很大，那么可能即使是深度或法线上很小的变化也会形成一条边。</p>
<p>给<code>OnRenderImage</code>函数加上<code>[ImageEffectOpaque]</code>属性是因为这里我们希望只对不透明物体描边，不希望对透明物体也进行描边。因为默认情况下，<code>OnRenderImage</code>函数会在所有不透明和透明的Pass执行完毕后被调用，以便对场景中所有游戏对象都产生影响。</p>
<p>接下里创建对应的Shader：</p>
<pre class="line-numbers language-shader"><code class="language-shader">SubShader
{
    CGINCLUDE

    #include "UnityCG.cginc"

    sampler2D _MainTex;
    sampler2D _CameraDepthNormalsTexture;
    half4  _MainTex_TexelSize;
    fixed  _EdgeOnly;
    fixed4 _EdgeColor;
    fixed4 _BackgroundColor;
    float  _SampleDistance;
    half4  _Sensitivity;

    struct v2f
    {
        float4 pos : SV_POSITION;
        half2  uv[5] : TEXCOORD0;
    };

    v2f vert(appdata_img v)
    {
        v2f o;
        o.pos = UnityObjectToClipPos(v.vertex);
        half2 uv = v.texcoord;
        o.uv[0] = uv;

        #if UNITY_UV_STARTS_AT_TOP
        if(_MainTex_TexelSize.y < 0)
            uv.y = 1 - uv.y;
        #endif

        o.uv[1] = uv + _MainTex_TexelSize.xy * half2(1, 1) * _SampleDistance;
        o.uv[2] = uv + _MainTex_TexelSize.xy * half2(-1, -1) * _SampleDistance;
        o.uv[3] = uv + _MainTex_TexelSize.xy * half2(-1, 1) * _SampleDistance;
        o.uv[4] = uv + _MainTex_TexelSize.xy * half2(1, -1) * _SampleDistance;

        return o;
    }

    half CheckSame(half4 center, half4 sample)
    {
        half2 centerNormal = center.xy;
        float centerDepth = DecodeFloatRG(center.zw);
        half2 sampleNormal = sample.xy;
        float sampleDepth = DecodeFloatRG(sample.zw);

        half2 diffNormal = abs(centerNormal - sampleNormal) * _Sensitivity.x;
        int isSameNormal = (diffNormal.x + diffNormal.y) < 0.1;

        float diffDepth = abs(centerDepth - sampleDepth) * _Sensitivity.y;
        int isSameDepth = diffDepth < 0.1 * centerDepth;

        return isSameNormal * isSameDepth ? 1.0 : 0.0;
    }

    fixed4 fragRobertsCrossDepthAndNormal(v2f i) : SV_Target
    {
        half4 sample1 = tex2D(_CameraDepthNormalsTexture, i.uv[1]);
        half4 sample2 = tex2D(_CameraDepthNormalsTexture, i.uv[2]);
        half4 sample3 = tex2D(_CameraDepthNormalsTexture, i.uv[3]);
        half4 sample4 = tex2D(_CameraDepthNormalsTexture, i.uv[4]);

        half edge = 1.0;

        edge *= CheckSame(sample1, sample2);
        edge *= CheckSame(sample3, sample4);

        fixed4 withEdgeColor = lerp(_EdgeColor, tex2D(_MainTex, i.uv[0]), edge);
        fixed4 onlyEdgeColor = lerp(_EdgeColor, _BackgroundColor, edge);

        return lerp(withEdgeColor, onlyEdgeColor, _EdgeOnly);
    }

    ENDCG

    Pass
    {
        ZTest Always Cull Off ZWrite Off

        CGPROGRAM

        #pragma vertex vert
        #pragma fragment fragRobertsCrossDepthAndNormal

        ENDCG
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>首先需要声明变量<code>_CameraDepthNormalsTexture</code>来访问深度+法线纹理。然后在顶点着色器中计算使用Roberts算子时需要采样的纹理坐标（计算时还使用了<code>_SampleDistance</code>来控制采样距离），并且将这些坐标存储到uv数组里。这里在顶点着色器里计算uv坐标，比起在片元着色器里计算，可以减少运算量，提高性能。而且从顶点着色器到片元着色器是线性插值的，所以即使是在顶点着色器中计算纹理坐标也不会影响其正确性。</p>
<p>然后在片元着色器里通过<code>CheckSame</code>函数来计算对角线上两个纹理的差值。其中我们并没有对法线值进行解码，这是因为我们只需要比较两个采样值之间的差异值，而并不需要知道它们对应的真正的法线值。渲染结果如下图：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/UnityShader%E9%AB%98%E7%BA%A7%E7%AF%87_8.png?raw=true" alt><br>这里实现的描边效果是基于屏幕空间进行的，所以场景内所有物体都会被添加描边效果。如果希望只对特定的物体进行描边（比如玩家选中场景的某个物体后），这时可以使用Unity提供的<code>Graphics.DrawMesh</code>或<code>Graphics.DrawMeshNow</code>函数把需要的物体再渲染一遍（在所有不透明物体渲染完毕以后），然后再在Shader里用上面的边缘检测的方式来判断是否是边界，如果是的话就显示边界色，如果不是的话就使用<code>Clip()</code>函数抛掉以保留像素原来的颜色（其实就是保留物体原色，只画边缘色）。</p>
<h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a><font size="5" color="red">扩展阅读</font></h2><p>可以使用Unity的着色器替换功能（即调用<code>Camera.RenderWithShader</code>函数）把整个场景再次渲染一次，来创建任何需要的缓存纹理。</p>
<p>Unity曾在2011年SIGGRAPH上做了一个关于使用深度纹理实现各种特效的演讲，详情看<a href="https://blogs.unity3d.com/2011/09/08/special-effects-with-depth-talk-at-siggraph/" target="_blank" rel="noopener">这里</a>。</p>
<h1 id="第十四章-非真实感渲染"><a href="#第十四章-非真实感渲染" class="headerlink" title="第十四章 非真实感渲染"></a><font size="6" color="orange">第十四章 非真实感渲染</font></h1><hr>
<h2 id="卡通风格的渲染"><a href="#卡通风格的渲染" class="headerlink" title="卡通风格的渲染"></a><font size="5" color="red">卡通风格的渲染</font></h2><p>要实现卡通渲染有很多种方法，其中之一就是使用基于色调的着色技术（tone-based shading），详情可参见<a href="http://www.faculty.idc.ac.il/arik/LODSeminar/07Shading/gooch-sg98.pdf" target="_blank" rel="noopener">这篇论文</a>。实现时我们往往会使用漫反射系数对一张一维纹理进行采样，来控制漫反射的色调。而且卡通风格的高光往往是一块块分界明显的纯色区域。除了光照模型不同外。卡通风格通常还需要在物体边缘部分绘制轮廓。下面我们会看到一种不同的基于模型的描边方法。</p>
<h3 id="渲染轮廓线"><a href="#渲染轮廓线" class="headerlink" title="渲染轮廓线"></a><font size="4" color="green">渲染轮廓线</font></h3><p>关于绘制模型轮廓线的方法的分类，详情可以参见《Real Time Rendering》或者《Unity Shader入门精要》P289。我们这里使用过程式几何轮廓线渲染的方法。这种方法的核心是使用两个Pass渲染。第一个Pass渲染背面的面片，并使用某些技术让它的轮廓可见；第二个Pass再正常渲染正面的面片。这种方法的优点在于快速有效，并且适用于绝大多数表面平滑的模型，但缺点是不适合类似于立方体这样平整的模型。</p>
<p>在第一个Pass里，我们会使用轮廓线颜色渲染整个背面的面片，并在视角空间下把模型顶点沿着法线方向向外扩张一段距离，这样来让背面的轮廓线变得可见（从正面看过去能看到背面的轮廓线）：</p>
<pre class="line-numbers language-shader"><code class="language-shader">viewPos = viewPos + viewNormal * _Outline;
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>但是如果直接使用顶点法线进行扩展，对于一些内凹的模型，就可能发生背面面片遮挡正面面片的情况。为了尽可能防止出现这样的情况，在扩张背面顶点之前，我们首先对顶点法线的z分量进行处理，使它们等于一个定值，然后把法线归一化后再对顶点进行扩张。这样的好处在于，扩展后的背面更加扁平化，从而降低了遮挡正面面片的可能性：</p>
<pre class="line-numbers language-shader"><code class="language-shader">viewNormal.z = -0.5;
viewNormal = normalize(viewNormal);
viewPos = viewPos + viewNormal * _Outline;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h3 id="添加高光"><a href="#添加高光" class="headerlink" title="添加高光"></a><font size="4" color="green">添加高光</font></h3><p>对于卡通渲染的高光反射光照模型，我们同样需要计算法线normal和半程向量halfDir的点乘结果，但不同的是，我们把该值和一个阈值进行比较，如果小于该阈值，则高光反射系数为0，否则返回1：</p>
<pre class="line-numbers language-shader"><code class="language-shader">float spec = dot(worldNormal, worldHalfDir);
spec = step(threshold, spec);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>上面是使用CG的step函数来实现和阈值比较的目的。大于阈值则返回1，否则返回0。</p>
<p>但是这往往会在高光区域的边界造成锯齿，如下图所示：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/UnityShader%E9%AB%98%E7%BA%A7%E7%AF%87_9.png?raw=true" alt><br>出现锯齿的原因在于，高光区域的边缘不是平滑渐变的，而是由0突变到1。我们可以在边界处很小的一块区域内，加入平滑处理来抗锯齿：</p>
<pre class="line-numbers language-shader"><code class="language-shader">float spec = dot(worldNormal, worldHalfDir);
spec = lerp(0, 1, smoothstep(-w, w, spec - threshold));
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>上面使用了CG的smoothstep函数，其中<code>w</code>是一个很小的值，当<code>spec - threshold</code>在<code>-w</code>到<code>w</code>之间时，在0到1之间进行插值，所以我们可以在[-w,w]区间内，即高光区域的边界处，得到一个从0到1平滑变化的spec值，从而实现抗锯齿的目的。不过在下面的实现中我们选择使用领域像素之间的近似导数值来作为w的值（而不是人为指定一个数值），这个导数可以通过CG的<code>fwidth</code>函数来得到。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a><font size="4" color="green">实现</font></h3><p>首先创建Shader：</p>
<pre class="line-numbers language-shader"><code class="language-shader">Shader "Unity Shaders Book/Chapter 14/ToonShading"
{
    Properties
    {
        _MainTex("Main Tex", 2D) = "white"{}
        _Ramp("Ramp Tex", 2D) = "white"{}
        _Color ("Color Tint", Color) = (1, 1, 1, 1)
        _Outline("Outline", Range(0, 1)) = 0.1
        _OutlineColor("Outline Color", Color) = (0, 0, 0, 1)
        _Specular("Specular Color", Color) = (1, 1, 1, 1)
        _SpecularScale("Specular Scale", Range(0, 0.1)) = 0.01 
    }
    SubShader
    {
        Tags {"RenderType" = "Opaque" "Queue" = "Geometry"}

        Pass
        {
            NAME "OUTLINE"

            Cull Front

            CGPROGRAM

            #pragma vertex vert
            #pragma fragment frag

            #include "UnityCG.cginc"

            float  _Outline;
            fixed4 _OutlineColor;

            struct a2v
            {
                float4 vertex : POSITION;
                float3 normal : NORMAL;
            };

            struct v2f
            {
                float4 pos : SV_POSITION;
            };

            v2f vert(a2v v)
            {
                v2f o;
                float4 viewPos = float4(UnityObjectToViewPos(v.vertex), 1.0);
                float3 viewNormal = mul((float3x3)UNITY_MATRIX_IT_MV, v.normal);
                viewNormal.z = -0.5;
                viewPos += float4(normalize(viewNormal), 0) * _Outline;
                o.pos = mul(UNITY_MATRIX_P, viewPos);
                return o;
            }

            float4 frag(v2f i) : SV_Target
            {
                return float4(_OutlineColor.rgb, 1);
            }

            ENDCG
        }

        Pass
        {
            Tags {"LightMode" = "ForwardBase"}

            Cull Back

            CGPROGRAM

            #pragma vertex vert
            #pragma fragment frag

            #pragma multi_compile_fwdbase

            #include "UnityCG.cginc"
            #include "Lighting.cginc"
            #include "AutoLight.cginc"

            fixed4 _Color;
            sampler2D _MainTex;
            fixed4 _MainTex_ST;
            sampler2D _Ramp;
            fixed4 _Specular;
            fixed  _SpecularScale;

            struct a2v
            {
                float4 vertex : POSITION;
                float3 normal : NORMAL;
                float4 texcoord : TEXCOORD;
                float4 tangent : TANGENT;
            };

            struct v2f
            {
                float4 pos : POSITION;
                float2 uv : TEXCOORD0;
                float3 worldNormal : TEXCOORD1;
                float3 worldPos : TEXCOORD2;
                SHADOW_COORDS(3)
            };

            v2f vert(a2v v)
            {
                v2f o;
                o.pos = UnityObjectToClipPos(v.vertex);
                o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);
                o.worldNormal = UnityObjectToWorldNormal(v.normal);
                o.worldPos = mul(unity_ObjectToWorld, v.vertex);

                TRANSFER_SHADOW(o);

                return o;
            }

            float4 frag(v2f i) : SV_Target
            {
                fixed3 worldNormal = normalize(i.worldNormal);
                fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));
                fixed3 worldViewDir = normalize(UnityWorldSpaceViewDir(i.worldPos));
                fixed3 worldHalfDir = normalize(worldLightDir + worldViewDir);

                fixed4 c = tex2D(_MainTex, i.uv);
                fixed3 albedo = c.rgb * _Color.rgb;

                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;
                UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);

                fixed diff = dot(worldNormal, worldLightDir);
                diff = (diff * 0.5 + 0.5) * atten;

                fixed3 diffuse = _LightColor0.rgb * albedo * tex2D(_Ramp, float2(diff, diff)).rgb;

                fixed spec = dot(worldNormal, worldHalfDir);
                fixed w = fwidth(spec) * 2.0;
                fixed3 specular = _Specular.rgb * lerp(0, 1, smoothstep(-w, w, spec + _SpecularScale - 1)) * step(0.001, _SpecularScale);

                return fixed4(ambient + diffuse + specular, 1.0);
            }

            ENDCG
        }
    }
    FallBack "Diffuse"
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中<code>_Ramp</code>是用于控制漫反射颜色的渐变纹理，<code>_Outline</code>用于控制轮廓线宽度，<code>_OutlineColor</code>是轮廓线的颜色，<code>_Specular</code>是高光反射颜色，<code>_SpecularScale</code>用于控制计算高光反射时使用的阈值。</p>
<p>在第一个Pass中设置剔除正面，只渲染背面，并且在顶点着色器中先把顶点和法线变换到观察空间中，然后设置法线的z分量，对其归一化后再将顶点沿其法线方向扩张，得到扩张后的顶点坐标。这样做是为了尽可能避免背面扩张后的顶点挡住正面的面片。</p>
<p>然后在第二个Pass中设置剔除背面，只渲染正面，并且由于需要添加光照效果，所以要为Pass进行相应的标签设置以及添加相应的编译指令和头文件。然后在片元着色器中计算半兰伯特漫反射系数，并和阴影值相乘得到最终的漫反射系数，再使用这个漫反射系数对渐变纹理<code>_Ramp</code>进行采样得到漫反射颜色。然后结合<code>fwidth</code>对高光区域的边界进行抗锯齿处理。这里对高光还乘了一个<code>step(0.001, _SpecularScale)</code>是为了让<code>_SpecularScale</code>为0时，可以完全消除高光反射的光照。渲染结果如下图：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/UnityShader%E9%AB%98%E7%BA%A7%E7%AF%87_10.png?raw=true" alt><br>更好的卡通渲染方式，可以参考<a href="http://amd-dev.wpengine.netdna-cdn.com/wordpress/media/2012/10/Mitchell-IllustrativeRenderingInTF2(Siggraph07" target="_blank" rel="noopener">这篇PPT</a>.pdf)和<a href="http://www.cs.princeton.edu/courses/archive/fall07/cos597B/papers/mitchell-team-fortress.pdf" target="_blank" rel="noopener">这篇论文</a>。</p>
<h2 id="素描风格的渲染"><a href="#素描风格的渲染" class="headerlink" title="素描风格的渲染"></a><font size="5" color="red">素描风格的渲染</font></h2><p>Praun等人曾在2001 SIGGRAPH上发表了一篇关于素描风格渲染的<a href="http://www.cs.utah.edu/~emilp/papers/praun01rth.pdf" target="_blank" rel="noopener">论文</a>，他们使用了提前生成素描纹理来实现实时的素描风格渲染，这些纹理组成了一个色调艺术映射（Tonal Art Map，TAM），如下图所示：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/UnityShader%E9%AB%98%E7%BA%A7%E7%AF%87_11_0.png?raw=true" alt><br>图中从左到右纹理中的笔触逐渐增多，用于模拟不同光照下的漫反射效果，从上到下对应了每张纹理的mipmap（这些mipmap的生成并不是简单的对上一层纹理进行降采样，而是需要保持笔触之间的间隔，以便更真实第模拟素描效果）。</p>
<p>下面我们将会实现论文算法的一个简化版本，不考虑mipmap的生成，而是直接使用6张素描纹理进行渲染。首先在顶点着色器里计算逐顶点的光照，根据光照结果来决定6张纹理的混合权重，并传递给片元着色器。然后在片元着色器里根据这些权重来混合6张纹理的采样结果。</p>
<p>首先在Shader里声明需要用到的属性：</p>
<pre class="line-numbers language-shader"><code class="language-shader">Properties
{
    _Color("Color Tint", Color) = (1, 1, 1, 1)
    _TileFactor("Tile Factor", Float) = 1
    _Outline("Outline", Range(0, 1)) = 0.1
    _Hatch0("Hatch 0", 2D) = "white"{}
    _Hatch1("Hatch 1", 2D) = "white"{}
    _Hatch2("Hatch 2", 2D) = "white"{}
    _Hatch3("Hatch 3", 2D) = "white"{}
    _Hatch4("Hatch 4", 2D) = "white"{}
    _Hatch5("Hatch 5", 2D) = "white"{}
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中<code>_Color</code>用于控制模型颜色；<code>_TileFactor</code>是纹理的平铺系数，该值越大模型上的素描线越密；<code>_Outline</code>是轮廓的宽度；<code>_Hatch0</code>至<code>_Hatch5</code>对应了渲染时使用的6张素描纹理，它们的线条密度依次增大。</p>
<p>由于素描风格往往也需要在物体周围渲染轮廓线，因此我们直接使用之前渲染轮廓的Pass：</p>
<pre class="line-numbers language-shader"><code class="language-shader">SubShader
{
    Tags{"RenderType" = "Opaque" "Queue" = "Geometry"}

    UsePass "Unity Shaders Book/Chapter 14/ToonShading/OUTLINE"
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后我们定义素描效果需要的Pass：</p>
<pre class="line-numbers language-shader"><code class="language-shader">Pass
{
    Tags {"LightMode" = "ForwardBase"}
    //...
    struct a2v
    {
        float4 vertex : POSITION;
        float4 tangent : TANGENT;
        float3 normal : NORMAL;
        float2 texcoord : TEXCOORD0;
    };

    struct v2f
    {
        float4 pos : SV_POSITION;
        float2 uv : TEXCOORD0;
        fixed3 hatchWeights0 : TEXCOORD1;
        fixed3 hatchWeights1 : TEXCOORD2;
        float3 worldPos : TEXCOORD3;
        SHADOW_COORDS(4)
    };

    v2f vert(a2v v)
    {
        v2f o;
        o.pos = UnityObjectToClipPos(v.vertex);
        o.uv = v.texcoord * _TileFactor;

        fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(v.vertex));
        fixed3 worldNormal = UnityObjectToWorldNormal(v.normal);
        fixed  diff = max(0, dot(worldLightDir, worldNormal));

        o.hatchWeights0 = fixed3(0, 0, 0);
        o.hatchWeights1 = fixed3(0, 0, 0);

        float hatchFactor = diff * 7.0;

        if(hatchFactor > 6.0)
        {
        }
        else if(hatchFactor > 5.0)
        {
            o.hatchWeights0.x = hatchFactor - 5.0;
        }
        else if(hatchFactor > 4.0)
        {
            o.hatchWeights0.x = hatchFactor - 4.0;
            o.hatchWeights0.y = 1.0 - o.hatchWeights0.x;
        }
        else if(hatchFactor > 3.0)
        {
            o.hatchWeights0.y = hatchFactor - 3.0;
            o.hatchWeights0.z = 1.0 - o.hatchWeights0.y;
        }
        else if(hatchFactor > 2.0)
        {
            o.hatchWeights0.z = hatchFactor - 2.0;
            o.hatchWeights1.x = 1.0 - o.hatchWeights0.z;
        }
        else if(hatchFactor > 1.0)
        {
            o.hatchWeights1.x = hatchFactor - 1.0;
            o.hatchWeights1.y = 1.0 - o.hatchWeights1.x;
        }
        else
        {
            o.hatchWeights1.y = hatchFactor;
            o.hatchWeights1.z = 1.0 - o.hatchWeights1.y;
        }

        o.worldPos = mul(unity_ObjectToWorld, v.vertex);

        TRANSFER_SHADOW(o);

        return o;
    }

    fixed4 frag(v2f i) : SV_Target
    {
        fixed4 hatchTex0 = tex2D(_Hatch0, i.uv) * i.hatchWeights0.x;
        fixed4 hatchTex1 = tex2D(_Hatch1, i.uv) * i.hatchWeights0.y;
        fixed4 hatchTex2 = tex2D(_Hatch2, i.uv) * i.hatchWeights0.z;
        fixed4 hatchTex3 = tex2D(_Hatch3, i.uv) * i.hatchWeights1.x;
        fixed4 hatchTex4 = tex2D(_Hatch4, i.uv) * i.hatchWeights1.y;
        fixed4 hatchTex5 = tex2D(_Hatch5, i.uv) * i.hatchWeights1.z;
        fixed4 whiteColor = fixed4(1, 1, 1, 1) * (1 - i.hatchWeights0.x - i.hatchWeights0.y - i.hatchWeights0.z - i.hatchWeights1.x - i.hatchWeights1.y - i.hatchWeights1.z);
        fixed4 hatchColor = hatchTex0 + hatchTex1 + hatchTex2 + hatchTex3 + hatchTex4 + hatchTex5 + whiteColor;
        UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);
        return fixed4(hatchColor.rgb * _Color.rgb * atten, 1.0);
    }
    //...
}    
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中6张纹理的混合权重存储在两个fixed3类型的变量中（<code>hatchWeights0</code>和<code>hatchWeights1</code>）。在顶点着色器里使用<code>_TileFactor</code>和顶点的原有纹理坐标得到新的纹理采样坐标，然后先计算逐顶点的漫反射光照<code>diff</code>，再将其缩放到[0, 7]的范围得到<code>hatchFactor</code>。然后根据<code>hatchFactor</code>所处的区间来计算对应的纹理混合权重（漫反射光照越强的地方素描笔触越少）。</p>
<p>然后在片元着色器里对每张纹理进行采样，并和听他们对应的权重值相乘得到每张纹理的采样颜色。而且还计算了纯白色在渲染中的贡献度，这是通过从1中减去6张纹理的权重来得到的。这是一位素描中往往由留白的部分，因此我们希望在最后的渲染中光照最亮的部分是纯白色的。渲染结果如下图：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/UnityShader%E9%AB%98%E7%BA%A7%E7%AF%87_11.png?raw=true" alt></p>
<h2 id="扩展阅读-1"><a href="#扩展阅读-1" class="headerlink" title="扩展阅读"></a><font size="5" color="red">扩展阅读</font></h2><p>除了之前提到的那篇论文，<a href="https://alastaira.wordpress.com/2013/11/01/hand-drawn-shaders-and-creating-tonal-art-maps/" target="_blank" rel="noopener">这篇博客</a>也介绍了另一种效果和Photo Shop等软件相似的素描方法。国际会议NPAR上也有很多关于非真实感渲染的论文。浙江大学耿卫东教授的《艺术化绘制的图形学原理与方法》也是很好的学习资料。另外在Unity Store中也有很多好的卡通渲染的资源，比如<a href="https://assetstore.unity.com/packages/vfx/shaders/toon-shader-free-21288" target="_blank" rel="noopener">Toon Shader Free</a>、<a href="https://assetstore.unity.com/packages/vfx/shaders/toon-styles-shader-pack-7212" target="_blank" rel="noopener">Toon Styles Shader Pack</a>、<a href="https://assetstore.unity.com/packages/vfx/shaders/hand-drawn-shader-pack-12465" target="_blank" rel="noopener">Hard-Drawn Shader Pack</a>等等，它们包含了诸如铅笔渲染、蜡笔渲染等等多种手绘风格的非真实感渲染效果。</p>
<h1 id="第十五章-使用噪声"><a href="#第十五章-使用噪声" class="headerlink" title="第十五章 使用噪声"></a><font size="6" color="orange">第十五章 使用噪声</font></h1><hr>
<h2 id="消融效果"><a href="#消融效果" class="headerlink" title="消融效果"></a><font size="5" color="red">消融效果</font></h2><p>消融效果的原理很简单，概括来说就是噪声纹理+透明度测试。我们使用对噪声纹理采样的结果和某个控制消融程度的阈值比较，如果小于阈值，就是用clip函数把它对应的像素裁剪掉，这些部分就对应了被“烧毁”的镂空区域。而镂空区域边缘的烧焦效果则是将两种颜色混合，再用pow函数处理后，与原纹理颜色混合后的结果。</p>
<p>原理挺简单的，直接给出Shader把：</p>
<pre class="line-numbers language-shader"><code class="language-shader">Shader "Unity Shaders Book/Chapter 15/Dissolve"
{
    Properties
    {
        _MainTex ("Base (RGB)", 2D) = "white" {}
        _BumpMap ("Normal Map", 2D) = "bump" {}
        _BurnMap("Burn Map", 2D) = "white"{}
        _BurnAmount ("Burn Amount", Range(0.0, 1.0)) = 0.0
        _BurnFirstColor("Burn First Color", Color) = (1, 0, 0, 1)
        _BurnSecondColor("Burn Second Color", Color) = (1, 0, 0, 1)
        _BurnWidth("Burn Line Width", Range(0.0, 0.2)) = 0.1
    }

    SubShader
    {
        Pass
        {
            Tags {"LightMode" = "ForwardBase"}

            Cull Off

            CGPROGRAM

            #include "Lighting.cginc"
            #include "AutoLight.cginc"

            #pragma multi_compile_fwdbase

            #pragma vertex vert
            #pragma fragment frag

            fixed _BurnAmount;
            fixed _BurnWidth;
            sampler2D _MainTex;
            sampler2D _BumpMap;
            fixed4 _BurnFirstColor;
            fixed4 _BurnSecondColor;
            sampler2D _BurnMap;

            float4 _MainTex_ST;
            float4 _BumpMap_ST;
            float4 _BurnMap_ST;

            struct a2v {
                float4 vertex : POSITION;
                float3 normal : NORMAL;
                float4 tangent : TANGENT;
                float4 texcoord : TEXCOORD0;
            };

            struct v2f {
                float4 pos : SV_POSITION;
                float2 uvMainTex : TEXCOORD0;
                float2 uvBumpMap : TEXCOORD1;
                float2 uvBurnMap : TEXCOORD2;
                float3 lightDir : TEXCOORD3;
                float3 worldPos : TEXCOORD4;
                SHADOW_COORDS(5)
            };

            v2f vert(a2v v)
            {
                v2f o;
                o.pos = UnityObjectToClipPos(v.vertex);
                o.uvMainTex = TRANSFORM_TEX(v.texcoord, _MainTex);
                o.uvBumpMap = TRANSFORM_TEX(v.texcoord, _BumpMap);
                o.uvBurnMap = TRANSFORM_TEX(v.texcoord, _BurnMap);

                TANGENT_SPACE_ROTATION;

                o.lightDir = mul(rotation, ObjSpaceLightDir(v.vertex));
                o.worldPos = mul(unity_ObjectToWorld, v.vertex);

                TRANSFER_SHADOW(o);

                return o;
            }

            fixed4 frag(v2f i) : SV_Target
            {
                fixed3 burn = tex2D(_BurnMap, i.uvBurnMap);
                clip(burn.r - _BurnAmount);

                float3 tangentLightDir = normalize(i.lightDir);
                fixed3 tangentNormal = UnpackNormal(tex2D(_BumpMap, i.uvBumpMap));

                fixed3 albedo = tex2D(_MainTex, i.uvMainTex);
                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;

                fixed3 diffuse = _LightColor0.rgb * albedo * max(0, dot(tangentNormal, tangentLightDir));

                fixed t = 1 - smoothstep(0.0, _BurnWidth, burn.r - _BurnAmount);
                fixed3 burnColor = lerp(_BurnFirstColor, _BurnSecondColor, t);
                burnColor = pow(burnColor, 5);

                UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);
                fixed3 finalColor = lerp(ambient + diffuse * atten, burnColor, t * step(0.0001, _BurnAmount));

                return fixed4(finalColor, 1);
            }

            ENDCG
        }

        Pass
        {
            Tags{"LightMode" = "ShadowCaster"}

            CGPROGRAM

            #pragma vertex vert
            #pragma fragment frag

            #pragma multi_compile_shadowcaster

            #include "UnityCG.cginc"

            fixed _BurnAmount;
            sampler2D _BurnMap;
            float4 _BurnMap_ST;

            struct v2f
            {
                V2F_SHADOW_CASTER;
                float2 uvBurnMap : TEXCOORD1;
            };

            v2f vert(appdata_base v)
            {
                v2f o;
                TRANSFER_SHADOW_CASTER_NORMALOFFSET(o);
                o.uvBurnMap = TRANSFORM_TEX(v.texcoord, _BurnMap);
                return o;
            }

            fixed4 frag(v2f i) : SV_Target
            {
                fixed3 burn = tex2D(_BurnMap, i.uvBurnMap).rgb;
                clip(burn.r - _BurnAmount);
                SHADOW_CASTER_FRAGMENT(i);
            }

            ENDCG
        }

    }
    FallBack "Diffuse"
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中<code>_MainTex</code>、<code>_BumpMap</code>是物体的漫反射纹理和法线纹理；<code>_BurnMap</code>是噪声纹理；<code>_BurnAmount</code>用于控制消融程度（噪声纹理中的值小于该值后对应的片元会被抛掉），当值为0时，物体为正常效果，当值为1时，物体完全消融；<code>_BurnFirstColor</code>和<code>_BurnSecondColor</code>对应了火焰边缘的两种颜色值；<code>_BurnWidth</code>用于烧焦效果的范围，它的值越大，火焰边缘的蔓延范围越广。</p>
<p>第一个Pass用于模拟消融效果，其中关闭了面剔除，这是因为消融会导致裸露模型的背面，如果只渲染正面会出现错误的结果。在片元着色器中首先对噪声纹理进行采样，将采样结果和用于控制消融程度的属性<code>_BurnAmount</code>相减，如果相减结果小于0，则clip函数会剔除对应的像素，从而不会显示到屏幕上。如果通过了测试，则进行正常的光照计算。首先算出漫反射光照，然后用噪声纹素值在0~_BurnWidth的范围内插值，用插值的结果t来混合两种火焰颜色，为了让效果更接近烧焦的痕迹，我们还使用pow函数对结果进行处理。然后再次使用t来混合正常光照颜色和烧焦颜色。乘上<code>step</code>函数是为了保证当<code>_BurnAmount</code>为0时，不显示任何消融效果。</p>
<p>而第二个Pass是为了配合消融效果（本质上是AlphaTest），让其显示出正常的阴影效果，避免已经被消融的地方依然向其他物体投射不应该有的阴影。</p>
<p>为了实现动态的消融效果，还创建了另一个脚本，来根据时间动态地设置Shader中的<code>_BurnAmount</code>属性：</p>
<pre class="line-numbers language-c#"><code class="language-c#">public class BurnHelper : MonoBehaviour
{
    public Material material;

    [Range(0.01f, 1.0f)]
    public float burnSpeed = 0.3f;

    private float burnAmount = 0.0f;

    void Start ()
    {
        if (material == null)
        {
            Renderer renderer = gameObject.GetComponent<renderer>();
            if (renderer != null)
            {
                material = renderer.material;
            }
        }
    }

    void Update ()
    {
        burnAmount = Mathf.Repeat(Time.time * burnSpeed, 1.0f);
        material.SetFloat("_BurnAmount", burnAmount);
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></renderer></code></pre>
<p>渲染结果如下图：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/UnityShader%E9%AB%98%E7%BA%A7%E7%AF%87_12.png?raw=true" alt></p>
<h2 id="水波效果"><a href="#水波效果" class="headerlink" title="水波效果"></a><font size="5" color="red">水波效果</font></h2><p>在模拟实时水面的过程中，我们往往也会使用噪声纹理。此时，噪声纹理通常会用作一个高度图，以不断修改水面的法线方向。为了模拟水不断流动的效果，我们会使用和时间相关的变量来对噪声纹理进行采样，当得到法线信息后，再结合菲涅尔系数进行正常的反射+折射计算，得到最后的水面波动效果。</p>
<p>Shader代码大部分和之前实现玻璃效果的代码相同，不同的是水波的法线纹理是由一张噪声纹理生成而得（在纹理面板中把噪声纹理的类型设置为Normal Map，并且选中Create from grayscale，Unity就会自动从噪声纹理生成对应的法线纹理），而且对该纹理的采样坐标是随着时间不断平移的。</p>
<p>首先声明需要用到的属性：</p>
<pre class="line-numbers language-shader"><code class="language-shader">Properties
{
    _Color ("Main Color", Color) = (0, 0.15, 0.115, 1)
    _MainTex ("Base (RGB)", 2D) = "white" {}
    _WaveNormalMap ("Wave Noraml Map", 2D) = "bump" {}
    _Cubemap ("Environment Cubemap", Cube) = "_Skybox" {}
    _WaveXSpeed ("Wave Horizontal Speed", Range(-0.1, 0.1)) = 0.01
    _WaveYSpeed ("Wave Vertical Speed", Range(-0.1, 0.1)) = 0.01
    _Distortion ("Distortion", Range(0, 100)) = 10
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中<code>_Color</code>用于控制水面颜色；<code>_MainTex</code>是水面波纹的漫反射纹理；<code>_WaveNormalMap</code>是一个由噪声纹理生成的法线纹理；<code>_Cubemap</code>是用于模拟反射的立方体纹理；<code>_WaveXSpeed</code>和<code>_WaveYSpeed</code>用于控制法线纹理采样坐标在X和Y方向上的平移速度；<code>_Distortion</code>用于控制模拟折射时图像的扭曲程度。</p>
<p>然后在SubShader中首先使用<code>GrabPass</code>来获取屏幕图像，以供模拟折射时使用：</p>
<pre class="line-numbers language-shader"><code class="language-shader">SubShader
{
    Tags { "Queue"="Transparent" "RenderType"="Opaque" }

    GrabPass { "_RefractionTex" }
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后在下一个Pass中先定义需要的变量，并在顶点着色器里进行顶点变换以及切线空间的计算：</p>
<pre class="line-numbers language-shader"><code class="language-shader">fixed4 _Color;
sampler2D _MainTex;
float4 _MainTex_ST;
sampler2D _WaveNormalMap;
float4 _WaveNormalMap_ST;
samplerCUBE _Cubemap;
fixed _WaveXSpeed;
fixed _WaveYSpeed;
float _Distortion;    
sampler2D _RefractionTex;
float4 _RefractionTex_TexelSize;

v2f vert(a2v v) 
{
    v2f o;
    o.pos = UnityObjectToClipPos(v.vertex);
    o.scrPos = ComputeGrabScreenPos(o.pos);
    o.uv.xy = TRANSFORM_TEX(v.texcoord, _MainTex);
    o.uv.zw = TRANSFORM_TEX(v.texcoord, _WaveNormalMap);

    float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;  
    fixed3 worldNormal = UnityObjectToWorldNormal(v.normal);  
    fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);  
    fixed3 worldBinormal = cross(worldNormal, worldTangent) * v.tangent.w; 

    o.TtoW0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);  
    o.TtoW1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);  
    o.TtoW2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);  

    return o;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中建议去看一下<code>ComputeGrabScreenPos</code>函数的内部实现，会发现对<code>o.scrPos.xy</code>除以w分量之后就会得到对<code>_RefractionTex</code>的采样坐标，其范围在0~1之间。</p>
<p>然后是片元着色器：</p>
<pre class="line-numbers language-shader"><code class="language-shader">fixed4 frag(v2f i) : SV_Target
{
    float3 worldPos = float3(i.TtoW0.w, i.TtoW1.w, i.TtoW2.w);
    fixed3 viewDir = normalize(UnityWorldSpaceViewDir(worldPos));
    float2 speed = _Time.y * float2(_WaveXSpeed, _WaveYSpeed);

    fixed3 bump1 = UnpackNormal(tex2D(_WaveNormalMap, i.uv.zw + speed)).rgb;
    fixed3 bump2 = UnpackNormal(tex2D(_WaveNormalMap, i.uv.zw - speed)).rgb;
    fixed3 bump = normalize(bump1 + bump2);

    float2 offset = bump.xy * _Distortion * _RefractionTex_TexelSize.xy;
    i.scrPos.xy = offset * i.scrPos.z + i.scrPos.xy;
    fixed3 refrCol = tex2D( _RefractionTex, i.scrPos.xy/i.scrPos.w).rgb;

    bump = normalize(half3(dot(i.TtoW0.xyz, bump), dot(i.TtoW1.xyz, bump), dot(i.TtoW2.xyz, bump)));
    fixed4 texColor = tex2D(_MainTex, i.uv.xy + speed);
    fixed3 reflDir = reflect(-viewDir, bump);
    fixed3 reflCol = texCUBE(_Cubemap, reflDir).rgb * texColor.rgb * _Color.rgb;

    fixed fresnel = pow(1 - saturate(dot(viewDir, bump)), 4);
    fixed3 finalColor = reflCol * fresnel + refrCol * (1 - fresnel);

    return fixed4(finalColor, 1);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中我们使用了内置的<code>_Time.y</code>变量和<code>_WaveXSpeed</code>、<code>_WaveYSpeed</code>属性计算了法线纹理的当前偏移量，并利用该值对法线纹理进行两次采样，这是为了模拟两层交叉的水面波动的效果，对两次结果相加并归一化后得到切线空间下的法线方向。然后和之前玻璃效果实现折射的方式类似，不同的是，我们在计算偏移后的屏幕坐标时，把偏移量和平面坐标的z分量相乘，这是为了模拟深度越大、折射程度越大的效果（如果不想要这种效果的就不用乘z了，直接把偏移量加给屏幕坐标）；实现反射的方式也和之前玻璃效果的类似，不同点在于这里也对主纹理（即水面的漫反射纹理）的采样坐标加上了偏移量<code>speed</code>，来实现纹理动画，以模拟水面波纹移动的效果。并且最后我们计算了菲涅尔系数，用它来混合折射和反射颜色。渲染结果如下图：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/UnityShader%E9%AB%98%E7%BA%A7%E7%AF%87_13.png?raw=true" alt><br>可以看出，左图视角方向更贴近水面，这时反射效果比较强烈；而右图视角方向更偏向于垂直水面，此时折射效果比较强烈。</p>
<h2 id="扩展阅读-2"><a href="#扩展阅读-2" class="headerlink" title="扩展阅读"></a><font size="5" color="red">扩展阅读</font></h2><p>上面用到的噪声纹理是如何得到的？其实这些噪声纹理可以被认为是一种程序纹理，它们都是由计算机利用某些算法生成的。Perlin噪声和Worley噪声是两种最常用的噪声类型。我们上面使用的噪声纹理就是有Perlin噪声生成而来。Perlin噪声可以用于生成更自然的噪声纹理，而Worley噪声则通常用于模拟诸如石头、水、纸张等多孔噪声。像PhotoShop这些软件也可以帮助美术人员生成需要的噪声纹理。</p>
<p><a href="http://flafla2.github.io/2014/08/09/perlinnoise.html" target="_blank" rel="noopener">这里</a>是一篇关于理解Perlin噪声的很好的文章，<a href="http://www.rhythmiccanvas.com/research/papers/worley.pdf" target="_blank" rel="noopener">这篇论文</a>是关于Worley噪声的。<a href="https://github.com/Scrawk/Procedural-Noise" target="_blank" rel="noopener">这篇博客</a>里给出了很多程序噪声在Unity中的实现源码。</p>
<h1 id="第十六章-Unity中的渲染优化技术"><a href="#第十六章-Unity中的渲染优化技术" class="headerlink" title="第十六章 Unity中的渲染优化技术"></a><font size="6" color="orange">第十六章 Unity中的渲染优化技术</font></h1><hr>
<h2 id="移动平台的特点"><a href="#移动平台的特点" class="headerlink" title="移动平台的特点"></a><font size="5" color="red">移动平台的特点</font></h2><ol>
<li>为了减少overdraw（即一个像素被绘制多次），PowerVR芯片（通常用于IOS设备和某些Android设备）使用了分块延迟渲染（Tiled-based Deferred Rendering，TBDR）架构，把所有的渲染图像装入一个个tile中，再有硬件找到可见的片元，而只有这些可见片元才会执行片元着色器</li>
<li>另外一些基于tile的GPU架构，如果Adreno（高通的芯片）和Mali（ARM的芯片）则会使用Early-Z或相似的技术进行一个低精度的深度检测，来剔除那些不需要渲染的图元。</li>
<li>还有一些GPU，比如Tegra（NVIDIA的芯片），则使用了传统的架构设计，因此在这些设备上，overdraw更可能造成性能的瓶颈。</li>
<li>由于芯片架构造成的不同，一些游戏往往需要针对不同的芯片发布不同的版本，以便对每个芯片进行更有针对性的优化。尤其是在Android设备上，芯片差异很大，而IOS平台的硬件条件相对统一，我们可以在Unity手册的<a href="https://docs.unity3d.com/Manual/iphone-Hardware.html" target="_blank" rel="noopener">IOS硬件指南</a>中找到相关的资料。</li>
</ol>
<h2 id="影响性能的因素"><a href="#影响性能的因素" class="headerlink" title="影响性能的因素"></a><font size="5" color="red">影响性能的因素</font></h2><p>造成游戏性能瓶颈的主要原因有以下几个方面：</p>
<ol>
<li>CPU：<ul>
<li>过多的Draw Call</li>
<li>复杂的脚本或者物理模拟</li>
</ul>
</li>
<li>GPU：<ul>
<li>顶点处理<ul>
<li>过多的顶点</li>
<li>过多的逐顶点计算</li>
</ul>
</li>
<li>片元处理<ul>
<li>过多的片元（既可能是由于分辨率造成的，也可能是由于overdraw造成的）</li>
<li>过多的逐片元计算</li>
</ul>
</li>
</ul>
</li>
<li>带宽：<ul>
<li>使用了尺寸很大且未压缩的纹理</li>
<li>分辨率过高的帧缓存</li>
</ul>
</li>
</ol>
<p>对CPU来说，过多的draw call会造成CPU的性能瓶颈，这是因为每次调用draw call时，CPU往往都需要改变很多渲染状态的设置，人这些操作是非常耗时的。如果一帧中需要的draw call数目过多的话，就会导致CPU把大部分时间都花费在提交draw call的工作上面了。</p>
<p>GPU的性能瓶颈和需要处理的顶点数目、屏幕分辨率、现存等因素有关。</p>
<p>针对这些可能造成性能瓶颈的因素，后面涉及的优化技术有：</p>
<ol>
<li>CPU优化：<ul>
<li>使用批处理技术减少draw call数目</li>
</ul>
</li>
<li>CPU优化：<ul>
<li>减少需要处理的顶点数目：<ul>
<li>优化几何体</li>
<li>使用模型的LOD技术</li>
<li>使用遮挡剔除技术</li>
<li>减少需要处理的片元数目：</li>
<li>控制绘制顺序</li>
<li>警惕透明物体</li>
<li>减少实时光照</li>
<li>减少计算复杂度：</li>
<li>使用Shader的LOD技术</li>
<li>代码方面的优化</li>
</ul>
</li>
</ul>
</li>
<li>节省内存带宽<ul>
<li>减少纹理大小</li>
<li>利用分辨率缩放</li>
</ul>
</li>
</ol>
<h2 id="Unity中的渲染分析工具"><a href="#Unity中的渲染分析工具" class="headerlink" title="Unity中的渲染分析工具"></a><font size="5" color="red">Unity中的渲染分析工具</font></h2><p>Unity内置了一些工具来帮助我们进行性能分析，包括渲染统计窗口（Rendering Statistics Window）、性能分析器（Profiler）、帧调试器（Frame Debugger）。</p>
<h3 id="渲染统计窗口"><a href="#渲染统计窗口" class="headerlink" title="渲染统计窗口"></a><font size="4" color="green">渲染统计窗口</font></h3><p>可以通过Game视图的Stats按钮来打开它，如下图所示：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/UnityShader%E9%AB%98%E7%BA%A7%E7%AF%87_14.png?raw=true" alt><br>可以看到主要包含了3个方面的信息：音频（Audio）、图像（Graphics）和网络（Network）。图像方面的信息含义如下表：<br>信息名称 | 描述<br>:- | :-<br>每帧的时间和FPS | 在Graphics的右侧显示了FPS数目，和处理和渲染一帧所需要的时间<br>Batches | 一帧中需要进行的批处理数目<br>Saved by batching | 合并的批处理数目，这个数字表明了批处理为我们节省了多少draw call<br>Tris和Verts | 需要绘制的三角面片和顶点数目<br>Screen | 屏幕的大小，以及它占用的内存大小<br>SetPass | 渲染使用的Pass的数目，每个Pass都需要Unity的runtime来绑定一个新的Shader，这可能造成CPU的瓶颈<br>Visible Skinned Meshes | 渲染的蒙皮网格的数目<br>Animations | 播放的动画数目</p>
<h3 id="性能分析器"><a href="#性能分析器" class="headerlink" title="性能分析器"></a><font size="4" color="green">性能分析器</font></h3><p>单击Window→Profiler可以打开Unity的性能分析器。其渲染区域（Rendering）提供了更多关于渲染的统计信息。如下图所示：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/UnityShader%E9%AB%98%E7%BA%A7%E7%AF%87_15.png?raw=true" alt><br>性能分析器提供了很多有用的信息，比如批处理数目、Pass数目、draw call数目、动态批处理/静态批处理数目、渲染纹理数目和内存占用等等。</p>
<h3 id="帧调试器"><a href="#帧调试器" class="headerlink" title="帧调试器"></a><font size="4" color="green">帧调试器</font></h3><p>可以通过Window→Frame Debugger来打开帧调试器，之前的篇章有讲过就不赘述了。</p>
<p>需要注意的是，渲染统计窗口、性能分析器、帧调试器等等显示的数据都是基于当前的开发平台得到的，而非真机上的结果。可能有一天直接在Unity中对移动设备进行性能分析不会再是梦想把。在这之前，还是需要一些外部的性能分析工具。</p>
<h3 id="其他性能分析工具"><a href="#其他性能分析工具" class="headerlink" title="其他性能分析工具"></a><font size="4" color="green">其他性能分析工具</font></h3><p>对于Android平台来说，高通的Adreno分析工具可以对不同的测试机进行详细的性能分析。英伟达的NVPerfHUD工具可以帮助我们得到几乎所有需要的性能分析数据，比如每个draw call的GPU时间、每个Shader花费的cycle数目等等。</p>
<p>对于IOS平台来说，Unity内置的分析器可以得到整个场景花费的GPU时间。PowerVRAM的PVRUniSco shader分析器也可以给出一个大致的性能评估。XCode中的OpenGL ES Driver Instruments可以给出一些宏观上的性能信息，例如设备利用率、渲染器利用率等等。不过相对于Android平台，对IOS的性能分析工具很少也很苦难。而且PowerVR芯片采样率基于tile的延迟渲染器，因此想要得到每个draw call花费的GPU时间几乎是不可能的。</p>
<p>一些其他的性能分析工具可以在Unity的<a href="https://docs.unity3d.com/Manual/MobileProfiling.html" target="_blank" rel="noopener">官方手册</a>中找到。</p>
<h2 id="减少draw-call数目"><a href="#减少draw-call数目" class="headerlink" title="减少draw call数目"></a><font size="5" color="red">减少draw call数目</font></h2><p>批处理的思想很简单，就是在每次调用draw call时尽可能多地处理多个物体。但是需要是使用同一个材质的物体才能一起进行批处理。Unity中支持两种批处理方式：一种是动态批处理，另一种是静态批处理。对于动态批处理来说，有点是一切处理都是Unity自动完成的，不需要我们自己做任何操作，而且物体是可以运动的（因为每一帧都会重新合并网格），但缺点是限制很多，可能一不小心破坏了这种机制，导致Unity无法动态批处理一些使用了相同材质的物体。而对于静态批处理来说，它的优点是自由度很高，限制很少，但缺点是可能会占用更多的内存，而且经过静态批处理后的所有物体都不可以再移动了（即使在脚本中尝试改变物体的位置也是无效的）。</p>
<h3 id="动态批处理"><a href="#动态批处理" class="headerlink" title="动态批处理"></a><font size="4" color="green">动态批处理</font></h3><p>动态批处理的基本原理是：<strong>每一帧</strong>把可以进行批处理的模型网格进行合并，再把合并后模型数据传递给GPU，然后使用同一个材质对其渲染。</p>
<p>但是除了要使用同一种材质，动态批处理还需要满足一些其他条件：</p>
<ul>
<li>网格的顶点属性规模要小于900。例如，如果shader中需要使用顶点位置、发现和纹理坐标这3个属性，那么要想模型能够被动态批处理，它的顶点数目不能超过300。</li>
<li>使用光照纹理时，必须保证物体的额外参数（比如光照纹理上的索引、偏移量等等）指向光照纹理中的同一个位置。</li>
<li>多Pass的shader会中断批处理。比如在前向渲染中，我们有时需要使用额外的Pass来为模型添加更多的光照效果，但这样一来这些模型是不会被动态批处理的。</li>
</ul>
<p>需要注意的是，只有物体在点光源的影响范围内，Unity才会调用额外的Pass来处理它。</p>
<h3 id="静态批处理"><a href="#静态批处理" class="headerlink" title="静态批处理"></a><font size="4" color="green">静态批处理</font></h3><p>它的实现原理是：只在运行开始阶段，把需要进行静态批处理的模型合并到一个新的网格结构中，这意味着这些模型不可以在运行时被移动。但由于它只需要进行一次合并操作，因此比动态批处理更加高效。静态批处理的另一个缺点是它往往于鏊占用更多的内存来存储合并后的几何结构。这时因为，如果静态批处理前一些物体共享相同的网格，那么静态批处理后每个物体将不再共享相同的网格，而是每个物体都会在内存里有一份对应的网格，即一个网格会复制成多个网格发给GPU。如果场景中存才很多这样共享相同网格的物体（比如场景中成千上万的树），那么静态批处理后可能就会造成内存带宽开销太大的性能瓶颈了。这个时候要么改用动态批处理（但要小心控制模型的顶点属性规模），或者自己编写批处理的方法。</p>
<p>在Unity中实现批处理，需要我们手动把物体面板上的Static框勾选上（实际上只需要勾选Batching Static）。</p>
<p>对于勾选了Static的所有静态物体，Unity首先会把这些静态物体变换到<strong>世界空间</strong>下，然后为它们构建一个更大的顶点和索引缓存。对于使用了同一材质的物体，Unity只需要调用一个draw call就可以绘制全部物体。而对于使用了不同材质的物体，静态批处理同样可以提升渲染性能。尽管这些物体仍然需要多个draw call，但静态批处理可以减少这些draw call之间的状态切换，而这些切换往往是费时的操作。</p>
<p>如果场景中包含了除了平行光以外的其他光源，并且在shader中定义了额外的Pass来处理它们，这些额外的Pass部分是不会被批处理的。但是处理平行光的Base Pass部分仍然会被静态批处理，因此仍然可以节省一些draw call。</p>
<h3 id="共享材质"><a href="#共享材质" class="headerlink" title="共享材质"></a><font size="4" color="green">共享材质</font></h3><p>无论是动态批处理还是静态批处理，都要求模型之间共享同一个材质。注意共享同一个材质不是说共享同一个Shader，而是还要包括Shader使用的各种参数也需要是一样的。</p>
<p>如果两个材质之间只有使用的纹理不同，我们可以把这些纹理合并到一张更大的纹理（称为图集），再使用不同的采样坐标对纹理采样。这样就可以变成使用同一个材质了。</p>
<p>但是如果是颜色等等参数不一样呢？一种常用的方法是使用网格的顶点数据来存储这些参数。比如，森林场景中所有的树使用了同一种材质，但不同的树颜色可能不同，如果我们想要通过批处理来减少draw call，可以利用网格顶点的颜色属性来调整。</p>
<p>还有一点需要注意，如果需要在脚本中访问共享材质，应该使用<code>Renderer.sharedMaterial</code>，而不是<code>Renderer.material</code>，后者会创建一个对应材质的复制品，从而破换批处理在对应物体上的应用，这可能不是我们希望看到的。</p>
<h3 id="批处理的注意事项"><a href="#批处理的注意事项" class="headerlink" title="批处理的注意事项"></a><font size="4" color="green">批处理的注意事项</font></h3><p>在选择使用动态批处理还是静态批处理时有一些小的建议：</p>
<ul>
<li>尽可能选择静态批处理，但得时刻小心对内存的消耗，并且记住经过静态批处理的物体不可以再被移动</li>
<li>如果无法进行静态批处理，而要使用动态批处理的话，请小心之前提到的各种条件限制</li>
<li>对于游戏中的小道具，例如金币等等，可以使用动态批处理</li>
<li>对于包含动画的这类物体，我们无法全部使用静态批处理，但其中如果有不动的部分，可以把这部分标识成static</li>
</ul>
<p>由于批处理需要把多个模型变换到世界空间下再合并它们，所以，如果shader中存在一些基于模型空间下的坐标运算，那么往往会得到错误的结果。可以在shader中使用<code>DisableBatching</code>标签来强制使用该Shader的材质不会被批处理。</p>
<p>使用半透明材质的物体通常需要使用严格的从后往前的绘制顺序来保证透明混合的正确性，对于这些物体，Unity会首先保证它们的绘制顺序，再尝试对它们进行批处理。所以，当绘制顺序无法满足时，批处理将无法再这些物体上被成功应用。</p>
<h2 id="减少需要处理的顶点数目"><a href="#减少需要处理的顶点数目" class="headerlink" title="减少需要处理的顶点数目"></a><font size="5" color="red">减少需要处理的顶点数目</font></h2><h3 id="优化几何体"><a href="#优化几何体" class="headerlink" title="优化几何体"></a><font size="4" color="green">优化几何体</font></h3><p>优化几何体通常是美术的事，不过有一点需要注意：Unity中显示的三角面片数目和顶点数目往往要多于建模软件里显示的数目，通常Unity显示的数目要大很多。这是因为有些顶点会有好几个纹理坐标（同一个点在不同的面上可能会有不同的纹理坐标）或者好几个法线或者切线（为了产生平滑的边界），这时Unity会把这个顶点拆分成好几个顶点。所以有一条几何优化的建议：移除不必要的硬边以及纹理衔接，避免边界平滑和纹理分离。</p>
<h3 id="模型的LOD技术"><a href="#模型的LOD技术" class="headerlink" title="模型的LOD技术"></a><font size="4" color="green">模型的LOD技术</font></h3><p>另一个减少顶点数目的方法是使用LOD技术。在Unity中，我们可以使用LOD Group组间来为一个物体构建一个LOD。我们需要为同一个对象准备多个包含不同细节程度的模型，然后把它们赋给LOD Group组间中的不同等级，Unity就会自动判断当前位置上需要使用哪个等级的模型。</p>
<h3 id="遮挡剔除技术"><a href="#遮挡剔除技术" class="headerlink" title="遮挡剔除技术"></a><font size="4" color="green">遮挡剔除技术</font></h3><p>遮挡剔除（Occlusion culling）可以用来消除那些在其他物体后面看到的物件，所以资源不会浪费在计算那些看不到的顶点上，进而提高性能。</p>
<p>遮挡剔除会使用一个虚拟的摄像机来遍历场景，从而构建一个潜在可见的对象集合的层级结构。在运行时刻，每个摄像机将会使用这个数据来识别哪些物体是可见的，而哪些被其他物体挡住不可见。使用遮挡剔除技术，不仅可以减少处理的顶点数目，还可以减少overdraw，提高游戏性能。</p>
<p>要在Unity中使用遮挡剔除技术，我们需要进行一系列额外的处理工作。具体步骤参见<a href="https://docs.unity3d.com/Manual/OcclusionCulling.html" target="_blank" rel="noopener">官方文档</a>。</p>
<p>模型的LOD技术和遮挡剔除技术可以同时减少CPU和GPU的负荷。CPU可以提交更少的draw call，而GPU需要处理的顶点和片元数目也减少了。</p>
<h2 id="减少需要处理的片元数目"><a href="#减少需要处理的片元数目" class="headerlink" title="减少需要处理的片元数目"></a><font size="5" color="red">减少需要处理的片元数目</font></h2><p>Unity提供了查看overdraw的视图，在Scene视图左上方的下拉菜单中选择Overdraw即可。实际上，这里的视图只是提供了查看物体相互遮挡的层数，并不是真正的最终屏幕绘制的overdraw。也就是说，可以理解为它显示的是，如果没有使用任何深度测试和其他优化策略时的overdraw。这种视图是通过把所有对象都渲染成一个透明的轮廓，通过查看透明颜色的累计程度，来判断物体之间的遮挡。</p>
<h3 id="控制绘制顺序"><a href="#控制绘制顺序" class="headerlink" title="控制绘制顺序"></a><font size="4" color="green">控制绘制顺序</font></h3><p>为了最大限度地避免overdraw，一个重要的优化策略就是控制绘制顺序。由于深度测试的存在，如果我们可以保证物体都是从前往后绘制的，那么就可以很大程度上减少overdraw。这是因为在后面绘制的物体由于无法通过深度测试，因此就不会再进行后面的渲染处理（感觉这个地方不太对，除非开启了前置深度测试~）。</p>
<p>在Unity中，那些渲染队列数目小于2500（如BackGround、Geometry、AlphaTest）的对象都被认为是不透明的物体，这些物体总体上是从前往后绘制的，而使用其他的队列（比如Transparent、Overlay等）的物体，都是从后往前绘制的。所以，我们可以尽可能地把物体的队列设置为不透明物体的渲染队列，而尽量避免使用半透明队列。有时候巧妙地设置一些物体的渲染队列，能够减少很多drawcall，节省很多渲染时间，比如把天空盒的队列设置为“Geometry+1”，这样就能保证它在所有物体之后绘制，而不会出现由它造成的overdraw。</p>
<h3 id="时刻警惕透明物体"><a href="#时刻警惕透明物体" class="headerlink" title="时刻警惕透明物体"></a><font size="4" color="green">时刻警惕透明物体</font></h3><p>半透明物体通常都是从后往前渲染，所以半透明物体几乎一定会造成overdraw。</p>
<p>例如GUI，我们应该尽量减少窗口中GUI所占的面积。如果实在无能为力，可以把GUI的绘制和三维场景的绘制交给不同的摄像机，并且视野范围尽量不要重叠。当然，这样可能会对游戏的美观度产生一定影响。</p>
<p>在移动平台上，透明度测试Alpha Test也会影响游戏性能。虽然透明度测试没有关闭深度写入，但由于它的实现使用了discard或clip操作，而这些操作会导致一些硬件的优化策略失效。这种时候，使用透明度混合的性能往往比使用透明度测试更好。</p>
<h3 id="减少实时光照和阴影"><a href="#减少实时光照和阴影" class="headerlink" title="减少实时光照和阴影"></a><font size="4" color="green">减少实时光照和阴影</font></h3><p>如果场景中包含了过多的点光源，并且使用了多个Pass的Shader，那么很有可能会造成性能下降。例如，一个场景里如果包含了3个逐像素的点光源，而且使用了逐像素的Shader，那么很有可能将draw call数目（CPU的瓶颈）提高3倍，同时也会增加overdraw（GPU的瓶颈）。这是因为，对于逐像素的光源来说，被这些光源照亮的物体需要被再渲染一次。更糟糕的是，无论是静态批处理还是动态批处理，对于这种额外的处理逐像素光源的Pass都无法进行批处理，即它们会中断批处理。</p>
<p>所以有些游戏往往使用了烘焙技术，把光照提前烘焙到一张光照纹理（lightmap）中，然后在运行时刻只需要根据纹理采样得到光照结果即可。另一种模拟光源的方法是使用<strong>God Ray</strong>。场景中很多小型光源的效果都是靠这种方法模拟的。它们一般并不是真的光源，而是通过透明纹理模拟得到的。</p>
<p>在移动平台上，一个物体使用的逐像素光源数目应该小于等于1（不包括平行光）。如果一定要使用更多的实时光，可以选择用逐顶点光照来代替。</p>
<p>在游戏《Shadow Gun》中，开发者们把复杂的光照计算存储到一张查找纹理（lookup texture，lookup table，LUT）中。然后在运行时，根据光源方向、视角方向、法线方向等参数来对LUT采样得到光照结果。使用LUT，不仅可以让我们使用BRDF等更出色的光照模型，还可以利用查找纹理的大小来进一步优化性能。比如主要角色可以使用更大分辨率的LUT，而一些NPC就使用较小的LUT。</p>
<p>实时阴影同样是一个非常消耗性能的效果。不仅是CPU需要提交更多的draw call，GPU也需要进行更多的处理。因此，我们应该尽量减少实时阴影，例如使用烘焙把静态物体的阴影信息存储到光照纹理中，而只对场景中的动态物体使用适当的实时阴影。</p>
<h2 id="节省带宽"><a href="#节省带宽" class="headerlink" title="节省带宽"></a><font size="5" color="red">节省带宽</font></h2><p>大量使用未经压缩的纹理以及使用过大的分辨率都会造成由于带宽而引发的性能瓶颈。</p>
<h3 id="减少纹理大小"><a href="#减少纹理大小" class="headerlink" title="减少纹理大小"></a><font size="4" color="green">减少纹理大小</font></h3><p>所有纹理的长宽比最好是正方形，而且长宽值最好是2的整数幂。这是因为很多优化策略只有在这种时候才可以发挥最大效用。</p>
<p>应该尽可能使用mipmap和纹理压缩。除非确定纹理不会发生缩放（例如GUI和2D游戏中的纹理），否则都应该为纹理生成相应的mipmap。</p>
<p>纹理压缩同样可以节省带宽。但是GPU架构不同，会有不同的纹理压缩格式。不过Unity可以根据不同的设备选择不同的压缩格式，而我们只需要把纹理压缩格式设置为自动压缩即可。</p>
<h3 id="利用分辨率缩放"><a href="#利用分辨率缩放" class="headerlink" title="利用分辨率缩放"></a><font size="4" color="green">利用分辨率缩放</font></h3><p>很多低端机，除了分辨率高其他硬件条件并不尽如人意，而这恰恰是游戏性能两个瓶颈：过大的屏幕分辨率和糟糕的GPU。这时我们可能需要对于特定机器进行分辨率的放缩。</p>
<h2 id="减少计算复杂度"><a href="#减少计算复杂度" class="headerlink" title="减少计算复杂度"></a><font size="5" color="red">减少计算复杂度</font></h2><h3 id="Shader的LOD技术"><a href="#Shader的LOD技术" class="headerlink" title="Shader的LOD技术"></a><font size="4" color="green">Shader的LOD技术</font></h3><p>可以通过在Shader中使用下面的语句来指定该Shader的LOD值：</p>
<pre class="line-numbers language-shader"><code class="language-shader">SubShder
{
    Tags{"RenderType" = "..."}
    LOD 200
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后在脚本里使用<code>Shader.maximumLOD</code>或者<code>Shader.globalMaximumLOD</code>来设置运行最大的LOD，这样那些LOD值大于阈值的Shader对应的物体就都不会被渲染了。这个其实就是选择性地开启特效。</p>
<h3 id="代码方面的优化"><a href="#代码方面的优化" class="headerlink" title="代码方面的优化"></a><font size="4" color="green">代码方面的优化</font></h3><p>下面是一些普遍成立的优化策略，但不一定绝对能提高效率（有时在某些设备上使用这些策略性能降低也是有可能的）：</p>
<ul>
<li>尽可能使用低精度的浮点值进行运算。最高精度的float/highp适用于存储注入顶点坐标等变量，但是计算速度最慢，应该尽量避免在片元着色器里使用这种精度；half/mediump适用于标量、纹理坐标等，计算速度大约是float的两倍；fixed/lowp适用于绝大多数颜色变量和归一化后的方向矢量。它的计算速度大约是float的4倍。</li>
<li>应该尽量避免在不同精度之间进行转换，这有可能会造成一定的性能下降。</li>
<li>应该使用尽可能少的插值变量。比如在顶点着色器里把两个纹理坐标打包到一个float4的变量中，然后传递给片元着色器。不过在PowerVRay硬件上，这个反而会带来性能下降。</li>
<li>尽可能不要使用全屏的屏幕后处理效果。</li>
<li>尽量把多个特效合并到一个Shader中。比如把颜色校正和添加噪声等屏幕特效合成到Bloom特效的最后一个Pass中。</li>
<li>尽可能不要使用分支或者循环语句。</li>
<li>尽可能避免使用sin、pow、log等等较为复杂的数学运算，可以使用查找表来作为代替。</li>
<li>尽可能不要使用discard操作，因为这会影响硬件的某些优化。</li>
</ul>
<h2 id="扩展阅读-3"><a href="#扩展阅读-3" class="headerlink" title="扩展阅读"></a><font size="5" color="red">扩展阅读</font></h2><ol>
<li>Unity官方手册的<a href>移动平台优化指南</a>以及手册中<a href>优化图形性能</a>一文，给出了常见的性能瓶颈以及相应的优化技术。</li>
<li>SIGGRAPH 2011上Unity<a href>关于移动平台上Shader优化</a>的演讲。</li>
<li>Unite 2013会议上，针对移动平台优化Unity游戏的演讲。</li>
<li>GDC 2014，Unity展示了如何使用内置的分析器分析移动平台的有些性能。</li>
<li>SIGGRAPH2015上，Unity的一些talk和course，包括Moving Mobile Graphics课程中关于移动平台上PBR的优化技术。</li>
<li>成功的移动平台游戏，比如Unite 2011上开发者给出了《Shadow Gun》中使用的渲染和优化技术，并且2012年他们还放出了示例场景，来让更多的开发者学习如何优化移动平台上的shader。</li>
<li>Unity Store里的《Angry Bots》游戏项目，也是学习游戏优化的好实例。</li>
</ol>
<hr>
<p>参考文献：《Unity Shader入门精要》</p>

            </div>

            <!-- Post Comments -->
            
    <!-- 使用 DISQUS_CLICK -->
<div id="disqus-comment">
    <div id="disqus_thread"></div>

<!-- add animation -->
<style>
	.disqus_click_btn {
            line-height: 30px;
            margin: 0;
            min-width: 50px;
            padding: 0 14px;
            display: inline-block;
            font-family: "Roboto", "Helvetica", "Arial", sans-serif;
            font-size: 14px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0;
            overflow: hidden;
            will-change: box-shadow;
            transition: box-shadow .2s cubic-bezier(.4, 0, 1, 1), background-color .2s cubic-bezier(.4, 0, .2, 1), color .2s cubic-bezier(.4, 0, .2, 1);
            outline: 0;
            cursor: pointer;
            text-decoration: none;
            text-align: center;
            vertical-align: middle;
            border: 0;
            background: rgba(158, 158, 158, .2);
            box-shadow: 0 2px 2px 0 rgba(0, 0, 0, .14), 0 3px 1px -2px rgba(0, 0, 0, .2), 0 1px 5px 0 rgba(0, 0, 0, .12);
            color: #fff;
            background-color: #7EC0EE;
            text-shadow: 0
        }
</style>
	
<div class="btn_click_load" id="disqus_bt"> 
    <button class="disqus_click_btn">点击查看评论</button>
</div>

<!--
<script type="text/javascript">
$('.btn_click_load').click(function() {
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'http-miccall-tech'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    document.getElementById('disqus_bt').style.display = "none";
});
</script>
-->
<script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://yoursite.com/2019/04/29/Unity-Shader高级篇/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = 'http://yoursite.com/2019/04/29/Unity-Shader高级篇/'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
</script>

<script type="text/javascript">
    $('.btn_click_load').click(function() {  //click to load comments
        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document;
            var s = d.createElement('script');
            s.src = '//http-miccall-tech.disqus.com/embed.js';
            s.setAttribute('data-timestamp', + new Date());
            (d.head || d.body).appendChild(s);
        })();
        $('.btn_click_load').css('display','none');
    });
</script>
</div>
<style>
    #disqus-comment{
        background-color: #eee;
        padding: 2pc;
    }
</style>


        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
                <li>Design: <a href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
            </ul>
            
            	<span id="busuanzi_container_site_pv">2019总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			
        </div>
    </div>
</body>



 	
</html>
