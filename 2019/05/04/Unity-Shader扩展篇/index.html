<!DOCTYPE HTML>
<html>

<head><meta name="generator" content="Hexo 3.9.0">
	<link rel="bookmark" type="image/x-icon" href="/img/logo_miccall.png">
	 <link rel="shortcut icon" href="/img/logo_miccall.png">
	
			
    <title>
    Elays'Blog
    </title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
	<script>
	(function(){
		if('{{ page.password }}'){
			if (prompt('请输入文章密码') !== "aaa"){
				alert('密码错误！');
				history.back();
			}
		}
	})();
	</script>
    <link rel="stylesheet" href="/css/mic_main.css">
    <link rel="stylesheet" href="/css/dropdownMenu.css">
    
    	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css">
    </noscript>
			    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<link rel="stylesheet" href="/css/prism-dark.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>
    
		
<!-- Layouts -->


<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<!--<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">-->
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/latest.js?config=TeX-MML-AM_CHTML">
</script>

<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_undefined.css">
<link rel="stylesheet" href="/css/typo.css">
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">MICCALL</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special">
            <ul class="menu links">
			<!-- Homepage  主页  --> 
			<li>
	            <a href="/" rel="nofollow">主页</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">分类</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="/categories/C/">C#</a></li><li><a class="category-link" href="/categories/C-语法/">C#语法</a></li><li><a class="category-link" href="/categories/C/">C++</a></li><li><a class="category-link" href="/categories/C语言/">C语言</a></li><li><a class="category-link" href="/categories/Graphics/">Graphics</a></li><li><a class="category-link" href="/categories/Math/">Math</a></li><li><a class="category-link" href="/categories/OpenGL/">OpenGL</a></li><li><a class="category-link" href="/categories/Unity/">Unity</a></li><li><a class="category-link" href="/categories/博客配置/">博客配置</a></li><li><a class="category-link" href="/categories/并行计算/">并行计算</a></li><li><a class="category-link" href="/categories/操作系统/">操作系统</a></li><li><a class="category-link" href="/categories/数据结构/">数据结构</a></li><li><a class="category-link" href="/categories/毕设/">毕设</a></li><li><a class="category-link" href="/categories/游戏开发/">游戏开发</a></li><li><a class="category-link" href="/categories/计算机系统/">计算机系统</a></li><li><a class="category-link" href="/categories/设计模式/">设计模式</a></li><li><a class="category-link" href="/categories/面试/">面试</a>
	                    </li></ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/gallery/" title="图库">
		                图库
		            </a>
		        </li>
		        
		        <li>
		            <a href="/tag/" title="搜索">
		                搜索
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
		            
		                <li><a href="https://github.com/miccall" class="icon fa-github"><span class="label">GitHub</span></a></li>
		            
		            
		            
		            
			</ul>
</nav>

        <div id="main">
            <div class="post_page_title_img" style="height: 25rem;background-image: url(https://github.com/Popperelay/Photos/blob/master/Photos/UnityShader%E6%89%A9%E5%B1%95%E7%AF%87_BG.jpg?raw=true);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;">
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2>Unity Shader扩展篇</h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
				<!-- 目录 -->
				<p class="show-toc-btn" id="show-toc-btn" onclick="showToc();" style="display:none">
				<span class="btn-bg"></span>
				<span class="btn-text">文章导航</span>
				</p>
				<div id="toc-article" class="toc-article">
					<span id="toc-close" class="toc-close" title="隐藏导航" onclick="showBtn();">×</span>
					<strong class="toc-title">文章目录</strong>
					<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#第十七章-Unity的表面着色器探秘"><span class="toc-text">第十七章 Unity的表面着色器探秘</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#表面着色器的一个例子"><span class="toc-text">表面着色器的一个例子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#编译指令"><span class="toc-text">编译指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#表面函数"><span class="toc-text">表面函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#光照函数"><span class="toc-text">光照函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#其他可选参数"><span class="toc-text">其他可选参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#两个结构体"><span class="toc-text">两个结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#数据来源：Input结构体"><span class="toc-text">数据来源：Input结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#表面属性：SurfaceOutput结构体"><span class="toc-text">表面属性：SurfaceOutput结构体</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Unity背后做了什么"><span class="toc-text">Unity背后做了什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#表面着色器实例代码分析"><span class="toc-text">表面着色器实例代码分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#表面着色器的缺点"><span class="toc-text">表面着色器的缺点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第十八章-基于物理的渲染"><span class="toc-text">第十八章 基于物理的渲染</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#PBS的理论和数学基础"><span class="toc-text">PBS的理论和数学基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#光是什么"><span class="toc-text">光是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#渲染方程"><span class="toc-text">渲染方程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#精确光源"><span class="toc-text">精确光源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#双向反射分布函数BRDF"><span class="toc-text">双向反射分布函数BRDF</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#漫反射项"><span class="toc-text">漫反射项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#高光反射项"><span class="toc-text">高光反射项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PBS-中的光照"><span class="toc-text">PBS 中的光照</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Unity中的PBS实现"><span class="toc-text">Unity中的PBS实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#动手：PBS实践"><span class="toc-text">动手：PBS实践</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Unity-5的Standard-Shader"><span class="toc-text">Unity 5的Standard Shader</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#它们是如何实现的"><span class="toc-text">它们是如何实现的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何使用Standard-Shader"><span class="toc-text">如何使用Standard Shader</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#一个更加复杂的例子"><span class="toc-text">一个更加复杂的例子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#答疑解惑"><span class="toc-text">答疑解惑</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是全局光照"><span class="toc-text">什么是全局光照</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是伽马校正"><span class="toc-text">什么是伽马校正</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是HDR"><span class="toc-text">什么是HDR</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#扩展阅读"><span class="toc-text">扩展阅读</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第二十章-还有更多内容吗"><span class="toc-text">第二十章 还有更多内容吗</span></a></li></ol>
			   </div>
			   <script type="text/javascript">
				function showToc(){
					var toc_article = document.getElementById("toc-article");
					var show_toc_btn = document.getElementById("show-toc-btn");
					toc_article.setAttribute("style","display:block");
					show_toc_btn.setAttribute("style","display:none");
					};
				function showBtn(){
					var toc_article = document.getElementById("toc-article");
					var show_toc_btn = document.getElementById("show-toc-btn");
					toc_article.setAttribute("style","display:none");
					show_toc_btn.setAttribute("style","display:block");
					};
			   </script>
				
                <h1 id="第十七章-Unity的表面着色器探秘"><a href="#第十七章-Unity的表面着色器探秘" class="headerlink" title="第十七章 Unity的表面着色器探秘"></a><font size="6" color="orange">第十七章 Unity的表面着色器探秘</font></h1><p>Unity的著名渲染工程师Aras认为，把渲染流程分为顶点和像素的抽象层面是错误的，是一种不易理解的抽象。相反，他认为，应该划分成表面着色器、光照模型和光照着色器这样的层面。其中，表面着色器定义了模型表面的反射率、法线、高光等；光照模型则选择是用Lambert还是Blinn-Phong等模型；而光照着色器负责计算光照衰减、阴影等。这样绝大部分时间我们只需要和表面着色器打交道，比如混合纹理和颜色等。</p>
<p>其实Unity的表面着色器（Surface）实际上就是在顶点/片元着色器上又添加了一层抽象，即Unity在背后会根据表面着色器生成一个包含了很多Pass的顶点/片元着色器。</p>
<h2 id="表面着色器的一个例子"><a href="#表面着色器的一个例子" class="headerlink" title="表面着色器的一个例子"></a><font size="5" color="red">表面着色器的一个例子</font></h2><p>下面直接来看一个表面着色器的Shader代码：</p>
<pre class="line-numbers language-shader"><code class="language-shader">Shader "Unity Shaders Book/Chapter 17/BumpedDiffuse"
{
    Properties
    {
        _MainTex ("Base (RGB)", 2D) = "white" {}
        _BumpMap("Normal Map", 2D) = "bump"{}
        _Color ("Main Color", Color) = (1, 1, 1, 1)
    }
    SubShader
    {
        Tags{"RenderType" = "Opaque"}
        LOD 300

        CGPROGRAM

        #pragma surface surf Lambert
        #pragma target 3.0

        sampler2D _MainTex;
        sampler2D _BumpMap;
        fixed4 _Color;

        struct Input
        {
            float2 uv_MainTex;
            float2 uv_BumpMap;
        };

        void surf(Input IN, inout SurfaceOutput o)
        {
            fixed4 tex = tex2D(_MainTex, IN.uv_MainTex);
            o.Albedo = tex.rgb * _Color.rgb;
            o.Alpha = tex.a * _Color.a;
            o.Normal = UnpackNormal(tex2D(_BumpMap, IN.uv_BumpMap));
        }

        ENDCG
    }
    FallBack "Legacy Shaders/Diffuse"
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到表面着色器的CG代码是直接而且必须写在SubShader块中的，Unity会在背后为我们生成多个Pass。在CG代码里我们只需要添加一些编译指令、定义一个结构体，在表面函数<code>surf</code>中另一个结构体的值。然后我们无需改动Shader代码，就可以向场景中任意添加一些点光源和聚光灯，改变它们的颜色，就能得到如下图所示的结果：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/UnityShader%E6%89%A9%E5%B1%95%E7%AF%87_1.jpg?raw=true" alt><br>可以看到，一个表面着色器最重要的部分是编译指令以及两个结构体。下面我们分别来看一下。</p>
<h2 id="编译指令"><a href="#编译指令" class="headerlink" title="编译指令"></a><font size="5" color="red">编译指令</font></h2><p>编译指令最重要的作用是指明该表面着色器使用的表面函数和光照函数，以及一些其他可选的参数。其格式如下：</p>
<pre class="line-numbers language-shader"><code class="language-shader">#pragma surface surfaceFunction lightModel [optionalparams]
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>其中<code>#pragma surface</code>用于指明该编译指令是用于定义表面着色器的，在它的后面需要指明使用的表面函数（surfaceFunction ）和光照模型（lightModel ）以及一些可选参数（optionalparams）。</p>
<h3 id="表面函数"><a href="#表面函数" class="headerlink" title="表面函数"></a><font size="4" color="green">表面函数</font></h3><p>表面着色器的优点在于抽象出了表面这一概念。一个对象的表面属性定义了它的反射率、光滑度、透明度等值。而编译指令中的<code>surfaceFunction</code>函数就是用于定义这些表面属性的。它的函数格式是固定的（函数名可变）：</p>
<pre class="line-numbers language-shader"><code class="language-shader">void surf(Input IN, inout SurfaceOutput o);
void surf(Input IN, inout SurfaceOutputStandard o);
void surf(Input IN, inout SurfaceOutputStandradSpecular o);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>在表面函数中，输入结构体<code>Input IN</code>包含了许多表面属性的数据来源，Unity会自动计算Input里的数据，我们只需要定义并使用该结构体。然后在表面函数<code>surf</code>中我们自定义计算各种表面属性，并把结果存储到输出结构体<code>SurfaceOutput</code>、<code>SurfaceOutputStandard</code>或<code>SurfaceOutputStandradSpecular</code>中。Unity会把输出结构体的值传递给光照函数进行光照计算。</p>
<h3 id="光照函数"><a href="#光照函数" class="headerlink" title="光照函数"></a><font size="4" color="green">光照函数</font></h3><p>除了表面函数，我们还需要在编译指令中指定另一个非常重要的函数：光照函数。光照函数会使用表面函数中输出的各种表面属性，来应用某些光照模型，进而模拟物体表面的光照效果。Unity内置了基于物理的光照模型函数Standard和StandardSpecular（定义在UnityPBSLighting.cginc文件中），以及简单的非基于物理的光照模型函数Lambert和BlinnPhong（定义在Lighting.cginc文件中）。</p>
<p>不过我们也可以定义自己的光照函数。自定义前向渲染中的光照函数的格式如下：</p>
<pre class="line-numbers language-shader"><code class="language-shader">//用于不依赖视角的光照模型，例如漫反射
half4 LightingName(SurfaceOutput s, half3 lightDir, half atten);
//用于依赖视角的光照模型，例如镜面反射
half4 LightingName(SurfaceOutput s, half3 lightDir, half3 viewDir, half atten);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们可以在Unity的<a href="https://docs.unity3d.com/Manual/SL-SurfaceShaderLighting.html" target="_blank" rel="noopener">《表面着色器的自定义光照模型》</a>以及<a href="https://docs.unity3d.com/Manual/SL-SurfaceShaderLightingExamples.html" target="_blank" rel="noopener">《表面着色器的光照例子》</a>中找到更全面的介绍和示例。</p>
<h3 id="其他可选参数"><a href="#其他可选参数" class="headerlink" title="其他可选参数"></a><font size="4" color="green">其他可选参数</font></h3><p>编译指令的可选参数中，包含的比较重要和常用的参数如下：</p>
<ul>
<li>顶点修改函数（<code>vertex:VertexFunction</code>）和最终颜色修改函数(<code>finalcolor:ColorFunction</code>)。顶点修改函数允许我们自定义一些顶点属性（例如把顶点颜色传递给表面函数，或者修改顶点位置来实现某些顶点动画）。最终颜色修改函数允许我们在颜色绘制到屏幕前，最后一次修改颜色值（例如实现自定义的雾效等）。</li>
<li>阴影。例如使用<code>addshadow</code>参数会为表面着色器生成一个阴影投射的Pass；使用<code>fullforwardshadows</code>参数可以让点光源或聚光灯在前向渲染中也可以有阴影（因为默认情况下Unity只会为最重要的平行光生成阴影）；也可以使用<code>noshadow</code>参数来禁用阴影。</li>
<li>Alpha Test和Alpha Blend。例如<code>alphatest:VariableName</code>参数会使用名为VariableName的变量来剔除不满足条件的片元（这时可能还需要使用上面的<code>addshadow</code>参数来生成正确的阴影投射的Pass）；使用<code>alpha</code>参数会进行透明混合。</li>
<li>光照。例如<code>noambient</code>参数会告诉Unity不要用任何环境光照或光照探针（light probe）；<code>novertexlights</code>参数会告诉Unity不要应用任何逐顶点光照；<code>noforwardadd</code>参数会告诉Unity去掉所有前向渲染中的额外的Pass（也就是告诉Unity只支持一个逐像素的平行光，其他的光源使用逐顶点或者SH的光照方式，常用于移动平台中）；还有一些控制光照烘焙、雾效模拟的参数，如<code>nolightmap</code>、<code>nofog</code>等。</li>
<li>控制代码的生成。例如使用<code>exclude_path:deferred</code>、<code>exclude_path:forward</code>、<code>exclude_path:prepass</code>参数来告诉Unity不需要为某些渲染路径生成代码（因为默认情况下Unity会为一个表面着色器生成相应的前向渲染路径、延迟渲染路径使用的代码，导致生成的Shader文件比较大）。</li>
</ul>
<h2 id="两个结构体"><a href="#两个结构体" class="headerlink" title="两个结构体"></a><font size="5" color="red">两个结构体</font></h2><h3 id="数据来源：Input结构体"><a href="#数据来源：Input结构体" class="headerlink" title="数据来源：Input结构体"></a><font size="4" color="green">数据来源：Input结构体</font></h3><p>Input结构体包含了许多表面属性的数据来源，因此它会作为表面函数的输入结构体（如果自定义了顶点修改函数，它还会作为顶点修改函数的输出结构体）。该结构体支持的内置变量如下表：</p>
<table>
<thead>
<tr>
<th style="text-align:left">变量</th>
<th style="text-align:left">描述 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">uv_TexName</td>
<td style="text-align:left">纹理<code>_TexName</code>对应的纹理坐标</td>
</tr>
<tr>
<td style="text-align:left">float3 viewDir</td>
<td style="text-align:left">视角方向</td>
</tr>
<tr>
<td style="text-align:left">float4 screenPos</td>
<td style="text-align:left">屏幕空间坐标</td>
</tr>
<tr>
<td style="text-align:left">flaot3 worldPos</td>
<td style="text-align:left">世界空间下的位置</td>
</tr>
<tr>
<td style="text-align:left">float3 worldRefl</td>
<td style="text-align:left">世界空间下的反射方向（前提是没有修改表面法线o.Normal）</td>
</tr>
<tr>
<td style="text-align:left">float3 worldRefl; INTERNAL_DATA</td>
<td style="text-align:left">如果修改了表面法线o.Normal，需要使用该变量告诉Unity要基于修改后的法线计算世界空间下的反射方向。在表面函数中，我们需要使用<code>WorldReflectionVector(IN, o.Normal)</code>函数得到世界空间下的反射方向</td>
</tr>
<tr>
<td style="text-align:left">float3 worldNormal</td>
<td style="text-align:left">世界空间下的法线方向（前提是没有修改表面法线o.Normal）</td>
</tr>
<tr>
<td style="text-align:left">float3 worldNormal; INTERNAL_DATA</td>
<td style="text-align:left">如果修改了表面法线o.Normal，需要使用该变量告诉Unity要基于修改后的法线计算世界空间下的反射方向。在表面函数中，我们需要使用<code>WorldNormalVector(IN, o.Normal)</code>函数得到世界空间下的法线方向</td>
</tr>
</tbody>
</table>
<p>需要注意的是，我们并不需要自己计算上述的各个变量，而只需要在Input结构体中按上述名称严格声明这些变量即可，Unity会在背后为我们准备好这些数据，而我们只需要在表面函数中直接使用它们即可。</p>
<p>除此之外，还可以再Input结构体中自定义一些属性。</p>
<h3 id="表面属性：SurfaceOutput结构体"><a href="#表面属性：SurfaceOutput结构体" class="headerlink" title="表面属性：SurfaceOutput结构体"></a><font size="4" color="green">表面属性：SurfaceOutput结构体</font></h3><p>有了Input结构体来提供所需要的数据后，我们就可以据此计算各种表面属性。<code>SurfaceOutput</code>、<code>SurfaceOutputStandard</code>和<code>SurfaceOutputStandradSpecular</code>这些结构体就是用来存储表面属性的。它会作为表面函数的输出，随后会作为光照函数的输入来进行各种光照计算。相比于Input结构体的自由性，这些结构体里的变量是提前就声明好的，不可以增加也不会减少（如果没有对某些变量赋值，就会使用默认值）。如果使用了非基于物理的光照模型，我们通常会使用<code>SurfaceOutput</code>结构体，而如果使用了基于物理的光照模型Standard或StandardSpecular，我们会分别使用<code>SurfaceOutputStandard</code>或<code>SurfaceOutputStandradSpecular</code>结构体。前者结构体用于默认的金属工作流（Metallic Workflow），对应了Standard光照函数；而后者结构体用于高光工作流（Specular Workflow），对应了StandardSpecular光照函数。</p>
<h2 id="Unity背后做了什么"><a href="#Unity背后做了什么" class="headerlink" title="Unity背后做了什么"></a><font size="5" color="red">Unity背后做了什么</font></h2><p>Unity在背后会根据表面着色器生成一个包含了很多Pass的顶点/片元着色器。而且Unity提供了一个功能：在每个编译完成的编码着色器的面板上，都有一个”Show generated code”的按钮，点击它就可以看到Unity为这个表面着色器生成的所有顶点/片元着色器代码。</p>
<p>表面着色器的渲染计算流水线如下图所示（其中黄色的是可以自定义的函数，灰色的是Unity自动生成的计算步骤）：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/UnityShader%E6%89%A9%E5%B1%95%E7%AF%87_2.jpg?raw=true" alt><br>其中调用光照函数时，如果使用的是内置的Lambert或BlinnPhong光照函数，Unity还会自动计算动态全局光照，并添加到光照模型的计算中。在进行其他颜色叠加时，如果没有使用光照烘焙，还会添加逐顶点光照的影响。</p>
<h2 id="表面着色器实例代码分析"><a href="#表面着色器实例代码分析" class="headerlink" title="表面着色器实例代码分析"></a><font size="5" color="red">表面着色器实例代码分析</font></h2><p>下面的表面着色器Shader，效果是对模型按法线进行膨胀：</p>
<pre class="line-numbers language-shader"><code class="language-shader">Shader "Unity Shaders Book/Chapter 17/NormalExtrusion"
{
    Properties
    {
        _MainTex ("Base (RGB)", 2D) = "white" {}
        _BumpMap("Normal Map", 2D) = "bump"{}
        _ColorTint("Color Tint", Color) = (1, 1, 1, 1)
        _Amount("Extrusion Amount", Range(-0.5, 0.5)) = 0.1
    }
    SubShader
    {
        Tags{"RenderType" = "Opaque"}
        LOD 300

        CGPROGRAM

        #pragma surface surf CustomLambert vertex:myvert finalcolor:mycolor addshadow exclude_path:deferred exclude_path:prepass nometa
        #pragma target 3.0

        sampler2D _MainTex;
        sampler2D _BumpMap;
        fixed4 _ColorTint;
        half   _Amount;

        struct Input
        {
            float2 uv_MainTex;
            float2 uv_BumpMap;
        };

        void myvert(inout appdata_full v)
        {
            v.vertex.xyz += v.normal * _Amount;
        }

        void surf(Input IN, inout SurfaceOutput o)
        {
            fixed4 tex = tex2D(_MainTex, IN.uv_MainTex);
            o.Albedo = tex.rgb;
            o.Alpha = tex.a;
            o.Normal = UnpackNormal(tex2D(_BumpMap, IN.uv_BumpMap));
        }

        half4 LightingCustomLambert(SurfaceOutput s, half3 lightDir, half atten)
        {
            half NdotL = dot(s.Normal, lightDir);
            half4 c;
            c.rgb = s.Albedo * _LightColor0.rgb * (NdotL * atten);
            c.a = s.Alpha;
            return c;
        }

        void mycolor(Input IN, SurfaceOutput o, inout fixed4 color)
        {
            color *= _ColorTint;
        }

        ENDCG
    }
    FallBack "Legacy Shaders/Diffuse"
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到其中用到了自定义的光照函数、顶点修改函数、最终颜色修改函数、添加ShadowCasterPass、取消对延迟渲染路径生成相应的shader代码，并且使用<code>nometa</code>参数取消对提取元数据的Pass的生成。渲染结果如下图：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/UnityShader%E6%89%A9%E5%B1%95%E7%AF%87_3.jpg?raw=true" alt></p>
<p>感兴趣的话，推荐点击“Show Generated Code”，看一下Unity在背后为该表面着色器生成的顶点/片元着色器代码。</p>
<h2 id="表面着色器的缺点"><a href="#表面着色器的缺点" class="headerlink" title="表面着色器的缺点"></a><font size="5" color="red">表面着色器的缺点</font></h2><p>表面着色器虽然可以快速实现各种光照效果，但我们失去了对各种优化和各种特效实现的控制。因此，使用表面着色器往往会对性能造成一定影响。除了性能比较差以外，表面着色器还无法完成一些自定义的渲染效果，比如之前实现过的玻璃效果。所以，下面有一些建议：</p>
<ul>
<li>如果需要和各种光源打交道，尤其是想要使用Unity中的全局光照的话，可以使用表面着色器，但要时刻小心它的性能</li>
<li>如果需要处理的光源数目非常少，例如只有一个平行光，那么使用顶点/片元着色器是一个更好的选择</li>
<li>最重要的是，如果有很多自定义的渲染效果，那么请选择顶点/片元着色器</li>
</ul>
<h1 id="第十八章-基于物理的渲染"><a href="#第十八章-基于物理的渲染" class="headerlink" title="第十八章 基于物理的渲染"></a><font size="6" color="orange">第十八章 基于物理的渲染</font></h1><hr>
<h2 id="PBS的理论和数学基础"><a href="#PBS的理论和数学基础" class="headerlink" title="PBS的理论和数学基础"></a><font size="5" color="red">PBS的理论和数学基础</font></h2><h3 id="光是什么"><a href="#光是什么" class="headerlink" title="光是什么"></a><font size="4" color="green">光是什么</font></h3><p>光射到表面后有一部分会折射进物体内部，折射进物体内部的光有一部分会被吸收，另一部分会散射到外部。由于散射光线的出射位置不同，可以分为下图所示的两种情况：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/UnityShader%E6%89%A9%E5%B1%95%E7%AF%87_4.jpg?raw=true" alt><br>左图：散射光线的出射位置到入射点的距离大于像素大小，这时需要使用次表面散射技术来渲染；右图：散射光线的出射位置到入射点的距离小于像素大小，这时渲染可有完全在局部完成，用常用的漫反射渲染即可。</p>
<h3 id="渲染方程"><a href="#渲染方程" class="headerlink" title="渲染方程"></a><font size="4" color="green">渲染方程</font></h3><p>图形学中大名鼎鼎的渲染方程如下图所示：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/UnityShader%E6%89%A9%E5%B1%95%E7%AF%87_5.png?raw=true" alt><br>当去掉其中的自发光项$L_e(v)$后，剩余的部分就是著名的反射率方程（Reflection Equation）。</p>
<h3 id="精确光源"><a href="#精确光源" class="headerlink" title="精确光源"></a><font size="4" color="green">精确光源</font></h3><p>对于一个精确光源，我们可以使用下面的等式来计算它在某个观察方向$v$上的出射辐射率：<br>$$<br>L_o(v)=\pi f(l_c,v)c_{light}(n\cdot l_c)<br>$$<br>其中$l_c$表示光源到着色点的方向，$c_{light}$表示光源的颜色，$n$表示着色点的法线，$f(l_c,v)$表示给定某个入射方向的入射光后，有多少百分比的光照被反射到了观察方向上，这个$f$叫做双向反射分布函数，即BRDF。</p>
<p>上面的反射率方程可以用若干个精确光源来近似表示：<br>$$<br>L_o(v)=\sum_{i=0}^{n}L_o^i(v)=\sum_{i=0}^{n}\pi f(l_c^i,v)c_{light}(n\cdot l_{c}^{i})<br>$$</p>
<h3 id="双向反射分布函数BRDF"><a href="#双向反射分布函数BRDF" class="headerlink" title="双向反射分布函数BRDF"></a><font size="4" color="green">双向反射分布函数BRDF</font></h3><p>如果绕着表面法线旋转入射方向和观察方向并不会影响BRDF的结果，这种BDRF被称为是各向同性（isotropic）的BRDF，相反则是各向异性（anisotropic）的BRDF。</p>
<p>BDRF，即$f(l,v)$表示当一束光沿着入射方向$l$到达表面某点时，有多少部分的能量被反射到了观察方向$v$上。</p>
<p>BRDF包含两种不同的物理现象：高光反射项（即表面反射现象）和漫反射项（即次表面散射现象）。</p>
<p>Disney向公众开源了一个名为<a href="https://github.com/wdas/brdf" target="_blank" rel="noopener">BRDFExplorer</a>的软件，来让用户可以直接地对比各种分析型BRDF模型与真实测量得到的BRDF值之间的差异。</p>
<p>下面分别来看一下BRDF的漫反射项和高光反射项。</p>
<h3 id="漫反射项"><a href="#漫反射项" class="headerlink" title="漫反射项"></a><font size="4" color="green">漫反射项</font></h3><p>Lambert模型是最简单、应用最广泛的漫反射BRDF：<br>$$<br>f_{Lambert}(l,v)=\frac{c_{diff}}{\pi}<br>$$<br>其中，$c_{diff}$表示漫反射光线所占的比例，通常被称为是漫反射颜色。之所以要除以$\pi$，是因为我们假设漫反射在所有方向上的强度都是相同的，而BRDF要求在半球内的积分值为1。</p>
<p>结合前面精确光源的出射辐射率公式，可以得到入射方向为$l$d的光源在某点的出射漫反射辐射率为：<br>$$<br>L_o(v)=\pi f_{Lambert}(l,v)c_{light}(n\cdot l)=c_{diff}c_{light}(n\cdot l)<br>$$<br>可以看到和我们之前一直使用的漫反射项基本完全一样。</p>
<p>但是通过对真实材质的BRDF数据进行分析，研究人员发现许多材质在掠射角表现出了明显的高光反射峰值，而且还与表面的粗糙度有着强烈的联系：粗糙表面在掠射角容易形成一条亮边，而相反地光滑表面则容易在掠射角形成一条阴影边。这些都是Lambert模型无法描述的。如下图所示：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/UnityShader%E6%89%A9%E5%B1%95%E7%AF%87_6.png?raw=true" alt><br>图中从左到右是粗糙材质和光滑材质的真实漫反射结果，以及 Lambert 漫反射结果。</p>
<p>所以，许多基于物理的渲染选择使用更加复杂的漫反射项来模拟更加真实的次表面散射结果。比如在Disney BRDF中，它的漫反射项为：<br>$$<br>f_{diff}(l,v)=\frac{baseColor}{\pi}(1+(F_{D90}-1)(1-n\cdot l)^5)(1+(F_{D90}-1)(1-n\cdot v)^5)<br>$$<br>其中，$F_{D90}=0.5+2roughness(h\cdot l)^2$，$baseColor$是表面颜色，$roughness$是粗糙度。该漫反射模型使得光滑材质可以在掠射角具有更明显的阴影边，又使得粗糙材质在掠射角具有亮边。该式子也是Unity 5内部使用的漫反射项。</p>
<h3 id="高光反射项"><a href="#高光反射项" class="headerlink" title="高光反射项"></a><font size="4" color="green">高光反射项</font></h3><p>当我们计算 BRDF 时，入射方向$l$和观察方向$v$都会被给定，这意味着只有一部分微面元反射的光线才会进入到我们的眼睛中，这部分微面元会恰好把光线反射到方向$v$上，即它们的法线$m$等于$l$和$v$的一半，也就是我们一直看到的半角度矢量$h$（half-angle vector，也被称为 half vector）。然而，这些$m = h$的微面元反射也并不会全部添加到 BRDF 的计算中。这是因为，它们其中一部分会在入射方向 l 上被其他微面元挡住（shadowing），或是在它们的反射方向$v$上被其他微面元挡住了（masking）。微面元理论认为，所有这些被遮挡住的微面元不会添加到高光反射项的计算中。</p>
<p>基于微面元理论的这些假设，BRDF的高光反射项可以用如下公式表示：<br>$$<br>f_{spec}(l,v)=\frac{F(l,h)G(l,v,h)D(h)}{4(n\cdot l)(n \cdot v)}<br>$$<br>这就是著名的Torrance-Sparrow微面元模型。$D(h)$是微面元的法线分布函数 （ normal distribution function ， NDF ） ，它用于计算有多少比例的微面元的法线满足$m=h$，只有这部分微面元才会把光线从$l$方向反射到$v$上。$G(l, v, h)$是阴影—遮掩函数（ shadowing-masking function ） ，它用于计算那些满足$m=h$的微面元中有多少会由于遮挡而不会被人眼看到，因此它给出了活跃的微面元（active microfacets）所占的浓度，只有活跃的微面元才会成功地把光线反射到观察方向上。$F(l, h)$则是这些活跃微面元的菲涅尔反射（ Fresnel reflectance ）函数，它可以告诉我们每个活跃的微面元会把多少入射光线反射到观察方向上，即表示了反射光线占入射光线的比率。事实上，现实生活中几乎所有的物体都会表现出菲涅耳现象。最后，分母$4(n ⋅ l)(n ⋅ v)$是用于校正从微面元的局部空间到整体宏观表面数量差异的校正因子。</p>
<ul>
<li>菲涅耳反射函数<br>  菲涅耳反射函数计算了光学表面反射光线所占的部分，它表明了当光照方向和观察方向夹角逐渐增大时高光反射强度增大的现象。多数 PBS 实现选择使用Schlick 菲涅耳近似等式 [7] 来得到近似的菲涅尔反射效果：<br>$$<br>F_{Schlick}(l,h)=c_{spec}+(1-c_{spec})(1-(l\cdot h))^5<br>$$<br>其中，$c_{spec}$是材质的高光反射颜色。通过对真实世界材质的观察，人们发现金属材质的高光反射颜色值往往比较大，而非金属材质的反射颜色值则往往较小。</li>
<li><p>法线分布函数<br>  法线分布函数$D(h)$表示了对于当前表面来说有多少比例的微面元的法线满足$m=h$，这意味着只有这些微面元才会把光线从 l 方向反射到 v 上。它决定了高光区域的大小、亮度和形状，因此是高光反射项中非常重要的一项。Blinn-Phong 模型使用的法线分布函数$D(h)$为：<br>$$<br>D_{blinn}(h)=\frac{gloss+2}{2\pi}(n\cdot h)^{gloss}<br>$$<br>上面的式子和我们之前所见的 Blinn-Phong 模型有所不同，这是因为我们在里面加入了归一化因子，这是因为法线分布函数必须满足一个条件，即所有微面元的投影面积必须等于该区域宏观表面的投影面积。因此，上述公式也被称为是归一化的Phong法线分布函数</p>
<p>  但实际上，Blinn-Phong 模型并不能真实地反映很多真实世界中物体的微面元法线方向分布，它其实完全是一种经验型模型，因此，很多更加复杂的分布函数被提了出来。GGX 分布（也被称为 Trowbridge-Reitz 法线分布函数）是一种更新的法线分布函数，它的公式如下：<br>$$<br>D_{GGX}(h)=\frac{\alpha^2}{\pi((\alpha^2-1)(n\cdot h)+1)^2}<br>$$<br>与 Blinn-Phong 的法线分布相比，GGX 分布具有更明亮、更狭窄且拖尾更长的高光区域，它的结果更接近于一些测量得到的真实材质的 BRDF 分布。在 Disney BRDF 中，Disney 认为对于很多材质来说，GGX 表现出来的高光拖尾仍然不够长。他们选择使用一种更加广义的法线分布模型，即 Generalized-Trowbridge-Reitz（GTR）分布。GTR分布于 GGX 分布很类似，但它的分母部分的指数不是 2，而是一个可调参数。Disney 使用两个不同指数的 GTR 分布作为两个高光反射片，其中第一个反射片用于表示基本材质层，第二个反射片用于表示基本材质表面的清漆层。除此之外，他们还发现令$α = roughness^2$可以在材质粗糙度上得到更加线性的变化。否则，直接使用$roughness$作为参数的话会导致在光滑材质和粗糙材质之间插值出来的材质总是偏粗糙的。</p>
</li>
<li><p>阴影-遮挡函数<br>阴影-遮挡函数$G(l, v, h)$也被称为 几何函数（ geometry function ） ，它表明了具有给定面法线$m$的微面元在沿着入射方向$l$和观察方向$v$上不会被其他微面元挡住的概率。</p>
<p>许多已发表的微面元BRDF模型习惯把$G(l, v, h)$和高光反射项的分母$(n ⋅ l)(n ⋅ v)$部分结合起来，即把$G(l, v, h)$除以$(n⋅ l)(n ⋅ v)$的部分合在一起讨论，这是因为这两个部分都和微面元的可见性有关，因此 Naty Hoffman在他的演讲中称这个合项为可见性项（ visibility term ）。</p>
<p>最早的阴影-遮挡函数之一是 Cook-Torrance 阴影遮挡函数：<br>$$<br>G_{ct}(l,v,h)=min(1, \frac{2(n\cdot h)(n\cdot v)}{v\cdot h},\frac{2(n\cdot h)(n\cdot l)}{v\cdot h})<br>$$<br>后来，Kelemen 等人提出了一个对于 Cook-Torrance 阴影遮挡函数非常快速且有效的近似实现：<br>$$<br>\frac{G_{ct}(l,v,h)}{(n\cdot l)(n\cdot v)}\approx \frac{1}{(l\cdot h)^2}<br>$$<br>但是它们实际上是基于一个非真实的微几何模型，而且不受材质粗糙度的影响。</p>
<p>目前在图形学中广受推崇的是 Smith 阴影-遮掩函数。Smith 函数比 Cook-Torrance 函数更加精确，而且考虑进了表面粗糙度和法线分布的影响：<br>$$<br>G(l,v,h)=\frac{2}{1+\sqrt{1+\alpha_g^2\tan\theta_v^2}}<br>$$<br>其中$\alpha_g=(0.5+\frac{roughness}{2})^2$；$θ_v$表示观察方向$v$和表面法线$n$之间的夹角。根据艺术家的反馈以及对测量得到的 BRDF 图像的观察，Disney 在上述式子中重新映射了 α g 和 roughness 之间的关系，由此得到了一个在视觉上让艺术家更加满意的效果。</p>
</li>
</ul>
<h3 id="PBS-中的光照"><a href="#PBS-中的光照" class="headerlink" title="PBS 中的光照"></a><font size="4" color="green">PBS 中的光照</font></h3><p>Sébastien Lagarde 在他的<a href="https://seblagarde.wordpress.com/2012/09/29/image-based-lighting-approaches-and-parallax-corrected-cubemap/" target="_blank" rel="noopener">博文</a>里详细介绍了 IBL 的一些实现方法以及如何得到视差正确的局部环境贴图的方法，非常值得一看。</p>
<h3 id="Unity中的PBS实现"><a href="#Unity中的PBS实现" class="headerlink" title="Unity中的PBS实现"></a><font size="4" color="green">Unity中的PBS实现</font></h3><ul>
<li><p>Unity使用的BRDF漫反射项如下：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/UnityShader%E6%89%A9%E5%B1%95%E7%AF%87_7.png?raw=true" alt><br>其中$F_{D90}=0.5+2roughness(h\cdot l)^2$。</p>
</li>
<li><p>Unity使用的菲涅尔反射函数如下：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/UnityShader%E6%89%A9%E5%B1%95%E7%AF%87_8.png?raw=true" alt></p>
</li>
<li>Unity使用的法线分布函数如下：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/UnityShader%E6%89%A9%E5%B1%95%E7%AF%87_9.png?raw=true" alt><br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/UnityShader%E6%89%A9%E5%B1%95%E7%AF%87_10.jpg?raw=true" alt></li>
<li>Unity 5.3以后使用的阴影-遮挡函数如下：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/UnityShader%E6%89%A9%E5%B1%95%E7%AF%87_11.jpg?raw=true" alt><br>其中$\alpha_g=roughness^2$。由于原始的 Smith-Joint 阴影-遮掩函数涉及两个开根号操作，处于性能方面的考虑，Unity 在实现上选择使用上述仅包含乘法的近似公式来简化计算。尽管在数学上这个近似公式并不正确，但从效果上来看是足够接受的。</li>
</ul>
<h2 id="动手：PBS实践"><a href="#动手：PBS实践" class="headerlink" title="动手：PBS实践"></a><font size="5" color="red">动手：PBS实践</font></h2><p>使用PBS公式来计算漫反射和高光反射的Shader代码如下（未测试过）：</p>
<pre class="line-numbers language-shader"><code class="language-shader">Shader "Unity Shaders Book/Chapter 18/CustomPBR"
{
    Properties
    {
        _Color("Color", Color) = (1, 1, 1, 1)
        _MainTex ("Albedo", 2D) = "white" {}
        _Glossiness("Smoothness", Range(0.0, 1.0)) = 0.5
        _SpecColor("Specular", Color) = (0.2, 0.2, 0.2)
        _SpecGlossMap("Specular (RGB ) Smoothness (A)", 2D) = "white" {}
        _BumpScale ("Bump Scale", Float) = 1.0
        _BumpMap ("Normal Map", 2D) = "bump" {}
        _EmissionColor ("Color", Color) = (0, 0, 0)
        _EmissionMap ("Emission", 2D) = "white" {}
    }

    SubShader
    {
        Tags{"RenderType" = "Opaque"}
        LOD 300

        CGINCLUDE

        #include "UnityCG.cginc"

        inline half3 CustomDisneyDiffuseTerm(half NdotV, half NdotL, half LdotH, half roughness, half3 baseColor) 
        {
            half fd90 = 0.5 + 2 * LdotH * LdotH * roughness;
            // Two schlick fresnel term
            half lightScatter  = (1 + (fd90 - 1) * pow(1 - NdotL, 5));
            half viewScatter  = (1 + (fd90 - 1) * pow(1 - NdotV, 5));
            return baseColor * UNITY_INV_PI * lightScatter * viewScatter;
        }

        inline half CustomSmithJointGGXVisibilityTerm(half NdotL, half NdotV, half roughness)
        {
            // Original formulation:
            //  lambda_v  = (-1 + sqrt(a2 * (1 - NdotL2) / NdotL2 + 1)) * 0.5f;
            //  lambda_l  = (-1 + sqrt(a2 * (1 - NdotV2) / NdotV2 + 1)) * 0.5f;
            //  G  = 1 / (1 + lambda_v + lambda_l);
            // Approximation of the above formulation (simplify the sqrt, not mathematically correct but close enough)
            half a2 = roughness * roughness;
            half lambdaV = NdotL * (NdotV * (1 - a2) + a2);
            half lambdaL = NdotV * (NdotL * (1 - a2) + a2);
            return 0.5f / (lambdaV + lambdaL + 1e-5f);
        }

        inline half CustomGGXTerm(half NdotH, half roughness) 
        {
            half a2 = roughness * roughness;
            half d = (NdotH * a2 - NdotH) * NdotH + 1.0f;
            return UNITY_INV_PI * a2 / (d * d + 1e-7f);
        }

        inline half3 CustomFresnelTerm(half3 c, half cosA) 
        {
            half t = pow(1 - cosA, 5);
            return c + (1 - c) * t;
        }

        inline half3 CustomFresnelLerp(half3 c0, half3 c1, half cosA) 
        {
            half t = pow(1 - cosA, 5);
            return lerp (c0, c1, t);
        }

        ENDCG

        Pass
        {
            Tags{"LightMode" = "ForwardBase"}

            CGPROGRAM

            #pragma target 3.0

            #pragma multi_compile_fwdbase
            #pragma multi_compile_fog

            #pragma vertex vert
            #pragma fragment frag

            #include "UnityCG.cginc"
            #include "AutoLight.cginc"
            #include "HLSLSupport.cginc"
            #include "Lighting.cginc"

            float4 _Color;
            sampler2D _MainTex;
            float4 _MainTex_ST;
            float  _Glossiness;
            //float3 _SpecColor;
            sampler2D _SpecGlossMap;
            float4 _SpecGlossMap_ST;
            float  _BumpScale;
            sampler2D _BumpMap;
            float3 _EmissionColor;
            sampler2D _EmissionMap;
            float4 _EmissionMap_ST;

            struct a2v
            {
                float4 vertex : POSITION;
                float3 normal : NORMAL;
                float4 tangent : TANGENT;
                float4 texcoord : TEXCOORD0;
            };

            struct v2f 
            {
                float4 pos : SV_POSITION;
                float2 uv : TEXCOORD0;
                float4 TtoW0 : TEXCOORD1;
                float4 TtoW1 : TEXCOORD2;
                float4 TtoW2 : TEXCOORD3;
                SHADOW_COORDS(4)    // Defined in AutoLight.cginc
                UNITY_FOG_COORDS(5) // Defined in UnityCG.cginc
            };

            v2f vert(a2v v) 
            {
                v2f o;
                //UNITY_INITIALIZE_OUTPUT(v2f, o);            // Defined in HLSLSupport.cginc
                o.pos = UnityObjectToClipPos(v.vertex);
                o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);
                float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
                fixed3 worldNormal = UnityObjectToWorldNormal(v.normal);
                fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
                fixed3 worldBinormal = cross(worldNormal, worldTangent) * v.tangent.w;
                o.TtoW0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
                o.TtoW1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
                o.TtoW2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
                TRANSFER_SHADOW(o);
                UNITY_TRANSFER_FOG(o, o.pos);                // Defined in UnityCG.cginc
                return o;
            }

            half4 frag(v2f i) : SV_Target 
            {
                half4 specGloss = tex2D(_SpecGlossMap, i.uv);
                specGloss.a *= _Glossiness;
                half3 specColor = specGloss.rgb * _SpecColor.rgb;
                half roughness = 1 - specGloss.a;
                half oneMinusReflectivity = 1 - max(max(specColor.r, specColor.g), specColor.b);
                half3 diffColor = _Color.rgb * tex2D(_MainTex, i.uv).rgb * oneMinusReflectivity;

                half3 normalTangent = UnpackNormal(tex2D(_BumpMap, i.uv));
                normalTangent.xy *= _BumpScale;
                normalTangent.z = sqrt(1.0 - saturate(dot(normalTangent.xy, normalTangent.xy)));
                half3  normalWorld  =  normalize(half3(dot(i.TtoW0.xyz,  normalTangent), dot(i.TtoW1.xyz, normalTangent), dot(i.TtoW2.xyz, normalTangent)));
                float3 worldPos = float3(i.TtoW0.w, i.TtoW1.w, i.TtoW2.w);
                half3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
                half3 viewDir = normalize(UnityWorldSpaceViewDir(worldPos));
                half3 reflDir = reflect(-viewDir, normalWorld);
                UNITY_LIGHT_ATTENUATION(atten, i, worldPos);

                half3 halfDir = normalize(lightDir + viewDir);
                half nv = saturate(dot(normalWorld, viewDir));
                half nl = saturate(dot(normalWorld, lightDir));
                half nh = saturate(dot(normalWorld, halfDir));
                half lv = saturate(dot(lightDir, viewDir));
                half lh = saturate(dot(lightDir, halfDir));

                // Diffuse term
                half3 diffuseTerm = CustomDisneyDiffuseTerm(nv, nl, lh, roughness, diffColor);

                // Specular term
                half V = CustomSmithJointGGXVisibilityTerm(nl, nv, roughness);
                half D = CustomGGXTerm(nh, roughness * roughness);
                half3 F = CustomFresnelTerm(specColor, lh);
                half3 specularTerm = F * V * D;

                // Emission term
                half3 emisstionTerm = tex2D(_EmissionMap, i.uv).rgb * _EmissionColor.rgb;

                // IBL
                half perceptualRoughness = roughness * (1.7 - 0.7 * roughness);
                half mip = perceptualRoughness * 6;
                half4 envMap = UNITY_SAMPLE_TEXCUBE_LOD(unity_SpecCube0, reflDir, mip); // Defined in HLSLSupport.cginc
                half grazingTerm = saturate((1 - roughness) + (1 - oneMinusReflectivity));
                half surfaceReduction = 1.0 / (roughness * roughness + 1.0);
                half3 indirectSpecular = surfaceReduction * envMap.rgb * CustomFresnelLerp(specColor, grazingTerm, nv);

                // Combine all togather
                half3 col = emisstionTerm + UNITY_PI * (diffuseTerm + specularTerm) * _LightColor0.rgb * nl * atten + indirectSpecular;
                UNITY_APPLY_FOG(i.fogCoord, c.rgb);
                return half4(col, 1);
            }

            ENDCG
        }

        Pass
        {
            Tags{"LightMode" = "ForwardAdd"}

            Blend One One

            CGPROGRAM

            #pragma target 3.0

            #pragma multi_compile_fwdadd

            #pragma vertex vert
            #pragma fragment frag

            #include "UnityCG.cginc"
            #include "AutoLight.cginc"
            #include "Lighting.cginc"

            float4 _Color;
            sampler2D _MainTex;
            float4 _MainTex_ST;
            float  _Glossiness;
            //float3 _SpecColor;
            sampler2D _SpecGlossMap;
            float4 _SpecGlossMap_ST;
            float  _BumpScale;
            sampler2D _BumpMap;

            struct a2v
            {
                float4 vertex : POSITION;
                float3 normal : NORMAL;
                float4 tangent : TANGENT;
                float4 texcoord : TEXCOORD0;
            };

            struct v2f 
            {
                float4 pos : SV_POSITION;
                float2 uv : TEXCOORD0;
                float4 TtoW0 : TEXCOORD1;
                float4 TtoW1 : TEXCOORD2;
                float4 TtoW2 : TEXCOORD3;
                SHADOW_COORDS(4)    // Defined in AutoLight.cginc
            };

            v2f vert(a2v v) 
            {
                v2f o;
                //UNITY_INITIALIZE_OUTPUT(v2f, o);            // Defined in HLSLSupport.cginc
                o.pos = UnityObjectToClipPos(v.vertex);
                o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);
                float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
                fixed3 worldNormal = UnityObjectToWorldNormal(v.normal);
                fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
                fixed3 worldBinormal = cross(worldNormal, worldTangent) * v.tangent.w;
                o.TtoW0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
                o.TtoW1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
                o.TtoW2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
                TRANSFER_SHADOW(o);
                return o;
            }

            half4 frag(v2f i) : SV_Target 
            {
                half4 specGloss = tex2D(_SpecGlossMap, i.uv);
                specGloss.a *= _Glossiness;
                half3 specColor = specGloss.rgb * _SpecColor.rgb;
                half roughness = 1 - specGloss.a;
                half oneMinusReflectivity = 1 - max(max(specColor.r, specColor.g), specColor.b);
                half3 diffColor = _Color.rgb * tex2D(_MainTex, i.uv).rgb * oneMinusReflectivity;

                half3 normalTangent = UnpackNormal(tex2D(_BumpMap, i.uv));
                normalTangent.xy *= _BumpScale;
                normalTangent.z = sqrt(1.0 - saturate(dot(normalTangent.xy, normalTangent.xy)));
                half3  normalWorld  =  normalize(half3(dot(i.TtoW0.xyz,  normalTangent), dot(i.TtoW1.xyz, normalTangent), dot(i.TtoW2.xyz, normalTangent)));
                float3 worldPos = float3(i.TtoW0.w, i.TtoW1.w, i.TtoW2.w);
                half3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
                half3 viewDir = normalize(UnityWorldSpaceViewDir(worldPos));
                half3 reflDir = reflect(-viewDir, normalWorld);
                UNITY_LIGHT_ATTENUATION(atten, i, worldPos);

                half3 halfDir = normalize(lightDir + viewDir);
                half nv = saturate(dot(normalWorld, viewDir));
                half nl = saturate(dot(normalWorld, lightDir));
                half nh = saturate(dot(normalWorld, halfDir));
                half lv = saturate(dot(lightDir, viewDir));
                half lh = saturate(dot(lightDir, halfDir));

                // Diffuse term
                half3 diffuseTerm = CustomDisneyDiffuseTerm(nv, nl, lh, roughness, diffColor);

                // Specular term
                half V = CustomSmithJointGGXVisibilityTerm(nl, nv, roughness);
                half D = CustomGGXTerm(nh, roughness * roughness);
                half3 F = CustomFresnelTerm(specColor, lh);
                half3 specularTerm = F * V * D;

                // Combine all togather
                half3 col = UNITY_PI * (diffuseTerm + specularTerm) * _LightColor0.rgb * nl * atten;
                return half4(col, 1);
            }

            ENDCG
        }
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中<code>_MainTex</code>和<code>_Color</code> 用于控制漫反射项中的材质纹理和颜色，<code>_SpecColor</code> 和<code>_SpecGlossMap</code> 的 RGB 通道值用于控制材质的高光反射颜色。<code>_SpecGlossMap</code>的 A 通道值和<code>_Glossiness</code>用于共同控制材质的粗糙度。<code>_BumpMap</code> 则是材质的法线纹理，它的凹凸程度可以依靠<code>_BumpScale</code> 属性来控制。最后，<code>_EmissionColor</code> 和<code>_EmissionMap</code> 用于控制材质的自发光颜色。</p>
<p>使用#pragma target 3.0 来指明使用 Shader Target 3.0，这是因为基于物理渲染涉及了较多的公式，因此需要较多的数学指令来进行计算，这可能会超过 ShaderTarget 2.0 对指令数目的规定，因此我们选择使用更高的 Shader Target 3.0.</p>
<p>当中计算了一个变量 oneMinusReflectivity，这个变量并不是我们之前提到的 BRDF中需要的变量，它主要是为了计算掠射角的反射颜色，从而得到效果更好的菲涅耳反射效果。</p>
<p><code>UNITY_INV_PI</code>是在UnityCG.cginc 文件中定义的宏变量，即圆周率π的倒数。</p>
<p> Cg 关键词 inline来修饰函数声明，inline 的作用是用于告诉编译器应该尽可能使用内联调用的方式来调用该函数，减少函数调用的开销。</p>
<p>代码中的可见性项 V（也叫几何项），它计算的是阴影-遮掩函数<strong>除以高光反射项的分母部分后</strong>的结果。</p>
<p>IBL 部分的主要思想是使用材质粗糙度对环境贴图进行 LOD（Level Of Detail）采样，这是因为粗糙度越大的材质，反射的环境光照应该越模糊，而这可以通过对环境贴图不同级数的多级渐远纹理（mipmaps）进行采样来模拟得到（这里是算的单个精确光源的光照，所以并不涉及IBL的积分问题）。</p>
<p>片元着色器中的<code>unity_SpecCube0</code> 包含了该物体周围当前活跃的反射探针（ReflectionProbe）中所包含的环境贴图。尽管我们没有在场景中手动放置任何反射探针，但 Unity 会根据Window -&gt; Lighting -&gt; Skybox 中的设置，在场景中生成一个默认的反射探针。由于我们在 Window -&gt; Lighting -&gt; Skybox 中设置了自定义的天空盒，因此此时<code>unity_SpecCube0</code>中包含的就是这个自定义天空盒的环境贴图。如果我们在场景中放置了其他反射探针，Unity 则会根据相关设置和物体所在的位置自动把距离该物体最近的一个或几个反射探针数据传递给 Shader。而且在采样 <code>unity_SpecCube0</code> 时我们也应该使用内置宏如<code>UNITY_SAMPLE_TEXCUBE</code>（在HLSLSupport.cginc 文件中被定义）来采样（而不能使用<code>texCUBE</code>函数来对它采样）。由于在这里我们还需要对指定级数的多级渐远纹理采样，因此我们使用内置宏<code>UNITY_SAMPLE_TEXCUBE_LOD</code>（在 HLSLSupport.cginc 文件中被定义）来实现。</p>
<p>为了给 IBL 添加更加真实的菲涅耳反射，我们对高光反射颜色 <code>specColor</code> 和掠射颜色<code>grazingTerm</code> 进行菲涅耳插值。掠射颜色 <code>grazingTerm</code> 是由材质粗糙度和之前计算得到的<code>oneMinusReflectivity</code> 共同决定的。使用掠射角度进行菲涅耳插值的好处是，我们可以在掠射角得到更加真实的菲涅耳反射效果，同时还考虑了材质粗糙度的影响。除此之外，我们还使用了由粗糙度计算得到的 surfaceReduction 参数进一步对 IBL 的进行修正。</p>
<p>最后，我们只需要按照渲染方程把所有项加起来即可。</p>
<p>由于场景中可能存在多个光源，我们还需要实现 Forward Add Pass。Forward Add Pass 的实现与 Forward Base Pass 基本一致，其中不同的是，Forward Add Pass 不需要计算雾效、自发光和 IBL 的部分，因为这些只需要在 Forward Base Pass 计算一遍即可。</p>
<p>而且需要注意的是，我们还需要保证 Player Settings  → Other Settings  → Rendering  → ColorSpace 中的选项是 Linear，即线性空间，只有这样才能保证我们的计算是在线性空间下进行的，且输出的为线性颜色。</p>
<p>渲染结果如下图：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/UnityShader%E6%89%A9%E5%B1%95%E7%AF%87_12.jpg?raw=true" alt></p>
<h2 id="Unity-5的Standard-Shader"><a href="#Unity-5的Standard-Shader" class="headerlink" title="Unity 5的Standard Shader"></a><font size="5" color="red">Unity 5的Standard Shader</font></h2><h3 id="它们是如何实现的"><a href="#它们是如何实现的" class="headerlink" title="它们是如何实现的"></a><font size="4" color="green">它们是如何实现的</font></h3><p>Unity 支持两种流行的基于物理的工作流程：金属工作流 （ metallic workflow ） 和高光反射工作流 （ specular workflow ） 。其中，金属工作流是默认的工作流程，对应的 Shader 为 StandardShader。而如果想要使用高光反射工作流，就需要在材质的 Shader 下拉框中选择 Standard （Specular setup）。需要注意的是，通常来讲，使用不同的工作流可以实现相同的效果，只是它们使用的参数不同而已。金属工作流也不意味着它只能模拟金属类型的材质，金属工作流的名字来源于它定义了材质表面的金属值（是金属类型的还是非金属类型的）。高光反射工作流的名字来源于它可以直接指定表面的高光反射颜色（有很强的高光反射还是很弱的高光反射）等。而在金属工作流中这个颜色需要由漫反射颜色和金属值衍生而来。在内部实现上，这两种工作流实际上最终都会使用同一套 BRDF 模型，不同的是 BRDF 模型中各个输入参数的来源不同而已。</p>
<p>Unity内置的与 PBS 相关的各个头文件以及相关描述参见参考书18.3节。</p>
<p>Standard.shader 和 StandardSpecular.shader 最大的不同之处在于，它们在设置 BRDF 的输入时使用了不同的函数来设置各个参数 — 基于金属工作流的 Standard Shader 使用 <code>MetallicSetup</code> 函数来设置各个参数，基于高光反射工作流的 Standard（Specular setup）Shader 使用 <code>SpecularSetup</code> 函数来设置。</p>
<p>Standard Shader中前向渲染路径使用的Pass如下图所示：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/UnityShader%E6%89%A9%E5%B1%95%E7%AF%87_13.jpg?raw=true" alt><br>两个 Pass 的代码大体相同，只是 ForwardBase Pass 进行了更多的光照<br>计算，例如，计算全局光照、自发光等效果，这些计算只需要在物体的整个渲染过程中计算一次即可，因此不需要在 FarwardAdd Pass 中再计算一次。</p>
<h3 id="如何使用Standard-Shader"><a href="#如何使用Standard-Shader" class="headerlink" title="如何使用Standard Shader"></a><font size="4" color="green">如何使用Standard Shader</font></h3><p>对于金属材质和非金属材质，它们的漫反射和高光反射有一些不同的特点：</p>
<ul>
<li>金属材质<ul>
<li>几乎没有漫反射，因为所有被吸收的光都会被自由电子立刻转化为其他形式的能量；</li>
<li>有非常强烈的高光反射；</li>
<li>高光反射通常是有颜色的，例如金子的反光颜色为黄色。</li>
</ul>
</li>
<li>非金属材质<ul>
<li>大多数角度高光反射的强度比较弱，但在掠射角时高光反射强度反而会增强，即菲涅耳现象；</li>
<li>高光反射的颜色比较单一；</li>
<li>漫反射的颜色多种多样。</li>
</ul>
</li>
</ul>
<p>至于怎样调Standard Shader的参数，新建一个材质，选择Standard的Shader，然后自己慢慢玩就可以了。需要说明的有一下几点：</p>
<ul>
<li>在金属工作流中，材质面板中的 Albedo 定义了物体的整体颜色，它通常就是我们视觉上认为的物体颜色。</li>
<li>高光反射工作流中，材质的 Albedo属性定义了表面的漫反射强度。对于非金属材质，它的值通常仍然是视觉上认为的物体颜色，但<br>对于金属材质，Albedo 的值通常非常接近黑色。</li>
<li>我们还可以为 Standard Shader 选择它使用的渲染模式。其中Fade 模式和 Transparent 模式是类似的，不同的是，在 Transparent 模式下，当材质的透明值不断降低时，它的反射仍然能被保留，而在 Fade 模式下，该材质的所有渲染效果都会逐渐从屏幕上淡出。</li>
</ul>
<h2 id="一个更加复杂的例子"><a href="#一个更加复杂的例子" class="headerlink" title="一个更加复杂的例子"></a><font size="5" color="red">一个更加复杂的例子</font></h2><ul>
<li>使用HDR格式的Skybox可以让场景中物体的反射更加真实，有利于我们得到更加可信的光照效果。</li>
<li>在渲染实现上，即便场景中没有任何光源，Unity 在内部仍然会调用 ForwardBase Pass（假设使用的是前向渲染路径的话），并使用反射的光照信息来填充光源信息，再进行基于物理的渲染计算。所以即使场景中没有任何光源，场景中的物体也不是全黑的。</li>
<li>实时光照往往需要较大的性能消耗，对于移动平台这样资源比较短缺的平台，我们可以选择 Baked 模式，此时，Unity 会把该光源的光照效<br>果烘焙到一张光照纹理（lightmap）中，这样我们就不用实时为物体计算复杂的光照，而只需要通过纹理采样来得到光照结果。选择烘焙模式的缺点在于，如果场景中的物体发生了移动，但是它的阴影等光照效果并不会发生变化。烘焙选项中的 Mix 模式则允许我们混合使用实时模式和烘焙模式，它会把场景中的静态物体（即那些被标识为 Static 的物体）的光照烘焙到光照纹理中，但仍然会对动态物体产生实时光照。</li>
<li>光源面板中的 Bounce Intensity 参数可以让我们调节间接光照的强度。当我们把它设为 0 时，意味着一条光线仅会和一个物体相交，不再被继续反射，也就是说，场景中的物体只会受到直接光照的影响。</li>
<li>反射探针的工作原理和光照探针（Light Probes）类似，它允许我们在场景中的特定位置上对整个场景的环境反射进行采样，并把采样结果存储在每个探针上。当游戏中包含反射效果的物体从这些探针附近经过时，Unity 会把从这些邻近探针存储的反射结果传递给物体使用的反射纹理。如果物体周围存在多个反射探针，Unity 还会在这些反射结果之间进行插值，来得到平滑渐变的反射效果。实际上，Unity 会在场景中放置一个默认的反射探针，这个反射探针存储了对场景使用的 Skybox 的反射结果，来作为场景的环境光照（见 18.3.1 节）。如果我们需要让场景中的物体包含额外的反射效果，就需要放置更多的反射探针。通常来说，反射探针应该被放置在那些具有明显反射现象的物体的旁边，或是一些墙角等容易发生遮挡的物体周围。</li>
<li>使用 Unity 内置的反射探针的另一个好处是，我们可以模拟互相反射。如下图所示：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/UnityShader%E6%89%A9%E5%B1%95%E7%AF%87_14.jpg?raw=true" alt><br>我们在每个金属球的位置处放置了一个反射探针，并把每个金属球上的 Mesh Renderer 组件中的 Reflection Probes 设置为 Simple，这样保证它们只会使用离它们最近的一个反射探针。默认情况下，反射探针只会捕捉一次反射，也就是说，左边金属球使用的反射探针只会捕捉到由右边的金属球第一次反射过来的光线。但在理想情况下，反射过来的光线会继续被左边的金属球反射，并对右边的金属球造成影响。Unity 允许我们控制物体之间这样来回反射的次数，这可以通过改变Lighting设置中的Reflection Bounces参数来实现。上图所示的场景中我们把这个参数设置为了2。</li>
<li>这些探针实际上也是通过在它的位置上放置一个摄像机，来渲染得到一个 Cubemap。如果我们把反弹次数设置的很大，或是使用实时渲染，那么这些探针很可能会造成性能瓶颈。更多关于如何优化反射探针以及它的高级用法，可以参见<a href="https://docs.unity3d.com/Manual/ReflectionProbes.html" target="_blank" rel="noopener">Unity 的官方手册</a>。</li>
<li>在使用基于物理的渲染方法渲染整个场景时，我们应该使用线性空间 （ Linear Space ） 来得到最好的渲染效果。默认情况下，Unity 会使用伽马空间（Gamma Space），如果要使用线性空间的话，我们需要在 Edit→Project Settings→Player→OtherSettings→Color Space中选择 Linear选项。使用线性空间可以得到更加真实的效果。但它的缺点在于，需要一些硬件支持来实现线性计算，但一些移动平台对它的支持并不好。这种情况下，我们往往只能退而求其次，选择伽马空间进行渲染和计算。</li>
</ul>
<h2 id="答疑解惑"><a href="#答疑解惑" class="headerlink" title="答疑解惑"></a><font size="5" color="red">答疑解惑</font></h2><h3 id="什么是全局光照"><a href="#什么是全局光照" class="headerlink" title="什么是全局光照"></a><font size="4" color="green">什么是全局光照</font></h3><p>由于静态的光照烘焙无法在光照条件改变时更新物体的光照效果，因此，Unity 使用了预计算实时全局光照 （ Precomputed Realtime GI ） 为我们提供了一个解决途径，来动态地为场景实时更新复杂的光照结果。 因为一旦物体和光源的位置被固定了，这些物体对光线的反弹路径以及漫反射光照（我们假设漫反射光照在各个方向的分布是相同的）也是固定的，也就是说是和摄像机无关的。因此，我们可以使用预计算方法来把这些物体之间的关系提前计算出来，而在实时运行时，只要光源的位置（光源的颜色是可以实时变化的）不变，即便改变了光源颜色和强度、物体材质属性（指的是漫反射和自发光相关的属性），这些信息就一直有效，不需要实时更新。在预计算阶段，Enlighten 会在由所有静态物体组成的场景上，进行简化的“光线追踪”过程。</p>
<p>一个例外是物体的高光反射，这是和摄像机的位置相关的，Unity 的解决方案是使用反射探针。对于动态移动的物体来说，我们可以使用光照探针来模拟它的光照环境。</p>
<p>因此，在实时运行时，Unity 会利用预计算得到的信息来计算光照信息，并把它们存储在额外的光照纹理、光照探针或 Cubemap 中，再和物体材质进行必要的光照计算，得到最后的渲染效果。</p>
<p>可以在Unity的<a href="https://docs.unity3d.com/Manual/GIIntro.html" target="_blank" rel="noopener">官方手册</a>中找到更多关于Unity全局光照的介绍。</p>
<h3 id="什么是伽马校正"><a href="#什么是伽马校正" class="headerlink" title="什么是伽马校正"></a><font size="4" color="green">什么是伽马校正</font></h3><p>Unity 默认的空间是伽马空间，在伽马空间下进行渲染会导致很多非线性空间下的计算。</p>
<p>显示器会把Shader中输出的颜色值乘以2.2次方之后再显示到屏幕上（2.2来源于CRT 显示器输入电压和显示亮度之间的非线性关系，以及图像的伽马编码）。</p>
<p>人眼有一个有趣的特性，就是对光的灵敏度在不同亮度上是不一样的。在正常的光照条件下，人眼对较暗区域的变化更加敏感。所以产生了对图像的伽马编码：对真实的颜色乘上0.45次方后，可以充分利用图像的存储空间（比如$0.5\approx 0.22^{0.45}$，这个时候我们就可以用0.22来表示一个原来0.5的亮度，这样一来原本只有0~1的范围（可能用8位bit来编码）却可以表示出更多的颜色亮度，而且这个指数曲线符合越亮的颜色亮度占用越小的编码范围，对人眼视觉效果几乎没有影响）。</p>
<p>微软联合爱普生、惠普提供了 sRGB 颜色空间标准，推荐显示器的显示伽马值为 2.2，并配合 0.45 的编码伽马就可以保证最后伽马曲线之间可以相互抵消（因为 2.2×0.45≈1）。</p>
<p>实际上，渲染中非线性输入最有可能的来源就是纹理。为了充分利用存储空间，大多数图像文件都进行了提前的校正，即已经使用了一个编码伽马对像素值编码。但这意味着它们是非线性的，如果我们在 Shader 中直接使用纹理采样值就会造成在非线性空间的计算，使得结果和真实世界的结果不一致。</p>
<p>当选择线性空间时，Unity 会把输入纹理设置为 sRGB 模式，在这种模式下，硬件在对纹理进行采样时会自动将其转换到线性空间中；并且，GPU 会在 Shader 写入默认颜色缓冲前自动进行伽马校正。需要注意，透明通道是不会参与伽马校正的。</p>
<p>然而，Unity 的线性空间并不是所有平台都支持的，例如，移动平台就无法使用线性空间。此时，我们就需要自己在 Shader 中进行伽马校正。对非线性输入纹理的校正代码通常如下：</p>
<pre class="line-numbers language-shader"><code class="language-shader">float3 diffuseCol = pow(tex2D( diffTex, texCoord ), 2.2 );
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>在最后输出前，对输出像素值的校正代码通常如下面这样：</p>
<pre class="line-numbers language-shader"><code class="language-shader">fragColor.rgb = pow(fragColor.rgb, 1.0/2.2);
return fragColor;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>但是，手工对输出像素进行伽马校正会在使用混合时出现问题。这是因为，校正会导致写入颜色缓冲内的颜色是非线性的，这样混合就发生在非线性空间中。一种解决方法是，在中间计算时不要对输出颜色值进行伽马校正，但在最后需要进行一个屏幕后处理操作来对最后的输出进行伽马校正，也就是说我们需要保证伽马校正发生在渲染的最后一步中，但这可能会造成一定的性能损耗。</p>
<h3 id="什么是HDR"><a href="#什么是HDR" class="headerlink" title="什么是HDR"></a><font size="4" color="green">什么是HDR</font></h3><p>Nvidia 曾总结过使用 HDR 进行渲染的动机：让亮的物体可以真的非常亮，暗的物体可以真的非常暗，同时又可以看到两者之间的细节。</p>
<p>HDR 也有自身的缺点，首先由于使用了浮点缓冲来存储高精度图像，不仅需要更大的显存空间，渲染速度会变慢，除此之外，一些硬件并不支持 HDR。而且一旦使用了 HDR，我们无法再利用硬件的抗锯齿功能。</p>
<p>在 Unity 中使用 HDR 也非常简单，我们可以在 Camera 组件面板中打开 HDR 选项即可。此时，场景就会被渲染到一个 HDR 的图像缓冲中，这个缓冲的精度范围可以远远超过 0～1。最后，我们可以再使用一个色调映射的屏幕后处理脚本来把 HDR 图像转换到 LDR 图像进行显示。</p>
<p>可以在 Unity 官方手册的<a href="https://docs.unity3d.com/Manual/HDR.html" target="_blank" rel="noopener">高动态范围渲染</a>中找到更多HDR相关内容。</p>
<h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a><font size="5" color="red">扩展阅读</font></h2><p>Unity 官方提供了很多学习 PBS 的资料。在 Unity 官方博客中的<a href="https://blogs.unity3d.com/2014/09/18/global-illumination-in-unity-5/" target="_blank" rel="noopener">全局光照</a>一文中，简明地阐述了全局光照的解决方案。在另外两篇博客(<a href="https://blogs.unity3d.com/2015/02/18/working-with-physically-based-shading-a-practical-approach/" target="_blank" rel="noopener">这里</a>和<a href="https://blogs.unity3d.com/2014/10/29/physically-based-shading-in-unity-5-a-primer/" target="_blank" rel="noopener">这里</a>)中，介绍了 Standard Shader 的用法和注意事项。在Unity 官方教程的<a href="https://unity3d.com/learn/tutorials/s/graphics" target="_blank" rel="noopener">Graphics 分项</a>下，也有很多关于 PBS 的教程，例如，在预计算实时 GI 的<a href="https://unity3d.com/learn/tutorials/topics/graphics/introduction-precomputed-realtime-gi" target="_blank" rel="noopener">系列文章</a>中，介绍了 Unity 5 的 Enlighten 系统中预计算实时 GI 的实现原理，以及如何正确地把它应用在大型项目中来提升画面效果并减少烘焙时间。在 Unity 5 的<a href="https://unity3d.com/learn/tutorials/topics/graphics/lighting-overview" target="_blank" rel="noopener">光照概览</a>中，介绍了 Unity 5 中使用的各种全局光照技术；在 Standard Shader 的<a href="https://unity3d.com/learn/tutorials/topics/graphics/standard-shader" target="_blank" rel="noopener">视频教程</a>中，Unity 介绍了 Standard Shader 的基本用法以及和光照之间的配合。与之类似的还有<a href="https://blogs.unity3d.com/2016/11/01/adam-demo-executable-and-assets-released/" target="_blank" rel="noopener">Adam</a>的相关资源，这些都是非常好的学习资料。</p>
<p>Renaldas Zioma 在他的 SIGGRPAH2015 演讲 Optimizing PBR for Mobile 中介绍了如何在移动平台上应用和优化 PBR。</p>
<p>Kostas Anagnostou 在他的<a href="https://interplayoflight.wordpress.com/2013/12/30/readings-on-physically-based-rendering/" target="_blank" rel="noopener">文章</a>中整理了非常多的关于 PBR 的相关文章。</p>
<p>至于国内的，龚敏敏在他的 KlayGE 引擎中引入了 PBS，并写了<a href>系列博文</a><a href="http://www.klayge.org/tag/pbr/来简明地阐述其中的理论基础。作者文刀秋二给出了关于[基于物理着色的系列文章](https://www.zhihu.com/people/edliu/posts)；FOXhunt" target="_blank" rel="noopener">http://www.klayge.org/tag/pbr/来简明地阐述其中的理论基础。作者文刀秋二给出了关于[基于物理着色的系列文章](https://www.zhihu.com/people/edliu/posts)；FOXhunt</a> 在他的专栏文章<a href="https://zhuanlan.zhihu.com/p/21489591?refer=c_37032701" target="_blank" rel="noopener">如何看懂这些 “ 该死的 “ 图形学公式</a>一文中以比较详细易懂的方式解释和推导了 BRDF 模型中的各种参数和公式。</p>
<h1 id="第二十章-还有更多内容吗"><a href="#第二十章-还有更多内容吗" class="headerlink" title="第二十章 还有更多内容吗"></a><font size="6" color="orange">第二十章 还有更多内容吗</font></h1><hr>
<p>每年SIGGRAPH Course上的课程<strong>Physically Based Shading in Theory and Practice</strong>和<strong>Advances in Real-time Rendering</strong>，都是很好的学习资料。这些课程里，来自EI、育碧、Epic等知名游戏公司的技术人员将阐述他们是如何在游戏中使用各种复杂的渲染技术来实现次世代游戏画面的。</p>
<p><a href="http://www.glslsandbox.com/" target="_blank" rel="noopener">GLSL Sandbox Gallery</a>是一个和<a href="https://www.shadertoy.com/" target="_blank" rel="noopener">Shadertoy</a>类似的网站。</p>
<hr>
<p>参考文献：《Unity Shader入门精要》</p>

            </div>

            <!-- Post Comments -->
            
    <!-- 使用 DISQUS_CLICK -->
<div id="disqus-comment">
    <div id="disqus_thread"></div>

<!-- add animation -->
<style>
	.disqus_click_btn {
            line-height: 30px;
            margin: 0;
            min-width: 50px;
            padding: 0 14px;
            display: inline-block;
            font-family: "Roboto", "Helvetica", "Arial", sans-serif;
            font-size: 14px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0;
            overflow: hidden;
            will-change: box-shadow;
            transition: box-shadow .2s cubic-bezier(.4, 0, 1, 1), background-color .2s cubic-bezier(.4, 0, .2, 1), color .2s cubic-bezier(.4, 0, .2, 1);
            outline: 0;
            cursor: pointer;
            text-decoration: none;
            text-align: center;
            vertical-align: middle;
            border: 0;
            background: rgba(158, 158, 158, .2);
            box-shadow: 0 2px 2px 0 rgba(0, 0, 0, .14), 0 3px 1px -2px rgba(0, 0, 0, .2), 0 1px 5px 0 rgba(0, 0, 0, .12);
            color: #fff;
            background-color: #7EC0EE;
            text-shadow: 0
        }
</style>
	
<div class="btn_click_load" id="disqus_bt"> 
    <button class="disqus_click_btn">点击查看评论</button>
</div>

<!--
<script type="text/javascript">
$('.btn_click_load').click(function() {
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'http-miccall-tech'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    document.getElementById('disqus_bt').style.display = "none";
});
</script>
-->
<script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://yoursite.com/2019/05/04/Unity-Shader扩展篇/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = 'http://yoursite.com/2019/05/04/Unity-Shader扩展篇/'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
</script>

<script type="text/javascript">
    $('.btn_click_load').click(function() {  //click to load comments
        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document;
            var s = d.createElement('script');
            s.src = '//http-miccall-tech.disqus.com/embed.js';
            s.setAttribute('data-timestamp', + new Date());
            (d.head || d.body).appendChild(s);
        })();
        $('.btn_click_load').css('display','none');
    });
</script>
</div>
<style>
    #disqus-comment{
        background-color: #eee;
        padding: 2pc;
    }
</style>


        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
                <li>Design: <a href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
            </ul>
            
            	<span id="busuanzi_container_site_pv">2019总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			
        </div>
    </div>
</body>



 	
</html>
