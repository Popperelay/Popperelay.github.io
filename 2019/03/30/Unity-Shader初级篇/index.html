<!DOCTYPE HTML>
<html>

<head><meta name="generator" content="Hexo 3.9.0">
	<link rel="bookmark" type="image/x-icon" href="/img/logo_miccall.png">
	 <link rel="shortcut icon" href="/img/logo_miccall.png">
	
			
    <title>
    Elays'Blog
    </title>
    <meta charset="utf-8">
	<script>
    (function(){
        if('{{ page.password }}'){
            if (prompt('请输入文章密码') !== '{{ page.password }}'){
                alert('密码错误');
                history.back();
            }
        }
    })();
	</script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <link rel="stylesheet" href="/css/mic_main.css">
    <link rel="stylesheet" href="/css/dropdownMenu.css">
    
    	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css">
    </noscript>
			    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<link rel="stylesheet" href="/css/prism-dark.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>
    
		
<!-- Layouts -->


<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<!--<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">-->
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/latest.js?config=TeX-MML-AM_CHTML">
</script>

<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_undefined.css">
<link rel="stylesheet" href="/css/typo.css">
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">MICCALL</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special">
            <ul class="menu links">
			<!-- Homepage  主页  --> 
			<li>
	            <a href="/" rel="nofollow">主页</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">分类</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="/categories/C/">C#</a></li><li><a class="category-link" href="/categories/C-语法/">C#语法</a></li><li><a class="category-link" href="/categories/C/">C++</a></li><li><a class="category-link" href="/categories/C语言/">C语言</a></li><li><a class="category-link" href="/categories/Graphics/">Graphics</a></li><li><a class="category-link" href="/categories/Math/">Math</a></li><li><a class="category-link" href="/categories/OpenGL/">OpenGL</a></li><li><a class="category-link" href="/categories/Unity/">Unity</a></li><li><a class="category-link" href="/categories/博客配置/">博客配置</a></li><li><a class="category-link" href="/categories/并行计算/">并行计算</a></li><li><a class="category-link" href="/categories/操作系统/">操作系统</a></li><li><a class="category-link" href="/categories/数据结构/">数据结构</a></li><li><a class="category-link" href="/categories/毕设/">毕设</a></li><li><a class="category-link" href="/categories/游戏开发/">游戏开发</a></li><li><a class="category-link" href="/categories/计算机系统/">计算机系统</a></li><li><a class="category-link" href="/categories/设计模式/">设计模式</a></li><li><a class="category-link" href="/categories/面试/">面试</a>
	                    </li></ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/gallery/" title="图库">
		                图库
		            </a>
		        </li>
		        
		        <li>
		            <a href="/tag/" title="搜索">
		                搜索
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
		            
		                <li><a href="https://github.com/miccall" class="icon fa-github"><span class="label">GitHub</span></a></li>
		            
		            
		            
		            
			</ul>
</nav>

        <div id="main">
            <div class="post_page_title_img" style="height: 25rem;background-image: url(https://github.com/Popperelay/Photos/blob/master/Photos/UnityShader%E5%88%9D%E7%BA%A7%E7%AF%87_BG.jpg?raw=true);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;">
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2>Unity Shader初级篇</h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
				<!-- 目录 -->
				<p class="show-toc-btn" id="show-toc-btn" onclick="showToc();" style="display:none">
				<span class="btn-bg"></span>
				<span class="btn-text">文章导航</span>
				</p>
				<div id="toc-article" class="toc-article">
					<span id="toc-close" class="toc-close" title="隐藏导航" onclick="showBtn();">×</span>
					<strong class="toc-title">文章目录</strong>
					<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#第五章-开始Unity-Shader的学习之旅"><span class="toc-text">第五章 开始Unity Shader的学习之旅</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#一个最简单的顶点-片元着色器"><span class="toc-text">一个最简单的顶点/片元着色器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Unity提供的内置文件和变量"><span class="toc-text">Unity提供的内置文件和变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Unity提供的CG-HLSL语义"><span class="toc-text">Unity提供的CG/HLSL语义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#调试Unity-Shader"><span class="toc-text">调试Unity Shader</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#渲染平台的差异"><span class="toc-text">渲染平台的差异</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Shader整洁之道"><span class="toc-text">Shader整洁之道</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第六章-Unity中的基础光照"><span class="toc-text">第六章 Unity中的基础光照</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#在Unity-Shader中实现漫反射光照模型"><span class="toc-text">在Unity Shader中实现漫反射光照模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#在Unity-Shader中实现高光反射光照模型"><span class="toc-text">在Unity Shader中实现高光反射光照模型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第七章-基础纹理"><span class="toc-text">第七章 基础纹理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#单张纹理"><span class="toc-text">单张纹理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#凹凸映射"><span class="toc-text">凹凸映射</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#渐变纹理"><span class="toc-text">渐变纹理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#遮罩纹理"><span class="toc-text">遮罩纹理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第八章-透明效果"><span class="toc-text">第八章 透明效果</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Unity-Shader的渲染顺序"><span class="toc-text">Unity Shader的渲染顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#透明度测试"><span class="toc-text">透明度测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#透明度混合"><span class="toc-text">透明度混合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#开启深度写入的半透明效果"><span class="toc-text">开启深度写入的半透明效果</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ShaderLab的混合命令"><span class="toc-text">ShaderLab的混合命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#双面渲染的透明效果"><span class="toc-text">双面渲染的透明效果</span></a></li></ol></li></ol>
			   </div>
			   <script type="text/javascript">
				function showToc(){
					var toc_article = document.getElementById("toc-article");
					var show_toc_btn = document.getElementById("show-toc-btn");
					toc_article.setAttribute("style","display:block");
					show_toc_btn.setAttribute("style","display:none");
					};
				function showBtn(){
					var toc_article = document.getElementById("toc-article");
					var show_toc_btn = document.getElementById("show-toc-btn");
					toc_article.setAttribute("style","display:none");
					show_toc_btn.setAttribute("style","display:block");
					};
			   </script>
				
                <h1 id="第五章-开始Unity-Shader的学习之旅"><a href="#第五章-开始Unity-Shader的学习之旅" class="headerlink" title="第五章 开始Unity Shader的学习之旅"></a><font size="6" color="orange">第五章 开始Unity Shader的学习之旅</font></h1><hr>
<p>Mac使用的图像编程接口是基于OpenGL的，而其他平台如Windows，可能使用的是DirectX。在OpenGL中，渲染纹理（RenderTexture）的(0,0)在左下角，而在DirectX中，(0,0)点是在左上角。</p>
<h2 id="一个最简单的顶点-片元着色器"><a href="#一个最简单的顶点-片元着色器" class="headerlink" title="一个最简单的顶点/片元着色器"></a><font size="5" color="red">一个最简单的顶点/片元着色器</font></h2><p>下面是一个显示物体法线颜色的Unity Shader着色器（最终颜色是法线的归一化颜色乘上来自颜色拾取器的颜色）：</p>
<pre class="line-numbers language-shader"><code class="language-shader">Shader "Unity Shaders Book/Chapter5/SimplerShader"
{
    Properties
    {
        _Color ("Color Tint", Color) = (1.0, 1.0, 1.0, 1.0)
    }

    SubShader
    {
        Pass
        {
            CGPROGRAM

            #pragma vertex vert
            #pragma fragment frag

            fixed4 _Color;

            struct a2v
            {
                float4 vertex : POSITION;
                float3 normal : NORMAL;
                float4 texcoord : TEXCOORD0;
            };

            struct v2f
            {
                float4 pos : SV_POSITION;
                float3 color : COLOR0;
            };

            v2f vert(a2v v)
            {
                v2f o;
                o.pos = mul(UNITY_MATRIX_MVP, v.vertex);
                o.color = v.normal * 0.5 + fixed3(0.5, 0.5, 0.5);
                return o;
            }

            float4 frag(v2f i) : SV_Target
            {
                return fixed4(i.color * _Color.rgb, 1.0);
            }

            ENDCG
        }
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中POSITION、SV_POSITION等等都是Cg/HLSL的语义（SV是system_value的简写，表示系统数值，或者系统数值语义），它们是不可省略的，因为这些语义将告诉系统用户需要哪些输入值，以及用户的输出是什么。换句话说，这些语义可以让Shader知道从哪里读取数据，并把数据输出到哪里。比如POSITION将告诉Unity，把模型的顶点坐标填充到输入参数v的vertex属性中；SV_POSITION将告诉Unity，顶点着色器的输出是裁剪空间中的顶点坐标。如果没有这些语义来限定输入和输出参数的话，渲染器就完全不知道用户的输入输出是什么，也就无法得到正确的渲染结果（顶点着色器的输出里必须包含SV_POSITION语义，否则渲染器将无法得到裁剪空间中的顶点坐标）。而SV_Target也是HLSL中的一个系统语义，它等同于告诉渲染器，把用户的输出颜色存储到一个渲染目标（render target）中（这里将输出到默认的帧缓存中）。</p>
<p>那填充到POSITION、NORMAL、TANGENT这些语义中的数据是从哪里来的呢？在Unity中，它们是由使用该材质的MeshRender组件提供的。在每帧调用DrawCall时，MeshRender组件会把它负责渲染的模型数据发送给Unity Shader。</p>
<p>其中属性Properties中的变量将会显示到Unity的材质面板上，以供用户自定义输入。其中<code>_Color (&quot;Color Tint&quot;, Color) = (1.0, 1.0, 1.0, 1.0)</code>是声明了一个属性_Color，它的类型是Color，初始值是(1.0,1.0,1.0,1.0)，对应白色。需要注意的是，在Cg代码片段中，必须再定义一个与属性名称和类型都匹配的变量，比如上面代码里的<code>fixed4 _Color;</code>。</p>
<p>在UnityShader中，uniform关键词是可以省略的（这个uniform是Cg中的修饰词，和OpenGL中的意思不一样）。</p>
<h2 id="Unity提供的内置文件和变量"><a href="#Unity提供的内置文件和变量" class="headerlink" title="Unity提供的内置文件和变量"></a><font size="5" color="red">Unity提供的内置文件和变量</font></h2><p>在UnityShader中可以使用<code>#include</code>包含一些其他文件，比如Unity在一些.cginc文件中就为我们提供了一些非常有用的变量和函数：</p>
<pre class="line-numbers language-shader"><code class="language-shader">CGPROGRAM
//...
#include "UnityCG.cginc"
//...
ENDCG
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Unity提供的内置着色器文件（通常都是一些着色函数的源代码），可以从<a href="https://unity3d.com/cn/get-unity/download/archive" target="_blank" rel="noopener">这里</a>下载。下载下来后会有很多个文件夹，其中CGIncludes文件夹中包含了所有的内置包含文件；DefaultResources文件夹中包含了一些内置组间或功能所需要的Unity Shader，例如一些GUI元素使用的Shader；DefaultResourcesExtra则包含了所有Unity中内置的Unity Shader；Editor文件夹目前只包含了一个脚本文件，它用于定义Unity5引入的Standard Shader所用的材质面板。这些文件都是我们学习Unity内置着色器或函数的非常好的参考资料。</p>
<p>下表给出了CGIncludes中主要的包含文件以及它们的主要用处：</p>
<table>
<thead>
<tr>
<th style="text-align:left">文件名</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">UnityCG.cginc</td>
<td style="text-align:left">包含了最常使用的帮助函数、宏和结构体等</td>
</tr>
<tr>
<td style="text-align:left">UnityShaderVariables.cginc</td>
<td style="text-align:left">在编译Unity Shader时，会被自动包含进来。包含了许多内置的全局变量，如UNITY_MATRIX_MVP等</td>
</tr>
<tr>
<td style="text-align:left">Lighting.cginc</td>
<td style="text-align:left">包含了各种内置的光照模型，如果编写的是Surface Shader的话，会自动包含进来</td>
</tr>
<tr>
<td style="text-align:left">HLSLSupport.cginc</td>
<td style="text-align:left">在编译Unity Shader时，会被自动包含进来。声明了很多用于跨平台编译的宏和定义</td>
</tr>
</tbody>
</table>
<p>其中最常用的UnityCG.cginc文件中的一些常用的结构体如下表所示：</p>
<table>
<thead>
<tr>
<th style="text-align:left">名称</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">包含的变量</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">appdata_base</td>
<td style="text-align:left">可用于顶点着色器的输入</td>
<td style="text-align:left">顶点位置、顶点法线、第一组纹理坐标</td>
</tr>
<tr>
<td style="text-align:left">appdata_tan</td>
<td style="text-align:left">可用于顶点着色器的输入</td>
<td style="text-align:left">顶点位置、顶点切线、顶点法线、第一组纹理坐标</td>
</tr>
<tr>
<td style="text-align:left">appdata_full</td>
<td style="text-align:left">可用于顶点着色器的输入</td>
<td style="text-align:left">顶点位置、顶点切线、顶点法线、四组（或更多）纹理坐标</td>
</tr>
<tr>
<td style="text-align:left">appdata_img</td>
<td style="text-align:left">可用于顶点着色器的输入</td>
<td style="text-align:left">顶点位置、第一组纹理坐标</td>
</tr>
<tr>
<td style="text-align:left">v2f_img</td>
<td style="text-align:left">可用于顶点着色器的输出</td>
<td style="text-align:left">裁剪空间中的位置、纹理坐标</td>
</tr>
</tbody>
</table>
<p>UnityCG.cginc文件中还提供了一些常用的帮助函数：</p>
<table>
<thead>
<tr>
<th style="text-align:left">函数名</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">float WorldSpaceViewDir(float4 v)</td>
<td style="text-align:left">输入一个模型空间中的顶点位置，返回世界空间中从该点到摄像机的观察方向</td>
</tr>
<tr>
<td style="text-align:left">float3 ObjSpaceViewDir(float4 v)</td>
<td style="text-align:left">输入一个模型空间中的顶点位置，返回模型空间中从该点到摄像机的观察方向</td>
</tr>
<tr>
<td style="text-align:left">float3 WorldSpaceLightDir(float4 v)</td>
<td style="text-align:left">仅可用于前向渲染中。输入一个模型空间中的顶点位置，返回世界空间中从该点到光源的光照方向。没有被归一化</td>
</tr>
<tr>
<td style="text-align:left">float3 ObjSpaceLightDir(float4 v)</td>
<td style="text-align:left">仅可用于前向渲染中。输入一个模型空间中的顶点位置，返回模型空间中从该点到光源的光照方向。没有被归一化</td>
</tr>
<tr>
<td style="text-align:left">float3 UnityObjectToWorldNormal(float3 norm)</td>
<td style="text-align:left">把法线方向从模型空间转换到世界空间中，返回的是归一化的向量</td>
</tr>
<tr>
<td style="text-align:left">float3 UnityObjectToWorldDir(float3 dir)</td>
<td style="text-align:left">把方向矢量从模型空间变换到世界空间中，返回的是归一化的向量</td>
</tr>
<tr>
<td style="text-align:left">float3 UnityWorldToObjectDir(float3 dir)</td>
<td style="text-align:left">把方向矢量从世界空间变换到模型空间中，返回的是归一化的向量</td>
</tr>
</tbody>
</table>
<h2 id="Unity提供的CG-HLSL语义"><a href="#Unity提供的CG-HLSL语义" class="headerlink" title="Unity提供的CG/HLSL语义"></a><font size="5" color="red">Unity提供的CG/HLSL语义</font></h2><p>从应用阶段传递模型数据给顶点着色器时Unity支持的常用语义如下表：</p>
<table>
<thead>
<tr>
<th style="text-align:left">语义</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">POSITION</td>
<td style="text-align:left">模型空间中的顶点位置，通常是float4类型</td>
</tr>
<tr>
<td style="text-align:left">NORMAL</td>
<td style="text-align:left">顶点法线，通常是float3类型</td>
</tr>
<tr>
<td style="text-align:left">TANGENT</td>
<td style="text-align:left">顶点切线，通常是float4类型</td>
</tr>
<tr>
<td style="text-align:left">TEXCOORDn，如TEXCOORD0、TEXCOORD1</td>
<td style="text-align:left">该顶点的纹理坐标，TEXCOORD0表示第一组纹理坐标，以此类推。通常是float2或float4类型</td>
</tr>
<tr>
<td style="text-align:left">COLOR</td>
<td style="text-align:left">顶点颜色，通常是fixed4或float4类型</td>
</tr>
</tbody>
</table>
<p>从顶点着色器传递数据给片元着色器时Unity支持的常用语义如下表：</p>
<table>
<thead>
<tr>
<th style="text-align:left">语义</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">SV_POSITION</td>
<td style="text-align:left">裁剪空间中的顶点坐标，结构体中必须包含一个用该语义修饰的变量</td>
</tr>
<tr>
<td style="text-align:left">COLOR0</td>
<td style="text-align:left">通常用于输出第一组顶点颜色，但不是必需的</td>
</tr>
<tr>
<td style="text-align:left">COLOR1</td>
<td style="text-align:left">通常用于输出第二组顶点颜色，但不是必需的</td>
</tr>
<tr>
<td style="text-align:left">TEXCOORD0~TEXCOORD7</td>
<td style="text-align:left">通常用于输出纹理坐标，但不是必需的</td>
</tr>
</tbody>
</table>
<p>片元着色器输出时Unity支持的常用语义如下表：</p>
<table>
<thead>
<tr>
<th style="text-align:left">语义</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">SV_Target</td>
<td style="text-align:left">输出值将会存储到渲染目标（render target）中</td>
</tr>
</tbody>
</table>
<p>一个语义可以使用的寄存器只能处理4个浮点值。所以如果想要定义矩阵类型，如float3x4，可以将其拆分成多个行或者列向量来实现。</p>
<h2 id="调试Unity-Shader"><a href="#调试Unity-Shader" class="headerlink" title="调试Unity Shader"></a><font size="5" color="red">调试Unity Shader</font></h2><p>使用VS的Graphics Debugger可以对顶点着色器和片元着色器进行单步调试。具体安装和使用方法参见<a href="https://docs.unity3d.com/Manual/SL-DebuggingD3D11ShadersWithVS.html" target="_blank" rel="noopener">这里</a>。Unity原生的帧调试器应可以看某一帧是如何一步步渲染出来的（无法对shader断点调试）。</p>
<h2 id="渲染平台的差异"><a href="#渲染平台的差异" class="headerlink" title="渲染平台的差异"></a><font size="5" color="red">渲染平台的差异</font></h2><p>Unity的屏幕坐标原点在左下角，这和OpenGL一样，但是和DirectX是相反的（DirectX的屏幕坐标原点在左上角）。所以当把Unity Shader编译到DirectX平台上的时候，Unity会自动为我们翻转屏幕图像纹理。但是一种情况例外：如果我们开启了抗锯齿（在Edit→Project Settings→Quality→Anti Aliasing中开启）并使用到了渲染纹理，这时在DirectX平台下，我们得到的屏幕图像并不会被Unity翻转（可以通过判断主纹理的纹素大小在竖直方向上是否是负值来判断是否出现了这种情况，具体参见原书P116）。</p>
<p>DirectX9/11也不支持在顶点着色器中使用tex2D函数，因为在顶点着色器阶段Shader无法得到UV偏导，而tex2D函数需要这样的偏导信息（这和纹理采样时使用的数学运算有关）。如果我们确实需要在顶点着色器中访问纹理，需要使用tex2Dlod函数来代替，如：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token function">tex2Dlod</span><span class="token punctuation">(</span>tex<span class="token punctuation">,</span> <span class="token function">float4</span><span class="token punctuation">(</span>uv<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>而且我们还需要添加#pragma target 3.0，因为tex2Dlod是Shader Model 3.0中的特性。</p>
<h2 id="Shader整洁之道"><a href="#Shader整洁之道" class="headerlink" title="Shader整洁之道"></a><font size="5" color="red">Shader整洁之道</font></h2><p>在CG/HLSL中，有3种精度的数值类型：float、half和fixed，它们的精度以及范围如下表所示：</p>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">精度</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">float</td>
<td style="text-align:left">最高精度的浮点值。通常使用32位来存储</td>
</tr>
<tr>
<td style="text-align:left">half</td>
<td style="text-align:left">中等精度的浮点值。通常使用16位来存储，精度范围是-60000~+60000</td>
</tr>
<tr>
<td style="text-align:left">fixed</td>
<td style="text-align:left">最低精度的浮点值。通常使用11位来存储，精度范围是-2.0~+2.0</td>
</tr>
</tbody>
</table>
<p>尽可能使用精度较低的类型，因为这可以优化Shader的性能，这一点在移动平台上尤其重要。</p>
<p>对于分支语句的建议是：</p>
<ul>
<li>分支判断语句中使用的条件变量最好是常数，即在Shader运行过程中不会发生变化</li>
<li>每个分支中包含的操作指令数尽可能少</li>
<li>分支的嵌套层数尽可能少</li>
</ul>
<p>可以在《GPU精粹2》中的GPU流程控制一章中更加深入地了解为什么流程控制语句在GPU上会影响性能。</p>
<h1 id="第六章-Unity中的基础光照"><a href="#第六章-Unity中的基础光照" class="headerlink" title="第六章 Unity中的基础光照"></a><font size="6" color="orange">第六章 Unity中的基础光照</font></h1><hr>
<p>计算机图形学的第一定律：如果它看起来是对的，那么它就是对的。</p>
<p>漫反射光照符合兰伯特定律（Lambert’s law）：反射光线的强度与表面法线和光源之间夹角的余弦值成正比。</p>
<p>反射向量$r$可以通过法线$n$和入射向量$l$来得到（原理很简单，画个菱形就知道了）：<br>$$<br>r=2(n\cdot l)n-l<br>$$</p>
<h2 id="在Unity-Shader中实现漫反射光照模型"><a href="#在Unity-Shader中实现漫反射光照模型" class="headerlink" title="在Unity Shader中实现漫反射光照模型"></a><font size="5" color="red">在Unity Shader中实现漫反射光照模型</font></h2><hr>
<p>其实就是Phong光照模型，公式很简单，直接上Shader代码了：</p>
<pre class="line-numbers language-shader"><code class="language-shader">Shader "Unity Shader Book/Chapter 6/Diffuse Pixel-Level"
{
    Properties
    {
        _Diffuse("Diffuse", Color) = (1, 1, 1, 1)
    }

    SubShader
    {
        Pass
        {
            Tags {"LightMode" = "ForwardBase"}

            CGPROGRAM

            #pragma vertex vert
            #pragma fragment frag

            #include "Lighting.cginc"

            float4 _Diffuse;

            struct a2v
            {
                float4 pos : POSITION;
                float4 normal : NORMAL;
            };

            struct v2f
            {
                float4 pos : SV_POSITION;
                float3 normal : TEXCOORD0;
            };

            v2f vert(a2v v)
            {
                v2f o;
                o.pos = UnityObjectToClipPos(v.pos);
                o.normal = mul(v.normal, (float3x3)unity_WorldToObject);
                return o;
            }

            fixed4 frag(v2f i) : SV_Target
            {
                fixed3o Ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;

                fixed3 WorldNormal = normalize(i.normal);
                fixed3 WorldLight = normalize(_WorldSpaceLightPos0.xyz);
                fixed3 Diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(dot(WorldNormal, WorldLight));

                return fixed4(Ambient + Diffuse, 1.0);
            }

            ENDCG
        }
    }

}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中<code>LightMode</code>标签是Pass标签的一种，它用于定义该Pass在Unity的光照流水线中的角色（后面的章节会详述）。只有定义了正确的LightMode，我们才能得到一些Unity的内置光照变量，比如后面用到的<code>_LightColor0</code>（该变量定义在内置文件Lighting.cginc里），可以用它访问到该Pass处理的光源的颜色和强度信息，而光源方向可以用<code>_WorldSpaceLightPos0</code>来得到（因为这里假设场景里唯一的光源是平行光）。还可以通过内置变量<code>UNITY_LIGHTMODEL_AMBIENT</code>来得到环境光部分。</p>
<p>在顶点着色器代码vert中，对法线进行变换时，需要对模型空间中的法线乘上模型矩阵的逆转置矩阵。这里使用<code>unity_WorldToObject</code>可以得到模型变换矩阵的逆矩阵（即世界空间到模型空间的变换矩阵），然后通过左乘原法线向量就能得到逆转置相乘的效果。</p>
<p>上面的兰伯特漫反射有个问题：在光照无法到达的区域，模型的外观通常是全黑的，没有任何明暗变化（因为光照值都因为小于0而被截断到0），这会使模型的背光区域看起来就像一个平面一样，失去了模型细节表现。可以用半兰伯特光照模型来解决：其实就是把法线和入射向量的夹角余弦值从-1到1的范围归一化到0到1之间而已。<br>$$<br>c_{diffuse}=(c_{light}\cdot m_{diffuse})(0.5(n\cdot l)+0.5)<br>$$<br>使用半兰伯特模型后，背光面也会有明暗变化。</p>
<h2 id="在Unity-Shader中实现高光反射光照模型"><a href="#在Unity-Shader中实现高光反射光照模型" class="headerlink" title="在Unity Shader中实现高光反射光照模型"></a><font size="5" color="red">在Unity Shader中实现高光反射光照模型</font></h2><p>高光也很简单，直接上代码把：</p>
<pre class="line-numbers language-shader"><code class="language-shader">Shader "Unity Shader Book/Chapter 6/Specular Pixel-Level"
{
    Properties
    {
        _Diffuse("Diffuse", Color) = (1, 1, 1, 1)
        _Specular ("Specular", Color) = (1,1,1,1)
        _Gloss ("Gloss", Range(8.0, 256)) = 20
    }

    SubShader
    {
        Pass
        {
            Tags {"LightMode" = "ForwardBase"}

            CGPROGRAM

            #pragma vertex vert
            #pragma fragment frag

            #include "Lighting.cginc"

            float4 _Diffuse;
            fixed4 _Specular;
            float  _Gloss;

            struct a2v
            {
                float4 pos : POSITION;
                float4 normal : NORMAL;
            };

            struct v2f
            {
                float4 pos : SV_POSITION;
                float3 normal : TEXCOORD0;
                float3 worldPos : TEXCOORD1;
            };

            v2f vert(a2v v)
            {
                v2f o;
                o.pos = UnityObjectToClipPos(v.pos);
                o.normal = mul(v.normal, (float3x3)unity_WorldToObject);
                o.worldPos = mul(unity_ObjectToWorld, v.pos).xyz;
                return o;
            }

            fixed4 frag(v2f i) : SV_Target
            {
                fixed3 Ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;

                fixed3 WorldNormal = normalize(i.normal);
                fixed3 WorldLight = normalize(_WorldSpaceLightPos0.xyz);
                fixed3 Diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(dot(WorldNormal, WorldLight));

                fixed3 ReflectDir = normalize(reflect(-WorldLight, WorldNormal));
                fixed3 ViewDir = normalize(_WorldSpaceCameraPos.xyz - i.worldPos);
                fixed3 Specular = _LightColor0.rgb * _Specular.rgb * pow(saturate(dot(ReflectDir, ViewDir)), _Gloss);

                return fixed4(Ambient + Diffuse + Specular, 1.0);
            }

            ENDCG
        }
    }

}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对于Blinn-Phong光照模型只是把反射向量换成中间向量就可以了：</p>
<pre class="line-numbers language-shader"><code class="language-shader">                fixed3 ViewDir = normalize(_WorldSpaceCameraPos.xyz - i.worldPos);
                fixed3 HalfDir = normalize(WorldLight + ViewDir);
                fixed3 Specular = _LightColor0.rgb * _Specular.rgb * pow(saturate(dot(HalfDir, WorldNormal)), _Gloss);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h1 id="第七章-基础纹理"><a href="#第七章-基础纹理" class="headerlink" title="第七章 基础纹理"></a><font size="6" color="orange">第七章 基础纹理</font></h1><hr>
<h2 id="单张纹理"><a href="#单张纹理" class="headerlink" title="单张纹理"></a><font size="5" color="red">单张纹理</font></h2><p>在OpenGL里，纹理空间的原点位于左下角，而在DirectX里，原点在左上角。Unity使用的纹理空间是符合OpenGL传统的，即原点位于纹理左下角。</p>
<p>在Unity Shader里使用纹理，需要先在Properties里加上一个纹理属性：</p>
<pre class="line-numbers language-shader"><code class="language-shader">Properties
{
    _MainTex("Main Tex", 2D) = "white"{}
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>声明了一个名为<code>_MainTex</code>的变量，类型是2D纹理，在监视器面板中显示的名字是“Main Tex”，并且使用了一个字符串后跟一个花括号来作为初始值，其中“white”是一个内置纹理的名字，表示一张全白的纹理。</p>
<p>并且还需要在CG代码段中，为该纹理声明对应的纹理采样器以及纹理的缩放和偏移属性：</p>
<pre class="line-numbers language-shader"><code class="language-shader">sampler2D _MainTex;
float4 _MainTex_ST;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>其中<code>_MainTex_ST</code>的名字不是任意起的。在Unity中，我们需要使用<strong>纹理名_ST</strong>的方式来声明某个纹理的属性。其中，ST是缩放（scale）和平移（translation）的缩写。<code>_MainTex_ST</code>可以让我们得到该纹理的缩放和偏移值，其中<code>_MainTex_ST.xy</code>存储的是缩放值，<code>_MainTex_ST.zw</code>存储的是偏移值。这些值可以在材质面板的纹理属性中调节。然后可以利用这些变量去纹理中进行采样得到albedo：</p>
<pre class="line-numbers language-shader"><code class="language-shader">struct v2f
{
    float4 pos : SV_POSITION;
    float3 worldNormal : TEXCOORD0;
    float3 worldPos : TEXCOORD1;
    float2 uv : TEXCOORD2;
};

v2f vert(a2v v)
{
    v2f o;
    o.uv = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    //only call the built-in function, need #include "UnityCG.cginc"
    //o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);
    return o;
}

fixed4 frag(v2f i) : SV_Target
{
    fixed3 Albedo = tex2D(_MainTex, i.uv).rgb * _Color.rgb;
    fixed3 Ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * Albedo;
    fixed3 Diffuse = _LightColor0.rgb * Albedo * max(0, dot(WorldNormal, WorldLightDir));
    //...
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用多级渐远纹理（mipmap）时，通常会多占用33%的内存空间。如果一张纹理没有使用多级渐远纹理技术，那么Trilinear得到的结果和Bilinear就是一样的。</p>
<p>如果使用了非2的幂大小（Non Power of Two，NPOT）的纹理，那么这些纹理往往会占用更多的内存空间，而且GPU读取纹理的速度也会有所下降。有一些平台甚至不支持这种NPOT纹理，这时Unity在内部会把它缩放成最近的2的幂大小。处于性能和空间的考虑，我们应该尽量使用2的幂大小的纹理。</p>
<h2 id="凹凸映射"><a href="#凹凸映射" class="headerlink" title="凹凸映射"></a><font size="5" color="red">凹凸映射</font></h2><p>切线空间的法线纹理其实就是存储了每个点在各自的切线空间中的<strong>法线扰动方向</strong>。也就是说，如果一个点的法线方向不变，那么在它的切线空间中，新的法线方向就是z轴方向，即值为（0,0,1），经过映射后存储在纹理中就对应了RGB(0.5,0.5,1.0)的浅蓝色。所以切线空间下的法线纹理才会出现大片的浅蓝色。这些蓝色实际上说明顶点的大部分法线是和模型本身法线是一样的，不需要改变。</p>
<p>使用模型空间法线纹理的优点如下：</p>
<ul>
<li>实现简单，更加直观</li>
<li>在纹理坐标的缝合处和尖锐的边角部分，可见的突变（缝隙）较少，即可以提供平滑的边界。这是因为模型空间下的法线纹理存储的是同意坐标系下的法线信息，因此在边界处通过插值得到的法线可以平滑变换。而切线空间下的法线纹理中的法线信息是依靠纹理坐标的方向得到的结果，可能会在边缘处或尖锐的部分造成更多可见的缝合迹象。</li>
</ul>
<p>但使用切线空间法线纹理的优点更多：</p>
<ul>
<li>自由度高。模型空间下的法线纹理记录的是绝对法线信息，仅可用于创建它时的那个模型，而应用到其他模型上效果就完全错误了。而切线空间下的法线纹理记录的是相对法线信息，这意味着，即便把该纹理应用到一个完全不同的网格上，也可以得到一个合理的结果。</li>
<li>可进行UV动画。比如，我们可以移动一个纹理的UV坐标来实现一个凹凸移动的效果。但使用模型空间下的法线纹理会得到完全错误的结果。UV动画在水或者火山熔岩这种类型的物体上会经常用到。</li>
<li>可以重用法线纹理。比如，一个砖块，我们仅使用一张法线纹理就可以用到所有的6个面上。</li>
<li>可压缩。原理是由于法线是归一化的，有了x、y后就可以算出z，所以z不用存下来。但是由于在模型空间下的法线的z可能是正也可能是负的，导致无法最终根据开方的结果来确定到底取正还是负，而切线空间下法线的z方向肯定是正的，所以在切线空间下可以对法线纹理进行压缩（只存储xy分量），而模型空间下的法线纹理不可以。</li>
</ul>
<p>法线贴图技术可以在切线空间下计算，也可以在世界空间下计算。先上切线空间下的代码：</p>
<pre class="line-numbers language-shader"><code class="language-shader">Shader "Unity Shaders Book/Chapter 7/NormalMapTangentSpace"
{
    Properties
    {
        _Color("Color Tint", Color) = (1, 1, 1, 1)
        _MainTex("Main Tex", 2D) = "white"{}
        _BumpMap("Normal Map", 2D) = "bump"{}
        _BumpScale("Bump Scale", Float) = 1.0
        _Specular("Specular", Color) = (1, 1, 1, 1)
        _Gloss("Gloss", Range(8.0, 256)) = 20
    }

    SubShader
    {
        Pass
        {
            Tags {"LightMode" = "ForwardBase"}

            CGPROGRAM

            #pragma vertex vert
            #pragma fragment frag

            #include "Lighting.cginc"

            fixed4 _Color;
            sampler2D _MainTex;
            float4 _MainTex_ST;
            sampler2D _BumpMap;
            float4 _BumpMap_ST;
            float  _BumpScale;
            fixed4 _Specular;
            float  _Gloss;

            struct a2v
            {
                float4 vertex : POSITION;
                float3 normal : NORMAL;
                float4 tangent : TANGENT;
                float4 texcoord : TEXCOORD0;
            };

            struct v2f
            {
                float4 pos : SV_POSITION;
                float4 uv : TEXCOORD0;
                float3 lightDir : TEXCOORD1;
                float3 viewDir : TEXCOORD2;
            };

            v2f vert(a2v v)
            {
                v2f o;
                o.pos = UnityObjectToClipPos(v.vertex);

                o.uv.xy = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;
                o.uv.zw = v.texcoord.xy * _BumpMap_ST.xy + _BumpMap_ST.zw;

                //float3 binormal = cross(normalize(v.normal), normalize(v.tangent.xyz)) * v.tangent.w;
                //float3x3 ModelToTangentMatrix = float3x3(v.tangent, binormal, v.normal);
                //or get ModelToTangentMatrix by built-in macro TANGENT_SPACE_ROTATION
                TANGENT_SPACE_ROTATION;
                o.lightDir = mul(rotation, ObjSpaceLightDir(v.vertex)).xyz;
                o.viewDir = mul(rotation, ObjSpaceViewDir(v.vertex)).xyz;

                return o;
            }

            fixed4 frag(v2f i) : SV_Target
            {
                fixed3 tangentLightDir = normalize(i.lightDir);
                fixed3 tangentViewDir = normalize(i.viewDir);

                fixed4 packedNormal = tex2D(_BumpMap, i.uv.zw);
                fixed3 unpackedNormal;
                //if the texture is not marked as "Normal Map"
                //unpackedNormal = unpackedNormal * 2 - 1;
                //else if the texture is marked as "Normal Map", need to use the built-in function
                unpackedNormal = UnpackNormal(packedNormal);
                unpackedNormal.xy *= _BumpScale;
                unpackedNormal.z = sqrt(1.0 - saturate(dot(unpackedNormal.xy, unpackedNormal.xy)));

                fixed3 albedo = tex2D(_MainTex, i.uv).rgb * _Color.rgb;
                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;
                fixed3 diffuse = _LightColor0.rgb * albedo * max(0, dot(unpackedNormal, tangentLightDir));

                fixed3 halfDir = normalize(tangentLightDir + tangentViewDir);
                fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(0, dot(unpackedNormal, halfDir)), _Gloss);

                return fixed4(ambient + diffuse + specular, 1.0);
            }

            ENDCG
        }
    }

    Fallback "Specular"
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>原理很简单，就是事先在顶点着色器中把光线入射向量<code>lightDir</code>和观察向量<code>viewDir</code>变换到切线空间下。需要注意的是从模型空间到切线空间的变换矩阵可以用注释里的代码来算，即切向量、副切向量、法线按行排列得到的矩阵<code>ModelToTangentMatrix</code>（其中算副切线时乘以<code>v.tangent.w</code>，是因为和切线与法线都垂直的方向有两个，可以用w来决定选择其中哪一个方向）。其实Unity也为我们提供了一个内置宏<code>TANGENT_SPACE_ROTATION</code>，该宏其实就是定义了一个从<strong>模型空间到切线空间</strong>的变换矩阵<code>rotation</code>。我们需要先在CG代码段里声明这个宏，然后就可以直接使用<code>rotation</code>这个矩阵了（需要注意的是<code>rotation</code>矩阵是从模型空间转换到切线空间的，而不是从世界空间转换到切线空间）。</p>
<p>并且法线纹理中存储的是法线被映射到0~1之后的值，而真正的法线范围应该是-1~1，所以需要把纹理中的法线值反映射回来。这里反映射有两种情况：</p>
<ul>
<li>如果没有在Unity里把法线纹理的类型设置为Normal map，就需要在CG代码中手动进行这个过程，即上面代码注释里那样：先乘2再减1</li>
<li>如果已经在Unity里把法线纹理的类型设置为Normal map，就不能再像上面那样来进行反映射了。因为把纹理类型标识为Normal map后，Unity会根据平台来选择不同的压缩方法。这时，如果我们再使用上面的方法来计算就会得到错误的结果，因为此时<code>_BumpMap</code>的rgb分量并不再是切线空间下法线方向的xyz值了。这时需要使用Unity的内置函数UnpackNormal来得到正确的法线方向。</li>
</ul>
<p>对反映射之后的法线乘上<code>_BumpScale</code>后，可以根据该值来改变模型的凹凸程度。</p>
<p>如果要在世界空间里应用法线贴图，需要把世界空间到切线空间的转换矩阵（即TBN矩阵）从顶点着色器传递到片元着色器里，所以，需要先在结构体<code>v2f</code>中加入存储TBN矩阵的变量：</p>
<pre class="line-numbers language-shader"><code class="language-shader">struct v2f
{
    float4 pos : SV_POSITION;
    float4 uv : TEXCOORD0;
    float4 Tangent2WorldSpace0 : TEXCOORD1;
    float4 Tangent2WorldSpace1 : TEXCOORD2;
    float4 Tangent2WorldSpace2 : TEXCOORD3;
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>之所以要把TBN矩阵按行分开来存，是因为在Unity Shader里一个插值寄存器最多只能存储float4大小的变量，对于矩阵这样的变量，应该把它拆成多个变量再进行存储。然后在顶点着色器里算出对应的顶点世界坐标、TBN向量即可：</p>
<pre class="line-numbers language-shader"><code class="language-shader">v2f vert(a2v v)
{
    v2f o;
    o.pos = UnityObjectToClipPos(v.vertex);

    o.uv.xy = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    o.uv.zw = v.texcoord.xy * _BumpMap_ST.xy + _BumpMap_ST.zw;

    float3 WorldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
    float3 WorldNormal = UnityObjectToWorldNormal(v.normal);
    float3 WorldTangent = UnityObjectToWorldDir(v.tangent.xyz);
    float3 WorldBinormal = cross(WorldNormal, WorldTangent) *v.tangent.w; 

    o.Tangent2WorldSpace0 = float4(WorldTangent.x, WorldBinormal.x, WorldNormal.x, WorldPos.x);
    o.Tangent2WorldSpace1 = float4(WorldTangent.y, WorldBinormal.y, WorldNormal.y, WorldPos.y);
    o.Tangent2WorldSpace2 = float4(WorldTangent.z, WorldBinormal.z, WorldNormal.z, WorldPos.z);

    return o;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后在片元着色器里，需要对采出来并反映射之后的法线向量，从切线空间变换到世界空间里：</p>
<pre class="line-numbers language-shader"><code class="language-shader">fixed4 frag(v2f i) : SV_Target
{
    //...
    //Transform the normal from tangent sapce to world space
    unpackedNormal = normalize(half3(dot(i.Tangent2WorldSpace0.xyz, unpackedNormal), dot(i.Tangent2WorldSpace1.xyz, unpackedNormal), dot(i.Tangent2WorldSpace2.xyz, unpackedNormal)));
    //...
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>最后用世界空间下的光线方向、观察方向、法线方向等等来计算Blinn-Phong光照就可以了。</p>
<p>如果导入Unity的不是一张淡蓝色的法线贴图，而是一张黑白色的高度图（高度图记录了相对高度，也可以用来实现类似BumpMap的效果），不过导入后需要把该高度纹理的类型设置为Normal Map，还需要勾选Create from Grayscale，这样一来，就可以把该高度图和切线空间下的法线纹理同等对待了。</p>
<h2 id="渐变纹理"><a href="#渐变纹理" class="headerlink" title="渐变纹理"></a><font size="5" color="red">渐变纹理</font></h2><hr>
<p>渐变纹理的原理其实就是：使用漫反射半兰伯特的值作为纹理坐标，来采样渐变纹理，将采出的纹素值作为漫反射值。完整代码如下：</p>
<pre class="line-numbers language-shader"><code class="language-shader">Shader "Unity Shaders Book/Chapter 7/Ramp Texture"
{
    Properties
    {
        _Color("Color Tint", Color) = (1,1,1,1)
        _RampTex("Ramp Tex", 2D) = "white"{}
        _Specular("Specular", Color) = (1,1,1,1)
        _Gloss("Gloss", Range(8.0, 256.0)) = 20
    }

    SubShader
    {
        Pass
        {
            Tags{"LightMode" = "ForwardBase"}

            CGPROGRAM

            #pragma vertex vert
            #pragma fragment frag

            #include "Lighting.cginc"

            fixed4 _Color;
            sampler2D _RampTex;
            float4 _RampTex_ST;
            fixed4 _Specular;
            float _Gloss;

            struct a2v
            {
                float4 Vertex : POSITION;
                float3 Normal : NORMAL;
                float4 TexCoord : TEXCOORD0;
            };

            struct v2f
            {
                float4 Pos : SV_POSITION;
                float3 WorldNormal : TEXCOORD0;
                float3 WorldPos : TEXCOORD1;
                float2 UV : TEXCOORD2;    
            };

            v2f vert(a2v v)
            {
                v2f o;
                o.Pos = UnityObjectToClipPos(v.Vertex);
                o.WorldNormal = UnityObjectToWorldNormal(v.Normal);
                o.WorldPos = mul(unity_ObjectToWorld, v.Vertex).xyz;
                o.UV = TRANSFORM_TEX(v.TexCoord, _RampTex);
                return o;
            }

            fixed4 frag(v2f i) : SV_Target
            {
                fixed3 WorldNormal = normalize(i.WorldNormal);
                fixed3 WorldLightDir = normalize(UnityWorldSpaceLightDir(i.WorldPos));

                fixed3 Ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;
                fixed HalfLambert = 0.5 * dot(WorldNormal, WorldLightDir) + 0.5;
                //use HalfLambert
                fixed3 Diffuse = tex2D(_RampTex, fixed2(HalfLambert, HalfLambert)).rgb * _Color.rgb * _LightColor0.rgb;

                fixed3 ViewDir = normalize(UnityWorldSpaceViewDir(i.WorldPos));
                fixed3 HalfDir = normalize(ViewDir + WorldLightDir);
                fixed3 Specular = _LightColor0.rgb * _Specular.rgb * pow(max(0, dot(WorldNormal, HalfDir)), _Gloss);

                return fixed4(Ambient + Diffuse + Specular, 1.0);
            }

            ENDCG
        }
    }

    Fallback "Specular"
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>需要注意的是，应该把渐变纹理的Wrap Mode设为Clamp模式。因为上面我们使用的采样坐标是<code>fixed2(HalfLambert, HalfLambert)</code>，这个采样坐标是浮点类型的，就有可能会因为精度问题出现1.00001这样的坐标值，如果使用的是Repeat模式，坐标会被保留小数部分，从而采出来渐变纹理中最左边的纹素，即黑色，所以就会出现像下图这样在高光区域反而出现了黑点。<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/UnityShader%E5%88%9D%E7%BA%A7%E7%AF%87_1.jpg?raw=true" alt><br>把渐变纹理改成clamp模式后可以解决这种问题，如下图：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/UnityShader%E5%88%9D%E7%BA%A7%E7%AF%87_2.jpg?raw=true" alt></p>
<h2 id="遮罩纹理"><a href="#遮罩纹理" class="headerlink" title="遮罩纹理"></a><font size="5" color="red">遮罩纹理</font></h2><p>遮罩纹理可以用来保护某些区域，使它们免于某些修改。比如镜面光贴图就是一种遮罩纹理，它可以控制物体表面上哪些区域可以反射高光；还可以用遮罩纹理来控制多张纹理的混合方式等等。使用遮罩纹理可以让美术人员更加精准（像素级别）地控制模型表面的各种性质。</p>
<p>比如想用遮罩纹理来控制高光的细节，它的代码很简单，只需要在算镜面光的时候乘上从遮罩纹理中采出的遮罩值就可以了：</p>
<pre class="line-numbers language-shader"><code class="language-shader">//...
fixed  SpecularMask = tex2D(_SpecularMaskTex, i.UV).r * _SpecularMaskScale;
fixed3 Specular = _LightColor0.rgb * _Specular.rgb * pow(max(0, dot(TangentNormal, HalfDir)), _Gloss) * SpecularMask;
//...
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>其他代码和凹凸贴图一样，就不再列出完整代码了。</p>
<h1 id="第八章-透明效果"><a href="#第八章-透明效果" class="headerlink" title="第八章 透明效果"></a><font size="6" color="orange">第八章 透明效果</font></h1><hr>
<h2 id="Unity-Shader的渲染顺序"><a href="#Unity-Shader的渲染顺序" class="headerlink" title="Unity Shader的渲染顺序"></a><font size="5" color="red">Unity Shader的渲染顺序</font></h2><p>Unity为了解决渲染顺序的问题提供了渲染队列（render queue）这一解决方案。我们可以使用SubShader的Queue标签来决定我们的渲染对象将归于哪个渲染队列。Unity在内部使用一系列整数索引来表示每个渲染队列，且索引号越小表示越早被渲染。Unity5中提前定义的5个渲染队列如下表：</p>
<table>
<thead>
<tr>
<th style="text-align:left">名称</th>
<th style="text-align:left">队列索引号</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Background</td>
<td style="text-align:left">1000</td>
<td style="text-align:left">这个渲染队列会在任何其他队列之前被渲染，我们通常使用该队列来渲染那些需要绘制在背景上的物体</td>
</tr>
<tr>
<td style="text-align:left">Geometry</td>
<td style="text-align:left">2000</td>
<td style="text-align:left">默认的渲染队列，大多数物体都使用这个队列。不透明物体使用这个队列</td>
</tr>
<tr>
<td style="text-align:left">AlphaTest</td>
<td style="text-align:left">2450</td>
<td style="text-align:left">需要透明度测试的物体使用这个队列。在Unity5中它从Geometry队列中被单独分出来，这是因为在所有不透明物体渲染之后再渲染它们会更加高效</td>
</tr>
<tr>
<td style="text-align:left">Transparent</td>
<td style="text-align:left">3000</td>
<td style="text-align:left">这个队列中的物体会在所有Geometry和AlphaTest物体渲染后，再按从后向前的顺序进行渲染。任何使用了透明度混合（例如关闭了深度写入的Shader）的物体都应该使用该队列</td>
</tr>
<tr>
<td style="text-align:left">Overlay</td>
<td style="text-align:left">4000</td>
<td style="text-align:left">该队列用于实现一些叠加效果。任何需要在最后渲染的物体都应该使用该队列</td>
</tr>
</tbody>
</table>
<p>所以，如果我们想要通过透明度测试实现透明效果，Shader代码应该类似如下：</p>
<pre class="line-numbers language-shader"><code class="language-shader">SubShader
{
    Tags{"Queue" = "AlphaTest"}
    Pass
    {
        //...
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果我们想要通过透明度混合来实现透明效果，Shader代码应该类似如下：</p>
<pre class="line-numbers language-shader"><code class="language-shader">SubShader
{
    Tags{"Queue" = "Transparent"}
    Pass
    {
        ZWrite Off
        //...
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中<code>ZWrite Off</code>用于关闭深度写入，在这里我们选择把它写在Pass中，也可以把它写在SubShader中，这时意味着该SubShader下的所有Pass都会关闭深度写入。</p>
<h2 id="透明度测试"><a href="#透明度测试" class="headerlink" title="透明度测试"></a><font size="5" color="red">透明度测试</font></h2><p>可以根据Alpha值来判断是否抛弃一个片元，来进行透明度测试：</p>
<pre class="line-numbers language-shader"><code class="language-shader">if((TexColor.a - _Cutoff) < 0.0)  //如果a通道的值小于_Cutoff，则丢弃当前片元
    discard;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>这段代码可以直接用Cg中的一个函数clip来代替：</p>
<pre class="line-numbers language-shader"><code class="language-shader">//Alpha test
clip(TexColor.a - _Cutoff);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>Alpha test的原理和代码都很简单，完整代码如下：</p>
<pre class="line-numbers language-shader"><code class="language-shader">Shader "Unity Shaders Book/Chapter 8/AlphaTest"
{
    Properties
    {
        _Color("Main Tint", Color) = (1,1,1,1)
        _MainTex("Main Tex", 2D) = "white"{}
        _Cutoff("Alpha Cutoff", Range(0, 1)) = 0.5
    }

    SubShader
    {
        Tags{"Queue" = "AlphaTest" "IgnoreProjector" = "True" "RenderType" = "TransparentCutout"}

        Pass
        {
            Tags{"LightMode" = "ForwardBase"}

            CGPROGRAM

            #pragma vertex vert
            #pragma fragment frag

            #include "Lighting.cginc"

            fixed4 _Color;
            sampler2D _MainTex;
            float4 _MainTex_ST;
            fixed  _Cutoff;

            struct a2v
            {
                float4 Vertex : POSITION;
                float3 Normal : NORMAL;
                float4 TexCoord : TEXCOORD0;
            };

            struct v2f
            {
                float4 Pos : SV_POSITION;
                float3 WorldNormal : TEXCOORD0;
                float3 WorldPos : TEXCOORD1;
                float2 UV : TEXCOORD2;
            };

            v2f vert(a2v v)
            {
                v2f o;
                o.Pos = UnityObjectToClipPos(v.Vertex);
                o.WorldNormal = UnityObjectToWorldNormal(v.Normal);
                o.WorldPos = mul(unity_ObjectToWorld, v.Vertex).xyz;
                o.UV = TRANSFORM_TEX(v.TexCoord, _MainTex);
                return o;
            }

            fixed4 frag(v2f i) : SV_Target
            {
                fixed3 WorldNormal = normalize(i.WorldNormal);
                fixed3 WorldLightDir = normalize(UnityWorldSpaceLightDir(i.WorldPos));

                fixed4 TexColor = tex2D(_MainTex, i.UV);
                //Alpha test
                clip(TexColor.a - _Cutoff);
                //Equal to:
                //if((TexColor.a - _Cutoff) < 0.0)
                    //discard;
                fixed3 Albedo = TexColor * _Color.rgb;
                fixed3 Ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * Albedo;
                fixed3 Diffuse = _LightColor0.rgb * Albedo * max(0, dot(WorldNormal, WorldLightDir));

                return fixed4(Ambient + Diffuse, 1.0);
            }

            ENDCG
        }
    }

    //Fallback "Specular"
    Fallback "Transparent/Cutout/VertexLit"
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中我们需要把Queue标签设置为<code>AlphaTest</code>，而RenderType标签可以让Unity把这个Shader归入到提前定义的组（这里就是TransparentCutout组）中，以指明该Shader是一个使用了透明度测试的Shader。RenderType标签通常被用于着色器替换功能。我们还把IgnoreProjector设置为True，这意味着这个Shader不会受到投影器（Projectors）的影响。通常，使用率透明度测试的Shader都应该在SubShader中设置这三个标签。</p>
<p>并且最后设置的回调Shader不是之前使用的Diffuse或者Specular，而是内置的<code>Transparent/Cutout/VertexLit</code>。这样设置不仅能够保证我们编写的SubShader无法在当前显卡上工作时可以有合适的代替Shader，还可以保证使用透明度测试的物体可以正确地向其他物体投射阴影。</p>
<h2 id="透明度混合"><a href="#透明度混合" class="headerlink" title="透明度混合"></a><font size="5" color="red">透明度混合</font></h2><p>为了进行透明混合，需要使用Unity提供的混合命令：Blend。使用诸如<code>Blend SrcAlpha OneMinusSrcAlpha</code>就能实现按片元Alpha值来混合的效果。这个语句需要写在对应的Pass中（关闭深度写入的<code>ZWrite Off</code>不是必须的）：</p>
<pre class="line-numbers language-shader"><code class="language-shader">Pass
{
    Tags {"LightMode" = "ForwardBase"}

    ZWrite Off
    Blend SrcAlpha OneMinusSrcAlpha
    //...
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其余的就是正常计算光照就可以了，完整代码如下：</p>
<pre class="line-numbers language-shader"><code class="language-shader">Shader "Unity Shaders Book/Chpater 8/AlphaBlend"
{
    Properties
    {
        _Color("Main Tint", Color) = (1,1,1,1)
        _MainTex("Main Tex", 2D) = "white"{}
        _AlphaScale("Alpha Scale", Range(0, 1)) = 1 
    }



    SubShader
    {
        Tags {"Queue" = "Transparent" "IgnoreProjector" = "True" "RenderType" = "Transparent"}

        Pass
        {
            Tags {"LightMode" = "ForwardBase"}

            ZWrite Off
            Blend SrcAlpha OneMinusSrcAlpha

            CGPROGRAM

            #pragma vertex vert
            #pragma fragment frag

            #include "Lighting.cginc"

            fixed4 _Color;
            sampler2D _MainTex;
            float4 _MainTex_ST;
            fixed  _AlphaScale;

            struct a2v
            {
                float4 Vertex : POSITION;
                float3 Normal : Normal;
                float4 TexCoord : TEXCOORD0;
            };

            struct v2f
            {
                float4 Pos : SV_POSITION;
                float3 WorldNormal : TEXCOORD0;
                float3 WorldPos : TEXCOORD1;
                float2 UV : TEXCOORD2;
            };

            v2f vert(a2v v)
            {
                v2f o;
                o.Pos = UnityObjectToClipPos(v.Vertex);
                o.WorldNormal = UnityObjectToWorldNormal(v.Normal);
                o.WorldPos = mul(unity_ObjectToWorld, v.Vertex).xyz;
                o.UV = TRANSFORM_TEX(v.TexCoord, _MainTex);
                return o;
            }

            fixed4 frag(v2f i) : SV_Target
            {
                fixed3 WorldNormal = normalize(i.WorldNormal);
                fixed3 WorldLightDir = normalize(UnityWorldSpaceLightDir(i.WorldPos));

                fixed4 TexColor = tex2D(_MainTex, i.UV);
                fixed3 Albedo = TexColor.rgb * _Color.rgb;

                fixed3 Ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * Albedo;
                fixed3 Diffuse = _LightColor0.rgb * Albedo * max(0, dot(WorldNormal, WorldLightDir));

                return fixed4(Ambient + Diffuse, TexColor.a * _AlphaScale);
            }

            ENDCG
        }
    }

    Fallback "Transparent/VertexLit"
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中变量<code>_AlphaScale</code>用于在透明纹理的基础上控制整体的透明度，影响到最终片元的w分量上。而且设置的回调Shader也有变化，变成了<code>Transparent/VertexLit</code>。</p>
<h2 id="开启深度写入的半透明效果"><a href="#开启深度写入的半透明效果" class="headerlink" title="开启深度写入的半透明效果"></a><font size="5" color="red">开启深度写入的半透明效果</font></h2><hr>
<p>当网格模型本身存在着相互交叉的结构时，上面的代码往往会得到错误的半透明效果：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/UnityShader%E5%88%9D%E7%BA%A7%E7%AF%87_3.jpg?raw=true" alt><br>这是因为引擎通常都只是对透明物体按从后往前的顺序渲染，这个排序是以物体模型为单位的，无法处理模型自交的问题（模型上后面的前面的片元先于后面的片元绘制就会出现这种错误的透明效果）。并且上面的代码在绘制透明物体时还关闭了深度写入（深度测试还是有效的）（其实关闭深度写入不是必须的，不关闭也可以）。有一个缓解方法：先开启深度写入，但不输出颜色把模型渲染一次，这样就能在深度缓存中保留下最近的深度，然后再把模型像上面那样进行透明混合，渲染结果如下图所示，可以看出虽然可实现模型与它后面的背景的正常混合，但是模型内部之间仍然没有实现出真正的半透明效果。<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/UnityShader%E5%88%9D%E7%BA%A7%E7%AF%87_4.jpg?raw=true" alt><br>对应的Shader其实就只是在上面那个shader上多加了一个Pass：</p>
<pre class="line-numbers language-shader"><code class="language-shader">SubShader
{
    Tags {"Queue" = "Transparent" "IgnoreProjector" = "True" "RenderType" = "Transparent"}

    Pass
    {
        ZWrite On
        ColorMask 0
    }

    Pass
    {
        //和上个shader中那个pass一样的代码
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个新加的Pass的目的仅仅是为了把模型的深度信息写入深度缓存中，从而剔除模型中被自身遮挡的片元。所以Pass里第一行开启了深度写入，第二行设置了颜色通道的写掩码，使用<code>ColorMask</code>命令，它的语义如下：</p>
<pre class="line-numbers language-shader"><code class="language-shader">ColorMask RGB | A | 0 | 其它任何R、B、B、A的组合
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>当命令ColorMask的参数为0时，意味着该Pass不写入任何颜色通道，即不会输出任何颜色。</p>
<h2 id="ShaderLab的混合命令"><a href="#ShaderLab的混合命令" class="headerlink" title="ShaderLab的混合命令"></a><font size="5" color="red">ShaderLab的混合命令</font></h2><p>ShaderLab中设置和混合因子的命令有两个：</p>
<table>
<thead>
<tr>
<th style="text-align:left">名称</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>Blend SrcFactor DstFactor</code></td>
<td style="text-align:left">开启混合，并设置混合因子。源颜色（该片元产生的颜色）会乘以SrcFactor，而目标颜色（已经存在于颜色缓冲里的颜色）会乘以DstFactor，然后把两者相加后再存入颜色缓存中（其实不止于相加）</td>
</tr>
<tr>
<td style="text-align:left"><code>Blend SrcFactor DstFactor, SrcFactorA DstFactorA</code></td>
<td style="text-align:left">和上面几乎一样，只是使用不同的因子来混合Alpha通道</td>
</tr>
</tbody>
</table>
<p>第一个命令会使用相同的因子来混合RGBA通道，而第二个命令会用前两个因子来混合RGB通道，用后两个因子来混合A通道。</p>
<p>这些混合因子可以有下面这些选项：</p>
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">One</td>
<td style="text-align:left">因子为1</td>
</tr>
<tr>
<td style="text-align:left">Zero</td>
<td style="text-align:left">因子为0</td>
</tr>
<tr>
<td style="text-align:left">SrcColor</td>
<td style="text-align:left">因子为源颜色值</td>
</tr>
<tr>
<td style="text-align:left">SrcAlpha</td>
<td style="text-align:left">因子为源颜色的透明度值（A通道）</td>
</tr>
<tr>
<td style="text-align:left">DstColor</td>
<td style="text-align:left">因子为目标颜色值</td>
</tr>
<tr>
<td style="text-align:left">DstAlpha</td>
<td style="text-align:left">因子为目标颜色的透明度值（A通道）</td>
</tr>
<tr>
<td style="text-align:left">OneMinusSrcColor</td>
<td style="text-align:left">因子为（1-源颜色）</td>
</tr>
<tr>
<td style="text-align:left">OneMinusSrcAlpha</td>
<td style="text-align:left">因子为（1-源颜色的透明度值）</td>
</tr>
<tr>
<td style="text-align:left">OneMinusDstColor</td>
<td style="text-align:left">因子为（1-目标颜色值）</td>
</tr>
<tr>
<td style="text-align:left">OneMinusDstAlpha</td>
<td style="text-align:left">因子为（1-目标颜色的透明度值）</td>
</tr>
</tbody>
</table>
<p>并且混合操作也不止于相加，还可以使用<code>BlendOp BlendOperation</code>命令来设置其他混合操作，BlendOperation有下面这些选项：</p>
<table>
<thead>
<tr>
<th style="text-align:left">操作</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Add</td>
<td style="text-align:left">将源颜色与目标颜色按混合因子相加</td>
</tr>
<tr>
<td style="text-align:left">Sub</td>
<td style="text-align:left">将源颜色与目标颜色按混合因子相减（源颜色-目标颜色）</td>
</tr>
<tr>
<td style="text-align:left">RevSub</td>
<td style="text-align:left">将目标颜色和源颜色按混合因子相减（目标颜色-源颜色）</td>
</tr>
<tr>
<td style="text-align:left">Min</td>
<td style="text-align:left">使用源颜色和目标颜色中每个分量的较小值</td>
</tr>
<tr>
<td style="text-align:left">Max</td>
<td style="text-align:left">使用源颜色和目标颜色中每个分量的较大值</td>
</tr>
<tr>
<td style="text-align:left">其他逻辑操作</td>
<td style="text-align:left">仅在DirectX 11.1中支持</td>
</tr>
</tbody>
</table>
<p>如果不设置混合操作的话，默认使用的是Add操作。</p>
<h2 id="双面渲染的透明效果"><a href="#双面渲染的透明效果" class="headerlink" title="双面渲染的透明效果"></a><font size="5" color="red">双面渲染的透明效果</font></h2><p>之前的Shader渲染透明物体时，都只能看到透明物体的正面，而不能看到透明物体的背面。这是因为，默认情况下渲染引擎剔除了物体背面的图元，而只渲染了物体的正面。我们可以使用Cull命令来控制需要剔除物体的哪个面的渲染图元。Cull命令的语义如下：</p>
<pre class="line-numbers language-shader"><code class="language-shader">Cull Back | Front | Off
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>可以控制剔除背面（默认）、正面或者关闭剔除功能。</p>
<p>在渲染透明物体时，如果想要看到物体背面，对于透明度混合来说，可以先渲染透明物体的背面，再渲染透明物体的正面。对应的Shader如下：</p>
<pre class="line-numbers language-shader"><code class="language-shader">Shader "Unity Shaders Book/Chpater 8/AlphaBlendBothSided"
{
    //...
    SubShader
    {
        Tags {"Queue" = "Transparent" "IgnoreProjector" = "True" "RenderType" = "Transparent"}

        Pass
        {
            Tags {"LightMode" = "ForwardBase"}

            Cull Front    //剔除正面，渲染背面
            ZWrite Off
            Blend SrcAlpha OneMinusSrcAlpha
            //和AlphaBlend那个shader一样的代码
        }

        Pass
        {
            Tags {"LightMode" = "ForwardBase"}

            Cull Back    //剔除背面，渲染正面
            ZWrite Off
            Blend SrcAlpha OneMinusSrcAlpha
            //和AlphaBlend那个shader一样的代码
        }
    }
    Fallback "Transparent/VertexLit"
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>最终得到的结果如下图：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/UnityShader%E5%88%9D%E7%BA%A7%E7%AF%87_5.jpg?raw=true" alt></p>
<hr>
<p>参考文献：《Unity Shader入门精要》</p>

            </div>

            <!-- Post Comments -->
            
    <!-- 使用 DISQUS_CLICK -->
<div id="disqus-comment">
    <div id="disqus_thread"></div>

<!-- add animation -->
<style>
	.disqus_click_btn {
            line-height: 30px;
            margin: 0;
            min-width: 50px;
            padding: 0 14px;
            display: inline-block;
            font-family: "Roboto", "Helvetica", "Arial", sans-serif;
            font-size: 14px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0;
            overflow: hidden;
            will-change: box-shadow;
            transition: box-shadow .2s cubic-bezier(.4, 0, 1, 1), background-color .2s cubic-bezier(.4, 0, .2, 1), color .2s cubic-bezier(.4, 0, .2, 1);
            outline: 0;
            cursor: pointer;
            text-decoration: none;
            text-align: center;
            vertical-align: middle;
            border: 0;
            background: rgba(158, 158, 158, .2);
            box-shadow: 0 2px 2px 0 rgba(0, 0, 0, .14), 0 3px 1px -2px rgba(0, 0, 0, .2), 0 1px 5px 0 rgba(0, 0, 0, .12);
            color: #fff;
            background-color: #7EC0EE;
            text-shadow: 0
        }
</style>
	
<div class="btn_click_load" id="disqus_bt"> 
    <button class="disqus_click_btn">点击查看评论</button>
</div>

<!--
<script type="text/javascript">
$('.btn_click_load').click(function() {
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'http-miccall-tech'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    document.getElementById('disqus_bt').style.display = "none";
});
</script>
-->
<script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://yoursite.com/2019/03/30/Unity-Shader初级篇/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = 'http://yoursite.com/2019/03/30/Unity-Shader初级篇/'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
</script>

<script type="text/javascript">
    $('.btn_click_load').click(function() {  //click to load comments
        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document;
            var s = d.createElement('script');
            s.src = '//http-miccall-tech.disqus.com/embed.js';
            s.setAttribute('data-timestamp', + new Date());
            (d.head || d.body).appendChild(s);
        })();
        $('.btn_click_load').css('display','none');
    });
</script>
</div>
<style>
    #disqus-comment{
        background-color: #eee;
        padding: 2pc;
    }
</style>


        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
                <li>Design: <a href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
            </ul>
            
            	<span id="busuanzi_container_site_pv">2019总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			
        </div>
    </div>
</body>



 	
</html>
