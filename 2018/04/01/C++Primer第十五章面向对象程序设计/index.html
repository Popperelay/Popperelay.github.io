<!DOCTYPE HTML>
<html>

<head>
	<link rel="bookmark"  type="image/x-icon"  href="/img/logo_miccall.png"/>
	 <link rel="shortcut icon" href="/img/logo_miccall.png">
	
			
    <title>
    Elays'Blog
    </title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="/css/mic_main.css" />
    <link rel="stylesheet" href="/css/dropdownMenu.css" />
    
    	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css" />
    </noscript>
			    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<link rel="stylesheet" href="/css/prism-dark.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>
    
		
<!-- Layouts -->


<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<!--<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">-->
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/latest.js?config=TeX-MML-AM_CHTML" async>
</script>

<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_undefined.css" />
<link rel="stylesheet" href="/css/typo.css" />
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">MICCALL</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special" >
            <ul class="menu links" >
			<!-- Homepage  主页  --> 
			<li >
	            <a href="/" rel="nofollow">主页</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">分类</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="/categories/Boost/">Boost</a></li><li><a class="category-link" href="/categories/C-语法/">C#语法</a></li><li><a class="category-link" href="/categories/C/">C++</a></li><li><a class="category-link" href="/categories/C语言/">C语言</a></li><li><a class="category-link" href="/categories/Math/">Math</a></li><li><a class="category-link" href="/categories/OpenGL/">OpenGL</a></li><li><a class="category-link" href="/categories/c/">c++</a></li><li><a class="category-link" href="/categories/全局光照/">全局光照</a></li><li><a class="category-link" href="/categories/博客配置/">博客配置</a></li><li><a class="category-link" href="/categories/并行计算/">并行计算</a></li><li><a class="category-link" href="/categories/操作系统/">操作系统</a></li><li><a class="category-link" href="/categories/数据结构/">数据结构</a></li><li><a class="category-link" href="/categories/毕设/">毕设</a></li><li><a class="category-link" href="/categories/游戏开发/">游戏开发</a></li><li><a class="category-link" href="/categories/游戏设计模式/">游戏设计模式</a></li><li><a class="category-link" href="/categories/计算机图形学/">计算机图形学</a></li><li><a class="category-link" href="/categories/计算机系统/">计算机系统</a></li><li><a class="category-link" href="/categories/设计模式/">设计模式</a></li><li><a class="category-link" href="/categories/调试错误集锦/">调试错误集锦</a></li><li><a class="category-link" href="/categories/面试/">面试</a>
	                    </ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/gallery/" title="图库">
		                图库
		            </a>
		        </li>
		        
		        <li>
		            <a href="/tag/" title="搜索">
		                搜索
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
		            
		                <li><a href="https://github.com/miccall" class="icon fa-github"><span class="label">GitHub</span></a></li>
		            
		            
		            
		            
			</ul>
</nav>

        <div id="main" >
            <div class ="post_page_title_img" style="height: 25rem;background-image: url(http://oqcvzqam1.bkt.clouddn.com/C++Primer%E7%AC%AC15%E7%AB%A0.jpg);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;" >
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2 >C++Primer第十五章 面向对象程序设计</h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
				<!-- 目录 -->
				<p class="show-toc-btn" id="show-toc-btn" onclick="showToc();" style="display:none">
				<span class="btn-bg"></span>
				<span class="btn-text">文章导航</span>
				</p>
				<div id="toc-article" class="toc-article">
					<span id="toc-close" class="toc-close" title="隐藏导航" onclick="showBtn();">×</span>
					<strong class="toc-title">文章目录</strong>
					
			   </div>
			   <script type="text/javascript">
				function showToc(){
					var toc_article = document.getElementById("toc-article");
					var show_toc_btn = document.getElementById("show-toc-btn");
					toc_article.setAttribute("style","display:block");
					show_toc_btn.setAttribute("style","display:none");
					};
				function showBtn(){
					var toc_article = document.getElementById("toc-article");
					var show_toc_btn = document.getElementById("show-toc-btn");
					toc_article.setAttribute("style","display:none");
					show_toc_btn.setAttribute("style","display:block");
					};
			   </script>
				
                <p><font size="5" color="orange">OOP：概述</font></p>
<hr>
<ol>
<li>OOP：面向对象程序设计，object-oriented programming</li>
<li>面向对象层序设计得核心思想是数据抽象、继承和动态绑定（多态）。通过使用数据抽象，我们可以将类的接口与实现分离；使用继承，可以定义相似的类型并对其相似关系建模；使用动态绑定，可以在一定程度上忽略相似类型的区别，而以统一的方式使用它们的对象。</li>
<li>C++11新标准允许派生类显式地注明它将使用哪个成员函数改写基类的虚函数，具体措施是在该函数的形参列表之后增加一个override关键字。</li>
<li>在C++语言中，当我们使用基类的<strong>引用或指针</strong>调用一个虚函数时将发生动态绑定。</li>
</ol>
<p><font size="5" color="orange">定义基类和派生类</font></p>
<hr>
<ol>
<li>基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此。</li>
<li>关键字virtual只能出现在类内部的声明语句之前而不能用于类外部的函数定义。</li>
<li>在一个对象中，继承自基类的部分和派生类自定义的部分不一定是连续存储的。</li>
<li>在派生类的构造函数初始化列表中，应该首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员。</li>
<li>不要在派生类对象中直接初始化基类的成员。尽管从语法上来说我们可以在派生类构造函数体内给它的公有或保护的基类成员赋值，但是最好不要这么做。应该调用基类的构造函数来初始化那些从基类继承而来的成员。</li>
<li><p>如果我们想将某个类用作基类，则该类必须已经定义而非仅仅声明：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">class</span> <span class="token class-name">CBase</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//声明但未定义</span>
 <span class="token keyword">class</span> <span class="token class-name">CDerive</span> <span class="token operator">:</span><span class="token keyword">public</span> CBase <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//错误：CBase必须被定义</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p> 这种情况下，通常应该#include CBase类所在的头文件，而不能仅仅是用class关键字声明它。</p>
<p> 这一规定的原因显而易见：派生类中包含并且可以使用它从基类继承而来的成员，为了使用这些成员，派生类当然要知道它们是什么。</p>
</li>
<li>如果有时我们不希望一个类被继承，可以在定义时在类名后跟一个关键字final来防止阻止发生：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">class</span> <span class="token class-name">CNoDreived</span> final <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li>当使用基类的引用（或指针）时，实际上我们并不清楚该引用（或指针）所绑定对象的真实类型。该对象可能是基类的对象，也可能是派生类的对象。</li>
<li>之所以存在派生类向基类的类型转换是因为每个派生类对象都包含一个基类部分，而基类的引用或指针可以绑定到该基类部分上。</li>
<li>即使一个基类指针或引用绑定在一个派生类对象上，我们也不能执行从基类向派生类的转换：<pre class="line-numbers language-cpp"><code class="language-cpp">CDerived DerivedObj<span class="token punctuation">;</span>
CBase <span class="token operator">*</span>pBaseObj <span class="token operator">=</span> <span class="token operator">&amp;</span>DerivedObj<span class="token punctuation">;</span>
CDerived <span class="token operator">*</span>pDerivedObj <span class="token operator">=</span> pBaseObj<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//错误，不能将基类转换成派生类</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
编译器在编译时无法确定某个特定的转换在运行时是否安全，这是因为编译器只能通过检查指针或引用的静态类型来推断该转换是否合法。想要成功地将基类指针转换为派生类指针，我们可以使用dynamic_cast来完成：<code>CDerived *pDerivedObj = dynamic_cast&lt;CDerived*&gt;pBaseObj;</code>，它会请求一个类型转换，该转换的安全检查将在运行时执行（当然前提是基类定义了虚函数才可以进行转换）。除此之外，如果我们已知某个基类向派生类的转换是安全的，则可以直接使用static_cast来强制覆盖掉编译器的检查工作。</li>
<li>派生类向基类的自动类型转换<strong>只对指针或引用类型有效</strong>，在派生类类型和基类类型之间不存在这样的转换。</li>
</ol>
<p><font size="5" color="orange">虚函数</font></p>
<hr>
<ol>
<li>如果我们使用override标记了某个函数，但是发现基类中没有该函数或者该函数不是虚函数，那么编译器会报错。所以，建议在派生类重写虚函数时最好加上override关键字，这样就能让编译器帮忙检查重写虚函数是否有效。</li>
<li>我们还能把某个函数指定为final。如果我们已经把函数定义成final了，则之后（在子类中）任何尝试<strong>覆盖</strong>该函数的操作都将引发错误。</li>
<li><p>如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致。因为使用基类指针调用虚函数时，使用的永远是基类虚函数里的默认实参，与基类指针实际绑定的动态对象无关：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">class</span> <span class="token class-name">CBase</span>
 <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
     <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">printV</span><span class="token punctuation">(</span><span class="token keyword">int</span> vI <span class="token operator">=</span> <span class="token number">41</span><span class="token punctuation">)</span>
     <span class="token punctuation">{</span>
         std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> vI <span class="token operator">&lt;&lt;</span> <span class="token string">"CBase"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>

 <span class="token keyword">class</span> <span class="token class-name">CDerived</span> <span class="token operator">:</span> <span class="token keyword">public</span> CBase
 <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
     <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">printV</span><span class="token punctuation">(</span><span class="token keyword">int</span> vI <span class="token operator">=</span> <span class="token number">45</span><span class="token punctuation">)</span> override
     <span class="token punctuation">{</span>
         std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> vI <span class="token operator">&lt;&lt;</span> <span class="token string">"CDerived"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>

 CDerived DerivedObj<span class="token punctuation">;</span>
 CBase <span class="token operator">*</span>pBaseObj <span class="token operator">=</span> <span class="token operator">&amp;</span>DerivedObj<span class="token punctuation">;</span>
 pBaseObj<span class="token operator">-</span><span class="token operator">></span><span class="token function">printV</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//输出的是41CDerived，而不是45CDerived</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>在某些情况下，我们可能希望不要执行虚函数的动态版本，而是希望执行父类的版本。我们可以在执行虚函数前加入作用域运算符来完成这一点。比如上面的程序，如果把调用虚函数的那句代码改成：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token comment" spellcheck="true">//强行调用基类中定义的虚函数版本，而不管pBaseObj绑定的动态类型到底是什么</span>
 pBaseObj<span class="token operator">-</span><span class="token operator">></span>CBase<span class="token operator">::</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//输出的是41CBase</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p> 程序执行的将不再是子类的printV函数，而是基类的。</p>
<p> 什么时候会出现这种情况呢？即什么时候需要回避虚函数的默认机制？通常是当一个派生类的虚函数需要调用它覆盖的基类的虚函数版本时。</p>
<p> 值得注意的是，如果一个派生类虚函数需要调用它的基类版本，但是没有使用作用域运算符，则在运行时该调用将被解析为对派生类版本自身的调用，从而导致无限递归。</p>
</li>
</ol>
<p><font size="5" color="orange">抽象基类</font></p>
<ol>
<li>将一个虚函数声明为纯虚函数时使用的=0，只能出现在类内部的虚函数声明语句处。</li>
<li><p>值得注意的是，我们也可以为纯虚函数提供定义，不过函数体必须定义在类的外部。也就是说我们不能在类的内部为一个=0的函数提供函数体。</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">class</span> <span class="token class-name">CBase</span>
 <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
     <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">int</span> vI<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>

 <span class="token keyword">void</span> CBase<span class="token operator">::</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">int</span> vI<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//在类外为纯虚函数提供函数体</span>
 <span class="token punctuation">{</span>
     std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> vI <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>我们不能创建抽象基类（定义了纯虚函数的类）的对象。</li>
</ol>
<p><font size="5" color="orange">访问控制与继承</font></p>
<hr>
<ol>
<li><p>派生类的成员或友元只能通过派生类对象来访问基类的受保护成员，派生类对于一个基类对象中的受保护成员没有任何访问特权。即派生类想要访问到基类的保护成员，只能通过派生类对象，而不能通过基类对象：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">class</span> <span class="token class-name">CBase</span>
 <span class="token punctuation">{</span>
 <span class="token keyword">protected</span><span class="token operator">:</span>
     <span class="token keyword">int</span> m_BaseData<span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>

 <span class="token keyword">class</span> <span class="token class-name">CDerived</span> <span class="token operator">:</span><span class="token keyword">public</span> CBase
 <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
     <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span>CDerived <span class="token operator">&amp;</span>vDerivedObj<span class="token punctuation">)</span>
     <span class="token punctuation">{</span>
         std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> vDerivedObj<span class="token punctuation">.</span>m_BaseData <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//正确，可以通过派生类对象访问其基类保护成员</span>
     <span class="token punctuation">}</span>

     <span class="token keyword">void</span> <span class="token function">print1</span><span class="token punctuation">(</span>CBase <span class="token operator">&amp;</span>vBaseObj<span class="token punctuation">)</span>
     <span class="token punctuation">{</span>
         std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> vBaseObj<span class="token punctuation">.</span>m_BaseData <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//错误，不可以通过基类对象来访问基类保护成员</span>
     <span class="token punctuation">}</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 其实原因很简单，如果print1是合法的，即在子类里可以通过基类对象访问基类的保护成员，那么我们就可以随意定义一个子类，来规避掉基类保护成员的保护特性了。这显然与保护属性的设计初衷不符。</p>
</li>
<li><p>派生访问说明符对派生类成员/友元访问基类的权限没有任何影响，它只控制派生类<strong>对象</strong>对于基类成员的访问权限：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">class</span> <span class="token class-name">CBase</span>
 <span class="token punctuation">{</span>
 <span class="token keyword">protected</span><span class="token operator">:</span>
     <span class="token keyword">int</span> m_BaseData<span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>

 <span class="token keyword">class</span> <span class="token class-name">CDerived</span> <span class="token operator">:</span><span class="token keyword">private</span> CBase
 <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
     <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
     <span class="token punctuation">{</span>
         std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> m_BaseData <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//合法</span>
     <span class="token punctuation">}</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 可以看到，即使派生访问说明符是private（即私有派生），也不影响子类成员对基类非私有成员的访问权限，它只影响派生类<strong>对象</strong>从外界访问基类成员的权限。<strong>其实受影响的不只是派生类对象，也包括派生类的派生类</strong>。</p>
</li>
<li><p>只有公有继承时，派生类对象指针才能转换成基类指针：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">class</span> <span class="token class-name">CBase</span>
 <span class="token punctuation">{</span>
 <span class="token keyword">protected</span><span class="token operator">:</span>
     <span class="token keyword">int</span> m_BaseData<span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>

 <span class="token keyword">class</span> <span class="token class-name">CDerived</span> <span class="token operator">:</span><span class="token keyword">protected</span> CBase
 <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
     <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
     <span class="token punctuation">{</span>
         std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> m_BaseData <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>

 CDerived DerivedObj<span class="token punctuation">;</span>
 CBase <span class="token operator">*</span>pBaseObj <span class="token operator">=</span> <span class="token operator">&amp;</span>DerivedObj<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//错误，只有公有继承时，子类指针才能转换为基类指针</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>就像友元关系不能传递一样，友元关系同样也不能继承。即父亲的朋友不一定是儿子的朋友，反之亦然。</li>
<li><p>我们可以使用using声明来改变派生类中继承自基类的成员的访问权限：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">class</span> <span class="token class-name">CBase</span>
 <span class="token punctuation">{</span>
 <span class="token keyword">protected</span><span class="token operator">:</span>
     <span class="token keyword">int</span> m_BaseData <span class="token operator">=</span> <span class="token number">41</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>

 <span class="token keyword">class</span> <span class="token class-name">CDerived</span> <span class="token operator">:</span><span class="token keyword">private</span> CBase
 <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
     <span class="token keyword">using</span> CBase<span class="token operator">::</span>m_BaseData<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//将继承自基类的m_BaseData的访问权限从private改变为public</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>

 CDerived DerivedObj<span class="token punctuation">;</span>
 <span class="token comment" spellcheck="true">//由于在子类中将继承成员m_BaseData的访问权限改成了public，所以可以直接使用子类对象访问该成员</span>
 std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> DerivedObj<span class="token punctuation">.</span>m_BaseData <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 值得注意的是，派生类只能为那些它可以访问的名字提供using声明。如果上面的程序，在CBase里，m_BaseData 本身就是private的，那么子类因为访问不到它，所以就无法改变它的访问权限。</p>
</li>
<li>人们常常有一种错觉，认为在使用关键字struct和class定义的类之间还有更深层次的差别。事实上，唯一的差别就是默认成员访问说明符及默认派生访问说明符，除此之外，再无其他不同之处。</li>
</ol>
<p><font size="5" color="orange">继承中的类作用域</font></p>
<hr>
<ol>
<li><p>编译器查找函数时，名字查找先于类型检查。和其他作用域一样，如果派生类的成员与基类的某个成员同名，则派生类将在其作用域内隐藏该基类成员。即使派生类成员和基类成员的形参列表不一致，基类成员也仍然会被隐藏掉：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">class</span> <span class="token class-name">CBase</span>
 <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
     <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
     <span class="token punctuation">{</span>
         std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"CBase"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>

 <span class="token keyword">class</span> <span class="token class-name">CDerived</span> <span class="token operator">:</span><span class="token keyword">public</span> CBase
 <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
     <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">int</span> vI<span class="token punctuation">)</span>
     <span class="token punctuation">{</span>
         std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"CDerived"</span> <span class="token operator">&lt;&lt;</span> vI <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>

 CDerived DerivedObj<span class="token punctuation">;</span>
 DerivedObj<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//正确，调用派生类的print成员函数</span>
 DerivedObj<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//错误，因为名字相同而屏蔽掉了基类的print成员函数，即使参数类型不同</span>
 DerivedObj<span class="token punctuation">.</span>CBase<span class="token operator">::</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//正确，通过作用域符强行调用基类的print成员</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 因为编译器的名字查找优先于类型检查，当通过子类对象在子类中找到名为print的函数以后就不再查找了，这个时候不检查函数类型是否满足，直到编译的时候才发现类型并不满足，然后报错。</p>
</li>
</ol>
<p><font size="5" color="orange">构造函数与拷贝控制</font></p>
<hr>
<ol>
<li>基类通常应该定义一个虚析构函数，这样我们就能动态析构继承体系中的对象了。</li>
<li>如果基类的析构函数不是虚函数，则delete一个指向派生类对象的基类指针将可能产生未定义的行为。</li>
<li>虚析构函数将阻止合成移动操作。如果一个类定义了析构函数，即使它通过=default的形式使用了合成的版本，编译器也不会为这个类合成移动操作。</li>
<li>如果基类缺少拷贝控制成员（也就是说基类中该拷贝控制成员是删除的或不可被子类访问的），它会阻止其子类合成对应的拷贝控制成员（删除的）。比如基类缺少移动操作会阻止派生类拥有自己的合成移动操作。</li>
<li><p>拷贝移动时，应该带上基类成员一起（子类显式地执行基类的拷贝移动操作）；而析构时不需要带上基类成员，因为基类的析构函数会被自动调用。</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">class</span> <span class="token class-name">CBase</span>
 <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
     <span class="token function">CBase</span><span class="token punctuation">(</span><span class="token keyword">const</span> CBase <span class="token operator">&amp;</span>vBase<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
     <span class="token function">CBase</span><span class="token punctuation">(</span>CBase <span class="token operator">&amp;&amp;</span>vBase<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
     <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">CBase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>

 <span class="token keyword">class</span> <span class="token class-name">CDerived</span> <span class="token operator">:</span><span class="token keyword">public</span> CBase
 <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
     <span class="token function">CDerived</span><span class="token punctuation">(</span><span class="token keyword">const</span> CDerived <span class="token operator">&amp;</span>vDerived<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">CBase</span><span class="token punctuation">(</span>vDerived<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//带上基类一起拷贝</span>
     <span class="token function">CDerived</span><span class="token punctuation">(</span>CDerived <span class="token operator">&amp;&amp;</span>vDerived<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">CBase</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>vDerived<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//带上基类一起移动</span>
     <span class="token operator">~</span><span class="token function">CDerived</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//不需要带上基类</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 在CDerived的拷贝构造函数中，对象vDerived被绑定到基类构造函数的CBase&amp;形参上，CBase的拷贝构造函数负责将vDerived的基类部分拷贝给要创建的对象。</p>
</li>
<li>如果构造函数或析构函数调用了某个虚函数，则我们应该执行与构造函数或析构函数所属类型相对应的虚函数版本。因为调用基类的构造函数时，子类的虚函数还是未完成状态，在调用基类的析构函数时，子类的虚函数已经被销毁。</li>
<li><p>类不能继承默认构造函数、拷贝构造函数和移动构造函数。我们可以使用using声明来显式继承基类的构造函数（不是太理解这个继承说的什么意思，因为在子类中确实可以调用基类的构造函数）：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">class</span> <span class="token class-name">CBase</span>
 <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
     <span class="token function">CBase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"CBase Copy Constructor"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
     <span class="token function">CBase</span><span class="token punctuation">(</span><span class="token keyword">const</span> CBase <span class="token operator">&amp;</span>vBase<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
     <span class="token function">CBase</span><span class="token punctuation">(</span>CBase <span class="token operator">&amp;&amp;</span>vBase<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
     <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">CBase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>

 <span class="token keyword">class</span> <span class="token class-name">CDerived</span> <span class="token operator">:</span><span class="token keyword">public</span> CBase
 <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
     <span class="token keyword">using</span> CBase<span class="token operator">::</span>CBase<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//继承CBase里的所有构造函数</span>

     <span class="token function">CDerived</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
     <span class="token function">CDerived</span><span class="token punctuation">(</span><span class="token keyword">const</span> CDerived <span class="token operator">&amp;</span>vDerived<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">CBase</span><span class="token punctuation">(</span>vDerived<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
     <span class="token function">CDerived</span><span class="token punctuation">(</span>CDerived <span class="token operator">&amp;&amp;</span>vDerived<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">CBase</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>vDerived<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
     <span class="token operator">~</span><span class="token function">CDerived</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>和普通成员的using声明不同，一个构造函数的using声明不会改变该构造函数的访问级别。</li>
<li>使用using声明来显式继承基类构造函数时：当一个基类构造函数含有默认实参时，这些实参并不会被继承，相反，派生类将获得多个继承的构造函数，其中每个构造函数分别省略掉一个含有默认实参的形参。</li>
</ol>
<p><font size="5" color="orange">容器与继承</font></p>
<ol>
<li>当派生类对象被赋值给基类对象时，其中的派生类部分将被“切掉”，因此容器和存在继承关系的类型无法兼容</li>
</ol>
<p><font size="5" color="orange">文本查询程序再探</font></p>
<hr>
<p>好吧，等有时间可以挥霍了再来写这一部分了。。。<br>&nbsp; </p>
<hr>
<p>参考文献：《C++Primer第五版》</p>

            </div>

            <!-- Post Comments -->
            
    <!-- 使用 DISQUS_CLICK -->
<div id="disqus-comment">
    <div id="disqus_thread"></div>

<!-- add animation -->
<style>
	.disqus_click_btn {
            line-height: 30px;
            margin: 0;
            min-width: 50px;
            padding: 0 14px;
            display: inline-block;
            font-family: "Roboto", "Helvetica", "Arial", sans-serif;
            font-size: 14px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0;
            overflow: hidden;
            will-change: box-shadow;
            transition: box-shadow .2s cubic-bezier(.4, 0, 1, 1), background-color .2s cubic-bezier(.4, 0, .2, 1), color .2s cubic-bezier(.4, 0, .2, 1);
            outline: 0;
            cursor: pointer;
            text-decoration: none;
            text-align: center;
            vertical-align: middle;
            border: 0;
            background: rgba(158, 158, 158, .2);
            box-shadow: 0 2px 2px 0 rgba(0, 0, 0, .14), 0 3px 1px -2px rgba(0, 0, 0, .2), 0 1px 5px 0 rgba(0, 0, 0, .12);
            color: #fff;
            background-color: #7EC0EE;
            text-shadow: 0
        }
</style>
	
<div class="btn_click_load" id="disqus_bt"> 
    <button class="disqus_click_btn">点击查看评论</button>
</div>

<!--
<script type="text/javascript">
$('.btn_click_load').click(function() {
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'http-miccall-tech'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    document.getElementById('disqus_bt').style.display = "none";
});
</script>
-->
<script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://yoursite.com/2018/04/01/C++Primer第十五章面向对象程序设计/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = 'http://yoursite.com/2018/04/01/C++Primer第十五章面向对象程序设计/'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
</script>

<script type="text/javascript">
    $('.btn_click_load').click(function() {  //click to load comments
        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document;
            var s = d.createElement('script');
            s.src = '//http-miccall-tech.disqus.com/embed.js';
            s.setAttribute('data-timestamp', + new Date());
            (d.head || d.body).appendChild(s);
        })();
        $('.btn_click_load').css('display','none');
    });
</script>
</div>
<style>
    #disqus-comment{
        background-color: #eee;
        padding: 2pc;
    }
</style>


        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
                <li>Design: <a href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
            </ul>
            
            	<span id="busuanzi_container_site_pv">2019总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			
        </div>
    </div>
</body>



 	
</html>
