<!DOCTYPE HTML>
<html>

<head>
	<link rel="bookmark"  type="image/x-icon"  href="/img/logo_miccall.png"/>
	 <link rel="shortcut icon" href="/img/logo_miccall.png">
	
			
    <title>
    Elays'Blog
    </title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="/css/mic_main.css" />
    <link rel="stylesheet" href="/css/dropdownMenu.css" />
    
    	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css" />
    </noscript>

			    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<link rel="stylesheet" href="/css/prism-dark.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>
    
		
<!-- Layouts -->


<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<!--<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">-->
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/latest.js?config=TeX-MML-AM_CHTML" async>
</script>

<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_undefined.css" />
<link rel="stylesheet" href="/css/typo.css" />
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">MICCALL</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special" >
            <ul class="menu links" >
			<!-- Homepage  主页  --> 
			<li >
	            <a href="/" rel="nofollow">主页</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">分类</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="/categories/Boost/">Boost</a></li><li><a class="category-link" href="/categories/C-语法/">C#语法</a></li><li><a class="category-link" href="/categories/C/">C++</a></li><li><a class="category-link" href="/categories/C语言/">C语言</a></li><li><a class="category-link" href="/categories/OpenGL/">OpenGL</a></li><li><a class="category-link" href="/categories/c/">c++</a></li><li><a class="category-link" href="/categories/全局光照/">全局光照</a></li><li><a class="category-link" href="/categories/博客配置/">博客配置</a></li><li><a class="category-link" href="/categories/并行计算/">并行计算</a></li><li><a class="category-link" href="/categories/操作系统/">操作系统</a></li><li><a class="category-link" href="/categories/数据结构/">数据结构</a></li><li><a class="category-link" href="/categories/毕设/">毕设</a></li><li><a class="category-link" href="/categories/游戏开发/">游戏开发</a></li><li><a class="category-link" href="/categories/游戏设计模式/">游戏设计模式</a></li><li><a class="category-link" href="/categories/计算机图形学/">计算机图形学</a></li><li><a class="category-link" href="/categories/计算机系统/">计算机系统</a></li><li><a class="category-link" href="/categories/设计模式/">设计模式</a></li><li><a class="category-link" href="/categories/调试错误集锦/">调试错误集锦</a>
	                    </ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/gallery/" title="图库">
		                图库
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
		            
		                <li><a href="https://github.com/miccall" class="icon fa-github"><span class="label">GitHub</span></a></li>
		            
		            
		            
		            
			</ul>
</nav>

        <div id="main" >
            <div class ="post_page_title_img" style="height: 25rem;background-image: url(http://oqcvzqam1.bkt.clouddn.com/C++Primer%E7%AC%AC17%E7%AB%A0.jpg);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;" >
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2 >C++Primer第十七章 标准库特殊设施</h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
				<div id="toc" class="toc-article">
					<strong class="toc-title">文章目录</strong>
					
				</div>
                <p><font size="5" color="orange">tuple类型</font></p>
<hr>
<ol>
<li><p>tuple是类似pair的模板，一个tuple可以有任意数量的成员。当我们希望将一些数据组合成单一对象，但又不想麻烦地定义一个新数据结构来表示这些数据时，tuple是非常有用的。下表列出了一些重要的tuple操作，它们都定义在tuple头文件中：<br>tuple操作 | 描述<br>:-: | : -:<br>tuple<t1,t2,...,tn> t; | 定义一个tuple，有n个成员，第i个成员的类型是Ti，所有成员都进行值初始化<br>tuple<t1,t2,...,tn> t(v1,v2,…,vn)| 定义一个tuple，每个成员用对应的vi进行初始化。此构造函数是explicit的，即参数无法进行隐式转换<br>make_tuple<v1,v2,...,vn> | 返回一个用给定值初始化的tuple。tuple的类型从初始值的类型推断。<br>get<i>(t) | 返回t的第i个数据成员的引用。如果t是一个左值，则返回的结果是一个左值引用；如果t是一个右值，则返回的结果是一个右值引用。tuple的所有成员都是public的。<br>tuple_size<tupletype>::value | 返回给定tuple类型tupleType中包含的成员的数量。注意tupleType是一个类型而非变量，所以通常要配合decltype使用。<br>tuple_element<i, tupletype="">::type | 返回给定tuple类型中第i个成员的类型。</i,></tupletype></i></v1,v2,...,vn></t1,t2,...,tn></t1,t2,...,tn></p>
</li>
<li><p>和上表tuple操作对应的程序如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>tuple<span class="token operator">&lt;</span>size_t<span class="token punctuation">,</span> size_t<span class="token punctuation">,</span> size_t<span class="token operator">></span> t0<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//正确，3个成员都值初始化</span>
 std<span class="token operator">::</span>tuple<span class="token operator">&lt;</span>size_t<span class="token punctuation">,</span> size_t<span class="token punctuation">,</span> size_t<span class="token operator">></span> t1<span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//正确</span>
 std<span class="token operator">::</span>tuple<span class="token operator">&lt;</span>size_t<span class="token punctuation">,</span> size_t<span class="token punctuation">,</span> size_t<span class="token operator">></span> t2 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//VS下实验正确</span>
 <span class="token keyword">auto</span> t3 <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">make_tuple</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//正确</span>
 <span class="token keyword">auto</span> a1 <span class="token operator">=</span> std<span class="token operator">::</span>get<span class="token operator">&lt;</span><span class="token number">1</span><span class="token operator">></span><span class="token punctuation">(</span>t1<span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token comment" spellcheck="true">//正确，通过get来访问t1中第1个成员的引用，a1 = 2</span>

 size_t sz <span class="token operator">=</span> std<span class="token operator">::</span>tuple_size<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>t3<span class="token punctuation">)</span><span class="token operator">></span><span class="token operator">::</span>value<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//正确，返回t3中的成员数量，sz = 3</span>
 <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;</span> sz<span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
     std<span class="token operator">::</span>tuple_element<span class="token operator">&lt;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>t3<span class="token punctuation">)</span><span class="token operator">></span><span class="token operator">::</span>type a3 <span class="token operator">=</span> std<span class="token operator">::</span>get<span class="token operator">&lt;</span><span class="token number">1</span><span class="token operator">></span><span class="token punctuation">(</span>t3<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//正确，用type返回t3中第1个成员的类型，a3的类型是size_t，a3 = 2</span>
 <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>只有两个tuple具有相同数量的成员，而且成员之间可以隐式转换时，我们才可以比较它们：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>tuple<span class="token operator">&lt;</span>size_t<span class="token punctuation">,</span> size_t<span class="token operator">></span> t1<span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
 std<span class="token operator">::</span>tuple<span class="token operator">&lt;</span>size_t<span class="token punctuation">,</span> size_t<span class="token punctuation">,</span> size_t<span class="token operator">></span> t2<span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
 std<span class="token operator">::</span>tuple<span class="token operator">&lt;</span>size_t<span class="token punctuation">,</span> std<span class="token operator">::</span>string<span class="token operator">></span> t3<span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token string">"girl"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
 std<span class="token operator">::</span>tuple<span class="token operator">&lt;</span>size_t<span class="token punctuation">,</span> std<span class="token operator">::</span>string<span class="token operator">></span> t4<span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token string">"boy"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
 <span class="token keyword">bool</span> b1 <span class="token operator">=</span> <span class="token punctuation">(</span>t1 <span class="token operator">==</span> t2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//错误，t1和t2成员数量不同，不能比较</span>
 <span class="token keyword">bool</span> b2 <span class="token operator">=</span> <span class="token punctuation">(</span>t1 <span class="token operator">==</span> t3<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//错误，t1的size_t类型成员和t3的string类型成员无法进行比较</span>
 <span class="token keyword">bool</span> b3 <span class="token operator">=</span> <span class="token punctuation">(</span>t3 <span class="token operator">==</span> t4<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//正确，t3和t4成员类型和数量都完全相同</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>由于tuple定义了&lt;和==运算符，所以我们可以将tuple序列传递给算法，并且可以在无序容器中将tuple作为关键字类型。</li>
<li>tuple的一个常见用途是从一个函数返回多个值。</li>
</ol>
<p><font size="5" color="orange">bitset类型</font></p>
<hr>
<ol>
<li>除了第四章中说到的位运算符以外，标准库还定义了bitset类，使得位运算的使用更为容易，并且能够处理超过最长整型类型大小的位集合。bitset类定义在头文件bitset中。</li>
<li>bitset类是一个模板类，它类似array类，具有固定的大小。当我们定义一个bitset时，需要声明它包含多少个二进制位：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>bitset<span class="token operator">&lt;</span><span class="token number">32</span><span class="token operator">></span> <span class="token function">Bitvec</span><span class="token punctuation">(</span><span class="token number">1U</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//32位，最低位为1，其他位为0</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
 指定的固定大小必须是一个常量表达式。</li>
<li>当我们使用一个整型值来初始化bitset时，此值将被转换为unsigned long long类型并被当做位模式来处理。如果常量整型值位数比定义的bitset位数少，则赋值之后不足的高位被置0；如果常量整型值位数比定义的bitset位数多，则多余的高位被丢弃。</li>
<li>我们也可以直接使用string或者字符数组来初始化bitset：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>bitset<span class="token operator">&lt;</span><span class="token number">4</span><span class="token operator">></span> <span class="token function">Bitvec2</span><span class="token punctuation">(</span><span class="token string">"1011"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//Bitvec2[0]到Bitvec2[3]分别是1、1、0、1（注意并不是顺序赋值）</span>
 std<span class="token operator">::</span>string str <span class="token operator">=</span> <span class="token string">"1101001110011"</span><span class="token punctuation">;</span>
 std<span class="token operator">::</span>bitset<span class="token operator">&lt;</span><span class="token number">32</span><span class="token operator">></span> <span class="token function">Bitvec3</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//从str[6]开始的4个二进制位：1110（0被赋值给Bitvec3[0]）其余高位被置0</span>
 std<span class="token operator">::</span>bitset<span class="token operator">&lt;</span><span class="token number">32</span><span class="token operator">></span> <span class="token function">Bitvec4</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> str<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//使用最后5个字符</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
 值得注意的是在字符串中的二进制字符也被认为是有高低位的，最右边的字符是最低位，初始化时被赋给bitset[0]。</li>
<li>bitset还有一系列成员函数用于设置或查询某些位是0或者1，具体可参考《C++Primer第五版》P643页，其中的置位是变成1的意思，复位是变成0的意思。</li>
<li>我们也可以使用IO运算符来直接读写bitset：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>bitset<span class="token operator">&lt;</span><span class="token number">16</span><span class="token operator">></span> Bits<span class="token punctuation">;</span>
 std<span class="token operator">::</span>cin <span class="token operator">>></span> Bits<span class="token punctuation">;</span>
 std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> Bits <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
 当输入的01个数达到16，或者遇到输入的不是1或者0时，读取过程会停止。比如输入下面第一行的01字符，将得到第二行的输出：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token number">111110000011</span>
 <span class="token number">0000111110000011</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
 其实在输入过程中，C++创建了一个临时的string对象来保存输入的字符，一旦输入结束，就立即用临时的string对象来初始化bitset。</li>
<li>通常使用bitset类来代替位运算符，会更简单直白。</li>
</ol>
<p><font size="5" color="orange">正则表达式</font></p>
<hr>
<ol>
<li>C++正则表达式库（RE库）是新标准的一部分，它定义在头文件regex中，它包含如下表所示的多个组件：</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">组件</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">regex</td>
<td>正则表达式类，会包含一个正则表达式字符串</td>
</tr>
<tr>
<td style="text-align:center">regex_match</td>
<td>函数，确定一个字符序列与一个正则表达式是否匹配</td>
</tr>
<tr>
<td style="text-align:center">regex_search</td>
<td>函数，寻找第一个与正则表达式匹配的子序列</td>
</tr>
<tr>
<td style="text-align:center">sregex_iterator</td>
<td>迭代器适配器，调用regex_search来遍历一个string中所有匹配的子串</td>
</tr>
<tr>
<td style="text-align:center">smatch</td>
<td>容器类，用于保存搜索结果（保存在内部的string中）</td>
</tr>
<tr>
<td style="text-align:center">ssub_match</td>
<td>string中匹配的子表达式的结果</td>
</tr>
</tbody>
</table>
<ol>
<li>如果输入序列与regex匹配，则regex_match函数返回true；如果输入序列中一个子串与regex匹配，则regex_search函数返回true。如果匹配成功，成功匹配的信息会被保存在smatch对象中。</li>
<li>比如我们可以用正则表达式来判断一条众所周知的英文单词拼写规则：字符i和e连在一起时，i如果不在c之后，则必须在e之前（也就是说如果前面没有c，则只能是ie而不能是ei）。<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>string <span class="token function">Pattern</span><span class="token punctuation">(</span><span class="token string">"[^c]ei"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token comment" spellcheck="true">//查找不在字符c之后的字符串ei</span>
 Pattern <span class="token operator">=</span> <span class="token string">"[[:alpha:]]*"</span> <span class="token operator">+</span> Pattern <span class="token operator">+</span> <span class="token string">"[[:alpha:]]*"</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//我们需要包含Pattern的整个单词</span>
 std<span class="token operator">::</span>regex <span class="token function">RegexObj</span><span class="token punctuation">(</span>Pattern<span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token comment" spellcheck="true">//构建一个用正则表达式字符串Pattern来查找匹配的regex</span>
 std<span class="token operator">::</span>smatch Results<span class="token punctuation">;</span>                                    <span class="token comment" spellcheck="true">//定义一个对象保存搜索结果</span>
 std<span class="token operator">::</span>string TestStr <span class="token operator">=</span> <span class="token string">"receipt freind theif receive"</span><span class="token punctuation">;</span>    
 <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">regex_search</span><span class="token punctuation">(</span>TestStr<span class="token punctuation">,</span> Results<span class="token punctuation">,</span> RegexObj<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">//如果有匹配子串</span>
     std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> Results<span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//打印第一个匹配的单词</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
 程序输出如下：<pre class="line-numbers language-cpp"><code class="language-cpp"> freind
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
 我们首先定义了一个string来保存希望查找的正则表达式。正则表达式[^c]表明我们希望匹配任意不是’c’的字符，而[^c]ei指出我们想要匹配这种字符后接ei的字符串。模式[[:alpha:]]匹配任意字母，符号+和*分别表示我们希望“一个或多个”或“零个或多个”匹配。因此[[:alpha:]]*将匹配零个或多个任意字母。</li>
<li>默认情况下，regex使用的正则表达式语言是ECMAScript。</li>
<li>在定义regex时，我们还可以提供一些选项，比如regex::icase就表示在匹配过程中忽略大小写。具体有哪些选项可参看《C++Primer第五版》P647页。</li>
<li>我们可以将一个C++程序保存在.cc结尾的文件中，也可以保存在.Cc、.cC或是.CC结尾的文件中，效果是一样的。我们可以编写一个正则表达式来识别上述任何一种扩展名：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token comment" spellcheck="true">//一个或多个字母或数字字符后接一个'.'再接"cpp"或"cxx"或"cc"</span>
 std<span class="token operator">::</span>regex <span class="token function">RegexObj</span><span class="token punctuation">(</span><span class="token string">"[[:alnum:]]+\\.(cpp|cxx|cc)$"</span><span class="token punctuation">,</span> std<span class="token operator">::</span>regex<span class="token operator">::</span>icase<span class="token punctuation">)</span><span class="token punctuation">;</span>
 std<span class="token operator">::</span>smatch Results<span class="token punctuation">;</span>
 std<span class="token operator">::</span>string FileName<span class="token punctuation">;</span>
 <span class="token keyword">while</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>cin <span class="token operator">>></span> FileName<span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">regex_search</span><span class="token punctuation">(</span>FileName<span class="token punctuation">,</span> Results<span class="token punctuation">,</span> RegexObj<span class="token punctuation">)</span><span class="token punctuation">)</span>
         std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> Results<span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
 为了表示与句点字符‘.’匹配的正则表达式，必须写成\.（第一个反斜线去掉C++语言中反斜线的特殊含义，即，正则表达式字符串为.，第二个反斜线则表示在正则表达式中去掉.的特殊含义）。</li>
<li>正则表达式不是由C++编译器解释的，它是在运行时，当一个regex对象被初始化或被赋予一个新模式时，才被“编译”的。如果我们编写的正则表达式存在错误，则在运行时标准库会抛出一个类型为regex_error的异常。类似标准异常类型，regex_error也有一个what成员函数来描述发生了什么错误；它还有一个code成员函数，用来返回某个错误类型对应的数值编码（code返回的值是由具体实现定义的）。<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">try</span>
 <span class="token punctuation">{</span>
     <span class="token comment" spellcheck="true">//错误，alnum漏掉了右括号，构造函数会抛出异常</span>
     std<span class="token operator">::</span>regex <span class="token function">RegexObj</span><span class="token punctuation">(</span><span class="token string">"[[:alnum:]+\\.(cpp|cxx|cc)$"</span><span class="token punctuation">,</span> std<span class="token operator">::</span>regex<span class="token operator">::</span>icase<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
 <span class="token keyword">catch</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>regex_error e<span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
     std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> e<span class="token punctuation">.</span><span class="token function">what</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\ncode: "</span> <span class="token operator">&lt;&lt;</span> e<span class="token punctuation">.</span><span class="token function">code</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
 程序输出如下：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token function">regex_error</span><span class="token punctuation">(</span>error_brack<span class="token punctuation">)</span><span class="token operator">:</span> The expression contained mismatched <span class="token punctuation">[</span> <span class="token operator">and</span> <span class="token punctuation">]</span><span class="token punctuation">.</span>
 code<span class="token operator">:</span> <span class="token number">4</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li>正则表达式的编译是一个非常慢的操作，特别是在使用了扩展的正则表达式语法或复杂的正则表达式时。因此，构造一个regex对象以及向一个已存在的regex赋予一个新的正则表达式可能是非常耗时的。为了最小化这种开销，应该努力避免创建很多不必要的regex。特别是，如果在一个循环中使用正则表达式，应该在循环外创建它，而不是在每步迭代时都编译它。</li>
<li>我们可以用smatch来把正则表达式匹配的结果存到string里，也可以用cmatch把结果存到数组序列里。<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>regex <span class="token function">RegexObj</span><span class="token punctuation">(</span><span class="token string">"[[:alnum:]]+\\.(cpp|cxx|cc)$"</span><span class="token punctuation">,</span> std<span class="token operator">::</span>regex<span class="token operator">::</span>icase<span class="token punctuation">)</span><span class="token punctuation">;</span>
 std<span class="token operator">::</span>smatch Results<span class="token punctuation">;</span>
 <span class="token keyword">if</span> <span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">regex_search</span><span class="token punctuation">(</span><span class="token string">"myfile.cc"</span><span class="token punctuation">,</span> Results<span class="token punctuation">,</span> RegexObj<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//错误，输入的字符串是char*类型的，不能用smatch来保存</span>
     std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> Results<span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
 因为输入的待搜索字符串是char*类型的，所以不能用smatch来存储匹配结果，应该使用cmatch，或者把输入字符串变为string类型：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>regex <span class="token function">RegexObj</span><span class="token punctuation">(</span><span class="token string">"[[:alnum:]]+\\.(cpp|cxx|cc)$"</span><span class="token punctuation">,</span> std<span class="token operator">::</span>regex<span class="token operator">::</span>icase<span class="token punctuation">)</span><span class="token punctuation">;</span>
 std<span class="token operator">::</span>cmatch Results<span class="token punctuation">;</span>
 <span class="token keyword">if</span> <span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">regex_search</span><span class="token punctuation">(</span><span class="token string">"myfile.cc"</span><span class="token punctuation">,</span> Results<span class="token punctuation">,</span> RegexObj<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//正确，可以用cmatch来保存char*类型的匹配结果</span>
     std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> Results<span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>regex <span class="token function">RegexObj</span><span class="token punctuation">(</span><span class="token string">"[[:alnum:]]+\\.(cpp|cxx|cc)$"</span><span class="token punctuation">,</span> std<span class="token operator">::</span>regex<span class="token operator">::</span>icase<span class="token punctuation">)</span><span class="token punctuation">;</span>
 std<span class="token operator">::</span>smatch Results<span class="token punctuation">;</span>
 std<span class="token operator">::</span>string Str <span class="token operator">=</span> <span class="token string">"myfile.cc"</span><span class="token punctuation">;</span>
 <span class="token keyword">if</span> <span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">regex_search</span><span class="token punctuation">(</span>Str<span class="token punctuation">,</span> Results<span class="token punctuation">,</span> RegexObj<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//正确，可以用smatch来保存string类型的匹配结果</span>
     std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> Results<span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>之前查找违反“如果前面没有c，则只能是ie而不能是ei”规则（后面简称ie规则）的单词的程序，只能找到输入序列里第一个匹配的单词。我们可以使用sregex_iterator来获得所有匹配。regex迭代器是一种迭代器适配器，被绑定到一个输入序列和一个regex对象上。sregex_iterator对应的操作如下表：</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">操作</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">sregex_iterator it(b, e, r);</td>
<td>定义一个迭代器it，它绑定到迭代器b和e表示的字符串上以及regex对象r上，定义时会自动调用regex_search，定位到给定string中的第一个匹配位置</td>
</tr>
<tr>
<td style="text-align:center">sregex_iterator end;</td>
<td>定义一个尾后迭代器</td>
</tr>
<tr>
<td style="text-align:center">*it或者it-&gt;</td>
<td>根据最后一次调用regex_search的结果，返回一个smatch对象的引用或一个指向smatch对象的指针</td>
</tr>
</tbody>
</table>
<p>++it或者it++ | 从输入序列当前匹配位置开始调用regex_search。前置版本返回递增后迭代器，后置版本返回旧值。<br>it1==it2 | 如果两个sregex_iterator都是一样尾后迭代器，则它们相当；否则，如果它们是从相同的输入序列和regex对象构造，则它们相当</p>
<ol>
<li>当我们将一个sregex_iterator绑定到一个string和一个regex对象时，迭代器自动定位到给定string中第一个匹配位置。即，sregex_iterator的构造函数会对给定的string和regex调用regex_search。当我们解引用迭代器时，会得到一个对应最近一次搜索结果的smatch对象。当我们递增迭代器时，它调用regex_search在输入string中查找下一个匹配。</li>
<li>用sregex_iterator来查找输入序列中所有不符合ie规则的单词：<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>string <span class="token function">Pattern</span><span class="token punctuation">(</span><span class="token string">"[^c]ei"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                          <span class="token comment" spellcheck="true">//查找不在字符c之后的字符串ei</span>
Pattern <span class="token operator">=</span> <span class="token string">"[[:alpha:]]*"</span> <span class="token operator">+</span> Pattern <span class="token operator">+</span> <span class="token string">"[[:alpha:]]*"</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//我们需要包含Pattern的整个单词</span>
std<span class="token operator">::</span>regex <span class="token function">RegexObj</span><span class="token punctuation">(</span>Pattern<span class="token punctuation">,</span>std<span class="token operator">::</span>regex<span class="token operator">::</span>icase<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//构建一个用正则表达式字符串Pattern来查找匹配的regex，并且匹配时忽略大小写</span>
std<span class="token operator">::</span>string TestStr <span class="token operator">=</span> <span class="token string">"receipt freind theif receive"</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>sregex_iterator <span class="token function">It</span><span class="token punctuation">(</span>TestStr<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> TestStr<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> RegexObj<span class="token punctuation">)</span><span class="token punctuation">,</span> EndIt<span class="token punctuation">;</span> It <span class="token operator">!=</span> EndIt<span class="token punctuation">;</span> <span class="token operator">++</span>It<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//++时会调用regex_search来查找下一个匹配</span>
<span class="token punctuation">{</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> It<span class="token operator">-</span><span class="token operator">></span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
程序输出如下：<pre class="line-numbers language-cpp"><code class="language-cpp">freind
theif
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
在for语句中定义了迭代器It和EndIt，EndIt是一个空sregex_iterator，起到尾后迭代器的作用。我们可以将此循环想象为不断从一个匹配位置跳到下一个匹配位置。</li>
<li><p>正则表达式中通常包含一个或多个子表达式。通常用括号表示一个子表达式。如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//RegexObj有两个子表达式：第一个是点之前表示文件名的部分，第二个表示文件扩展名</span>
std<span class="token operator">::</span>regex <span class="token function">RegexObj</span><span class="token punctuation">(</span><span class="token string">"([[:alnum:]]+)\\.(cpp|cxx|cc)$"</span><span class="token punctuation">,</span> std<span class="token operator">::</span>regex<span class="token operator">::</span>icase<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>匹配对象除了提供匹配整体的相关信息外，还提供访问正则表达式（模式）中每个子表达式的能力。子匹配是按照位置来访问的。第一个子匹配位置为0，表示与整个正则表达式对应的匹配，随后是每个子表达式对应的匹配。所以我们可以向下面的程序一样，输出每个子匹配的结果：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//RegexObj有两个子表达式：第一个是点之前表示文件名的部分，第二个表示文件扩展名</span>
std<span class="token operator">::</span>regex <span class="token function">RegexObj</span><span class="token punctuation">(</span><span class="token string">"([[:alnum:]]+)\\.(cpp|cxx|cc)$"</span><span class="token punctuation">,</span> std<span class="token operator">::</span>regex<span class="token operator">::</span>icase<span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token operator">::</span>string FileName <span class="token operator">=</span> <span class="token string">"TxtFile.txt CFile.cc"</span><span class="token punctuation">;</span>
std<span class="token operator">::</span>smatch Results<span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">regex_search</span><span class="token punctuation">(</span>FileName<span class="token punctuation">,</span> Results<span class="token punctuation">,</span> RegexObj<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> Results<span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//输出CFile.cc</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> Results<span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//输出CFile</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> Results<span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//输出cc</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Results.str(0)是在访问整个正则表达式匹配的结果，而Results.str(1)是在访问Results.str(0)中与第一个子表达式匹配的结果，Results.str(2)是在访问Results.str(0)中与第二个子表达式匹配的结果。</p>
<p>可以看到子表达式最大的作用在于，可以把完整正则表达式匹配的结果分开成好几部分。</p>
</li>
<li>当我们希望在输入序列中查找并替换一个正则表达式时，可以调用regex_replace函数。它类似regex_search函数，不同的是，它还接受一个用于描述我们想要的输出形式的字符串，而且没有smatch Results参数：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//RegexObj有两个子表达式：第一个是点之前表示文件名的部分，第二个表示文件扩展名</span>
std<span class="token operator">::</span>regex <span class="token function">RegexObj</span><span class="token punctuation">(</span><span class="token string">"([[:alnum:]]+)\\.(cpp|cxx|cc)$"</span><span class="token punctuation">,</span> std<span class="token operator">::</span>regex<span class="token operator">::</span>icase<span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token operator">::</span>string FileName <span class="token operator">=</span> <span class="token string">"TxtFile.txt CFile.cc"</span><span class="token punctuation">;</span>
std<span class="token operator">::</span>string Format <span class="token operator">=</span> <span class="token string">"$1-$2"</span><span class="token punctuation">;</span>                                               <span class="token comment" spellcheck="true">//把匹配的文件名改为类似a-cpp这种格式</span>
std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span><span class="token function">regex_replace</span><span class="token punctuation">(</span>FileName<span class="token punctuation">,</span> RegexObj<span class="token punctuation">,</span> Format<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//输出TxtFile.txt CFile-cc</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
其中我们用一个符号$后跟子表达式的索引号来表示一种特定的格式。</li>
</ol>
<p><font size="5" color="orange">随机数</font></p>
<hr>
<ol>
<li>在新标准出现之前，C和C++都依赖于一个简单的C库函数rand来生成随机数。此函数生成均匀分布的伪随机<strong>整数</strong>，每个随机数的范围在0和一个系统相关的最大值（至少为32767）之间。rand函数有一些问题：即使不是大多数，也有很多程序需要不同范围的随机数。一些应用需要随机浮点数。一些程序需要非均匀分布的数。而程序员为了解决这些问题而试图转换rand生成的随机数的范围、类型或分布时，常常会引入非随机性。</li>
<li>定义在头文件random中的随机数库通过一组协作的类来解决这些问题：随机数引擎类和随机数分布类。一个引擎类可以生成unsigned随机数序列，一个分布类使用一个引擎类生成指定类型的、在给定范围内的、服从特定概率分布的随机数。</li>
<li>C++程序不应该使用库函数rand，而应使用default_random_engine类和恰当的分布类对象。</li>
<li>随机数引擎是函数对象类，它们定义了一个调用运算符，该运算符不接受参数并返回一个随机unsigned整数。我们可以通过调用一个随机数引擎对象来生成原始随机数：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>default_random_engine e<span class="token punctuation">;</span>
 <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
     std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">e</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//e()调用对象e来生成下一个随机数</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
 在我的机子上，生成的结果如下：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token number">3499211612</span> <span class="token number">581869302</span> <span class="token number">3890346734</span> <span class="token number">3586334585</span> <span class="token number">545404204</span> <span class="token number">4161255391</span> <span class="token number">3922919429</span> <span class="token number">949333985</span> <span class="token number">2715962298</span> <span class="token number">1323567403</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
 我们首先定义了一个名为e的default_random_engine对象。在for循环内，我们调用对象e来获得下一个随机数。</li>
<li>随机数引擎具有下表的这些操作：</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">操作</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Engine e;</td>
<td>默认构造函数；使用该引擎类型默认的种子</td>
</tr>
<tr>
<td style="text-align:center">Engine e(s);</td>
<td>使用整型值s作为种子</td>
</tr>
<tr>
<td style="text-align:center">e.seed(s)</td>
<td>使用种子s重置引擎的状态</td>
</tr>
<tr>
<td style="text-align:center">e.min()，e.max()</td>
<td>此引擎可生成的最小值和最大值</td>
</tr>
<tr>
<td style="text-align:center">Engine::result_type</td>
<td>此引擎生成的unsigned整型类型</td>
</tr>
<tr>
<td style="text-align:center">e.discard(u)</td>
<td>将引擎推进u步；u的类型为unsigned unsigned long</td>
</tr>
</tbody>
</table>
<ol>
<li>对于大多数场合，随机数引擎的输出是要不能直接使用的，因为它生成的随机数的值返回和分布通常与我们需要的不符，正确转换随机数的范围和分布又极其困难。这也是我们之前将其叫为原始随机数的原因。这种时候，我们可以再结合分布类型对象来得到我们想要的随机数。比如下面的程序：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>uniform_int_distribution<span class="token operator">&lt;</span><span class="token keyword">unsigned</span><span class="token operator">></span> <span class="token function">u</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//定义0到9之间（包含）的均匀分布</span>
 std<span class="token operator">::</span>default_random_engine e<span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">//定义随机数引擎</span>
 <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
     std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">u</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">//将随机数引擎e作为分布对象的参数，每个调用会返回在指定范围内并服从均匀分布的值</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
 本机运行的结果如下：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token number">2</span> <span class="token number">2</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">4</span> <span class="token number">1</span> <span class="token number">9</span> <span class="token number">5</span> <span class="token number">8</span> <span class="token number">3</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
 上面的uniform_int_distribution就是一个分布类型。类似引擎类型，分布类型也是函数对象类。分布类型定义了一个调用运算符，它接受一个随机数引擎作为参数。分布对象使用它的引擎参数生成随机数，并将其映射到指定的分布。值得注意的是，我们传递给分布对象的是引擎对象本身，即u(e)，而不是u(e())。我们传递的是引擎本身，而不是它生成的下一个值，原因<br>是某些分布可能需要调用引擎多次才能得到一个值。</li>
<li>当我们说<strong>随机数发生器</strong>时，是指分布对象和引擎对象的组合。</li>
<li><p>先看如下程序：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">unsigned</span><span class="token operator">></span> <span class="token function">badRandVec</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
     std<span class="token operator">::</span>default_random_engine e<span class="token punctuation">;</span>
     std<span class="token operator">::</span>uniform_int_distribution<span class="token operator">&lt;</span><span class="token keyword">unsigned</span><span class="token operator">></span> <span class="token function">u</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">unsigned</span><span class="token operator">></span> Set<span class="token punctuation">;</span>
     <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
         Set<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token function">u</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token keyword">return</span> Set<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>

 std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">unsigned</span><span class="token operator">></span> v1 <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span><span class="token function">badRandVec</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">unsigned</span><span class="token operator">></span> v2 <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span><span class="token function">badRandVec</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>v1 <span class="token operator">==</span> v2<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token string">"equal"</span> <span class="token operator">:</span> <span class="token string">"not euqal"</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 程序总会输出equal，也就是说两次调用badRandVec函数生成的随机数序列都总是一样的。想要每次调用生成的随机数都不一样，需要将引擎对象和分布对象都定义为static的：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">unsigned</span><span class="token operator">></span> <span class="token function">badRandVec</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
     <span class="token keyword">static</span> std<span class="token operator">::</span>default_random_engine e<span class="token punctuation">;</span>
     <span class="token keyword">static</span> std<span class="token operator">::</span>uniform_int_distribution<span class="token operator">&lt;</span><span class="token keyword">unsigned</span><span class="token operator">></span> <span class="token function">u</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">unsigned</span><span class="token operator">></span> Set<span class="token punctuation">;</span>
     <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
         Set<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token function">u</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token keyword">return</span> Set<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 由于e和u是static的，因此它们在函数调用之间会保持住状态。第一次调用会使用u(e)生成的序列中的前100个随机数，第二次调用会获得接下来100个，以此类推。</p>
<p> 总结一下，一个给定的随机数发生器一直会生成相同的随机数序列。一个函数如果定义了局部的随机数发生器，应该将其（包括引擎和分布对象）定义为static的。否则，每次调用函数都会生成相同的序列。</p>
</li>
<li><p>当然，除了上面的方法，也可以通过给随机数引擎一个不同的种子，来让它生成不同的随机数序列。方法就是前面表中的第二行和第三行，可以在定义时或者使用seed成员函数来设置随机数种子。选择一个好的种子，与生成好的随机数所涉及的其他大多数事情相同，是极其困难的。可能最常用的方法是调用系统函数time（定义在头文件ctime中），它返回从一个特定时刻到当前经过了多少秒。函数time接受单个指针参数，它指向用于写入时间的数据结构。如果此指针为空，则函数简单地返回时间：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">static</span> std<span class="token operator">::</span>default_random_engine <span class="token function">e</span><span class="token punctuation">(</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//稍微随机些的种子</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p> 由于time返回以<strong>秒</strong>计的时间，因此这种方式只适用于生成种子的间隔为秒级或更长的应用。</p>
<p> 值得注意的是，如果程序作为一个自动过程的一部分反复适用，将time的返回值作为种子的方式就无效了，因为它可能多次使用的都是相同的种子。</p>
</li>
<li>程序有时候需要生成随机浮点数。新标准以前最常用的是用rand()的结果除以RAND_MAX。但这种方法不正确，因为随机整数的精度通常低于随机浮点数，这样，有一些浮点值就永远不会被生成了。使用新标准，我们可以定义一个uniform_real_distribution类型的分布对象，用这个分布对象来将随机整数映射到随机浮点数（说白了就是使用它来生成随机浮点数）：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">static</span> std<span class="token operator">::</span>default_random_engine e<span class="token punctuation">;</span>
<span class="token keyword">static</span> std<span class="token operator">::</span>uniform_real_distribution<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span> <span class="token function">u</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">u</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
本机运行结果如下：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token number">0.135477</span> <span class="token number">0.835009</span> <span class="token number">0.968868</span> <span class="token number">0.221034</span> <span class="token number">0.308167</span> <span class="token number">0.547221</span> <span class="token number">0.188382</span> <span class="token number">0.992881</span> <span class="token number">0.996461</span> <span class="token number">0.967695</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li>分布类型都是模板，具有单一的模板类型参数，表示分布生成的随机数的类型。这些分布类型要么生成浮点数类型，要么生成整数类型。每个分布模板都有都有一个默认实参，生成浮点值的分布类型默认生成double值，而生成整型值的分布默认生成int值：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">static</span> std<span class="token operator">::</span>uniform_real_distribution<span class="token operator">&lt;</span><span class="token operator">></span> <span class="token function">u</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//默认生成double值</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li>还有一些非均匀分布（新标准定义了20中分布类型，可以参考《C++Primer第五版》P781页），比如正态分布、伯努利分布等等。下面我们用正态分布来生成一些随机数：<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>default_random_engine e<span class="token punctuation">;</span>
std<span class="token operator">::</span>normal_distribution<span class="token operator">&lt;</span><span class="token operator">></span> <span class="token function">n</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">1.5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//均值为4，标准差为1.5</span>
std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">unsigned</span><span class="token operator">></span> <span class="token function">Values</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">!=</span> <span class="token number">200</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">//生成200次随机数</span>
<span class="token punctuation">{</span>
    <span class="token keyword">unsigned</span> v <span class="token operator">=</span> <span class="token function">lround</span><span class="token punctuation">(</span><span class="token function">n</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//舍入到最接近的整数</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>v <span class="token operator">&lt;</span> Values<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">//如果结果在范围内</span>
        <span class="token operator">++</span>Values<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//统计每个数出现了多少次</span>
<span class="token punctuation">}</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> Values<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">": "</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span><span class="token function">string</span><span class="token punctuation">(</span>Values<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">'*'</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
程序运行结果如下：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token number">0</span><span class="token operator">:</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span>
<span class="token number">1</span><span class="token operator">:</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span>
<span class="token number">2</span><span class="token operator">:</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span>
<span class="token number">3</span><span class="token operator">:</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span>
<span class="token number">4</span><span class="token operator">:</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span>
<span class="token number">5</span><span class="token operator">:</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span>
<span class="token number">6</span><span class="token operator">:</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span>
<span class="token number">7</span><span class="token operator">:</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span>
<span class="token number">8</span><span class="token operator">:</span> <span class="token operator">*</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
可以看到生成的200次随机数，确实是符合正态分布的（3,4,5的个数最多）。</li>
<li><p>有一个分布不接受模板参数，即bernoulli_distribution，因为它是一个普通类，而非模板。此分布总是返回一个bool值。它返回true的概率是一个常数，此概率的默认值是0.5。比如现在围棋中需要决定白棋先行还是黑棋先行，我们可以用一个值范围是0到1的uniform_int_distribution来选择先行的棋子，也可以直接用伯努利分布来完成这个选择：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>default_random_engine e<span class="token punctuation">;</span>
std<span class="token operator">::</span>bernoulli_distribution b<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//默认是50/50的机会</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">20</span><span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//std::default_random_engine e;</span>
    <span class="token comment" spellcheck="true">//std::bernoulli_distribution b;    //默认是50/50的机会</span>
    <span class="token keyword">bool</span> IsWhiteFirst <span class="token operator">=</span> <span class="token function">b</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>IsWhiteFirst <span class="token operator">?</span> <span class="token string">"白棋先行"</span> <span class="token operator">:</span> <span class="token string">"黑棋先行"</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>本机输出如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">白棋先行 黑棋先行 黑棋先行 白棋先行 白棋先行 黑棋先行 白棋先行 黑棋先行 黑棋先行 黑棋先行 黑棋先行 黑棋先行 白棋先行 黑 棋先行 白棋先行 白棋先行 白棋先行 黑棋先行 黑棋先行 黑棋先行
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>值得注意的是，引擎和分布对象都应该定义在循环外面，否则每次迭代都是重新生成对象，产生的随机数每次都会是一样的：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">20</span><span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token operator">::</span>default_random_engine e<span class="token punctuation">;</span>
    std<span class="token operator">::</span>bernoulli_distribution b<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//默认是50/50的机会</span>
    <span class="token keyword">bool</span> IsWhiteFirst <span class="token operator">=</span> <span class="token function">b</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>IsWhiteFirst <span class="token operator">?</span> <span class="token string">"白棋先行"</span> <span class="token operator">:</span> <span class="token string">"黑棋先行"</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>程序输出会如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">白棋先行 白棋先行 白棋先行 白棋先行 白棋先行 白棋先行 白棋先行 白棋先行 白棋先行 白棋先行 白棋先行 白棋先行 白棋先行 白 棋先行 白棋先行 白棋先行 白棋先行 白棋先行 白棋先行 白棋先行
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>可以看到引擎和分布对象在循环里时，每次迭代都是生成相同的随机值。</p>
<p>我们还可以调整先行一方的概率：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>bernoulli_distribution <span class="token function">b</span><span class="token punctuation">(</span><span class="token number">0.55</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//给白棋一个微小的优势</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
</ol>
<p><font size="5" color="orange">IO库再探</font></p>
<hr>
<ol>
<li>当操纵符改变流的格式状态时，通常改变后的状态对所有后续IO都生效。</li>
<li>通常最好在不需要特殊格式时尽快将流恢复到默认状态。</li>
<li>默认情况下，bool值打印1或0。我们可以通过对流使用boolalpha操纵符来覆盖这种格式：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"default bool values: "</span> <span class="token operator">&lt;&lt;</span> <span class="token boolean">true</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token operator">&lt;&lt;</span><span class="token boolean">false</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
 std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"alpha bool values: "</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>boolalpha <span class="token operator">&lt;&lt;</span> <span class="token boolean">true</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> <span class="token boolean">false</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
 程序输出如下：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">default</span> <span class="token keyword">bool</span> values<span class="token operator">:</span> <span class="token number">1</span> <span class="token number">0</span>
 alpha <span class="token keyword">bool</span> values<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token boolean">false</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
 一旦向cout写入了boolalpha，我们就改变了cout打印bool值的方式。后续打印bool值的操作都会打印true或false而非1或0。<br> 为了取消cout格式状态的改变，我们使用noboolalpha：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">bool</span> b <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
 std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>boolalpha <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>noboolalpha <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
 我们只对b应用了boolalpha，改变了它的输出方式，b输出完成后就用noboolalpha将其恢复到初始状态。</li>
<li><p>我们可以使用hex、oct和dec将默认的十进制输入输出改为十六进制、八进制或是改回十进制：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"default\t"</span> <span class="token operator">&lt;&lt;</span> <span class="token number">20</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1024</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//默认十进制</span>
 std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"octal\t"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>oct <span class="token operator">&lt;&lt;</span> <span class="token number">20</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1024</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//八进制</span>
 std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"hex\t"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>hex <span class="token operator">&lt;&lt;</span> <span class="token number">20</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1024</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//十六进制</span>
 std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"decimal\t"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>dec <span class="token operator">&lt;&lt;</span> <span class="token number">20</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1024</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//改回十进制</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p> 类似boolalpha，这些操纵符也会改变格式状态。它们会影响下一个和随后所有的整型输出，直至另一个操纵符又改变了格式为止。</p>
<p> 值得注意的是，操纵符hex、oct和dec只影响<strong>整型</strong>运算对象，浮点值的表示形式不受影响。</p>
</li>
<li><p>当对流应用showbase操纵符时，会在输出结果中显示进制，它遵循与整型常量中指定进制相同的规范：</p>
<ul>
<li>前导0x表示十六进制</li>
<li>前导0表示八进制</li>
<li><p>无前导字符串表示十进制</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>showbase<span class="token punctuation">;</span>                                                <span class="token comment" spellcheck="true">//打印整型值时显示进制</span>
std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"default\t"</span> <span class="token operator">&lt;&lt;</span> <span class="token number">20</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1024</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//默认十进制</span>
std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"octal\t"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>oct <span class="token operator">&lt;&lt;</span> <span class="token number">20</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1024</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//八进制</span>
std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"hex\t"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>hex <span class="token operator">&lt;&lt;</span> <span class="token number">20</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1024</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//十六进制</span>
std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"decimal\t"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>dec <span class="token operator">&lt;&lt;</span> <span class="token number">20</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1024</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//改回十进制</span>
std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>noshowbase<span class="token punctuation">;</span>                                            <span class="token comment" spellcheck="true">//恢复流状态</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>程序输出如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">default</span> <span class="token number">20</span> <span class="token number">1024</span>
octal   <span class="token number">024</span> <span class="token number">02000</span>
hex     <span class="token number">0x14</span> <span class="token number">0x400</span>
decimal <span class="token number">20</span> <span class="token number">1024</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
</li>
<li>默认情况下，十六进制会以小写打印，前导字符也是小写的x。我们可以使用uppercase操纵符来输出大写的X并将十六进制数字a到f以大写输出：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>uppercase <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>showbase <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>hex <span class="token operator">&lt;&lt;</span> <span class="token number">20</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1999</span><span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>nouppercase <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>noshowbase <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>dec <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
 输出如下：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token number">0X14</span> <span class="token number">0X7CF</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>我们可以控制浮点数输出三种格式：</p>
<ul>
<li>以多高精度（多少个数字）打印浮点值</li>
<li>数值是打印为十六进制、定点十进制还是科学记数法形式</li>
<li><p>对于没有小数部分的浮点值是否打印小数点</p>
<p>默认情况下，浮点值按六位数字精度打印；如果浮点值没有小数部分，则不打印小数点；根据浮点数的值选择打印成定点十进制或科学记数法形式。</p>
<p>默认情况下，精度会控制打印的数字的<strong>总数</strong>。当打印时，浮点值按当前精度舎入而非截断。我们可以通过调用IO对象的precision成员或使用setprecision操纵符来改变精度（接受参数的操纵符都定义在头文件iomanip中，如setprecision）：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Precision: "</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>cout<span class="token punctuation">.</span><span class="token function">precision</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">", value: "</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span><span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token number">2.0</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//输出当前精度以及当前精度下根号2的值</span>
std<span class="token operator">::</span>cout<span class="token punctuation">.</span><span class="token function">precision</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                                                                <span class="token comment" spellcheck="true">//设置打印精度为12位数字</span>
std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Precision: "</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>cout<span class="token punctuation">.</span><span class="token function">precision</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">", value: "</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span><span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token number">2.0</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//输出当前精度以及当前精度下根号2的值</span>
std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span><span class="token function">setprecision</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                                                        <span class="token comment" spellcheck="true">//另一种设置打印精度的方式是使用setprecision操纵符</span>
std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Precision: "</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>cout<span class="token punctuation">.</span><span class="token function">precision</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">", value: "</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span><span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token number">2.0</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//输出当前精度以及当前精度下根号2的值</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>输出如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">Precision<span class="token operator">:</span> <span class="token number">6</span><span class="token punctuation">,</span> value<span class="token operator">:</span> <span class="token number">1.41421</span>
Precision<span class="token operator">:</span> <span class="token number">12</span><span class="token punctuation">,</span> value<span class="token operator">:</span> <span class="token number">1.41421356237</span>
Precision<span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span> value<span class="token operator">:</span> <span class="token number">1.41</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
</li>
<li>在iostream中定义了很多操纵符，比如对浮点数总是显示小数点的showpoint、左对齐的left、右对齐的right、浮点值显示为定点十进制的fixed、浮点值显示为科学记数法的scientific、浮点值显示为十六进制的hexfloat、重置浮点数格式为十进制的defaultfloat、输入运算符不跳过空白符的noskipws等等，详情可参考《C++Primer第五版》P670页。</li>
<li>通常情况下，由标准库来选择记数法是最好的方式。</li>
<li>scientific、fixed、hexfloat等操纵符会改变流的精度的默认含义。默认情况下精度指定的是数字的总位数，既包括小数点之后的数字也包含小数点之前的数字，而使用它们三以后精度控制的是小数点后面的数字位数。</li>
<li>默认情况下，输入运算符会忽略空白符。如下程序：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">char</span> ch<span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>cin <span class="token operator">>></span> ch<span class="token punctuation">)</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> ch<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
给定下面输入序列时：<pre class="line-numbers language-cpp"><code class="language-cpp">a b     c
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
输出是：<pre class="line-numbers language-cpp"><code class="language-cpp">abc
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
可以看到空白符没有被输入运算符读进来，我们可以使用操纵符noskipws让输入运算符读取空白符，而不是跳过它们：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">char</span> ch<span class="token punctuation">;</span>
std<span class="token operator">::</span>cin <span class="token operator">>></span> std<span class="token operator">::</span>noskipws<span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>cin <span class="token operator">>></span> ch<span class="token punctuation">)</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> ch<span class="token punctuation">;</span>
std<span class="token operator">::</span>cin <span class="token operator">>></span> std<span class="token operator">::</span>skipws<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
还是如上输入序列时，输出将是下面这样：<pre class="line-numbers language-cpp"><code class="language-cpp">a b     c
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
可以看到使用操纵符noskipws后，输入运算符可以不跳过空白符，可以把空白符也读进来。</li>
<li>标准库还提供了一组低层操作，支持未格式化IO。这些操作允许我们将一个流当作一个无解释的字节序列来处理。</li>
<li>我们可以使用未格式化IO操作get和put来读取和写入一个字符（不会忽略空白符）：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">char</span> ch<span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>cin<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">)</span>
    std<span class="token operator">::</span>cout<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
此程序保留输入中的空白符，其输出与输入完全相同。</li>
<li>类似get、put这种单字节低层IO操作如下表：</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">操作</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">is.get(ch)</td>
<td>从istream is读取下一个字符存入字符ch中。返回is</td>
</tr>
<tr>
<td style="text-align:center">os.put(ch)</td>
<td>将字符ch输出到ostream os。返回os</td>
</tr>
<tr>
<td style="text-align:center">is.get()</td>
<td>将is的下一个字节作为int返回</td>
</tr>
<tr>
<td style="text-align:center">is.putback(ch)</td>
<td>将字符ch放回is。返回is</td>
</tr>
<tr>
<td style="text-align:center">is.unget()</td>
<td>将is向后移动一个字节。返回is</td>
</tr>
<tr>
<td style="text-align:center">is.peek()</td>
<td>将下一个字节作为int返回，但不从流中删除它</td>
</tr>
</tbody>
</table>
<ol>
<li><p>有时我们需要读取一个字符才能知道还未准备好处理它。在这种情况下，我们希望将字符放回流中。标准库提供了三种方法退回字符，它们有着细微的差别：</p>
<ul>
<li>peek 返回输入流中下一个字符的副本，但不会将它从流中删除，peek返回的值仍然留在流中。</li>
<li>unget 使得输入流向后移动，从而最后读取的值又回到流中。即使我们不知道最后从流中读取什么值，仍然可以调用unget。</li>
<li>putback是更特殊版本的unget：它退回从流中读取的最后一个值，但它接受一个参数，此参数必须与最后读取的值相同。</li>
</ul>
<p>一般情况下，在读取下一个值之前，标准库保证我们可以退回最多一个值。即，标准库不保证在中间不进行读取操作的情况下能连续调用putback或unget。</p>
</li>
<li>函数peek和无参的get版本都以int类型从输入流返回一个字符，为什么不返回char呢？返回int的原因是可以返回文件尾标记。char范围中的每个值都表示一个真实字符（可参考ASCII码表），它的取值范围内吗，没有额外的值可以用来表示文件尾。</li>
<li>头文件cstdio定义了一个名为EOF的const，我们可以用它来检测从get返回的值是否是文件尾，而不必记忆表示文件尾的实际数值：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> ch<span class="token punctuation">;</span>                                    <span class="token comment" spellcheck="true">//使用int而不是char来保存get()的返回值</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ch <span class="token operator">=</span> std<span class="token operator">::</span>cin<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">EOF</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//循环读取并输出输入中的所有数据</span>
    std<span class="token operator">::</span>cout<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
这个与之前的那段代码很相似，唯一不同的是这里的get版本是无参的，而前面的版本是有参数的。</li>
<li>前面说的是单字节低层IO操作，当然也还有多字节低层IO操作，如下表：</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">操作</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">is.get(sink, size, delim)</td>
<td>从istream is中读取最多size个字节，并保存在sink表示的字符数组中。读取过程直至遇到字符delim或读取了size个字节或遇到文件尾时停止。如果遇到了delim，则将其留在输入流中，而不存入sink里。</td>
</tr>
<tr>
<td style="text-align:center">is.getline(sink, size, delim)</td>
<td>与接受三个参数的get版本类似，但会读取并丢弃delim</td>
</tr>
<tr>
<td style="text-align:center">is.read(sink, size)</td>
<td>读取最多size个字节，存入字符数组sink中。返回is</td>
</tr>
<tr>
<td style="text-align:center">is.gcount()</td>
<td>返回上一个未格式化读取操作从is读取的字节数</td>
</tr>
<tr>
<td style="text-align:center">os.write(source, size)</td>
<td>将字符数组source中的size个字节写入os。返回os</td>
</tr>
<tr>
<td style="text-align:center">is.ignore(size, delim)</td>
<td>读取并忽略最多size个字符，包括delim。与其他未格式化函数不同，ignore有默认参数：size的默认值为1，delim的默认值为文件尾</td>
</tr>
</tbody>
</table>
<ol>
<li>上表中get和getline函数很相似，差别在于处理分隔符的方式：get将分隔符留作istream中的下一个字符，而getline则读取并丢弃分隔符。不过无论哪个函数都不会将分隔符保存在sink中。</li>
<li>一般情况下，我们主张使用标准库提供的高层抽象。一个常见的编程错误是将get或peek的返回值赋予一个chat而不是一个int。这样做是错误的，但是编译器却不能发现这个错误。有可能会出现什么问题难以预料，甚至可能陷入无限循环。<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">char</span> ch<span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ch <span class="token operator">=</span> std<span class="token operator">::</span>cin<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">EOF</span><span class="token punctuation">)</span>
    std<span class="token operator">::</span>cout<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li>在大多数系统中，绑定到cin、cout、cerr和clog的流不支持随机访问：毕竟，当我们向cout直接输出数据时，类似向回跳10个位置这种操作时没有意义的。也就是说istream和ostream类型通常不支持随机访问，seek和tell函数对它们不一定有效，所以后续所述的tell和seek函数用法只适用于fstream和sstream类型。</li>
<li>seek和tell函数如下表所示：</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">操作</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">tellg()、tellp</td>
<td>返回一个输入流中（tellg）或输出流中（tellp）标记的当前位置</td>
</tr>
<tr>
<td style="text-align:center">seekg(pos)、seekp(pos)</td>
<td>在一个输入流或输出流中将标记重定位到给定的绝对地址。pos通常是前一个tellg或tellp返回的值。</td>
</tr>
<tr>
<td style="text-align:center">seekp(off, from)、seekg(off, from)</td>
<td>在一个输入流或输出流中将标记重定位到from之前或之后off个位置（off可正可负），from可能是：beg（流开始位置）、cur（标记当前在流里的位置）、end（流结尾位置）。</td>
</tr>
</tbody>
</table>
<ol>
<li>上表中g版本表示我么正在获得（读取）数据，而p版本表示我们正在放置（写入）数据。虽然标准库对读和写的随机访问有不同版本的函数来完成，但是实际上在一个流中只有一个标记：并不存在独立的读标记和写标记，读和写用的同一个标记。标准库将g和p版本的读写位置都映射到这个单一的标记。</li>
<li><p>比如现在有如下文件Offset.txt：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">abcd
efg
hi
j
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>现在我们想要新增一行，该行记录了文件里每一行的起始偏移位置（这样做有可能会对以后我们快速访问到某一行很有帮助哦！），我们想要得到的结果如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">abcd
efg
hi
j
<span class="token number">5</span> <span class="token number">9</span> <span class="token number">12</span> <span class="token number">14</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>《C++Primer第五版》P678页的程序太复杂，它每统计一个偏移量就会写一次文件，这样做在实际开发中是不好的，效率太低。可以考虑使用下面的程序（简单很多而且只有一次文件写操作）：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>fstream <span class="token function">FInOut</span><span class="token punctuation">(</span><span class="token string">"Offset.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>FInOut<span class="token punctuation">)</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"open file failed!"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>

std<span class="token operator">::</span>string Line<span class="token punctuation">,</span> LastLine<span class="token punctuation">;</span>
size_t Count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">getline</span><span class="token punctuation">(</span>FInOut<span class="token punctuation">,</span> Line<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">//到达文件尾之后seekp等等函数就都失效了，需要先用clear函数复位才能继续使用</span>
<span class="token punctuation">{</span>
    Count <span class="token operator">+</span><span class="token operator">=</span> Line<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">//1是指行末的换行符</span>
    LastLine <span class="token operator">+</span><span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">to_string</span><span class="token punctuation">(</span>Count<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
FInOut<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                    <span class="token comment" spellcheck="true">//clear函数一定要有，重置所有状态标识位</span>
FInOut<span class="token punctuation">.</span><span class="token function">seekp</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> std<span class="token operator">::</span>fstream<span class="token operator">::</span>end<span class="token punctuation">)</span><span class="token punctuation">;</span>
FInOut <span class="token operator">&lt;&lt;</span> LastLine <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
FInOut<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面程序值得注意的有以下几点：</p>
<ul>
<li>统计偏移量时，必须包含每行末尾不可见的换行符（因为getline函数读入字符串到string对象时不会读入换行符）。</li>
<li>while循环结束后，已经到达了文件末尾，此时seekp等等函数都会失效，无法再把读写指针重定位到某个位置，必须先使用clear函数将所有状态标识位复位。</li>
<li>fstream::end并不表示到达文件末尾，到达文件末尾是指流的eofbit位被置位。<br>&nbsp; </li>
</ul>
</li>
</ol>
<hr>
<p>参考文献：《C++Primer第五版》</p>

            </div>

            <!-- Post Comments -->
            
    <!-- 使用 DISQUS_CLICK -->
<div id="disqus-comment">
    <div id="disqus_thread"></div>

<!-- add animation -->
<style>
	.disqus_click_btn {
            line-height: 30px;
            margin: 0;
            min-width: 50px;
            padding: 0 14px;
            display: inline-block;
            font-family: "Roboto", "Helvetica", "Arial", sans-serif;
            font-size: 14px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0;
            overflow: hidden;
            will-change: box-shadow;
            transition: box-shadow .2s cubic-bezier(.4, 0, 1, 1), background-color .2s cubic-bezier(.4, 0, .2, 1), color .2s cubic-bezier(.4, 0, .2, 1);
            outline: 0;
            cursor: pointer;
            text-decoration: none;
            text-align: center;
            vertical-align: middle;
            border: 0;
            background: rgba(158, 158, 158, .2);
            box-shadow: 0 2px 2px 0 rgba(0, 0, 0, .14), 0 3px 1px -2px rgba(0, 0, 0, .2), 0 1px 5px 0 rgba(0, 0, 0, .12);
            color: #fff;
            background-color: #7EC0EE;
            text-shadow: 0
        }
</style>
	
<div class="btn_click_load" id="disqus_bt"> 
    <button class="disqus_click_btn">点击查看评论</button>
</div>

<!--
<script type="text/javascript">
$('.btn_click_load').click(function() {
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'http-miccall-tech'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    document.getElementById('disqus_bt').style.display = "none";
});
</script>
-->
<script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://yoursite.com/2018/04/17/C++Primer第十七章标准库特殊设施/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = 'http://yoursite.com/2018/04/17/C++Primer第十七章标准库特殊设施/'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
</script>

<script type="text/javascript">
    $('.btn_click_load').click(function() {  //click to load comments
        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document;
            var s = d.createElement('script');
            s.src = '//http-miccall-tech.disqus.com/embed.js';
            s.setAttribute('data-timestamp', + new Date());
            (d.head || d.body).appendChild(s);
        })();
        $('.btn_click_load').css('display','none');
    });
</script>
</div>
<style>
    #disqus-comment{
        background-color: #eee;
        padding: 2pc;
    }
</style>


        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
                <li>Design: <a href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
            </ul>
            
            	<span id="busuanzi_container_site_pv">2018总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			
        </div>
    </div>
</body>



 	
</html>
