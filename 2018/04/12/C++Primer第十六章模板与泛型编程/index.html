<!DOCTYPE HTML>
<html>

<head>
	<link rel="bookmark"  type="image/x-icon"  href="/img/logo_miccall.png"/>
	 <link rel="shortcut icon" href="/img/logo_miccall.png">
	
			
    <title>
    Elays'Blog
    </title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="/css/mic_main.css" />
    <link rel="stylesheet" href="/css/dropdownMenu.css" />
    
    	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css" />
    </noscript>

			    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<link rel="stylesheet" href="/css/prism-dark.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>
    
		
<!-- Layouts -->


<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<!--<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">-->
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/latest.js?config=TeX-MML-AM_CHTML" async>
</script>

<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_undefined.css" />
<link rel="stylesheet" href="/css/typo.css" />
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">MICCALL</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special" >
            <ul class="menu links" >
			<!-- Homepage  主页  --> 
			<li >
	            <a href="/" rel="nofollow">主页</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">分类</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="/categories/Boost/">Boost</a></li><li><a class="category-link" href="/categories/C-语法/">C#语法</a></li><li><a class="category-link" href="/categories/C/">C++</a></li><li><a class="category-link" href="/categories/C语言/">C语言</a></li><li><a class="category-link" href="/categories/OpenGL/">OpenGL</a></li><li><a class="category-link" href="/categories/c/">c++</a></li><li><a class="category-link" href="/categories/全局光照/">全局光照</a></li><li><a class="category-link" href="/categories/博客配置/">博客配置</a></li><li><a class="category-link" href="/categories/并行计算/">并行计算</a></li><li><a class="category-link" href="/categories/操作系统/">操作系统</a></li><li><a class="category-link" href="/categories/数据结构/">数据结构</a></li><li><a class="category-link" href="/categories/毕设/">毕设</a></li><li><a class="category-link" href="/categories/游戏开发/">游戏开发</a></li><li><a class="category-link" href="/categories/游戏设计模式/">游戏设计模式</a></li><li><a class="category-link" href="/categories/计算机图形学/">计算机图形学</a></li><li><a class="category-link" href="/categories/计算机系统/">计算机系统</a></li><li><a class="category-link" href="/categories/设计模式/">设计模式</a></li><li><a class="category-link" href="/categories/调试错误集锦/">调试错误集锦</a>
	                    </ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/gallery/" title="图库">
		                图库
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
		            
		                <li><a href="https://github.com/miccall" class="icon fa-github"><span class="label">GitHub</span></a></li>
		            
		            
		            
		            
			</ul>
</nav>

        <div id="main" >
            <div class ="post_page_title_img" style="height: 25rem;background-image: url(http://oqcvzqam1.bkt.clouddn.com/C++Primer%E7%AC%AC16%E7%AB%A0.jpg);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;" >
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2 >C++Primer第十六章 模板与泛型编程</h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
				<div id="toc" class="toc-article">
					<strong class="toc-title">文章目录</strong>
					
				</div>
                <p><font size="5" color="orange">定义模板</font></p>
<hr>
<ol>
<li>用关键字typename来指定模板类型参数比用class更为直观。</li>
<li><p>模板参数列表中，除了可以定义类型参数以外，还可以定义常量表达式：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">unsigned</span> N<span class="token punctuation">,</span><span class="token keyword">unsigned</span> M<span class="token operator">></span>
 <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p1<span class="token punctuation">)</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p2<span class="token punctuation">)</span><span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
     <span class="token keyword">return</span> <span class="token function">strcmp</span><span class="token punctuation">(</span>p1<span class="token punctuation">,</span> p2<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>

 <span class="token function">compare</span><span class="token punctuation">(</span><span class="token string">"the"</span><span class="token punctuation">,</span> <span class="token string">"this"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 编译器会实例化出如下版本：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p1<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p2<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p> 所以在这种可变长度的情景下，模板也是很有用的，它不仅仅模板化某种类型，也模板化常量值。</p>
</li>
<li>非类型模板参数的模板实参必须是常量表达式。</li>
<li>函数模板可以声明为inline或constexpr的，如同非模板函数一样。inline或constexpr说明符放在模板参数列表之后，返回类型之前：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
 <span class="token keyword">inline</span> T <span class="token function">min</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li>函数模板和类模板成员函数的定义通常放在头文件中。</li>
<li>编译器可以根据函数实参来推断函数模板的类型，所以在调用函数模板时可以不在尖括号中提供具体的模板信息；但是编译器无法推断类模板的模板参数类型，所以为了使用类模板，我们必须在模板名后的尖括号中提供额外信息，用来替代模板参数的模板实参列表。</li>
<li>在类外定义类模板的成员函数时，需要加上template，即使该成员函数并没有使用到模板信息。</li>
<li>默认情况下，对于一个实例化了的类模板，其成员只有在使用时才被实例化。</li>
<li>在一个类模板的作用域内，我们可以直接使用模板名而不必指定模板实参。</li>
<li><p>新标准允许我们为类模板定义一个类型别名：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span> <span class="token keyword">using</span> twin <span class="token operator">=</span> std<span class="token operator">::</span>pair<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> T<span class="token operator">></span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    twin<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> IntPair<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//IntPair是一个std::pair&lt;int, int></span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>类模板的static数据成员初始化时也需要使用template：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
<span class="token keyword">class</span> <span class="token class-name">CData</span> 
<span class="token punctuation">{</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> m_Data<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
<span class="token keyword">int</span> CData<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span>m_Data <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>先看如下程序：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
<span class="token keyword">class</span> <span class="token class-name">CData</span> 
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">using</span> value_type <span class="token operator">=</span> std<span class="token operator">::</span>pair<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> T<span class="token operator">></span><span class="token punctuation">;</span>

    value_type <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    value_type m_Data<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
CData<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span>value_type CData<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> m_Data<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这段程序会在第14行报错，说value_type不是一个类型。这是因为默认情况下，C++语言假定通过作用域运算符访问的名字不是类型而是变量。为了通知编译器它是一个类型时，必须在前面加上typename关键字。值得注意的是这里只能用typename而不能用class。</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
<span class="token keyword">typename</span> CData<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span>value_type CData<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> m_Data<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>非模板类也可以有模板成员函数。</li>
<li><p>当我们在类模板外定义一个成员模板时，必须同时为类模板和成员模板提供模板参数列表。类模板的参数列表在前，成员模板的参数列表在后：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
<span class="token keyword">class</span> <span class="token class-name">CData</span> 
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> It<span class="token operator">></span>
    It <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>    <span class="token comment" spellcheck="true">//类模板的模板参数列表</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> It<span class="token operator">></span>    <span class="token comment" spellcheck="true">//成员模板的模板参数列表</span>
It CData<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>在大系统中，在多个文件中实例化相同模板的额外开销可能非常严重。在新标准中，我们可以通过显式实例化来避免这种开销。一个显示实例化有如下形式：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">extern</span> <span class="token keyword">template</span> declaration<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//实例化声明</span>
<span class="token keyword">template</span> declaration<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//实例化定义</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
declaration是一个类或函数声明，其中所有模板参数已被替换为模板实参。例如：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">extern</span> <span class="token keyword">template</span> <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token operator">&lt;</span> std<span class="token operator">::</span>string <span class="token operator">></span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//声明</span>
<span class="token keyword">template</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//定义</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
当编译器遇到extern模板声明时，它不会在本文件中生成实例化代码。将一个实例化声明为extern就表示承诺在程序其他位置有该实例化的一个非extern声明（定义）。对一个给定的实例化版本，可能有多个extern声明，但必须只有一个定义。</li>
<li>显式实例化在定义时，会实例化模板类的所有成员，而普通实例化模板类，成员只有在被使用时才被实例化。</li>
<li><p>shared_ptr和unique_ptr的另一个差异是它们运行哟用户重载默认删除器的方式。我们可以很容易地重载一个shared_ptr的删除器，只要在创建或reset指针时传递给它一个可调用对象即可。与之相反，删除器的类型是一个unique_ptr对象的类型的一部分。用户必须在定义unique_ptr时以显式模板实参的形式提供删除器的类型。</p>
<p>shared_ptr不是将删除器直接保存为一个成员，因为删除器的类型直到运行时才会知道。而由于删除器的类型是unique_ptr类型的一部分，因此删除器成员的类型在编译时是知道的，从而删除器可以直接保存在unique_ptr对象中。通过在编译时绑定删除器。unique_ptr避免了间接调用删除器的运行时开销。通过在运行时绑定删除器，shared_ptr使用用户重载删除器更为方便。</p>
</li>
</ol>
<p><font size="5" color="orange">模板实参推断</font></p>
<hr>
<ol>
<li>算术转换、派生类向基类的转换、用户自定义的转换等等，都不能应用到函数模板的模板参数中。</li>
<li>将实参传递给带模板类型的函数形参时，能够自动应用的类型转换只有const转换、数组或函数到指针的转换。</li>
<li>如果模板函数参数类型不是模板参数，则对实参进行正常的类型转换。</li>
<li>显式模板实参会按从左至右的顺序与对应的模板参数匹配。</li>
<li><p>如下面的程序，我们想要定义一个函数模板来返回迭代器范围中的首元素：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> It<span class="token operator">></span>
 <span class="token operator">?</span><span class="token operator">?</span><span class="token operator">?</span> <span class="token operator">&amp;</span><span class="token function">f</span><span class="token punctuation">(</span>It beg<span class="token punctuation">,</span> It end<span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
     <span class="token keyword">return</span> <span class="token operator">*</span>beg<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 由于是模板函数，我们并不知道返回的准确类型，只知道返回类型和迭代器指向元素的类型相同，于是我们可以使用decltype(*beg)来获取返回类型，但是函数返回类型出现在函数参数之前，在编译器遇到参数列表之前，beg都是不存在的。为了解决这个问题，我们可以使用尾置返回类型：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> It<span class="token operator">></span>
 <span class="token keyword">auto</span> <span class="token function">f</span><span class="token punctuation">(</span>It beg<span class="token punctuation">,</span> It end<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token operator">*</span>beg<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//尾置返回类型</span>
 <span class="token punctuation">{</span>
     <span class="token keyword">return</span> <span class="token operator">*</span>beg<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> decltype推断的类型是beg所指向的元素的类型的引用，如果不想要引用，可以使用：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> It<span class="token operator">></span>
 <span class="token keyword">auto</span> <span class="token function">f</span><span class="token punctuation">(</span>It beg<span class="token punctuation">,</span> It end<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token keyword">typename</span> remove_reference<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token operator">*</span>beg<span class="token punctuation">)</span><span class="token operator">></span><span class="token operator">::</span>type
 <span class="token punctuation">{</span>
     <span class="token keyword">return</span> <span class="token operator">*</span>beg<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 其中使用typename的原因前面已经说过，不再赘述。而remove_reference&lt;&gt;是标准库定义的类型转换模板中的一种。这些类似的模板定义在头文件type_traits中，用于改变类型的引用、指针等等属性。比如上面去掉类型的引用属性。具体有哪些可参考《C++ Primer5》第16章。</p>
<p> type是这些类型转换模板的public成员，表示转换后的类型。</p>
</li>
<li>当我们用一个函数模板初始化一个函数指针或为一个函数指针赋值时，编译器使用指针的类型来推断模板实参：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
 <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span>pf<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> compare<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//编译器根据指针类型推断模板实参类型</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li>如果一个函数参数是指向模板参数类型的右值引用（如T&amp;&amp;），则可以传递给它任意类型的实参。如果将一个左值传递给这样的参数，则函数参数被实例化为一个普通的左值引用（T&amp;）。也就是说模板参数可以被推断为一个引用类型，则对模板内的代码可能影响很大：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
 <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>T <span class="token operator">&amp;&amp;</span>vValue<span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
     T t <span class="token operator">=</span> vValue<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//拷贝还是绑定一个引用？</span>
 <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
 <strong>如果我们对一个左值int i调用f时，则T为int&amp;。对一个右值41调用f时，则T为int。</strong></li>
<li>在实际中，右值引用通常用于两种情况：模板转发其实参或模板被重载（后续详述）。</li>
<li><p>标准库move是使用右值引用的模板的一个很好的例子。标准库的move是这样定义的：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
 <span class="token keyword">typename</span> remove_reference<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span>type<span class="token operator">&amp;&amp;</span> <span class="token function">move</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> t<span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
     <span class="token keyword">return</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> remove_reference<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span>type<span class="token operator">&amp;&amp;</span><span class="token operator">></span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 可以看到，std::move实际上是使用static_cast把一个左值强制转换为右值引用的一个模板函数。std::move的工作过程如下：</p>
<p> 在std::move(std::string(“bye!”))中：</p>
<ul>
<li>因为实参时右值，所以推断出T的类型为string</li>
<li>因此，remove_reference用string进行实例化</li>
<li>remove_reference<string>的type成员是string</string></li>
<li>move的返回类型是string&amp;&amp;</li>
<li><p>move的函数参数t的类型为string&amp;&amp;</p>
<p>所以该move的实例化版本为<code>string&amp;&amp; move(string &amp;&amp;t)</code>。</p>
<p>在std::move(s1)中：</p>
</li>
<li>因为实参时左值，所以推断出T的类型为string&amp;</li>
<li>因此，remove_reference用string&amp;进行实例化</li>
<li>remove_reference<string&>的type成员是string</string&></li>
<li>move的返回类型仍然是string&amp;&amp;</li>
<li><p>move的函数参数t的类型为string&amp; &amp;&amp;，会折叠为string&amp;</p>
<p>所以该move的实例化版本为<code>string&amp;&amp; move(string &amp;t)</code>。这就是我们想要的，使用std::move来获取一个左值的右值引用。</p>
</li>
</ul>
</li>
<li>虽然不能隐式地将一个左值转换为右值引用，但我们可以用static_cast显式地将一个左值转换为一个右值引用。</li>
<li><p>某些函数需要将其一个或多个实参<strong>连同类型不变地</strong>转发给其他函数。在此情况下，我们需要保持被转发实参的所有性质，包括实参类型是否是const的以及实参是左值还是右值。</p>
<p>比如我们现在想把一个函数f的两个实参顺序翻转一下，形成另一个新的函数：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> F<span class="token punctuation">,</span><span class="token keyword">typename</span> T1<span class="token punctuation">,</span> <span class="token keyword">typename</span> T2<span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">flip1</span><span class="token punctuation">(</span>F f<span class="token punctuation">,</span> T1 t1<span class="token punctuation">,</span> T2 t2<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//flip1是f参数翻转后的版本，但是丢失了参数的顶层const和引用属性</span>
<span class="token punctuation">{</span>
    <span class="token function">f</span><span class="token punctuation">(</span>t2<span class="token punctuation">,</span> t1<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个函数一般情况下工作得很好，但当我们希望用它调用一个接受引用参数的函数时就会出现问题：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> v1<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>v2<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> v1 <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">++</span>v2 <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>在这段代码中，f改变了绑定到v2的实参的值。但是，如果我们通过flip1调用f，f所做的改变就不会影响实参：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token function">f</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//f改变了实参i</span>
<span class="token function">flip1</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> j<span class="token punctuation">,</span> <span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//通过flip1调用f不会改变j</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>问题在于flip1的参数t1不是引用类型，f的参数v1被绑定到t1，而不是绑定到j上。所以其改变并不会影响实参j。</p>
<p>通过将一个函数参数定义为一个指向<strong>模板类型</strong>参数的<strong>右值引用</strong>，我们可以保持其对应实参的所有类型信息。如果我们将函数参数定义为T1&amp;&amp;和T2&amp;&amp;，通过引用折叠就可以保持翻转实参的左值/右值属性：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> F<span class="token punctuation">,</span><span class="token keyword">typename</span> T1<span class="token punctuation">,</span> <span class="token keyword">typename</span> T2<span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">flip2</span><span class="token punctuation">(</span>F f<span class="token punctuation">,</span> T1 <span class="token operator">&amp;&amp;</span>t1<span class="token punctuation">,</span> T2 <span class="token operator">&amp;&amp;</span>t2<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//flip2是f参数翻转后的版本，保持了实参的左值/右值以及const属性</span>
<span class="token punctuation">{</span>
    <span class="token function">f</span><span class="token punctuation">(</span>t2<span class="token punctuation">,</span> t1<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在调用<code>flip2(f, j, 41);</code>时，将传递给参数t1一个左值，但是因为是右值引用，所以推断出的T1的类型是int&amp;，那么t1的类型会折叠为int&amp;，也就是引用类型，所以t1会被绑定到j上，然后调用函数f时v2会被绑定到t1上，所以对v2的改变最终会影响到实参j。</p>
<p>值得注意的是，只有把左值传递给模板类型的右值，才会发生引用折叠，但是不能把左值传递给一个非模板类型的右值，因为不能直接把一个左值绑定到右值上。也就是说可以把左值赋给模板类型的右值，但是不能赋给普通类型的右值。</p>
</li>
<li><p>上面的flip2值解决了一半问题：它对于接受左值引用的函数工作得很好，但不能用于接受右值引用参数的函数。例如：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;&amp;</span>i<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>j<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> j <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>在如下调用时会编译报错：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token function">flip2</span><span class="token punctuation">(</span>g<span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//错误，不能把左值赋给一个右值int&amp;&amp;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这是因为在flip2在调用函数g时，t2本质上是一个变量，变量都是左值，所以我们无法把左值t2赋给函数g的右值参数i（注意这是普通右值，不是模板类型的右值）。</p>
<p>我们可以使用std::forward来保持原始实参42的右值属性。forward定义在头文件utility中，与move不同，forward必须显式指定它的模板实参，它会返回显式实参类型的右值引用，即forward<t>的返回类型是T&amp;&amp;。所以我们可以重写flip2函数，让它在维持左值引用的同时，还能维持右值引用：</t></p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> F<span class="token punctuation">,</span><span class="token keyword">typename</span> T1<span class="token punctuation">,</span> <span class="token keyword">typename</span> T2<span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">flip3</span><span class="token punctuation">(</span>F f<span class="token punctuation">,</span> T1 <span class="token operator">&amp;&amp;</span>t1<span class="token punctuation">,</span> T2 <span class="token operator">&amp;&amp;</span>t2<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//flip3是f参数翻转后的版本，同时支持左值引用和右值引用</span>
<span class="token punctuation">{</span>
    <span class="token function">f</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>T2<span class="token operator">></span><span class="token punctuation">(</span>t2<span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">(</span>t1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在调用<code>flip3(g, i, 41);</code>时，由于i是左值，所以T1是int&amp;；由于41是右值，所以T2是int。所以forward<t2>(t2)的返回类型是int&amp;&amp;，可以将右值传递给函数g的右值参数i；forward<t1>(t1)的返回类型是int&amp; &amp;&amp;，折叠后是int&amp;，可以将左值传递给g的左值参数j。</t1></t2></p>
<p>总结：当用于一个指向模板参数类型的右值引用函数参数（比如上面的t1、t2）时，forward会保持<strong>原始实参</strong>（右值引用形参t1、t2对应的实参i、41）的所有细节（原始实参的左/右值属性）。</p>
</li>
</ol>
<p><font size="5" color="orange">可变参数模板</font></p>
<hr>
<ol>
<li>一个可变参数模板就是一个接受可变数目参数的模板函数或模板类。可变数目的参数被称为参数包。存在两种参数包：模板参数包（表示零个或多个模板参数）、函数参数包（表示零个或多个函数参数）。</li>
<li>我们用一个省略号来指出一个模板参数或函数参数表示一个包：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token comment" spellcheck="true">//Args是一个模板参数包；rest是一个函数参数包</span>
 <span class="token comment" spellcheck="true">//Args表示零个或多个模板类型参数</span>
 <span class="token comment" spellcheck="true">//rest表示零个或多个函数参数</span>
 <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token punctuation">,</span> <span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Args<span class="token operator">></span>
 <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">const</span> T <span class="token operator">&amp;</span>t<span class="token punctuation">,</span> <span class="token keyword">const</span> Args<span class="token operator">&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> rest<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>对一个可变参数模板，编译器还会推断包中参数的数目：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token keyword">double</span> d <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span> std<span class="token operator">::</span>string s <span class="token operator">=</span> <span class="token string">"Hello!"</span><span class="token punctuation">;</span>
 <span class="token function">f</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> s<span class="token punctuation">,</span> <span class="token number">41</span><span class="token punctuation">,</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//包中有3个参数</span>
 <span class="token function">f</span><span class="token punctuation">(</span><span class="token string">"Hi"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//空包</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
 编译器会为f函数实例化出对应的两个不同的版本。其中T的类型都是从第一个实参的类型推断出来的，剩下的实参（如果有的话）提供函数额外实参的数目和类型。</li>
<li>当我们需要知道包中有多少个元素时，可以使用sizeof…运算符：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token punctuation">,</span> <span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Args<span class="token operator">></span>
 <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">const</span> T <span class="token operator">&amp;</span>t<span class="token punctuation">,</span> <span class="token keyword">const</span> Args<span class="token operator">&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> rest<span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
     std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">(</span>Args<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//模板参数的数目</span>
     std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">(</span>rest<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//函数参数的数目</span>
 <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>我们可以使用一个initializer_list来定义一个可接受可变数目实参的函数。但是，所有实参必须具有相同的类型（或它们的类型可以转换为同一个公共类型）。如果所有实参的类型并不相同时，可变参数模板是很有用的：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token comment" spellcheck="true">//用来终止递归并打印最后一个元素的函数</span>
 <span class="token comment" spellcheck="true">//此函数必须在可变参数版本的print定义之前声明</span>
 <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
 ostream<span class="token operator">&amp;</span> <span class="token function">print</span><span class="token punctuation">(</span>ostream <span class="token operator">&amp;</span>os<span class="token punctuation">,</span> <span class="token keyword">const</span> T <span class="token operator">&amp;</span>t<span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
     <span class="token keyword">return</span> os <span class="token operator">&lt;&lt;</span> t<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
 <span class="token comment" spellcheck="true">//包中除了最后一个元素之外的其他元素都会调用这个版本的print</span>
 <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token punctuation">,</span> <span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Args<span class="token operator">></span>
 ostream<span class="token operator">&amp;</span> <span class="token function">print</span><span class="token punctuation">(</span>ostream <span class="token operator">&amp;</span>os<span class="token punctuation">,</span> <span class="token keyword">const</span> T <span class="token operator">&amp;</span>t<span class="token punctuation">,</span> <span class="token keyword">const</span> Args<span class="token operator">&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> rest<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//这里面的t很重要</span>
 <span class="token punctuation">{</span>
     os <span class="token operator">&lt;&lt;</span> t <span class="token operator">&lt;&lt;</span> <span class="token string">","</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//打印第一个实参</span>
     <span class="token keyword">return</span> <span class="token function">print</span><span class="token punctuation">(</span>os<span class="token punctuation">,</span> rest<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//递归调用，打印其他实参</span>
 <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
 如果发现可变参数模板函数和非可变参数模板函数都满足调用匹配，那么编译器会选择非可变的模板，因为它更加特例化。比如当rest中的参数只剩下一个时，编译器会去调用第一个print而不是第二个print。</li>
</ol>
<p><font size="5" color="orange">模板特例化</font></p>
<hr>
<ol>
<li><p>当我们不能（或不希望）使用模板版本时，可以定义类或函数模板的一个特例化版本。比如compare函数：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token comment" spellcheck="true">//第一个版本，可以比较任意两个类型</span>
 <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
 <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token keyword">const</span> T <span class="token operator">&amp;</span>v1<span class="token punctuation">,</span> <span class="token keyword">const</span> T <span class="token operator">&amp;</span>v2<span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
     <span class="token keyword">return</span> v1 <span class="token operator">&lt;</span> v2<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 如果我们传字符指针，它会去比较两个指针的值：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token string">"Hi"</span><span class="token punctuation">,</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> <span class="token string">"Girl"</span><span class="token punctuation">;</span>
 <span class="token function">compare</span><span class="token punctuation">(</span>p1<span class="token punctuation">,</span> p2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p> 但这并不是我们想要的，我们想要的是比较指针所指向的两个字符串，而不是两个指针的值。为了让该模板函数也可以正确处理字符指针，我们可以为它定义一个模板特例化版本。一个模板特例化版本就是模板的一个独立的定义，在其中一个或多个模板参数被指定为特定的类型。</p>
<p> 为了指出我们正在实例化一个模板，应使用关键字template后跟一个空尖括号对（&lt;&gt;）。空尖括号指出我们将为原模板的所有模板参数提供实参：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token comment" spellcheck="true">//compare的特例化版本，处理指向字符数组的指针</span>
 <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">></span>
 <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token keyword">const</span> <span class="token operator">&amp;</span>p1<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token keyword">const</span> <span class="token operator">&amp;</span>p2<span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
     <span class="token keyword">return</span> <span class="token function">strcmp</span><span class="token punctuation">(</span>p1<span class="token punctuation">,</span> p2<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 其中p1、p2都是指向const char的const指针的引用。</p>
</li>
<li>从上面的程序可以看到，模板的特例化版本的函数内容可以和原模板函数的内容不同。</li>
<li>特例化的本质是实例化一个模板，而非重载它。因此，特例化不影响函数匹配。</li>
<li>编译器优先选择非模板版本，再选择模板特例化版本，再选择最佳匹配的模板版本。</li>
<li>模板及其特例化版本应该声明在同一个头文件中。所以同名模板的声明应该放在前面，然后是这些模板的特例化版本。</li>
<li><p>默认情况下，无序容器使用hash<key_type>来组织其元素。标准库为内置类型和很多标准库类型定义了hash类的特例化版本，比如我们可以使用一个（未命名的）hash<string>对象来生成一个字符串的hash值。所以我们可以把类似string这种标准库类型对象存入无序容器中，但是却无法把类似CData这种自定义类型放入无序容器中，因为标准库没有提供针对CData的hash类版本：</string></key_type></p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">double</span><span class="token operator">></span> IntDoubleMap<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//正确</span>
 std<span class="token operator">::</span>unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> CData<span class="token operator">></span> IntCDataMap<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//正确</span>
 std<span class="token operator">::</span>unordered_map<span class="token operator">&lt;</span>CData<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> CDataIntMap2<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//错误，标准库没有为键CData提供对应的hash版本</span>
 std<span class="token operator">::</span>unordered_set<span class="token operator">&lt;</span>CData<span class="token operator">></span> DataSet<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//错误，标准库没有为CData提供对应的hash版本</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p> 这时我们就需要自己为CData类定义一个特例化的hash版本了：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">namespace</span> std                                    <span class="token comment" spellcheck="true">//hash类定义在std命名空间中</span>
 <span class="token punctuation">{</span>
     <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">></span>                                    <span class="token comment" spellcheck="true">//我们正在定义一个特例化版本，模板参数为CData</span>
     <span class="token keyword">struct</span> hash<span class="token operator">&lt;</span>CData<span class="token operator">></span>
     <span class="token punctuation">{</span>
         <span class="token comment" spellcheck="true">//用来散列一个无序容器的类型必须要定义下列类型</span>
         <span class="token keyword">typedef</span> size_t result_type<span class="token punctuation">;</span>
         <span class="token keyword">typedef</span> CData argument_type<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//默认情况下，此类型需要==</span>
         size_t  <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> CData<span class="token operator">&amp;</span> vData<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span><span class="token punctuation">;</span>

     size_t hash<span class="token operator">&lt;</span>CData<span class="token operator">></span><span class="token operator">::</span><span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> CData<span class="token operator">&amp;</span> vData<span class="token punctuation">)</span> <span class="token keyword">const</span> 
     <span class="token punctuation">{</span>
         <span class="token keyword">return</span> hash<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>vData<span class="token punctuation">.</span><span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> hash<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>vData<span class="token punctuation">.</span><span class="token function">getDataName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 在上面的代码中我们为CData定义了一个特例化的hash模板，在调用运算符()里，返回CData每个成员hash值的异或，作为CData最终的hash值。因为hash类定义在std命名空间中，所以我们的特例化hash版本也需要在同一个命名空间下。有了这段代码以后，上面把CData存入无序容器的操作就是正确的了。</p>
<p> 而且为了让CData的用户能够使用hash的特例化版本，我们应该在CData的头文件中定义该特例化版本。</p>
<p> hash模板函数的原型如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
 <span class="token keyword">struct</span> hash
 <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p> 从上面可以看出，对函数模板特例化时，模板实参是在函数参数类型中直接提供，如上面的compare函数；而类模板特例化时，模板实参是在类名后面加一个尖括号，在尖括号里指定模板实参（和实例化模板类比较像，如std::vector<int>）。</int></p>
</li>
<li>与函数模板不同，类模板的特例化不必为所有模板参数提供实参。也就是说我们只能部分特例化类模板，而不能部分特例化函数模板。</li>
<li>标准库类型remove_reference类型就是一个部分特例化模板类的例子：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token comment" spellcheck="true">//原始的、最通用的版本</span>
 <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
 <span class="token keyword">struct</span> remove_reference
 <span class="token punctuation">{</span>
     <span class="token keyword">typedef</span> T type<span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>
 <span class="token comment" spellcheck="true">//部分特例化模板类，用于左值引用</span>
 <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
 <span class="token keyword">struct</span> remove_reference<span class="token operator">&lt;</span>T<span class="token operator">&amp;</span><span class="token operator">></span>
 <span class="token punctuation">{</span>
     <span class="token keyword">typedef</span> T type<span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>
 <span class="token comment" spellcheck="true">//部分特例化模板类，用于右值引用</span>
 <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
 <span class="token keyword">struct</span> remove_reference<span class="token operator">&lt;</span>T<span class="token operator">&amp;&amp;</span><span class="token operator">></span>
 <span class="token punctuation">{</span>
     <span class="token keyword">typedef</span> T type<span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
 后面两个版本都是第一个版本的部分特例化版本，分别将T&amp;和T&amp;&amp;作为模板实参，但是T具体是什么还不知道，这就是部分特例化，指定了模板实参，但是并不是所有的参数类型都明确知晓。</li>
<li><p>我们还可以只特例化模板类的成员函数，而不是特例化整个模板类：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
 <span class="token keyword">class</span> <span class="token class-name">CData</span>
 <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
     <span class="token function">CData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
     <span class="token operator">~</span><span class="token function">CData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
     <span class="token function">CData</span><span class="token punctuation">(</span>T vData<span class="token punctuation">)</span> <span class="token punctuation">{</span> m_Data <span class="token operator">=</span> vData<span class="token punctuation">;</span> <span class="token punctuation">}</span>

     <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> m_Data <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
     T m_Data <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>

 <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">></span>                                    <span class="token comment" spellcheck="true">//我们正在特例化一个模板</span>
 <span class="token keyword">void</span> CData<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>                <span class="token comment" spellcheck="true">//我们正在特例化CData&lt;int>的成员函数print</span>
 <span class="token punctuation">{</span>
     std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> m_Data <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>

 CData<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span> <span class="token function">Data1</span><span class="token punctuation">(</span><span class="token number">41.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 Data1<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                <span class="token comment" spellcheck="true">//输出41</span>
 CData<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span>      <span class="token function">Data2</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 Data2<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                <span class="token comment" spellcheck="true">//输出82，使用我们为int定义的特例化版本CData&lt;int>::print()</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>&nbsp; </p>
</li>
</ol>
<hr>
<p>参考文献：《C++Primer第五版》</p>

            </div>

            <!-- Post Comments -->
            
    <!-- 使用 DISQUS_CLICK -->
<div id="disqus-comment">
    <div id="disqus_thread"></div>

<!-- add animation -->
<style>
	.disqus_click_btn {
            line-height: 30px;
            margin: 0;
            min-width: 50px;
            padding: 0 14px;
            display: inline-block;
            font-family: "Roboto", "Helvetica", "Arial", sans-serif;
            font-size: 14px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0;
            overflow: hidden;
            will-change: box-shadow;
            transition: box-shadow .2s cubic-bezier(.4, 0, 1, 1), background-color .2s cubic-bezier(.4, 0, .2, 1), color .2s cubic-bezier(.4, 0, .2, 1);
            outline: 0;
            cursor: pointer;
            text-decoration: none;
            text-align: center;
            vertical-align: middle;
            border: 0;
            background: rgba(158, 158, 158, .2);
            box-shadow: 0 2px 2px 0 rgba(0, 0, 0, .14), 0 3px 1px -2px rgba(0, 0, 0, .2), 0 1px 5px 0 rgba(0, 0, 0, .12);
            color: #fff;
            background-color: #7EC0EE;
            text-shadow: 0
        }
</style>
	
<div class="btn_click_load" id="disqus_bt"> 
    <button class="disqus_click_btn">点击查看评论</button>
</div>

<!--
<script type="text/javascript">
$('.btn_click_load').click(function() {
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'http-miccall-tech'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    document.getElementById('disqus_bt').style.display = "none";
});
</script>
-->
<script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://yoursite.com/2018/04/12/C++Primer第十六章模板与泛型编程/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = 'http://yoursite.com/2018/04/12/C++Primer第十六章模板与泛型编程/'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
</script>

<script type="text/javascript">
    $('.btn_click_load').click(function() {  //click to load comments
        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document;
            var s = d.createElement('script');
            s.src = '//http-miccall-tech.disqus.com/embed.js';
            s.setAttribute('data-timestamp', + new Date());
            (d.head || d.body).appendChild(s);
        })();
        $('.btn_click_load').css('display','none');
    });
</script>
</div>
<style>
    #disqus-comment{
        background-color: #eee;
        padding: 2pc;
    }
</style>


        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
                <li>Design: <a href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
            </ul>
            
            	<span id="busuanzi_container_site_pv">2018总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			
        </div>
    </div>
</body>



 	
</html>
