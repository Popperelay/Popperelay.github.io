<!DOCTYPE HTML>
<html>

<head><meta name="generator" content="Hexo 3.9.0">
	<link rel="bookmark" type="image/x-icon" href="/img/logo_miccall.png">
	 <link rel="shortcut icon" href="/img/logo_miccall.png">
	
			
    <title>
    Elays'Blog
    </title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <link rel="stylesheet" href="/css/mic_main.css">
    <link rel="stylesheet" href="/css/dropdownMenu.css">
    
    	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css">
    </noscript>
			    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<link rel="stylesheet" href="/css/prism-dark.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>
    
		
<!-- Layouts -->


<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<!--<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">-->
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/latest.js?config=TeX-MML-AM_CHTML">
</script>

<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_undefined.css">
<link rel="stylesheet" href="/css/typo.css">
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">MICCALL</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special">
            <ul class="menu links">
			<!-- Homepage  主页  --> 
			<li>
	            <a href="/" rel="nofollow">主页</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">分类</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="/categories/C/">C#</a></li><li><a class="category-link" href="/categories/C-语法/">C#语法</a></li><li><a class="category-link" href="/categories/C/">C++</a></li><li><a class="category-link" href="/categories/C语言/">C语言</a></li><li><a class="category-link" href="/categories/Graphics/">Graphics</a></li><li><a class="category-link" href="/categories/Math/">Math</a></li><li><a class="category-link" href="/categories/OpenGL/">OpenGL</a></li><li><a class="category-link" href="/categories/Unity/">Unity</a></li><li><a class="category-link" href="/categories/博客配置/">博客配置</a></li><li><a class="category-link" href="/categories/并行计算/">并行计算</a></li><li><a class="category-link" href="/categories/操作系统/">操作系统</a></li><li><a class="category-link" href="/categories/数据结构/">数据结构</a></li><li><a class="category-link" href="/categories/毕设/">毕设</a></li><li><a class="category-link" href="/categories/游戏开发/">游戏开发</a></li><li><a class="category-link" href="/categories/计算机系统/">计算机系统</a></li><li><a class="category-link" href="/categories/设计模式/">设计模式</a></li><li><a class="category-link" href="/categories/面试/">面试</a>
	                    </li></ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/gallery/" title="图库">
		                图库
		            </a>
		        </li>
		        
		        <li>
		            <a href="/tag/" title="搜索">
		                搜索
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
		            
		                <li><a href="https://github.com/miccall" class="icon fa-github"><span class="label">GitHub</span></a></li>
		            
		            
		            
		            
			</ul>
</nav>

        <div id="main">
            <div class="post_page_title_img" style="height: 25rem;background-image: url(https://github.com/Popperelay/Photos/blob/master/Photos/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC1%E7%AB%A0_BG.jpg?raw=true);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;">
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2>深入理解计算机系统第一章 计算机系统漫游</h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
				<!-- 目录 -->
				<p class="show-toc-btn" id="show-toc-btn" onclick="showToc();" style="display:none">
				<span class="btn-bg"></span>
				<span class="btn-text">文章导航</span>
				</p>
				<div id="toc-article" class="toc-article">
					<span id="toc-close" class="toc-close" title="隐藏导航" onclick="showBtn();">×</span>
					<strong class="toc-title">文章目录</strong>
					
			   </div>
			   <script type="text/javascript">
				function showToc(){
					var toc_article = document.getElementById("toc-article");
					var show_toc_btn = document.getElementById("show-toc-btn");
					toc_article.setAttribute("style","display:block");
					show_toc_btn.setAttribute("style","display:none");
					};
				function showBtn(){
					var toc_article = document.getElementById("toc-article");
					var show_toc_btn = document.getElementById("show-toc-btn");
					toc_article.setAttribute("style","display:none");
					show_toc_btn.setAttribute("style","display:block");
					};
			   </script>
				
                <p><font size="5" color="orange">信息就是位+上下文</font></p>
<hr>
<ul>
<li>源程序实际上是0和1组成的位序列，8个位组成一个字节。每个字节表示程序程序中的某些文本字符。</li>
<li>大部分的现代计算机系统都使用ASCII标准来表示文本字符，这种方式实际上就是用一个唯一的单字节大小的整数值来表示每个字符。</li>
<li>只有ASCII字符构成的文件成文文本文件，所有其他文件都称为二进制文件。</li>
</ul>
<p><font size="5" color="orange">程序被其他程序翻译成不同的格式</font></p>
<hr>
<ul>
<li><p>如下hello.c程序：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">  <span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

  <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"hello, world\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>  把这个源文件hello.c转换成可执行目标程序的过程是由编译系统来完成的。编译过程分为4个阶段，这4个阶段的程序：预处理器、编译器、汇编器、链接器，一起构成了编译系统。如下图所示：<br>  <img src="https://github.com/Popperelay/Photos/blob/master/Photos/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC1%E7%AB%A0_1.png?raw=true" alt></p>
<ol>
<li>预处理阶段。预处理器（cpp）根据以字符#开头的命令，修改原始的C程序hello.c。它会把对应的头文件直接插入程序文本中，得到新的C程序hello.i。</li>
<li>编译阶段。编译器（ccl）将预处理之后的文本文件hello.i转换成汇编语言程序hello.s：<pre class="line-numbers language-cpp"><code class="language-cpp"> main<span class="token operator">:</span>
   subq    $<span class="token number">8</span><span class="token punctuation">,</span> <span class="token operator">%</span>rsp
   movl    $<span class="token punctuation">.</span>LOC<span class="token punctuation">,</span> <span class="token operator">%</span>edi
   call    puts
   movl    $<span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">%</span>eax
   addq    $<span class="token number">8</span><span class="token punctuation">,</span> <span class="token operator">%</span>rsp
   ret
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
 汇编语言是非常有用的，因为它为不同高级语言的不同编译器提供了通用的输出语言。例如C编译器和Fortran编译器产生的输出文件用的都是一样的汇编语言</li>
<li>汇编阶段。汇编器（as）将汇编语言程序hello.s转换成二进制的可重定位目标程序hello.o。</li>
<li>链接阶段。注意到在程序中调用了一个printf函数，它存在于一个名为printf.o的单独的预编译好了的目标文件中，而这个文件必须以某种方式合并到我们的hello.o程序中。链接器（ld）就负责处理这种合并。链接结果会得到一个二进制的可执行目标文件hello。这个可执行目标文件后续可以被加载到内存中，由系统来执行。</li>
</ol>
</li>
<li><p>GCC是GNU（GNU’s Not Unix）项目开发出来的一个编译器。</p>
</li>
</ul>
<p><font size="5" color="orange">了解编译系统如何工作是大有益处的</font></p>
<hr>
<p>了解编译系统如何工作会有以下几点好处：</p>
<ul>
<li>优化程序性能。比如，一个switch语句是否总是比一些列的if-else语句高效得多？一个函数调用的开销有多大？while循环比for循环更有效吗？指针引用比数组索引更有效吗？为什么将循环求和的结果放到一个本地变量中，会比将其放到一个通过引用传递过来的参数中，运行起来快很多呢？为什么我们只是简单地重新排列一下算术表达式中的括号就能让函数运行得更快？</li>
<li>理解链接时出现的错误。比如，链接器报告说它无法解析一个引用，这是什么意思？静态变量和全局变量的区别是什么？如果你在不同的C文件中定义了名字相同的两个全局变量会发生什么？静态库和动态库的区别是什么？我们在命令行上排列库的顺序有什么影响？最严重的是，为什么有些链接错误直到运行时才会出现？</li>
<li>避免安全漏洞。学习安全编程的第一步就是理解数据和控制信息存储在程序栈上的方式会引起的后果。</li>
</ul>
<p><font size="5" color="orange">处理器读并解释存储在内存中的指令</font></p>
<hr>
<p><font size="4" color="red">系统的硬件组成</font><br>为了理解运行hello程序时发生了什么，我们需要了解一个典型系统的硬件组织。如下图所示：<br>    <img src="https://github.com/Popperelay/Photos/blob/master/Photos/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC1%E7%AB%A0_2.png?raw=true" alt></p>
<ul>
<li>总线<br>总线是贯穿整个系统的一组电子管道，它携带信息字节并负责在各个部件间传递信息。通常总线被设计成传送定长的字节块，也就是字（word）。字中的字节数（即字长）是一个基本的系统参数，各个系统中都不尽相同。现在大多数机器字长要么是4个字节（32位机），要么是8个字节（64位机）。</li>
<li>I/O设备<br>I/O（输入/输出）设备是系统与外部世界的联系通道。每个I/O设备都通过一个控制器或适配器与I/O总线相连。控制器和适配器之间的区别主要在于它们的封装方式。控制器是I/O设备本身或者系统的主板（主印制电路板）上的芯片组；而适配器则是一块插在主板插槽上的卡。无论如何，它们的功能都是在I/O总线和I/O设备之间传递信息。</li>
<li>主存<br>主存是一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。从物理上来说，主存是一组动态随机存取存储器（DRAM）芯片组成的。<br>在运行Linux的x86-64机器上，short类型的数据需要2个字节，int和float类型需要4个字节，而long和double类型需要8个字节。</li>
<li><p>处理器<br>中央处理单元（CPU），简称处理器，是解释（或执行）存储在主存中指令的引擎。处理器的核心是一个大小为一个字的存储设备（或寄存器），称为程序计数器（PC）。在任何时刻，PC都指向主存中的某条机器语言指令（即含有该条指令的地址）。<br>执行一条指令包含执行一系列的步骤。处理器从程序计数器指向的内存处读取指令，解释指令中的位，执行该指令指示的简单操作，然后更新PC，使其指向下一条指令，而这条指令并不一定和在内存中刚刚执行的指令相邻。</p>
<p>寄存器文件是一个小的存储设备，由一些单个字长的寄存器组成，每个寄存器都有唯一的名字。ALU计算新的数据和地址值。</p>
<p>处理器看上去它的指令集架构的简单实现，但是实际上现代处理器使用了非常复杂的机制来加速程序的执行。</p>
</li>
</ul>
<p><font size="4" color="red">运行hello程序</font><br>当我们通过键盘在终端输入“./hello”字符串以后，shell程序会将字符串逐一读入CPU的寄存器中，然后再把该字符串从寄存器放到内存中。这个过程如下图所示：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC1%E7%AB%A0_3.png?raw=true" alt><br>当我们在键盘上输入回车键时，shell程序就知道我们已经结束了命令的输入。然后shell会执行一系列指令来加载可执行文件hello，它们会把hello文件中的代码和数据从磁盘复制到主存（数据主要是要程序中要输出的字符串“hello, world\n”，而且利用直接存储器存取（DMA）技术，代码和数据可以不通过处理器而直接从磁盘到达主存）。这个过程如下图所示：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC1%E7%AB%A0_4.png?raw=true" alt><br>一旦可执行文件hello中的代码和数据被加载到内存，处理器就开始执行hello程序的main程序中的机器语言指令。这些指令将字符串“hello, world\n”中的字节从主存复制到CPU的寄存器文件中，然后再从寄存器文件复制到显示设备里，最终显示在屏幕上。这个过程如下图所示：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC1%E7%AB%A0_5.png?raw=true" alt></p>
<p><font size="5" color="orange">高速缓存至关重要</font></p>
<hr>
<p>上面hello程序的执行过程揭示了一个重要的问题：系统花费了大量的时间把信息从一个地方挪到另一个地方。hello程序的机器指令最初是放在磁盘上，当程序加载时，它们被复制到主存；当处理器运行程序时，指令又从主存复制到处理器。相似地，数据串“hello, world\n”开始时在磁盘上，然后被复制到主存，最后从主存上复制到显式设备。从程序员的角度看，这些复制就是开销，减慢了程序“真正”的工作。但是这些复制操作又必不可少，系统设计者能做的就是让这些复制操作尽可能快地完成。</p>
<p>针对处理器与主存之间的差异（速度、容量、造价等等），系统设计者采用了更小更快的存储设备，称为高速缓存存储器（cache，高速缓存），作为暂时的集结区域，存放处理器近期可能会需要的信息。如下图所示：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC1%E7%AB%A0_6.png?raw=true" alt><br>高速缓存有可能分为多级：L1、L2、L3，即多个访问速度、容量不同的高速缓存存储器（L1最快容量最小）。高速缓存是用一种叫做静态随机访问存储器（SRAM）的硬件技术实现的。</p>
<p>通过多级高速缓存，系统可以获得一个很大的存储器，同时访问速度也很快，其实根本原因不只是在硬件上，更在于利用了高速缓存的局部性原理，即程序具有访问局部区域的数据和代码的趋势，通过让高速缓存里存放可能经常访问的数据，大部分的内存操作都能在快速的高速缓存中完成。</p>
<p>意识到高速缓存存在的应用程序员，能够利用高速缓存将程序性能提高一个数量级。</p>
<p><font size="5" color="orange">存储设备形成层次结构</font></p>
<hr>
<p>在处理器和一个较大较慢的设备（例如主存）之间插入一个更小更快的存储设备（例如高速缓存）的想法已经成为一个普遍的观念。所以，实际上每个计算机系统中的存储设备都被组织成了一个存储器层次结构：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC1%E7%AB%A0_7.png?raw=true" alt><br>从上至下，设备的访问速度越来越慢、容量越来越大，并且每字节的造价也越来越便宜。</p>
<p>存储器层次结构的主要思想是上一层的存储器作为低一层存储器的高速缓存。</p>
<p>正如可以运用不同的高速缓存的知识来提高程序性能一样，程序员同样可以利用对整个存储器层次结构的理解来提高程序性能。</p>
<p><font size="5" color="orange">操作系统管理硬件</font></p>
<hr>
<p>所有应用程序对硬件的操作尝试都必须通过操作系统。</p>
<p>操作系统有两个基本功能：1. 防止硬件被失控的应用程序滥用； 2. 向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。操作系统通过几个基本的抽象概念来实现这两个功能：文件（对I/O设备的抽象表示）、虚拟内存（对主存和磁盘I/O设备的抽象表示）、进程（对处理器、主存和I/O设备的抽象表示）。</p>
<p><font size="4" color="red">进程</font><br>进程是操作系统对一个正在运行的程序的一种抽象。在一个系统上每个进程都好像在独立地适用硬件。而并发运行，则是说一个进程的指令和另一个进程的指令是交错执行的。</p>
<p>下图展示了hello程序运行时的进程切换概念：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC1%E7%AB%A0_8.png?raw=true" alt><br>hello程序运行时有两个并发的进程：shell进程（A）和hello进程（B）。最开始，只有shell进程在运行，即等待命令行上的输入。当我们让它运行hello程序时，shell通过调用一个专门的函数，即系统调用，来执行我们的请求，系统调用会将控制权传递给操作系统。操作系统保存shell进程的上下文，创建一个新的hello进程及其上下文，然后将控制权传给新的hello进程。hello进程终止后，操作系统恢复shell进程的上下文，并将控制权传回给它，shell进程会继续等待下一个命令行输入。</p>
<p>如上图中所示，从一个进程到另一个进程的转换是由操作系统内核（kernel）管理的。内核是操作系统代码常驻主存的部分。注意，内核不是一个独立的进程。相反，它是系统管理全部进程所用代码和数据结构的集合。</p>
<p><font size="4" color="red">线程</font><br>在现代系统中，一个进程实际上可以由多个称为线程的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据。</p>
<p><font size="4" color="red">虚拟内存</font><br>虚拟内存是一个抽象概念，它为每个进程提供了一个假象，即每个进程都在独占地适用主存。每个进程看到的内存都是一致的，称为虚拟地址空间。下图是Linux进程的虚拟地址空间（图中的地址是从下往上增大的）：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC1%E7%AB%A0_9.png?raw=true" alt><br>每个进程看到的虚拟地址空间由大量准确定义的区构成，每个区都有专门的功能。我们从下往上介绍：</p>
<ul>
<li>程序代码和数据。对所有的进程来说，代码是从同一固定地址开始，紧接着的是和C全局变量相对应的数据位置。</li>
<li>堆。代码和数据区后紧随着的是运行时堆。代码和数据区在进程一开始运行时就被指定了固定大小，而堆可以在运行时动态地扩展和收缩（动态分配内存new、delete）。</li>
<li>共享库。大约在地址空间的中间部分是一块用来存放像C标准库和数学库这样的共享库的代码和数据的区域。</li>
<li>栈。位于用户虚拟地址空间顶部的是用户栈，编译器用它来实现函数调用。和堆一样，用户栈在程序执行期间可以动态地扩展和收缩（函数调用和返回时）。</li>
<li>内核虚拟内存。地址空间顶部的区域是为内核保留的。不允许应用程序读写这个区域的内容或者直接调用内核代码定义的函数。</li>
</ul>
<p><font size="4" color="red">文件</font><br>文件就是字节序列，仅此而已。每个I/O设备，包括磁盘、键盘、显示器，甚至网络，都可以看成是文件。系统中的所有输入输出都是通过使用一小组称为Unix I/O的系统函数调用读写文件来实现的。</p>
<p><font size="5" color="orange">系统之间利用网络通信</font></p>
<hr>
<p>我们可以使用telnet应用在一个远程主机上运行hello程序。过程如下图所示：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC1%E7%AB%A0_10.png?raw=true" alt></p>
<p><font size="5" color="orange">重要主题</font></p>
<hr>
<p><font size="4" color="red">Amdahl定律</font><br>Amdahl定律的主要思想是：当我们对系统的某个部分加速时，其对系统整体性能的影响取决于该部分的重要性和加速程度。要想显著加速整个系统，必须提升全系统中相当大的部分的速度（即优化系统的大部分组间才能获得较高的加速比）。</p>
<p>加速比的相关公式可以参考《深入理解计算机系统第三版》P16页。</p>
<p><font size="4" color="red">并发和并行</font><br>并发是指一个同时具有多个活动的系统，而并行是指用并发来使一个系统运行得更快。计算机系统中主要是三个层级的并发/并行：</p>
<ul>
<li><p>线程级并发：<br> 传统意义上，这种并发执行只是模拟出来的，是通过使一台计算机在它正在执行的进程间快速切换来实现的。</p>
<p>  多核处理器是将多个CPU（称为“核”）集成到一个集成电路芯片上。下图就是一个典型多核处理器的组织结构：<br>  <img src="https://github.com/Popperelay/Photos/blob/master/Photos/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC1%E7%AB%A0_11.png?raw=true" alt></p>
<p>  超线程，有时称为同时多线程（simultaneous multi-threading），是一项允许一个CPU执行多个控制流的技术。常规的处理器需要大约20000个时钟周期做不同线程间的转换，而超线程的处理器可以在单个周期的基础上决定要执行哪一个线程。举例来说，Intel Core i7处理器可以让每个核执行两个线程，所以一个4核的系统实际上可以并行执行8个线程。</p>
</li>
<li><p>指令级并行<br>在较低的抽象层次上，现代处理器可以同时执行多条指令的属性称为指令级并行。如果处理器可以达到比一个周期一条指令更快的执行速率，就称之为超标量处理器。大多数现代处理器都支持超标量操作。</p>
</li>
<li>单指令、多数据并行<br>在最低层次上，许多现代处理器拥有特殊的硬件，允许一条指令产生多个可以并行执行的操作，这种方式称为单指令、多数据，即SIMD并行。例如，较新几代的Intel和AMD处理器都具有并行地对8对单精度浮点数（C数据类型float）做加法的指令。<br>&nbsp; </li>
</ul>
<hr>
<p>参考文献：《深入理解计算机系统第三版》</p>

            </div>

            <!-- Post Comments -->
            
    <!-- 使用 DISQUS_CLICK -->
<div id="disqus-comment">
    <div id="disqus_thread"></div>

<!-- add animation -->
<style>
	.disqus_click_btn {
            line-height: 30px;
            margin: 0;
            min-width: 50px;
            padding: 0 14px;
            display: inline-block;
            font-family: "Roboto", "Helvetica", "Arial", sans-serif;
            font-size: 14px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0;
            overflow: hidden;
            will-change: box-shadow;
            transition: box-shadow .2s cubic-bezier(.4, 0, 1, 1), background-color .2s cubic-bezier(.4, 0, .2, 1), color .2s cubic-bezier(.4, 0, .2, 1);
            outline: 0;
            cursor: pointer;
            text-decoration: none;
            text-align: center;
            vertical-align: middle;
            border: 0;
            background: rgba(158, 158, 158, .2);
            box-shadow: 0 2px 2px 0 rgba(0, 0, 0, .14), 0 3px 1px -2px rgba(0, 0, 0, .2), 0 1px 5px 0 rgba(0, 0, 0, .12);
            color: #fff;
            background-color: #7EC0EE;
            text-shadow: 0
        }
</style>
	
<div class="btn_click_load" id="disqus_bt"> 
    <button class="disqus_click_btn">点击查看评论</button>
</div>

<!--
<script type="text/javascript">
$('.btn_click_load').click(function() {
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'http-miccall-tech'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    document.getElementById('disqus_bt').style.display = "none";
});
</script>
-->
<script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://yoursite.com/2018/04/21/深入理解计算机系统第一章计算机系统漫游/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = 'http://yoursite.com/2018/04/21/深入理解计算机系统第一章计算机系统漫游/'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
</script>

<script type="text/javascript">
    $('.btn_click_load').click(function() {  //click to load comments
        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document;
            var s = d.createElement('script');
            s.src = '//http-miccall-tech.disqus.com/embed.js';
            s.setAttribute('data-timestamp', + new Date());
            (d.head || d.body).appendChild(s);
        })();
        $('.btn_click_load').css('display','none');
    });
</script>
</div>
<style>
    #disqus-comment{
        background-color: #eee;
        padding: 2pc;
    }
</style>


        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
                <li>Design: <a href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
            </ul>
            
            	<span id="busuanzi_container_site_pv">2019总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			
        </div>
    </div>
</body>



 	
</html>
