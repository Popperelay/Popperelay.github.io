<!DOCTYPE HTML>
<html>

<head><meta name="generator" content="Hexo 3.9.0">
	<link rel="bookmark" type="image/x-icon" href="/img/logo_miccall.png">
	 <link rel="shortcut icon" href="/img/logo_miccall.png">
	
			
    <title>
    Elays'Blog
    </title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
	<script>
	(function(){
		if('{{ page.password }}'){
			if (prompt('请输入博客密码') !== "elayRender"){
				alert('密码错误！');
				window.close();
			}
		}
	})();
	</script>
    <link rel="stylesheet" href="/css/mic_main.css">
    <link rel="stylesheet" href="/css/dropdownMenu.css">
    
    	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css">
    </noscript>
			    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<link rel="stylesheet" href="/css/prism-dark.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>
    
		
<!-- Layouts -->


<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<!--<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">-->
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/latest.js?config=TeX-MML-AM_CHTML">
</script>

<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_undefined.css">
<link rel="stylesheet" href="/css/typo.css">
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">MICCALL</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special">
            <ul class="menu links">
			<!-- Homepage  主页  --> 
			<li>
	            <a href="/" rel="nofollow">主页</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">分类</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="/categories/C/">C#</a></li><li><a class="category-link" href="/categories/C-语法/">C#语法</a></li><li><a class="category-link" href="/categories/C/">C++</a></li><li><a class="category-link" href="/categories/C语言/">C语言</a></li><li><a class="category-link" href="/categories/Graphics/">Graphics</a></li><li><a class="category-link" href="/categories/Math/">Math</a></li><li><a class="category-link" href="/categories/OpenGL/">OpenGL</a></li><li><a class="category-link" href="/categories/Unity/">Unity</a></li><li><a class="category-link" href="/categories/Vulkan/">Vulkan</a></li><li><a class="category-link" href="/categories/博客配置/">博客配置</a></li><li><a class="category-link" href="/categories/并行计算/">并行计算</a></li><li><a class="category-link" href="/categories/操作系统/">操作系统</a></li><li><a class="category-link" href="/categories/数据结构/">数据结构</a></li><li><a class="category-link" href="/categories/毕设/">毕设</a></li><li><a class="category-link" href="/categories/游戏开发/">游戏开发</a></li><li><a class="category-link" href="/categories/计算机系统/">计算机系统</a></li><li><a class="category-link" href="/categories/设计模式/">设计模式</a></li><li><a class="category-link" href="/categories/面试/">面试</a>
	                    </li></ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/gallery/" title="图库">
		                图库
		            </a>
		        </li>
		        
		        <li>
		            <a href="/tag/" title="搜索">
		                搜索
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
		            
		                <li><a href="https://github.com/miccall" class="icon fa-github"><span class="label">GitHub</span></a></li>
		            
		            
		            
		            
			</ul>
</nav>

        <div id="main">
            <div class="post_page_title_img" style="height: 25rem;background-image: url(https://github.com/Popperelay/Photos/blob/master/Photos/Open39PBR%E7%90%86%E8%AE%BA_BG.jpg?raw=true);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;">
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2>OpenGL39 PBR理论</h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
				<!-- 目录 -->
				<p class="show-toc-btn" id="show-toc-btn" onclick="showToc();" style="display:none">
				<span class="btn-bg"></span>
				<span class="btn-text">文章导航</span>
				</p>
				<div id="toc-article" class="toc-article">
					<span id="toc-close" class="toc-close" title="隐藏导航" onclick="showBtn();">×</span>
					<strong class="toc-title">文章目录</strong>
					<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#微平面模型"><span class="toc-text">微平面模型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#能量守恒"><span class="toc-text">能量守恒</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#反射率方程"><span class="toc-text">反射率方程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#辐射通量"><span class="toc-text">辐射通量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#立体角"><span class="toc-text">立体角</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#辐射强度"><span class="toc-text">辐射强度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#辐射率"><span class="toc-text">辐射率</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#辐照度"><span class="toc-text">辐照度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#反射率方程的含义"><span class="toc-text">反射率方程的含义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#黎曼和近似求解积分"><span class="toc-text">黎曼和近似求解积分</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#BRDF"><span class="toc-text">BRDF</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Cook-Torrance-BRDF模型"><span class="toc-text">Cook-Torrance BRDF模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#正态分布函数"><span class="toc-text">正态分布函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#几何函数"><span class="toc-text">几何函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#菲涅尔方程"><span class="toc-text">菲涅尔方程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Cook-Torrance反射率方程"><span class="toc-text">Cook-Torrance反射率方程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#编写PBR材质"><span class="toc-text">编写PBR材质</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#延伸阅读"><span class="toc-text">延伸阅读</span></a></li></ol>
			   </div>
			   <script type="text/javascript">
				function showToc(){
					var toc_article = document.getElementById("toc-article");
					var show_toc_btn = document.getElementById("show-toc-btn");
					toc_article.setAttribute("style","display:block");
					show_toc_btn.setAttribute("style","display:none");
					};
				function showBtn(){
					var toc_article = document.getElementById("toc-article");
					var show_toc_btn = document.getElementById("show-toc-btn");
					toc_article.setAttribute("style","display:none");
					show_toc_btn.setAttribute("style","display:block");
					};
			   </script>
				
                <p>PBR（Physical Based Rendering，基于物理的渲染），指的是一些渲染技术的集合，这些渲染技术在不同程度上都基于与现实世界的物理原理更相符的基本理论。正因为PBR的目的就是为了使用一种更符合物理学规律的方式来模拟光线，所以它比Phong或者Blinn-Phong看起来更真实一些。</p>
<p>但是，PBR仍然只是现实世界物理原理的一种近似，所以才是基于物理着色，而不是直接叫物理着色。PBR必须满足三个条件：</p>
<ol>
<li>基于微平面（microfacet）的表面模型。</li>
<li>能量守恒。</li>
<li>应用基于物理的BRDF（双向反射分布函数）。</li>
</ol>
<h1 id="微平面模型"><a href="#微平面模型" class="headerlink" title="微平面模型"></a><font size="6" color="orange">微平面模型</font></h1><hr>
<p>所有的PBR技术都基于微平面理论：达到微观尺度之后任何平面都可以用被称为微平面（microfacets）的细小镜面来进行描绘。根据平面粗糙程度的不同，这些细小镜面的取向排列可以相当不一致，如下图所示：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/Open39PBR%E7%90%86%E8%AE%BA_1.png?raw=true" alt><br>一个平面越粗糙，这个平面上的微平面的排列就越混乱。从而导致，在发生镜面光/镜面反射时，入射光线更趋向于向完全不听的方向发散（Scatter）开来，进而产生出分布范围更广泛的镜面反射。而对于一个光滑的平面，光线大体上会更趋向于同一个方向反射，造成更小更锐利的反射：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/Open39PBR%E7%90%86%E8%AE%BA_2.png?raw=true" alt><br>在微观尺度下，没有任何平面是完全光滑的。然而由于这些微平面已经微小到无法逐像素的继续对其进行区分，因此我们只有假设一个粗糙度（Roughness）参数，然后用统计学的方法来概率地估算微平面的粗糙程度。我们可以基于一个平面的粗糙度来计算出半程向量的方向与微平面平均取向方向一致的概率。这个半程向量就是Blinn-Phong光照中的半程向量：由光线入射向量$l$和观察向量$v$来计算：<br>$$h=\frac{l+v}{||l+v||}$$<br>微平面的取向方向与半程向量的方向越是一致，镜面反射的效果就越是锐利。半程向量再加上一个介于0到1之间的粗糙度参数，我们可以概略地估算出微平面的取向。<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/Open39PBR%E7%90%86%E8%AE%BA_3.png?raw=true" alt><br>我们可以看到，较高的粗糙度值显示出来的镜面反射的轮廓要更大一些，较小的粗糙值显示出的镜面反射轮廓则更小更锐利。</p>
<h1 id="能量守恒"><a href="#能量守恒" class="headerlink" title="能量守恒"></a><font size="6" color="orange">能量守恒</font></h1><hr>
<p>微平面近似法使用了这样一种形式的能量守恒（Energy Conservation）：出射光线的能量永远不能超过入射光线的能量（发光面除外）。在上面图中我们可以看到，随着粗糙度的上升镜面反射区域会增加，但是镜面反射的亮度却会下降。这也刚好符合能量守恒的定律。</p>
<p>为了遵循能量守恒定律，我们需要对漫反射光和镜面反射光之间做出明确的区分。当一束光线碰到一个表面的时候，它就会分离成一个折射部分和一个反射部分。反射部分就是会直接反射开来而不会进入平面的那部分光线，这就是我们所说的镜面光照。而折射部分就是余下的会进入表面并被吸收的那部分光线，这也就是我们所说的漫反射光照。</p>
<p>当光线接触到一个表面的时候，折射光是不会立即就被吸收的。通过物理学我们可以得知，光线实际上是可以被认为是一束没有耗尽就不停向前运动的能量，而光束是通过碰撞的方式来消耗能量。每一种材料都是由无数微小的粒子所组成，这些粒子都能如下图所示一样与光线发生碰撞。这些粒子在每次的碰撞中都可以吸收光线所携带的一部分或者是全部的能量而后转变成为热量。<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/Open39PBR%E7%90%86%E8%AE%BA_4.png?raw=true" alt><br>一般来说，并非所有能量都会被全部吸收，而光线也会继续沿着（基本上）随机的方向发散，然后再和其他粒子碰撞直至能量完全耗尽或者再次离开这个表面。而光线脱离物体表面后将会协同构成该表面的漫反射颜色。不过在基于物理的渲染之中我们进行了简化，假设对平面上的每一点所有的折射光都会被完全吸收而不会散开。而有一些被称为次表面散射（Subsurface Scattering）技术的着色器技术将这个问题考虑了进去，它们显著提升了一些诸如皮肤、大理石或者蜡质这样材质的视觉效果，当然也会降低性能。</p>
<p>对于金属（Metallic）表面，当讨论到反射与折射的时候还有一个细节需要注意。<strong>金属表面对所有的折射光都会被直接吸收而不会散开</strong>，只留下反射光或者说镜面反射光。也就是说，<strong>金属表面不会显示出漫反射颜色</strong>。所以在PBR渲染管线中，通常会将金属与电介质区别处理。</p>
<p>反射光与折射光之间的这个区别，使我们得到了另一条关于能量守恒的经验结论：反射光与折射光它们二者之间是互斥的关系。无论何种光线，其被材质表面所反射的能量将无法再被材质吸收。因此，诸如折射光这样的余下的进入表面之中的能量正好就是我们计算完反射之后余下的能量。</p>
<p>我们按照能量守恒的关系，首先计算镜面反射部分，它的值等于入射光线被反射的能量所占的百分比。然后折射部分就可以直接有镜面反射部分计算得出：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">float</span> kS <span class="token operator">=</span> <span class="token function">calculateSpecularComponent</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 反射/镜面反射 部分</span>
<span class="token keyword">float</span> kD <span class="token operator">=</span> <span class="token number">1.0</span> <span class="token operator">-</span> ks<span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 折射/漫反射 部分</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>这样一来，镜面反射和折射的能量总和就不会超过1.0了（即不会超过入射光线的能量）。</p>
<h1 id="反射率方程"><a href="#反射率方程" class="headerlink" title="反射率方程"></a><font size="6" color="orange">反射率方程</font></h1><hr>
<p>渲染方程（Render Equation）是如今我们用来模拟光的视觉效果最好的模型。基于物理的渲染遵循着渲染方程的一个特例化版本：反射率方程（The Reflection Equation）：<br>$$L_o(p,\omega_o)=\int_{\Omega}f_r(p,\omega_i,\omega_o)L_i(p,w_i)n\cdot \omega_id\omega_i$$<br>要正确理解这个方程式，我们必须要涉足一些辐射度量学（Radiometry）的内容。辐射度量学是一种用来度量电磁场辐射（包括可见光）的手段。其中辐射率（Radiance）$L$可以用来量化单一方向上发射来的光线的大小或者强度。由于辐射率是由许多物理变量集合而成的，所以我们需要先关注一下这些物理量：</p>
<h2 id="辐射通量"><a href="#辐射通量" class="headerlink" title="辐射通量"></a><font size="5" color="red">辐射通量</font></h2><p>辐射通量（Radiant flux）$\Phi$表示的是一个光源所输出的能量，以瓦特为单位。也就是光源所发出的不同波长的能量总和。通常我们不直接使用波长的强度来表示辐射通量，而是直接使用三原色RGB（虽然会带来一些信息损失，但是对视觉效果的影响几乎可以忽略）。</p>
<h2 id="立体角"><a href="#立体角" class="headerlink" title="立体角"></a><font size="5" color="red">立体角</font></h2><p>立体角（Solid Angle）用$\omega$表示，它可以为我们描述投射到单位球体上的一个截面的大小或者面积。投射到这个单位球体上的截面的面积就被称为立体角。可以把立体角想象称为一个带有体积的方向，如下图所示：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/Open39PBR%E7%90%86%E8%AE%BA_5.png?raw=true" alt><br>可以把自己想象称为一个站在单位球面的中心的管擦着，向着投影的方向看。这个投影轮廓的大小就是立体角。</p>
<h2 id="辐射强度"><a href="#辐射强度" class="headerlink" title="辐射强度"></a><font size="5" color="red">辐射强度</font></h2><p>辐射强度（Radiant Intensity）表示的是在单位球面上，一个光源向每单位立体角所投送的辐射通量。举例来说，假设一个全向光源向所有方向均匀的辐射能量，辐射强度就能帮我们就算出它在一个单位面积（立体角）内的能量大小，即计算辐射强度的公式如下：<br>$$I=\frac{d\Phi}{d\omega}$$<br>其中$I$表示辐射通量$\Phi$除以立体角$\omega$。</p>
<h2 id="辐射率"><a href="#辐射率" class="headerlink" title="辐射率"></a><font size="5" color="red">辐射率</font></h2><p>了解了这些之后，我们就可以看一下什么是<strong>辐射率</strong>了。辐射率（Radiance）实际上表示的是：一个拥有辐射通量$\Phi$的光源在单位面积$A$、单位立体角$\omega$上辐射出的总能量：<br>$$L=\frac{d^2\Phi}{dAd\omega~cos\theta}$$<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/Open39PBR%E7%90%86%E8%AE%BA_6.png?raw=true" alt><br>辐射率是辐射度量学上表示一个区域平面上光线总量的物理量，它受到入射（Incident）光线与平面法线间的夹角$\theta$的余弦值$cos\theta$的影响：当直接辐射到平面上的程度越低时，光线就越弱，而当光线完全垂直于平面时强度最高。其中$cos\theta$就是入射光线向量和平面法向量的点积：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">float</span> cosTheta <span class="token operator">=</span> <span class="token function">dot</span><span class="token punctuation">(</span>lightDir<span class="token punctuation">,</span> N<span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>如果我们把立体角$\omega$和面积$A$看作是无穷小的，那么我们就能用辐射率来表示单束光线穿过空间中的一个点的通量。这就使我们可以计算得出作用于单个（片段）点上的单束光线的辐射率，实际上我们通常是把立体角$\omega$转变为方向向量$\omega$，然后把面$A$转换为点$p$。这样我们就能直接在着色器里使用辐射率来计算单束光线对每个片段的作用了。</p>
<h2 id="辐照度"><a href="#辐照度" class="headerlink" title="辐照度"></a><font size="5" color="red">辐照度</font></h2><p>事实上，当涉及到辐射率时，我们通常关心的是所有投射到点$p$上的光线的总和，而这个总和就称为辐照度（Irradiance）。</p>
<h2 id="反射率方程的含义"><a href="#反射率方程的含义" class="headerlink" title="反射率方程的含义"></a><font size="5" color="red">反射率方程的含义</font></h2><p>了解了辐射率和辐照度之后，我们再来看一下反射率方程：<br>$$L_o(p,\omega_o)=\int_{\Omega}f_r(p,\omega_i,\omega_o)L_i(p,\omega_i)n\cdot \omega_id\omega_i$$<br>我们知道在渲染方程中，$L$代表通过某个无限小的立体角在某个点上的辐射率，而立体角可以视作是入射方向向量$\omega_i$。我们使用入射光线和平面法线之间夹角的余弦值来计算反射能量，即公式中的$n\cdot \omega_i$。$\omega_o$表示观察方向，也就是出射方向。反射率公式计算了点$p$在观察方向$\omega_o$上被反射出来的辐射率的总和$L_o(p,\omega_o)$。也就是说：$L_o$表示了从$\omega_o$方向上观察，光线投射到点$p$上反射出来的辐照度。</p>
<p>再通俗地解释一下：$L_o$表示的是从$\omega_o$方向观察点$p$时的颜色（辐照度），$f_r(p,\omega_i,\omega_o)$表示在点$p$上，从$\omega_o$方向反射出去的光照占从$\omega_i$方向入射进来的光照的比例，$L_i(p,\omega_i)$就表示从$\omega_i$方向入射到点$p$的光照（或者叫辐射率），$n\cdot\omega_i$表示的是光照的反射强度和光线入射方向与法线之间的夹角的关系（通常都是关系入射方向越靠近法线，反射强度会越大），$\int_{\Omega}…d\omega_i$表示在以点$p$的法线为轴的半球内，对所有入射光线的积分。</p>
<h2 id="黎曼和近似求解积分"><a href="#黎曼和近似求解积分" class="headerlink" title="黎曼和近似求解积分"></a><font size="5" color="red">黎曼和近似求解积分</font></h2><p>因为反射率公式是基于物体表面上点$p$的辐照度来计算的，所以我们需要计算的就不只是单一的一个方向上的入射光，而是一个以点$p$为球心的半球领域$\Omega$内所有方向上的入射光。这个半球领域（Hemisphere）可以描述为以平面法线$n$为轴所环绕的半个球体：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/Open39PBR%E7%90%86%E8%AE%BA_7.png?raw=true" alt><br>反射率公式中存在积分$\int$，它的运算包含了半球领域$\Omega$内所有入射方向上的$d\omega_i$。积分运算的值等于一个函数曲线的面积，它的计算结果要么是解析解，要么就是数值解。由于渲染方程和反射率方程都没有解析解，所以我们会用离散的方法来求得这个积分的数值解：在半球领域$\Omega$中按一定的步长将反射率方程分散求解，然后再按照步长大小将所得到的结果平均化。这种方法被称为黎曼和（Riemann sum），可以用下面的代码粗略的演示一下用黎曼和求解这个积分的过程：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> steps <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
<span class="token keyword">float</span> sum <span class="token operator">=</span> <span class="token number">0.0f</span><span class="token punctuation">;</span>
vec3 P    <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
vec3 Wo   <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
vec3 N    <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
<span class="token keyword">float</span> dW  <span class="token operator">=</span> <span class="token number">1.0f</span> <span class="token operator">/</span> steps<span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> steps<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    vec3 Wi <span class="token operator">=</span> <span class="token function">getNextIncomingLightDir</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    sum <span class="token operator">+</span><span class="token operator">=</span> <span class="token function">Fr</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> Wi<span class="token punctuation">,</span> Wo<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token function">L</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> Wi<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token function">dot</span><span class="token punctuation">(</span>N<span class="token punctuation">,</span> Wi<span class="token punctuation">)</span> <span class="token operator">*</span> dW<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>通过利用<code>dW</code>来对所有离散部分进行缩放，其和最后就等于积分函数的总面积或者总体积。这个用来对每个离散步长进行缩放的<code>dW</code>可以认为就是反射率方程中的$d\omega_i$。使用离散步长得到的是函数总面积的一个近似值，可以通过增加离散部分的数量来提高黎曼和近似求解积分的准确度。</p>
<p>反射率方程概括了在半球领域$\Omega$内，碰撞到了点$p$上的所有入射方向$\omega_i$上的光线的辐射率，并受到$f_r$的约束，然后返回观察方向上反射光的$L_o$。</p>
<p>入射光的辐射率$L_i$可以由光源处获得，此外还可以利用一个环境贴图来测算所有入射方向上的辐射率。这样一来辐射率方程中剩下的未知符号就只剩$f_r$了，它被称为BRDF（Bidirectional Reflective Distribution Function，双向反射分布函数），它的作用是基于表面材质属性来对入射辐射率$L_i$进行缩放或者加权。</p>
<h1 id="BRDF"><a href="#BRDF" class="headerlink" title="BRDF"></a><font size="6" color="orange">BRDF</font></h1><hr>
<p>BRDF（双向反射分布函数），它接受入射光方向$\omega_i$、出射（观察）方向$\omega_o$、平面法线$n$以及一个用来表示微平面粗糙程度的参数$a$作为函数的输入参数。BRDF可以近似的求出每束光线在一个给定了材质属性的平面上，最终反射出来的光线所作出的贡献程度。例如，如果一个平面拥有完全光滑的表面（比如镜面），那么几乎对于所有的入射光线$\omega_i$而言BRDF函数都会返回0.0，只有一束反射角度完全等于$\omega_o$的光线才会得到1.0这个返回值。</p>
<p>BRDF基于我们之前所探讨过的微平面理论来近似的求得材质的反射与折射属性。对于一个BRDF，为了实现物理学上的可信度，它必须遵守能力守恒定律，也就是说反射光线的总和永远不能超过入射光线的总和。严格上来说，同样采用$\omega_i$和$\omega_o$作为输入参数的Blinn-Phong光照模型也被认为是一个BRDF，但是Blinn-Phong模型并没有遵循能量守恒定律，因此它不被认为是基于物理的渲染。</p>
<h2 id="Cook-Torrance-BRDF模型"><a href="#Cook-Torrance-BRDF模型" class="headerlink" title="Cook-Torrance BRDF模型"></a><font size="5" color="red">Cook-Torrance BRDF模型</font></h2><p>如今已经有很好的几种BRDF都能近似的得出物体表面对于光的反应，但是几乎所有实时渲染管线使用的都是一种被称为Cook-Torrance BRDF的模型。该模型兼有漫反射和镜面反射两个部分：<br>$$f_r=k_df_{lambert}+k_sf_{cook-torrance}$$<br>其中$k_d$是之前提到过的入射光线中被折射部分的能力所占的比率，而$k_s$是被反射部分的比率。加号左侧表示的是漫反射部分，用$f_{lambert}$表示，它被称为Lambertian漫反射，$f_{lambert}$类似以前漫反射中使用的常数因子，用如下公式来表示：<br>$$f_{lambert}=\frac{c}{\pi}$$<br>$c$表示物体表面颜色，除以$\pi$是为了对漫反射光进行标准化（因为前面含有BRDF的积分方程是受$\pi$影响的）。</p>
<blockquote>
<p>Lambertian漫反射和我们之前经常使用的漫反射有什么关系？之前我们是用表面法向量与光照方向向量之间进行点乘，然后再将结果与平面颜色相乘得到漫反射参数。点乘依然还在，但是却不在BRDF之内，而是转变成为了$L_o$积分公式末尾处的$n\cdot \omega_i$。</p>
</blockquote>
<p>目前存在这许多不同类型的模型来实现BRDF的漫反射部分，不过它们更真实的同时也带来了昂贵的运算开销。不过Lambertian漫反射模型已经足够应付大多数实时渲染的用途了。</p>
<p>Cook-Torrance BRDF的镜面反射部分如下：<br>$$f_{cook-torrance}=\frac{DFG}{4(\omega_o\cdot n)(\omega_i \cdot n)}$$<br>该镜面反射部分包含三个函数（DFG），以及分母部分的一个标准化因子。D、F、G分别代表着一种类型的函数，分别用来近似计算出表面反射特性的一个特定部分。三个函数分别为正态分布函数、菲涅尔方程和几何函数：</p>
<ul>
<li>正态分布函数（Normal distribution function）：估算在受到表面粗糙度的影响下，取向方向与半程向量一致的微平面数量。这是用来估算微平面的主要函数。</li>
<li>几何函数（Geometry function）：描述了微平面自成阴影的属性。当一个平面相对比较粗糙的时候，平面表面上的微平面有可能挡住其他的微平面从而减少表面所反射的光线。</li>
<li>菲涅尔方程（Fresnel equation）：它描述的是在不同观察角度下（即不同的$\omega_o$）表面反射光线所占的比率。</li>
</ul>
<p>上面的每一种函数都是用来估算相应的物理参数的，每种函数都有很多种形式，有的真实感很好，有的性能高效。Epic Games（美国一家游戏公司）对于这些函数的多种近似实现方式进行了大量的<a href="http://graphicrants.blogspot.nl/2013/08/specular-brdf-reference.html" target="_blank" rel="noopener">研究</a>。我们在这里介绍Epic Games在Unreal Engine 4中所使用的函数：D使用Trowbridge-Reitz GGX，F使用Fresnel-Schlick近似，G使用Smith’s Schlick-GGX。</p>
<h3 id="正态分布函数"><a href="#正态分布函数" class="headerlink" title="正态分布函数"></a><font size="4" color="red">正态分布函数</font></h3><p>正态分布函数D（或者所NDF），从统计学上近似的表示了与某些（半程）向量$h$取向一致的微平面的比率。例如，给定向量$h$，如果我们的微平面中有35%与向量$h$取向一致，则正态分布函数NDF将会返回0.35。</p>
<p>Trowbridge-Reitz GGX正态分布函数可以从统计学上来估算微平面的总体取向度，形式如下：<br>$$NDF_{GGXTR}(n,h,\alpha)=\frac{\alpha^2}{\pi((n\cdot h)^2(\alpha^2-1)+1)^2}$$<br>其中$h$表示用来与微平面取向做比较用的半程向量，$\alpha$表示表面粗糙度。</p>
<p>通俗地来说，如果给GGX正态分布函数传入的$n$是宏观表面的法线，那么该函数就描述了有多少微平面的法线接近该宏观表面法线，越多的话高光区域就越亮，亮斑越小，反之就越暗，亮斑逐渐扩散。所以正态分布函数$D$返回的是一个标量。</p>
<p>在shader中编写的Trowbridge-Reitz GGX正态分布函数是下面这个样子的：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">float</span> <span class="token function">D_GGX_TR</span><span class="token punctuation">(</span>vec3 N<span class="token punctuation">,</span> vec3 H<span class="token punctuation">,</span> <span class="token keyword">float</span> a<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">float</span> a2     <span class="token operator">=</span> a<span class="token operator">*</span>a<span class="token punctuation">;</span>
    <span class="token keyword">float</span> NdotH  <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token function">dot</span><span class="token punctuation">(</span>N<span class="token punctuation">,</span> H<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">float</span> NdotH2 <span class="token operator">=</span> NdotH<span class="token operator">*</span>NdotH<span class="token punctuation">;</span>

    <span class="token keyword">float</span> nom    <span class="token operator">=</span> a2<span class="token punctuation">;</span>
    <span class="token keyword">float</span> denom  <span class="token operator">=</span> <span class="token punctuation">(</span>NdotH2 <span class="token operator">*</span> <span class="token punctuation">(</span>a2 <span class="token operator">-</span> <span class="token number">1.0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    denom        <span class="token operator">=</span> PI <span class="token operator">*</span> denom <span class="token operator">*</span> denom<span class="token punctuation">;</span>

    <span class="token keyword">return</span> nom <span class="token operator">/</span> denom<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="几何函数"><a href="#几何函数" class="headerlink" title="几何函数"></a><font size="4" color="red">几何函数</font></h3><p>几何函数从统计学上近似的求得了微平面间相互遮蔽的比率，这种相互遮蔽会损耗光线的能量。<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/Open39PBR%E7%90%86%E8%AE%BA_8.png?raw=true" alt><br>与NDF类似，几何函数采用表面粗糙度作为输入参数，粗糙度较高的表面其微平面间相互遮蔽的概率就较高。</p>
<p>Schlick-GGX几何函数如下：<br>$$G_{SchlickGGX}(n,v,k)=\frac{n\cdot v}{(n\cdot v)(1-k)+k}$$<br>其中$k$是粗糙度$\alpha$的重映射，将几何函数用于直接光照或者IBL光照时，这个重映射是不同的：<br>$$<br>k_{direct}=\frac{(\alpha+1)^2}{8} \<br>k_{IBL}=\frac{\alpha^2}{2}<br>$$</p>
<p>为了有效地估算几何部分，需要将光线入射方向向量$l$（几何阴影，Shadow，即入射光线可能被一些其他表面遮挡住）和观察方向$v$（几何遮蔽，Mask，即反射出去的光线也可能会被其他表面遮挡住）都考虑进去。我们可以结合史密斯法（Smith’s method）来把两者都纳入其中：<br>$$G(n,v,l,k)=G_{sub}(n,v,k)G_{sub}(n,l,k)$$<br>结合史密斯法和Schlick-GGX得到的就是最终的Smith’s Schlick-GGX几何函数，使用它可以得到如下图所示的不同粗糙度的视觉效果：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/Open39PBR%E7%90%86%E8%AE%BA_9.png?raw=true" alt><br>几何函数返回的是一个在[0.0, 1.0]之间的标量，其中白色或者说1.0表示没有微平面阴影，而黑色或者说0.0表示微平面彻底被遮蔽。</p>
<p>在shader中编写的Smith’s Schlick-GGX几何函数如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">float</span> <span class="token function">GeometrySchlickGGX</span><span class="token punctuation">(</span><span class="token keyword">float</span> NdotV<span class="token punctuation">,</span> <span class="token keyword">float</span> k<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">float</span> nom   <span class="token operator">=</span> NdotV<span class="token punctuation">;</span>
    <span class="token keyword">float</span> denom <span class="token operator">=</span> NdotV <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">1.0</span> <span class="token operator">-</span> k<span class="token punctuation">)</span> <span class="token operator">+</span> k<span class="token punctuation">;</span>

    <span class="token keyword">return</span> nom <span class="token operator">/</span> denom<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">float</span> <span class="token function">GeometrySmith</span><span class="token punctuation">(</span>vec3 N<span class="token punctuation">,</span> vec3 V<span class="token punctuation">,</span> vec3 L<span class="token punctuation">,</span> <span class="token keyword">float</span> k<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">float</span> NdotV <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token function">dot</span><span class="token punctuation">(</span>N<span class="token punctuation">,</span> V<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">float</span> NdotL <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token function">dot</span><span class="token punctuation">(</span>N<span class="token punctuation">,</span> L<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">float</span> ggx1 <span class="token operator">=</span> <span class="token function">GeometrySchlickGGX</span><span class="token punctuation">(</span>NdotV<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">float</span> ggx2 <span class="token operator">=</span> <span class="token function">GeometrySchlickGGX</span><span class="token punctuation">(</span>NdotL<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> ggx1 <span class="token operator">*</span> ggx2<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="菲涅尔方程"><a href="#菲涅尔方程" class="headerlink" title="菲涅尔方程"></a><font size="4" color="red">菲涅尔方程</font></h3><p>菲涅尔方程描述的是反射光线对比入射光线的比率（也就是镜面反射在入射光线中所占的比例），这个比率会随着我们观察的角度不同而不同。当光线碰到一个表面时，菲涅尔方程会根据观察角度告诉我们被反射的光线所占的百分比。利用这个反射比率和能力守恒原则，我们可以直接得出折射光线的比率。</p>
<p>当垂直观察的时候，任何物体或者材质表面都有一个基础反射率（Base Reflectivity），但是如果以一定的角度往平面上看的时候所有反光都会变得明显起来。观察方向越靠近表面法线方向折射效果越明显，反之反射效果越明显，这被称之为菲涅尔现象（可以想象在观察水面的时候，垂直看向水面，我们越能清晰地看到水下的物体（源于折射光线比较多），而以水面平行的方向去看，就很难看到水下的物体了）。</p>
<p>菲涅尔方程是一个相对复杂的方程式，不过我们可以用Fresnel-Schlick方法来求得近似解：<br>$$F_{Schlick}(n,v,F_0)=F_0+(1-F_0)(1-(n\cdot v))^5$$<br>其中$F_0$表示平面的基础反射率，它是利用所谓的折射指数（Indices of Refraction）计算得出的。</p>
<p>下表列出了一些材质表面的基础反射率：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/Open39PBR%E7%90%86%E8%AE%BA_10.png?raw=true" alt><br>可以观察到，几乎所有电介质（相当于非金属）材质表面的基础反射率都不会高于0.17，而导体材质表面的基础反射率通常在0.5到1.0之间变化。此外，对于导体或者金属表面而言，基础反射率一般是带有色彩的，因为不同波长的光线，照射到同一个物体表面的时候，反射和折射的比例并不总是相同的，所以我们要用RGB三原色来表示$F_0$（也是菲涅尔函数返回三元向量的原因）。</p>
<p>由于金属表面会吸收所有折射光线而没有漫反射，所以我们可以直接使用其表面颜色纹理来作为它们的基础反射率，但是电介质不可以。所以我们引入一个叫金属度（Metalness）的参数，来描述一个材质表面是金属的还是非金属的。在shader里面用代码表示是这样的：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">vec3 F0 <span class="token operator">=</span> <span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">0.04</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
F0      <span class="token operator">=</span> <span class="token function">mix</span><span class="token punctuation">(</span>F0<span class="token punctuation">,</span> surfaceColor<span class="token punctuation">.</span>rgb<span class="token punctuation">,</span> metalness<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>对于大多数电介质表面而言使用0.04作为基础反射率已经足够好了，可以在不需要输入额外表面参数的情况下得到物理可信的结果。所以对于金属表面，上面代码的金属度是1.0，最终得到基础反射率<code>F0</code>就是表面颜色；而对于电介质表面金属度是0.0，最终得到的基础反射率<code>F0</code>就是0.04。</p>
<p>然后Fresnel-Schlick近似菲涅尔方程可以用代码表示为：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">vec3 <span class="token function">fresnelSchlick</span><span class="token punctuation">(</span><span class="token keyword">float</span> cosTheta<span class="token punctuation">,</span> vec3 F0<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> F0 <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">1.0</span> <span class="token operator">-</span> F0<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">1.0</span> <span class="token operator">-</span> cosTheta<span class="token punctuation">,</span> <span class="token number">5.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中<code>cosTheta</code>是表面法向量$n$和观察向量$v$的点乘的结果。</p>
<blockquote>
<p>理论上来说，一个表面的金属度应该是二元的：要么是金属，要么不是金属。但是，大多数的渲染管线都运行在0.0到1.0之间线性的调配金属度。这主要是由于材质纹理精度不足以描述一个拥有诸如细沙/刮痕的金属表面，通过对这些小的非金属粒子/刮痕调整金属度值，我们可以获得非常好看的视觉效果。</p>
</blockquote>
<h2 id="Cook-Torrance反射率方程"><a href="#Cook-Torrance反射率方程" class="headerlink" title="Cook-Torrance反射率方程"></a><font size="5" color="red">Cook-Torrance反射率方程</font></h2><p>已经了解了cook-Torrance BRDF中的所有元素，现在我们可以将cook-Torrance BRDF纳入到最终的反射率方程中去了：<br>$$L_o(p,\omega_o)=\int_\Omega(k_d\frac{c}{\pi}+k_s\frac{DFG}{4(\omega_o\cdot n)(\omega_i\cdot n)})L_i(p,\omega_i)n\cdot \omega_id\omega_i$$<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/Open39PBR%E7%90%86%E8%AE%BA_10_2.png?raw=true" alt><br>这个方程现在完整地描述了一个基于物理的渲染模型，它现在可以认为就是我们一般意义上理解的基于物理的渲染，即PBR。</p>
<h1 id="编写PBR材质"><a href="#编写PBR材质" class="headerlink" title="编写PBR材质"></a><font size="6" color="orange">编写PBR材质</font></h1><hr>
<p>PBR渲染管线所需要的每一个表面参数都可以用纹理来定义或者建模。使用纹理可以让我们逐个片段的来控制每个表面上特定的点对于光线是如何响应（或者说叫反射）的：不论那个点金属的、粗糙或者平滑。</p>
<p>下面是在一个PBR渲染管线中经常会碰到的纹理列表，以及将它们输入PBR渲染器所能得到的相应的视觉输出：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/Open39PBR%E7%90%86%E8%AE%BA_11.png?raw=true" alt></p>
<ul>
<li>反射率（Albedo）纹理：它为每一个像素指定其基础反射率（如果是金属表面的话，指定的就是金属表面的颜色）。</li>
<li>法线（Normal）纹理：它使我们可以逐片段地指定独特的法线，来为表面制造出凹凸不平的假象。</li>
<li>金属度（Metalness）纹理：它逐个纹素地指定该纹素是不是金属质地的。</li>
<li>粗糙度（Roughness）纹理：它可以以纹素为单位指定某个表面有多粗糙。采样出来的粗糙度数值会影响一个表面的微平面统计学上的取向度。一个比较粗糙的表面会得到范围更大更模糊的镜面反射（高光），而一个比较光滑的表面则会得到集中而清晰的镜面反射。</li>
<li>AO（Ambient Occlusion，环境光遮蔽）贴图：它为表面和周围潜在的几何图形指定了一个额外的阴影因子。比如如果我们有一个砖块表面，反射率纹理上的砖块裂缝部分应该没有任何阴影信息。然而AO贴图则会把那些光线较难逃逸出来的暗色边缘指定出来。在光照的结尾阶段引入环境遮蔽可以明显地提升场景的视觉效果（网格/表面的环境遮蔽贴图要么通过手动生成，要么由3D建模软件自动生成）。</li>
</ul>
<p>美术师们可以在纹素级别设置或调整这些基于物理的输入值，还可以以现实世界材料的表面物理性质来建立他们的材质数据。这是PBR渲染管线最大的优势之一，因为无论环境或者光照的设置如何改变，这些表面的性质是不会改变的，这使得美术师们可以更便捷地获取到物理可信的结果。</p>
<h1 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a><font size="6" color="orange">延伸阅读</font></h1><hr>
<ul>
<li><a href="http://blog.selfshadow.com/publications/s2013-shading-course/hoffman/s2013_pbs_physics_math_notes.pdf" target="_blank" rel="noopener">Background: Physics and Math of Shading by Naty Hoffmann</a>：如果想要了解更多关于光线背后的物理知识以及它们和PBR理论之间有什么联系的话，可以参考这篇文章。</li>
<li><a href="http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf" target="_blank" rel="noopener">Real shading in Unreal Engine 4</a>：这里探讨了Epic Games在他们的Unreal 4引擎中所采用的PBR模型。</li>
<li><a href="https://www.marmoset.co/toolbag/learn/pbr-theory" target="_blank" rel="noopener">Marmoset: PBR Theory</a>：主要针对美术师的PBR介绍。</li>
<li><a href="http://www.codinglabs.net/article_physically_based_rendering.aspx" target="_blank" rel="noopener">Coding Labs: Physically based rendering</a>：介绍渲染方程以及它和PBR直接的关系。</li>
<li><a href="http://www.codinglabs.net/article_physically_based_rendering_cook_torrance.aspx" target="_blank" rel="noopener">Coding Labs: Physically Based Rendering - Cook–Torrance</a>：介绍了Cook-Torrance BRDF。</li>
<li><a href="http://blog.wolfire.com/2015/10/Physically-based-rendering" target="_blank" rel="noopener">Wolfire Games - Physically based rendering</a>：介绍了PBR，由Lukas Orsvärn所著。<br>&nbsp; </li>
</ul>
<hr>
<p>参考文献：<a href="https://learnopengl.com/" target="_blank" rel="noopener">LearnOpenGL</a>  <a href="https://blog.csdn.net/i_dovelemon/article/details/78945950" target="_blank" rel="noopener">基于物理的着色系统-直接光照</a></p>

            </div>

            <!-- Post Comments -->
            
    <!-- 使用 DISQUS_CLICK -->
<div id="disqus-comment">
    <div id="disqus_thread"></div>

<!-- add animation -->
<style>
	.disqus_click_btn {
            line-height: 30px;
            margin: 0;
            min-width: 50px;
            padding: 0 14px;
            display: inline-block;
            font-family: "Roboto", "Helvetica", "Arial", sans-serif;
            font-size: 14px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0;
            overflow: hidden;
            will-change: box-shadow;
            transition: box-shadow .2s cubic-bezier(.4, 0, 1, 1), background-color .2s cubic-bezier(.4, 0, .2, 1), color .2s cubic-bezier(.4, 0, .2, 1);
            outline: 0;
            cursor: pointer;
            text-decoration: none;
            text-align: center;
            vertical-align: middle;
            border: 0;
            background: rgba(158, 158, 158, .2);
            box-shadow: 0 2px 2px 0 rgba(0, 0, 0, .14), 0 3px 1px -2px rgba(0, 0, 0, .2), 0 1px 5px 0 rgba(0, 0, 0, .12);
            color: #fff;
            background-color: #7EC0EE;
            text-shadow: 0
        }
</style>
	
<div class="btn_click_load" id="disqus_bt"> 
    <button class="disqus_click_btn">点击查看评论</button>
</div>

<!--
<script type="text/javascript">
$('.btn_click_load').click(function() {
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'http-miccall-tech'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    document.getElementById('disqus_bt').style.display = "none";
});
</script>
-->
<script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://yoursite.com/2018/08/14/OpenGL39-PBR理论/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = 'http://yoursite.com/2018/08/14/OpenGL39-PBR理论/'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
</script>

<script type="text/javascript">
    $('.btn_click_load').click(function() {  //click to load comments
        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document;
            var s = d.createElement('script');
            s.src = '//http-miccall-tech.disqus.com/embed.js';
            s.setAttribute('data-timestamp', + new Date());
            (d.head || d.body).appendChild(s);
        })();
        $('.btn_click_load').css('display','none');
    });
</script>
</div>
<style>
    #disqus-comment{
        background-color: #eee;
        padding: 2pc;
    }
</style>


        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
                <li>Design: <a href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
            </ul>
            
            	<span id="busuanzi_container_site_pv">2019总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			
        </div>
    </div>
</body>



 	
</html>
