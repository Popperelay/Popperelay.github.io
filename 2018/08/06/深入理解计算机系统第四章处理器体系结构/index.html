<!DOCTYPE HTML>
<html>

<head>
	<link rel="bookmark"  type="image/x-icon"  href="/img/logo_miccall.png"/>
	 <link rel="shortcut icon" href="/img/logo_miccall.png">
	
			
    <title>
    Elays'Blog
    </title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="/css/mic_main.css" />
    <link rel="stylesheet" href="/css/dropdownMenu.css" />
    
    	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css" />
    </noscript>
			    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<link rel="stylesheet" href="/css/prism-dark.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>
    
		
<!-- Layouts -->


<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<!--<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">-->
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/latest.js?config=TeX-MML-AM_CHTML" async>
</script>

<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_undefined.css" />
<link rel="stylesheet" href="/css/typo.css" />
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">MICCALL</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special" >
            <ul class="menu links" >
			<!-- Homepage  主页  --> 
			<li >
	            <a href="/" rel="nofollow">主页</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">分类</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="/categories/Boost/">Boost</a></li><li><a class="category-link" href="/categories/C-语法/">C#语法</a></li><li><a class="category-link" href="/categories/C/">C++</a></li><li><a class="category-link" href="/categories/C语言/">C语言</a></li><li><a class="category-link" href="/categories/Math/">Math</a></li><li><a class="category-link" href="/categories/OpenGL/">OpenGL</a></li><li><a class="category-link" href="/categories/c/">c++</a></li><li><a class="category-link" href="/categories/全局光照/">全局光照</a></li><li><a class="category-link" href="/categories/博客配置/">博客配置</a></li><li><a class="category-link" href="/categories/并行计算/">并行计算</a></li><li><a class="category-link" href="/categories/操作系统/">操作系统</a></li><li><a class="category-link" href="/categories/数据结构/">数据结构</a></li><li><a class="category-link" href="/categories/毕设/">毕设</a></li><li><a class="category-link" href="/categories/游戏开发/">游戏开发</a></li><li><a class="category-link" href="/categories/游戏设计模式/">游戏设计模式</a></li><li><a class="category-link" href="/categories/计算机图形学/">计算机图形学</a></li><li><a class="category-link" href="/categories/计算机系统/">计算机系统</a></li><li><a class="category-link" href="/categories/设计模式/">设计模式</a></li><li><a class="category-link" href="/categories/调试错误集锦/">调试错误集锦</a>
	                    </ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/gallery/" title="图库">
		                图库
		            </a>
		        </li>
		        
		        <li>
		            <a href="/tag/" title="搜索">
		                搜索
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
		            
		                <li><a href="https://github.com/miccall" class="icon fa-github"><span class="label">GitHub</span></a></li>
		            
		            
		            
		            
			</ul>
</nav>

        <div id="main" >
            <div class ="post_page_title_img" style="height: 25rem;background-image: url(http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0_BG.jpg);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;" >
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2 >深入理解计算机系统第四章 处理器体系结构</h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
				<!-- 目录 -->
				<p class="show-toc-btn" id="show-toc-btn" onclick="showToc();" style="display:none">
				<span class="btn-bg"></span>
				<span class="btn-text">文章导航</span>
				</p>
				<div id="toc-article" class="toc-article">
					<span id="toc-close" class="toc-close" title="隐藏导航" onclick="showBtn();">×</span>
					<strong class="toc-title">文章目录</strong>
					<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Y86-64指令集体系结构"><span class="toc-text">Y86-64指令集体系结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#程序员可见的状态"><span class="toc-text">程序员可见的状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#指令编码"><span class="toc-text">指令编码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Y86-64异常"><span class="toc-text">Y86-64异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#一些Y86-64指令的详情"><span class="toc-text">一些Y86-64指令的详情</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#逻辑设计和硬件控制语言HCL"><span class="toc-text">逻辑设计和硬件控制语言HCL</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#逻辑门"><span class="toc-text">逻辑门</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#组合电路和HCL布尔表达式"><span class="toc-text">组合电路和HCL布尔表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#字级的组合电路和HCL整数表达式"><span class="toc-text">字级的组合电路和HCL整数表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#集合关系"><span class="toc-text">集合关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#存储器和时钟"><span class="toc-text">存储器和时钟</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Y86-64的顺序实现"><span class="toc-text">Y86-64的顺序实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#将处理组织成阶段"><span class="toc-text">将处理组织成阶段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SEQ硬件结构"><span class="toc-text">SEQ硬件结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SEQ的时序"><span class="toc-text">SEQ的时序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SEQ阶段的实现"><span class="toc-text">SEQ阶段的实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#流水线的通用原理"><span class="toc-text">流水线的通用原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#计算流水线"><span class="toc-text">计算流水线</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#流水线操作的详细说明"><span class="toc-text">流水线操作的详细说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#流水线的局限性"><span class="toc-text">流水线的局限性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#不一致的划分"><span class="toc-text">不一致的划分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#流水线过深，收益反而下降"><span class="toc-text">流水线过深，收益反而下降</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#带反馈的流水线系统"><span class="toc-text">带反馈的流水线系统</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Y86-64的流水线实现"><span class="toc-text">Y86-64的流水线实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#预测下一个PC"><span class="toc-text">预测下一个PC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#流水线冒险"><span class="toc-text">流水线冒险</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#用暂停来避免数据冒险"><span class="toc-text">用暂停来避免数据冒险</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#用转发来避免数据冒险"><span class="toc-text">用转发来避免数据冒险</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#加载-使用数据冒险"><span class="toc-text">加载/使用数据冒险</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#避免控制冒险"><span class="toc-text">避免控制冒险</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#异常处理"><span class="toc-text">异常处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#性能分析"><span class="toc-text">性能分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#未完成的工作"><span class="toc-text">未完成的工作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#多周期指令"><span class="toc-text">多周期指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#与存储系统的接口"><span class="toc-text">与存储系统的接口</span></a></li></ol></li></ol></li></ol></li></ol>
			   </div>
			   <script type="text/javascript">
				function showToc(){
					var toc_article = document.getElementById("toc-article");
					var show_toc_btn = document.getElementById("show-toc-btn");
					toc_article.setAttribute("style","display:block");
					show_toc_btn.setAttribute("style","display:none");
					};
				function showBtn(){
					var toc_article = document.getElementById("toc-article");
					var show_toc_btn = document.getElementById("show-toc-btn");
					toc_article.setAttribute("style","display:none");
					show_toc_btn.setAttribute("style","display:block");
					};
			   </script>
				
                <p>一个处理器支持的指令和指令的字节级编码称为它的指令集体系结构（Instruction-Set Architecture，ISA）。在本章里，我们会自定义一个简单的指令集，称作Y86-64指令集（我们要尝试一点点建立起一个简单的可工作的处理器）。</p>
<p>HCL（Hardware Control Language）是一种描述硬件系统控制部分的简单语言。</p>
<p>冒险就是指一条指令的位置或操作数依赖于其他仍在流水线中的指令。</p>
<h1 id="Y86-64指令集体系结构"><a href="#Y86-64指令集体系结构" class="headerlink" title="Y86-64指令集体系结构"></a><font size="6" color="orange">Y86-64指令集体系结构</font></h1><hr>
<h2 id="程序员可见的状态"><a href="#程序员可见的状态" class="headerlink" title="程序员可见的状态"></a><font size="5" color="red">程序员可见的状态</font></h2><p>如下图所示：<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0_1.png" alt=""><br>在Y86-64体系结构中，我们定义了15个寄存器，3个一位的条件码：ZF、SF和OF，程序计数器PC、内存以及状态码Stat（它表明程序是正常运行，还是出现了某种异常）。</p>
<p><font size="5" color="red">Y86-64指令</font><br>Y86-64指令集基本上是x86-64指令集的一个子集。下图是我们自定义的Y86-64指令集：<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0_2.png" alt=""></p>
<ul>
<li>Y86-64的传送指令有4种：irmovq、rrmovq、mrmovq和rmmovq。其中i代表立即数、r代表寄存器、m代表内存。比如irmovq表示的就是将立即数传送到寄存器里。</li>
<li>还定义了6个条件传送指令：cmovle、cmovl、cmove、cmovne、cmovge和cmovg。</li>
<li>还定义了4个整数操作指令（OPq），它们是addq、subq、andq和xorq。它们在执行的同时会设置3个条件码ZF、SF和OF。</li>
<li>还定义了7个跳转指令（JXX）：jmp、jle、jl、je、jne、jge和jg。</li>
<li>以及调用指令call、入栈指令pushq、出栈指令popq、停止指令halt（它会导致处理器停止，并将状态码设置为HLT）。</li>
</ul>
<h2 id="指令编码"><a href="#指令编码" class="headerlink" title="指令编码"></a><font size="5" color="red">指令编码</font></h2><p>每条Y86-64指令都需要编码，它们的编码长度1~10字节不等。每条指令的第一个字节表明指令的类型（说明指令名字），这个字节分为两部分：高4位是代码（code）部分，低4位是功能（function）部分。从上面的图中可以看到每条指令的code部分是从0到B顺序编码的，而第二个部分只对类似OPq这种有好几个不同类型的才有用，如下图所示：<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0_3.png" alt=""></p>
<p>Y86-64指令的第一个字节用来表示指令类型，紧接着后面一个字节用来指明指令需要用到的两个寄存器（每4位表示一个寄存器，如果指令不需要任何寄存器就不需要这个字节了），那么，所以那15个寄存器也需要被编码：<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0_4.png" alt=""><br>有些指令还可能需要用一个常数来表明源操作数、偏移量或者目的位置（如上图中的V、D、Dest），通常我们用8个字节来编码这个常数（在x86-64中可以将常熟之编码成1、2、4或8个字节）。</p>
<p>注：x86-64有时称为“复杂指令集计算机”（CISC），与“精简指令集计算机”（RISC）相对。</p>
<h2 id="Y86-64异常"><a href="#Y86-64异常" class="headerlink" title="Y86-64异常"></a><font size="5" color="red">Y86-64异常</font></h2><p>在图4-1中有一个状态码Stat，它是程序员可见的一个状态，它的可能值有4种：AOK、HLT、ADR和INS。如下图所示：<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0_5.png" alt=""></p>
<p><font size="4" color="red">Y86-64程序</font><br>我们来看一个例子：下面是一个C函数和对应的x86-64汇编代码以及Y86-64汇编代码：<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0_6.png" alt=""><br>可以看出两种汇编代码的不同：</p>
<ul>
<li>由于Y86-64在算术指令中不支持立即数作为操作数，所以需要先将常数加载到寄存器（第2~3行）。</li>
<li>要实现从内存读取一个数值并将其与另一个寄存器相加，由于Y86-64的算术指令要求两个操作数都必须是寄存器（从图4-2中可以看出），所以它需要两条指令来完成这个功能（第8~9行，先从内存到寄存器，再寄存器和寄存器相加），而x86-64只需要一条addq指令即可（第5行）。</li>
<li>由于Y86-64在执行算出操作时会同时设置条件码，而x86-64不会，所以就不需要像x86-64那样执行完subq指令以后还要去执行testq指令。但是Y86-64代码在进入循环之前，必须先用andq指令初始化条件码。</li>
</ul>
<h2 id="一些Y86-64指令的详情"><a href="#一些Y86-64指令的详情" class="headerlink" title="一些Y86-64指令的详情"></a><font size="5" color="red">一些Y86-64指令的详情</font></h2><p>有两个指令在某种情况下需要特别注意一下：</p>
<ul>
<li>pushq指令会把栈指针减8，并且将一个寄存器值写入内存中。因此当执行<code>pushq %rsp</code>时，到底入栈的是%rsp的原始值，还是%rsp减去8以后的值？Y86-64和x86-64都规定压入的是%rsp的原始值。</li>
<li>popq指令在执行<code>popq %rsp</code>时，也有类似的歧义，Y86-64和x86-64都规定：执行这条指令后%rsp的值是从栈内存中弹出的值，而不是等于加上8以后的栈指针。</li>
</ul>
<h1 id="逻辑设计和硬件控制语言HCL"><a href="#逻辑设计和硬件控制语言HCL" class="headerlink" title="逻辑设计和硬件控制语言HCL"></a><font size="6" color="orange">逻辑设计和硬件控制语言HCL</font></h1><hr>
<p>现代的硬件设计者都可以通过硬件描述语言（Hardware Description Language，HDL）来生成有效的电路设计。我们这里所用的HCL是HDL的简化版本。</p>
<p>在当前的技术中，逻辑1是用1.0伏特左右的高电压表示的，而逻辑0是用0.0伏特左右的低电压表示的。要实现一个数字系统需要三个主要的组成部分：计算对位进行操作的函数的组合逻辑、存储位的存储单元、控制存储器单元更新的时钟信号。</p>
<h2 id="逻辑门"><a href="#逻辑门" class="headerlink" title="逻辑门"></a><font size="5" color="red">逻辑门</font></h2><p>最基本的逻辑门与、或、非如下图所示，它们对应的HCL符号分别是：&amp;&amp;、||、!：<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0_7.png" alt=""></p>
<h2 id="组合电路和HCL布尔表达式"><a href="#组合电路和HCL布尔表达式" class="headerlink" title="组合电路和HCL布尔表达式"></a><font size="5" color="red">组合电路和HCL布尔表达式</font></h2><p>将很多的逻辑门组合成一个网，就能构建计算块（computational block），称为组合电路（combinational circuits）。如何构建这些网有几个限制：</p>
<ul>
<li>每个逻辑门的输入必须连接到下述选项之一：1. 一个系统输入（称为主输入） 2. 某个存储器单元的输出 3. 某个逻辑门的输出。</li>
<li>两个或多个逻辑门的输出不能连接在一起。否则他们可能会使线上的信号矛盾，可能会导致一个不合法的电压或电路故障。</li>
<li>这个网必须是无环的。也就是在网中不能有路径经过一系列的门而形成一个回路，这样的回路会导致该网络计算的函数有歧义。</li>
</ul>
<p>下图4-10是一个非常有用的简单组合电路的例子：<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0_8.png" alt=""><br>用HCL来写这个网的函数就是：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">bool</span> eq <span class="token operator">=</span> <span class="token punctuation">(</span>a <span class="token operator">&amp;&amp;</span> b<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span><span class="token operator">!</span>a <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>图4-11是另一个简单但很有用的组合电路，称为多路复用器（multiplexor，通常称为MUX）。当s为0时，上面的AND门将传送信号b（因为这个门的另一个输入是!s），而当s为1时，下面的AND门将传送信号a。它的HCL表示是：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">bool</span> out <span class="token operator">=</span> <span class="token punctuation">(</span>s <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span><span class="token operator">!</span>s <span class="token operator">&amp;&amp;</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="字级的组合电路和HCL整数表达式"><a href="#字级的组合电路和HCL整数表达式" class="headerlink" title="字级的组合电路和HCL整数表达式"></a><font size="5" color="red">字级的组合电路和HCL整数表达式</font></h2><p>上面所述的电路只是位级运算，而执行字级计算的组合电路根据输入字的各个位，用逻辑门来计算输出字的各个位。比如下面的组合电路，用来测两个64位字A和B是否相等：<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0_9.png" alt=""><br>这个组合电路是用64个图4-10中所示的单个位相等电路实现的。这些单个位电路的输出用一个AND门连接起来，形成了这个电路的输出。该组合电路用HCL表示如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">bool</span> Eq <span class="token operator">=</span> <span class="token punctuation">(</span>A <span class="token operator">==</span> B<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>再比如下图是一个字级的多路复用器电路。它根据控制输入位s，产生一个64位的字Out，等于两个输入字A或者B中的一个：<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0_10.png" alt=""><br>这个电路由64个相同的子电路组成，每个子电路的结构都类似于图4-11中的位级多路复用器。不过它只产生一次!s，然后在每个位的地方都重复使用它，从而减少反相器或非门的数量。该组合电路用HCL表示如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">word Out <span class="token operator">=</span> <span class="token punctuation">[</span>
    s<span class="token operator">:</span> A<span class="token punctuation">;</span>
    <span class="token number">1</span><span class="token operator">:</span> B<span class="token punctuation">;</span>
<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>在比如下图所示的四路复用器：<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0_11.png" alt=""><br>这个电路根据控制信号s1和s0，从4个输入字A、B、C和D中选择一个，将控制信号看作一个两位的二进制数。我们可以用HCL来表示这个电路：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">word Out4 <span class="token operator">=</span> <span class="token punctuation">[</span>
    <span class="token operator">!</span>s1 <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>s0 <span class="token operator">:</span> A<span class="token punctuation">;</span>    #<span class="token number">00</span>
    <span class="token operator">!</span>s1        <span class="token operator">:</span> B<span class="token punctuation">;</span>    #<span class="token number">01</span>
    <span class="token operator">!</span>s0        <span class="token operator">:</span> C<span class="token punctuation">;</span>    #<span class="token number">10</span>
    <span class="token number">1</span>          <span class="token operator">:</span> D<span class="token punctuation">;</span>    #<span class="token number">11</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>右边的注释（#）表明了s1和s0的什么组合会导致该种情况会被选中。可以看到选择表达式有时可以简化，因为HCL规定只有第一个匹配的情况才会被选中。例如，第二个表达式可以写成<code>!s1</code>，而不用写成更完整的<code>!s1 &amp;&amp; s0</code>，<code>!s0</code>已经在第一个表达式中出现了，这里第二个表达式的<code>!s1</code>就足以表示剩下的<code>!s1 &amp;&amp; s0</code>这种情况。</p>
<p>算术/逻辑单元（ALU）是一种很重要的组合电路，下图是它的一个抽象的图示：<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0_12.png" alt=""><br>可以看到，这个ALU中画的4个操作对应于Y86-64指令集支持的四种不同的整数操作，而图上的控制值（1、2、3、4）和这些操作指令的功能码相对应。我们还注意到减法的操作数顺序，是输入B减去输入A（这样做是为了让这个顺序与subq指令的参数顺序一致）。</p>
<h2 id="集合关系"><a href="#集合关系" class="headerlink" title="集合关系"></a><font size="5" color="red">集合关系</font></h2><p>假设想从一个两位信号code中选择高位和低位来为图4-14中的四路复用器产生信号s1和s0，如下图所示：<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0_13.png" alt=""><br>根据可能的code值，可以用相等测试来表示信号s1和s0的产生</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">bool</span> s1 <span class="token operator">=</span> code <span class="token operator">==</span> <span class="token number">2</span> <span class="token operator">||</span> code <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token keyword">bool</span> s0 <span class="token operator">=</span> code <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">||</span> code <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>还有一种更简洁的方式来表示，当code在集合{2,3}中时为s1为1，而code在集合{1,3}中时s0为1：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">bool</span> s1 <span class="token operator">=</span> code in <span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">bool</span> s0 <span class="token operator">=</span> code in <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>判断集合关系的通用格式是：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">iexpr in <span class="token punctuation">{</span>iexpr1<span class="token punctuation">,</span> iexpr2<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span>iexprk<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="存储器和时钟"><a href="#存储器和时钟" class="headerlink" title="存储器和时钟"></a><font size="5" color="red">存储器和时钟</font></h2><p>为了产生时序电路（sequential circuit），也就是有状态并且在这个状态上进行计算的系统，我们必须引入按位存储信息的设备。存储设备都是由一个<strong>时钟</strong>控制的，时钟是一个周期性信号，决定什么时候要把新值加载到设备中。</p>
<p>考虑两类存储器设备：</p>
<ul>
<li>时钟寄存器（简称寄存器）：存储单个位或字。时钟信号控制寄存器加载输入值。</li>
<li>随机访问存储器（简称内存）：存储多个字，用地址来选择该读或该写哪个字。随机访问存储器的例子包括：<ul>
<li>处理器的虚拟内存系统：硬件和操作系统软件结合起来处理器可以在一个很大的地址空间内访问任意的字；</li>
<li>寄存器文件：用寄存器标识符作为地址。在Y86-64处理器中，寄存器文件有15个程序寄存器（%rax~%r14）。</li>
</ul>
</li>
</ul>
<p>在硬件中，寄存器直接将它的输入和输出线连接到电路的其他部分。在机器级编程中，寄存器代表的是CPU中位数不多的可寻址的字，这里的地址是寄存器ID。</p>
<p>下图更详细地说明了一个硬件寄存器以及它是如何工作的。寄存器是作为电路不同部分中的组合逻辑之间的屏障。每当每个时钟到达上升沿时，值才会从寄存器的输入传送到输出。<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0_14.png" alt=""><br>下图展示了一个典型的寄存器文件：<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0_15.png" alt=""><br>寄存器文件有两个读端口（A和B），还有一个写端口（W）。这样一个多端口随机访问存储器允许同时进行多个读和写操作。图中所示的寄存器文件中，电路可以读两个程序寄存器的值，同时更新第三个寄存器的状态。</p>
<p>向寄存器文件写入字是由时钟信号控制的，控制方式类似于将值加载到时钟寄存器。每次时钟上升时，输入valW上的值会被写入输入dstW上的寄存器ID指示的程序寄存器。</p>
<p>处理器有一个随机访问存储器来存储程序数据，如下图所示：<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0_16.png" alt=""><br>这个内存有一个地址输入，一个写的数据输入，以及一个读的数据输出。从内存中读的操作方式类似于组合逻辑：如果我们在输入address上提供一个地址，并将write控制信号设置为0，那么在经过一些延迟之后，存储在那个地址上的值会出现在输出data上。如果地址超出了范围，error信号会设置为1，否则就设置为0。写内存是由时钟控制的：我们将address设置为期望的地址，将data in设置为期望的值，而write设置为1.然后当我们控制时钟时，只要地址是合法的，就会更新内存中指定的位置。对于读操作来说，如果地址是不合法的，error信号会被设置为1。</p>
<h1 id="Y86-64的顺序实现"><a href="#Y86-64的顺序实现" class="headerlink" title="Y86-64的顺序实现"></a><font size="6" color="orange">Y86-64的顺序实现</font></h1><p>现在已经有了实现Y86-64处理器所需要的部件。接下来我们用这些部件来构建一个SEQ（顺序的）处理器。</p>
<hr>
<h2 id="将处理组织成阶段"><a href="#将处理组织成阶段" class="headerlink" title="将处理组织成阶段"></a><font size="5" color="red">将处理组织成阶段</font></h2><p>通常，处理一条指令包括很多操作：取指、译码、执行、访存、写回、更新PC。</p>
<ul>
<li>取指：取指阶段从内存读取指令字节，地址为程序计数器（PC）的值。从指令中抽取出指令指示符字节的 两个四位部分，称为icode(指令代码)和ifun(指令功能)。它可能取出一个寄存器指示符字节，指明一个或两个寄存器操作数rA和rB。它还可能取出一个四字节常数valC。它按顺序方式计算当前指令的下一条指令的地址valP。也就是说，valP等于PC的值加上已取出指令的长度。</li>
<li>译码：译码阶段从寄存器文件读入最多两个操作数，得到值valA和/或valB。通常，它读入指令rA和rB字段指明的寄存器，不过有些指令是读寄存器%rsp的。</li>
<li>执行：在执行阶段，算术/逻辑单元（ALU）要么执行指令指明的操作（根据ifun的值），计算内存引用的有效地址，呀么增加或减少栈指针。得到的值称为valE。也可看设置条件码。对于条件传送指令来说，这个阶段会检验条件码和传送条件（有ifun给出），如果条件成立，则更新目标寄存器。同样，对一条跳转指令来说，这个阶段会决定是不是应该选择分支。</li>
<li>访存：访存阶段可以将数据写入内存，或者从内存读出数据。读出的值为valM。</li>
<li>写回：写回阶段最多可以写两个结果到寄存器文件。</li>
<li>更新PC：将PC设置成下一条指令的地址。</li>
</ul>
<p>比如下图给出了指令OPq（整数和逻辑运算）、rrmovq（寄存器-寄存器传送）和irmovq（立即数-寄存器传送）的处理过程：<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0_17.png" alt=""><br>表中CC是条件码的意思。<br>下图给出了内存读写指令rmmovq和mrmovq所需要的处理：<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0_18.png" alt=""><br>下图给出了处理pushq和popq指令所需的步骤：<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0_19.png" alt=""><br>下图表明了三类控制转移指令的处理过程：<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0_20.png" alt=""></p>
<h2 id="SEQ硬件结构"><a href="#SEQ硬件结构" class="headerlink" title="SEQ硬件结构"></a><font size="5" color="red">SEQ硬件结构</font></h2><p>在SEQ（顺序处理器）中，这些处理阶段、所有硬件单元的处理都在一个时钟周期内完成（当然这个时钟周期会很长），如下图所示：<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0_21.png" alt=""><br>硬件单元与各个处理阶段相关联：</p>
<ul>
<li>取值：将程序计数器寄存器作为地址，指令内存读取指令的字节。PC增加器湖实验valP，即增加了的程序计数器。</li>
<li>译码：寄存器文件有两个读端口A和B，从这两个端口同时读寄存器值valA和valB。</li>
<li><p>执行：执行阶段会根据指令的类型，将算术/逻辑单元（ALU）用于不同的目的。对整数操作，它要执行所指定的运算。对其他指令，它会作为一个加法器来计算增加或减少帧指针，或者计算有效地址，或者只是简单地加0，将一个输入传递到输出。</p>
<p>条件码寄存器（CC）有三个条件码位。ALU负责计算条件码的新值。当执行条件传送指令时，根据条件码和传送指令来计算决定是否更新目标寄存器。同样，当执行一条跳转指令时，会根据条件码和跳转类型来计算分支信号Cnd。</p>
</li>
<li><p>访存：在执行访存操作时，数据内存读出或写入一个内存字。指令和数据内存访问的是相同的内存位置，但是用于不同的目的。</p>
</li>
<li>写回：寄存器文件有两个写端口。端口E用来写ALU计算出来的值，而端口M用来写从数据内存中读出的值。</li>
<li>PC更新：程序计数器的新值从这几个中选择一个：valP，下一条指令的地址；valC，调用指令或跳转指令指定的目标地址；valM，从内存读取的返回地址。</li>
</ul>
<h2 id="SEQ的时序"><a href="#SEQ的时序" class="headerlink" title="SEQ的时序"></a><font size="5" color="red">SEQ的时序</font></h2><p>SEQ的实现包括组合逻辑和两种存储器设备：时钟存储器（程序计数器和条件码寄存器）、随机访问存储器（寄存器文件、指令内存和数据内存）。</p>
<p>我们在实现Y86-64指令集时，需要遵循以下原则组织计算：</p>
<blockquote>
<p>原则：从不回读<br>处理器从来不需要为了完成一条指令的执行而去读由该指令更新了的状态。</p>
</blockquote>
<p>这条原则对实现的成功来说至关重要。假设我们对pushq指令的<strong>实现</strong>是先将%rsp减8，再将更新后的<strong>%rsp值</strong>作为写操作的地址，这种方式就与该原则相违背。因为为了执行内存写操作，它需要先从寄存器文件中读更新过的栈指针，我们真正的实现是将减后的栈指针值，作为信号valE，然后再用这个信号既作为寄存器写的数据，也作为内存写的地址。因此，在时钟上升开始下一个周期时，处理器就可以<strong>同时</strong>执行寄存器写和内存写了。</p>
<p>我们在时钟上升时更新寄存器的值，并开始执行新的指令。如下图所示：<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0_22.png" alt=""></p>
<h2 id="SEQ阶段的实现"><a href="#SEQ阶段的实现" class="headerlink" title="SEQ阶段的实现"></a><font size="5" color="red">SEQ阶段的实现</font></h2><p>各阶段的具体硬件实现略，感觉对程序员帮助不大~_~</p>
<p>SEQ唯一的问题就是它太慢了：时钟必须非常慢，以使信号能在一个周期内传播所有的阶段。比如处理一条ret指令：在时钟周期起始时，从更新过的PC开始，要从指令内存中读出指令，从寄存器文件中读出栈指针，ALU将栈指针加8，为了得到程序计数器的下一个值，还要从内存中读出返回地址。所有这一切都必须在这个周期结束之前完成，当然时钟周期很长了。</p>
<p>这种实现方法不能充分利用硬件单元，因为每个单元只在整个时钟周期的一部分时间内才被使用。我们会看到引入流水线能获得更好的性能。</p>
<h1 id="流水线的通用原理"><a href="#流水线的通用原理" class="headerlink" title="流水线的通用原理"></a><font size="6" color="orange">流水线的通用原理</font></h1><hr>
<p>流水线化其实就是把一类事情的处理过程分割成多个过程，然后让这类事情的多个实例错开并行执行。比如汽车清洗这类事情，我们可以在前面一辆汽车趁那个喷水阶段进入擦洗阶段时，下一辆就可以进入喷水阶段了。</p>
<p>流水线化的一个重要特性就是提高了系统的吞吐量（throughput），也就是单位时间内服务的顾客总数，不过它也会轻微地增加延迟（latency），也就是服务一个用户所需要的时间。例如，自助餐厅里的一个只需要甜点的顾客，能很快通过一个非流水线化的系统，只在甜点阶段停留；但是在流水线化的系统中，这个顾客如果试图直接去甜点阶段就有可能招致其他顾客的愤怒了。</p>
<h2 id="计算流水线"><a href="#计算流水线" class="headerlink" title="计算流水线"></a><font size="5" color="red">计算流水线</font></h2><p>下图给出了一个很简单的非流水线化的硬件系统例子：<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0_23.png" alt=""><br>我们假设其中组合逻辑需要300ps，加载寄存器需要20ps。图中下方的是一种时序图：流水线图。在图中，时间从左向右流动，从上到下写着一组指令（I1、I2、I3）。实心的长方形表示这些指令执行的时间。下面的公式给出了运行这个非流水线化的系统的最大吞吐量：<br>$$吞吐量=\frac{1条指令}{(20+300)ps}\cdot \frac{1000ps}{1ns}\approx3.12~GIPS$$<br>我们用GIPS（每秒千兆条指令或者每秒十亿条指令）为单位来描述吞吐量。</p>
<p>从头到尾执行一条指令所需要的时间称为延迟（latency）。在此系统中，延迟为320ps，也就是吞吐量的倒数。</p>
<p>假设将系统执行的计算分成三个阶段（A、B和C），每个阶段需要100ps，如下图所示：<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0_24.png" alt=""><br>我们在各个阶段之间放上流水线寄存器，这样每条指令都会按照三步经过这个系统，从头到尾需要三个完整的时钟周期。在这个系统中，我们将时钟周期设为100+20=120ps，得到的吞吐量大约为8.33GIPS。因为处理一条指令需要3个时钟周期，所以这条流水线的延迟就是3x120=360ps。我们将系统吞吐量提高到原来的8.33/3.12=2.67倍，代价是增加了一些硬件，以及延迟的少量增加（360/320=1.12）。延迟变大是由于增加的流水线寄存器的时间开销。</p>
<h2 id="流水线操作的详细说明"><a href="#流水线操作的详细说明" class="headerlink" title="流水线操作的详细说明"></a><font size="5" color="red">流水线操作的详细说明</font></h2><p>减缓时钟（也就是让时钟周期变长）不会影响流水线的行为。信号传播到流水线寄存器的输入，但是直到时钟上升时才会改变寄存器的状态。另一方面，如果时钟运行得太快，就会有灾难性的后果。值可能会来不及通过组合逻辑，因此当时钟上升时，寄存器的输入还不是合法的值。所以，要保证时钟比信号在组合逻辑中传播的时间要长。</p>
<h2 id="流水线的局限性"><a href="#流水线的局限性" class="headerlink" title="流水线的局限性"></a><font size="5" color="red">流水线的局限性</font></h2><h3 id="不一致的划分"><a href="#不一致的划分" class="headerlink" title="不一致的划分"></a><font size="4" color="red">不一致的划分</font></h3><p>如下图所示：<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0_25.png" alt=""><br>这里我们将计算划分为了三个阶段，但是通过这些阶段的延迟从50ps到150ps不等。通过所有阶段的延迟和仍然为300ps。但是，运行时钟的速率是由最慢的阶段的延迟限制的。流水线图表明，每个时钟周期，阶段A都会空闲（白色部分）100ps，而阶段C会空闲50ps。最慢的是阶段B，需要150ps，所以我们必须把时钟周期设置为150+20=170ps，得到吞吐量为5.88GIPS。而且，由于时钟周期减慢了，延迟也增加到了170x3=510ps。</p>
<p>对硬件设计者来说，将系统计算设计划分成一组具有相同延迟的阶段时一个严峻的挑战。</p>
<h3 id="流水线过深，收益反而下降"><a href="#流水线过深，收益反而下降" class="headerlink" title="流水线过深，收益反而下降"></a><font size="4" color="red">流水线过深，收益反而下降</font></h3><p>下图说明了流水线技术的另一个局限性：<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0_26.png" alt=""><br>这里将计算分成了6个阶段，每个阶段需要50ps，在之间插入流水线寄存器，这个系统的最小时钟周期为50+20=70ps，吞吐量为14.29GIPS，所以我们只将性能提高了14.29/8.33=1.71倍（没有前面3段一致的划分得到的2.67倍高），可以看到阶段数增多时，寄存器的数量也会随之增加，而寄存器带来的延迟就成了重要的性能制约因素。</p>
<p>为了提高时钟频率，现代处理器采用了很深的（15或更多的阶段）流水线。处理器架构师将指令的执行划分成很多分成简单的步骤，这样一来每个阶段的延迟就很小。同时电路设计者小心地设计流水线寄存器，使其延迟尽可能小。芯片设计者也必须小心地设计始终传播网络，以保证时钟在整个芯片上同时改变。所有这些都是设计高速微处理器面临的挑战。</p>
<h3 id="带反馈的流水线系统"><a href="#带反馈的流水线系统" class="headerlink" title="带反馈的流水线系统"></a><font size="4" color="red">带反馈的流水线系统</font></h3><p>对于像x86-64或Y86-64这样执行机器程序的系统来说，相邻指令之间很可能是相关的。比如下面这个Y86-64指令序列：<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0_27.png" alt=""><br>可以看到其中每对相邻的指令之间都有数据相关。</p>
<p>除了数据相关以外，还有由指令控制流造成的顺序相关。比如：<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0_28.png" alt=""><br>jne指令（第3行）产生了一个控制相关，因为条件测试的结果会决定要执行的新指令是irmovq指令（第4行）还是halt指令（第7行）。在我们的SEQ设计中，这些相关都是由反馈路径来决定的（图4-22的右边部分）。这些反馈将更新了的寄存器值向下传送到寄存器文件，将新的PC值向下传送到PC寄存器。</p>
<p>下图说明了将流水线引入含有反馈路径的系统中的危险：<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0_29.png" alt=""><br>在原来的系统（图a）中，每条指令的结果都反馈给下一条指令：图b就说明了这个情况，指令I1的结果成为I2的输入，依次类推。如果试图以最直接的方式将它转换成一个三阶段流水线（图c），我们将改变系统的行为：指令I1的结果变成了指令I4的输入。</p>
<p>我们必须以某种方式来处理指令间的数据和控制相关。</p>
<h1 id="Y86-64的流水线实现"><a href="#Y86-64的流水线实现" class="headerlink" title="Y86-64的流水线实现"></a><font size="6" color="orange">Y86-64的流水线实现</font></h1><hr>
<h2 id="预测下一个PC"><a href="#预测下一个PC" class="headerlink" title="预测下一个PC"></a><font size="5" color="red">预测下一个PC</font></h2><p>流水线化设计的目的就是每个时钟周期都发射一条新指令，也就是说每个时钟周期都有一条新指令进入执行阶段并最终完成。要做到这一点，我们必须在取出当前指令之后，马上确定下一条指令的位置。不幸的是，如果取出的指令是条件分支指令，要到几个周期后，也就是指令通过执行阶段之后，我们才能知道是否要选择分支。类似地，如果取出的指令是ret，要到指令通过访存阶段，才能确定返回地址。</p>
<p>除了条件转移指令和ret以外，根据取指阶段中计算出的信息，我们能够确定下一条指令的地址。对于call和jmp（无条件转移）来说，下一条指令的地址是指令中的常数字valC，而对于其他指令来说就是valP（即原程序计数器值加1）。因此，通过预测PC的下一个值，在大多数情况下，我们能够达到每个时钟周期发射一条新指令的目的。当然如果预测错了会有对应的处理预测错误的方式。</p>
<p>预测分支方向并根据猜测开始取指的技术称为分支预测。</p>
<h2 id="流水线冒险"><a href="#流水线冒险" class="headerlink" title="流水线冒险"></a><font size="5" color="red">流水线冒险</font></h2><p>相邻指令之间的相关形式有两种：1）数据相关。下一条指令会用到这一条指令计算出的结果。2）控制相关。一条指令要确定下一条指令的位置，例如在执行跳转、调用或返回指令时。</p>
<p>这些相关可能会导致流水线产生计算错误，称为冒险（hazard）。同样地，也分为数据冒险和控制冒险。</p>
<p>下图在irmovq指令和add指令之间插入了三条nop指令，当addq指令在周期7经过译码阶段时，它可以读到正确的源数据值，所以这两条指令之间已经没有了数据冒险：<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0_30.png" alt=""><br>可以看到程序prog1通过流水线并得到正确的结果，因为3条nop指令在有数据相关的指令之间创造了一些延迟。</p>
<p>下面几幅图分别是在插入2条、1条、0条nop指令时，由于数据相关造成的错误值：<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0_31.png" alt=""><br><img src="http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0_32.png" alt=""><br><img src="http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0_33.png" alt=""></p>
<h3 id="用暂停来避免数据冒险"><a href="#用暂停来避免数据冒险" class="headerlink" title="用暂停来避免数据冒险"></a><font size="4" color="red">用暂停来避免数据冒险</font></h3><p>暂停（stalling）是避免冒险的一种常用技术，暂停时，处理器会停止流水线中一条或多条指令，直到冒险条件不在满足。让一条指令停顿在译码阶段，直到产生它的源操作数的指令通过了写回阶段，这样我们的处理器就能避免数据冒险。</p>
<p>下面两幅图画出了暂停的效果：<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0_34.png" alt=""><br>当指令addq处于译码阶段时，流水线控制逻辑发现执行、访存或写回阶段中至少有一条指令会更新寄存器%rdx或%rax。处理器不会让addq指令带着不正确的结果通过这个阶段，而是会暂停指令，将它阻塞在译码阶段。</p>
<p>将addq指令阻塞在译码阶段时，我们还必须将紧跟其后的halt指令阻塞在取指阶段。通过将程序计数器保持不变就能做到这一点，这样一来，会不断地对halt指令进行取指，知道暂停结束。</p>
<p>暂停技术就是让一组指令阻塞在它们所处的阶段，而允许其他指令继续通过流水线。每次要把一条指令阻塞在译码阶段，就在执行阶段插入一个气泡（bubble）。气泡就像就像一个自动产生的nop指令：它不会改变寄存器、内存、条件码或程序状态。</p>
<p>虽然实现暂停这一机制相当容易，但是得到的性能并不好。一条指令更新一个寄存器，紧随其后的指令就使用被更新的寄存器，像这样的情况不胜枚举。那么暂停就很有可能会导致流水线暂停长达三个周期，严重降低了整体的吞吐量。</p>
<h3 id="用转发来避免数据冒险"><a href="#用转发来避免数据冒险" class="headerlink" title="用转发来避免数据冒险"></a><font size="4" color="red">用转发来避免数据冒险</font></h3><p>最初的设计是在译码阶段从寄存器文件中读入源操作数，但是对这些源寄存器的写有可能要在写回阶段才能进行。与其暂停直到写完成，不如简单地将要写的值传到流水线寄存器E作为源操作数。下图描述了这一策略：<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0_35.png" alt=""><br>译码阶段逻辑发现，寄存器%rax是操作数valB的源寄存器，而在写端口E上还有一个对%rax的未进行的写。它只要简单地将提供到端口E的数据字（信号W_valE）作为操作数valB的值，就能避免暂停。</p>
<p>这种将结果值直接从一个流水线阶段传到较早阶段（W→D）的技术称为数据转发（data forwarding，简称转发或旁路）。它使得程序prog2的指令能够正确通过流水线而不需要任何暂停。</p>
<p>需要注意的是，通常都是在本周期内的各个阶段进行转发（比如从第6周期的W阶段转发到第6周期的D阶段），或者从前面周期的某个阶段转发到后面周期的某个阶段，而不能从后面周期某个阶段转发到前面周期的某个阶段。</p>
<h3 id="加载-使用数据冒险"><a href="#加载-使用数据冒险" class="headerlink" title="加载/使用数据冒险"></a><font size="4" color="red">加载/使用数据冒险</font></h3><p>有一类数据冒险不能单纯用转发来解决，因为内存读在流水线发生的比较晚（内存读处于第4个阶段）。下图举例说明了加载/使用冒险（load/use hazard）。<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0_36.png" alt=""><br>addq指令在周期7中需要该寄存器的值，但是mrmovq指令直到周期8才产生出这个值。为了从mrmovq“转发到”到addq，转发逻辑不得不将值送回到过去的时间（也就是说需要把阶段M中的数值进行转发。但是M的值是在第8周期中才使用的，不可能转发到第7周期的D阶段，即add指令的译码阶段）！这显然不可能。我们必须找到其他机制来解决这种形式的数据冒险。</p>
<p>我们可以将暂停和转发结合起来，避免加载/使用数据冒险。当mrmovq指令通过执行阶段时，流水线控制逻辑发现译码阶段中的指令（addq）需要从内存中读出的结果。它会将译码阶段中的指令暂停一个周期，导致执行阶段中插入一个气泡。然后再结合转发就可以解决这种数据冒险，如下图所示：<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0_37.png" alt=""></p>
<h3 id="避免控制冒险"><a href="#避免控制冒险" class="headerlink" title="避免控制冒险"></a><font size="4" color="red">避免控制冒险</font></h3><p>也可以通过改变指令处理顺序，并结合插入气泡来避免控制冒险。对于ret指令如下图所示：<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0_38.png" alt=""><br>上图中，在周期4，分支逻辑发现不应该选择分支之前，已经取出了两条指令，它们不应该继续执行下去了。幸运的是，这两条指令都没有导致程序员可见的状态发生改变。只要到指令到达执行阶段时才会发生那种情况，在执行阶段中，指令会改变条件码。我们只要在下一个周期往译码和执行阶段中插入气泡，并同时取出跳转指令后面的指令，这样就能取消那两条预测错误的指令。这样一来，两条预测错误的指令就会简单地从流水线中消失，因此不会对程序员可见的状态产生影响。唯一的缺点是两个时钟周期的指令处理能力被浪费了。</p>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a><font size="4" color="red">异常处理</font></h3><p>当流水线中有一个或多个阶段出现异常时，信息只是简单地存放在流水线寄存器的状态字段中。异常事件不会对流水线中的指令流有任何影响，除了会禁止流水线中后面的指令更新程序员可见的状态（条件码寄存器和内存），直到异常指令到达最后的流水线阶段。因为指令到达写回阶段的顺序与它们在非流水线化的处理器中执行的顺序相同，所以我们可以保证第一条遇到异常的指令会第一个到达写回阶段，此时程序执行会停止，流水线寄存器W中的状态码会被记录为程序状态。如果取出了某条指令，过后又取消了，那么所有关于这条指令的异常状态信息都会被取消。所有导致异常的指令后面的指令都不能改变程序员可见的状态。携带指令的异常状态以及所有其他信息通过流水线的简单原则是处理异常的简单而可靠的机制。</p>
<h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a><font size="4" color="red">性能分析</font></h3><p>所有需要流水线控制逻辑进行特殊处理的条件，都会导致流水线不能够实现每个时钟周期发射一条新指令的目标。我们可以通过确定往流水线中插入气泡的频率，来衡量这种效率的损失，因为插入气泡会导致未使用的流水线周期。一条返回指令会产生三个气泡，一个加载/使用冒险会产生一个气泡，而一个预测错误的分支会产生两个气泡。我们可以通过执行一条指令所需要的平均时钟周期数CPI（Cycles Per Instruction，每指令周期数）来量化这些处罚对整体性能的影响。</p>
<p>如果某个阶段一共处理了$C_i$条指令和$C_b$个气泡，那么处理器一共需要大约$C_i+C_b$个时钟周期来执行$C_i$条指令。于是，可以用如下方法来计算这个基准程序的CPI：<br>$$CPI=\frac{C_i+C_b}{C_i}=1.0+\frac{C_b}{C_i}$$<br>也就是说，CPI等于1.0加上一个处罚项$C_b/C_i$，这个项表明执行一条指令平均要插入多少个气泡。因为只有三种指令类型会导致插入气泡，我们可以将这个处罚项分解成三个部分：<br>$$CPI=1.0+lp+mp+rp$$<br>$lp$、$mp$、$rp$分别表示由于加载/使用冒险、预测错误分支、ret指令返回而插入的气泡的平均数。</p>
<p>为了估计每种处罚，我们需要知道相关指令（加载、条件转移和返回）的出现频率，以及每种指令特殊情况（需要插入气泡的情况）出现的频率。据统计，这三类相关指令的频率如下表所示：<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0_40.png" alt=""><br>三种处罚的总和是0.27，所以CPI为1.27。离我们想要的一个周期发射一条指令也不远了。</p>
<h3 id="未完成的工作"><a href="#未完成的工作" class="headerlink" title="未完成的工作"></a><font size="4" color="red">未完成的工作</font></h3><h4 id="多周期指令"><a href="#多周期指令" class="headerlink" title="多周期指令"></a><font size="5" color="red">多周期指令</font></h4><p>通常简答的操作可以在一个周期内完成，但是像整数乘法、除法以及浮点运算，都不是在一个周期内就能完成的。</p>
<p>我们当然不能为了在一个周期内执行完浮点运算等复杂操作，就去延长时钟周期。通过采用独立于主流水线的特殊硬件功能单元来处理较为复杂的操作，可以得到更好的性能。通常，有一个功能单元来执行整数乘法和除法，还有一个来执行浮点操作。当一条指令进入译码阶段时，它可以被发射到特殊单元。在这个特殊单元执行该操作时，流水线会继续处理其他指令。通常，浮点单元本身也是流水线化的，因此多条指令可以在主流水线和各个单元中并发执行。</p>
<h4 id="与存储系统的接口"><a href="#与存储系统的接口" class="headerlink" title="与存储系统的接口"></a><font size="5" color="red">与存储系统的接口</font></h4><p>似乎读写数据（从内存读写、从磁盘读写等等）也都不是一个时钟周期内就能完成的。实际上，通过多级存储系统，将TLB（Translation Look-aside Buffer，翻译后背缓冲器，用于虚拟地址到物理地址的快速翻译）高速缓存结合起来使用，在大多数时候，确实可能在一个时钟周期内读指令、读或者写数据。</p>
<p>但是当高速缓存不命中的时候就没法在一个时钟周期内搞定了。从处理器的角度来看，将用暂停来处理短时间内的高速缓存不命中和用异常处理来处理长时间的缺页结合起来，能够顾及到存储器访问时由于存储器层次结构引起的所有不可预测性。</p>
<p>较新的处理器支持超标量（superscalar）操作，意味着它们通过并行地取指、译码和执行多条指令，可以实现小于1.0的CPI（这时性能测量标准已经从CPI转化成了它的倒数：每周期执行指令的平均数，即IPC）。</p>

            </div>

            <!-- Post Comments -->
            
    <!-- 使用 DISQUS_CLICK -->
<div id="disqus-comment">
    <div id="disqus_thread"></div>

<!-- add animation -->
<style>
	.disqus_click_btn {
            line-height: 30px;
            margin: 0;
            min-width: 50px;
            padding: 0 14px;
            display: inline-block;
            font-family: "Roboto", "Helvetica", "Arial", sans-serif;
            font-size: 14px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0;
            overflow: hidden;
            will-change: box-shadow;
            transition: box-shadow .2s cubic-bezier(.4, 0, 1, 1), background-color .2s cubic-bezier(.4, 0, .2, 1), color .2s cubic-bezier(.4, 0, .2, 1);
            outline: 0;
            cursor: pointer;
            text-decoration: none;
            text-align: center;
            vertical-align: middle;
            border: 0;
            background: rgba(158, 158, 158, .2);
            box-shadow: 0 2px 2px 0 rgba(0, 0, 0, .14), 0 3px 1px -2px rgba(0, 0, 0, .2), 0 1px 5px 0 rgba(0, 0, 0, .12);
            color: #fff;
            background-color: #7EC0EE;
            text-shadow: 0
        }
</style>
	
<div class="btn_click_load" id="disqus_bt"> 
    <button class="disqus_click_btn">点击查看评论</button>
</div>

<!--
<script type="text/javascript">
$('.btn_click_load').click(function() {
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'http-miccall-tech'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    document.getElementById('disqus_bt').style.display = "none";
});
</script>
-->
<script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://yoursite.com/2018/08/06/深入理解计算机系统第四章处理器体系结构/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = 'http://yoursite.com/2018/08/06/深入理解计算机系统第四章处理器体系结构/'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
</script>

<script type="text/javascript">
    $('.btn_click_load').click(function() {  //click to load comments
        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document;
            var s = d.createElement('script');
            s.src = '//http-miccall-tech.disqus.com/embed.js';
            s.setAttribute('data-timestamp', + new Date());
            (d.head || d.body).appendChild(s);
        })();
        $('.btn_click_load').css('display','none');
    });
</script>
</div>
<style>
    #disqus-comment{
        background-color: #eee;
        padding: 2pc;
    }
</style>


        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
                <li>Design: <a href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
            </ul>
            
            	<span id="busuanzi_container_site_pv">2019总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			
        </div>
    </div>
</body>



 	
</html>
