<!DOCTYPE HTML>
<html>

<head><meta name="generator" content="Hexo 3.9.0">
	<link rel="bookmark" type="image/x-icon" href="/img/logo_miccall.png">
	 <link rel="shortcut icon" href="/img/logo_miccall.png">
	
			
    <title>
    Elays'Blog
    </title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
	<script>
	(function(){
		if('{{ page.password }}'){
			if (prompt('请输入博客密码') !== "elayRender"){
				alert('密码错误！');
				window.open('','_top'); 
				window.opener=null; 
				window.close();
			}
		}
	})();
	</script>
    <link rel="stylesheet" href="/css/mic_main.css">
    <link rel="stylesheet" href="/css/dropdownMenu.css">
    
    	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css">
    </noscript>
			    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<link rel="stylesheet" href="/css/prism-dark.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>
    
		
<!-- Layouts -->


<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<!--<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">-->
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/latest.js?config=TeX-MML-AM_CHTML">
</script>

<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_undefined.css">
<link rel="stylesheet" href="/css/typo.css">
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">MICCALL</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special">
            <ul class="menu links">
			<!-- Homepage  主页  --> 
			<li>
	            <a href="/" rel="nofollow">主页</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">分类</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="/categories/C/">C#</a></li><li><a class="category-link" href="/categories/C-语法/">C#语法</a></li><li><a class="category-link" href="/categories/C/">C++</a></li><li><a class="category-link" href="/categories/C语言/">C语言</a></li><li><a class="category-link" href="/categories/Graphics/">Graphics</a></li><li><a class="category-link" href="/categories/Math/">Math</a></li><li><a class="category-link" href="/categories/OpenGL/">OpenGL</a></li><li><a class="category-link" href="/categories/Unity/">Unity</a></li><li><a class="category-link" href="/categories/Vulkan/">Vulkan</a></li><li><a class="category-link" href="/categories/博客配置/">博客配置</a></li><li><a class="category-link" href="/categories/并行计算/">并行计算</a></li><li><a class="category-link" href="/categories/操作系统/">操作系统</a></li><li><a class="category-link" href="/categories/数据结构/">数据结构</a></li><li><a class="category-link" href="/categories/毕设/">毕设</a></li><li><a class="category-link" href="/categories/游戏开发/">游戏开发</a></li><li><a class="category-link" href="/categories/计算机系统/">计算机系统</a></li><li><a class="category-link" href="/categories/设计模式/">设计模式</a></li><li><a class="category-link" href="/categories/面试/">面试</a>
	                    </li></ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/gallery/" title="图库">
		                图库
		            </a>
		        </li>
		        
		        <li>
		            <a href="/tag/" title="搜索">
		                搜索
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
		            
		                <li><a href="https://github.com/miccall" class="icon fa-github"><span class="label">GitHub</span></a></li>
		            
		            
		            
		            
			</ul>
</nav>

        <div id="main">
            <div class="post_page_title_img" style="height: 25rem;background-image: url(https://github.com/Popperelay/Photos/blob/master/Photos/OpenGL40PBR%E5%85%89%E7%85%A7_BG.png?raw=true);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;">
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2>OpenGL40 PBR实现</h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
				<!-- 目录 -->
				<p class="show-toc-btn" id="show-toc-btn" onclick="showToc();" style="display:none">
				<span class="btn-bg"></span>
				<span class="btn-text">文章导航</span>
				</p>
				<div id="toc-article" class="toc-article">
					<span id="toc-close" class="toc-close" title="隐藏导航" onclick="showBtn();">×</span>
					<strong class="toc-title">文章目录</strong>
					<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#点大小的光源的辐射率计算"><span class="toc-text">点大小的光源的辐射率计算</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#一个PBR表面模型"><span class="toc-text">一个PBR表面模型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#直接光照明"><span class="toc-text">直接光照明</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#伽马校正和HDR渲染"><span class="toc-text">伽马校正和HDR渲染</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#运行结果"><span class="toc-text">运行结果</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#带贴图的PBR"><span class="toc-text">带贴图的PBR</span></a></li></ol>
			   </div>
			   <script type="text/javascript">
				function showToc(){
					var toc_article = document.getElementById("toc-article");
					var show_toc_btn = document.getElementById("show-toc-btn");
					toc_article.setAttribute("style","display:block");
					show_toc_btn.setAttribute("style","display:none");
					};
				function showBtn(){
					var toc_article = document.getElementById("toc-article");
					var show_toc_btn = document.getElementById("show-toc-btn");
					toc_article.setAttribute("style","display:none");
					show_toc_btn.setAttribute("style","display:block");
					};
			   </script>
				
                <p>这篇文章主要是把<a href="http://popperelay.cn/2018/08/14/OpenGL39-PBR%E7%90%86%E8%AE%BA/" target="_blank" rel="noopener">上篇文章</a>中的理论转化为实际的渲染器。先来看一下上篇文章中提到的反射率方程的最终版：<br>$$L_o(p,\omega_o)=\int_\Omega(k_d\frac{c}{\pi}+k_s\frac{DFG}{4(\omega_o\cdot n)(\omega_i\cdot n)})L_i(p,\omega_i)n\cdot \omega_id\omega_i$$<br>通过上一篇文章，我们大致清楚这个反射率方程在干什么，但是仍然有一些迷雾尚未揭开。比如说我们究竟怎样表示场景的辐射度以及辐射率$L$？我们知道辐射率$L$表示在给定立体角$\omega$的情况下，光源的辐射通量$\Phi$或光源在角度$\omega$下发送出来的光能。我们不妨假设立体角$\omega$无限小，这样辐射率就表示光源在一条光线或单个方向向量上的辐射通量。</p>
<h1 id="点大小的光源的辐射率计算"><a href="#点大小的光源的辐射率计算" class="headerlink" title="点大小的光源的辐射率计算"></a><font size="6" color="orange">点大小的光源的辐射率计算</font></h1><hr>
<p>想象一下，我们有一个点光源（在所有方向具有相同的亮度），它的辐射通量用RGB表示为（23.47,21.31,20.79）。该光源的辐射强度等于它在每一条出射光线上的辐射通量。然而，如下图所示：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/OpenGL40PBR%E5%85%89%E7%85%A7_1.png?raw=true" alt><br>当我们为一个表面上的特定点$p$着色时，在其半球领域$\Omega$的所有可能的入射方向上，只有一个入射方向向量$\omega_i$直接来自于该点光源。假设我们在场景中只有一个光源，位于空间中的某一个点，因而对于$p$点的其他可能的入射光线方向上的辐射率为0。</p>
<p>如果我们假设点光源不受光线衰减（光照强度随着距离变暗）的影响，那么无论我们把光源放在哪，入射光线的辐射率总是一样的（除去入射角$cos\theta$对辐射率的影响之外）。正是因为我们无论从哪个角度观察它，点光源总具有相同的辐射强度，所以我们可以有效地将其辐射强度建模为其辐射通量：一个常量向量（23.47,21.31,20.79）。</p>
<p>然而，辐射率也需要位置$p$作为输入，正如所有现实的点光源都会受光线衰减影响一样，点光源的辐射强度应该根据点$p$所在的位置和光源的位置以及他们之间的距离而做一些缩放。因此，根据原始的辐射率定义公式，我们会根据表面法向量$n$和入射角度$\omega_i$来缩放光源的辐射强度。</p>
<p>写成代码是这样的：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">vec3  lightColor  <span class="token operator">=</span> <span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">23.47</span><span class="token punctuation">,</span> <span class="token number">21.31</span><span class="token punctuation">,</span> <span class="token number">20.79</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
vec3  wi          <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>lightPos <span class="token operator">-</span> fragPos<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">float</span> cosTheta    <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token function">dot</span><span class="token punctuation">(</span>N<span class="token punctuation">,</span> wi<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">float</span> attenuation <span class="token operator">=</span> <span class="token function">calculateAttenuation</span><span class="token punctuation">(</span>fragPos<span class="token punctuation">,</span> lightPos<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">float</span> radiance    <span class="token operator">=</span> lightColor <span class="token operator">*</span> attenuation <span class="token operator">*</span> cosTheta<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这段代码应该很熟悉了，它正是我们一直以来计算漫反射光照的方式。当涉及到直接照明（direct lighting）时，辐射率的计算方式和我们之前计算当只有一个光源照射在物体表面的时候非常相似（在最终的代码里会看到在计算辐射度时没有乘<code>cosTheta</code>，这是因为反射率方程中的$n \cdot w_i$已经考虑到这一点了）。</p>
<blockquote>
<p>需要注意的是，这个结论成立的条件是点光源体积无限小，相当于在空间中的一个点。如果我们认为该光源是具有体积的，它就不会只在一个入射光方向（针对点$p$的光线入射方向）上辐射率不为0了（因为它有一整个面都在发光，而不是一个点在发光）。</p>
</blockquote>
<p>对于其他类型的从单点发出来的光源，我们可以类似地计算出辐射率。比如，定向光拥有恒定的$\omega_i$而不会有衰减因子；而一个聚光灯光源则没有恒定的辐射强度，其辐射强度时根据聚光灯的方向向量来缩放的。</p>
<p>这也让我们回到了对半球领域$\Omega$的积分$\int$上：由于我们事先知道所有贡献光源的位置，因此对物体表面上的一个点着色并不需要我们去求解积分，我们可以直接拿光源的（已知的）数目，去计算它们的总辐照度，因为每个光源仅仅只有一个方向上的光线会影响物体表面的辐射率。这使得PBR对直接光源的计算相对简单，因为我们只需要有效地遍历所有有贡献的光源。不过我们后面把环境照明也考虑进来以后，就必须用积分去计算了，这是因为有了环境光以后，光线可能会在任意一个方向入射到点$p$。</p>
<h1 id="一个PBR表面模型"><a href="#一个PBR表面模型" class="headerlink" title="一个PBR表面模型"></a><font size="6" color="orange">一个PBR表面模型</font></h1><hr>
<p>我们尝试来写一下PBR模型（反射率方程）的片元着色器。首先是相关的输入参数：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#version 430 core</span>

in vec2 v2f_TexCoords<span class="token punctuation">;</span>
in vec3 v2f_WorldPos<span class="token punctuation">;</span>
in vec3 v2f_Normal<span class="token punctuation">;</span>
out vec4 Color_<span class="token punctuation">;</span>

uniform vec3 u_ObjectColor<span class="token punctuation">;</span>
uniform <span class="token keyword">float</span> u_Metalness<span class="token punctuation">;</span>
uniform <span class="token keyword">float</span> u_Roughness<span class="token punctuation">;</span>
uniform <span class="token keyword">float</span> u_AO<span class="token punctuation">;</span>
uniform vec3  u_LightPos<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
uniform vec3  u_LightColors<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
uniform vec3  u_ViewPos<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后我们在片元着色器的开始部分，计算一下任何光照算法都需要用到的法线向量和观察向量：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    vec3 N <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>v2f_Normal<span class="token punctuation">)</span><span class="token punctuation">;</span>
    vec3 V <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>u_ViewPos <span class="token operator">-</span> v2f_WorldPos<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="直接光照明"><a href="#直接光照明" class="headerlink" title="直接光照明"></a><font size="5" color="red">直接光照明</font></h2><p>我们使用4个点光源来直接表示场景的辐照度。我们先循环计算每个点光源相对于当前片元的辐射率（前面已经说过这个循环可以看作是在片元的半球领域内对所有直接光源求积分）：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//反射率方程</span>
vec3 Lo <span class="token operator">=</span> <span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//计算光源的入射辐射度Li</span>
    vec3 L <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>u_LightPos<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> v2f_WorldPos<span class="token punctuation">)</span><span class="token punctuation">;</span>
    vec3 H <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>V <span class="token operator">+</span> L<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">float</span> Distance <span class="token operator">=</span> <span class="token function">length</span><span class="token punctuation">(</span>u_LightPos<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> v2f_WorldPos<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">float</span> Attenuation <span class="token operator">=</span> <span class="token number">1.0</span> <span class="token operator">/</span> <span class="token punctuation">(</span>Distance <span class="token operator">*</span> Distance<span class="token punctuation">)</span><span class="token punctuation">;</span>
    vec3 Radiance <span class="token operator">=</span> u_LightColors<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> Attenuation<span class="token punctuation">;</span>
    <span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>  
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>由于我们在线性空间内计算光照（我们会在着色器的尾部进行Gamma校正），所以上面的代码中我们使用在物理上更为准确的平方倒数作为衰减。</p>
<p>首先我们想要计算镜面反射和漫反射的系数。从上篇文章中知道我们可以使用菲涅尔方程来计算：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//菲涅尔方程，用于描述反射光线比例</span>
vec3 <span class="token function">FresnelSchlick</span><span class="token punctuation">(</span><span class="token keyword">float</span> vCosTheta<span class="token punctuation">,</span> vec3 vF0<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> vF0 <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">1.0</span> <span class="token operator">-</span> vF0<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">1.0</span> <span class="token operator">-</span> vCosTheta<span class="token punctuation">,</span> <span class="token number">5.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">//计算基础反射率</span>
vec3 F0 <span class="token operator">=</span> <span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">0.04</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
F0 <span class="token operator">=</span> <span class="token function">mix</span><span class="token punctuation">(</span>F0<span class="token punctuation">,</span> u_ObjectColor<span class="token punctuation">,</span> u_Metalness<span class="token punctuation">)</span><span class="token punctuation">;</span>
vec3  F <span class="token operator">=</span> <span class="token function">FresnelSchlick</span><span class="token punctuation">(</span><span class="token function">clamp</span><span class="token punctuation">(</span><span class="token function">dot</span><span class="token punctuation">(</span>H<span class="token punctuation">,</span> V<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> F0<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>菲涅尔方程返回的是一个物体表面光线被反射的比率，也就是反射率方程中的$k_s$。其中albedo是表面纹理颜色，$F_0$是基础反射率。</p>
<p>计算出$k_s$之后，我们就能顺带求出$k_d$了：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">    <span class="token comment" spellcheck="true">//计算漫反射和镜面反射的比例</span>
    vec3 ks <span class="token operator">=</span> F<span class="token punctuation">;</span>
    vec3 kd <span class="token operator">=</span> <span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">1.0</span><span class="token punctuation">)</span> <span class="token operator">-</span> ks<span class="token punctuation">;</span>
    kd <span class="token operator">*</span><span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1.0</span> <span class="token operator">-</span> u_Metalness<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//金属表面没有漫反射  </span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>因为金属不会折射光线，因此不会有漫反射，所以如果表面是金属的，我们会把系数$k_d$变为0。</p>
<p>然后，相对于每一个光源我们都想计算完整的Cook-Torrance BRDF的镜面反射部分：<br>$$\frac{DFG}{4(\omega_o\cdot n)(\omega_i \cdot n)}$$</p>
<p>已经计算出$F$，剩下的项就是正态分布函数$D$和几何函数$G$了。</p>
<p>和上一篇文章类似，计算D和G的代码类似于如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//正态分布函数，用于估算微平面取向</span>
<span class="token keyword">float</span> <span class="token function">DistributionGGX</span><span class="token punctuation">(</span>vec3 vN<span class="token punctuation">,</span> vec3 vH<span class="token punctuation">,</span> <span class="token keyword">float</span> vRoughness<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">float</span> a <span class="token operator">=</span> vRoughness <span class="token operator">*</span> vRoughness<span class="token punctuation">;</span>
    <span class="token keyword">float</span> a2 <span class="token operator">=</span> a <span class="token operator">*</span> a<span class="token punctuation">;</span>
    <span class="token keyword">float</span> NdotH <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token function">dot</span><span class="token punctuation">(</span>vN<span class="token punctuation">,</span> vH<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">float</span> NdotH2 <span class="token operator">=</span> NdotH <span class="token operator">*</span> NdotH<span class="token punctuation">;</span>
    <span class="token keyword">float</span> nom <span class="token operator">=</span> a2<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//分子</span>
    <span class="token keyword">float</span> denom <span class="token operator">=</span> NdotH2 <span class="token operator">*</span> <span class="token punctuation">(</span>a2 <span class="token operator">-</span> <span class="token number">1.0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1.0</span><span class="token punctuation">;</span>
    denom <span class="token operator">=</span> PI <span class="token operator">*</span> denom <span class="token operator">*</span> denom<span class="token punctuation">;</span>
    <span class="token keyword">return</span> nom <span class="token operator">/</span> <span class="token function">max</span><span class="token punctuation">(</span>denom<span class="token punctuation">,</span> <span class="token number">0.001</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//防止vRoughness=0而且NdotH=1时出现分母除0的情况</span>
<span class="token punctuation">}</span>

<span class="token keyword">float</span> <span class="token function">GeometrySchlickGGX</span><span class="token punctuation">(</span><span class="token keyword">float</span> vNdotV<span class="token punctuation">,</span> <span class="token keyword">float</span> vRoughness<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">float</span> r <span class="token operator">=</span> vRoughness <span class="token operator">+</span> <span class="token number">1.0</span><span class="token punctuation">;</span>
    <span class="token keyword">float</span> k <span class="token operator">=</span> r <span class="token operator">*</span> r <span class="token operator">/</span> <span class="token number">8.0</span><span class="token punctuation">;</span>
    <span class="token keyword">float</span> nom <span class="token operator">=</span> vNdotV<span class="token punctuation">;</span>
    <span class="token keyword">float</span> denom <span class="token operator">=</span> vNdotV <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">1.0</span> <span class="token operator">-</span> k<span class="token punctuation">)</span> <span class="token operator">+</span> k<span class="token punctuation">;</span>
    <span class="token keyword">return</span> nom <span class="token operator">/</span> denom<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">//几何函数，用于描述微平面的几何遮蔽和几何阴影</span>
<span class="token keyword">float</span> <span class="token function">GeometrySmith</span><span class="token punctuation">(</span>vec3 vN<span class="token punctuation">,</span> vec3 vV<span class="token punctuation">,</span> vec3 vL<span class="token punctuation">,</span> <span class="token keyword">float</span> vRoughness<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">float</span> NdotV <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token function">dot</span><span class="token punctuation">(</span>vN<span class="token punctuation">,</span> vV<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">float</span> NdotL <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token function">dot</span><span class="token punctuation">(</span>vN<span class="token punctuation">,</span> vL<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">float</span> ggx1 <span class="token operator">=</span> <span class="token function">GeometrySchlickGGX</span><span class="token punctuation">(</span>NdotV<span class="token punctuation">,</span> vRoughness<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">float</span> ggx2 <span class="token operator">=</span> <span class="token function">GeometrySchlickGGX</span><span class="token punctuation">(</span>NdotL<span class="token punctuation">,</span> vRoughness<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> ggx1 <span class="token operator">*</span> ggx2<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>与上一篇文章唯一不同的是，我们在上面函数里直接传入了粗糙度参数。</p>
<p>那么我们现在就可以在循环里计算出完整的Cook-Torrance BRDF镜面反射部分了：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">    <span class="token comment" spellcheck="true">//计算Cook-Torrance BRDF</span>
    <span class="token keyword">float</span> D <span class="token operator">=</span> <span class="token function">DistributionGGX</span><span class="token punctuation">(</span>N<span class="token punctuation">,</span> H<span class="token punctuation">,</span> u_Roughness<span class="token punctuation">)</span><span class="token punctuation">;</span>
    vec3  F <span class="token operator">=</span> <span class="token function">FresnelSchlick</span><span class="token punctuation">(</span><span class="token function">clamp</span><span class="token punctuation">(</span><span class="token function">dot</span><span class="token punctuation">(</span>H<span class="token punctuation">,</span> V<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> F0<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">float</span> G <span class="token operator">=</span> <span class="token function">GeometrySmith</span><span class="token punctuation">(</span>N<span class="token punctuation">,</span> V<span class="token punctuation">,</span> L<span class="token punctuation">,</span> u_Roughness<span class="token punctuation">)</span><span class="token punctuation">;</span>
    vec3 nom <span class="token operator">=</span> D <span class="token operator">*</span> F <span class="token operator">*</span> G<span class="token punctuation">;</span>
    <span class="token keyword">float</span> denom <span class="token operator">=</span> <span class="token number">4</span> <span class="token operator">*</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token function">dot</span><span class="token punctuation">(</span>N<span class="token punctuation">,</span> V<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token function">dot</span><span class="token punctuation">(</span>N<span class="token punctuation">,</span> L<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    vec3 Specular <span class="token operator">=</span> nom <span class="token operator">/</span> <span class="token function">max</span><span class="token punctuation">(</span>denom<span class="token punctuation">,</span> <span class="token number">0.001</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//防止NdotV=0.0或者NdotL=0.0时，分母除0</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注意我们让分母最小为0.001是为了避免出现除零错误。</p>
<p>这样漫反射和镜面反射部分都有了以后，我们就可以直接求出出射光线的辐射率了：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">    <span class="token keyword">const</span> <span class="token keyword">float</span> PI <span class="token operator">=</span> <span class="token number">3.14159265359</span><span class="token punctuation">;</span>

    <span class="token keyword">float</span> NdotL <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token function">dot</span><span class="token punctuation">(</span>N<span class="token punctuation">,</span> L<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Lo <span class="token operator">+</span><span class="token operator">=</span> <span class="token punctuation">(</span>kd <span class="token operator">*</span> u_ObjectColor <span class="token operator">/</span> PI <span class="token operator">+</span> Specular<span class="token punctuation">)</span> <span class="token operator">*</span> Radiance <span class="token operator">*</span> NdotL<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>最终的结果<code>Lo</code>（出射光线的辐射率），实际上是反射率方程在半球领域$\Omega$内的积分的结果。但是我们实际上不需要去求积，因为对于所有可能的入射光线方向，我们知道只有4个方向的入射光线会影响到片元的着色。因此，我们可以直接循环N次计算这些入射光线的方向（N也就是场景中光源的数量）。</p>
<p>值得注意的是，不需要对<code>specular</code>再乘以一次<code>kS</code>，因为在计算镜面反射部分<code>specular</code>时，公式中已经乘了菲涅尔系数（DFG中的F），菲涅尔方程算出来的就是<code>kS</code>。</p>
<p>最后剩下的工作就是加一个环境光给<code>Lo</code>：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">vec3 Ambient <span class="token operator">=</span> <span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">0.03</span><span class="token punctuation">)</span> <span class="token operator">*</span> u_ObjectColor <span class="token operator">*</span> u_AO<span class="token punctuation">;</span>
vec3 Color <span class="token operator">=</span> Ambient <span class="token operator">+</span> Lo<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h1 id="伽马校正和HDR渲染"><a href="#伽马校正和HDR渲染" class="headerlink" title="伽马校正和HDR渲染"></a><font size="6" color="orange">伽马校正和HDR渲染</font></h1><hr>
<p>直到现在，我们假设的所有计算都是在线性的颜色空间中进行的，因此我们需要在着色器最后作<a href="http://popperelay.cn/2017/05/24/OpenGL27Gamma%E6%A0%A1%E6%AD%A3/" target="_blank" rel="noopener">伽马校正</a>。在线性空间中计算光照是非常重要的，因为PBR要求所有输入都是线性的，如果不是这样，我们就会得到不正常的光照。另外，我们希望所有光照的输入都尽可能地接近他们在物理上的取值，这样他们的反射率或者说颜色值就会在色谱上有比较大的变化空间。<code>Lo</code>作为结果可能会变大得很快（超过1），但是因为默认的LDR输入而取值被截断。所以在伽马校正之前我们采用色调映射使<code>Lo</code>从LDR的值映射为HDR的值。</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//HDR色调映射</span>
Color <span class="token operator">=</span> Color <span class="token operator">/</span> <span class="token punctuation">(</span>Color <span class="token operator">+</span> <span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//Gamma校正</span>
Color <span class="token operator">=</span> <span class="token function">pow</span><span class="token punctuation">(</span>Color<span class="token punctuation">,</span> <span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">1.0</span> <span class="token operator">/</span> <span class="token number">2.2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里我们采用的色调映射方法为Reinhard 操作，使得我们在伽马校正后可以保留尽可能多的辐照度变化。<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/OpenGL40PBR%E5%85%89%E7%85%A7_2.png?raw=true" alt><br>采用线性颜色空间和HDR在PBR渲染关系中非常重要。如果没有这些操作，几乎是不可能正确地捕获到不同光照强度下的细节变化，导致我们最终的计算变得不正确，视觉上看起来会很不自然。</p>
<h1 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a><font size="6" color="orange">运行结果</font></h1><hr>
<p>完整的代码请看<a href="https://github.com/Popperelay/BlogCode/tree/master/LearnOpenGL40_PBR/LearnOpenGL40_PBR_1" target="_blank" rel="noopener">这里</a>。</p>
<p>我们在场景里防止了4个点光源和一些球体，同时令这些球体的金属度和粗糙度沿垂直方向和水平方向分别变化，最终会得到下面这样的结果：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/OpenGL40PBR%E5%85%89%E7%85%A7_3.png?raw=true" alt><br>上诉图片里从下往上球体的金属度从0.0变到1.0，从左到右球体的粗糙度从0.0变到1.0。可以看到仅仅改变这两个值，显示的效果就会发生巨大的改变。</p>
<h1 id="带贴图的PBR"><a href="#带贴图的PBR" class="headerlink" title="带贴图的PBR"></a><font size="6" color="orange">带贴图的PBR</font></h1><hr>
<p>我们将粗糙度、金属度等等材质参数用纹理来表示：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">uniform sampler2D u_NormalMap<span class="token punctuation">;</span>
uniform sampler2D u_ObjectColorMap<span class="token punctuation">;</span>
uniform sampler2D u_MetalnessMap<span class="token punctuation">;</span>
uniform sampler2D u_RoughtnessMap<span class="token punctuation">;</span>
uniform sampler2D u_AOMap<span class="token punctuation">;</span>

vec3 <span class="token function">getNormalFromMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    vec3 TangentNormal <span class="token operator">=</span> <span class="token function">texture</span><span class="token punctuation">(</span>u_NormalMap<span class="token punctuation">,</span> v2f_TexCoords<span class="token punctuation">)</span><span class="token punctuation">.</span>xyz <span class="token operator">*</span> <span class="token number">2.0</span> <span class="token operator">-</span> <span class="token number">1.0</span><span class="token punctuation">;</span>

    vec3 Q1 <span class="token operator">=</span> <span class="token function">dFdx</span><span class="token punctuation">(</span>v2f_WorldPos<span class="token punctuation">)</span><span class="token punctuation">;</span>
    vec3 Q2 <span class="token operator">=</span> <span class="token function">dFdy</span><span class="token punctuation">(</span>v2f_WorldPos<span class="token punctuation">)</span><span class="token punctuation">;</span>
    vec2 st1 <span class="token operator">=</span> <span class="token function">dFdx</span><span class="token punctuation">(</span>v2f_TexCoords<span class="token punctuation">)</span><span class="token punctuation">;</span>
    vec2 st2 <span class="token operator">=</span> <span class="token function">dFdy</span><span class="token punctuation">(</span>v2f_TexCoords<span class="token punctuation">)</span><span class="token punctuation">;</span>

    vec3 N <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>v2f_Normal<span class="token punctuation">)</span><span class="token punctuation">;</span>
    vec3 T <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>Q1 <span class="token operator">*</span> st2<span class="token punctuation">.</span>t <span class="token operator">-</span> Q2 <span class="token operator">*</span> st1<span class="token punctuation">.</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
    vec3 B <span class="token operator">=</span> <span class="token operator">-</span><span class="token function">normalize</span><span class="token punctuation">(</span><span class="token function">cross</span><span class="token punctuation">(</span>N<span class="token punctuation">,</span> T<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    mat3 TBN <span class="token operator">=</span> <span class="token function">mat3</span><span class="token punctuation">(</span>T<span class="token punctuation">,</span> B<span class="token punctuation">,</span> N<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">normalize</span><span class="token punctuation">(</span>TBN <span class="token operator">*</span> TangentNormal<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    vec3  ObjectColor <span class="token operator">=</span> <span class="token function">pow</span><span class="token punctuation">(</span><span class="token function">texture</span><span class="token punctuation">(</span>u_ObjectColorMap<span class="token punctuation">,</span> v2f_TexCoords<span class="token punctuation">)</span><span class="token punctuation">.</span>rgb<span class="token punctuation">,</span> <span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">2.2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">float</span> Metalness <span class="token operator">=</span> <span class="token function">texture</span><span class="token punctuation">(</span>u_MetalnessMap<span class="token punctuation">,</span> v2f_TexCoords<span class="token punctuation">)</span><span class="token punctuation">.</span>r<span class="token punctuation">;</span>
    <span class="token keyword">float</span> Roughness <span class="token operator">=</span> <span class="token function">texture</span><span class="token punctuation">(</span>u_RoughtnessMap<span class="token punctuation">,</span> v2f_TexCoords<span class="token punctuation">)</span><span class="token punctuation">.</span>r<span class="token punctuation">;</span>
    <span class="token keyword">float</span> AO <span class="token operator">=</span> <span class="token function">texture</span><span class="token punctuation">(</span>u_AOMap<span class="token punctuation">,</span> v2f_TexCoords<span class="token punctuation">)</span><span class="token punctuation">.</span>r<span class="token punctuation">;</span>

    vec3 N <span class="token operator">=</span> <span class="token function">getNormalFromMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>需要注意的是，因为物体颜色纹理在美工人员创建的时候就已经在sRGB空间了，所以我们需要在光照计算之前先把他们转换到线性空间（环境遮蔽贴图通常也需要转换到线性空间）。而金属度和粗糙度纹理大多数时候都是保证在线性空间中的。</p>
<p>在根据法线贴图计算法线的时候，需要用TBN矩阵做一个切线空间到世界空间的坐标变换，具体可参考<a href="http://popperelay.cn/2018/08/14/OpenGL31-%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE/" target="_blank" rel="noopener">OpenGL31法线贴图</a>。</p>
<p>改成纹理作为材质输入参数以后，运行结果如下：<br><img src="https://github.com/Popperelay/Photos/blob/master/Photos/OpenGL40PBR%E5%85%89%E7%85%A7_4.png?raw=true" alt><br>金属表面会在场景中看起来有点黑，因为它们没有漫反射，考虑环境光镜面光照以后看起来会更加自然（下一篇基于图片的光照IBL中会介绍）。</p>
<p>完整的代码请看<a href="https://github.com/Popperelay/BlogCode/tree/master/LearnOpenGL40_PBR/LearnOpenGL40_PBR_2" target="_blank" rel="noopener">这里</a>。<br>&nbsp; </p>
<hr>
<p>参考文献：<a href="https://learnopengl.com/" target="_blank" rel="noopener">LearnOpenGL</a></p>

            </div>

            <!-- Post Comments -->
            
    <!-- 使用 DISQUS_CLICK -->
<div id="disqus-comment">
    <div id="disqus_thread"></div>

<!-- add animation -->
<style>
	.disqus_click_btn {
            line-height: 30px;
            margin: 0;
            min-width: 50px;
            padding: 0 14px;
            display: inline-block;
            font-family: "Roboto", "Helvetica", "Arial", sans-serif;
            font-size: 14px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0;
            overflow: hidden;
            will-change: box-shadow;
            transition: box-shadow .2s cubic-bezier(.4, 0, 1, 1), background-color .2s cubic-bezier(.4, 0, .2, 1), color .2s cubic-bezier(.4, 0, .2, 1);
            outline: 0;
            cursor: pointer;
            text-decoration: none;
            text-align: center;
            vertical-align: middle;
            border: 0;
            background: rgba(158, 158, 158, .2);
            box-shadow: 0 2px 2px 0 rgba(0, 0, 0, .14), 0 3px 1px -2px rgba(0, 0, 0, .2), 0 1px 5px 0 rgba(0, 0, 0, .12);
            color: #fff;
            background-color: #7EC0EE;
            text-shadow: 0
        }
</style>
	
<div class="btn_click_load" id="disqus_bt"> 
    <button class="disqus_click_btn">点击查看评论</button>
</div>

<!--
<script type="text/javascript">
$('.btn_click_load').click(function() {
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'http-miccall-tech'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    document.getElementById('disqus_bt').style.display = "none";
});
</script>
-->
<script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://yoursite.com/2018/08/16/OpenGL40PBR实现/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = 'http://yoursite.com/2018/08/16/OpenGL40PBR实现/'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
</script>

<script type="text/javascript">
    $('.btn_click_load').click(function() {  //click to load comments
        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document;
            var s = d.createElement('script');
            s.src = '//http-miccall-tech.disqus.com/embed.js';
            s.setAttribute('data-timestamp', + new Date());
            (d.head || d.body).appendChild(s);
        })();
        $('.btn_click_load').css('display','none');
    });
</script>
</div>
<style>
    #disqus-comment{
        background-color: #eee;
        padding: 2pc;
    }
</style>


        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
                <li>Design: <a href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
            </ul>
            
            	<span id="busuanzi_container_site_pv">2019总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			
        </div>
    </div>
</body>



 	
</html>
