<!DOCTYPE HTML>
<html>

<head>
	<link rel="bookmark"  type="image/x-icon"  href="/img/logo_miccall.png"/>
	 <link rel="shortcut icon" href="/img/logo_miccall.png">
	
			
    <title>
    Elays'Blog
    </title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="/css/mic_main.css" />
    <link rel="stylesheet" href="/css/dropdownMenu.css" />
    
    	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css" />
    </noscript>
			    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<link rel="stylesheet" href="/css/prism-dark.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>
    
		
<!-- Layouts -->


<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<!--<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">-->
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/latest.js?config=TeX-MML-AM_CHTML" async>
</script>

<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_undefined.css" />
<link rel="stylesheet" href="/css/typo.css" />
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">MICCALL</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special" >
            <ul class="menu links" >
			<!-- Homepage  主页  --> 
			<li >
	            <a href="/" rel="nofollow">主页</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">分类</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="/categories/Boost/">Boost</a></li><li><a class="category-link" href="/categories/C-语法/">C#语法</a></li><li><a class="category-link" href="/categories/C/">C++</a></li><li><a class="category-link" href="/categories/C语言/">C语言</a></li><li><a class="category-link" href="/categories/OpenGL/">OpenGL</a></li><li><a class="category-link" href="/categories/c/">c++</a></li><li><a class="category-link" href="/categories/全局光照/">全局光照</a></li><li><a class="category-link" href="/categories/博客配置/">博客配置</a></li><li><a class="category-link" href="/categories/并行计算/">并行计算</a></li><li><a class="category-link" href="/categories/操作系统/">操作系统</a></li><li><a class="category-link" href="/categories/数据结构/">数据结构</a></li><li><a class="category-link" href="/categories/毕设/">毕设</a></li><li><a class="category-link" href="/categories/游戏开发/">游戏开发</a></li><li><a class="category-link" href="/categories/游戏设计模式/">游戏设计模式</a></li><li><a class="category-link" href="/categories/计算机图形学/">计算机图形学</a></li><li><a class="category-link" href="/categories/计算机系统/">计算机系统</a></li><li><a class="category-link" href="/categories/设计模式/">设计模式</a></li><li><a class="category-link" href="/categories/调试错误集锦/">调试错误集锦</a>
	                    </ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/gallery/" title="图库">
		                图库
		            </a>
		        </li>
		        
		        <li>
		            <a href="/tag/" title="搜索">
		                搜索
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
		            
		                <li><a href="https://github.com/miccall" class="icon fa-github"><span class="label">GitHub</span></a></li>
		            
		            
		            
		            
			</ul>
</nav>

        <div id="main" >
            <div class ="post_page_title_img" style="height: 25rem;background-image: url(http://oqcvzqam1.bkt.clouddn.com/OpenGL42IBL%E9%95%9C%E9%9D%A2%E5%8F%8D%E5%B0%84%E9%83%A8%E5%88%86_12.png);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;" >
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2 >OpenGL42 IBL镜面反射部分</h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
				<!-- 目录 -->
				<p class="show-toc-btn" id="show-toc-btn" onclick="showToc();" style="display:none">
				<span class="btn-bg"></span>
				<span class="btn-text">文章导航</span>
				</p>
				<div id="toc-article" class="toc-article">
					<span id="toc-close" class="toc-close" title="隐藏导航" onclick="showBtn();">×</span>
					<strong class="toc-title">文章目录</strong>
					<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#使用黎曼和在PBR里直接求解镜面积分"><span class="toc-text">使用黎曼和在PBR里直接求解镜面积分</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#蒙特卡洛积分"><span class="toc-text">蒙特卡洛积分</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#使用蒙特卡洛在PBR里直接求解积分"><span class="toc-text">使用蒙特卡洛在PBR里直接求解积分</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#镜面积分部分的终极形式"><span class="toc-text">镜面积分部分的终极形式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#低差异序列"><span class="toc-text">低差异序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GGX重要性采样"><span class="toc-text">GGX重要性采样</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#预计算镜面积分部分：分割求和近似"><span class="toc-text">预计算镜面积分部分：分割求和近似</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#分割求和的第一部分：预过滤环境贴图"><span class="toc-text">分割求和的第一部分：预过滤环境贴图</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#预过滤卷积瑕疵"><span class="toc-text">预过滤卷积瑕疵</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#高粗糙度下的cubemap接缝"><span class="toc-text">高粗糙度下的cubemap接缝</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#预过滤卷积中的亮点"><span class="toc-text">预过滤卷积中的亮点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#分割求和的第二部分：BRDF积分贴图"><span class="toc-text">分割求和的第二部分：BRDF积分贴图</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#完成IBL反射"><span class="toc-text">完成IBL反射</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#下一步？"><span class="toc-text">下一步？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#延伸阅读"><span class="toc-text">延伸阅读</span></a></li></ol>
			   </div>
			   <script type="text/javascript">
				function showToc(){
					var toc_article = document.getElementById("toc-article");
					var show_toc_btn = document.getElementById("show-toc-btn");
					toc_article.setAttribute("style","display:block");
					show_toc_btn.setAttribute("style","display:none");
					};
				function showBtn(){
					var toc_article = document.getElementById("toc-article");
					var show_toc_btn = document.getElementById("show-toc-btn");
					toc_article.setAttribute("style","display:none");
					show_toc_btn.setAttribute("style","display:block");
					};
			   </script>
				
                <p>还是先贴出终极反射率方程：<br>$$L_o(p,\omega_o)=\int_{\Omega}(k_d\frac{c}{\pi}+k_s\frac{DFG}{4(\omega_o\cdot n)(\omega_i \cdot n)})L_i(p,\omega_i)n\cdot\omega_id\omega_i$$</p>
<h1 id="使用黎曼和在PBR里直接求解镜面积分"><a href="#使用黎曼和在PBR里直接求解镜面积分" class="headerlink" title="使用黎曼和在PBR里直接求解镜面积分"></a><font size="6" color="orange">使用黎曼和在PBR里直接求解镜面积分</font></h1><hr>
<p>上一篇文章使用预计算的辐照度贴图求解了漫反射积分部分，那这篇文章我们着重关注镜面积分部分。即：<br>$$L_o(p,\omega_o)=\int_{\Omega}k_s\frac{DFG}{4(\omega_o\cdot n)(\omega_i\cdot n)}L_i(p,\omega_i)n\cdot\omega_id\omega_i=\int_{\Omega}f_r(p,\omega_i,\omega_o)L_i(p,\omega_i)n\cdot\omega_id\omega_i$$<br>当然，我们可以直接在使用PBR渲染物体时，在片元着色器里直接来做这个积分：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">float3 <span class="token function">SpecularIBL</span><span class="token punctuation">(</span> float3 SpecularColor<span class="token punctuation">,</span> <span class="token keyword">float</span> Roughness<span class="token punctuation">,</span> float3 N<span class="token punctuation">,</span> float3 V <span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>
    float3 SpecularLighting <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//循环列举出一堆观察向量wi</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">float</span> Phi <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span> Phi <span class="token operator">&lt;</span> DoublePI<span class="token punctuation">;</span> Phi <span class="token operator">+</span><span class="token operator">=</span> SampleDelta<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">float</span> Theta <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span> Theta <span class="token operator">&lt;</span> HalfPI<span class="token punctuation">;</span> Theta <span class="token operator">+</span><span class="token operator">=</span> SampleDelta<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">//根据球面坐标算出世界空间下的wi</span>
            vec3 wi <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">//根据wi去采样环境贴图得到对应的Li</span>
            vec3 Randiance <span class="token operator">=</span> <span class="token function">texture</span><span class="token punctuation">(</span>u_EnvMap<span class="token punctuation">,</span> wi<span class="token punctuation">)</span><span class="token punctuation">.</span>rgb<span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">//分别计算DFG</span>
            D <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
            F <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
            G <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">//再结合已知的法线n、已知的观察向量wo等来直接计算积分式子</span>
            SpecularLighting  <span class="token operator">+</span><span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
            <span class="token operator">++</span>SampleCount<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    SpecularLighting  <span class="token operator">=</span> SpecularLighting  <span class="token operator">/</span> SampleCount<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其实上面的方法还是用的黎曼和来求解积分，用黎曼和来计算上一篇文章的漫反射积分部分足够了，但是对于镜面部分的积分来说，它的效果更精细，信号也是高频的，如果只是使用黎曼和来求解积分的话，误差会较大，效果不够好。所以我们需要使用其他的积分求解方案。业界对于求解镜面积分部分，最常用的就是使用一种叫蒙特卡洛积分的技术来求解这个积分。</p>
<h1 id="蒙特卡洛积分"><a href="#蒙特卡洛积分" class="headerlink" title="蒙特卡洛积分"></a><font size="6" color="orange">蒙特卡洛积分</font></h1><hr>
<p>蒙特卡洛积分主要围绕统计和概率理论的结合。蒙特卡洛帮助我们在不需要考虑所有群体的情况下，求解一个群体的统计量或价值的问题。</p>
<p>例如，假设你想要计算一个国家所有公民的平均身高。 为了得到结果，你可以测量每个公民并平均他们的身高，这将为你提供你正在寻找的确切答案。但是，由于大多数国家人口众多，这不是一个现实的方法：需要花费太多精力和时间。</p>
<p>另一种方法是选择一个小得多的完全随机（无偏）的人口子集，测量他们的身高并求均值。这个人口子集可能小到只有100人。虽然不如确切的答案准确，但你会得到一个相对接近真相的答案。这被称为大数定律。我们的想法是，如果你从总人口中测量一组较小的$N$个完全随机样本，结果将与真实答案相对接近，并随着样本数$N$的增加而变得更接近。</p>
<p>蒙特卡罗积分建立在这个大数定律的基础上，并采用相同的方法来求解积分。不是为所有可能的（理论上无限的）样本值x求解积分，而是简单地从总人口中随机挑选N个样本值，再求平均。 随着N增加，我们保证得到的结果更接近积分的确切答案：<br>$$O =  \int\limits_{a}^{b} f(x) dx = \frac{1}{N} \sum_{i=0}^{N-1} \frac{f(x)}{pdf(x)}$$<br>为了求解积分，我们在群体$a$到$b$上取$N$个随机样本，将它们加在一起并除以样本总数来平均它们。 $pdf$代表概率密度函数，它告诉我们特定样本在整个样本集上出现的概率。 例如，人口高度的$pdf$看起来有点像这样：<br><img src="http://oqcvzqam1.bkt.clouddn.com/OpenGL42IBL%E9%95%9C%E9%9D%A2%E5%8F%8D%E5%B0%84%E9%83%A8%E5%88%86_5.png" alt=""><br>从这张图中我们可以看到，如果我们选取了人口的任意随机样本，那么选中高度为1.70的人的样本的可能性更高，而选中样本高度为1.50的概率较低。</p>
<p>当涉及蒙特卡罗积分时，一些样本可能比其他样本具有更高的生成概率。 这就是为什么对于任何一般的蒙特卡罗估计，我们根据$pdf$将采样值除以采样概率。 到目前为止，在我们估算积分的每个例子中，我们生成的样本是均匀的，具有完全相同的生成机会。 到目前为止，我们的估计是无偏的，这意味着在给定数量不断增加的样本的情况下，我们最终会收敛到积分的精确解。</p>
<p>然而，有一些蒙特卡罗估计器是有偏差的，这意味着生成的样本不是完全随机的，而是集中于特定的值或方向。 这些有偏差的蒙特卡罗估计器具有更快的收敛速度，这意味着它们可以以更快的速率收敛到精确解，但由于它们的偏差性质，它们很可能永远不会收敛到精确解。 这通常是可接受的折衷，尤其是在计算机图形学中，因为只要结果在视觉上可接受，精确的解决方案就不太重要。 正如我们很快就会看到重要性采样（使用偏差估计器）所生成的样本偏向于特定方向，在这种情况下，我们通过将每个样本乘以或除以其对应的$pdf$来说明这一点。</p>
<p>蒙特卡罗积分在计算机图形学中非常普遍，因为它是离散地并且有效地近似连续积分的一种相当直观的方式：对任何面积/体积进行采样（如半球$Ω$），在该区域内生成$N$个随机样本，然后求和，并权衡每个样本对最终结果的贡献。</p>
<p>蒙特卡洛积分是一个广泛的数学主题，我们不会深入研究具体细节，但我们会提到有多种方法可以生成随机样本。 默认情况下，每个样本都是我们习惯的完全（伪）随机，但是通过利用半随机序列的某些属性，我们可以生成仍然是随机的但具有有趣属性的采样向量。 例如，我们可以对称为低差异序列的东西进行蒙特卡罗积分，这些序列仍然会生成随机样本，但每个样本分布更均匀：<br><img src="http://oqcvzqam1.bkt.clouddn.com/OpenGL42IBL%E9%95%9C%E9%9D%A2%E5%8F%8D%E5%B0%84%E9%83%A8%E5%88%86_6.png" alt=""><br>当使用低差异序列生成蒙特卡罗采样向量时，该过程称为准蒙特卡罗积分。准蒙特卡罗方法具有更快的收敛速度，这使得它们对于性能繁重的应用而言是有意思的。</p>
<h1 id="使用蒙特卡洛在PBR里直接求解积分"><a href="#使用蒙特卡洛在PBR里直接求解积分" class="headerlink" title="使用蒙特卡洛在PBR里直接求解积分"></a><font size="6" color="orange">使用蒙特卡洛在PBR里直接求解积分</font></h1><hr>
<h2 id="镜面积分部分的终极形式"><a href="#镜面积分部分的终极形式" class="headerlink" title="镜面积分部分的终极形式"></a><font size="5" color="red">镜面积分部分的终极形式</font></h2><p>那么现在我们可以用蒙特卡洛积分来代替黎曼和求解积分了。最上面的镜面积分公式使用蒙特卡洛积分来表示的话，会是下面这样子：<br>$$<br>\begin{align}<br>L_o(p,\omega_o) &amp; =\int_{\Omega}k_s\frac{DFG}{4(\omega_o\cdot n)(\omega_i\cdot n)}L_i(p,\omega_i)n\cdot\omega_id\omega_i \\<br>&amp;=\frac{1}{N}\sum_{i=0}^{N-1}\frac{k_s\frac{DFG}{4(\omega_o\cdot n)(\omega_i\cdot n)}L_i(p,\omega_i)n\cdot\omega_i}{pdf(\omega_i)}<br>\end{align}<br>$$<br>而对于镜面反射积分来说，$pdf(\omega_i)=\frac{D(n\cdot h)}{4(\omega_o\cdot h)}$，所以：<br>$$<br>\begin{align}<br>L_o(p,\omega_o) &amp;=\frac{1}{N}\sum_{i=0}^{N-1}\frac{k_s\frac{DFG}{4(\omega_o\cdot n)(\omega_i\cdot n)}L_i(p,\omega_i)n\cdot\omega_i}{\frac{D(n\cdot h)}{4(\omega_o\cdot h)}} \\<br>&amp;= \frac{1}{N}\sum_{i=0}^{N-1}k_s\frac{DFG}{4(\omega_o\cdot n)}L_i(p,\omega_i) \times \frac{4(\omega_o\cdot h)}{D(n\cdot h)}\\<br>&amp;= \frac{1}{N}\sum_{i=0}^{N-1}k_s\frac{FGL_i(p,\omega_i)(\omega_o\cdot h)}{(\omega_o\cdot n)(n\cdot h)}<br>\end{align}<br>$$<br>由于$k_s$其实就是菲涅尔函数$f$的返回值，所以实际上上面公式里的$k_s$和$f$重复了。也就是说，使用上蒙特卡洛积分以后，我们的镜面积分终极形式变成了：<br>$$L_o(p,\omega_o) = \frac{1}{N}\sum_{i=0}^{N-1}\frac{FGL_i(p,\omega_i)(\omega_o\cdot h)}{(\omega_o\cdot n)(n\cdot h)}$$<br>那么我们现在把这个公式直接转换成代码：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">float3 <span class="token function">SpecularIBL</span><span class="token punctuation">(</span> float3 SpecularColor<span class="token punctuation">,</span> <span class="token keyword">float</span> Roughness<span class="token punctuation">,</span> float3 N<span class="token punctuation">,</span> float3 V <span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>
    float3 SpecularLighting <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//循环列举出一堆观察向量wi</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">float</span> Phi <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span> Phi <span class="token operator">&lt;</span> DoublePI<span class="token punctuation">;</span> Phi <span class="token operator">+</span><span class="token operator">=</span> SampleDelta<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">float</span> Theta <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span> Theta <span class="token operator">&lt;</span> HalfPI<span class="token punctuation">;</span> Theta <span class="token operator">+</span><span class="token operator">=</span> SampleDelta<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            vec3 wi <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//wi就是入射光L的方向</span>
            vec3 wo <span class="token operator">=</span> V<span class="token punctuation">;</span>
            vec3 H <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>wi <span class="token operator">+</span> V<span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token keyword">float</span> NoV <span class="token operator">=</span> <span class="token function">saturate</span><span class="token punctuation">(</span> <span class="token function">dot</span><span class="token punctuation">(</span> N<span class="token punctuation">,</span> V <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">float</span> NoL <span class="token operator">=</span> <span class="token function">saturate</span><span class="token punctuation">(</span> <span class="token function">dot</span><span class="token punctuation">(</span> N<span class="token punctuation">,</span> L <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">float</span> NoH <span class="token operator">=</span> <span class="token function">saturate</span><span class="token punctuation">(</span> <span class="token function">dot</span><span class="token punctuation">(</span> N<span class="token punctuation">,</span> H <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">float</span> VoH <span class="token operator">=</span> <span class="token function">saturate</span><span class="token punctuation">(</span> <span class="token function">dot</span><span class="token punctuation">(</span> V<span class="token punctuation">,</span> H <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token keyword">if</span><span class="token punctuation">(</span> NoL <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                float3 SampleColor <span class="token operator">=</span> <span class="token function">texture</span><span class="token punctuation">(</span>u_EnvMap<span class="token punctuation">,</span> wi<span class="token punctuation">)</span><span class="token punctuation">.</span>rgb<span class="token punctuation">;</span>
                <span class="token keyword">float</span> G <span class="token operator">=</span> <span class="token function">GeometrySmith</span><span class="token punctuation">(</span> Roughness<span class="token punctuation">,</span> NoV<span class="token punctuation">,</span> NoL <span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">float</span> Fc <span class="token operator">=</span> <span class="token function">pow</span><span class="token punctuation">(</span> <span class="token number">1</span> <span class="token operator">-</span> VoH<span class="token punctuation">,</span> <span class="token number">5</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
                float3 F <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> Fc<span class="token punctuation">)</span> <span class="token operator">*</span> SpecularColor <span class="token operator">+</span> Fc<span class="token punctuation">;</span>
                <span class="token comment" spellcheck="true">// Incident light = SampleColor * NoL</span>
                <span class="token comment" spellcheck="true">// Microfacet specular = D*G*F / (4*NoL*NoV)</span>
                <span class="token comment" spellcheck="true">// pdf = D * NoH / (4 * VoH)</span>
                SpecularLighting <span class="token operator">+</span><span class="token operator">=</span> SampleColor <span class="token operator">*</span> F <span class="token operator">*</span> G <span class="token operator">*</span> VoH <span class="token operator">/</span> <span class="token punctuation">(</span>NoH <span class="token operator">*</span> NoV<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token operator">++</span>SampleCount<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    SpecularLighting  <span class="token operator">=</span> SpecularLighting  <span class="token operator">/</span> SampleCount<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>是不是总感觉还是用的黎曼和在求解积分（虽然我们确实用的是蒙特卡洛求解积分的公式）？原因在于我们还是用的球面坐标和移动步长来算的$\omega_i$。其实我们可以借助前面讲的低差异序列来生成$\omega_i$。这样可以生成一些均匀样本，而且不必要使用两层循环。那么我们来具体看一下什么是低差异序列。</p>
<h2 id="低差异序列"><a href="#低差异序列" class="headerlink" title="低差异序列"></a><font size="5" color="red">低差异序列</font></h2><p> 我们将使用Holmers Dammertz详细描述的Hammersley序列。 Hammersley序列基于Van Der Corpus序列，后者反映了小数点后面的十进制数的二进制表示。</p>
<p>使用一些巧妙的比特技巧，我们可以在着色器程序中非常有效地生成Van Der Corpus序列，我们使用该着色器在总共N个样本里获得样本i的Hammersley序列：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">float</span> <span class="token function">RadicalInverse_VdC</span><span class="token punctuation">(</span>uint bits<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    bits <span class="token operator">=</span> <span class="token punctuation">(</span>bits <span class="token operator">&lt;&lt;</span> <span class="token number">16u</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span>bits <span class="token operator">>></span> <span class="token number">16u</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    bits <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>bits <span class="token operator">&amp;</span> <span class="token number">0x55555555u</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1u</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>bits <span class="token operator">&amp;</span> <span class="token number">0xAAAAAAAAu</span><span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1u</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    bits <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>bits <span class="token operator">&amp;</span> <span class="token number">0x33333333u</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">2u</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>bits <span class="token operator">&amp;</span> <span class="token number">0xCCCCCCCCu</span><span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">2u</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    bits <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>bits <span class="token operator">&amp;</span> <span class="token number">0x0F0F0F0Fu</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">4u</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>bits <span class="token operator">&amp;</span> <span class="token number">0xF0F0F0F0u</span><span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">4u</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    bits <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>bits <span class="token operator">&amp;</span> <span class="token number">0x00FF00FFu</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">8u</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>bits <span class="token operator">&amp;</span> <span class="token number">0xFF00FF00u</span><span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">8u</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">float</span><span class="token punctuation">(</span>bits<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2.3283064365386963e-10</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// / 0x100000000</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">// ----------------------------------------------------------------------------</span>
vec2 <span class="token function">Hammersley</span><span class="token punctuation">(</span>uint i<span class="token punctuation">,</span> uint N<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">vec2</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token operator">/</span><span class="token keyword">float</span><span class="token punctuation">(</span>N<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">RadicalInverse_VdC</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>Hammersley</code>函数为我们提供了大小为<code>N</code>的总样本集的低差异样本<code>i</code>。</p>
<blockquote>
<p>不支持位操作时的Hammersley序列</p>
<p>并非所有与OpenGL相关的驱动程序都支持位运算符（例如WebGL和OpenGL ES 2.0），在这种情况下，你可能希望使用不依赖于位运算符的替代版Van Der Corpus Sequence：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">float</span> <span class="token function">VanDerCorpus</span><span class="token punctuation">(</span>uint n<span class="token punctuation">,</span> <span class="token operator">></span> uint base<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">float</span> invBase <span class="token operator">=</span> <span class="token number">1.0</span> <span class="token operator">/</span> <span class="token keyword">float</span><span class="token punctuation">(</span>base<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">float</span> denom   <span class="token operator">=</span> <span class="token number">1.0</span><span class="token punctuation">;</span>
    <span class="token keyword">float</span> result  <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span><span class="token punctuation">(</span>uint i <span class="token operator">=</span> <span class="token number">0u</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">32u</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">></span> <span class="token number">0u</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            denom   <span class="token operator">=</span> <span class="token function">mod</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            result <span class="token operator">+</span><span class="token operator">=</span> denom <span class="token operator">*</span> invBase<span class="token punctuation">;</span>
            invBase <span class="token operator">=</span> invBase <span class="token operator">/</span> <span class="token number">2.0</span><span class="token punctuation">;</span>
            n       <span class="token operator">=</span> <span class="token function">uint</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">// ----------------------------------------------------------------------------</span>
vec2 <span class="token function">HammersleyNoBitOps</span><span class="token punctuation">(</span>uint i<span class="token punctuation">,</span> uint N<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">vec2</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token operator">/</span><span class="token keyword">float</span><span class="token punctuation">(</span>N<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">VanDerCorpus</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token number">2u</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>请注意，由于旧硬件中的GLSL循环限制，序列循环会遍历所有可能的32位。这个版本性能较差，但可以在所有硬件上运行，即使是那些不支持位操作的硬件。</p>
</blockquote>
<p>想要更详细了解低差异序列原理的，可以参考<a href="https://blog.csdn.net/i_dovelemon/article/details/76599923" target="_blank" rel="external">这篇文章</a>。</p>
<p>那么现在我们可以使用低差异序列来生成$\omega_i$了：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">float3 <span class="token function">SpecularIBL</span><span class="token punctuation">(</span> float3 SpecularColor<span class="token punctuation">,</span> <span class="token keyword">float</span> Roughness<span class="token punctuation">,</span> float3 N<span class="token punctuation">,</span> float3 V <span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>
    float3 SpecularLighting <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//使用低差异序列来生成一堆观察向量wi</span>
    <span class="token keyword">const</span> uint NumSamples <span class="token operator">=</span> <span class="token number">1024</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span> uint i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> NumSamples<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        float2 Xi <span class="token operator">=</span> <span class="token function">Hammersley</span><span class="token punctuation">(</span> i<span class="token punctuation">,</span> NumSamples <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//使用低差异序列来生成入射光方向</span>
        vec3 wi <span class="token operator">=</span> <span class="token function">vec3</span><span class="token punctuation">(</span>Xi<span class="token punctuation">,</span> <span class="token function">random</span><span class="token punctuation">(</span><span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//wi就是入射光L的方向</span>
        vec3 wo <span class="token operator">=</span> V<span class="token punctuation">;</span>
        vec3 H <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>wi <span class="token operator">+</span> V<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">float</span> NoV <span class="token operator">=</span> <span class="token function">saturate</span><span class="token punctuation">(</span> <span class="token function">dot</span><span class="token punctuation">(</span> N<span class="token punctuation">,</span> V <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">float</span> NoL <span class="token operator">=</span> <span class="token function">saturate</span><span class="token punctuation">(</span> <span class="token function">dot</span><span class="token punctuation">(</span> N<span class="token punctuation">,</span> L <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">float</span> NoH <span class="token operator">=</span> <span class="token function">saturate</span><span class="token punctuation">(</span> <span class="token function">dot</span><span class="token punctuation">(</span> N<span class="token punctuation">,</span> H <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">float</span> VoH <span class="token operator">=</span> <span class="token function">saturate</span><span class="token punctuation">(</span> <span class="token function">dot</span><span class="token punctuation">(</span> V<span class="token punctuation">,</span> H <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">if</span><span class="token punctuation">(</span> NoL <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            float3 SampleColor <span class="token operator">=</span> <span class="token function">texture</span><span class="token punctuation">(</span>u_EnvMap<span class="token punctuation">,</span> wi<span class="token punctuation">)</span><span class="token punctuation">.</span>rgb<span class="token punctuation">;</span>
            <span class="token keyword">float</span> G <span class="token operator">=</span> <span class="token function">GeometrySmith</span><span class="token punctuation">(</span> Roughness<span class="token punctuation">,</span> NoV<span class="token punctuation">,</span> NoL <span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">float</span> Fc <span class="token operator">=</span> <span class="token function">pow</span><span class="token punctuation">(</span> <span class="token number">1</span> <span class="token operator">-</span> VoH<span class="token punctuation">,</span> <span class="token number">5</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
            float3 F <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> Fc<span class="token punctuation">)</span> <span class="token operator">*</span> SpecularColor <span class="token operator">+</span> Fc<span class="token punctuation">;</span>

            SpecularLighting <span class="token operator">+</span><span class="token operator">=</span> SampleColor <span class="token operator">*</span> F <span class="token operator">*</span> G <span class="token operator">*</span> VoH <span class="token operator">/</span> <span class="token punctuation">(</span>NoH <span class="token operator">*</span> NoV<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    SpecularLighting  <span class="token operator">=</span> SpecularLighting  <span class="token operator">/</span> NumSamples<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这样一来看起来就不再像是黎曼和积分了，代码也变得更简单。但是实际上使用1024个采样点依然得不到好的反射效果。实际上，我们使用均匀采样对于漫反射来说是适用的，但是对于镜面反射效果就不是很好了，因为镜面反射时，由于表面有粗糙度，出射光线大多数是靠近反射向量（和入射向量对称的那条）的，会围绕反射向量形成一个像叶子一样的形状，我们称之为镜面叶。如下图所示：<br><img src="http://oqcvzqam1.bkt.clouddn.com/OpenGL42IBL%E9%95%9C%E9%9D%A2%E5%8F%8D%E5%B0%84%E9%83%A8%E5%88%86_4.png" alt=""><br>随着粗糙度的增加，镜面叶的大小也会增加；而入射光方向不同时，镜面叶的形状也会发生变化。因此，镜面叶的形状高度依赖于材质。</p>
<p>由于大多数反射光线都是在镜面叶里面的（即靠近反射向量），所以如果我们均匀采样的话，会有很多采样向量是没有意义的，我们应该尽量让采样向量偏向于反射向量。这个过程其实就叫做重要性采样。镜面叶外的任何随机生成的样本都与镜面积分无关，将样本生成集中在镜面叶内才是有意义的，当然代价是蒙特卡罗估计偏差。那么我们下面具体来看一下什么是重要性采样。</p>
<h2 id="GGX重要性采样"><a href="#GGX重要性采样" class="headerlink" title="GGX重要性采样"></a><font size="5" color="red">GGX重要性采样</font></h2><p>从本质上讲，重要性采样是：在一些受粗糙度限制的区域内生成样采样向量，该区域以微平面半程向量为轴环绕。通过将低差异序列和GGX正态分布函数相结合，来偏置采样向量（即让采样向量偏向于某一个方向），我们获得了高收敛率。因为我们可以以更快的速度解决问题，所以我们只需要更少的样本就可以达到足够的近似值。 </p>
<p>我们将基于表面粗糙度，生成偏向于微表面法线的半程向量，而不是均匀或随机（蒙特卡罗）在积分的半球Ω上生成样本矢量（其实实际上半程向量偏向于法线，也就等同于出射向量偏向于镜面反射向量，我们本质上是要求出射向量对应的入射向量$\omega_i$的，直接获得半程向量的好处是：我们不需要再去求入射向量的镜面反射向量了，可以降低点计算量嘛）。 </p>
<p>为了构建采样，我们需要一些方法来使采样向量朝向和偏置向某些表面粗糙度下的镜面叶。我们可以使用<a href="http://popperelay.cn/2018/08/14/OpenGL39-PBR%E7%90%86%E8%AE%BA/" target="_blank" rel="external">《OPENGL39 PBR理论》</a>中描述的NDF，将GGX NDF结合在Epic Games描述的球形采样向量过程中。至于怎样结合GGX让采样向量更靠近于某个方向（这里是法线方向（或者叫观察方向）），推导过程太长了，直接给出采样向量的球面坐标公式：<br>$$\theta_s = arctan(\frac{\alpha\sqrt{\xi_1}}{\sqrt{1-\xi_1}}) \\<br>\phi_s = 2\pi\xi_2$$<br>其中$\xi_1$和$\xi_2$就分别是二维Hammersley序列的<code>x</code>和<code>y</code>（具体可参考<a href="http://www.codinglabs.net/article_physically_based_rendering_cook_torrance.aspx" target="_blank" rel="external">这篇文章</a>）。</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">vec3 <span class="token function">ImportanceSampleGGX</span><span class="token punctuation">(</span>vec2 Xi<span class="token punctuation">,</span> vec3 N<span class="token punctuation">,</span> <span class="token keyword">float</span> roughness<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">float</span> a <span class="token operator">=</span> roughness<span class="token operator">*</span>roughness<span class="token punctuation">;</span>

    <span class="token keyword">float</span> phi <span class="token operator">=</span> <span class="token number">2.0</span> <span class="token operator">*</span> PI <span class="token operator">*</span> Xi<span class="token punctuation">.</span>x<span class="token punctuation">;</span>
    <span class="token keyword">float</span> cosTheta <span class="token operator">=</span> <span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1.0</span> <span class="token operator">-</span> Xi<span class="token punctuation">.</span>y<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token number">1.0</span> <span class="token operator">+</span> <span class="token punctuation">(</span>a<span class="token operator">*</span>a <span class="token operator">-</span> <span class="token number">1.0</span><span class="token punctuation">)</span> <span class="token operator">*</span> Xi<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//可以由上面arctan的公式推出来</span>
    <span class="token keyword">float</span> sinTheta <span class="token operator">=</span> <span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token number">1.0</span> <span class="token operator">-</span> cosTheta<span class="token operator">*</span>cosTheta<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// from spherical coordinates to cartesian coordinates</span>
    vec3 H<span class="token punctuation">;</span>
    H<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token function">cos</span><span class="token punctuation">(</span>phi<span class="token punctuation">)</span> <span class="token operator">*</span> sinTheta<span class="token punctuation">;</span>
    H<span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token function">sin</span><span class="token punctuation">(</span>phi<span class="token punctuation">)</span> <span class="token operator">*</span> sinTheta<span class="token punctuation">;</span>
    H<span class="token punctuation">.</span>z <span class="token operator">=</span> cosTheta<span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// from tangent-space vector to world-space sample vector</span>
    vec3 up        <span class="token operator">=</span> <span class="token function">abs</span><span class="token punctuation">(</span>N<span class="token punctuation">.</span>z<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0.999</span> <span class="token operator">?</span> <span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    vec3 tangent   <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span><span class="token function">cross</span><span class="token punctuation">(</span>up<span class="token punctuation">,</span> N<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    vec3 bitangent <span class="token operator">=</span> <span class="token function">cross</span><span class="token punctuation">(</span>N<span class="token punctuation">,</span> tangent<span class="token punctuation">)</span><span class="token punctuation">;</span>

    vec3 sampleVec <span class="token operator">=</span> tangent <span class="token operator">*</span> H<span class="token punctuation">.</span>x <span class="token operator">+</span> bitangent <span class="token operator">*</span> H<span class="token punctuation">.</span>y <span class="token operator">+</span> N <span class="token operator">*</span> H<span class="token punctuation">.</span>z<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">normalize</span><span class="token punctuation">(</span>sampleVec<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>重要性采样的这个方法，基于一些输入参数粗糙度和低差异序列值<code>Xi</code>，返回给我们一个在一定程度上靠向微表面半程向量的样本向量。 请注意，根据迪士尼最初的PBR研究，Epic Games使用平方粗糙度来获得更好的视觉效果。</p>
<p>有了低差异的Hammersley序列和偏向于法线的样本生成方式，我们可以重写一下在PBR里计算积分的代码了：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">float3 <span class="token function">SpecularIBL</span><span class="token punctuation">(</span>vec3 SpecularColor<span class="token punctuation">,</span> <span class="token keyword">float</span> Roughness<span class="token punctuation">,</span> vec3 N<span class="token punctuation">,</span> vec3 V<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    vec3 SpecularLighting <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> uint NumSamples <span class="token operator">=</span> <span class="token number">1024</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span> uint i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> NumSamples<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        vec2 Xi <span class="token operator">=</span> <span class="token function">Hammersley</span><span class="token punctuation">(</span> i<span class="token punctuation">,</span> NumSamples <span class="token punctuation">)</span><span class="token punctuation">;</span>
        vec3 H <span class="token operator">=</span> <span class="token function">ImportanceSampleGGX</span><span class="token punctuation">(</span> Xi<span class="token punctuation">,</span> Roughness<span class="token punctuation">,</span> N <span class="token punctuation">)</span><span class="token punctuation">;</span>
        vec3 L <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span><span class="token number">2.0</span> <span class="token operator">*</span> <span class="token function">dot</span><span class="token punctuation">(</span> V<span class="token punctuation">,</span> H <span class="token punctuation">)</span> <span class="token operator">*</span> H <span class="token operator">-</span> V<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">float</span> NoV <span class="token operator">=</span> <span class="token function">saturate</span><span class="token punctuation">(</span> <span class="token function">dot</span><span class="token punctuation">(</span> N<span class="token punctuation">,</span> V <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">float</span> NoL <span class="token operator">=</span> <span class="token function">saturate</span><span class="token punctuation">(</span> <span class="token function">dot</span><span class="token punctuation">(</span> N<span class="token punctuation">,</span> L <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">float</span> NoH <span class="token operator">=</span> <span class="token function">saturate</span><span class="token punctuation">(</span> <span class="token function">dot</span><span class="token punctuation">(</span> N<span class="token punctuation">,</span> H <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">float</span> VoH <span class="token operator">=</span> <span class="token function">saturate</span><span class="token punctuation">(</span> <span class="token function">dot</span><span class="token punctuation">(</span> V<span class="token punctuation">,</span> H <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">if</span><span class="token punctuation">(</span> NoL <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            vec3 SampleColor <span class="token operator">=</span> <span class="token function">texture</span><span class="token punctuation">(</span>u_EnvMap<span class="token punctuation">,</span> L<span class="token punctuation">)</span><span class="token punctuation">.</span>rgb<span class="token punctuation">;</span>
            <span class="token keyword">float</span> G <span class="token operator">=</span> <span class="token function">GeometrySmith</span><span class="token punctuation">(</span> Roughness<span class="token punctuation">,</span> NoV<span class="token punctuation">,</span> NoL <span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">float</span> Fc <span class="token operator">=</span> <span class="token function">pow</span><span class="token punctuation">(</span> <span class="token number">1</span> <span class="token operator">-</span> VoH<span class="token punctuation">,</span> <span class="token number">5</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
            vec3 F <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> Fc<span class="token punctuation">)</span> <span class="token operator">*</span> SpecularColor <span class="token operator">+</span> Fc<span class="token punctuation">;</span>

            SpecularLighting <span class="token operator">+</span><span class="token operator">=</span> SampleColor <span class="token operator">*</span> F <span class="token operator">*</span> G <span class="token operator">*</span> VoH <span class="token operator">/</span> <span class="token punctuation">(</span>NoH <span class="token operator">*</span> NoV<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    SpecularLighting  <span class="token operator">=</span> SpecularLighting  <span class="token operator">/</span> NumSamples<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中<code>vec3 L  = normalize(2.0 * dot(V, H) * H - V);</code>是根据观察向量<code>V</code>和半程向量<code>H</code>，来求入射向量<code>L</code>，原理如下图（<code>V</code>和<code>L</code>都是单位向量，所以下图的四边形是一个菱形）（注意积分积的不是镜面叶里的反射向量，而是它们对应的入射向量）。<br><img src="http://oqcvzqam1.bkt.clouddn.com/OpenGL42IBL%E9%95%9C%E9%9D%A2%E5%8F%8D%E5%B0%84%E9%83%A8%E5%88%86_6_2.png" alt=""></p>
<h1 id="预计算镜面积分部分：分割求和近似"><a href="#预计算镜面积分部分：分割求和近似" class="headerlink" title="预计算镜面积分部分：分割求和近似"></a><font size="6" color="orange">预计算镜面积分部分：分割求和近似</font></h1><hr>
<p>前面所做的工作都是在PBR里面进行的，也就是说前面的积分是每帧都要运行的，实际上这运行起来很耗时，难以达到实时效率。那么我们能不能像漫反射积分那样，利用cubemap预先计算好所有法线半球（以法线为轴的半球）里的漫反射积分，然后将结果存储到辐照度cubemap里呢？</p>
<p>如果像之前漫反射积分一样，我们通过绘制一个立方体来运行着色器。那么也就是说我们能够在着色器里，通过立方体的顶点知道入射光方向$\omega_i$，但是我们看一下镜面积分的终极形式：<br>$$L_o(p,\omega_o) = \frac{1}{N}\sum_{i=0}^{N-1}\frac{FGL_i(p,\omega_i)(\omega_o\cdot h)}{(\omega_o\cdot n)(n\cdot h)}$$<br>求这个积分不仅要求我们知道$\omega_i$，还要知道$\omega_o$是什么。从绘制的立方体里面，我们只能知道$\omega_i$，而无法得知$\omega_o$，因为$\omega_o$是和摄像机位置和点$p$的位置来确定的，而在绘制的立方体中这两个值都无法在预计算拿到（因为摄像机位置在运行过程中会变，不同的点即使它们受到的入射光方向$\omega_i$相同，由于位置不同也会导致$\omega_o$发生改变），而漫反射积分部分里面只有一个$\omega_i$在变，所以可以很简单地对它进行预先积分。但是对于镜面反射积分，$\omega_i$和$\omega_o$都在变，就很难预先积分出想要的结果（即运行时直接拿来采样就能得到对应的镜面颜色）了。那么我们有没有什么办法可以把$\omega_i$和$\omega_o$分开呢？</p>
<p>我们可以把镜面积分变成如下形式：<br>$$L_o(p,\omega_o) = (\frac{1}{N}\sum_{i=0}^{N-1}L_i(p,\omega_i))(\frac{1}{N}\sum_{i=0}^{N-1}\frac{FG(\omega_o\cdot h)}{(\omega_o\cdot n)(n\cdot h)})$$<br>其中$\theta$是光线入射向量$\omega_i$和法线$n$的夹角。（为什么会变成这种形式，后面看到了这两部分各自的GLSL程序就知道了）。</p>
<p>如果写成原来的积分形式的话就是下面这样：<br>$$<br>L_o(p,\omega_o)==\int_{\Omega}L_id\omega_i\int_{\Omega}f_r(p,\omega_i,\omega_o)n\cdot\omega_id\omega_i<br>$$<br>对于第一部分确实是只有$\omega_i$没有$\omega_o$了，但是对于第二部分好像$\omega_i$和$\omega_o$还是在一起。但是实际上，第二部分由于和辐射度一点关系没有，我们完全可以在切线空间下来计算这一部分。由于切线空间下，法线向量$n=(0,0,1)$，那么我们可以指定一个法线向量$n$和观察向量$v$（或者说$\omega_o$）之间的夹角余弦值$\cos\theta$，从而计算出观察向量$\omega_o$的坐标，同时我们可以通过重要性采样得到一堆偏向法线$n=(0,0,1)$的半程向量$h$，所以我们就可以通过观察向量$\omega_o$和半程向量$h$得到一堆对应的入射向量$\omega_i$，然后来进行积分（可以对照后面的代码来加深理解）。</p>
<p>这里面有一个很重要的前提：第二部分是在切线空间下进行的（当然第一部分可以在世界空间下进行）。因为在切线空间下，无论是哪个点，它们的法线都是相同的$n=(0,0,1)$，我们可以借助这个量，来从$\omega_o$和重要性采样得到的$h$来计算出对应的$\omega_i$。如果不是在切线空间下，由于$n$对于每一个点都可能不一样，我们就很难找到$\omega_o$和$\omega_i$之间的这种一一对应关系（因为其中会加入其它变量，比如世界空间里的$n$）。正是由于切线空间下可以由$\omega_o$推出$\omega_i$，所以我们也可以很简单的进行积分了。由于第二部分不涉及到关照参数，所以我们也没有必要绘制一个立方体（漫反射积分绘制立方体是为了在每一个立方体顶点的方向上存储一个辐照度结果），而且这部分除了上面说所的$n$和$\omega_o$之间的夹角余弦值这个参数以外，就只剩下粗糙度这个参数了，也就是说对于这两个参数的每一个组合，我们都要来一次第二部分的积分计算。而这两个参数都是可以转换到[0,1]之间的，所以我们完全可以借助一张二维纹理来完成这个积分过程，以纹理坐标的x分量作为夹角余弦值，以y分量作为粗糙度，然后将积分所得的结果作为颜色值存入对应的纹素位置上。得到的二维纹理称为BRDF积分纹理。</p>
<p>而第一部分的积分计算由于涉及到了辐照率，同时只和$\omega_i$有关，所以可以用和漫反射积分一样的方法来求解就可以了。得到的cubemap称为预过滤环境贴图。</p>
<p>最后，我们在PBR中，可以根据当前渲染的物体片元的世界坐标来索引预过滤环境贴图得到镜面积分的第一部分的结果，根据当前片元的法线和观察向量的余弦值作为x值，粗糙度作为y值，来查找BRDF积分纹理得到镜面积分的第二部分的结果，然后把它们乘起来就得到最终的镜面积分结果了。</p>
<p>把镜面积分分为两部分的这个过程，其实就叫分割求和近似（Split Sum Approximation）。下面我们分别来看一下这两部分积分具体怎么算。</p>
<h1 id="分割求和的第一部分：预过滤环境贴图"><a href="#分割求和的第一部分：预过滤环境贴图" class="headerlink" title="分割求和的第一部分：预过滤环境贴图"></a><font size="6" color="orange">分割求和的第一部分：预过滤环境贴图</font></h1><hr>
<p>第一个部分（当进行卷积时）称为预过滤环境贴图，是一个预先计算的环境卷积贴图（类似于辐照度贴图），不过这次考虑了粗糙度。为了增加粗糙度的级别数，会使用更多散乱的采样向量来卷积环境贴图，从而产生更多模糊的反射。对于我们卷积的每个粗糙度级别，我们会将顺序模糊结果存储在预过滤贴图的mipmap层级中。例如，预过滤的环境贴图在其5个mipmap层级中存储5个不同粗糙度值下的预卷积结果，如下图所示：<br><img src="http://oqcvzqam1.bkt.clouddn.com/OpenGL42IBL%E9%95%9C%E9%9D%A2%E5%8F%8D%E5%B0%84%E9%83%A8%E5%88%86_1.png" alt=""><br>由于我们使用重要性采样来获得偏向法线的半程向量，然后需要用观察向量来得到对应的光线入射向量$\omega_i$，但是在卷积环境贴图时事先不知道观察方向，所以Epic Games通过假设观察方向（也即是镜面反射方向）总是等于输出采样向量$\omega_o$来做了进一步的近似。代码如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">vec3 N <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>w_o<span class="token punctuation">)</span><span class="token punctuation">;</span>
vec3 R <span class="token operator">=</span> N<span class="token punctuation">;</span>
vec3 V <span class="token operator">=</span> R<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>通过这种方式，预过滤的环境卷积不需要知道观察方向。当然，这也是瑕疵所在，意味着当我们从一个角度观察镜面反射时，我们不会得到很好的grazing镜面反射效果（好的效果应该像下面左图一样，镜面反射的结果应该是被拉长的），如下图所示（来自于一篇介绍移动霜冻的PBR文章）；不过，这通常被认为是一个还可以接受的妥协：<br><img src="http://oqcvzqam1.bkt.clouddn.com/OpenGL42IBL%E9%95%9C%E9%9D%A2%E5%8F%8D%E5%B0%84%E9%83%A8%E5%88%86_2.png" alt=""><br>预过滤环境贴图与我们如何对光照贴图进行卷积非常相似。 不同之处在于我们现在考虑粗糙度，并在预过滤贴图的mip层级中按顺序存储更粗糙的反射。</p>
<p>我们还是使用低差异序列和重要性采样来生成偏向法线的半程向量，使用法线和入射向量的夹角余弦值作为权重（注意我们这里并没有和公式一样来除以采样个数），其余的和之前卷积漫反射环境贴图大致一样（绘制立方体，以立方体插值之后的片元位置为入射光线方向$\omega_i$）：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#version 430 core</span>

in vec4 g2f_WorldPos<span class="token punctuation">;</span>
out vec4 Color_<span class="token punctuation">;</span>

uniform samplerCube u_EnvironmentCubeMap<span class="token punctuation">;</span>
uniform <span class="token keyword">float</span> u_Roughness<span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token keyword">float</span> PI <span class="token operator">=</span> <span class="token number">3.14159265359</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html</span>
<span class="token comment" spellcheck="true">// efficient VanDerCorpus calculation.</span>
<span class="token keyword">float</span> <span class="token function">RadicalInverse_VdC</span><span class="token punctuation">(</span>uint uBits<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
     uBits <span class="token operator">=</span> <span class="token punctuation">(</span>uBits <span class="token operator">&lt;&lt;</span> <span class="token number">16u</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span>uBits <span class="token operator">>></span> <span class="token number">16u</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     uBits <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>uBits <span class="token operator">&amp;</span> <span class="token number">0x55555555u</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1u</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>uBits <span class="token operator">&amp;</span> <span class="token number">0xAAAAAAAAu</span><span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1u</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     uBits <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>uBits <span class="token operator">&amp;</span> <span class="token number">0x33333333u</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">2u</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>uBits <span class="token operator">&amp;</span> <span class="token number">0xCCCCCCCCu</span><span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">2u</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     uBits <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>uBits <span class="token operator">&amp;</span> <span class="token number">0x0F0F0F0Fu</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">4u</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>uBits <span class="token operator">&amp;</span> <span class="token number">0xF0F0F0F0u</span><span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">4u</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     uBits <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>uBits <span class="token operator">&amp;</span> <span class="token number">0x00FF00FFu</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">8u</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>uBits <span class="token operator">&amp;</span> <span class="token number">0xFF00FF00u</span><span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">8u</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token keyword">return</span> <span class="token keyword">float</span><span class="token punctuation">(</span>uBits<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2.3283064365386963e-10</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// / 0x100000000</span>
<span class="token punctuation">}</span>

vec2 <span class="token function">Hammersley</span><span class="token punctuation">(</span>uint vIndex<span class="token punctuation">,</span> uint vN<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">vec2</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">(</span>vIndex<span class="token punctuation">)</span><span class="token operator">/</span><span class="token keyword">float</span><span class="token punctuation">(</span>vN<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">RadicalInverse_VdC</span><span class="token punctuation">(</span>vIndex<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

vec3 <span class="token function">ImportanceSampleGGX</span><span class="token punctuation">(</span>vec2 vHammersleyVec<span class="token punctuation">,</span> vec3 vNormal<span class="token punctuation">,</span> <span class="token keyword">float</span> vRoughness<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">float</span> a <span class="token operator">=</span> vRoughness <span class="token operator">*</span> vRoughness<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//Theta和Phi是半程向量的球面坐标</span>
    <span class="token keyword">float</span> Phi <span class="token operator">=</span> <span class="token number">2.0</span> <span class="token operator">*</span> PI <span class="token operator">*</span> vHammersleyVec<span class="token punctuation">.</span>x<span class="token punctuation">;</span>
    <span class="token keyword">float</span> CosTheta <span class="token operator">=</span> <span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1.0</span> <span class="token operator">-</span> vHammersleyVec<span class="token punctuation">.</span>y<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token number">1.0</span> <span class="token operator">+</span> <span class="token punctuation">(</span>a <span class="token operator">*</span> a <span class="token operator">-</span> <span class="token number">1.0</span><span class="token punctuation">)</span> <span class="token operator">*</span> vHammersleyVec<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//可以由上面arctan的公式推出来</span>
    <span class="token keyword">float</span> SinTheta <span class="token operator">=</span> <span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token number">1.0</span> <span class="token operator">-</span> CosTheta <span class="token operator">*</span> CosTheta<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//H是半程向量在其切线空间里的坐标</span>
    vec3 H<span class="token punctuation">;</span>
    H<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token function">cos</span><span class="token punctuation">(</span>Phi<span class="token punctuation">)</span> <span class="token operator">*</span> SinTheta<span class="token punctuation">;</span>
    H<span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token function">sin</span><span class="token punctuation">(</span>Phi<span class="token punctuation">)</span> <span class="token operator">*</span> SinTheta<span class="token punctuation">;</span>
    H<span class="token punctuation">.</span>z <span class="token operator">=</span> CosTheta<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//从切线空间转换到世界空间</span>
    vec3 Up        <span class="token operator">=</span> <span class="token function">abs</span><span class="token punctuation">(</span>vNormal<span class="token punctuation">.</span>z<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0.999</span> <span class="token operator">?</span> <span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    vec3 Tangent   <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span><span class="token function">cross</span><span class="token punctuation">(</span>Up<span class="token punctuation">,</span> vNormal<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    vec3 Bitangent <span class="token operator">=</span> <span class="token function">cross</span><span class="token punctuation">(</span>vNormal<span class="token punctuation">,</span> Tangent<span class="token punctuation">)</span><span class="token punctuation">;</span>
    vec3 SampleVec <span class="token operator">=</span> Tangent <span class="token operator">*</span> H<span class="token punctuation">.</span>x <span class="token operator">+</span> Bitangent <span class="token operator">*</span> H<span class="token punctuation">.</span>y <span class="token operator">+</span> vNormal <span class="token operator">*</span> H<span class="token punctuation">.</span>z<span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token function">normalize</span><span class="token punctuation">(</span>SampleVec<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    vec3 Normal <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span><span class="token function">vec3</span><span class="token punctuation">(</span>g2f_WorldPos<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//假设V=R=Normal</span>
    vec3 R <span class="token operator">=</span> Normal<span class="token punctuation">;</span>
    vec3 V <span class="token operator">=</span> R<span class="token punctuation">;</span>

    <span class="token keyword">const</span> <span class="token keyword">int</span> SAMPLE_COUNT <span class="token operator">=</span> <span class="token number">1024</span><span class="token punctuation">;</span>
    vec3 PrefilteredColor <span class="token operator">=</span> <span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">float</span> TotalWeight <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> SAMPLE_COUNT<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        vec2 HammersleyVec <span class="token operator">=</span> <span class="token function">Hammersley</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> SAMPLE_COUNT<span class="token punctuation">)</span><span class="token punctuation">;</span>
        vec3 H <span class="token operator">=</span> <span class="token function">ImportanceSampleGGX</span><span class="token punctuation">(</span>HammersleyVec<span class="token punctuation">,</span> Normal<span class="token punctuation">,</span> u_Roughness<span class="token punctuation">)</span><span class="token punctuation">;</span>
        vec3 L <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span><span class="token number">2.0</span> <span class="token operator">*</span> <span class="token function">dot</span><span class="token punctuation">(</span>V<span class="token punctuation">,</span> H<span class="token punctuation">)</span> <span class="token operator">*</span> H <span class="token operator">-</span> V<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">float</span> NdotL <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token function">dot</span><span class="token punctuation">(</span>Normal<span class="token punctuation">,</span> L<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>NdotL <span class="token operator">></span> <span class="token number">0.0</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            PrefilteredColor <span class="token operator">+</span><span class="token operator">=</span> <span class="token function">texture</span><span class="token punctuation">(</span>u_EnvironmentCubeMap<span class="token punctuation">,</span> L<span class="token punctuation">)</span><span class="token punctuation">.</span>rgb <span class="token operator">*</span> NdotL<span class="token punctuation">;</span>
            TotalWeight      <span class="token operator">+</span><span class="token operator">=</span> NdotL<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    PrefilteredColor <span class="token operator">=</span> PrefilteredColor <span class="token operator">/</span> TotalWeight<span class="token punctuation">;</span>

    Color_ <span class="token operator">=</span> <span class="token function">vec4</span><span class="token punctuation">(</span>PrefilteredColor<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后，我们需要生成一个新的立方体贴图来保存预过滤的环境贴图数据（因为要对不同的粗糙度存储不同的积分结果，所以我们需要为预过滤cubemap环境贴图生成多个mipmap层级）。 为了确保我们为其mip层级分配足够的内存，我们简单地调用<code>glGenerateMipmap</code>来分配所需的内存量。</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">GLuint PrefilterEnvMap <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token function">glGenTextures</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>PrefilterEnvMap<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">glBindTexture</span><span class="token punctuation">(</span>GL_TEXTURE_CUBE_MAP<span class="token punctuation">,</span> PrefilterEnvMap<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">6</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
    <span class="token function">glTexImage2D</span><span class="token punctuation">(</span>GL_TEXTURE_CUBE_MAP_POSITIVE_X <span class="token operator">+</span> i<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> GL_RGB16F<span class="token punctuation">,</span> <span class="token number">128</span><span class="token punctuation">,</span> <span class="token number">128</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> GL_RGB<span class="token punctuation">,</span> GL_FLOAT<span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">glTexParameteri</span><span class="token punctuation">(</span>GL_TEXTURE_CUBE_MAP<span class="token punctuation">,</span> GL_TEXTURE_WRAP_S<span class="token punctuation">,</span> GL_CLAMP_TO_EDGE<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">glTexParameteri</span><span class="token punctuation">(</span>GL_TEXTURE_CUBE_MAP<span class="token punctuation">,</span> GL_TEXTURE_WRAP_T<span class="token punctuation">,</span> GL_CLAMP_TO_EDGE<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">glTexParameteri</span><span class="token punctuation">(</span>GL_TEXTURE_CUBE_MAP<span class="token punctuation">,</span> GL_TEXTURE_WRAP_R<span class="token punctuation">,</span> GL_CLAMP_TO_EDGE<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">glTexParameteri</span><span class="token punctuation">(</span>GL_TEXTURE_CUBE_MAP<span class="token punctuation">,</span> GL_TEXTURE_MIN_FILTER<span class="token punctuation">,</span> GL_LINEAR_MIPMAP_LINEAR<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//确保将缩小过滤器设置为GL_LINEAR_MIPMAP_LINEAR以启用三线性过滤</span>
<span class="token function">glTexParameteri</span><span class="token punctuation">(</span>GL_TEXTURE_CUBE_MAP<span class="token punctuation">,</span> GL_TEXTURE_MAG_FILTER<span class="token punctuation">,</span> GL_LINEAR<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">glGenerateMipmap</span><span class="token punctuation">(</span>GL_TEXTURE_CUBE_MAP<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">glBindTexture</span><span class="token punctuation">(</span>GL_TEXTURE_CUBE_MAP<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>请注意，因为我们计划对<code>prefilterMap</code>采样其mipmap层级，所以需要确保将其缩小过滤器设置为<code>GL_LINEAR_MIPMAP_LINEAR</code>以启用三线性过滤。我们在其基本mip级别以128×128的每面分辨率存储预滤波的镜面反射。这对于大多数反射来说可能已经足够了，但如果有大量光滑材料（想想汽车反射），可能需要提高分辨率。</p>
<p>剩下要做的是让OpenGL在多个mipmap级别上使用不同的粗糙度值对环境贴图进行预过滤（就是在不同的粗糙度下多运行几次预过滤贴图的pass）。 这个实际上相当容易：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">shader <span class="token function">PrefilterEnvMap_shader</span><span class="token punctuation">(</span><span class="token string">"PrefilterEnvMap_VS.glsl"</span><span class="token punctuation">,</span> <span class="token string">"PrefilterEnvMap_FS.glsl"</span><span class="token punctuation">,</span> <span class="token string">"PrefilterEnvMap_GS.glsl"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//重复利用把球面贴图转换成cubemap的FBO，只需要换一下绑定的纹理附件即可</span>
<span class="token function">glBindFramebuffer</span><span class="token punctuation">(</span>GL_FRAMEBUFFER<span class="token punctuation">,</span> SphereMap2CubeMapFBO<span class="token punctuation">)</span><span class="token punctuation">;</span>
PrefilterEnvMap_shader<span class="token punctuation">.</span><span class="token function">Use</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">6</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
    <span class="token function">glUniformMatrix4fv</span><span class="token punctuation">(</span><span class="token function">glGetUniformLocation</span><span class="token punctuation">(</span>PrefilterEnvMap_shader<span class="token punctuation">.</span>shaderProgram<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">"u_VPMatrices4LookAtSixFaces["</span> <span class="token operator">+</span> std<span class="token operator">::</span><span class="token function">to_string</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"]"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> GL_FALSE<span class="token punctuation">,</span> <span class="token function">value_ptr</span><span class="token punctuation">(</span>VPMatrices4LookAtSixFaces<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">glBindTexture</span><span class="token punctuation">(</span>GL_TEXTURE_CUBE_MAP<span class="token punctuation">,</span> EnvCubeMap<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> MaxMipLevel <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> MipLevel <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> MipLevel <span class="token operator">&lt;</span> MaxMipLevel<span class="token punctuation">;</span> <span class="token operator">++</span>MipLevel<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    GLuint MipWidth <span class="token operator">=</span> <span class="token number">128</span> <span class="token operator">*</span> std<span class="token operator">::</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">,</span> MipLevel<span class="token punctuation">)</span><span class="token punctuation">;</span>
    GLuint MipHeight <span class="token operator">=</span> MipWidth<span class="token punctuation">;</span>
    <span class="token function">glViewport</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> MipWidth<span class="token punctuation">,</span> MipHeight<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">float</span> Roughness <span class="token operator">=</span> <span class="token keyword">float</span><span class="token punctuation">(</span>MipLevel<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span>MaxMipLevel <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">glUniform1f</span><span class="token punctuation">(</span><span class="token function">glGetUniformLocation</span><span class="token punctuation">(</span>PrefilterEnvMap_shader<span class="token punctuation">.</span>shaderProgram<span class="token punctuation">,</span> <span class="token string">"u_Roughness"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Roughness<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">glFramebufferTexture</span><span class="token punctuation">(</span>GL_FRAMEBUFFER<span class="token punctuation">,</span> GL_COLOR_ATTACHMENT0<span class="token punctuation">,</span> PrefilterEnvMap<span class="token punctuation">,</span> MipLevel<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">glClearColor</span><span class="token punctuation">(</span><span class="token number">0.01</span><span class="token punctuation">,</span> <span class="token number">0.01</span><span class="token punctuation">,</span> <span class="token number">0.01</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">//注意Clear要用在绑定纹理附件之后，否则因为是重用的SphereMap2CubeMapFBO，会把EnvCubeMap里的内容给Clear了</span>
    <span class="token function">glClear</span><span class="token punctuation">(</span>GL_COLOR_BUFFER_BIT <span class="token operator">|</span> GL_DEPTH_BUFFER_BIT<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">renderCube</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">glViewport</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> WIDTH<span class="token punctuation">,</span> HEIGHT<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">glBindTexture</span><span class="token punctuation">(</span>GL_TEXTURE_CUBE_MAP<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">glBindFramebuffer</span><span class="token punctuation">(</span>GL_FRAMEBUFFER<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>需要注意的是，由于需要绘制一个预过滤的cubemap环境贴图出来，所以我们还是使用了和以前一样的分层渲染技术（几何着色器里的<code>gl_Layer</code>）。</p>
<p>该过程类似于辐照度贴图卷积，但这次我们将帧缓冲区的尺寸缩放到适当的mipmap比例，每个mip级别将尺寸缩小2倍。另外，我们在<code>glFramebufferTexture2D</code>的最后一个参数中指定渲染的mip级别（用于将当前渲染的结果存储到纹理的指定mip层级中），并且将我们预过滤的粗糙度传递给预过滤器着色器。</p>
<p>这应该会得到一个适当的预过滤环境贴图，我们访问它的更高的mip级别时，它返回更模糊反射。如果我们在天空盒着色器中显示预过滤的环境立方体贴图，并在其着色器中强制采样稍高于第一个mip的级别，如下所示：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">vec3 EnvColor <span class="token operator">=</span> <span class="token function">textureLod</span><span class="token punctuation">(</span>u_FilterEnvMap<span class="token punctuation">,</span> v2f_WorldPos<span class="token punctuation">,</span> <span class="token number">1.2</span><span class="token punctuation">)</span><span class="token punctuation">.</span>rgb<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>我们得到的结果确实看起来像原始环境的模糊版本：<br><img src="http://oqcvzqam1.bkt.clouddn.com/OpenGL42IBL%E9%95%9C%E9%9D%A2%E5%8F%8D%E5%B0%84%E9%83%A8%E5%88%86_7.png" alt=""><br>到此为止的所有源码请看<a href="https://github.com/Popperelay/BlogCode/tree/master/LearnOpenGL42_IBL_Specular/LearnOpenGL42_IBL_Specular_1" target="_blank" rel="external">这里</a>。</p>
<h1 id="预过滤卷积瑕疵"><a href="#预过滤卷积瑕疵" class="headerlink" title="预过滤卷积瑕疵"></a><font size="6" color="orange">预过滤卷积瑕疵</font></h1><hr>
<p>虽然当前的预过滤器贴图在大多数情况下都能正常工作，但迟早会遇到几个与预过滤器卷积直接相关的渲染瑕疵。我们将列出这里最常见的内容，包括如何修复它们。</p>
<h2 id="高粗糙度下的cubemap接缝"><a href="#高粗糙度下的cubemap接缝" class="headerlink" title="高粗糙度下的cubemap接缝"></a><font size="5" color="red">高粗糙度下的cubemap接缝</font></h2><p>在粗糙表面上采样预过滤贴图，意味着在一些较低的mip层级上对预过滤贴图进行采样。在采样cubemap时，在默认情况下，OpenGL并不会在立方体贴图面之间进行线性插值。因为较低的mip层级都是较低的分辨率，而预过滤贴图则是由一个更大的样本叶卷积而成的，所以缺少面间滤波就变得很明显了：<br><img src="http://oqcvzqam1.bkt.clouddn.com/OpenGL42IBL%E9%95%9C%E9%9D%A2%E5%8F%8D%E5%B0%84%E9%83%A8%E5%88%86_8.png" alt=""><br>幸运的是，OpenGL为我们提供了通过启用<code>GL_TEXTURE_CUBE_MAP_SEAMLESS</code>来正确过滤立方体贴图面的选项：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token function">glEnable</span><span class="token punctuation">(</span>GL_TEXTURE_CUBE_MAP_SEAMLESS<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>只需在应用程序启动时的某个位置启用此属性，接缝就会消失。</p>
<h2 id="预过滤卷积中的亮点"><a href="#预过滤卷积中的亮点" class="headerlink" title="预过滤卷积中的亮点"></a><font size="5" color="red">预过滤卷积中的亮点</font></h2><p>由于镜面反射中的高频细节和光强度变化剧烈，镜面反射的卷积需要大量样本才能正确反映HDR环境反射的极端变化的性质。我们已经采集了大量样本，但在某些环境中，在一些较粗糙的mip级别上可能仍然不够，在这种情况下，你将开始看到明亮区域周围出现点状图案：<br><img src="http://oqcvzqam1.bkt.clouddn.com/OpenGL42IBL%E9%95%9C%E9%9D%A2%E5%8F%8D%E5%B0%84%E9%83%A8%E5%88%86_9.png" alt=""><br>一种选择是进一步增加样本数，但这不足以应付所有环境。如Chetan Jags所述，我们可以通过（在预滤波器卷积期间）不直接对环境贴图进行采样来减少次瑕疵，而是基于积分的$PDF$和粗糙度对环境贴图的mip层级进行采样：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//根据粗糙度/pdf来从环境立方体贴图的mip层级中采样</span>
<span class="token keyword">float</span> D   <span class="token operator">=</span> <span class="token function">DistributionGGX</span><span class="token punctuation">(</span>Normal<span class="token punctuation">,</span> H<span class="token punctuation">,</span> u_Roughness<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">float</span> NdotH <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token function">dot</span><span class="token punctuation">(</span>Normal<span class="token punctuation">,</span> H<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">float</span> HdotV <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token function">dot</span><span class="token punctuation">(</span>H<span class="token punctuation">,</span> V<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">float</span> pdf <span class="token operator">=</span> D <span class="token operator">*</span> NdotH <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token number">4.0</span> <span class="token operator">*</span> HdotV<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">0.0001</span><span class="token punctuation">;</span> 

<span class="token keyword">float</span> Resolution <span class="token operator">=</span> <span class="token number">512.0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//环境立方体贴图每个面的分辨率</span>
<span class="token keyword">float</span> saTexel  <span class="token operator">=</span> <span class="token number">4.0</span> <span class="token operator">*</span> PI <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token number">6.0</span> <span class="token operator">*</span> Resolution <span class="token operator">*</span> Resolution<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">float</span> saSample <span class="token operator">=</span> <span class="token number">1.0</span> <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">(</span>SAMPLE_COUNT<span class="token punctuation">)</span> <span class="token operator">*</span> pdf <span class="token operator">+</span> <span class="token number">0.0001</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">float</span> EnvMapMipLevel <span class="token operator">=</span> u_Roughness <span class="token operator">==</span> <span class="token number">0.0</span> <span class="token operator">?</span> <span class="token number">0.0</span> <span class="token operator">:</span> <span class="token number">0.5</span> <span class="token operator">*</span> <span class="token function">log2</span><span class="token punctuation">(</span>saSample <span class="token operator">/</span> saTexel<span class="token punctuation">)</span><span class="token punctuation">;</span> 

PrefilteredColor <span class="token operator">+</span><span class="token operator">=</span> <span class="token function">textureLod</span><span class="token punctuation">(</span>u_EnvironmentCubeMap<span class="token punctuation">,</span> L<span class="token punctuation">,</span> EnvMapMipLevel<span class="token punctuation">)</span><span class="token punctuation">.</span>rgb <span class="token operator">*</span> NdotL<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>因为要从环境贴图中获取mip层级，所以别忘了对它启用三线性过滤：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token function">glBindTexture</span><span class="token punctuation">(</span>GL_TEXTURE_CUBE_MAP<span class="token punctuation">,</span> EnvCubemap<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">glTexParameteri</span><span class="token punctuation">(</span>GL_TEXTURE_CUBE_MAP<span class="token punctuation">,</span> GL_TEXTURE_MIN_FILTER<span class="token punctuation">,</span> GL_LINEAR_MIPMAP_LINEAR<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>然后在渲染好环境贴图以后，让OpenGL生成mipmap：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 将球面贴图转换为cubemap</span>
<span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>
<span class="token comment" spellcheck="true">// 然后生成mipmap</span>
<span class="token function">glBindTexture</span><span class="token punctuation">(</span>GL_TEXTURE_CUBE_MAP<span class="token punctuation">,</span> EnvCubemap<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">glGenerateMipmap</span><span class="token punctuation">(</span>GL_TEXTURE_CUBE_MAP<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>显示效果非常好，并且应该在粗糙表面上的预过滤器贴图中删除了大多数亮点（即使不是全部的话也是大多数）。</p>
<h1 id="分割求和的第二部分：BRDF积分贴图"><a href="#分割求和的第二部分：BRDF积分贴图" class="headerlink" title="分割求和的第二部分：BRDF积分贴图"></a><font size="6" color="orange">分割求和的第二部分：BRDF积分贴图</font></h1><hr>
<p>在搞定第一部分之后，我们可以来关注分割求和近似的第二部分：BRDF。 让我们再次简要回顾一下蒙特卡洛下的镜面分割求和近似：<br>$$L_o(p,\omega_o) = (\frac{1}{N}\sum_{i=0}^{N-1}L_i(p,\omega_i))(\frac{1}{N}\sum_{i=0}^{N-1}\frac{FG(\omega_o\cdot h)}{(\omega_o\cdot n)(n\cdot h)})$$<br>我们已经在不同粗糙度级别的预过滤贴图中预先计算了分割求和近似的左侧部分。右侧部分要求我们对于角度$n\cdot\omega_o$、表面粗糙度和菲涅尔方程中的$F_0$来卷积BRDF方程。使用3个变量来积分BRDF有点多，但是我们可以把$F_0$移到积分外面：<br>$$<br>\begin{align}<br>BRDF&amp;=\frac{1}{N}\sum_{i=0}^{N-1}\frac{FG(\omega_o\cdot h)}{(\omega_o\cdot n)(n\cdot h)} \\<br>&amp;=\frac{1}{N}\sum_{i=0}^{N-1}\frac{(F_0+(1-F_0)(1-\omega_o\cdot h)^5)G(\omega_o\cdot h)}{(\omega_o\cdot n)(n\cdot h)} \\<br>&amp;=\frac{1}{N}\sum_{i=0}^{N-1}\frac{(F_0(1-(1-\omega_o\cdot h)^5)+(1-\omega_o\cdot h)^5)G(\omega_o\cdot h)}{(\omega_o\cdot n)(n\cdot h)} \\<br>&amp;=F_0\cdot\frac{1}{N}\sum_{i=0}^{N-1}\frac{((1-(1-\omega_o\cdot h)^5)G(\omega_o\cdot h)}{(\omega_o\cdot n)(n\cdot h)}+\frac{1}{N}\sum_{i=0}^{N-1}\frac{(1-\omega_o\cdot h)^5G(\omega_o\cdot h)}{(\omega_o\cdot n)(n\cdot h)}<br>\end{align}<br>$$<br>这个公式变换过程中，$F$就是Fresnel-Schlick菲涅尔方程，可以参考<a href="http://popperelay.cn/2018/08/14/OpenGL39-PBR%E7%90%86%E8%AE%BA/#微平面模型" target="_blank" rel="external">《OpenGL39PBR理论》</a>。$F_0$在积分上是一个常数，所以我们可以把$F_0$移到积分外面。那么我们最终得到的BRDF方程是：<br>$$<br>F_0\cdot\frac{1}{N}\sum_{i=0}^{N-1}\frac{((1-(1-\omega_o\cdot h)^5)G(\omega_o\cdot h)}{(\omega_o\cdot n)(n\cdot h)}+\frac{1}{N}\sum_{i=0}^{N-1}\frac{(1-\omega_o\cdot h)^5G(\omega_o\cdot h)}{(\omega_o\cdot n)(n\cdot h)}<br>$$<br>这两个部分分别表示对$F_0$的缩放比例和偏差。</p>
<p>我们可以借助于一张二维纹理，以纹理坐标的x、y分量作为$n$和$ω_o$之间的角度以及粗糙度，然后在着色器里卷积该BRDF方程，并将卷积结果存储在纹理中。 我们将卷积结果存储在2D查找纹理（LUT）中（将上面公式中的两部分积分（求和结果）分别存储在纹素的r和g通道），称为BRDF积分贴图。我们稍后在PBR光照着色器中使用它来获得最终的BRDF卷积间接镜面反射结果。</p>
<p>BRDF卷积着色器在2D平面上操作，使用其2D纹理坐标直接作为BRDF卷积的输入（<code>NdotV</code>和<code>roughnes</code>）。 这个代码和卷积预滤波环境贴图很类似：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">vec2 <span class="token function">IntegrateBRDF</span><span class="token punctuation">(</span><span class="token keyword">float</span> vNdotV<span class="token punctuation">,</span> <span class="token keyword">float</span> vRoughness<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    vec3 V<span class="token punctuation">;</span>
    V<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token number">1.0</span> <span class="token operator">-</span> vNdotV<span class="token operator">*</span>vNdotV<span class="token punctuation">)</span><span class="token punctuation">;</span>
    V<span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>
    V<span class="token punctuation">.</span>z <span class="token operator">=</span> vNdotV<span class="token punctuation">;</span>

    <span class="token keyword">float</span> A <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>
    <span class="token keyword">float</span> B <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span> 

    vec3 N <span class="token operator">=</span> <span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">const</span> uint SAMPLE_COUNT <span class="token operator">=</span> <span class="token number">1024u</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>uint i <span class="token operator">=</span> <span class="token number">0u</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> SAMPLE_COUNT<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        vec2 Xi <span class="token operator">=</span> <span class="token function">Hammersley</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> SAMPLE_COUNT<span class="token punctuation">)</span><span class="token punctuation">;</span>
        vec3 H <span class="token operator">=</span> <span class="token function">ImportanceSampleGGX</span><span class="token punctuation">(</span>Xi<span class="token punctuation">,</span> N<span class="token punctuation">,</span> vRoughness<span class="token punctuation">)</span><span class="token punctuation">;</span>
        vec3 L <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span><span class="token number">2.0</span> <span class="token operator">*</span> <span class="token function">dot</span><span class="token punctuation">(</span>V<span class="token punctuation">,</span> H<span class="token punctuation">)</span> <span class="token operator">*</span> H <span class="token operator">-</span> V<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">float</span> NdotL <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>L<span class="token punctuation">.</span>z<span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">float</span> NdotH <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>H<span class="token punctuation">.</span>z<span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">float</span> VdotH <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token function">dot</span><span class="token punctuation">(</span>V<span class="token punctuation">,</span> H<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">if</span><span class="token punctuation">(</span>NdotL <span class="token operator">></span> <span class="token number">0.0</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">float</span> G <span class="token operator">=</span> <span class="token function">GeometrySmith</span><span class="token punctuation">(</span>N<span class="token punctuation">,</span> V<span class="token punctuation">,</span> L<span class="token punctuation">,</span> vRoughness<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">float</span> G_Vis <span class="token operator">=</span> <span class="token punctuation">(</span>G <span class="token operator">*</span> VdotH<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span>NdotH <span class="token operator">*</span> vNdotV<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">float</span> Fc <span class="token operator">=</span> <span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">1.0</span> <span class="token operator">-</span> VdotH<span class="token punctuation">,</span> <span class="token number">5.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            A <span class="token operator">+</span><span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1.0</span> <span class="token operator">-</span> Fc<span class="token punctuation">)</span> <span class="token operator">*</span> G_Vis<span class="token punctuation">;</span>
            B <span class="token operator">+</span><span class="token operator">=</span> Fc <span class="token operator">*</span> G_Vis<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    A <span class="token operator">/</span><span class="token operator">=</span> <span class="token keyword">float</span><span class="token punctuation">(</span>SAMPLE_COUNT<span class="token punctuation">)</span><span class="token punctuation">;</span>
    B <span class="token operator">/</span><span class="token operator">=</span> <span class="token keyword">float</span><span class="token punctuation">(</span>SAMPLE_COUNT<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">vec2</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> B<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    vec2 integratedBRDF <span class="token operator">=</span> <span class="token function">IntegrateBRDF</span><span class="token punctuation">(</span>v2f_TexCoord<span class="token punctuation">.</span>x<span class="token punctuation">,</span> v2f_TexCoord<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
    Color_ <span class="token operator">=</span> integratedBRDF<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>正如你所看到的，BRDF卷积是从数学到代码的直接转换。 我们将法线和观察向量指教的角度$\cosθ$和粗糙度都作为输入，生成具有重要性采样的采样向量，并为每个样本求出相对于$F_0$的缩放比例和偏差，最后对它们求均值。</p>
<p>你可能从<a href="http://popperelay.cn/2018/08/14/OpenGL39-PBR%E7%90%86%E8%AE%BA/" target="_blank" rel="external">《OPENGL39 PBR理论》</a>中回忆起BRDF的几何项与IBL一起使用时略有不同，因为它的$k$变量具有稍微不同的解释：<br>$$k_{direct} = \frac{(\alpha + 1)^2}{8} \\<br>k_{IBL} = \frac{\alpha^2}{2}$$<br>由于BRDF卷积是镜面IBL积分的一部分，所以我们将为Schlick-GGX几何函数使用$k_{IBL}$：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">float</span> <span class="token function">GeometrySchlickGGX</span><span class="token punctuation">(</span><span class="token keyword">float</span> vNdotV<span class="token punctuation">,</span> <span class="token keyword">float</span> vRoughness<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//注意对于IBL来说，k的计算公式是不一样的</span>
    <span class="token keyword">float</span> a <span class="token operator">=</span> vRoughness<span class="token punctuation">;</span>
    <span class="token keyword">float</span> k <span class="token operator">=</span> <span class="token punctuation">(</span>a <span class="token operator">*</span> a<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2.0</span><span class="token punctuation">;</span>

    <span class="token keyword">float</span> nom   <span class="token operator">=</span> vNdotV<span class="token punctuation">;</span>
    <span class="token keyword">float</span> denom <span class="token operator">=</span> vNdotV <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">1.0</span> <span class="token operator">-</span> k<span class="token punctuation">)</span> <span class="token operator">+</span> k<span class="token punctuation">;</span>

    <span class="token keyword">return</span> nom <span class="token operator">/</span> denom<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">float</span> <span class="token function">GeometrySmith</span><span class="token punctuation">(</span>vec3 vN<span class="token punctuation">,</span> vec3 vV<span class="token punctuation">,</span> vec3 vL<span class="token punctuation">,</span> <span class="token keyword">float</span> vRoughness<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">float</span> NdotV <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token function">dot</span><span class="token punctuation">(</span>vN<span class="token punctuation">,</span> vV<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">float</span> NdotL <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token function">dot</span><span class="token punctuation">(</span>vN<span class="token punctuation">,</span> vL<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">float</span> ggx2 <span class="token operator">=</span> <span class="token function">GeometrySchlickGGX</span><span class="token punctuation">(</span>NdotV<span class="token punctuation">,</span> vRoughness<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">float</span> ggx1 <span class="token operator">=</span> <span class="token function">GeometrySchlickGGX</span><span class="token punctuation">(</span>NdotL<span class="token punctuation">,</span> vRoughness<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> ggx1 <span class="token operator">*</span> ggx2<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>请注意，虽然$k$取<code>a</code>作为其参数，但我们没有将<code>roughness</code>平方后赋给<code>a</code>（我们前面的代码<code>DistributionGGX</code>函数里是这么做的）。我不确定这是否与Epic Games的部分或原始的迪士尼论文不一致，但是直接将<code>roughness</code>转换为<code>a</code>会给出与Epic Games版本完全相同的BRDF积分贴图。</p>
<p>最后，为了存储BRDF卷积结果，我们生成一张512x512分辨率的2D纹理：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//生成BDRF积分贴图</span>
GLuint BRDFMap <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token function">glGenTextures</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>BRDFMap<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">glBindTexture</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> BRDFMap<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">glTexImage2D</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> GL_RG16F<span class="token punctuation">,</span> <span class="token number">512</span><span class="token punctuation">,</span> <span class="token number">512</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> GL_RG<span class="token punctuation">,</span> GL_FLOAT<span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">glTexParameteri</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> GL_TEXTURE_WRAP_S<span class="token punctuation">,</span> GL_CLAMP_TO_EDGE<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">glTexParameteri</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> GL_TEXTURE_WRAP_T<span class="token punctuation">,</span> GL_CLAMP_TO_EDGE<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">glTexParameteri</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> GL_TEXTURE_MIN_FILTER<span class="token punctuation">,</span> GL_LINEAR<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">glTexParameteri</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> GL_TEXTURE_MAG_FILTER<span class="token punctuation">,</span> GL_LINEAR<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">glBindTexture</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注意我们使用Epic Games建议的16位精度的浮点格式。要将环绕格式设置为<code>GL_CLAMP_TO_EDGE</code>，避免边缘采样走样。</p>
<p>然后，我们再次使用相同的帧缓存，在NDC屏幕四边形上运行着色器：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//重复利用把球面贴图转换成cubemap的FBO，只需要换一下绑定的纹理附件即可</span>
<span class="token function">glBindFramebuffer</span><span class="token punctuation">(</span>GL_FRAMEBUFFER<span class="token punctuation">,</span> SphereMap2CubeMapFBO<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">glFramebufferTexture2D</span><span class="token punctuation">(</span>GL_FRAMEBUFFER<span class="token punctuation">,</span> GL_COLOR_ATTACHMENT0<span class="token punctuation">,</span> GL_TEXTURE_2D<span class="token punctuation">,</span> BRDFMap<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">glViewport</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">512</span><span class="token punctuation">,</span> <span class="token number">512</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">glClear</span><span class="token punctuation">(</span>GL_COLOR_BUFFER_BIT <span class="token operator">|</span> GL_DEPTH_BUFFER_BIT<span class="token punctuation">)</span><span class="token punctuation">;</span>
BRDFMap_Shader<span class="token punctuation">.</span><span class="token function">Use</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">glBindTexture</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> BRDFMap<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">renderQuad</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">glViewport</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> WIDTH<span class="token punctuation">,</span> HEIGHT<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">glBindTexture</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">glBindFramebuffer</span><span class="token punctuation">(</span>GL_FRAMEBUFFER<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>分割求和积分的卷积BRDF得到的积分贴图应该像下面这样（卷积BRDF积分贴图的所有源码请看<a href="https://github.com/Popperelay/BlogCode/tree/master/LearnOpenGL42_IBL_Specular/LearnOpenGL42_IBL_Specular_2" target="_blank" rel="external">这里</a>）：<br><img src="http://oqcvzqam1.bkt.clouddn.com/OpenGL42IBL%E9%95%9C%E9%9D%A2%E5%8F%8D%E5%B0%84%E9%83%A8%E5%88%86_10.png" alt=""></p>
<p>在PBR着色器里使用此BRDF积分贴图和预过滤的环境贴图，我们可以将两者结合起来获得镜面反射积分的结果：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">vec3 R <span class="token operator">=</span> <span class="token function">reflect</span><span class="token punctuation">(</span><span class="token operator">-</span>V<span class="token punctuation">,</span> N<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token keyword">const</span> <span class="token keyword">float</span> MAX_REFLECTION_LOD <span class="token operator">=</span> <span class="token number">4.0</span><span class="token punctuation">;</span>
vec3 PrefilteredColor <span class="token operator">=</span> <span class="token function">textureLod</span><span class="token punctuation">(</span>u_PrefilterEnvMap<span class="token punctuation">,</span> R<span class="token punctuation">,</span>  u_Roughness <span class="token operator">*</span> MAX_REFLECTION_LOD<span class="token punctuation">)</span><span class="token punctuation">.</span>rgb<span class="token punctuation">;</span>    
vec2 BRDFColor <span class="token operator">=</span> <span class="token function">texture</span><span class="token punctuation">(</span>u_BRDFMap<span class="token punctuation">,</span> <span class="token function">vec2</span><span class="token punctuation">(</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token function">dot</span><span class="token punctuation">(</span>N<span class="token punctuation">,</span> V<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> u_Roughness<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>rg<span class="token punctuation">;</span>
vec3 SpecularPart <span class="token operator">=</span> PrefilteredColor <span class="token operator">*</span> <span class="token punctuation">(</span>F <span class="token operator">*</span> BRDFColor<span class="token punctuation">.</span>x <span class="token operator">+</span> BRDFColor<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="完成IBL反射"><a href="#完成IBL反射" class="headerlink" title="完成IBL反射"></a><font size="6" color="orange">完成IBL反射</font></h1><hr>
<p>为了使反射率方程的间接镜面反射部分运行起来，我们需要将分割求和近似的两个部分缝合在一起。让我们首先将预先计算的光照数据添加到PBR着色器的顶部：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">uniform samplerCube u_PrefilterEnvMap<span class="token punctuation">;</span>
uniform sampler2D u_BRDFMap<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>首先，我们通过使用反射向量对预过滤的环境地图进行采样来获得表面的间接镜面反射。 请注意，我们根据表面粗糙度对适当的mip层级进行采样，从而使较粗糙的表面得到更模糊的镜面反射。</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>
    vec3 R <span class="token operator">=</span> <span class="token function">reflect</span><span class="token punctuation">(</span><span class="token operator">-</span>V<span class="token punctuation">,</span> N<span class="token punctuation">)</span><span class="token punctuation">;</span>   

    <span class="token keyword">const</span> <span class="token keyword">float</span> MAX_REFLECTION_LOD <span class="token operator">=</span> <span class="token number">4.0</span><span class="token punctuation">;</span>
    vec3 PrefilteredColor <span class="token operator">=</span> <span class="token function">textureLod</span><span class="token punctuation">(</span>u_PrefilterEnvMap<span class="token punctuation">,</span> R<span class="token punctuation">,</span>  u_Roughness <span class="token operator">*</span> MAX_REFLECTION_LOD<span class="token punctuation">)</span><span class="token punctuation">.</span>rgb<span class="token punctuation">;</span>   
    <span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在预过滤步骤中，我们只将环境贴图最多卷积到最多5个mip级别（0到4），我们在此将其表示为<code>MAX_REFLECTION_LOD</code>，以确保我们不会在没有（相关）数据的情况下对某个mip层级进行采样。</p>
<p>然后给出材料的粗糙度以及法线和视图矢量之间的角度以后，我们去BRDF查找纹理中进行采样：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">vec3 F <span class="token operator">=</span> <span class="token function">FresnelSchlickRoughness</span><span class="token punctuation">(</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token function">dot</span><span class="token punctuation">(</span>N<span class="token punctuation">,</span> V<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> F0<span class="token punctuation">,</span> u_Roughness<span class="token punctuation">)</span><span class="token punctuation">;</span>
vec2 BRDFColor <span class="token operator">=</span> <span class="token function">texture</span><span class="token punctuation">(</span>u_BRDFMap<span class="token punctuation">,</span> <span class="token function">vec2</span><span class="token punctuation">(</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token function">dot</span><span class="token punctuation">(</span>N<span class="token punctuation">,</span> V<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> u_Roughness<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>rg<span class="token punctuation">;</span>
vec3 SpecularPart <span class="token operator">=</span> PrefilteredColor <span class="token operator">*</span> <span class="token punctuation">(</span>F <span class="token operator">*</span> BRDFColor<span class="token punctuation">.</span>x <span class="token operator">+</span> BRDFColor<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>给定来自BRDF查找纹理的相对于$F_0$（这里我们直接使用间接菲涅耳结果<code>F</code>）的缩放比例和偏差，我们把它与IBL反射率方程左边的预滤波部分组合起来，并重新构建近似积分结果<code>specular</code>。</p>
<p>这给了我们反射率方程的间接镜面反射部分。现在，将它与上一篇文章中反射率方程的漫反射部分结合起来，得到完整的PBR IBL结果：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">vec3 F <span class="token operator">=</span> <span class="token function">FresnelSchlickRoughness</span><span class="token punctuation">(</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token function">dot</span><span class="token punctuation">(</span>N<span class="token punctuation">,</span> V<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> F0<span class="token punctuation">,</span> u_Roughness<span class="token punctuation">)</span><span class="token punctuation">;</span>
vec3 Ks <span class="token operator">=</span> F<span class="token punctuation">;</span>
vec3 Kd <span class="token operator">=</span> <span class="token number">1.0</span> <span class="token operator">-</span> Ks<span class="token punctuation">;</span>
Kd <span class="token operator">*</span><span class="token operator">=</span> <span class="token number">1.0</span> <span class="token operator">-</span> u_Metalness<span class="token punctuation">;</span>
vec3 Irradiance <span class="token operator">=</span> <span class="token function">texture</span><span class="token punctuation">(</span>u_IrradianceMap<span class="token punctuation">,</span> N<span class="token punctuation">)</span><span class="token punctuation">.</span>rgb<span class="token punctuation">;</span>
vec3 DiffusePart <span class="token operator">=</span> Irradiance <span class="token operator">*</span> u_ObjectColor <span class="token operator">*</span> u_AO<span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token keyword">float</span> MAX_REFLECTION_LOD <span class="token operator">=</span> <span class="token number">4.0</span><span class="token punctuation">;</span>
vec3 PrefilteredColor <span class="token operator">=</span> <span class="token function">textureLod</span><span class="token punctuation">(</span>u_PrefilterEnvMap<span class="token punctuation">,</span> R<span class="token punctuation">,</span>  u_Roughness <span class="token operator">*</span> MAX_REFLECTION_LOD<span class="token punctuation">)</span><span class="token punctuation">.</span>rgb<span class="token punctuation">;</span>    
vec2 BRDFColor <span class="token operator">=</span> <span class="token function">texture</span><span class="token punctuation">(</span>u_BRDFMap<span class="token punctuation">,</span> <span class="token function">vec2</span><span class="token punctuation">(</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token function">dot</span><span class="token punctuation">(</span>N<span class="token punctuation">,</span> V<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> u_Roughness<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>rg<span class="token punctuation">;</span>
vec3 SpecularPart <span class="token operator">=</span> PrefilteredColor <span class="token operator">*</span> <span class="token punctuation">(</span>F <span class="token operator">*</span> BRDFColor<span class="token punctuation">.</span>x <span class="token operator">+</span> BRDFColor<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>

vec3 Ambient <span class="token operator">=</span> Kd <span class="token operator">*</span> DiffusePart <span class="token operator">+</span> SpecularPart<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>请注意，我们不会将<code>SpecularPart</code>乘以<code>Ks</code>，因为我们已经做了菲涅耳乘法。</p>
<p>现在，在粗糙度和金属属性不同的球体系列上运行这个精确的代码，我们终于可以在最终的PBR渲染器中看到它们的真实颜色（到此的所有源码请看<a href="https://github.com/Popperelay/BlogCode/tree/master/LearnOpenGL42_IBL_Specular/LearnOpenGL42_IBL_Specular_3" target="_blank" rel="external">这里</a>）：<br><img src="http://oqcvzqam1.bkt.clouddn.com/OpenGL42IBL%E9%95%9C%E9%9D%A2%E5%8F%8D%E5%B0%84%E9%83%A8%E5%88%86_11.png" alt=""><br>我们甚再疯狂点，使用一些很酷的纹理PBR材质：<br><img src="http://oqcvzqam1.bkt.clouddn.com/OpenGL42IBL%E9%95%9C%E9%9D%A2%E5%8F%8D%E5%B0%84%E9%83%A8%E5%88%86_12.png" alt=""><br>或者直接加载Andrew Maximov提供的很棒的免费<a href="http://artisaverb.info/PBT.html" target="_blank" rel="external">PBR3D模型</a>：<br><img src="http://oqcvzqam1.bkt.clouddn.com/OpenGL42IBL%E9%95%9C%E9%9D%A2%E5%8F%8D%E5%B0%84%E9%83%A8%E5%88%86_13.png" alt=""><br>我相信我们都同意我们的照明现在看起来更有说服力。 更好的是，无论我们使用哪种环境贴图，我们的照明看起来都是物理上正确的。 下面你会看到几个不同的预先计算的HDR地图，完全改变了照明动态，但在不改变单个照明变量的情况下仍然看起来物理正确！<br><img src="http://oqcvzqam1.bkt.clouddn.com/OpenGL42IBL%E9%95%9C%E9%9D%A2%E5%8F%8D%E5%B0%84%E9%83%A8%E5%88%86_14.png" alt=""></p>
<h1 id="下一步？"><a href="#下一步？" class="headerlink" title="下一步？"></a><font size="6" color="orange">下一步？</font></h1><hr>
<p>希望在本文结束时，您应该非常清楚地了解PBR的含义，甚至可以启动并运行实际的PBR渲染器。 在我们这些PBR文章中，我们在渲染循环之前，在应用程序开始时预先计算了所有相关的PBR基于图像的关照数据。这对于教育目的来说很好，但对于PBR的任何实际使用来说都不是很好。首先，预计算只需要进行一次，而不是每次启动。第二，当你使用多个环境贴图的那一刻，你必须在每次启动时预先计算每一个环境贴图，这往往会积累起来。</p>
<p>出于这个原因，你通常只需做一次：将环境贴图预先计算为辐照度贴图和预过滤贴图，然后将其存储在磁盘上（请注意，BRDF积分贴图不依赖于环境贴图，因此你只需要计算或加载一次）。这意味着你需要提供自定义图像格式来存储HDR立方体贴图，包括其mip级别。或者，你将其存储（并加载）为可用格式之一（例如支持存储mip级别的.dds）。</p>
<p>此外，我们已经在这些文章中描述了整个过程，包括生成预先计算的IBL图像，以帮助我们进一步理解PBR管道。 但是，通过使用<a href="https://github.com/dariomanesku/cmftStudio" target="_blank" rel="external">cmftStudio</a>或<a href="https://github.com/derkreature/IBLBaker" target="_blank" rel="external">IBLBaker</a>等几个很棒的工具为你生成这些预先计算的贴图，你将会得到同样精细的结果。</p>
<p>我们跳过的一点是将预先计算的立方体贴图作为反射探针：立方体贴图插值和视差校正。 这是在场景中放置几个反射探针的过程，该探针在某个特定位置拍摄场景的立方体贴图快照，然后我们可以将其作为场景的该部分的IBL数据进行卷积。通过基于相机附近的几个探头之间进行插值，我们可以实现局部高细节基于图像的光照，这仅仅受到我们愿意放置的反射探头数量的限制。 这样，例如，当从场景的明亮室外部分移动到较暗的室内部分时，基于图像的光照可以正确地更新。我将在未来的某个地方写一篇关于反射探针的教程，但是现在我推荐下面的Chetan Jags的文章给你一个良好的开端。</p>
<h1 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a><font size="6" color="orange">延伸阅读</font></h1><hr>
<ul>
<li><a href="http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf" target="_blank" rel="external">Real Shading in Unreal Engine 4</a>：这篇文章说明了Epic Games的分割求和近似方法。我们的IBL PBR代码也是出自这篇文章。</li>
<li><a href="http://www.trentreed.net/blog/physically-based-shading-and-image-based-lighting/" target="_blank" rel="external">Physically Based Shading and Image Based Lighting</a>：Trent Reed写的关于将镜面IBL实时集成到PBR管道中的很棒的博客。</li>
<li><a href="https://chetanjags.wordpress.com/2015/08/26/image-based-lighting/" target="_blank" rel="external">Image Based Lighting</a>：Chetan Jags对基于镜面的基于图像的光照及其一些注意事项的大量叙述，包括光探针插值。</li>
<li><a href="https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf" target="_blank" rel="external">Moving Frostbite to PBR</a>：关于将PBR集成到SébastienLagarde和Charles de Rousiers的AAA游戏引擎的写得很好的深入概述。</li>
<li><a href="https://jmonkeyengine.github.io/wiki/jme3/advanced/pbr_part3.html" target="_blank" rel="external">Physically Based Rendering – Part Three</a>：JMonkeyEngine团队对IBL光照和PBR的高级概述。</li>
<li><a href="https://placeholderart.wordpress.com/2015/07/28/implementation-notes-runtime-environment-map-filtering-for-image-based-lighting/" target="_blank" rel="external">Implementation Notes: Runtime Environment Map Filtering for Image Based Lighting</a>：Padraic Hennessy对预先滤HDR环境贴图和显著优化采样过程的大量叙述。<br>&nbsp; </li>
</ul>
<hr>
<p>参考文献：<a href="https://learnopengl.com/" target="_blank" rel="external">LearnOpenGL</a></p>

            </div>

            <!-- Post Comments -->
            
    <!-- 使用 DISQUS_CLICK -->
<div id="disqus-comment">
    <div id="disqus_thread"></div>

<!-- add animation -->
<style>
	.disqus_click_btn {
            line-height: 30px;
            margin: 0;
            min-width: 50px;
            padding: 0 14px;
            display: inline-block;
            font-family: "Roboto", "Helvetica", "Arial", sans-serif;
            font-size: 14px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0;
            overflow: hidden;
            will-change: box-shadow;
            transition: box-shadow .2s cubic-bezier(.4, 0, 1, 1), background-color .2s cubic-bezier(.4, 0, .2, 1), color .2s cubic-bezier(.4, 0, .2, 1);
            outline: 0;
            cursor: pointer;
            text-decoration: none;
            text-align: center;
            vertical-align: middle;
            border: 0;
            background: rgba(158, 158, 158, .2);
            box-shadow: 0 2px 2px 0 rgba(0, 0, 0, .14), 0 3px 1px -2px rgba(0, 0, 0, .2), 0 1px 5px 0 rgba(0, 0, 0, .12);
            color: #fff;
            background-color: #7EC0EE;
            text-shadow: 0
        }
</style>
	
<div class="btn_click_load" id="disqus_bt"> 
    <button class="disqus_click_btn">点击查看评论</button>
</div>

<!--
<script type="text/javascript">
$('.btn_click_load').click(function() {
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'http-miccall-tech'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    document.getElementById('disqus_bt').style.display = "none";
});
</script>
-->
<script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://yoursite.com/2018/08/26/OpenGL42-IBL镜面反射部分/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = 'http://yoursite.com/2018/08/26/OpenGL42-IBL镜面反射部分/'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
</script>

<script type="text/javascript">
    $('.btn_click_load').click(function() {  //click to load comments
        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document;
            var s = d.createElement('script');
            s.src = '//http-miccall-tech.disqus.com/embed.js';
            s.setAttribute('data-timestamp', + new Date());
            (d.head || d.body).appendChild(s);
        })();
        $('.btn_click_load').css('display','none');
    });
</script>
</div>
<style>
    #disqus-comment{
        background-color: #eee;
        padding: 2pc;
    }
</style>


        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
                <li>Design: <a href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
            </ul>
            
            	<span id="busuanzi_container_site_pv">2018总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			
        </div>
    </div>
</body>



 	
</html>
