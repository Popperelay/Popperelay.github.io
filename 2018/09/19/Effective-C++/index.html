<!DOCTYPE HTML>
<html>

<head><meta name="generator" content="Hexo 3.9.0">
	<link rel="bookmark" type="image/x-icon" href="/img/logo_miccall.png">
	 <link rel="shortcut icon" href="/img/logo_miccall.png">
	
			
    <title>
    Elays'Blog
    </title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <link rel="stylesheet" href="/css/mic_main.css">
    <link rel="stylesheet" href="/css/dropdownMenu.css">
    
    	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css">
    </noscript>
			    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<link rel="stylesheet" href="/css/prism-dark.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>
    
		
<!-- Layouts -->


<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<!--<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">-->
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/latest.js?config=TeX-MML-AM_CHTML">
</script>

	<script>
    (function(){
        if('{{ page.password }}'){
            if (prompt('请输入文章密码') !== '{{ page.password }}'){
                alert('密码错误');
                history.back();
            }
        }
    })();
	</script>

<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_undefined.css">
<link rel="stylesheet" href="/css/typo.css">
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">MICCALL</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special">
            <ul class="menu links">
			<!-- Homepage  主页  --> 
			<li>
	            <a href="/" rel="nofollow">主页</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">分类</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="/categories/C/">C#</a></li><li><a class="category-link" href="/categories/C-语法/">C#语法</a></li><li><a class="category-link" href="/categories/C/">C++</a></li><li><a class="category-link" href="/categories/C语言/">C语言</a></li><li><a class="category-link" href="/categories/Graphics/">Graphics</a></li><li><a class="category-link" href="/categories/Math/">Math</a></li><li><a class="category-link" href="/categories/OpenGL/">OpenGL</a></li><li><a class="category-link" href="/categories/Unity/">Unity</a></li><li><a class="category-link" href="/categories/博客配置/">博客配置</a></li><li><a class="category-link" href="/categories/并行计算/">并行计算</a></li><li><a class="category-link" href="/categories/操作系统/">操作系统</a></li><li><a class="category-link" href="/categories/数据结构/">数据结构</a></li><li><a class="category-link" href="/categories/毕设/">毕设</a></li><li><a class="category-link" href="/categories/游戏开发/">游戏开发</a></li><li><a class="category-link" href="/categories/计算机系统/">计算机系统</a></li><li><a class="category-link" href="/categories/设计模式/">设计模式</a></li><li><a class="category-link" href="/categories/面试/">面试</a>
	                    </li></ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/gallery/" title="图库">
		                图库
		            </a>
		        </li>
		        
		        <li>
		            <a href="/tag/" title="搜索">
		                搜索
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
		            
		                <li><a href="https://github.com/miccall" class="icon fa-github"><span class="label">GitHub</span></a></li>
		            
		            
		            
		            
			</ul>
</nav>

        <div id="main">
            <div class="post_page_title_img" style="height: 25rem;background-image: url(https://github.com/Popperelay/Photos/blob/master/Photos/Effective%20C++_BG.jpg?raw=true);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;">
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2>Effective C++</h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
				<!-- 目录 -->
				<p class="show-toc-btn" id="show-toc-btn" onclick="showToc();" style="display:none">
				<span class="btn-bg"></span>
				<span class="btn-text">文章导航</span>
				</p>
				<div id="toc-article" class="toc-article">
					<span id="toc-close" class="toc-close" title="隐藏导航" onclick="showBtn();">×</span>
					<strong class="toc-title">文章目录</strong>
					<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1：视C-为一个语言联邦"><span class="toc-text">1：视C++为一个语言联邦</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2：尽量以const-enum-inline替换-define"><span class="toc-text">2：尽量以const,enum,inline替换#define</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3：尽可能使用const"><span class="toc-text">3：尽可能使用const</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4：确定对象被使用前已先被初始化"><span class="toc-text">4：确定对象被使用前已先被初始化</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5：了解C-默默编写并调用哪些函数"><span class="toc-text">5：了解C++默默编写并调用哪些函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6：若不想使用编译器自动生成的函数，就该明确拒绝"><span class="toc-text">6：若不想使用编译器自动生成的函数，就该明确拒绝</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7：为多态基类声明virtual析构函数"><span class="toc-text">7：为多态基类声明virtual析构函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8：别让异常逃离析构函数"><span class="toc-text">8：别让异常逃离析构函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9：绝不在构造和析构过程中调用virtual函数"><span class="toc-text">9：绝不在构造和析构过程中调用virtual函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10：令operator-返回一个自身对象的引用"><span class="toc-text">10：令operator=返回一个自身对象的引用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11：在operator-中处理“自我赋值”"><span class="toc-text">11：在operator=中处理“自我赋值”</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12：复制对象时勿忘其每一个成分"><span class="toc-text">12：复制对象时勿忘其每一个成分</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#13：以对象管理资源"><span class="toc-text">13：以对象管理资源</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#14：在资源管理类中小心copying行为"><span class="toc-text">14：在资源管理类中小心copying行为</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#15：在资源管理类中提供对原始资源的访问"><span class="toc-text">15：在资源管理类中提供对原始资源的访问</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#16：成对使用new和delete时要采取相同形式"><span class="toc-text">16：成对使用new和delete时要采取相同形式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#17：以独立语句将new出来的对象置入智能指针"><span class="toc-text">17：以独立语句将new出来的对象置入智能指针</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#18：让接口容易被正确使用，不易被误用"><span class="toc-text">18：让接口容易被正确使用，不易被误用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#19：设计class犹如设计type"><span class="toc-text">19：设计class犹如设计type</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#20：用引用传递代替值传递"><span class="toc-text">20：用引用传递代替值传递</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#21：必须返回对象时，别妄想返回其引用"><span class="toc-text">21：必须返回对象时，别妄想返回其引用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#22：将成员变量声明为private"><span class="toc-text">22：将成员变量声明为private</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#23：用非成员函数和非友元函数来代替成员函数"><span class="toc-text">23：用非成员函数和非友元函数来代替成员函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#24：若所有参数皆需类型转换，请为此采用非成员函数"><span class="toc-text">24：若所有参数皆需类型转换，请为此采用非成员函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#25：考虑写出一个不抛出异常的swap函数"><span class="toc-text">25：考虑写出一个不抛出异常的swap函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#26：尽可能延后变量定义式的出现时间"><span class="toc-text">26：尽可能延后变量定义式的出现时间</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#27：尽量少做转型动作"><span class="toc-text">27：尽量少做转型动作</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#28：避免返回指向对象内部成分的非const指针"><span class="toc-text">28：避免返回指向对象内部成分的非const指针</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#29：为“异常安全”而努力是值得的"><span class="toc-text">29：为“异常安全”而努力是值得的</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#30：透彻了解内联的里里外外"><span class="toc-text">30：透彻了解内联的里里外外</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#31：将文件间的编译依存关系降至最低"><span class="toc-text">31：将文件间的编译依存关系降至最低</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#32：确定你的public继承塑模出is-a关系"><span class="toc-text">32：确定你的public继承塑模出is-a关系</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#33：避免遮掩继承而来的名称"><span class="toc-text">33：避免遮掩继承而来的名称</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#34：区分接口继承和实现继承"><span class="toc-text">34：区分接口继承和实现继承</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#35：考虑虚函数以外的其他选择"><span class="toc-text">35：考虑虚函数以外的其他选择</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#36：绝不重新定义继承而来的非虚函数"><span class="toc-text">36：绝不重新定义继承而来的非虚函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#37：绝不重新定义继承而来的缺省参数值"><span class="toc-text">37：绝不重新定义继承而来的缺省参数值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#38：通过复合塑模出has-a"><span class="toc-text">38：通过复合塑模出has-a</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#39：明智而审慎地使用private继承"><span class="toc-text">39：明智而审慎地使用private继承</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#40：明智而审慎地使用多重继承"><span class="toc-text">40：明智而审慎地使用多重继承</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#41：了解隐式接口和编译期多态"><span class="toc-text">41：了解隐式接口和编译期多态</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#42：了解typename的双重意义"><span class="toc-text">42：了解typename的双重意义</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#43：学习处理模板化基类内的名称"><span class="toc-text">43：学习处理模板化基类内的名称</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#44：将与参数无关的代码抽离模板"><span class="toc-text">44：将与参数无关的代码抽离模板</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#45：运用成员函数模板接受所有兼容类型"><span class="toc-text">45：运用成员函数模板接受所有兼容类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#46：需要类型转换时请为模板定义非成员函数"><span class="toc-text">46：需要类型转换时请为模板定义非成员函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#47：请使用traits类表现类型信息"><span class="toc-text">47：请使用traits类表现类型信息</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#48：认识模板元编程"><span class="toc-text">48：认识模板元编程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#49：了解new-handler的行为"><span class="toc-text">49：了解new-handler的行为</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#50：了解new和delete的合理替换时机"><span class="toc-text">50：了解new和delete的合理替换时机</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#51：编写new和delete时需固守常规"><span class="toc-text">51：编写new和delete时需固守常规</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#52：写了placement-new也要写placement-delete-font-gt"><span class="toc-text">52：写了placement new也要写placement delete/font&gt;</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#53：不要轻易忽视编译器的警告"><span class="toc-text">53：不要轻易忽视编译器的警告</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#54：让自己熟悉包括TR1在内的标准程序库"><span class="toc-text">54：让自己熟悉包括TR1在内的标准程序库</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#55：让自己熟悉Boost"><span class="toc-text">55：让自己熟悉Boost</span></a></li></ol>
			   </div>
			   <script type="text/javascript">
				function showToc(){
					var toc_article = document.getElementById("toc-article");
					var show_toc_btn = document.getElementById("show-toc-btn");
					toc_article.setAttribute("style","display:block");
					show_toc_btn.setAttribute("style","display:none");
					};
				function showBtn(){
					var toc_article = document.getElementById("toc-article");
					var show_toc_btn = document.getElementById("show-toc-btn");
					toc_article.setAttribute("style","display:none");
					show_toc_btn.setAttribute("style","display:block");
					};
			   </script>
				
                <h1 id="1：视C-为一个语言联邦"><a href="#1：视C-为一个语言联邦" class="headerlink" title="1：视C++为一个语言联邦"></a><font size="6" color="orange">1：视C++为一个语言联邦</font></h1><hr>
<h1 id="2：尽量以const-enum-inline替换-define"><a href="#2：尽量以const-enum-inline替换-define" class="headerlink" title="2：尽量以const,enum,inline替换#define"></a><font size="6" color="orange">2：尽量以const,enum,inline替换#define</font></h1><hr>
<ol>
<li><p>#define并不重视作用域，一旦宏被定义，在其后的编译过程中都一直有效（除非在某处被#undef），也就意味着#define不能够提供任何封装性（因为它不受类的作用域或者函数的作用域约束）。</p>
</li>
<li><p>在类里面，如果要用一个变量来定义数组的大小，使用普通变量和常量都是行不通的：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">class</span> <span class="token class-name">CData</span>
 <span class="token punctuation">{</span>
 <span class="token keyword">private</span><span class="token operator">:</span>
     <span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
     <span class="token keyword">int</span> m_Data<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//编译错误</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 我们可以用#define来实现这个功能：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">class</span> <span class="token class-name">CData</span>
 <span class="token punctuation">{</span>
 <span class="token keyword">private</span><span class="token operator">:</span>
     <span class="token macro property">#<span class="token directive keyword">define</span> N 10</span>
     <span class="token keyword">int</span> m_Data<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 不过我们尽量还是不要用#define，可以使用一个枚举值来代替（这被称为enum hack）：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">class</span> <span class="token class-name">CData</span>
 <span class="token punctuation">{</span>
 <span class="token keyword">private</span><span class="token operator">:</span>
     <span class="token keyword">enum</span> <span class="token punctuation">{</span> N <span class="token operator">=</span> <span class="token number">10</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
     <span class="token keyword">int</span> m_Data<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>用#define来定义的函数有很多缺点，可能造成一些麻烦。比如下面这个宏定义的函数（为宏中的所有实参加上小括号是个好的习惯）：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token macro property">#<span class="token directive keyword">define</span> MAX(a, b) (a) > (b) ? (a) : (b)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p> 但是当我们执行下面的语句时：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
 <span class="token function">MAX</span><span class="token punctuation">(</span><span class="token operator">++</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//a被累加两次</span>
 <span class="token function">MAX</span><span class="token punctuation">(</span><span class="token operator">++</span>a<span class="token punctuation">,</span> b <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//a被累加一次</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p> a的递增次数居然和它被比较的结果有关，这显然和函数的初衷违背（我们应该只是想a累加一次）。为了解决这个问题并保持宏定义函数的调用开销小的优点，我们可以用内联函数来代替它：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
 <span class="token keyword">inline</span> T <span class="token function">max</span><span class="token punctuation">(</span><span class="token keyword">const</span> T <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token keyword">const</span> T <span class="token operator">&amp;</span>b<span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
     <span class="token keyword">return</span> a <span class="token operator">></span> b <span class="token operator">?</span> a <span class="token operator">:</span> b<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>所以，请记住，对于单纯的常量，最好应const或者enum来替换#define，最好inline函数来替换宏定义函数。</li>
</ol>
<h1 id="3：尽可能使用const"><a href="#3：尽可能使用const" class="headerlink" title="3：尽可能使用const"></a><font size="6" color="orange">3：尽可能使用const</font></h1><hr>
<ol>
<li><p>对于用关键字const修饰的指针：如果const出现在星号左边，表示被指物是常量；如果const出现在星号右边，表示指针自身是常量；如果星号两边都有const，表示被指物和指针两者都是常量。</p>
</li>
<li><p>对于一个迭代器<code>iterator iter</code>，<code>const iter</code>表示迭代器所指向的物体是常量，而<code>const_iterator iter</code>才表示迭代器<code>iter</code>本身是个常量。</p>
</li>
<li><p>我们知道const成员函数和非const成员函数两者可以是重载关系的，如果两个函数内部的代码是相同的，为了简化代码，我们可以用非const成员函数去调const成员函数：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">class</span> <span class="token class-name">CData</span>
 <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
     <span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> <span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
     <span class="token punctuation">{</span>
         <span class="token keyword">return</span> m_Data<span class="token punctuation">;</span>
     <span class="token punctuation">}</span>

     <span class="token keyword">int</span><span class="token operator">&amp;</span> <span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
     <span class="token punctuation">{</span>
         <span class="token keyword">return</span> <span class="token keyword">const_cast</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&amp;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">const</span> CData<span class="token operator">&amp;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//因为要返回int&amp;，所以转换时要用const CData&amp;，而不是const CData，否则转换出来的只是副本，返回值的&amp;将无效（即在外面对返回值赋值时内部的m_Data并不会发生改变）</span>
     <span class="token punctuation">}</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
     <span class="token keyword">int</span> m_Data <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 但是我们不能用const成员函数去调用非const成员函数，因为非const成员函数内部可能会改变类成员，这样就会和调用它的const成员函数违背（这也是const成员函数不能调用非const成员函数的原因，编译就会报错的）。</p>
</li>
<li><p>当const和非const成员函数有着实质等价的实现时，令非const版本调用const版本可以避免代码重复。</p>
</li>
</ol>
<h1 id="4：确定对象被使用前已先被初始化"><a href="#4：确定对象被使用前已先被初始化" class="headerlink" title="4：确定对象被使用前已先被初始化"></a><font size="6" color="orange">4：确定对象被使用前已先被初始化</font></h1><hr>
<ol>
<li><p>在构造函数中使用初始化列表，比在构造函数里使用赋值语句效率要高（而且赋值语句本身并不属于构造范畴，即使它是处于构造函数内，其余版本的构造函数在调用之前会先去调用默认构造函数，然后才执行构造函数内的赋值语句）。</p>
</li>
<li><p>对于多个全局静态对象，编译器无法确定它们之间的初始化顺序，但是有时候我们想要先初始化全局对象a，再初始化全局对象b：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">class</span> <span class="token class-name">CData</span>
 <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
     <span class="token keyword">int</span> <span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> m_Data<span class="token punctuation">;</span> <span class="token punctuation">}</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
     <span class="token keyword">int</span> m_Data <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>

 CData DataObj<span class="token punctuation">;</span>

 <span class="token keyword">class</span> <span class="token class-name">CUser</span>
 <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
     <span class="token function">CUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
     <span class="token punctuation">{</span>
         m_NeededData <span class="token operator">=</span> DataObj<span class="token punctuation">.</span><span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
     <span class="token keyword">int</span> m_NeededData <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>

 CUser UserObj<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 编译器无法保证在初始化全局对象<code>UserObj</code>之前，先初始化全局对象<code>DataObj</code>。<br> 为了保证这种初始化顺序，我们可以把全局对象写入函数里，变成局部静态对象：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">class</span> <span class="token class-name">CData</span>
 <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
     <span class="token keyword">int</span> <span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> m_Data<span class="token punctuation">;</span> <span class="token punctuation">}</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
     <span class="token keyword">int</span> m_Data <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>

 CData<span class="token operator">&amp;</span> <span class="token function">initData</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">//将全局对象DataObj变成局部静态对象</span>
 <span class="token punctuation">{</span>
     <span class="token keyword">static</span> CData DataObj<span class="token punctuation">;</span>
     <span class="token keyword">return</span> DataObj<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>

 <span class="token keyword">class</span> <span class="token class-name">CUser</span>
 <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
     <span class="token function">CUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
     <span class="token punctuation">{</span>
         m_NeededData <span class="token operator">=</span> <span class="token function">initData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
     <span class="token keyword">int</span> m_NeededData <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>

 CUser UserObj<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 这样一来，编译器在调用到<code>initData</code>函数时就会去初始化<code>DataObj</code>对象，也就保证能够有效调用其<code>getData</code>成员函数。需要注意的是，编译器只有发现程序里确实有调用<code>initData</code>函数的代码时，才会去初始化<code>DataObj</code>这个局部静态对象，否则如果只是有这个函数，但是没有人调用它，这个局部静态对象是不会在编译时被生成的。</p>
</li>
<li><p>也就是说，为避免<code>跨编译单元的初始化顺序</code>问题，我们可以用局部静态对象，来代替全局对象。</p>
</li>
</ol>
<h1 id="5：了解C-默默编写并调用哪些函数"><a href="#5：了解C-默默编写并调用哪些函数" class="headerlink" title="5：了解C++默默编写并调用哪些函数"></a><font size="6" color="orange">5：了解C++默默编写并调用哪些函数</font></h1><hr>
<h1 id="6：若不想使用编译器自动生成的函数，就该明确拒绝"><a href="#6：若不想使用编译器自动生成的函数，就该明确拒绝" class="headerlink" title="6：若不想使用编译器自动生成的函数，就该明确拒绝"></a><font size="6" color="orange">6：若不想使用编译器自动生成的函数，就该明确拒绝</font></h1><hr>
<p>如果不想使用编译器自动生成的函数，有两种办法：</p>
<ul>
<li>可以将相应的成员函数声明为private并且不予实现，甚至函数名字都不要。</li>
<li>将对应的函数声明为<code>delete</code>：<pre class="line-numbers language-cpp"><code class="language-cpp">  <span class="token function">CData</span><span class="token punctuation">(</span><span class="token keyword">const</span> CData<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//阻止拷贝</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
</ul>
<h1 id="7：为多态基类声明virtual析构函数"><a href="#7：为多态基类声明virtual析构函数" class="headerlink" title="7：为多态基类声明virtual析构函数"></a><font size="6" color="orange">7：为多态基类声明virtual析构函数</font></h1><hr>
<ol>
<li><p>带多态性质的基类应该声明一个virtual析构函数（不带的话delete基类指针，只会删除对应的子类对象的基类部分，会造成局部销毁，容易导致资源泄漏、败坏内存结构）。</p>
</li>
<li><p>如果类带有任何virtual函数，它就应该拥有一个virtual析构函数。</p>
</li>
<li><p>如果一个类不是作为基类使用，或者不具备多态性，就不该声明为virtual析构函数（因为会额外多出虚函数需要维护的指针以及虚表）。</p>
</li>
</ol>
<h1 id="8：别让异常逃离析构函数"><a href="#8：别让异常逃离析构函数" class="headerlink" title="8：别让异常逃离析构函数"></a><font size="6" color="orange">8：别让异常逃离析构函数</font></h1><hr>
<ol>
<li>析构函数绝对不要抛出任何异常。如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后吞下它们（不传播）或程序结束。</li>
</ol>
<h1 id="9：绝不在构造和析构过程中调用virtual函数"><a href="#9：绝不在构造和析构过程中调用virtual函数" class="headerlink" title="9：绝不在构造和析构过程中调用virtual函数"></a><font size="6" color="orange">9：绝不在构造和析构过程中调用virtual函数</font></h1><hr>
<ol>
<li><p>由于基类在构造时，子类还没有被构造出来，所以在基类里调用的虚函数，并不会指向子类的对应函数，只会指向基类自己的对应函数。如下代码所示：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">class</span> <span class="token class-name">CData</span>
 <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
     <span class="token function">CData</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
     <span class="token punctuation">{</span>
         <span class="token function">printDataV</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>

     <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">printDataV</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> m_Data <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
     <span class="token keyword">int</span> m_Data <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>

 <span class="token keyword">class</span> <span class="token class-name">CDerivedData</span> <span class="token operator">:</span> <span class="token keyword">public</span> CData
 <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
     <span class="token function">CDerivedData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
     <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">printDataV</span><span class="token punctuation">(</span><span class="token punctuation">)</span> override <span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> m_Data <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
     <span class="token keyword">int</span> m_Data <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 在调用<code>CData *pData = new CDerivedData();</code>时输出的是10，而不是20。因为基类指针在构造函数里调用的虚函数并不会指向子类。</p>
</li>
</ol>
<h1 id="10：令operator-返回一个自身对象的引用"><a href="#10：令operator-返回一个自身对象的引用" class="headerlink" title="10：令operator=返回一个自身对象的引用"></a><font size="6" color="orange">10：令operator=返回一个自身对象的引用</font></h1><hr>
<ol>
<li><p>由于=这个运算符，通常会被用于<code>x=y=z</code>这样的连等，而它其实又是右结合的，等价于<code>x=(y=z)</code>。而我们的=运算符的形参又通常是<code>const T&amp; vParam</code>类型的，所以为了实现连等，我们需要在重载=运算符时，返回一个指向自身对象的引用：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">class</span> <span class="token class-name">CData</span>
 <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
     CData<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> CData<span class="token operator">&amp;</span> vData<span class="token punctuation">)</span>
     <span class="token punctuation">{</span>
         m_Data <span class="token operator">=</span> vData<span class="token punctuation">.</span>m_Data<span class="token punctuation">;</span>
         <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
     <span class="token keyword">int</span> m_Data <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 如果不返回引用的话，<code>(y=z)</code>就会返回一个临时的局部对象，然后在<code>x=(y=z)</code>时会把这个临时的局部对象传递给形参<code>vData</code>，这显然是不对的，不能对临时局部对象取地址&amp;。</p>
</li>
<li><p>对于和=类似的运算符，比如+=、-+这些，重载时也都应该返回自身对象的引用。</p>
</li>
</ol>
<h1 id="11：在operator-中处理“自我赋值”"><a href="#11：在operator-中处理“自我赋值”" class="headerlink" title="11：在operator=中处理“自我赋值”"></a><font size="6" color="orange">11：在operator=中处理“自我赋值”</font></h1><hr>
<ol>
<li><p>如下代码：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">class</span> <span class="token class-name">CData</span>
 <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
     CData<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> CData<span class="token operator">&amp;</span> vData<span class="token punctuation">)</span>
     <span class="token punctuation">{</span>
         <span class="token keyword">delete</span> m_pData<span class="token punctuation">;</span>
         m_pData <span class="token operator">=</span> vData<span class="token punctuation">.</span>m_pData<span class="token punctuation">;</span>
         <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
     <span class="token keyword">int</span> <span class="token operator">*</span>m_pData <span class="token operator">=</span><span class="token keyword">nullptr</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 由于传入的<code>vData</code>有可能和当前对象<code>*this</code>实际上是同一个对象，所以<code>delete m_pData;</code>之后再<code>vData.m_pData</code>就是无效的了。我们应该考虑到这种自我赋值的情况，可以改成下面这样：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> CData<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> CData<span class="token operator">&amp;</span> vData<span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> <span class="token operator">&amp;</span>vData<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//证同测试</span>

     <span class="token keyword">delete</span> m_pData<span class="token punctuation">;</span>
     m_pData <span class="token operator">=</span> vData<span class="token punctuation">.</span>m_pData<span class="token punctuation">;</span>
     <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 不过我们也可以通过不最早删除指针的方式来自动排除自我赋值带来的隐患：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">class</span> <span class="token class-name">CData</span>
 <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
     CData<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> CData<span class="token operator">&amp;</span> vData<span class="token punctuation">)</span>
     <span class="token punctuation">{</span>
         <span class="token keyword">auto</span> <span class="token operator">*</span>pTmp <span class="token operator">=</span> vData<span class="token punctuation">.</span>m_pData<span class="token punctuation">;</span>
         m_pData <span class="token operator">=</span> pTmp<span class="token punctuation">;</span>
         <span class="token keyword">delete</span> m_pData<span class="token punctuation">;</span>
         <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
     <span class="token keyword">int</span> <span class="token operator">*</span>m_pData <span class="token operator">=</span><span class="token keyword">nullptr</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 这样做也不一定就比之前证同测试方案的效率要低，因为毕竟没有分支结构了，少了一个控制流，CPU指令在执行流水线时就没有预测错误所带来的开销了。</p>
</li>
</ol>
<h1 id="12：复制对象时勿忘其每一个成分"><a href="#12：复制对象时勿忘其每一个成分" class="headerlink" title="12：复制对象时勿忘其每一个成分"></a><font size="6" color="orange">12：复制对象时勿忘其每一个成分</font></h1><hr>
<ol>
<li>复制对象时应该确保复制对象内的所有成员变量，以及<strong>继承而来的基类成分</strong>。</li>
</ol>
<h1 id="13：以对象管理资源"><a href="#13：以对象管理资源" class="headerlink" title="13：以对象管理资源"></a><font size="6" color="orange">13：以对象管理资源</font></h1><hr>
<ol>
<li><p>对于形如<code>T* f()</code>这样的函数，返回的对象指针，应该由用户来释放，但是用户通常会因为忘记释放，或者方式不对而导致诸多错误。可以使用智能指针<code>shared_ptr</code>等等，通过把指针放进对象里，对象退出时在析构函数里调用delete来释放资源。</p>
</li>
<li><p>值得注意的是，智能指针在其析构函数里调用的是delete而不是delete []，所以不要试图用指针指针来指向一个数组：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">pInt</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//不对，智能指针析构函数里调用的是delete，而不是delete[]，无法有效删除数组</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
</ol>
<h1 id="14：在资源管理类中小心copying行为"><a href="#14：在资源管理类中小心copying行为" class="headerlink" title="14：在资源管理类中小心copying行为"></a><font size="6" color="orange">14：在资源管理类中小心copying行为</font></h1><hr>
<h1 id="15：在资源管理类中提供对原始资源的访问"><a href="#15：在资源管理类中提供对原始资源的访问" class="headerlink" title="15：在资源管理类中提供对原始资源的访问"></a><font size="6" color="orange">15：在资源管理类中提供对原始资源的访问</font></h1><hr>
<h1 id="16：成对使用new和delete时要采取相同形式"><a href="#16：成对使用new和delete时要采取相同形式" class="headerlink" title="16：成对使用new和delete时要采取相同形式"></a><font size="6" color="orange">16：成对使用new和delete时要采取相同形式</font></h1><hr>
<ol>
<li><p>单一对象的内存布局一般不同于数组的内存布局。数组所用的内存通常还包括“数组大小”的记录，以便delete知道需要调用多少次析构函数。</p>
</li>
<li><p>如果在new表达式中使用[ ]，必须在相应的delete表达式中也使用[ ]。如果在new表达式中不使用[ ]，也一定不要在相应的delete表达式中使用[ ]。</p>
</li>
</ol>
<h1 id="17：以独立语句将new出来的对象置入智能指针"><a href="#17：以独立语句将new出来的对象置入智能指针" class="headerlink" title="17：以独立语句将new出来的对象置入智能指针"></a><font size="6" color="orange">17：以独立语句将new出来的对象置入智能指针</font></h1><hr>
<ol>
<li>调用如下函数时：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token function">fun</span><span class="token punctuation">(</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>CData<span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">CData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getNum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
 C++编译器不保证两个实参的执行顺序，完全有可能先执行<code>new CData()</code>，再执行<code>getNum()</code>，最后执行<code>std::shared_ptr&lt;CData&gt;()</code>，那么如果在执行<code>getNum()</code>的时候发生了异常，<code>new CData()</code>得到的指针将不会被放入指针指针对象中，无法被释放，导致资源泄漏。为了避免这种情况的发生，我们应该给这两个实参明确的执行顺序，让后者不可能插一脚到前者里面：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">auto</span> pData <span class="token operator">=</span> std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>CData<span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">CData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token function">fun</span><span class="token punctuation">(</span>pData<span class="token punctuation">,</span> <span class="token function">getNum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
 所以，我们应该用一条独立的语句来把new出来的对象放入智能指针内。如果不这样做，一旦异常被抛出，有可能导致难以察觉的资源泄漏。</li>
</ol>
<h1 id="18：让接口容易被正确使用，不易被误用"><a href="#18：让接口容易被正确使用，不易被误用" class="headerlink" title="18：让接口容易被正确使用，不易被误用"></a><font size="6" color="orange">18：让接口容易被正确使用，不易被误用</font></h1><hr>
<ol>
<li>任何接口如果要求客户必须记得做某些事情，就是有着“不正确使用”的倾向，因为客户可能会忘记做那件事。</li>
</ol>
<h1 id="19：设计class犹如设计type"><a href="#19：设计class犹如设计type" class="headerlink" title="19：设计class犹如设计type"></a><font size="6" color="orange">19：设计class犹如设计type</font></h1><hr>
<h1 id="20：用引用传递代替值传递"><a href="#20：用引用传递代替值传递" class="headerlink" title="20：用引用传递代替值传递"></a><font size="6" color="orange">20：用引用传递代替值传递</font></h1><hr>
<ol>
<li><p>引用往往以指针实现出来，因此引用传递通常意味着真正传递的是指针（所以引用也可以和指针一样用来实现多态）。</p>
</li>
<li><p>对于内置类型、STL迭代器和函数对象，用值传递比引用传递好。其余的还是尽量用引用传递把。</p>
</li>
</ol>
<h1 id="21：必须返回对象时，别妄想返回其引用"><a href="#21：必须返回对象时，别妄想返回其引用" class="headerlink" title="21：必须返回对象时，别妄想返回其引用"></a><font size="6" color="orange">21：必须返回对象时，别妄想返回其引用</font></h1><hr>
<h1 id="22：将成员变量声明为private"><a href="#22：将成员变量声明为private" class="headerlink" title="22：将成员变量声明为private"></a><font size="6" color="orange">22：将成员变量声明为private</font></h1><hr>
<ol>
<li>protected并不比public更具封装性，所以尽量拒绝使用protected和public。</li>
</ol>
<h1 id="23：用非成员函数和非友元函数来代替成员函数"><a href="#23：用非成员函数和非友元函数来代替成员函数" class="headerlink" title="23：用非成员函数和非友元函数来代替成员函数"></a><font size="6" color="orange">23：用非成员函数和非友元函数来代替成员函数</font></h1><hr>
<h1 id="24：若所有参数皆需类型转换，请为此采用非成员函数"><a href="#24：若所有参数皆需类型转换，请为此采用非成员函数" class="headerlink" title="24：若所有参数皆需类型转换，请为此采用非成员函数"></a><font size="6" color="orange">24：若所有参数皆需类型转换，请为此采用非成员函数</font></h1><hr>
<h1 id="25：考虑写出一个不抛出异常的swap函数"><a href="#25：考虑写出一个不抛出异常的swap函数" class="headerlink" title="25：考虑写出一个不抛出异常的swap函数"></a><font size="6" color="orange">25：考虑写出一个不抛出异常的swap函数</font></h1><hr>
<h1 id="26：尽可能延后变量定义式的出现时间"><a href="#26：尽可能延后变量定义式的出现时间" class="headerlink" title="26：尽可能延后变量定义式的出现时间"></a><font size="6" color="orange">26：尽可能延后变量定义式的出现时间</font></h1><hr>
<ol>
<li>对于下面两种循环方式：<pre class="line-numbers language-cpp"><code class="language-cpp"> CData DataObj<span class="token punctuation">;</span>
 <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
     DataObj <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
     CData <span class="token function">DataObj</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
 对于第一种方式，需要1个构造函数+1个析构函数+n个赋值操作，对于第二种方式，需要n个构造函数+n个析构函数，除非明确知道析构和构造代价太大（大于赋值的代价），否则应该尽量使用第二种方案（第二种方式是直接调用拷贝构造函数，而第一种方式是先构造再赋值，构造比赋值的效率要高）。</li>
</ol>
<h1 id="27：尽量少做转型动作"><a href="#27：尽量少做转型动作" class="headerlink" title="27：尽量少做转型动作"></a><font size="6" color="orange">27：尽量少做转型动作</font></h1><hr>
<ol>
<li><p>dynamic_cast转型代价很高，执行速度很慢。</p>
</li>
<li><p>reinterpret_cast是机器级代码上的转型，不可移植。</p>
</li>
<li><p>如下代码：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">class</span> <span class="token class-name">CData</span>
 <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
     <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">modifyData</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
     <span class="token punctuation">{</span>
         m_Data <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>

     <span class="token keyword">int</span> <span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> m_Data<span class="token punctuation">;</span> <span class="token punctuation">}</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
     <span class="token keyword">int</span> m_Data <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>

 <span class="token keyword">class</span> <span class="token class-name">CDerivedData</span> <span class="token operator">:</span> <span class="token keyword">public</span> CData
 <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
     <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">modifyData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> override
     <span class="token punctuation">{</span>
         <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>CData<span class="token operator">></span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">modifyData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>

 CDerivedData DerivedData<span class="token punctuation">;</span>
 DerivedData<span class="token punctuation">.</span><span class="token function">modifyData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 程序输出的结果是10，而不是20。这是因为<code>static_cast&lt;CData&gt;(*this).modifyData();</code>在转型时，会产生一个基类部分的副本，对副本调用<code>modifyData</code>函数，并不会改变<code>DerivedData</code>对象本身的数据成员。应该使用域作用符来调用基类函数，才会真正有效地更改成员数据：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">modifyData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> override
 <span class="token punctuation">{</span>
     CData<span class="token operator">::</span><span class="token function">modifyData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>优良的C++代码很少使用转型。如果可以，尽量避免转型，特别是在注重效率的代码中避免dynamic_cast。如果有个设计需要转型动作，试着发展无序转型的替代设计</p>
</li>
<li><p>如果转型是必要的，试着将它隐藏于某个函数背后（比如给自己的类定义隐式转换函数）。客户随后可以调用该函数，而不需要将转型放进他们自己的代码内。</p>
</li>
</ol>
<h1 id="28：避免返回指向对象内部成分的非const指针"><a href="#28：避免返回指向对象内部成分的非const指针" class="headerlink" title="28：避免返回指向对象内部成分的非const指针"></a><font size="6" color="orange">28：避免返回指向对象内部成分的非const指针</font></h1><hr>
<h1 id="29：为“异常安全”而努力是值得的"><a href="#29：为“异常安全”而努力是值得的" class="headerlink" title="29：为“异常安全”而努力是值得的"></a><font size="6" color="orange">29：为“异常安全”而努力是值得的</font></h1><hr>
<h1 id="30：透彻了解内联的里里外外"><a href="#30：透彻了解内联的里里外外" class="headerlink" title="30：透彻了解内联的里里外外"></a><font size="6" color="orange">30：透彻了解内联的里里外外</font></h1><hr>
<ol>
<li><p>不仅<strong>在头文件中定义</strong>的成员函数是默认声明的内联函数，在类定义里的友元函数也是默认声明为内联函数的。</p>
</li>
<li><p>内联函数通常一定被置于头文件内。</p>
</li>
<li><p>直接调用内联函数，编译器有可能会真的实现内联（代码展开），但是如果指向内联函数的指针来调用该函数，则编译器一定不会执行内联效果。</p>
</li>
</ol>
<h1 id="31：将文件间的编译依存关系降至最低"><a href="#31：将文件间的编译依存关系降至最低" class="headerlink" title="31：将文件间的编译依存关系降至最低"></a><font size="6" color="orange">31：将文件间的编译依存关系降至最低</font></h1><hr>
<h1 id="32：确定你的public继承塑模出is-a关系"><a href="#32：确定你的public继承塑模出is-a关系" class="headerlink" title="32：确定你的public继承塑模出is-a关系"></a><font size="6" color="orange">32：确定你的public继承塑模出is-a关系</font></h1><hr>
<ol>
<li><p>public继承意味着is-a。也就是说适用于基类身上的每一件事情一定也适用于派生类身上。或者说每一个派生类对象本质上也都是一个基类对象。</p>
</li>
<li><p>比如我们想要定义鸟和企鹅这两个类，那么企鹅类应该public继承鸟类吗？如下所示：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">class</span> <span class="token class-name">CBird</span>
 <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
     <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>

 <span class="token keyword">class</span> <span class="token class-name">CPenguin</span> <span class="token operator">:</span> <span class="token keyword">public</span> CBird
 <span class="token punctuation">{</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 但是鸟会飞，企鹅不会飞。。。基类会做的事情子类不会做，这违背公有派生的原则。那么我们可能像下面这样做：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">class</span> <span class="token class-name">CBird</span>
 <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
     <span class="token comment" spellcheck="true">//没有fly函数</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>

 <span class="token keyword">class</span> <span class="token class-name">CFlyingBird</span> <span class="token operator">:</span> CBird
 <span class="token punctuation">{</span>
     <span class="token keyword">public</span><span class="token operator">:</span>
         <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>

 <span class="token keyword">class</span> <span class="token class-name">CPenguin</span> <span class="token operator">:</span> <span class="token keyword">public</span> CFlyingBird
 <span class="token punctuation">{</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 这样的继承体系比原先的设计更能忠实反应我们真正的意思。但是如果我们的需求里不需要关注飞行这件事，那么不区分会飞的鸟和不会飞的鸟，会更好。</p>
</li>
<li><p>再比如，正方形应该公有继承矩形吗？从直观上说，正方形也是矩形，公有继承好像没什么问题。但是某些可以施行于矩形身上的事情（例如宽度可独立于其高度被外界修改）却不可施行于正方形上（宽度总是应该跟高度一样），所以公有继承可能是不合适的。</p>
</li>
</ol>
<h1 id="33：避免遮掩继承而来的名称"><a href="#33：避免遮掩继承而来的名称" class="headerlink" title="33：避免遮掩继承而来的名称"></a><font size="6" color="orange">33：避免遮掩继承而来的名称</font></h1><hr>
<h1 id="34：区分接口继承和实现继承"><a href="#34：区分接口继承和实现继承" class="headerlink" title="34：区分接口继承和实现继承"></a><font size="6" color="orange">34：区分接口继承和实现继承</font></h1><hr>
<ol>
<li><p>声明纯虚函数 ，是为了让子类只继承函数接口。</p>
</li>
<li><p>声明非纯虚函数，是为了让子类继承该函数的接口和<strong>缺省</strong>实现。</p>
</li>
<li><p>声明非虚的成员函数，是为了让子类继承函数的接口和一份<strong>强制性</strong>实现（即不可以被子类更改）。</p>
</li>
</ol>
<h1 id="35：考虑虚函数以外的其他选择"><a href="#35：考虑虚函数以外的其他选择" class="headerlink" title="35：考虑虚函数以外的其他选择"></a><font size="6" color="orange">35：考虑虚函数以外的其他选择</font></h1><hr>
<h1 id="36：绝不重新定义继承而来的非虚函数"><a href="#36：绝不重新定义继承而来的非虚函数" class="headerlink" title="36：绝不重新定义继承而来的非虚函数"></a><font size="6" color="orange">36：绝不重新定义继承而来的非虚函数</font></h1><hr>
<h1 id="37：绝不重新定义继承而来的缺省参数值"><a href="#37：绝不重新定义继承而来的缺省参数值" class="headerlink" title="37：绝不重新定义继承而来的缺省参数值"></a><font size="6" color="orange">37：绝不重新定义继承而来的缺省参数值</font></h1><hr>
<ol>
<li><p>虚函数是动态绑定，但是缺省参数值却是静态绑定的。如下代码：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">class</span> <span class="token class-name">CData</span>
 <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
     <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">printDataV</span><span class="token punctuation">(</span><span class="token keyword">int</span> vData <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>

 <span class="token keyword">class</span> <span class="token class-name">CDerivedData</span> <span class="token operator">:</span> <span class="token keyword">public</span> CData
 <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
     <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">printDataV</span><span class="token punctuation">(</span><span class="token keyword">int</span> vData <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">)</span> <span class="token keyword">const</span> override
     <span class="token punctuation">{</span>
         std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> vData <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>

 CData <span class="token operator">*</span>pDataObj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">CDerivedData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 pDataObj<span class="token operator">-</span><span class="token operator">></span><span class="token function">printDataV</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 程序输出的结果是10，而不是20。印证了参数是静态绑定的事实。</p>
</li>
<li><p>那么我们把子类的默认参数也改为20？倒是可以按照我们预期的工作，但是如果默认参数要变成另一个值，那么就需要把基类和所有子类的默认参数全都改一次！有很多可以代替虚函数的设计，其中NVI（non-virtual interface）手法如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">class</span> <span class="token class-name">CData</span>
 <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
     <span class="token keyword">void</span> <span class="token function">printData</span><span class="token punctuation">(</span><span class="token keyword">int</span> vData <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">)</span>
     <span class="token punctuation">{</span>
         <span class="token function">doPrintDataV</span><span class="token punctuation">(</span>vData<span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
     <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">doPrintDataV</span><span class="token punctuation">(</span><span class="token keyword">int</span> vData<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>

 <span class="token keyword">class</span> <span class="token class-name">CDerivedData</span> <span class="token operator">:</span> <span class="token keyword">public</span> CData
 <span class="token punctuation">{</span>
 <span class="token keyword">private</span><span class="token operator">:</span>
     <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">doPrintDataV</span><span class="token punctuation">(</span><span class="token keyword">int</span> vData<span class="token punctuation">)</span> <span class="token keyword">const</span> override
     <span class="token punctuation">{</span>
         std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> vData <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 在基类里使用一个非虚函数来提供缺省值，然后调用一个虚函数来完成具体的实现。这样一来，缺省值需要改变时，就只会影响到基类，而不会影响到任何子类。</p>
</li>
</ol>
<h1 id="38：通过复合塑模出has-a"><a href="#38：通过复合塑模出has-a" class="headerlink" title="38：通过复合塑模出has-a"></a><font size="6" color="orange">38：通过复合塑模出has-a</font></h1><hr>
<ol>
<li><p>复合是类型之间一种关系，当某种类型对象内含有其它类型的成员，便是复合关系。</p>
</li>
<li><p>复合意味着has-a（有一个）。</p>
</li>
</ol>
<h1 id="39：明智而审慎地使用private继承"><a href="#39：明智而审慎地使用private继承" class="headerlink" title="39：明智而审慎地使用private继承"></a><font size="6" color="orange">39：明智而审慎地使用private继承</font></h1><hr>
<ol>
<li><p>如果类之间的继承关系是private，编译器不会自动将一个子类对象转换为一个基类对象。</p>
</li>
<li><p>private继承其实也是has-a的关系，而复合也是，那么我们应该选择谁呢？我们应该尽可能使用复合，必要时才使用private继承。因为private继承通常需要重写基类的虚函数，但是由于是has-a的关系，基类里的功能实际上子类并不需要，如果在子类里硬加上的话，容易对子类的客户造成误解或者被误用。</p>
</li>
<li><p>当基类是个空的类（没有数据成员）时，使用private继承比使用复合更好，因为复合会耗费更大的内存空间（编译器、对齐等等原因），除此之外都应该尽量用复合来代替private继承。</p>
</li>
</ol>
<h1 id="40：明智而审慎地使用多重继承"><a href="#40：明智而审慎地使用多重继承" class="headerlink" title="40：明智而审慎地使用多重继承"></a><font size="6" color="orange">40：明智而审慎地使用多重继承</font></h1><hr>
<ol>
<li><p>多重继承比单一继承复杂，它可能导致新的歧义性，以及对virtual继承的需要（钻石型多重继承里面，子类可能会有最高基类数据来自多条路径下的多份拷贝）。</p>
</li>
<li><p>virtual继承会增加大小、速度、初始化（及赋值）复杂度等等成本。如果基类不带任何数据，这种情况下使用多重继承是比较实用的（不用考虑之前说的那些问题，因为基类没有数据成员）。</p>
</li>
</ol>
<h1 id="41：了解隐式接口和编译期多态"><a href="#41：了解隐式接口和编译期多态" class="headerlink" title="41：了解隐式接口和编译期多态"></a><font size="6" color="orange">41：了解隐式接口和编译期多态</font></h1><hr>
<ol>
<li>以不同的模板参数具现化函数模板会导致调用不同的函数，这就是所谓的编译器多态。</li>
</ol>
<h1 id="42：了解typename的双重意义"><a href="#42：了解typename的双重意义" class="headerlink" title="42：了解typename的双重意义"></a><font size="6" color="orange">42：了解typename的双重意义</font></h1><hr>
<ol>
<li>缺省情况下，嵌套从属名称不是类型（简单的说在模板中以::访问的默认是变量名而不是类型名）。</li>
</ol>
<h1 id="43：学习处理模板化基类内的名称"><a href="#43：学习处理模板化基类内的名称" class="headerlink" title="43：学习处理模板化基类内的名称"></a><font size="6" color="orange">43：学习处理模板化基类内的名称</font></h1><hr>
<ol>
<li>模板类在被继承时，子类无法直接拿到模板父类的模板成员函数，因为在定义子类时，父类还没有被具现化，它不能清楚地知道它要继承什么样的类，所以会拒绝在模板化基类中寻找继承而来的名称（在有的编译器上无法通过编译，需要加上<code>this-&gt;</code>或者在子类中使用<code>unsing</code>，告诉编译器在基类里有这个函数）。</li>
</ol>
<h1 id="44：将与参数无关的代码抽离模板"><a href="#44：将与参数无关的代码抽离模板" class="headerlink" title="44：将与参数无关的代码抽离模板"></a><font size="6" color="orange">44：将与参数无关的代码抽离模板</font></h1><hr>
<ol>
<li>使用模板可能会导致代码膨胀：其二进制码带着重复（或几乎重复）的代码、数据或两者。其结果有可能源码看起来合身而整齐，但目标码却不是那么回事。</li>
</ol>
<h1 id="45：运用成员函数模板接受所有兼容类型"><a href="#45：运用成员函数模板接受所有兼容类型" class="headerlink" title="45：运用成员函数模板接受所有兼容类型"></a><font size="6" color="orange">45：运用成员函数模板接受所有兼容类型</font></h1><hr>
<ol>
<li>在类内声明模板构造函数，并不会阻止编译器生成它们自己的构造函数（赋值函数也是一样的）。</li>
</ol>
<h1 id="46：需要类型转换时请为模板定义非成员函数"><a href="#46：需要类型转换时请为模板定义非成员函数" class="headerlink" title="46：需要类型转换时请为模板定义非成员函数"></a><font size="6" color="orange">46：需要类型转换时请为模板定义非成员函数</font></h1><hr>
<ol>
<li><p>模板实参推导过程中不考虑采纳“通过构造函数而发生的”隐式类型转换。</p>
</li>
<li><p>当我们编写一个类模板，如果有的函数“与此模板相关”并且“其参数有隐式类型转换”时，请将这些函数定义为类模板内部的友元函数（比如对模板类进行<code>operator*</code>的成员函数）。</p>
</li>
</ol>
<h1 id="47：请使用traits类表现类型信息"><a href="#47：请使用traits类表现类型信息" class="headerlink" title="47：请使用traits类表现类型信息"></a><font size="6" color="orange">47：请使用traits类表现类型信息</font></h1><hr>
<ol>
<li><p>STL中有一个名为advance的模板函数，用来将某个迭代器移动某个给定距离。</p>
</li>
<li><p>我们可以使用<code>typeid</code>来判断一个类型，但是也可以使用重载函数来解决同样的问题（这样就把运行期的问题移到了编译器）（比如判断迭代器类型是随机访问迭代器、双向迭代器或者输入迭代器）。</p>
</li>
<li><p>traits类其实就是在模板类里面加了个类型标签，比如在一个类里面使用typedef把<code>iterator_category</code>定义成<code>random_access_iterator_tag</code>，在另一个类里面使用typedef把<code>iterator_category</code>定义成<code>bidirectional_iterator_tag</code>。traits类使得“类型相关信息”在编译器可用。</p>
</li>
</ol>
<h1 id="48：认识模板元编程"><a href="#48：认识模板元编程" class="headerlink" title="48：认识模板元编程"></a><font size="6" color="orange">48：认识模板元编程</font></h1><hr>
<ol>
<li><p>使用模板元编程（TMP）的C++程序可能在每一方面都更高效：较小的可执行文件、较短的运行期、较少的内存需求。然而将工作从运行期转移至编译器的另一个结果是：编译时间变长了，程序如果使用TMP，其编译时间可能远长于不使用TMP的对应版本。</p>
</li>
<li><p>下面是一个TMP的初级程序：计算阶乘。</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">unsigned</span> n<span class="token operator">></span>
 <span class="token keyword">struct</span> SFactorial
 <span class="token punctuation">{</span>
     <span class="token keyword">enum</span>
     <span class="token punctuation">{</span>
         value <span class="token operator">=</span> n <span class="token operator">*</span> SFactorial<span class="token operator">&lt;</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token operator">></span><span class="token operator">::</span>value
     <span class="token punctuation">}</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>

 <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">></span>  <span class="token operator">/</span>特例化版本
 <span class="token keyword">struct</span> SFactorial<span class="token operator">&lt;</span><span class="token number">0</span><span class="token operator">></span>
 <span class="token punctuation">{</span>
     <span class="token keyword">enum</span> 
     <span class="token punctuation">{</span>
         value <span class="token operator">=</span> <span class="token number">1</span>
     <span class="token punctuation">}</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>模板元编程可将工作由运行期移往编译期，因而得以实现早期错误侦测和更高的执行效率。</p>
</li>
</ol>
<h1 id="49：了解new-handler的行为"><a href="#49：了解new-handler的行为" class="headerlink" title="49：了解new-handler的行为"></a><font size="6" color="orange">49：了解new-handler的行为</font></h1><hr>
<ol>
<li><p>由于堆是一个可被改动的全局性资源，因此多线程系统充斥着发狂访问这一类资源的竞速状态（race conditions）出现机会。</p>
</li>
<li><p>当operator new抛出异常以反映一个未获满足的内存需求之前，它会先调用一个客户指定的错误处理函数，即所谓的new-handler。我们可以使用<code>std::set_new_handler</code>函数来设置想要的错误处理函数：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">void</span> <span class="token function">outOfMem</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
     std<span class="token operator">::</span>cerr <span class="token operator">&lt;&lt;</span> <span class="token string">"无法分配所需的内存"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
     std<span class="token operator">::</span><span class="token function">abort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>

 std<span class="token operator">::</span><span class="token function">set_new_handler</span><span class="token punctuation">(</span>outOfMem<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">int</span> <span class="token operator">*</span>pBigDataArray <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">100000000L</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<h1 id="50：了解new和delete的合理替换时机"><a href="#50：了解new和delete的合理替换时机" class="headerlink" title="50：了解new和delete的合理替换时机"></a><font size="6" color="orange">50：了解new和delete的合理替换时机</font></h1><hr>
<ol>
<li>有许多理由需要写个自定的new和delete，包括改善效能、对堆运用错误进行调试、收集堆使用信息。</li>
</ol>
<h1 id="51：编写new和delete时需固守常规"><a href="#51：编写new和delete时需固守常规" class="headerlink" title="51：编写new和delete时需固守常规"></a><font size="6" color="orange">51：编写new和delete时需固守常规</font></h1><hr>
<ol>
<li>operator new应该内含一个无穷循环，并且尝试分配内存，如果它无法满足内存需求，就该调用new-handler。</li>
</ol>
<h1 id="52：写了placement-new也要写placement-delete-font-gt"><a href="#52：写了placement-new也要写placement-delete-font-gt" class="headerlink" title="52：写了placement new也要写placement delete/font&gt;"></a><font size="6" color="orange">52：写了placement new也要写placement delete/font&gt;</font></h1><hr>
<ol>
<li><p>如果自定义的operator new接受的参数除了一定会有的那个size_t（要分配的内存的大小）之外，还有其他参数，这就是个所谓的placement new。</p>
</li>
<li><p>类似于new的placement版本，operator delete如果接受额外参数，便称为placement delete。</p>
</li>
<li><p>placement delete只有在“伴随placement new调用而触发的构造函数”出现异常时才会被调用。对着一个指针执行delete绝不会调用placement delete。</p>
</li>
<li><p>当你写一个placement operator new，请确定也写出了对应的placement operator delete。如果没有这样做，你的程序可能会发生隐蔽而时断时续的内存泄漏。</p>
</li>
<li><p>当你声明placement new和placement delete，请确定不要无意识地遮掩了它们的正常版本（需要把它们的正常版本也显式定义出来）。</p>
</li>
</ol>
<h1 id="53：不要轻易忽视编译器的警告"><a href="#53：不要轻易忽视编译器的警告" class="headerlink" title="53：不要轻易忽视编译器的警告"></a><font size="6" color="orange">53：不要轻易忽视编译器的警告</font></h1><hr>
<h1 id="54：让自己熟悉包括TR1在内的标准程序库"><a href="#54：让自己熟悉包括TR1在内的标准程序库" class="headerlink" title="54：让自己熟悉包括TR1在内的标准程序库"></a><font size="6" color="orange">54：让自己熟悉包括TR1在内的标准程序库</font></h1><hr>
<ol>
<li>TR1自身只是一份规范。为获得TR1提供的好处，需要一份实物。一个好的实物来源是boost。</li>
</ol>
<h1 id="55：让自己熟悉Boost"><a href="#55：让自己熟悉Boost" class="headerlink" title="55：让自己熟悉Boost"></a><font size="6" color="orange">55：让自己熟悉Boost</font></h1><hr>
<p>参考文献：《Effective C++》</p>

            </div>

            <!-- Post Comments -->
            
    <!-- 使用 DISQUS_CLICK -->
<div id="disqus-comment">
    <div id="disqus_thread"></div>

<!-- add animation -->
<style>
	.disqus_click_btn {
            line-height: 30px;
            margin: 0;
            min-width: 50px;
            padding: 0 14px;
            display: inline-block;
            font-family: "Roboto", "Helvetica", "Arial", sans-serif;
            font-size: 14px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0;
            overflow: hidden;
            will-change: box-shadow;
            transition: box-shadow .2s cubic-bezier(.4, 0, 1, 1), background-color .2s cubic-bezier(.4, 0, .2, 1), color .2s cubic-bezier(.4, 0, .2, 1);
            outline: 0;
            cursor: pointer;
            text-decoration: none;
            text-align: center;
            vertical-align: middle;
            border: 0;
            background: rgba(158, 158, 158, .2);
            box-shadow: 0 2px 2px 0 rgba(0, 0, 0, .14), 0 3px 1px -2px rgba(0, 0, 0, .2), 0 1px 5px 0 rgba(0, 0, 0, .12);
            color: #fff;
            background-color: #7EC0EE;
            text-shadow: 0
        }
</style>
	
<div class="btn_click_load" id="disqus_bt"> 
    <button class="disqus_click_btn">点击查看评论</button>
</div>

<!--
<script type="text/javascript">
$('.btn_click_load').click(function() {
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'http-miccall-tech'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    document.getElementById('disqus_bt').style.display = "none";
});
</script>
-->
<script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://yoursite.com/2018/09/19/Effective-C++/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = 'http://yoursite.com/2018/09/19/Effective-C++/'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
</script>

<script type="text/javascript">
    $('.btn_click_load').click(function() {  //click to load comments
        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document;
            var s = d.createElement('script');
            s.src = '//http-miccall-tech.disqus.com/embed.js';
            s.setAttribute('data-timestamp', + new Date());
            (d.head || d.body).appendChild(s);
        })();
        $('.btn_click_load').css('display','none');
    });
</script>
</div>
<style>
    #disqus-comment{
        background-color: #eee;
        padding: 2pc;
    }
</style>


        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
                <li>Design: <a href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
            </ul>
            
            	<span id="busuanzi_container_site_pv">2019总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			
        </div>
    </div>
</body>



 	
</html>
