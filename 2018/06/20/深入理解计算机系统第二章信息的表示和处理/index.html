<!DOCTYPE HTML>
<html>

<head>
	<link rel="bookmark"  type="image/x-icon"  href="/img/logo_miccall.png"/>
	 <link rel="shortcut icon" href="/img/logo_miccall.png">
	
			
    <title>
    Elays'Blog
    </title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="/css/mic_main.css" />
    <link rel="stylesheet" href="/css/dropdownMenu.css" />
    
    	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css" />
    </noscript>

			    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<link rel="stylesheet" href="/css/prism-dark.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>
    
		
<!-- Layouts -->


<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<!--<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">-->
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/latest.js?config=TeX-MML-AM_CHTML" async>
</script>


<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_undefined.css" />
<link rel="stylesheet" href="/css/typo.css" />
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">MICCALL</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special" >
            <ul class="menu links" >
			<!-- Homepage  主页  --> 
			<li >
	            <a href="/" rel="nofollow">主页</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">分类</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="/categories/Boost/">Boost</a></li><li><a class="category-link" href="/categories/C-语法/">C#语法</a></li><li><a class="category-link" href="/categories/C/">C++</a></li><li><a class="category-link" href="/categories/C语言/">C语言</a></li><li><a class="category-link" href="/categories/OpenGL/">OpenGL</a></li><li><a class="category-link" href="/categories/c/">c++</a></li><li><a class="category-link" href="/categories/全局光照/">全局光照</a></li><li><a class="category-link" href="/categories/博客配置/">博客配置</a></li><li><a class="category-link" href="/categories/并行计算/">并行计算</a></li><li><a class="category-link" href="/categories/操作系统/">操作系统</a></li><li><a class="category-link" href="/categories/数据结构/">数据结构</a></li><li><a class="category-link" href="/categories/毕设/">毕设</a></li><li><a class="category-link" href="/categories/游戏开发/">游戏开发</a></li><li><a class="category-link" href="/categories/游戏设计模式/">游戏设计模式</a></li><li><a class="category-link" href="/categories/计算机图形学/">计算机图形学</a></li><li><a class="category-link" href="/categories/计算机系统/">计算机系统</a></li><li><a class="category-link" href="/categories/设计模式/">设计模式</a></li><li><a class="category-link" href="/categories/调试错误集锦/">调试错误集锦</a>
	                    </ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/about/" title="简历">
		                简历
		            </a>
		        </li>
		        
		        <li>
		            <a href="/group/" title="团队">
		                团队
		            </a>
		        </li>
		        
		        <li>
		            <a href="/gallery/" title="图库">
		                图库
		            </a>
		        </li>
		        
		        <li>
		            <a href="/tag/" title="标签">
		                标签
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
		            
		                <li><a href="https://github.com/miccall" class="icon fa-github"><span class="label">GitHub</span></a></li>
		            
		            
		            
		            
			</ul>
</nav>

        <div id="main" >
            <div class ="post_page_title_img" style="height: 25rem;background-image: url(http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC2%E7%AB%A0_BG.jpg);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;" >
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2 >深入理解计算机系统第二章 信息的表示和处理</h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
                <p><font size="5" color="orange">信息存储</font></p>
<hr>
<p><font size="4" color="red">字数据大小</font><br>每台计算机都有一个字长（word size），指明指针数据的标称大小（normal size）。因为虚拟地址是以这样的一个字来编码的，所以字长决定的最重要的系统参数就是虚拟地址空间的最大大小。也就是说，对于一个字长为$\omega$位的机器而言，虚拟地址的范围为$0 \sim 2^\omega-1$，程序最多访问$2^\omega$个字节。</p>
<p>我们将程序称为“32位程序”或“64位程序”时，区别在于该程序是如何编译的，而不是其运行的机器类型。即用32位还是64位指令来编译的：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">linux<span class="token operator">></span> gcc <span class="token operator">-</span>m32 prog<span class="token punctuation">.</span>c
linux<span class="token operator">></span> gcc <span class="token operator">-</span>m64 prog<span class="token punctuation">.</span>c
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>C语言数据类型中，有两种数据类型大小与程序字长有关：</p>
<ul>
<li>long和unsigned long类型，在32位程序里是4个字节，在64位程序里是8个字节。</li>
<li>指针类型char*，在32位程序里是4个字节，在64位程序里是8个字节（指针使用的是程序的全字长）。</li>
</ul>
<p>许多程序员假设一个声明为int类型的程序对象能被用来存储一个指针。这在多数32位的机器上能正常工作，但是在一台64位的机器上却会出问题。因为在64位程序里，指针时64位，不能用32位的int类型来存储。</p>
<p><font size="4" color="red">寻址和字节顺序</font><br>某些机器选择在内存中按照从最低有效字节到最高有效字节的顺序存储对象，而另一些机器则按照从最高有效字节到最低有效字节的顺序存储。前一种规则——最低有效字节在最前面的方式，称为小端法（little endian），后一种规则——最高有效字节在最前面的方式，称为大端法（big endian）。比如有一个变量x的类型为int，位于地址0x100处，它的十六进制值为0x01234567，下图分别是按照小端法和大端法来存储该变量值的方式：<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC2%E7%AB%A0_1.png" alt=""><br>注意，在字0x01234567中，高位字节的十六进制值为0x01，而低位字节值为0x67（有个很好的记法：地址由小到大增加时，如果存储的值的顺序和对应变量的十六进制表示顺序相同，则是大端法，顺序相反则是小端法）。</p>
<p>大多数Intel兼容机都只用小端模式，但是IBM和Oracle的大多数机器则是按照大端模式操作。许多比较新的微处理器是双端法（bi-endian），也就是说可以把它们配置成大端或者小端的机器运行。然而，实际情况是：一旦选择了特定操作系统，那么字节顺序也就固定下来（因为一种操作系统可能只能运行于大端或者小端模式）。</p>
<p>大多数情况下，大端或者小端机器所编译的程序会得到同样的结果。但是有时候，大端还是小端的字节顺序会成为问题：</p>
<ul>
<li>首先是在不同类型的机器之间通过网络传送二进制数据时，一个常见的问题是当小端法机器产生的数据被发送到大端法机器或者反过来时，接收程序会发现，字里的字节成了反序的。为了避免这类问题，网络应用程序的代码编写必须遵守已建立的关于字节顺序的规则，以确保发送方机器将它的内部表示转换成网络标准，而接收机器则将网络标准转换为它的内部表示。</li>
<li>第二种情况是，当阅读表示整数数据的字节序列时字节顺序也很重要。比如下面的机器级代码：<pre class="line-numbers language-cpp"><code class="language-cpp">4004d3<span class="token operator">:</span>  <span class="token number">01</span> <span class="token number">05</span> <span class="token number">43</span> 0b <span class="token number">20</span> <span class="token number">00</span>      add  <span class="token operator">%</span>eax<span class="token punctuation">,</span><span class="token function">0x200b43</span><span class="token punctuation">(</span><span class="token operator">%</span>rip<span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
这一行是由反汇编器（disassembler）生成的，反汇编器是一种可确定可执行程序文件所表示的指令序列的工具。这行代码的意思是：把一个字长的数据加到一个值上，该值的存储地址由0x200b43加上当前程序计数器的值得到。如果取出这个序列的最后4个字节：43 0b 20 00，并且按照相反的顺序（小端法）写出，我们得到00 20 0b 43。去掉开头的0，得到值0x200b43，这就是右边要加的数值；但是如果是大端法，那么要加的值就是0x430b2000了。</li>
<li><p>第三种情况是当编写规避正常的类型系统的程序时（比如强制类型转换）。比如下面的代码使用强制类型转换来规避类型系统，来打印程序对象的字节表示：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">  <span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">*</span> byte_pointer<span class="token punctuation">;</span>

  <span class="token keyword">void</span> <span class="token function">showBytes</span><span class="token punctuation">(</span>byte_pointer vStart<span class="token punctuation">,</span> size_t vLen<span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> vLen<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
          <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%.2x "</span><span class="token punctuation">,</span> vStart<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">void</span> <span class="token function">showInt</span><span class="token punctuation">(</span><span class="token keyword">int</span> vValue<span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
      <span class="token function">showBytes</span><span class="token punctuation">(</span><span class="token punctuation">(</span>byte_pointer<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>vValue<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">void</span> <span class="token function">showFloat</span><span class="token punctuation">(</span><span class="token keyword">float</span> vValue<span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
      <span class="token function">showBytes</span><span class="token punctuation">(</span><span class="token punctuation">(</span>byte_pointer<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>vValue<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">void</span> <span class="token function">showPointer</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>vPointer<span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
      <span class="token function">showBytes</span><span class="token punctuation">(</span><span class="token punctuation">(</span>byte_pointer<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>vPointer<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
      <span class="token keyword">int</span> IValue <span class="token operator">=</span> <span class="token number">12345</span><span class="token punctuation">;</span>
      <span class="token keyword">float</span> FValue <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>IValue<span class="token punctuation">;</span>
      <span class="token keyword">int</span> <span class="token operator">*</span>pValue <span class="token operator">=</span> <span class="token operator">&amp;</span>IValue<span class="token punctuation">;</span>
      <span class="token function">showInt</span><span class="token punctuation">(</span>IValue<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">showFloat</span><span class="token punctuation">(</span>FValue<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">showPointer</span><span class="token punctuation">(</span>pValue<span class="token punctuation">)</span><span class="token punctuation">;</span>

      <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面程序使用<code>(byte_pointer)</code>将指针<code>&amp;vValue</code>强制类型转换为<code>unsigned char *</code>，它告诉编译器，程序应该把这个指针看成指向一个字节序列，而不是指向一个原始数据类型的对象。运行结果如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token number">39</span> <span class="token number">30</span> <span class="token number">00</span> <span class="token number">00</span>
<span class="token number">00</span> e4 <span class="token number">40</span> <span class="token number">46</span>
<span class="token number">14</span> fa cf <span class="token number">00</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>数字12345的十六进制表示为0x00003039，本机输出它的十六进制表示是0x3930000，说明笔者本机是小端法机器。虽然上面的整型和浮点型数据都是对数值12345的编码，但是它们有截然不同的字节模式，整型为0x00003039，浮点型为0x4640E400，将他俩分别展开为二进制形式，如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">  <span class="token number">00000000000000000011000000111001</span>
                     <span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span>
            <span class="token number">01000110010000001110010000000000</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>会发现它俩有一个13位相匹配的位序列（星号标出来那一串），这当然不是巧合，后文研究浮点数表示格式时会见分晓。</p>
</li>
</ul>
<p><font size="4" color="red">表示字符串</font><br>在使用ASCII码作为字符码的任何系统上都将得到相同的结果，与字节顺序和字大小规则无关。因此，使用ASCII码表示的文本数据比二进制数据具有更强的平台独立性。二进制代码是不兼容的，很少有二进制代码能够在不同机器和操作系统组合之间移植。</p>
<p><font size="4" color="red">C语言中的位级运算</font><br>位级运算的一个常见用法就是实现掩码运算，这里掩码是一个位模式，表示从一个字中选出的位的集合。比如位级运算x&amp;0xFF将会生成一个由x的最低有效字节组成的值，而其他自己被置位0。</p>
<p><font size="4" color="red">C语言中的移位运算</font></p>
<ul>
<li>左移：C表达式<code>x&lt;&lt;k</code>会生成一个值：x向左移动k位，并在右端补k个0。</li>
<li>右移：右移<code>x&gt;&gt;k</code>有两种：逻辑右移和算术右移。逻辑右移是直接在左端补k个0；而算术右移是在左端补k个最高有效位的值（最高有效位是1就补1，是0就补0，它对有符号整数数据的运算非常有用）。</li>
</ul>
<p>因为算术右移补的实际上是符号位（最高有效位），所以只有有符号数才存在算术右移，无符号数不存在算术右移，它只有逻辑右移。</p>
<p>C语言标准并没有明确定义对于有符号数应该使用哪种类型的右移：算术右移或者逻辑右移都可以。不幸的是，这就意味着任何假设一种或者另一种右移形式的代码都可能会遇到可移植性问题。然而实际上，几乎所有的编译器/机器组合都对有符号数使用算术右移，且许多程序员也都假设机器会使用这种右移。与C相比，Java对于如何进行右移有明确的定义：表达式<code>x&gt;&gt;k</code>会将x算术右移k个位置，而<code>x&gt;&gt;&gt;k</code>会对x做逻辑右移。</p>
<p>如果数据只有w位，但是要求移动k位而且k&gt;=w，C语言规定这种情况下实际上移动的是k%w位。</p>
<p><font size="5" color="orange">整数表示</font></p>
<hr>
<p><font size="4" color="red">整型数据类型</font><br>对于有符号数据类型，它们的取值范围不是对称的：负数的范围比正数的范围大1。</p>
<p>C和C++都支持有符号（默认）和无符号数。Java只支持有符号数。</p>
<p><font size="4" color="red">无符号数的编码</font><br>无符号数编码定义如下(B2U是Binary to Unsigned的缩写)：<br>对向量$\vec x=[x_{\omega-1}, x_{\omega-2}, …, x_0]$：<br>$$<br>B2U_{\omega}(\vec x) \doteq \sum_{i=0}^{\omega-1} x_i 2^i<br>$$<br>也就是说无符号数编码其实就是每个二进制位对应的二次幂的加和。</p>
<p><font size="4" color="red">补码编码</font><br>最常见的有符号数的计算机表示方式是补码形式。有符号数补码编码的定义如下（B2T是Binary to Two’s-complement的缩写）：<br>对向量$\vec x=[x_{\omega-1}, x_{\omega-2}, …, x_0]$：<br>$$B2T_{\omega}(\vec x) \doteq -x_{\omega-1}2^{\omega-1}+\sum_{i=0}^{\omega-2}x_i2^i $$<br>也就是说补码编码实际上是最高位（符号位）的二次幂的负数，加上其余位的二次幂的和。如下：<br>$$B2T_4([1011])=-1 \cdot 2^3+ 0 \cdot 2^2+1\cdot2^1+1\cdot2^0=-8+0+2+1=-5$$<br>从无符号数编码和补码编码的定义上我们可以很容易得知，对于16位的编码，最小的无符号数$UMin_{\omega}$=0x0000=0，最大的无符号数$UMax_{\omega}$=0xFFFF=65535，最小的补码$TMin_{\omega}$=0x8000=-32768，最大的补码$TMax_{\omega}$=0x7FFF=32767。而且-1的补码编码是0xFFFF，0的补码编码是0x0000。</p>
<p>也可以看到补码编码下负数的表示范围总比正数的表示范围大1，之所以会有这样的不对称性，是因为一半的位模式（符号位设置为1的数）表示负数，一般的位模式（符号位设置为0的数）表示<strong>非</strong>负数，然后0恰好是非负数，当然就导致补码编码能表示的正数比负数少了一个。</p>
<p>有符号数还有其他两种表示方法：反码和原码。<br>反码编码(Ones’ Complement)定义如下：<br>$$B2O_{\omega}(\vec x) \doteq -x_{\omega-1}(2^{\omega-1}-1)+\sum_{i=0}^{\omega-2}x_i2^i$$<br>可以看到除了符号位的权是$-(2^{\omega-1}-1)$而不是$-2^{\omega-1}$以外，反码和补码的定义几乎是一样的。</p>
<p>原码编码(Sign-Magnitude)定义如下：<br>$$B2S_{\omega}(\vec x) \doteq (-1)^{x_{\omega-1}}\cdot(\sum_{i=0}^{\omega-2}x_i2^i)$$<br>可以看到原码实际上是除了符号位以外的其余位的二次幂的加和，再乘上符号位（符号位是0就乘1，符号位是1就乘-1）。</p>
<p>这两种表示方法都一个奇怪的数学，那就是对于数字0有两种不同的编码方式，它们都把[00…0]都解释为+0；-0在原码中是[10…0]，在反码中是[11…1]。虽然过去生成过基于反码表示的机器，但是几乎所有的现代机器都使用补码。</p>
<p>C语言标准并没有要求要用补码形式来表示有符号整数，但是几乎所有的机器都是这么做的。不过Java标准明确要求用补码来表示有符号整数。</p>
<p><font size="4" color="red">有符号数和无符号数之间的转换</font><br>强制类型转换时，数的底层位模式是不会变的，变的只是解释这些位的方式。比如0xFF在被解释为有符号数，按照补码编码它的值就是-1，但是按照无符号数编码它的值就是255：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">char</span> N1 <span class="token operator">=</span> <span class="token number">0xFF</span><span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> N1<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">unsigned</span> <span class="token keyword">char</span> N2 <span class="token operator">=</span> <span class="token number">0xFF</span><span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> N2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">unsigned</span> <span class="token keyword">char</span> N3 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token punctuation">)</span>N1<span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> N3<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>输出如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token operator">-</span><span class="token number">1</span> <span class="token number">255</span> <span class="token number">255</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>从上面无符号数编码和补码编码的定义中，我们可以很容易看出当符号位为-1时：$B2U_{\omega}(\vec x)-B2T_{\omega}(\vec x)=2*2^{\omega-1}=2^{\omega}$，当然符号位为0时，这个差值为0。所以补码到无符号数的转换可以定义为如下：<br>对满足$TMin_{\omega}\le x \le TMax_{\omega}$的$x$有：<br>$$<br>T2U_{\omega}(x)=<br>\begin{cases}<br>x+2^{\omega}, &amp; x&lt;0 \\<br>x, &amp; x \ge 0<br>\end{cases}<br>$$<br>再通俗解释一下，如果是4位长度的编码，从补码变为无符号数，最高有效位的权重从-8变为+8。因此，补码表示的负数如果看出无符号数，值会增加16。所以，补码的-5被强制转换为无符号数以后变成11，-1被变成15。</p>
<p>从无符号数变成补码当然就是反过来了，比如对于8位长度的编码，当无符号数处在补码能够表示的非负数范围0~127时，转换后的补码值不变；但是当无符号数处在这个范围之外时，即128~255的范围，转换后的补码值就是将该数减去$2^8=256$。所以，无符号数到补码的转换可以定义为如下：<br>$$<br>U2T_{\omega}(u)=<br>\begin{cases}<br>u, &amp; u \le TMax_{\omega} \\<br>u-2^{\omega}, &amp; u &gt; TMax_{\omega}<br>\end{cases}<br>$$</p>
<p><font size="4" color="red">C语言中的有符号数与无符号数</font><br>尽管C语言标准没有指定有符号数要采用某种表示，但是几乎所有的机器都使用补码。通常，大多数数字都默认为是有符号的。例如当声明一个像12345或者0x1A2B这样的常量时，这个值就被认为是有符号的。要创建一个无符号常量，必须加上后缀字符‘U’或者‘u’，例如12345U或者0x1A2Bu。</p>
<p>当执行一个运算时，如果它的一个运算数是有符号的而另一个是无符号的，那么C语言会隐式地将有符号参数强制类型转换为无符号数，并假设这两个数都是非负的，来执行这个运算。例如下面的代码：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">unsigned</span> <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&lt;</span> x<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Little"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Greater"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>输出的并不是我们通常想要的Little，二是Greater。这是因为在进行小于运算时，由于x是无符号数，所以有符号数-1会先被转换成无符号数4294967295U，所以实际上比较的是4294967295U&lt;0U，当然输出的就是Greater了。</p>
<p><font size="4" color="red">扩展一个数字的位表示</font><br>要将一个无符号数转换为一个更大的数据类型，我们只要简单地在二进制位表示的开头添加0，这种运算被称为零扩展（zero extension）。要讲一个补码数字转换为一个更大的数据类型，可以执行一个符号扩展（sign extension），在二进制位表示的开头添加符号位。比如把0101扩展为8位变成00000101，把1101扩展为8位变成11111101。可以很简单地证明符号扩展以后的值和原来的值相等（即1101和11111101表示的是同一个数值）：<br>对向量$\vec x=[1,x_{\omega-2},x_{\omega-3},…,x_0]$，把它从$\omega$位扩展为$\omega+k$位，变成$ \vec {x^,}=[1,…,1,1,x_{\omega-2},x_{\omega-3,…,x_0}]$，$\vec{x^,}$是在$\vec{x}$前面扩展了$k$个1。证明如下：<br>$$<br>\begin{align}<br>B2T_{\omega+k}(\vec{x^,})&amp;=(-2^{\omega+k}*1+2^{\omega+k-1}*1+…+2^{\omega}*1+2^{\omega-1}*1)+(2^{\omega-2}*x_{\omega-2}+…+2^0*x_0)\\<br>&amp;=-2^{\omega-1}*1+2^{\omega-2}*x_{\omega-2}+…+2^0*x_0\\<br>&amp;=B2T_{\omega}(\vec x)<br>\end{align}<br>$$<br>其实道理很简单，就是[111]和[111111111]其实都表示的是-1的意思。</p>
<p>当把short转换成unsigned（unsigned就是unsigned int）时，我们先要改变大小（从2字节扩展到4字节），之后再完成从有符号到无符号的转换。如下程序：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">short</span> sx <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">12345</span><span class="token punctuation">;</span>
<span class="token keyword">unsigned</span> uy <span class="token operator">=</span> sx<span class="token punctuation">;</span>
<span class="token function">showBytes</span><span class="token punctuation">(</span><span class="token punctuation">(</span>byte_pointer<span class="token punctuation">)</span><span class="token operator">&amp;</span>uy<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>程序在本机（小端法机器）输出如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">c7 cf ff ff
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>输出结果也证明了short到unsigned的转换是先扩展大小，再从有符号转变为无符号数。如果是先从有符号转变为无符号数，uy会先变成无符号数0xcfc7，然后把该无符号数扩展为4字节0x0000cfc7；如果是先把有符号数扩展4字节，uy会先变0xffffcfc7，然后把该有符号数转换从成无符号数0xffffcfc7。</p>
<p><font size="4" color="red">截断数字</font><br>截断无符号数：<br>令$\vec x$等于位向量$\vec x=[x_{\omega-1}, x_{\omega-2}, …, x_0]$，而$\vec {x^,}$是将其截断为$k$位的结果：$\vec x=[x_{k-1}, x_{k-2}, …, x_0]$。令$x=B2U_{\omega}(\vec x)$，$x^,=B2U_{k}(\vec {x^,})$，则$x^,=x\;mod\;2^k$。该原理背后的直觉就是：截去的部分变为0，就好像是对其取模$2^k$，前面那些位在该取模下结果都为0。</p>
<p>截断补码数值：<br>令$\vec x$等于位向量$\vec x=[x_{\omega-1}, x_{\omega-2}, …, x_0]$，而$\vec {x^,}$是将其截断为$k$位的结果：$\vec x=[x_{k-1}, x_{k-2}, …, x_0]$。令$x=B2U_{\omega}(\vec x)$，$x^,=B2T_{k}(\vec {x^,})$，则$x^,=U2T_k(x\;mod\;2^k)$。该原理背后的直觉就是：和无符号数一样，在位级操作上把前k位变为0（把有符号当作无符号数来截断），然后再把截断后的二进制数解释为有符号补码数（相当于把无符号数转换为有符号补码数）。</p>
<p><font size="4" color="red">关于有符号数与无符号数的建议</font><br>先看如下代码：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">float</span> <span class="token function">sumElements</span><span class="token punctuation">(</span><span class="token keyword">float</span> vArray<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">unsigned</span> vLength<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">float</span> Result<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> vLength <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
        Result <span class="token operator">+</span><span class="token operator">=</span> vArray<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> Result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当参数vLength等于0时，运行这段代码应该返回0.0。但是实际上，运行时会遇到一个内存错误（内存冲突，无法访问的地址）。这是因为0-1的结果是一个无符号数$UMax$，所以在i递增时，代码将会试图访问数组vArray以外的非法元素。解决方案是换成<code>&lt;vLength</code>，或者将参数vLength声明为有符号数。<br>再看下面的代码：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">strLonger</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>vStr1<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>vStr2<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">strlen</span><span class="token punctuation">(</span>vStr1<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">strlen</span><span class="token punctuation">(</span>vStr2<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>由于strlen函数的返回值是无符号size_t类型，所以当字符串vStr1的长度小于字符串vStr2的长度时，由于是无符号数运算，所以函数最终返回的不是0，而是1，出现错误结果。解决方案是改成<code>return strlen(vStr1) &gt; strlen(vStr2);</code>。</p>
<p>避免这类错误的一种方法就是绝不使用无符号数。实际上，除了C以外很少有语言支持无符号整数。因为这些语言的设计者认为无符号数带来的麻烦比益处多得多。比如Java只支持有符号整数，并且要求以补码运算来实现，正常的右移运算符&gt;&gt;被定义为执行算术右移，特殊的运算符&gt;&gt;&gt;被定义为逻辑右移。</p>
<p><font size="5" color="orange">整数运算</font></p>
<hr>
<p>有时我们会发现，两个整数相加会得出一个负数，而比较表达式<code>x&lt;y</code>和比较表达式<code>x-y&lt;0</code>会产生不同的结果。这些都是由于计算机运算的有限性造成的（即一定字长的编码表示的数的范围有限）。</p>
<p><font size="4" color="red">无符号加法</font><br>无符号数加法：<br>对满足$0\le x,y&lt;2^{\omega}$的$x$和$y$有：<br>$$<br>x+^u_{\omega}y=<br>\begin{cases}<br>x+y, &amp;x+y&lt;2^{\omega} &amp;正常 \\<br>x+y-2^{\omega}, &amp;2^{\omega}\le x+y&lt;2^{\omega+1} &amp;溢出<br>\end{cases}<br>$$<br>公式很好理解，就是溢出时，把溢出的那一位1给截掉。</p>
<p>说一个算术运算溢出，是指完整的整数结果不能放到数据类型的字长限制中去。</p>
<p>我们检测无符号数加法中的溢出，可以判断加法结果是否小于任何一个加数：<br>对在范围$0\le x,y\le UMax_{\omega}$中的$x$和$y$，令$s \doteq x+^u_{\omega}y$。则对计算$s$，当且仅当$s&lt;x$（或者等价地$s&lt;y$）时，发生了溢出。<br>对应程序如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">uAddOK</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> x<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> y<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">unsigned</span> sum <span class="token operator">=</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span>
    <span class="token keyword">return</span> sum <span class="token operator">></span> x <span class="token operator">&amp;&amp;</span> sum <span class="token operator">></span> y<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>无符号数求反：<br>对满足$0 \le x&lt;2^{\omega}$的任意$x$，其$\omega$位的无符号逆元$-^u_{\omega}x$由下式给出：<br>$$<br>-^u_{\omega}x=<br>\begin{cases}<br>x, &amp; x = 0\\<br>2^{\omega}-x, &amp; y=0<br>\end{cases}<br>$$<br>公式的原理很简单就不细说了。</p>
<p><font size="4" color="red">补码加法</font><br>补码加法：<br>对满足$-2^{\omega-1}\le x，y\le 2^{\omega-1}-1$的整数$x$和$y$有：</p>

            </div>

            <!-- Post Comments -->
            
    <!-- 使用 DISQUS_CLICK -->
<div id="disqus-comment">
    <div id="disqus_thread"></div>

<!-- add animation -->
<style>
	.disqus_click_btn {
            line-height: 30px;
            margin: 0;
            min-width: 50px;
            padding: 0 14px;
            display: inline-block;
            font-family: "Roboto", "Helvetica", "Arial", sans-serif;
            font-size: 14px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0;
            overflow: hidden;
            will-change: box-shadow;
            transition: box-shadow .2s cubic-bezier(.4, 0, 1, 1), background-color .2s cubic-bezier(.4, 0, .2, 1), color .2s cubic-bezier(.4, 0, .2, 1);
            outline: 0;
            cursor: pointer;
            text-decoration: none;
            text-align: center;
            vertical-align: middle;
            border: 0;
            background: rgba(158, 158, 158, .2);
            box-shadow: 0 2px 2px 0 rgba(0, 0, 0, .14), 0 3px 1px -2px rgba(0, 0, 0, .2), 0 1px 5px 0 rgba(0, 0, 0, .12);
            color: #fff;
            background-color: #7EC0EE;
            text-shadow: 0
        }
</style>
	
<div class="btn_click_load" id="disqus_bt"> 
    <button class="disqus_click_btn">点击查看评论</button>
</div>

<!--
<script type="text/javascript">
$('.btn_click_load').click(function() {
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'http-miccall-tech'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    document.getElementById('disqus_bt').style.display = "none";
});
</script>
-->
<script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://yoursite.com/2018/06/20/深入理解计算机系统第二章信息的表示和处理/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = 'http://yoursite.com/2018/06/20/深入理解计算机系统第二章信息的表示和处理/'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
</script>

<script type="text/javascript">
    $('.btn_click_load').click(function() {  //click to load comments
        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document;
            var s = d.createElement('script');
            s.src = '//http-miccall-tech.disqus.com/embed.js';
            s.setAttribute('data-timestamp', + new Date());
            (d.head || d.body).appendChild(s);
        })();
        $('.btn_click_load').css('display','none');
    });
</script>
</div>
<style>
    #disqus-comment{
        background-color: #eee;
        padding: 2pc;
    }
</style>


        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
                <li>Design: <a href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
            </ul>
            
            	<span id="busuanzi_container_site_pv">2018总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			
        </div>
    </div>
</body>



 	
</html>
