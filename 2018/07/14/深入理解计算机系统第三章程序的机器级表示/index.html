<!DOCTYPE HTML>
<html>

<head>
	<link rel="bookmark"  type="image/x-icon"  href="/img/logo_miccall.png"/>
	 <link rel="shortcut icon" href="/img/logo_miccall.png">
	
			
    <title>
    Elays'Blog
    </title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="/css/mic_main.css" />
    <link rel="stylesheet" href="/css/dropdownMenu.css" />
    
    	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css" />
    </noscript>

	<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');
			    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<link rel="stylesheet" href="/css/prism-dark.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>
    
		
<!-- Layouts -->


<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<!--<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">-->
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/latest.js?config=TeX-MML-AM_CHTML" async>
</script>

<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_undefined.css" />
<link rel="stylesheet" href="/css/typo.css" />
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">MICCALL</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special" >
            <ul class="menu links" >
			<!-- Homepage  主页  --> 
			<li >
	            <a href="/" rel="nofollow">主页</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">分类</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="/categories/Boost/">Boost</a></li><li><a class="category-link" href="/categories/C-语法/">C#语法</a></li><li><a class="category-link" href="/categories/C/">C++</a></li><li><a class="category-link" href="/categories/C语言/">C语言</a></li><li><a class="category-link" href="/categories/OpenGL/">OpenGL</a></li><li><a class="category-link" href="/categories/c/">c++</a></li><li><a class="category-link" href="/categories/全局光照/">全局光照</a></li><li><a class="category-link" href="/categories/博客配置/">博客配置</a></li><li><a class="category-link" href="/categories/并行计算/">并行计算</a></li><li><a class="category-link" href="/categories/操作系统/">操作系统</a></li><li><a class="category-link" href="/categories/数据结构/">数据结构</a></li><li><a class="category-link" href="/categories/毕设/">毕设</a></li><li><a class="category-link" href="/categories/游戏开发/">游戏开发</a></li><li><a class="category-link" href="/categories/游戏设计模式/">游戏设计模式</a></li><li><a class="category-link" href="/categories/计算机图形学/">计算机图形学</a></li><li><a class="category-link" href="/categories/计算机系统/">计算机系统</a></li><li><a class="category-link" href="/categories/设计模式/">设计模式</a></li><li><a class="category-link" href="/categories/调试错误集锦/">调试错误集锦</a>
	                    </ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/gallery/" title="图库">
		                图库
		            </a>
		        </li>
		        
		        <li>
		            <a href="/tag/" title="搜索">
		                搜索
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
		            
		                <li><a href="https://github.com/miccall" class="icon fa-github"><span class="label">GitHub</span></a></li>
		            
		            
		            
		            
			</ul>
</nav>

        <div id="main" >
            <div class ="post_page_title_img" style="height: 25rem;background-image: url(http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC3%E7%AB%A0_BG.jpg);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;" >
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2 >深入理解计算机系统第三章 程序的机器级表示</h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
				<div id="toc" class="toc-article">
					<strong class="toc-title">文章目录</strong>
					
				</div>
                <p>为何要了解程序的机器级表示：<br>试图最大化一段关键性能的程序员，通常会尝试源代码的各种形式，每次编译并检查产生的汇编代码，从而了解程序将要运行的效率如何。此外，也有些时候。高级语言提供的抽象层会隐藏我们想要了解的程序的运行时行为，而这些信息在机器代码级是可见的（比如用线程包写并发程序时，了解不同的线程是如何共享程序数据或保持数据私有的，以及准确知道如何在哪里访问共享数据，都是很重要的；再比如要了解一些程序漏洞是如何出现的，以及如何防御它们，也需要具备程序机器级表示的知识）。</p>
<p><font size="5" color="orange">历史观点</font></p>
<hr>
<p>Intel处理器系列俗称x86。</p>
<p>每个后继处理器的设计都是向后兼容的，即较早版本上编译的代码可以在较新的处理器上运行。</p>
<p><font size="5" color="orange">程序编码</font></p>
<hr>
<p><font size="4" color="red">机器级代码</font><br>机器代码只是简单地将内存看成一个很大的、按字节寻址的数组。</p>
<p>操作系统负责管理虚拟地址空间，将虚拟地址翻译成实际处理器内存中的物理地址。</p>
<p><font size="4" color="red">代码示例</font><br>反汇编器只是基于机器代码文件中的字节序列来确定汇编代码。它不需要访问该程序的源代码或汇编代码。比如反汇编下面左边的二进制代码，会得到右边的汇编代码：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//Disassembly of function multstore binary file prog</span>
<span class="token number">0000000000400540</span> <span class="token operator">&lt;</span> multstore <span class="token operator">></span> <span class="token operator">:</span>
  <span class="token number">400500</span> <span class="token operator">:</span> <span class="token number">53</span>                        <span class="token comment" spellcheck="true">//push     %rbx</span>
      <span class="token number">400541</span> <span class="token operator">:</span> <span class="token number">48</span> <span class="token number">89</span> d3                <span class="token comment" spellcheck="true">//mov     %rdx,%rbx</span>
      <span class="token number">400544</span> <span class="token operator">:</span> e8 <span class="token number">42</span> <span class="token number">00</span> <span class="token number">00</span> <span class="token number">00</span>        <span class="token comment" spellcheck="true">//callq  40058b &lt;mult2></span>
      <span class="token number">400549</span> <span class="token operator">:</span> <span class="token number">48</span> <span class="token number">89</span> <span class="token number">03</span>                <span class="token comment" spellcheck="true">//mov    %rax,(%rbx)</span>
      40054c <span class="token operator">:</span> 5b                    <span class="token comment" spellcheck="true">//pop    %rbx</span>
      40054d <span class="token operator">:</span> c3                    <span class="token comment" spellcheck="true">//retq</span>
      40054e <span class="token operator">:</span> <span class="token number">90</span>                    <span class="token comment" spellcheck="true">//nop</span>
      <span class="token number">40054f</span> <span class="token operator">:</span> <span class="token number">90</span>                    <span class="token comment" spellcheck="true">//nop</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>二进制代码是由下面的代码编译得到的：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">long</span> <span class="token function">mult2</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">,</span> <span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">multstore</span><span class="token punctuation">(</span><span class="token keyword">long</span> x<span class="token punctuation">,</span> <span class="token keyword">long</span> y<span class="token punctuation">,</span> <span class="token keyword">long</span> <span class="token operator">*</span>dest<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">long</span> t <span class="token operator">=</span> <span class="token function">mult2</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">*</span>dest <span class="token operator">=</span> t<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>二进制和汇编代码中插入空操作nop指令是为了使函数代码变为16字节，使得就存储器系统性能而言，能更好地放置下一个代码块。</p>
<p><font size="4" color="red">关于格式的注解</font><br>上面我们表述汇编代码用的是ATT格式，这是GCC、OBJDUMP和其他一些我们使用的工具的默认格式。其他一些编程工具，包括Microsoft的工具，以及来自Intel的文档，其汇编代码都是Intel格式的。<br>Intel和ATT格式在如下方面有所不同：</p>
<ul>
<li>Intel代码省略了指示大小的后缀。我们看到指令push和mov，而不是pushq和movq。</li>
<li>Intel代码省略了寄存器名字前面的‘%’符号，用的是rbx，而不是%rbx。</li>
<li>Intel代码用不同的方式来描述内存中的位置，例如是‘QWORD PTR[rbx]’而不是‘(%rbx)’。</li>
<li>在带有多个操作数的指令情况下，列出操作数的顺序相反。</li>
</ul>
<p><font size="5" color="orange">数据格式</font></p>
<hr>
<p>通常用术语“字”表示16位数据类型，用“双字”表示32位，用“四字”表示64位。</p>
<p><font size="5" color="orange">访问信息</font></p>
<hr>
<p>一个x86-64的中央处理单元（CPU）包含一组16个别存储64位值的<strong>通用目的寄存器</strong>。这些寄存器用来存储整数数据和指针。如下图所示：<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC3%E7%AB%A0_1_2.png" alt=""><br>每个寄存器是64位的，但是在使用其中不同位数时会有不同的名称，比如使用寄存器%rax的低8位时叫做%al，使用低16位时叫做%ax，使用32位时叫做%eax，使用64位时才叫做%rax（这些名字是由于指令集的演化历史造成的，%ax等对应早期8086处理器的16位寄存器，%eax等对应IA32架构的32位寄存器，%rax等对应x86-64的64位寄存器）。</p>
<p><font size="4" color="red">操作数指示符</font><br>大多数指令有一个或多个操作数（operand），指示出执行一个操作中要使用的源数据值，以及放置结果的目的位置。源数据值可以以常数形式给出、或者从寄存器中读出、或者从内存中读出，而结果可以存放在寄存器或内存中。因此操作数可以被分为三种类型：</p>
<ul>
<li>立即数类型（immediate）：<br>也就是常数值。在ATT格式中形如：\$4、\$0x1F。</li>
<li>寄存器类型（register）：<br>用寄存器里存储的值来作操作数。形如：%rax。</li>
<li>内存引用（memory）：<br>以某个内存地址里存放的值作为操作数。形如：(%rax)等等。</li>
</ul>
<p>得到操作数具体数值的过程，称为寻址模式。大体上分为立即数寻址、寄存器寻址和内存寻址，如下表所示：<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC3%E7%AB%A0_2_2.png" alt=""><br>比如最常用的$Imm(r_b,r_i,s)$形式，它由4个部分组成：一个立即数偏移$Imm$，一个基址寄存器$r_b$，一个变址寄存器$r_i$和一个比例因子$s$，它表示的有效地址是：$Imm+R[r_b]+R[R_i]\cdot s$，其中$R[r_b]$表示寄存器$r_b$里存储的值。然后硬件会去该地址处取出操作数的值。</p>
<p><font size="4" color="red">数据传送指令</font><br>下表是最简单形式的数据传送指令：movb、movw、movl和movq，它们都只是把数据从源位置复制到目的位置，不做任何变化，不同的只是操作的数据大小不同而已。<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC3%E7%AB%A0_3.png" alt=""><br>x86-64有一条限制：数据传送指令的两个操作数不能都指向内存位置。将一个值从一个内存位置复制到另一个内存位置需要两条指令：第一条指令将源值加载到寄存器中，第二条将该寄存器值写入目的位置。</p>
<p>在将较小的源值复制到较大的目的时，通常要扩展数据大小。这时会用到下面两个表中的数据传送指令：<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC3%E7%AB%A0_4.png" alt=""><br>其中cltq指令没有操作数：它总是以寄存器%eax作为源，%rax作为符号扩展结果的目的。它的效果与指令<code>movslq %eax,%rax</code>完全一致，不过编码更紧凑。</p>
<p><font size="4" color="red">数据传送示例</font><br><img src="http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC3%E7%AB%A0_4_2.png" alt=""><br>从这段汇编代码我们可以看到：</p>
<ul>
<li>C语言中所谓的“指针”其实就是地址。间接引用指针就是将该指针放在一个寄存器中，然后在内存引用中使用这个寄存器。</li>
<li>向x这样的局部变量通常是保存在寄存器中，而不是内存中。访问寄存器比访问内存要快得多。</li>
</ul>
<p><font size="4" color="red">压入和弹出栈数据</font><br>还有两个数据传送操作可以将数据压入程序栈中，以及从此程序栈中弹出数据，如下图所示：<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC3%E7%AB%A0_5.png" alt=""><br>需要注意的是：栈向下增长，也就是说。栈顶元素的地址是所有栈中元素地址中最低的（所以我们通常把栈倒着画，栈顶在图的底部，地址由下往上增大）。栈指针%rsp保存着栈顶元素的地址。</p>
<p>将一个四字值压入栈中，首先要将栈指针减8，然后将值写到新的栈顶地址。因此<code>push %rbp</code>的行为等价于下面两条指令：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">subq $<span class="token number">8</span><span class="token punctuation">,</span><span class="token operator">%</span>rsp            <span class="token comment" spellcheck="true">//Decrement stack pointer</span>
movq <span class="token operator">%</span>rbp<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token operator">%</span>rsp<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">//Store %rbp on stack</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>它们之间的区别是在机器代码中pushq指令编码为1个字节，而上面那两条指令一共需要8个字节。</p>
<p>弹出一个四字的操作包括从栈顶位置读出数据，然后将栈指针加8。因此，指令<code>popq %rax</code>等价于下面两条指令：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token function">movq</span> <span class="token punctuation">(</span><span class="token operator">%</span>rsp<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token operator">%</span>rax        <span class="token comment" spellcheck="true">//Read %rax from stack</span>
addq $<span class="token number">8</span><span class="token punctuation">,</span>rsp                <span class="token comment" spellcheck="true">//Increment stack pointer</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>因为栈和程序代码以及其他形式的程序数据都是放在同一内存中，所以程序可以用标准的内存寻址方法访问栈内的任意位置。例如，假设栈顶元素是四字，指令<code>movq 8(%rsp),%rdx</code>会将第二个四字从栈中复制到寄存器%rdx。</p>
<p><font size="5" color="orange">算术和逻辑操作</font></p>
<hr>
<p>下图是x86-64的一些整数和逻辑操作：<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC3%E7%AB%A0_6.png" alt=""></p>
<p><font size="4" color="red">加载有效地址</font><br>加载有效地址（load effective address）指令leaq实际上是movq指令的变形。它的指令形式是从内存读数据到寄存器，但实际上它根本就没有引用内存。它并不是从指定的位置读入数据，而是将有效<strong>地址</strong>（即源操作数S所在的地址）写入到目的操作数。该指令的目的操作数D必须是一个寄存器。</p>
<p>另外，它还可以简洁地描述普通的算术操作。例如，如果寄存器%rdx的值为x，那么指令<code>leaq 7(%rdx,%rdx,4), %rax</code>将设置寄存器%rax的值为<code>5x+7</code>。</p>
<p>比如如下C程序：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">long</span> <span class="token function">scale</span><span class="token punctuation">(</span><span class="token keyword">long</span> x<span class="token punctuation">,</span> <span class="token keyword">long</span> y<span class="token punctuation">,</span> <span class="token keyword">long</span> z<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">long</span> t <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token number">4</span> <span class="token operator">*</span> y <span class="token operator">+</span> <span class="token number">12</span> <span class="token operator">*</span> z<span class="token punctuation">;</span>
    <span class="token keyword">return</span> t<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>它被编译成如下汇编代码：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//long scale(long x, long y, long z)</span>
<span class="token comment" spellcheck="true">//x in %dri, y in %rsi, z in %rdx</span>
scale<span class="token operator">:</span>
  <span class="token function">leaq</span>    <span class="token punctuation">(</span><span class="token operator">%</span>rdi<span class="token punctuation">,</span> <span class="token operator">%</span>rsi<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">%</span>rax    <span class="token comment" spellcheck="true">//x + 4*y</span>
  <span class="token function">leaq</span>    <span class="token punctuation">(</span><span class="token operator">%</span>rdx<span class="token punctuation">,</span> <span class="token operator">%</span>rdx<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">%</span>rdx    <span class="token comment" spellcheck="true">//z + 2*z = 3*z</span>
  <span class="token function">leaq</span>    <span class="token punctuation">(</span><span class="token operator">%</span>rax<span class="token punctuation">,</span> <span class="token operator">%</span>rdx<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">%</span>rax    <span class="token comment" spellcheck="true">//(x + 4*y) + 4*(3*z) = x + 4*y + 12*z</span>
  ret
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>leaq指令能执行加法和有限形式的乘法，在编译如上简单的算术表达式时，是很有用处的。</p>
<p><font size="4" color="red">一元和二元操作</font><br>上面图中第二组是一元操作，只有一个操作数，既是源又是目的；图中第三组是二元操作，其中第二个操作数既是源又是目的。也就是说，指令<code>subq %rax,%rdx</code>是从%rdx中减去%rax。</p>
<p><font size="4" color="red">移位操作</font><br>上面图中第四组是移位操作。</p>
<p><font size="4" color="red">讨论</font><br>来看一个例子：<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC3%E7%AB%A0_6_2.png" alt=""></p>
<p><font size="4" color="red">特殊的算术操作</font><br>下图描述的是支持产生两个64位数字的全128位乘积以及整数除法的指令：<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC3%E7%AB%A0_7_2.png" alt=""><br>乘法指令有两种不同的形式：</p>
<ul>
<li>一种是前一张图中的IMUL指令类中的一种。它是一个双操作数乘法指令，从两个64位操作产生一个64位乘积。</li>
<li>一种是上图中的两条单操作数乘法指令。这两条指令用于计算两个64位的值的全128位乘积。它一个参数必须在寄存器%rax中给出，另一个参数作为指令的源操作数S给出，然后乘积存放在寄存器%rdx（高64位）和%rax（低64位）中。</li>
</ul>
<p>如下C程序说明了如何从两个无符号64位数字x和y生成128位的乘积：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;inttypes.h></span></span>

<span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> __int128 uint128_t<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//__int128由GCC支持</span>

<span class="token keyword">void</span> <span class="token function">store_uprod</span><span class="token punctuation">(</span>uint128_t <span class="token operator">*</span>dest<span class="token punctuation">,</span> uint64_t x<span class="token punctuation">,</span> uint64_t y<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token operator">*</span>dest <span class="token operator">=</span> x <span class="token operator">*</span> <span class="token punctuation">(</span>uint128_t<span class="token punctuation">)</span>y<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中，显式地把x和y声明为64位的数字（依赖于头文件inttypes.h中的定义），而__int128是GCC提供的128整数支持。这段C程序对应的汇编代码如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//void store_uprod(uint128_t *dest, uint64_t x, uint64_t y)</span>
<span class="token comment" spellcheck="true">//dest in %rdi, x in %rsi, y in %rdx</span>
store_uprod<span class="token operator">:</span>
  movq    <span class="token operator">%</span>rsi<span class="token punctuation">,</span> <span class="token operator">%</span>rax            <span class="token comment" spellcheck="true">//Copy x to multiplicand</span>
  mulq    <span class="token operator">%</span>rdx                <span class="token comment" spellcheck="true">//Multiply by y</span>
  movq    <span class="token operator">%</span>rax<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">%</span>rdi<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">//Store lower 8 bytes at dest</span>
  movq    <span class="token operator">%</span>rdx<span class="token punctuation">,</span> <span class="token function">8</span><span class="token punctuation">(</span><span class="token operator">%</span>rdi<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">//Store upper 8 bytes at dest+8</span>
  ret
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到，存储乘积需要两个movq指令：一个存储低8个字节，一个存储高8个字节（小端法机器）。</p>
<p>类似单操作数乘法指令，有符号除法指令idivl将寄存器%rdx（高64位）和%rax（低64位）中的128位数作为被除数，而除数作为指令的操作数给出。指令将商存储在寄存器%rax中，将余数存储在寄存器%rdx中。<br>因为在大多数除法应用中，被除数也常常是一个64位的值，而非128位。这时就需要把高64位%rdx中的值设为全0（无符号除法）或者%rax的符号位（有符号运算）。这个过程可以用指令cqto来完成，它不需要操作数，它会隐含地读出%rax的符号位，并将它复制到%rdx的所有位。<br>比如如下C程序，它计算了两个64位有符号数的商和余数：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">remdiv</span><span class="token punctuation">(</span><span class="token keyword">long</span> x<span class="token punctuation">,</span> <span class="token keyword">long</span> y<span class="token punctuation">,</span> <span class="token keyword">long</span> <span class="token operator">*</span>qp<span class="token punctuation">,</span> <span class="token keyword">long</span> <span class="token operator">*</span>rp<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">long</span> q <span class="token operator">=</span> x <span class="token operator">/</span> y<span class="token punctuation">;</span>
    <span class="token keyword">long</span> r <span class="token operator">=</span> x<span class="token operator">%</span>y<span class="token punctuation">;</span>
    <span class="token operator">*</span>qp <span class="token operator">=</span> q<span class="token punctuation">;</span>
    <span class="token operator">*</span>rp <span class="token operator">=</span> r<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对应的汇编代码如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//void remdiv(long x, long y, long *qp, long *rp)</span>
<span class="token comment" spellcheck="true">//x in %rdi, y in %rsi, qp in %rdx, rp in %rcx</span>
remdiv<span class="token operator">:</span>
  movq        <span class="token operator">%</span>rdx<span class="token punctuation">,</span> <span class="token operator">%</span>r8        <span class="token comment" spellcheck="true">//Copy qp</span>
  movq        <span class="token operator">%</span>rdi<span class="token punctuation">,</span> <span class="token operator">%</span>rax        <span class="token comment" spellcheck="true">//Move x to lower 8 bytes of dividend</span>
  cqto                        <span class="token comment" spellcheck="true">//Sign-extend to upper 8 bytes of dividend</span>
  idivq        <span class="token operator">%</span>rsi            <span class="token comment" spellcheck="true">//Divide by y</span>
  movq        <span class="token operator">%</span>rax<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">%</span>r8<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">//Store quotient at qp</span>
  movq        <span class="token operator">%</span>rdx<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">%</span>rcx<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//Store remainder at rp</span>
  ret
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面第一个movq会把寄存器%rdx中的内容复制到寄存器%r8中保存起来，原因是后面的除法操作会用到寄存器%rdx（高8位），所以需要先把%rdx中的原有内容备份一下，防止被覆盖丢失。</p>
<p><font size="5" color="orange">控制</font>、</p>
<hr>
<p>机器代码提供两种基本的低级机制来实现有条件的行为：测试数据值，然后根据测试的结果来改变控制流或数据流。</p>
<p><font size="4" color="red">条件码</font><br>除了整数寄存器，CPU还维护着一组单个位的条件码（condition code）寄存器，它们描述了最近的算术或逻辑操作的属性。可以检测这些寄存器来执行条件分支指令。最常用的条件码有：</p>
<ul>
<li>CF：进位标志。最近的操作使最高位产生了进位。可用来检查无符号操作的溢出。</li>
<li>ZF：零标志。最近的操作得出的结果为0。</li>
<li>SF：符号标志。最近的操作得到的结果为负数。</li>
<li>OF：溢出标志。最近的操作导致一个补码溢出：正溢出或负溢出。</li>
</ul>
<p>leaq指令不改变任何条件码，因为它是用来进行地址计算的。除此之外，其他的大多指令几乎都会设置条件码。还有两类指令，它们只设置条件码而不改变任何其他寄存器，如下图所示：<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC3%E7%AB%A0_8.png" alt=""><br>CMP指令根据两个操作数之差来设置条件码。除了只设置条件码而不更新目的寄存器之外，CMP指令与SUB指令的行为是一样的。TEST指令的行为和AND指令一样，除了它们只设置条件码而不改变目的寄存器的值。</p>
<p>典型的用法是，两个操作数是一样的（例如<code>testq %rax,%rax</code>用来检测%rax是负数，零，还是正数），或其中的一个操作数是一个掩码，用来指示哪些位应该被测试。</p>
<p><font size="4" color="red">访问条件码</font><br>有一类SET指令，可以根据条件码来改变字节内容，把该字节内容设置为0或者1。如下图所示：<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC3%E7%AB%A0_9.png" alt=""><br>这些SET指令的后缀e、ne等等不是表示大小，而是表示条件码的组合。它们的操作数D是低位单字节寄存器元素之一，或是一个字节的内存位置，指令会将这个字节设置成0或者1。</p>
<p>比如计算一个C语言表达式<code>a&lt;b</code>的典型指令序列如下（这里a和b都是long类型）：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//int comp(data_t a, data_t b)</span>
<span class="token comment" spellcheck="true">//a in %rdi, b in %rsi</span>
comp<span class="token operator">:</span>
  cmpq        <span class="token operator">%</span>rsi<span class="token punctuation">,</span> <span class="token operator">%</span>rdi        <span class="token comment" spellcheck="true">//Compare a:b，b在前a在后，ATT格式顺序相反</span>
  setl        <span class="token operator">%</span>al                <span class="token comment" spellcheck="true">//Set low-order byte of %eax to 0 or 1</span>
  movzbl    <span class="token operator">%</span>al<span class="token punctuation">,</span> <span class="token operator">%</span>eax        <span class="token comment" spellcheck="true">//Clear rest of %eax(and rest of rax)，因为movzbl会把%al零扩展以后再传送</span>
  ret
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><p>对于测试一个有符号比较<code>cmpq %rsi, %rdi</code>（其中%rdi中的值是有符号数a，%rsi中的值是有符号数b，其实也就是在比较a和b）：<br>首先如果ZF为1，则a=b。否则的话：当没有发生溢出时（即OF为0），如果SF为0，表示a&gt;b，如果SF为1，表示a<b；当发生溢出时（即of为1），如果sf为0（即溢出后结果为正，说明是负溢出），则说明a<b，如果sf为1（即溢出结果为负，说明是正溢出），则说明a>b。</b；当发生溢出时（即of为1），如果sf为0（即溢出后结果为正，说明是负溢出），则说明a<b，如果sf为1（即溢出结果为负，说明是正溢出），则说明a></p>
<p> 也就是说，我们可以通过ZF和SF^OF来判断有符号数的大小（异或结果是0则是a&gt;b，异或结果是1则是a&lt;b）。</p>
</li>
<li>对于测试一个无符号比较<code>cmpq %rsi, %rdi</code>（其中%rdi中的值是无符号数a，%rsi中的值是无符号数b，其实也就是在比较a和b）：<br>首先如果ZF为1，则a=b；否则，如果进位标志CF为1，说明cmpq操作在执行a-b时发生了溢出，使最高位发生了进位，则说明a<b，如果进位标志cf为0，则说明没有发生溢出，a>b。</b，如果进位标志cf为0，则说明没有发生溢出，a></li>
</ul>
<p><font size="4" color="red">跳转指令</font><br>跳转指令会改变指令的执行顺序。下图列举了不同的跳转指令：<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC3%E7%AB%A0_10.png" alt=""><br>jmp指令是无条件跳转。它可以是直接跳转，即跳转目标是作为指令的一部分编码的；也可以是间接跳转，即跳转目标是从寄存器或内存位置中读出的。汇编语言中，直接跳转是给出一个标号作为跳转目标的（如<code>jmp .L1</code>），而间接跳转的写法是‘*’后面跟一个操作数指示符（如<code>jmp *%rax</code>）。</p>
<p>图中所示的其他跳转指令都是有条件的：它们根据条件码的某种组合来跳转。需要注意的是，条件跳转只能是直接跳转，而不能是间接跳转。</p>
<p><font size="4" color="red">跳转指令的编码</font><br>在汇编代码中，跳转目标用符号标号书写。汇编器，以及后来的链接器，会产生跳转目标的适当编码。跳转指令有几种不同的编码，但是最常用都是PC相对的（PC-relative）。也就是，它们会将目标指令的地址与紧跟在<strong>跳转指令后面那条指令</strong>的地址的差作为编码。这些地址偏移量可以编码为1、2或4个字节。第二种编码方法是给出“绝对”地址，用4个字节直接指定目标。汇编器和链接器会选择适当的跳转目的编码。</p>
<p>例如下面的汇编代码是由源文件编译得到的：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">    movq    <span class="token operator">%</span>rdi<span class="token punctuation">,</span> <span class="token operator">%</span>rax
    jmp        <span class="token punctuation">.</span>L2
<span class="token punctuation">.</span>L3<span class="token operator">:</span>
    sarq    <span class="token operator">%</span>rax
<span class="token punctuation">.</span>L2 <span class="token operator">:</span>
    testq    <span class="token operator">%</span>rax<span class="token punctuation">,</span> <span class="token operator">%</span>rax
    jg<span class="token punctuation">.</span>L3
    rep<span class="token punctuation">;</span>ret
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>而下面的代码是它对应的二进制代码（.o格式）以及反汇编代码：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token number">0</span><span class="token operator">:</span>    <span class="token number">48</span> <span class="token number">89</span> f8            mov        <span class="token operator">%</span>rdi<span class="token punctuation">,</span><span class="token operator">%</span>rax
<span class="token number">3</span><span class="token operator">:</span>    eb <span class="token number">03</span>                jmp        <span class="token number">8</span><span class="token operator">&lt;</span>loop<span class="token operator">+</span><span class="token number">0x8</span><span class="token operator">></span>
<span class="token number">5</span><span class="token operator">:</span>    <span class="token number">48</span> d1 f8            sar        <span class="token operator">%</span>rax
<span class="token number">8</span><span class="token operator">:</span>    <span class="token number">48</span> <span class="token number">85</span> c0            test    <span class="token operator">%</span>rax<span class="token punctuation">,</span><span class="token operator">%</span>rax
b<span class="token operator">:</span>    <span class="token number">7f</span> f8                jg        <span class="token number">5</span><span class="token operator">&lt;</span>loop<span class="token operator">+</span><span class="token number">0x5</span><span class="token operator">></span>
d<span class="token operator">:</span>    f3 c3                repz<span class="token punctuation">;</span> retq
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到，在二进制代码中，第二行跳转指令指定的目标编码是0x03，在执行该跳转指令时程序计数器PC执行的指令地址是下一条指令的地址：0x5，所以跳转的目标地址实际上是PC的值加上编码值：0x03+0x05=0x08，test指令所在的地址处。类似的，对于二进制代码中第5行的跳转指令，目标编码是0xf8（十进制-8），再加上当前PC的值0xd，可以得到跳转目标地址为0x5，即指令sar所在的地址处。值得注意的就是，PC中保存的指令地址，是当前执行指令的下一条指令的地址。</p>
<p>而链接后的程序的反汇编代码如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">4004d0<span class="token operator">:</span>    <span class="token number">48</span> <span class="token number">89</span> f8            mov        <span class="token operator">%</span>rdi<span class="token punctuation">,</span><span class="token operator">%</span>rax
4004d3<span class="token operator">:</span>    eb <span class="token number">03</span>                jmp        4004d8<span class="token operator">&lt;</span>loop<span class="token operator">+</span><span class="token number">0x8</span><span class="token operator">></span>
4004d5<span class="token operator">:</span>    <span class="token number">48</span> d1 f8            sar        <span class="token operator">%</span>rax
4004d8<span class="token operator">:</span>    <span class="token number">48</span> <span class="token number">85</span> c0            test    <span class="token operator">%</span>rax<span class="token punctuation">,</span><span class="token operator">%</span>rax
4004db<span class="token operator">:</span>    <span class="token number">7f</span> f8                jg        4004d5<span class="token operator">&lt;</span>loop<span class="token operator">+</span><span class="token number">0x5</span><span class="token operator">></span>
4004dd<span class="token operator">:</span>    f3 c3                repz<span class="token punctuation">;</span> retq
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到跳转目标的编码并没有变，因为使用的是PC相对寻址，来对跳转目标进行编码，这种方式能够使指令编码很简洁（只需要2个字节），而且目标代码可以不做任何改变就移到内存中不同的位置。</p>
<p>上面的汇编代码以及反汇编代码中都有一个rep指令，它其实是一种空操作，之所以在ret指令之前加上rep指令，是为了防止跳转指令直接跳转到ret。因为根据AMD的说法，当ret指令通过跳转指令直接到达时，处理器不能正确预测ret指令的目的。</p>
<p><font size="4" color="red">用条件控制来实现条件分支</font><br>使用跳转指令就可以以条件控制的方式来实现if-else这样的条件分支了。如下代码示例：<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC3%E7%AB%A0_11_2.png" alt=""><br>其实就是在cmp比较之后，根据条件是否满足分别跳转至不同的指令地址处。它是实现条件操作的传统方法，也叫使用<strong>控制</strong>的条件转移。当条件满足时，程序沿着一条执行路径执行，而当条件不满足时，就走另一条路径。这种机制简单而通用，但是在现代处理器上，它可能非常低效。</p>
<p><font size="4" color="red">用条件传送来实现条件分支</font><br>还有另外一种实现条件操作的方式：使用<strong>数据</strong>的条件转移，也叫使用条件传送t。这种方法计算一个条件操作的两种结果，然后再根据条件是否满足从中选取一个。</p>
<p>比如下面代码示例：<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC3%E7%AB%A0_12_2.png" alt=""><br>可以看到在这种方式实现的汇编代码，它把条件的两种结果都算出来了，只是最后根据条件选择返回哪种结果而已。在汇编代码中，并不存在跳转指令，也就不存在条件分支。</p>
<p>现代处理器实际上是通过使用流水线（pipelining）技术来获得高性能（后续章节会有介绍）。要做到以流水线方式处理处理多条指令的各个阶段，就要求能够事先确定要执行的指令序列，这样才能保证流水线中充满了待执行的指令。当机器遇到条件跳转（也称为“分支”）时，只有当分支条件求值完成之后，才能决定分支往哪边走。处理器采用非常精密的<strong>分支预测逻辑</strong>来猜测每条指令是否会执行。只要它的猜测还比较可靠（现代微处理器设计试图达到90%以上的成功率），指令流水线中就会充满着指令。但是，如果错误预测一个跳转，就要求处理器丢掉它为该跳转指令后所有指令已做的工作，然后再开始用从中正确位置处起始的指令去填充流水线。所以，这样一个错误预测会招致很严重的惩罚，浪费大约15~30个始终周期，导致程序性能严重下降。</p>
<p>上面代码中由于不存在条件分支，所以会比前面的汇编代码运行更快。其中，cmovge是条件传送指令，它与jp等条件跳转指令不同，处理器无需预测测试的结果就可以执行条件传送。处理器只是读源值（可能是从内存中），检查条件码，然后要么更新目的寄存器，要么保持不变。</p>
<p>但是不是所有的条件表达式都可以用条件传送来编译。如果if和else的两个条件表达式中的任意一个可能产生错误条件或者副作用，就会导致非法的行为。比如下面这个C函数：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">long</span> <span class="token function">cread</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token operator">*</span>xp<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>xp <span class="token operator">?</span> <span class="token operator">*</span>xp <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果使用数据的条件转移，而不是使用控制的条件转移，来编译该函数，会得到如下汇编代码：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//long cread(long *xp)</span>
<span class="token comment" spellcheck="true">//Invalid implementation of function cread</span>
<span class="token comment" spellcheck="true">//xp in register %rdi</span>
cread<span class="token operator">:</span>
  <span class="token function">movq</span>        <span class="token punctuation">(</span><span class="token operator">%</span>rdi<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">%</span>rax    <span class="token comment" spellcheck="true">//v = *xp</span>
  testq        <span class="token operator">%</span>rdi<span class="token punctuation">,</span> <span class="token operator">%</span>rdi        <span class="token comment" spellcheck="true">//Test x</span>
  movl        $<span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">%</span>edx        <span class="token comment" spellcheck="true">//Set ve = 0 </span>
  cmove        <span class="token operator">%</span>rdx<span class="token punctuation">,</span> <span class="token operator">%</span>rax        <span class="token comment" spellcheck="true">//If x==0, v = ve</span>
  ret                        <span class="token comment" spellcheck="true">//return v</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>不过，这个实现是非法的，因为即使当测试为假时，movq指令对xp的间接引用还是发生了，导致一个间接引用空指针的错误。所以必须用分支代码来编译这段C代码。</p>
<p>而且，使用数据的条件转移（条件传送）也不总是会提高代码的效率。得看if和else两种情况下是否需要大量的计算，因为当相对应的条件不满足时，所做的大量计算就白费了。对GCC的实验表明，只有当两个表达式都很容易计算时（例如表达式分别都只是一条加法指令），它才会使用条件传送。而且经验表明，即使许多分支预测错误的开销关于超过更复杂的计算，GCC还是会使用条件控制转移。</p>
<p><font size="4" color="red">循环</font></p>
<ul>
<li><p>do-while循环：<br>do-while语句的通用形式如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">do</span> 
    body<span class="token operator">-</span>statement
<span class="token keyword">while</span> <span class="token punctuation">(</span>test<span class="token operator">-</span>expr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>这种通用形式可以被翻译为如下形式的goto代码：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">loop<span class="token operator">:</span>
    body <span class="token operator">-</span> statement
    t <span class="token operator">=</span> test <span class="token operator">-</span> expr<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">)</span>
        <span class="token keyword">goto</span> loop<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后按照这种形式的goto代码翻译成do-while循环的汇编代码。<br>比如如下求阶乘的程序示例：<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC3%E7%AB%A0_13.png" alt=""></p>
</li>
<li><p>while循环：<br>while语句的通用形式如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">  <span class="token keyword">while</span><span class="token punctuation">(</span>test<span class="token operator">-</span>expr<span class="token punctuation">)</span>
      body<span class="token operator">-</span>statement
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>它可以被翻译称为两种形式的goto代码。第一种是在do-while的goto代码的基础上变形，一开就直接goto跳转到条件测试部分（这种翻译方式也称跳转到中间）。如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">      <span class="token keyword">goto</span> test<span class="token punctuation">;</span>
  loop<span class="token operator">:</span>
      body<span class="token operator">-</span>statement
  test<span class="token operator">:</span>
      t <span class="token operator">=</span> test <span class="token operator">-</span> expr<span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">)</span>
          <span class="token keyword">goto</span> loop<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>第二种是把while变成do-while：首先用条件分支，如果初始条件不成立就跳过循环，把代码变换成do-while循环（这种方式也称guarded-do）：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">  t <span class="token operator">=</span> test<span class="token operator">-</span>expr<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>t<span class="token punctuation">)</span>
      <span class="token keyword">goto</span> done<span class="token punctuation">;</span>
  <span class="token keyword">do</span> 
      body<span class="token operator">-</span>statement
  <span class="token keyword">while</span> <span class="token punctuation">(</span>test<span class="token operator">-</span>expr<span class="token punctuation">)</span><span class="token punctuation">;</span>
  done<span class="token operator">:</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>  它俩分别对应的程序示例如下面两幅图所示：<br>  <img src="http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC3%E7%AB%A0_14.png" alt=""><br>  <img src="http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC3%E7%AB%A0_15.png" alt=""></p>
</li>
<li>for循环<br>for循环的通用形式如下：<pre class="line-numbers language-cpp"><code class="language-cpp">  <span class="token keyword">for</span><span class="token punctuation">(</span>init<span class="token operator">-</span>expr<span class="token punctuation">;</span> test<span class="token operator">-</span>expr<span class="token punctuation">;</span> update<span class="token operator">-</span>expr<span class="token punctuation">)</span>
      body<span class="token operator">-</span>statement
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
C语言标准有说明这个for循环和下面的while循环是等价的：<pre class="line-numbers language-cpp"><code class="language-cpp">  init<span class="token operator">-</span>expr<span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>test <span class="token operator">-</span> expr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      body<span class="token operator">-</span>statement
      update<span class="token operator">-</span>expr<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
从这里也可以看出测试条件不满足时，不再执行for循环的update-expr，而是直接退出。<br>那么也就可以用while循环的两种翻译方式来翻译for循环。其中用跳转到中间的方式翻译得到的汇编代码如下：<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC3%E7%AB%A0_16.png" alt=""></li>
</ul>
<p><font size="4" color="red">switch语句</font><br>switch语句有多重分支，在底层是采用跳转表来实现的（跳转表即case标号组成的数组）。switch语句、以及对应的goto代码和汇编代码示例如下图所示：<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC3%E7%AB%A0_17.png" alt=""><br>其中b)goto代码中的&amp;&amp;是创建一个指向标号所在代码位置的指针。在c)汇编代码中jmp指令的操作数有前缀‘*’，表明这是一个间接跳转，操作数指定一个内存位置。在d)汇编代码的跳转表中，.rodata是段的名字，.align 8表示8字节对齐。</p>
<p><font size="5" color="orange">过程</font></p>
<hr>
<p>假设过程P调用过程Q，Q执行后返回到P。这些动作包括下面一个或多个机制：</p>
<ul>
<li>传递控制：在进入过程Q的时候，程序计数器必须被设置为Q的代码的起始地址，然后在返回时，要把程序计数器设置为P中调用Q后面那条指令的地址。</li>
<li>传递数据：P必须能够向Q提供一个或多个参数，Q必须能够向P返回一个值。</li>
<li>分配和释放内存：在开始时，Q可能需要为局部变量分配空间，而在返回前，又必须释放这些存储空间。</li>
</ul>
<p><font size="4" color="red">运行时栈</font><br>C语言过程调用机制的一个关键特性在于使用了栈数据结构提供的后进先出的内存管理原则（大多数其他语言也是如此）。因为在调用过程开始时会分配内存空间，调用结束时会释放内存空间（即后进先出的内存分配策略）。</p>
<p>当x86-64过程需要的存储空间超出寄存器能够存放的大小时，就会在栈上分配空间，分配当前过程的这段栈空间就叫做该过程的栈帧。如下图所示：<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC3%E7%AB%A0_18.png" alt=""><br>当过程P调用过程Q时，会把返回地址压入栈中，指明当Q返回时，要从P程序的哪个位置继续执行。我们把这个返回地址当做P的栈帧的一部分，因为它存放的是与P相关的状态。Q的代码会扩展当前栈的边界，分配它的栈帧所需的空间。在这个空间中，它可以保存寄存器的值，分配局部变量空间，为它调用的过程设置参数。</p>
<p>大多数过程的栈帧都是定长的，在过程的开始就分配好了，但是有些过程需要变长的帧（比如在过程里动态分配栈内存空间）。</p>
<p>为了提高空间和时间效率，x86-64过程只分配自己所需要的栈帧部分，所以，上图中画出的某些栈帧部分可以省略。实际上，许多函数甚至根本不需要栈帧(比如当所有的局部变量都可以保存在寄存器中，而且该函数不会调用任何其他函数时，就可以没有栈帧）。</p>
<p><font size="4" color="red">转移控制</font><br>将控制从函数P转移到函数Q只需要简单地把程序计数器（PC）设置为Q的代码的起始位置，不过需要记录下从Q返回到P的代码位置。在x86-64中，使用指令<code>call Q</code>调用过程Q来记录的。该指令会把地址A压入栈中，并将PC设置为Q的起始地址。压入的地址A被称为返回地址，是紧跟在call指令后面的那条指令的地址。</p>
<p>也就是说call指令向栈帧中压入后续指令地址，再跳转至调用的过程的首地址；而ret指令会从栈中弹出那条后续指令地址，并跳转到此处执行。</p>
<p><font size="4" color="red">数据传送</font><br>x86-64中，大部分过程间的数据传送是通过寄存器实现的。当过程P调用过程Q时，P的代码必须首先把参数复制到适当的寄存器中。类似的，当Q返回到P时，P的代码可以访问寄存器%rax中的返回值。</p>
<p>x86-64中，可以通过寄存器最多传递6个整型参数（例如整数和指针），这点可以在前面的通用寄存器的图中看到只有6个寄存器可以拿来作传递参数用，而且可以看到这6个是按照特殊顺序来使用的，而使用的名字是根据参数的大小来确定的。</p>
<p>但是如果一个函数有大于6个整型参数，超出6个的部分就要通过栈来传递（即栈帧中的参数构造区）。比如如下代码示例：<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC3%E7%AB%A0_19.png" alt=""><br>其中第7个参数放置在栈帧里地址为8(%rsp)的位置上，第8个参数放置在栈帧里地址为16(%rsp)的位置上。其余6个参数都放在寄存器里。因为通过栈传递参数时，所有的数据大小都必须8字节对齐，所以该函数proc的栈帧结构如下图所示：<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC3%E7%AB%A0_20.png" alt=""></p>
<p><font size="4" color="red">栈上的局部存储</font><br>有时候局部数据必须存放在内存中，而不能存放在寄存器中，常见的情况包括：</p>
<ul>
<li>寄存器不足够存放所有的本地数据。</li>
<li>对一个局部变量使用地址运算符‘&amp;’，因此必须能够为它产生一个地址。</li>
<li>某些局部变量是数组或结构体，因此必须能够通过数组或结构引用被访问到。</li>
</ul>
<p>一般来说，过程通过减小栈指针在栈上分配空间（也就是栈帧那幅图中的局部变量区）。来看一个代码示例：<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC3%E7%AB%A0_21.png" alt=""><br>在汇编代码中，一开始栈指针就减掉了16，实际上这就是在栈上分配了16个字节，用来存放局部变量arg1和arg2。最后，该函数把栈指针加16，释放栈帧。</p>
<p>可以看到，运行时栈提供了一种简单的、在需要时分配、函数完成时释放局部存储的机制。</p>
<p><font size="4" color="red">寄存器中的局部存储空间</font><br>寄存器组是唯一被所有过程共享的资源。我们必须确保当一个过程（调用者）调用另一个过程（被调用者）时，被调用者不会覆盖调用者稍后会使用的寄存器值。</p>
<p>在前面同样寄存器的图中可以看到，寄存器%rbx、%rbp和%r12~%r15被划分为<strong>被调用者保存</strong>寄存器。当过程P调用过程Q时，Q必须保存这些寄存器的值，保证它们的值在Q返回到P时与Q被调用时是一样的。过程Q保存一个寄存器的值不变，妖门就是根本不去改变它，要么就是把原始值压入栈中（即栈帧那幅图中的被保存的寄存器的区域），改变寄存器的值，然后在返回前从栈中弹出旧值。</p>
<p>所有其他的寄存器，除了栈指针%rsp，都分类为<strong>调用者保存</strong>寄存器。比如如下代码示例：<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC3%E7%AB%A0_22.png" alt=""><br>为了防止在调用Q的过程中修改了寄存器%rdi和%rsi中保存的x和y的值，在代码一开始就将两个寄存器的内容压入栈中，中间可以随意使用这两个寄存器，结束时在从栈中弹出恢复两个寄存器的值。</p>
<p><font size="4" color="red">递归过程</font><br>递归调用其实跟普通调用，在机器代码级上没有什么区别。来看一个例子：<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC3%E7%AB%A0_23.png" alt=""></p>
<p><font size="5" color="orange">数组分配和访问</font></p>
<hr>
<p><font size="4" color="red">嵌套的数组</font><br>要访问一个数组其实就是计算好元素相对于数组起始地址的偏移量而已。比如可以用下面的代码将数组元素A[i][j]复制到寄存器%eax中：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//A in %rdi, i in %rsi, and j in %rdx</span>
<span class="token function">leaq</span> <span class="token punctuation">(</span><span class="token operator">%</span>rsi<span class="token punctuation">,</span> <span class="token operator">%</span>rsi<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">%</span>rax            <span class="token comment" spellcheck="true">//Compute 3i</span>
<span class="token function">leaq</span> <span class="token punctuation">(</span><span class="token operator">%</span>rdi<span class="token punctuation">,</span> <span class="token operator">%</span>rax<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">%</span>rax            <span class="token comment" spellcheck="true">//Compute A+12i</span>
<span class="token function">movl</span> <span class="token punctuation">(</span><span class="token operator">%</span>rax<span class="token punctuation">,</span> <span class="token operator">%</span>rdx<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">%</span>eax            <span class="token comment" spellcheck="true">//read form M[A+12i+4j]</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><font size="4" color="red">定长数组</font><br>C语言编译器能够优化定长多维数组上的操作代码（比如对于定长数组中元素的内存寻址优化）。比如声明如下整型数组：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">define</span> N 16</span>
<span class="token keyword">typedef</span> <span class="token keyword">int</span> fix_matrix<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>来看一个代码示例：<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC3%E7%AB%A0_24.png" alt=""><br>从b)优化的代码以及c)汇编代码中可以看到，编译器在寻址A[i][j]以及B[j][k]时，并没有做乘法，而是通过一些列的加法和移位算出&amp;A[i][0]等等基地址，然后再加上偏移量得到数组元素的地址。汇编代码中16、1024等常数都是由于定长N=16才产生的。</p>
<p><font size="4" color="red">边长数组</font><br>对于那些不能在编译时就能确定长度的数组，编译器就无法像定长那样都用加法和移位指定来算出基地址了。比如如下示例：<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC3%E7%AB%A0_25.png" alt=""><br>在这个变长数组的示例中，计算A[i]的地址就必须得用乘法指令来计算了，而无法在编译时通过移位和加法来代替，而且由于无法像定长数组一样高效计算B[N][k]的地址，所以就必须用一个寄存器来保存循环变量j的值，来实现循环条件。（这里变长数组和之前定长数组的代码风格不太一样，一个是用指针形式，一个使用数组形式，而且边长数组这里也是可以写成基地址加偏移量的形式的，类似<code>int *Arow = &amp;A[i][0]; ...;Arow++; Bptr+n;</code>）</p>
<p><font size="5" color="orange">异质的数据结构</font></p>
<hr>
<p><font size="4" color="red">结构</font><br>如下的结构体声明：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> SRec
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>
    <span class="token keyword">int</span> j<span class="token punctuation">;</span>
    <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>该结构体在内存中的排列如下：<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC3%E7%AB%A0_26.png" alt=""><br>好像是按照各自成员的大小串联起来的，这是因为它们刚好都各自符合对其规则（后文描述）。</p>
<p><font size="4" color="red">联合</font><br>什么时候用联合比较好？如果我们事先知道对一个数据结构中的两个不同字段的使用是互斥的，那么将这两个字段声明为联合的一部分，而不是结构的一部分，会减小分配空间的总量。</p>
<p>比如想实现一个二叉树的数据结构，每个叶子节点有两个double型的数据值，没有左右子节点，而每个内部节点有两个左右子节点的指针，但是没有数据。如果声明为结构体：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> SNode
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> SNode <span class="token operator">*</span>pLeftNode<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> SNode <span class="token operator">*</span>pRightNode<span class="token punctuation">;</span>
    <span class="token keyword">double</span> Data<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>那么每个节点都需要32个字节，无论是叶子节点还是内部节点都要浪费一般的字节。但是如果声明为联合：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">union</span> UNode
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">union</span> UNode <span class="token operator">*</span>pLeftNode<span class="token punctuation">;</span>
        <span class="token keyword">union</span> UNode <span class="token operator">*</span>pRightNode<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>Internal<span class="token punctuation">;</span>
    <span class="token keyword">double</span> Data<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>那么每个节点就只需要16个字节。</p>
<p>不过，如果这样编码，就没有办法来确定一个给定的节点到底是叶子结点还是内部节点。通常的方法是引入一个枚举类型，来标明这个节点的类型：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">enum</span> ENodeType
<span class="token punctuation">{</span>
    LEAF<span class="token punctuation">,</span>
    INTERNAL
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> SNode
<span class="token punctuation">{</span>
    ENodeType NodeType<span class="token punctuation">;</span>
    <span class="token keyword">union</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">struct</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">union</span> UNode <span class="token operator">*</span>pLeftNode<span class="token punctuation">;</span>
            <span class="token keyword">union</span> UNode <span class="token operator">*</span>pRightNode<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>Internal<span class="token punctuation">;</span>
        <span class="token keyword">double</span> Data<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>NodeInfo<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这样这个结构体就总共需要24个字节（因为NodeType和NodeInfo之间需要4个字节的填充来对齐）。</p>
<p>不过，这种使用联合的设计给代码造成的麻烦更多，带来的节省却是很小的。如果能省下很大的空间，这种设计才更加吸引人。</p>
<p>除此之外，联合还可以用来访问不同数据类型的位模式。例如，我们把double类型的数值强制转换为unsigned long类型 ：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">double</span> d <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span>
<span class="token keyword">unsigned</span> <span class="token keyword">long</span> u <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span>d<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>结果是u和d只在数值上有联系，u是d取整的结果，但是u和d的位级表示却是相差很大的（只有一小段子串匹配，匹配原因参见第二章）。那么如果我们想要强制转换后的数据在位模式上是一样的，怎么办？这时可以用联合来实现：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token function">double2bits</span><span class="token punctuation">(</span><span class="token keyword">double</span> d<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">union</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">double</span> d<span class="token punctuation">;</span>
        <span class="token keyword">unsigned</span> <span class="token keyword">long</span> u<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>temp<span class="token punctuation">;</span>
    temp<span class="token punctuation">.</span>d <span class="token operator">=</span> d<span class="token punctuation">;</span>
    <span class="token keyword">return</span> temp<span class="token punctuation">.</span>u<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个函数利用联合从一个double产生一个unsigned long类型的值。结果是输入的u和返回的d具有完全一样的位表示（不过u和d的数值就没有特别明显关系了）。</p>
<p>还可以用联合来将各种不同大小的数据类型结合到一起：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">unsigned</span> <span class="token function">uu2double</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> word0<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> word1<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">union</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">double</span> d<span class="token punctuation">;</span>
        <span class="token keyword">unsigned</span> u<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>temp<span class="token punctuation">;</span>
    temp<span class="token punctuation">.</span>u<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> word0<span class="token punctuation">;</span>
    temp<span class="token punctuation">.</span>u<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> word1<span class="token punctuation">;</span>
    <span class="token keyword">return</span> temp<span class="token punctuation">.</span>d<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>不过返回的d要注意字节顺序，在小端法机器上参数word0是d的低位4个字节，word1是d的高位4个字节。而在大端法机器上，刚好相反。</p>
<p><font size="4" color="red">数据对齐</font><br>许多计算机系统要求某种类型对象的地址必须是某个值K（通常是2、4或8）的倍数。这种<strong>对齐限制</strong>简化了形成处理器和内存系统之间接口的硬件设计。例如，假设一个处理器总是从内存取8个字节，则地址必须为8的倍数。如果我们能保证将所有的double类型数据的地址对齐成8的倍数，那么就可以用一个内存操作来读或者写值了。否则，我们可能需要执行两次内存访问，因为对象可能被分放在两个8字节内存块中。</p>
<p>无论数据是否对齐，x86-64硬件都能正常工作。不过，Intel还是建议要对齐数据以提高内存系统的性能。<strong>对齐原则是：任何K字节的基本对象的地址必须是K的倍数</strong>。</p>
<p>对于包含结构的代码，编译器可能需要在字段的分配中插入间隙，以保证每个结构元素都满足它的对齐要求。而结构本身对它的起始地址也有一些对齐要求。例如：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> S1
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>
    <span class="token keyword">char</span> c<span class="token punctuation">;</span>
    <span class="token keyword">int</span> j<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>假设编译器用最小的9字节来分配，如下图：<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC3%E7%AB%A0_27.png" alt=""><br>这样字段j的偏移量是5，就不满足4的倍数（因为j本身是4个字节大小）。所以，编译器在字段c和j之间插入3个字节的间隙：<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC3%E7%AB%A0_28.png" alt=""><br>这样j的偏移量是8，整个结构体的大小是12字节。</p>
<p>另外，结构体的末尾可能也需要一些字节填充。如下结构体：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> S2
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>
    <span class="token keyword">int</span> j<span class="token punctuation">;</span>
    <span class="token keyword">char</span> c<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>给这个结构体分配9个字节时，虽然i、j、c的偏移量都满足字节对齐要求，但是如果是下面这样的声明呢：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> S2 Data<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>那么从第二个结构体开始的i、j、c成员就不一定满足字节对齐了。所以编译器会在结构体的末尾填充3个字节：<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC3%E7%AB%A0_29.png" alt=""></p>
<p>对于大多数x86-64指令来说，保持数据对齐能够提高效率，但是它不会影响程序的行为。另一方面，如果数据没有对齐，某些型号的Intel和AMD处理器对于有些实现多媒体操作的SSE指令，就无法正确执行。这些指令对16字节数据块进行操作，在SSE单元和内存之间传送数据的指令要求内存地址必须是16的倍数。任何试图以不满足对齐要求的地址来访问内存都会导致异常，默认的行为是程序终止。</p>
<p><font size="5" color="orange">在机器级程序中将控制与数据结合起来</font></p>
<hr>
<p><font size="4" color="red">理解指针</font><br>因为leaq指令是设计用来计算内存引用的地址的，&amp;运算符的机器代码实现常常用这条指令来计算表达式的值。</p>
<p>将指针从一种类型强制转换成另一种类型，只改变它的类型，而不改变它的值。强制类型转换的一个效果是改变指针运算的伸缩。例如，如果p是一个char*类型的指针，它的值为p，那么表达式<code>(int*)p+7</code>计算为p+28，而<code>(int*)(p+7)</code>计算为p+7。</p>
<p>函数指针的值是该函数机器代码表示中第一条指令的地址。</p>
<p><font size="4" color="red">应用：使用GDB调试器</font><br>GNU的调试器GDB提供了许多有用的特性，支持机器级程序的运行时评估和分析。DDD是GDB的一个扩展，提供了图形用户界面。</p>
<p><font size="4" color="red">内存越界引用和缓冲区溢出</font><br>C对于数组引用不进行任何边界检查，而且局部变量和状态信息（例如保存的寄存器和返回地址）都存放在栈中。对越界的数组元素的写操作可能会破坏存储在栈中的状态信息。当程序使用这个被破坏的状态，试图重新加载寄存器或执行ret指令时，就会出现很严重的错误。</p>
<p>这样的缓冲区溢出的一个更加致命的使用就是让程序执行它本来不愿意执行的函数。这是一种最常见的通过计算机网络攻击系统安全的方法。通常，输入给程序一个字符串，这个字符串包含一些可执行代码的字节编码，称为攻击代码（exploit code），另外，还有一些字节会用一个指向攻击代码的指针覆盖返回地址。那么，执行ret指令的效果就是跳转到攻击代码。</p>
<p><font size="4" color="red">对抗缓冲区溢出攻击</font><br>这里介绍3种对抗缓冲区溢出攻击的方式：</p>
<ul>
<li><p>栈随机化：<br>栈随机化是栈的位置在程序每次运行时都有变化，这样攻击者就不容易知道攻击代码所放置的栈地址，难以用指向攻击代码的指针去覆盖栈帧中的返回地址。</p>
<p>实现的方式是：程序开始时，在栈上分配一段0~n字节之间的随机大小的空间，程序不使用这段空间，但是它会导致程序每次执行时后续的栈位置发生看变化。</p>
<p>在Linux系统中，栈随机化已经变成了标准行为。它是更大的一类技术中的一种，这类技术成为地址空间局部随机化（Address-Space Layout Randomization），或者简称ASLR。</p>
</li>
<li>栈破坏检测：<br>最近的GCC版本在产生的代码中加入了<strong>栈保护者</strong>（stack protector）机制，来检测缓冲区越界。其思想是在栈帧中任何局部缓冲区与栈状态之间存储一个特殊的金丝雀（canary）值。如下图所示：<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC3%E7%AB%A0_30.png" alt=""><br>这个金丝雀值，也称为哨兵值（guard value），是在程序每次运行时随机产生的，因此，关键字没有简答的方法能够知道它是什么。在恢复寄存器状态和从函数返回之前，程序检查这个金丝雀值是否被该函数的某个操作改变了。如果是的，那么程序异常中止。</li>
<li><p>限制可执行代码区域<br>最后一招是消除攻击者向系统中插入可执行代码的能力。其中一种方法是限制哪些内存区域能够存放可执行代码。许多系统允许控制三种访问形式：读（从内存读数据）、写（存储数据到内存）和执行（将内存的内容看作机器级代码）。</p>
<p>是否能够将执行代码限制在由编译器在创建原始程序时产生的那个部分中，取决于语言和操作系统。</p>
</li>
</ul>
<p><font size="4" color="red">支持变长栈帧</font><br>下面给出了一个包含变长数组的例子：<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC3%E7%AB%A0_31.png" alt=""><br>由于函数内声明了一个变长数组，所以编译器无法确定要给函数的栈帧分配多少空间。为了管理变长栈帧，x86-64代码使用寄存器%rbp作为帧指针（frame pointer）（指向栈帧里保存返回地址之后的地址，有时也称基指针（base pointer））。如下图所示：<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC3%E7%AB%A0_32.png" alt=""><br>可以看到，在汇编代码中一开始就把寄存器%rbp的值压入栈中，进行备份，然后在函数结尾时，使用leave指令将帧指针恢复到它一开始的值。这条指令不需要参数，等价于执行下面两条指令：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">movq <span class="token operator">%</span>rbp<span class="token punctuation">,</span> <span class="token operator">%</span>rsp      <span class="token comment" spellcheck="true">//Set stack pointer to beginning of frame</span>
popq <span class="token operator">%</span>rbp            <span class="token comment" spellcheck="true">//Restore saved %rbp and set stack ptr to end of caller's frame</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>也就是，首先把栈指针设置为保存%rbp值的位置，然后把该值从栈中弹出到%rbp。这个指令组合具有<strong>释放整个栈帧</strong>的效果。</p>
<p><font size="5" color="orange">浮点代码</font></p>
<hr>
<p>前面所述的%rax等通用寄存器都是存储整型的，AVX浮点体系结构允许数据存储在16个YMM寄存器中，它们的名字为%ymm0~%ymm15。每个YMM寄存器都是256位（32字节）。当对标量数据操作时，这些寄存器只保存浮点数，而且只使用低32位（对于float）或64位（对于double）。如下图所示：<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC3%E7%AB%A0_33.png" alt=""></p>
<p><font size="4" color="red">浮点传送和转换操作</font><br>下图是在内存和XMM寄存器之间（或者XMM寄存器之间）不做任何转换的传送浮点数的指令：<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC3%E7%AB%A0_34.png" alt=""><br>无论数据对齐与否，这些指令都能正确执行，不过代码优化规则建议32位内存数据满足4字节对齐，64位数据满足8字节对齐。使用浮点传送指令来读写内存时，如果地址不满足16字节对齐，它们会导致异常。指令名字中的字母‘a’表示“aligned（对齐的）”。</p>
<p>看一个浮点数传送的例子：<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC3%E7%AB%A0_35.png" alt=""></p>
<p>下面两幅图是浮点数和整数数据类型之间进行转换传送的指令：<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC3%E7%AB%A0_36.png" alt=""><br>在最常见的使用场景中，第二个源和目的操作数都是一样的，就像下面这条指令：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">vcvtsi2sdq  <span class="token operator">%</span>rax<span class="token punctuation">,</span> <span class="token operator">%</span>xmm1<span class="token punctuation">,</span> <span class="token operator">%</span>xmm1
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这条指令从寄存器%rax读出一个长整数，把它转换成数据类型double，并把结果存放进XMM寄存器%xmm1的低字节中。</p>
<p>如果想要在float和double之间转换，其实也可以用vcvtss2sd指令。假设%xmmm0的低位4字节保存着一个单精度值，那么下面这条语句就可以把它转换成一个双精度值（<strong>float转换到double</strong>），并将结果存储在寄存器%xmm0的低8位字节：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">vcvtss2sd  <span class="token operator">%</span>xmm0<span class="token punctuation">,</span> <span class="token operator">%</span>xmm0<span class="token punctuation">,</span>   <span class="token operator">%</span>xmm0
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>但是我们发现GCC实际上为它生成的汇编代码如下：<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC3%E7%AB%A0_37.png" alt=""><br>vunpcklps指令通常用来交叉放置来自两个XMM寄存器的值，把它们存储到第三个寄存器中。也就是说，如果一个源寄存器的内容为字[s3,s2,s1,s0]，另一个源寄存器为字[d3,d2,d1,d0]，那么目的寄存器的值会是[s1,d1,s0,d0]。在上面的代码中，我们看到三个操作数使用同一个寄存器，所以如果元素寄存器的值为[x3,x2,x1,x0]，那么该指令会将寄存器的值更新为[x1,x1,x0,x0]。<br>vcvtps2pd指令把源XMM寄存器中的两个低位单精度值扩展成目的XMM寄存器中的两个双精度值。<br>这两条指令的最终结果是将原始的%xmm0低位4字节中的单精度值转换成双精度值，再将其两个副本保存到%xmm0中（我们也不清楚GCC为什么会生成这样的代码，这样做既没有好处，也没有必要在XMM寄存器中把这个值复制一遍）。</p>
<p>对于把双精度转换成单精度（<strong>double转换到float</strong>），可以直接用下面的语句：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">vcvtsd2ss  <span class="token operator">%</span>xmm0<span class="token punctuation">,</span> <span class="token operator">%</span>xmm0<span class="token punctuation">,</span> <span class="token operator">%</span>xmm0
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>但是GCC也还是为其产生了类似的代码：<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC3%E7%AB%A0_38.png" alt=""></p>
<p><font size="4" color="red">过程中的浮点代码</font><br>当函数包含指针、整数和浮点数混合的参数时，指针和整数通过通用寄存器传递，而浮点值通过XMM寄存器传递。</p>
<p><font size="4" color="red">浮点运算操作</font><br>下图描述了一组指定浮点数算术运算的标量AVX2浮点指令：<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC3%E7%AB%A0_39.png" alt=""><br>图中指令操作数的顺序都是S1、S2、D。</p>
<p>来看一个例子：<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC3%E7%AB%A0_40.png" alt=""></p>
<p><font size="4" color="red">定义和使用浮点常数</font><br>和整数运算操作不同，AVX浮点操作不能以立即数值作为操作数。相反，编译器必须为所有的常量浮点数值分配和初始化存储空间，然后代码再把这些值从内存读入。如下面这个例子：<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC3%E7%AB%A0_41.png" alt=""><br>可以看到函数从标号为.LC2的内存位置读出值1.8，从标号为.LC3的位置读出值32.0。观察这些标号对应的值，可以看出每一个都是通过一对.long声明和十进制表示的值指定的，其实把这两个long数据的位模式连起来，用IEEE浮点数解释就能得到对应的浮点f常数。</p>
<p><font size="4" color="red">在浮点代码中使用位级操作</font><br>下图所示的指令可以针对浮点数进行位级操作（包括位级异或、位级与）：<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC3%E7%AB%A0_42.png" alt=""><br>其中封装数据的意思是，它们更新整个目的XMM寄存器，对两个源寄存器的所有位都实施指定的位级操作。</p>
<p><font size="4" color="red">浮点比较操作</font><br>下图是用于比较浮点数值的指令：<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC3%E7%AB%A0_43.png" alt=""><br>这些指令类似于CMP指令，它们都比较操作数S1和S2（顺序可能与预计的相反），并且设置条件码指示它们的相对值。与cmpq一样，它们遵循以相反顺序列出操作数ATT格式惯例。参数S2必须在XMM寄存器中，而S1可以在XMM寄存器也可以在内存中。</p>
<p>浮点比较指令会设置3个条件码：零标志位ZF、进位标志位CF和奇偶标志位PF（对于整数操作，当最近的一次算术或逻辑运算产生的值的最低位有效直接是偶校验的（即这个字节中有偶数个1），那么就会设置这个标志位；不过对于浮点数比较，当两个操作数中任一个是NaN时，会设置该位）。浮点数比较的条件码的设置条件如下图所示：<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC3%E7%AB%A0_44.png" alt=""><br>当任一操作数为NaN时，就会出现无序的情况。可以通过奇偶标志位发现这种情况。通常jp（jump on parity）指令是条件跳转，条件就是浮点比较得到一个无序的结果。</p>
<p>来看一个浮点比较的例子：<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC3%E7%AB%A0_45.png" alt=""><br>这段汇编代码的效率不是很高，因为它比较了x和0.0三次，即使一次比较就能获得所需的信息。而且它还生成了浮点数0.0两次：一次使用vxorps（第2行），一次从内存读出这个这个值（第10行）。</p>
<p><font size="5" color="orange">小结</font></p>
<hr>
<p>有一种称为<strong>及时编译</strong>（just-in-time compilation）的方法，动态地将字节代码序列翻译成机器指令。当代码要执行多次时（例如在循环中），这种方法执行起来更快。<br>&nbsp; </p>
<hr>
<p>参考文献：《深入理解计算机系统第三版》</p>

            </div>

            <!-- Post Comments -->
            
    <!-- 使用 DISQUS_CLICK -->
<div id="disqus-comment">
    <div id="disqus_thread"></div>

<!-- add animation -->
<style>
	.disqus_click_btn {
            line-height: 30px;
            margin: 0;
            min-width: 50px;
            padding: 0 14px;
            display: inline-block;
            font-family: "Roboto", "Helvetica", "Arial", sans-serif;
            font-size: 14px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0;
            overflow: hidden;
            will-change: box-shadow;
            transition: box-shadow .2s cubic-bezier(.4, 0, 1, 1), background-color .2s cubic-bezier(.4, 0, .2, 1), color .2s cubic-bezier(.4, 0, .2, 1);
            outline: 0;
            cursor: pointer;
            text-decoration: none;
            text-align: center;
            vertical-align: middle;
            border: 0;
            background: rgba(158, 158, 158, .2);
            box-shadow: 0 2px 2px 0 rgba(0, 0, 0, .14), 0 3px 1px -2px rgba(0, 0, 0, .2), 0 1px 5px 0 rgba(0, 0, 0, .12);
            color: #fff;
            background-color: #7EC0EE;
            text-shadow: 0
        }
</style>
	
<div class="btn_click_load" id="disqus_bt"> 
    <button class="disqus_click_btn">点击查看评论</button>
</div>

<!--
<script type="text/javascript">
$('.btn_click_load').click(function() {
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'http-miccall-tech'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    document.getElementById('disqus_bt').style.display = "none";
});
</script>
-->
<script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://yoursite.com/2018/07/14/深入理解计算机系统第三章程序的机器级表示/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = 'http://yoursite.com/2018/07/14/深入理解计算机系统第三章程序的机器级表示/'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
</script>

<script type="text/javascript">
    $('.btn_click_load').click(function() {  //click to load comments
        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document;
            var s = d.createElement('script');
            s.src = '//http-miccall-tech.disqus.com/embed.js';
            s.setAttribute('data-timestamp', + new Date());
            (d.head || d.body).appendChild(s);
        })();
        $('.btn_click_load').css('display','none');
    });
</script>
</div>
<style>
    #disqus-comment{
        background-color: #eee;
        padding: 2pc;
    }
</style>


        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
                <li>Design: <a href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
            </ul>
            
            	<span id="busuanzi_container_site_pv">2018总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			
        </div>
    </div>
</body>



 	
</html>
