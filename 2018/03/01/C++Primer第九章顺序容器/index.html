<!DOCTYPE HTML>
<html>

<head><meta name="generator" content="Hexo 3.9.0">
	<link rel="bookmark" type="image/x-icon" href="/img/logo_miccall.png">
	 <link rel="shortcut icon" href="/img/logo_miccall.png">
	
			
    <title>
    Elays'Blog
    </title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
	<script>
	(function(){
		if('{{ page.password }}'){
			if (prompt('请输入博客密码') !== "elayRender"){
				alert('密码错误！');
				window.location.href='http://www.google.com'
				window.open('','_top'); 
				window.top.close(); 
				window.opener=null; 
				window.close();
			}
		}
	})();
	</script>
    <link rel="stylesheet" href="/css/mic_main.css">
    <link rel="stylesheet" href="/css/dropdownMenu.css">
    
    	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css">
    </noscript>
			    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<link rel="stylesheet" href="/css/prism-dark.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>
    
		
<!-- Layouts -->


<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<!--<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">-->
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/latest.js?config=TeX-MML-AM_CHTML">
</script>

<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_undefined.css">
<link rel="stylesheet" href="/css/typo.css">
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">Elay</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special">
            <ul class="menu links">
			<!-- Homepage  主页  --> 
			<li>
	            <a href="/" rel="nofollow">主页</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">分类</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="/categories/C/">C#</a></li><li><a class="category-link" href="/categories/C-语法/">C#语法</a></li><li><a class="category-link" href="/categories/C/">C++</a></li><li><a class="category-link" href="/categories/C语言/">C语言</a></li><li><a class="category-link" href="/categories/Graphics/">Graphics</a></li><li><a class="category-link" href="/categories/Math/">Math</a></li><li><a class="category-link" href="/categories/OpenGL/">OpenGL</a></li><li><a class="category-link" href="/categories/Unity/">Unity</a></li><li><a class="category-link" href="/categories/Vulkan/">Vulkan</a></li><li><a class="category-link" href="/categories/博客配置/">博客配置</a></li><li><a class="category-link" href="/categories/并行计算/">并行计算</a></li><li><a class="category-link" href="/categories/操作系统/">操作系统</a></li><li><a class="category-link" href="/categories/数据结构/">数据结构</a></li><li><a class="category-link" href="/categories/毕设/">毕设</a></li><li><a class="category-link" href="/categories/游戏开发/">游戏开发</a></li><li><a class="category-link" href="/categories/计算机系统/">计算机系统</a></li><li><a class="category-link" href="/categories/设计模式/">设计模式</a>
	                    </li></ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
		            
		                <li><a href="null" class="icon fa-github"><span class="label">GitHub</span></a></li>
		            
		            
		            
		            
			</ul>
</nav>

        <div id="main">
            <div class="post_page_title_img" style="height: 25rem;background-image: url(https://github.com/Popperelay/Photos/blob/master/Photos/C++Primer%E7%AC%AC9%E7%AB%A0.jpg?raw=true);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;">
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2>C++Primer第九章 顺序容器</h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
				<!-- 目录 -->
				<p class="show-toc-btn" id="show-toc-btn" onclick="showToc();" style="display:none">
				<span class="btn-bg"></span>
				<span class="btn-text">文章导航</span>
				</p>
				<div id="toc-article" class="toc-article">
					<span id="toc-close" class="toc-close" title="隐藏导航" onclick="showBtn();">×</span>
					<strong class="toc-title">文章目录</strong>
					
			   </div>
			   <script type="text/javascript">
				function showToc(){
					var toc_article = document.getElementById("toc-article");
					var show_toc_btn = document.getElementById("show-toc-btn");
					toc_article.setAttribute("style","display:block");
					show_toc_btn.setAttribute("style","display:none");
					};
				function showBtn(){
					var toc_article = document.getElementById("toc-article");
					var show_toc_btn = document.getElementById("show-toc-btn");
					toc_article.setAttribute("style","display:none");
					show_toc_btn.setAttribute("style","display:block");
					};
			   </script>
				
                <p><font size="5" color="orange">顺序容器概述</font></p>
<hr>
<ol>
<li>标准库中的顺序容器类型如下：</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">vector</td>
<td>可变大小数组。支持随机访问。在尾部之外的位置插入或删除元素可能很慢</td>
</tr>
<tr>
<td style="text-align:center">deque</td>
<td>双端队列。支持快速随机访问。在头尾位置插入/删除速度很快</td>
</tr>
<tr>
<td style="text-align:center">list</td>
<td>双向链表。支持双向顺序访问。在list中任何位置插入/删除都很快</td>
</tr>
<tr>
<td style="text-align:center">forward_list</td>
<td>单向链表。只支持单向顺序访问。在链表中任何位置插入/删除都很快</td>
</tr>
<tr>
<td style="text-align:center">array</td>
<td>固定大小数组。支持快速随机访问。不能添加或删除元素</td>
</tr>
<tr>
<td style="text-align:center">string</td>
<td>与vector相似的容器，但专门用于保存字符。随机访问块，在尾部插入/删除速度很快</td>
</tr>
</tbody>
</table>
<ol start="2">
<li>链表容器（list和forward_list）相比于vector、deque、array这些容器，其额外内存开销会很大。</li>
<li>与内置数组相比，array是一种更安全、更容易使用的数组类型。</li>
<li>forward_list的设计目标是达到与最好的手写的单向链表数据结构相当的性能。因此，forward_list没有size操作，因为保存和计算其大小就会比手写链表多出额外的开销。</li>
<li>新标准的容器比旧版本快得多。新标准容器的性能几乎肯定与最精心优化过的同类数据结构一样好（通常会更好）。现代C++程序应该使用标准库容器，而不是更原始的数据结构，如内置数组。</li>
<li>如果程序只有在读取输入时才需要在容器中间位置插入元素，随后需要随机访问元素，则：<ul>
<li>首先确定是否真的需要在容器中间位置添加元素。当处理输入数据时，通常可以很容易地向vector追加数据，然后再调用标准库的sort函数来重排容器中的元素，从而避免在中间位置添加元素（这条准则需要容器是有序的）。</li>
<li>如果必须在中间位置插入元素，考虑在输入阶段使用list，一旦输入完成，将list中的内容拷贝到一个vector中。</li>
</ul>
</li>
</ol>
<p><font size="5" color="orange">容器库概述</font></p>
<hr>
<ol>
<li>标准库容器均为模板类。</li>
<li>容器的公共操作中（Container是某种容器），<code>Container::size_type</code>表示容器可能的最大容量大小，是无符号整数类型，<code>Container::difference_type</code>用于保存两个迭代器之间的距离，是有符号整数类型，<code>Container::value_type</code>是容器里的元素类型，<code>Container::reference</code>是容器里元素的左值类型，相当于<code>Container::value_type&amp;</code>。</li>
<li>forward_list迭代器不支持递减运算符，毕竟是单向链表嘛。</li>
<li>容器的begin和end成员函数其实是有重载版本的。非常量对象调用这两个函数时，会返回iterator；而常量对象调用这两个函数时，会返回const_iterator。</li>
<li>当不需要写访问时，迭代器应使用cbegin和cend函数（这两函数无论调用它们的是不是常量对象，都总是会返回const_iterator）。</li>
<li>用一个容器拷贝给另一个容器时，容器类型必须相同。而用迭代器范围来拷贝时要求低一点，不需要容器类型完全相同，只要容器里的元素可以进行隐式转换即可。<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">></span> CVec <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token string">"This"</span><span class="token punctuation">,</span><span class="token string">"There"</span><span class="token punctuation">,</span><span class="token string">"Here"</span> <span class="token punctuation">,</span><span class="token string">"Good"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
 std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> <span class="token function">SVec2</span><span class="token punctuation">(</span>Vec1<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//错误：直接拷贝时，容器类型必须匹配</span>
 <span class="token comment" spellcheck="true">//使用范围迭代器拷贝时，元素能隐式转换即可，不需要容器类型完全相同</span>
 std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> <span class="token function">SVec3</span><span class="token punctuation">(</span>CVec<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> CVec<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//正确</span>
 std<span class="token operator">::</span>forward_list<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> <span class="token function">SList</span><span class="token punctuation">(</span>CVec<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> CVec<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>当定义一个array时，除了指定元素类型，还要指定容器大小，使用时也是一样。毕竟array是一个固定大小的数组嘛：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>array<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token operator">></span> Datas<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//类型为：保存10个int的数组</span>
 std<span class="token operator">::</span>array<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token operator">></span><span class="token operator">::</span>size_type i<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li>虽然我们不能对内置数组类型进行拷贝操作，但是array是可以的：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> Data1<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
 <span class="token keyword">decltype</span><span class="token punctuation">(</span>Data1<span class="token punctuation">)</span> Data2 <span class="token operator">=</span> Data1<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//错误：内置数组不支持拷贝或赋值</span>
 std<span class="token operator">::</span>array<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token operator">></span> Data3 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
 std<span class="token operator">::</span>array<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token operator">></span> Data4 <span class="token operator">=</span> Data3<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//正确，只要数组类型匹配即合法</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>顺序容器（array除外）还定义了一个名为assign的成员函数，它用其参数所指定的元素的拷贝去替换左边容器中的所有元素（不要求容器相同，只要元素类型可以隐式转换即可）。assign操作不适用于array和关联容器。因为旧元素会被替换，所以传递给assign的迭代器不能指向调用assign的容器。</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">seq.assign(b, e)</td>
<td>将seq中的元素替换为迭代器b和e所表示的范围内的元素。迭代器b和e不能指向seq中的元素</td>
</tr>
<tr>
<td style="text-align:center">seq.assign(il)</td>
<td>将seq中的元素替换为初始化列表il中的元素</td>
</tr>
<tr>
<td style="text-align:center">seq.assign(n, t)</td>
<td>将seq中的元素替换为n个值为t的元素</td>
</tr>
</tbody>
</table>
<pre><code>```cpp
std::vector&lt;const char*&gt; Vec = { &quot;This&quot;,&quot;There&quot;,&quot;Here&quot; ,&quot;Good&quot; };
std::list&lt;std::string&gt; List;
List.assign(Vec.cbegin(), Vec.cend());
```
</code></pre><ol start="10">
<li>赋值相关运算符会导致指向左边容器内部的迭代器、引用和指针失效。不过<code>swap(Container1, Container2)</code>或者<code>Container1.swap(Container2)</code>操作不会。而且在容器之间swap操作通常比拷贝元素要快。</li>
<li>除array外，交换两个容器内容的swap操作保证会很快，因为元素本身并未交换，只是交换了两个容器的内部数据结构，它不对任何元素进行拷贝、删除或插入操作，因此可以保证在常数时间内完成。与其他容器不同，swap两个array会真正交换它们的元素，因此其所需的时间与array中元素的数目成正比。</li>
<li>除string外，指向容器的迭代器、引用和指针在swap操作之后都不会失效，它们仍指向swap操作之前所指向的那些元素。但是在swap操作之后，这些元素已经属于不同的容器了。例如，假定iter在swap之前指向svec[3]的元素，那么在swap操作之后它指向svec2[3]的元素。与其他容器不同，对一个string调用swap操作会导致迭代器、引用和指针失效。</li>
<li>在新标准中，容器提供成员函数版本的swap，也提供非成员版本的swap。统一使用非成员版本的swap是一个好习惯。</li>
<li>只有当内部的元素类型也定义了相应的比较运算符时，我们才可以使用关系运算符来比较两个容器。</li>
</ol>
<p><font size="5" color="orange">顺序容器操作</font></p>
<hr>
<ol>
<li>向容器中添加元素的insert函数的几个版本：</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">c.insert(p, t)</td>
<td>在迭代器p指向的元素<strong>之前</strong>插入一个值为t的元素。返回指向新添加元素的迭代器</td>
</tr>
<tr>
<td style="text-align:center">c.insert(p, n, t)</td>
<td>在迭代器p指向的元素之前插入n个值为t的元素</td>
</tr>
<tr>
<td style="text-align:center">c.insert(p, b, e)</td>
<td>将迭代器b和e指定的范围内的元素插入到迭代器p所指向的元素之前。b和e不能指向c中的元素</td>
</tr>
<tr>
<td style="text-align:center">c.insert(p, il)</td>
<td>将花括号包围的元素值列表il插入到迭代器p指向的元素之前</td>
</tr>
</tbody>
</table>
<ol start="2">
<li>向一个vector、string或deque插入元素会使所有指向容器的迭代器、引用和指针失效。</li>
<li>向一个vector或string添加元素可能引起整个对象存储空间的重新分配。重新分配一个对象的存储空间需要分配新的内存，并将元素从旧的空间移动到新的空间中。</li>
<li>vector、deque、list和string都支持insert成员，但是forward_list有点不同，它提供了自己特殊版本的insert成员（后文详述）。</li>
<li>由于迭代器有可能指向尾后迭代器（容器中不存在的元素的位置），所以是在迭代器之前的位置插入元素。</li>
<li>将元素插入到连续容器vector、deque、string中的任何位置都是合法的，但这样做可能很耗时。</li>
<li>新标准引入了三个新成员：emplace_front、emplace和emplace_back，这些操作构造而不是拷贝元素。这些操作分别对应push_front、insert和push_back，允许我们将元素放在容器头部、一个指定位置之前或容器尾部。调用一个emplace成员函数时，是将参数传递给元素类型的构造函数。emplace成员使用这些参数在容器管理的内存空间中直接构造元素。<strong>其实emplace相当于比push或insert多了一个隐式转换</strong>。</li>
<li>顺序容器的front和back成员函数返回的是元素的引用，begin和end成员函数返回的是迭代器。</li>
<li>使用容器的at成员函数来代替下标运算符[]，可以安全地随机访问容器中的元素。因为下标运算符在下标越界时函数行为未定义，但是at成员函数在索引越界时会抛出out_of_range异常。</li>
<li><code>c.erase(p)</code>和<code>c.erase(b, e)</code>操作是顺序容器的删除操作，前者删除迭代器p指向的元素，后者删除迭代器b和e所指定范围内的元素。都返回删除元素的下一个位置的迭代器。</li>
<li>删除deque中除首位之外的任何元素都会使所有迭代器、引用和指针失效。vector或string中删除点之后的迭代器、引用和指针都会失效。</li>
<li><p>由于forward_list是单向链表，无法获取链表中某个结点的前驱结点，导致无法在某个元素之前进行插入、删除等等操作，所以forward_list并未定义insert、emplace和earse等操作，而是定义了名为insert_after、emplace_after和erase_after的操作。在执行插入、删除等操作时，需要首先获取到前驱结点，再调用这些函数来完成相应工作。除此之外，forward_list还定义了名为before_begin的成员函数来获取首前迭代器（即链表首元素之前的位置，用于在链表首元素之前添加删除元素）。</p>
<p>如下程序可以删除存储在forward_list中的所有奇数，其中PrevIter用于存储用于遍历的当前迭代器的前驱迭代器。通过这个前驱迭代器来删除forward_list中的元素。</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>forward_list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> IList<span class="token punctuation">{</span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> PrevIter <span class="token operator">=</span> IList<span class="token punctuation">.</span><span class="token function">cbefore_begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> CurrIter <span class="token operator">=</span> <span class="token operator">++</span>PrevIter<span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>CurrIter <span class="token operator">!=</span> IList<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>CurrIter <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">)</span>
        CurrIter <span class="token operator">=</span> IList<span class="token punctuation">.</span><span class="token function">erase_after</span><span class="token punctuation">(</span>PrevIter<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">{</span>
        PrevIter <span class="token operator">=</span> CurrIter<span class="token punctuation">;</span>
        <span class="token operator">++</span>CurrIter<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>可以用顺序容器的<code>c.resize(n)</code>或<code>c.resize(n, t)</code>成员函数来改变容器大小。前者更改容器大小后，多出的元素被丢弃，新添加的元素进行值初始化；而后者新添加的元素被初始化为t。当然，resize操作不适用于array。</li>
<li>值得注意的是，resize操作只改变容器里的元素数目，并不改变容器的容量。而且使用resize后，指针、迭代器或引用都有可能失效。</li>
<li><p>总结一下，哪些情况下，会使容器的迭代器、指针和引用等失效：</p>
<ul>
<li>向容器添加元素后：<ul>
<li>对于vector和string。且存储空间被重新分配，则指向容器的迭代器、指针和引用都会失效。如果存储空间未重新分配，指向插入位置之后的元素的迭代器等会失效，之前的依然有效。</li>
<li>对于deque，插入到除首尾位置之外的任何位置都会导致迭代器等失效。如果在首尾位置添加元素，只会使迭代器失效，指针和引用依然有效。</li>
<li>对于list和forward_list，添加元素后迭代器、指针和引用等总是有效的。</li>
</ul>
</li>
<li>从容器删除一个元素后：<ul>
<li>对于vector和string，指向被删元素之后元素的迭代器、引用和指针失效，之前的依然有效。</li>
<li>对于deque，在除首尾位置之外的任何位置删除元素都会导致迭代器等失效。如果删除的是尾元素，则尾后迭代器会失效，但是其他迭代器、指针、引用等依然有效；如果删除的是首元素，迭代器等也依然有效。</li>
<li>对于list和forward_list，删除元素之后，除了指向被删除元素的其他迭代器等依然有效。</li>
</ul>
</li>
</ul>
<p>可以看出，其实添加和删除情况都差不多，主要是看添加删除元素后，迭代器所指向的地址是否还是原来的地址。在涉及到向容器添加或删除元素时，一定要注意之前的迭代器是否还指向正确的元素，尤其是在循环中。</p>
</li>
<li>不要保存end返回的迭代器。当我们添加/删除vector或string的元素后，或在deque中首元素之外的任何位置添加/删除元素后，原来end返回的迭代器总是会失效。所以，在循环中必须返回调用end成员函数，而不能在循环之前保存end返回的迭代器，当做容器的尾后迭代器来使用。比如如下程序就是错误的：<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> Vec<span class="token punctuation">{</span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> Iter <span class="token operator">=</span> Vec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> EndIter <span class="token operator">=</span> Vec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>Iter <span class="token operator">!=</span> EndIter<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//错误，插入或删除元素后EndIter就失效了</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>Iter <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        Iter <span class="token operator">=</span> Vec<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>Iter<span class="token punctuation">,</span> <span class="token operator">*</span>Iter<span class="token punctuation">)</span><span class="token punctuation">;</span>
        Iter <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">{</span>
        Iter <span class="token operator">=</span> Vec<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>Iter<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
不应该在循环之前把尾后迭代器保存下来，循环条件应该写成下面这样：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">while</span> <span class="token punctuation">(</span>Iter <span class="token operator">!=</span> Vec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//每次调用返回当前最新的尾后迭代器</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
</ol>
<p><font size="5" color="orange">vector对象是如何增长的</font></p>
<hr>
<ol>
<li>诸如vector和string，如果容器没有足够的空间容纳新的元素，而不得不获取新的内存空间时，vector和string的实现通常会分配比新的空间需求更大的内存空间。容器预留这些空间作为备用，可用来保存更多的新元素。这样，就不需要每次添加新元素都重新分配容器的内存空间了。虽然vector在每次重新分配内存空间时都需要移动所有元素，但使用此策略后，其扩张操作通常比list和deque还要快。</li>
<li>容器大小的管理操作函数如下表：</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">c.shrink_to_fit()</td>
<td>将capacity()减少为与size()相同大小</td>
</tr>
<tr>
<td style="text-align:center">c.capacity()</td>
<td>不重新分配内存空间的话，容器c可以保存多少元素</td>
</tr>
<tr>
<td style="text-align:center">c.reserve(n)</td>
<td>分配至少能容纳n个元素的内存空间</td>
</tr>
</tbody>
</table>
<ol start="3">
<li>reserve并不改变容器中元素的数量，它仅影响vector预先分配多大的内存空间。如果需求的n小于或等于当前容量，reserve什么也不做，而且容器不会退回多余的内存空间。这样，调用reserve永远也不会减少容器占用的内存空间。</li>
<li>如果确实需要容器退回不需要的内存空间，可以调用shrink_to_fit成员函数。但是，它只是一个请求，标准库并不保证一定会退还内存空间，需要更具具体的实现而定。</li>
</ol>
<p><font size="5" color="orange">额外的string操作</font></p>
<hr>
<ol>
<li>用字符串字面值赋给char类型的指针时，末尾会有一个空字符’\0’作为结尾标志，但以字符数组（非字符串变量值）赋给char型指针时，末尾没有这样一个空字符：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">char</span> <span class="token operator">*</span>cp <span class="token operator">=</span> <span class="token string">"This"</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//cp里保存的是：T、h、i、s、\0</span>
 <span class="token keyword">char</span> ca<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token string">'T'</span><span class="token punctuation">,</span><span class="token string">'h'</span><span class="token punctuation">,</span><span class="token string">'i'</span><span class="token punctuation">,</span><span class="token string">'s'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//ca里在s后面没有\0</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
 所以，可以使用cp去构造一个string对象，但是不能使用ca：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>string <span class="token function">s1</span><span class="token punctuation">(</span>cp<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//s1是：This</span>
 std<span class="token operator">::</span>string <span class="token function">s2</span><span class="token punctuation">(</span>ca<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//s2可能是："This烫烫烫烫坃\xe\x1烫烫飧f\xev"</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li>string的substr成员函数返回一个string，它是原始string的一部分的<strong>拷贝</strong>：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>string s <span class="token operator">=</span> <span class="token string">"This is ..."</span><span class="token punctuation">;</span>
 std<span class="token operator">::</span>string s1 <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// s1 = is...</span>
 std<span class="token operator">::</span>string s2 <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// s2 = is is ..</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li>除了如前面所述的顺序容器接受迭代器的insert和erase版本以外，string还额外提供了接受下标的版本：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>string s <span class="token operator">=</span> <span class="token string">"This is"</span><span class="token punctuation">;</span>
 s<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token string">"dog "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// s = This dog is</span>
 s<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// s = This dog is...</span>
 s<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//从序号为4的位置开始删除4个元素, s = This is... </span>
 s<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//从倒数第3个位置开始删除后面的所有元素，s = This is</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>string类还定义了两个额外的操作：append和replace。append用于在string末尾进行追加（插入）操作。而replace是把字符串中的某一段字符替换成另外的字符，相当于连续调用了erase和insert：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>string s <span class="token operator">=</span> <span class="token string">"This is"</span><span class="token punctuation">;</span>
 s<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">" a dog"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// s = This is a dog</span>
 s<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">"There"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//把从0号位置开始的4个元素替换为There，s = There is a dog</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li>string提供了6个不同的搜索函数（其中args时包含要查找的字符串，还可能包含要查找的起始位置，它默认为0）：</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">s.find(args)</td>
<td>查找s中args第一次出现的位置</td>
</tr>
<tr>
<td style="text-align:center">s.rfind(args)</td>
<td>查找s中args最后一次出现的位置</td>
</tr>
<tr>
<td style="text-align:center">s.find_first_of(args)</td>
<td>在s中查找args中任何一个字符第一次出现的位置</td>
</tr>
<tr>
<td style="text-align:center">s.find_last_of(args)</td>
<td>在s中查找args中任何一个字符最后一次出现的位置</td>
</tr>
<tr>
<td style="text-align:center">s.find_first_not_of(args)</td>
<td>在s中查找第一个不在args中的字符</td>
</tr>
<tr>
<td style="text-align:center">s.find_last_not_of(args)</td>
<td>在s中查找最后一个不在args中的字符</td>
</tr>
</tbody>
</table>
<ol start="6">
<li>上面的6个搜索操作都返回string::size_type类型的值，该类型其实是一个unsigned类型，表示匹配发生位置的下标。如果搜索失败，会返回一个名为string::npos的static成员，它也是string::size_type类型。例如在一个字符串中搜索子串出现的所有位置：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>string s <span class="token operator">=</span> <span class="token string">"aaabbaa"</span><span class="token punctuation">;</span>
 std<span class="token operator">::</span>string<span class="token operator">::</span>size_type pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
 <span class="token comment" spellcheck="true">//输出为0 1 5 </span>
 <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pos <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">"aa"</span><span class="token punctuation">,</span> pos<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> std<span class="token operator">::</span>string<span class="token operator">::</span>npos<span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
     std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> pos <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
     <span class="token operator">++</span>pos<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//移动到下一个字符，在剩余的子串中查找</span>
 <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>由于string的搜索操作返回的是一个无符号类型，所以通常不要用一个带符号类型来保存这些函数的返回值。</li>
<li>string的compare成员函数还可以比较string对象和C风格字符串，通常返回正数、负数或0，分别表示大于、小于或等于：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>string s <span class="token operator">=</span> <span class="token string">"aab"</span><span class="token punctuation">;</span>
 std<span class="token operator">::</span>string s2 <span class="token operator">=</span> <span class="token string">"ab"</span><span class="token punctuation">;</span>
 std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> s<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//本机输出-1</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li>把数值类型转换成string可以用to_string(val)函数，任何数值类型都可以。而把string转换成数值类型需要用stoi(s)、stod(s)、stof(s)、stol(s)…等等函数，它们还有额外的参数可以指定转换的进制（具体参考C++Premier中文版P328）:<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">float</span> Value <span class="token operator">=</span> <span class="token number">123.4</span><span class="token punctuation">;</span>
 std<span class="token operator">::</span>string Str <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">to_string</span><span class="token punctuation">(</span>Value<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">float</span> Value1 <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">stof</span><span class="token punctuation">(</span>Str<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<p><font size="5" color="orange">容器适配器</font></p>
<hr>
<ol>
<li>本质上，一个适配器是一种机制，能使某种事物的行为看起来像另外一种事物一样。一个容器适配器接受一种已有的容器类型，使其行为看起来像另外一种不同的类型。例如stack、queue和priority_queue：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>deque<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> Deque<span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
 std<span class="token operator">::</span>stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> Stk<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//空栈</span>
 std<span class="token operator">::</span>stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">Stk1</span><span class="token punctuation">(</span>Deque<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//基于Deque创建的适配器：栈，会把Deque中的元素拷贝到Stk1</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> IntStack<span class="token punctuation">;</span>
 <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
     IntStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>IntStack<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
     <span class="token keyword">int</span> Value <span class="token operator">=</span> IntStack<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     IntStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//pop返回的是void类型</span>
 <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>默认情况下，stack和queue是基于双端队列deque实现的，而priority_queue是在vector上实现的。不过我们也可以自己指定在哪种容器上来实现这些适配器，只需要在定义时添加第二个模板参数即可：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> Stk2<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//基于vector创建的栈</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li>对于一个给定的适配器，可以使用哪些容器是有限制的。stack只要求push_back、pop_back和back操作，因此可以使用除array和forward_list之外的任何容器类型来构造stack。queue适配器要求back、push_back、front和push_front，因此它可以构造于list或deque之上，但不能基于vector构造。priority_queue除了front、push_back和pop_back操作之外还要求随机访问能力，因此它可以构造于vector或deque之上，但不能基于list构造。</li>
<li>priority_queue允许我们为队列中的元素建立优先级。新加入的元素会排在所有优先级比它低的已有元素之前。默认情况下，标准库在元素类型上使用&lt;运算符来确定相对优先级。<br>&nbsp; </li>
</ol>
<hr>
<p>参考文献：《C++Primer第五版》</p>

            </div>

            <!-- Post Comments -->
            
    <!-- 使用 DISQUS_CLICK -->
<div id="disqus-comment">
    <div id="disqus_thread"></div>

<!-- add animation -->
<style>
	.disqus_click_btn {
            line-height: 30px;
            margin: 0;
            min-width: 50px;
            padding: 0 14px;
            display: inline-block;
            font-family: "Roboto", "Helvetica", "Arial", sans-serif;
            font-size: 14px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0;
            overflow: hidden;
            will-change: box-shadow;
            transition: box-shadow .2s cubic-bezier(.4, 0, 1, 1), background-color .2s cubic-bezier(.4, 0, .2, 1), color .2s cubic-bezier(.4, 0, .2, 1);
            outline: 0;
            cursor: pointer;
            text-decoration: none;
            text-align: center;
            vertical-align: middle;
            border: 0;
            background: rgba(158, 158, 158, .2);
            box-shadow: 0 2px 2px 0 rgba(0, 0, 0, .14), 0 3px 1px -2px rgba(0, 0, 0, .2), 0 1px 5px 0 rgba(0, 0, 0, .12);
            color: #fff;
            background-color: #7EC0EE;
            text-shadow: 0
        }
</style>
	
<div class="btn_click_load" id="disqus_bt"> 
    <button class="disqus_click_btn">点击查看评论</button>
</div>

<!--
<script type="text/javascript">
$('.btn_click_load').click(function() {
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'http-miccall-tech'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    document.getElementById('disqus_bt').style.display = "none";
});
</script>
-->
<script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://yoursite.com/2018/03/01/C++Primer第九章顺序容器/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = 'http://yoursite.com/2018/03/01/C++Primer第九章顺序容器/'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
</script>

<script type="text/javascript">
    $('.btn_click_load').click(function() {  //click to load comments
        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document;
            var s = d.createElement('script');
            s.src = '//http-miccall-tech.disqus.com/embed.js';
            s.setAttribute('data-timestamp', + new Date());
            (d.head || d.body).appendChild(s);
        })();
        $('.btn_click_load').css('display','none');
    });
</script>
</div>
<style>
    #disqus-comment{
        background-color: #eee;
        padding: 2pc;
    }
</style>


        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
                <li>Design: <a href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
            </ul>
            
            	<span id="busuanzi_container_site_pv">2019总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			
        </div>
    </div>
</body>



 	
</html>
