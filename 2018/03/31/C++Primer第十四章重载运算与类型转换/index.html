<!DOCTYPE HTML>
<html>

<head><meta name="generator" content="Hexo 3.9.0">
	<link rel="bookmark" type="image/x-icon" href="/img/logo_miccall.png">
	 <link rel="shortcut icon" href="/img/logo_miccall.png">
	
			
    <title>
    Elays'Blog
    </title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
	<script>
    (function(){
        if('{{ page.password }}'){
            if (prompt('请输入文章密码') !== '{{ page.password }}'){
                alert('密码错误');
                history.back();
            }
        }
    })();
	</script>
    <link rel="stylesheet" href="/css/mic_main.css">
    <link rel="stylesheet" href="/css/dropdownMenu.css">
    
    	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css">
    </noscript>
			    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<link rel="stylesheet" href="/css/prism-dark.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>
    
		
<!-- Layouts -->


<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<!--<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">-->
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/latest.js?config=TeX-MML-AM_CHTML">
</script>

<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_undefined.css">
<link rel="stylesheet" href="/css/typo.css">
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">MICCALL</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special">
            <ul class="menu links">
			<!-- Homepage  主页  --> 
			<li>
	            <a href="/" rel="nofollow">主页</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">分类</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="/categories/C/">C#</a></li><li><a class="category-link" href="/categories/C-语法/">C#语法</a></li><li><a class="category-link" href="/categories/C/">C++</a></li><li><a class="category-link" href="/categories/C语言/">C语言</a></li><li><a class="category-link" href="/categories/Graphics/">Graphics</a></li><li><a class="category-link" href="/categories/Math/">Math</a></li><li><a class="category-link" href="/categories/OpenGL/">OpenGL</a></li><li><a class="category-link" href="/categories/Unity/">Unity</a></li><li><a class="category-link" href="/categories/博客配置/">博客配置</a></li><li><a class="category-link" href="/categories/并行计算/">并行计算</a></li><li><a class="category-link" href="/categories/操作系统/">操作系统</a></li><li><a class="category-link" href="/categories/数据结构/">数据结构</a></li><li><a class="category-link" href="/categories/毕设/">毕设</a></li><li><a class="category-link" href="/categories/游戏开发/">游戏开发</a></li><li><a class="category-link" href="/categories/计算机系统/">计算机系统</a></li><li><a class="category-link" href="/categories/设计模式/">设计模式</a></li><li><a class="category-link" href="/categories/面试/">面试</a>
	                    </li></ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/gallery/" title="图库">
		                图库
		            </a>
		        </li>
		        
		        <li>
		            <a href="/tag/" title="搜索">
		                搜索
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
		            
		                <li><a href="https://github.com/miccall" class="icon fa-github"><span class="label">GitHub</span></a></li>
		            
		            
		            
		            
			</ul>
</nav>

        <div id="main">
            <div class="post_page_title_img" style="height: 25rem;background-image: url(https://github.com/Popperelay/Photos/blob/master/Photos/C++Primer%E7%AC%AC14%E7%AB%A0.jpg?raw=true);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;">
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2>C++Primer第十四章 重载运算与类型转换</h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
				<!-- 目录 -->
				<p class="show-toc-btn" id="show-toc-btn" onclick="showToc();" style="display:none">
				<span class="btn-bg"></span>
				<span class="btn-text">文章导航</span>
				</p>
				<div id="toc-article" class="toc-article">
					<span id="toc-close" class="toc-close" title="隐藏导航" onclick="showBtn();">×</span>
					<strong class="toc-title">文章目录</strong>
					
			   </div>
			   <script type="text/javascript">
				function showToc(){
					var toc_article = document.getElementById("toc-article");
					var show_toc_btn = document.getElementById("show-toc-btn");
					toc_article.setAttribute("style","display:block");
					show_toc_btn.setAttribute("style","display:none");
					};
				function showBtn(){
					var toc_article = document.getElementById("toc-article");
					var show_toc_btn = document.getElementById("show-toc-btn");
					toc_article.setAttribute("style","display:none");
					show_toc_btn.setAttribute("style","display:block");
					};
			   </script>
				
                <p><font size="5" color="orange">基本概念</font></p>
<hr>
<ol>
<li>重载的运算符本质上是一次函数调用，所以运算符原有的求值顺序的规则无法应用到重载的运算符上。特别是，逻辑与、或运算符、逗号运算符的重载版本其运算对象求值顺序规则无法保留下来。而且，&amp;&amp;和||运算符的重载版本也无法保留内置运算符的短路求值属性，两个运算对象总是会被求值。所以，不建议重载这些运算符。</li>
<li>通常情况下，不应该重载逗号、取地址、逻辑与和逻辑或运算符。</li>
<li>某些情况下，重载的运算符作为普通函数比作为成员函数更好。比如，具有对称性的运算符可能转换任意一端的运算对象，例如算术、相等比较、位运算符等等，因此它们通常应该是普通的非成员函数。</li>
</ol>
<p><font size="5" color="orange">输入和输出运算符</font></p>
<hr>
<ol>
<li><p>输入输出运算符必须是非成员函数。与iostream标准库兼容的输入输出运算符必须是普通的非成员函数，而不能是类的成员函数。否则，它的左侧运算对象将是我们的类的一个对象：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> CData Data1<span class="token punctuation">;</span>
 Data1 <span class="token operator">&lt;&lt;</span> cout<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//如果operator&lt;&lt;是CData的成员</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p> 显然不太对。因此，如果我们希望为类自定义IO运算符，则必须将其定义成非成员函数。而且，IO运算符通常需要读写类的非公有数据成员，所以IO运算符一般被声明为友元。</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">class</span> <span class="token class-name">CData</span>
 <span class="token punctuation">{</span>
     <span class="token keyword">friend</span> std<span class="token operator">::</span>istream<span class="token operator">&amp;</span> <span class="token keyword">operator</span> <span class="token operator">>></span> <span class="token punctuation">(</span>std<span class="token operator">::</span>istream <span class="token operator">&amp;</span>vioIStream<span class="token punctuation">,</span> CData <span class="token operator">&amp;</span>voData<span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token keyword">friend</span> std<span class="token operator">::</span>ostream<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>std<span class="token operator">::</span>ostream <span class="token operator">&amp;</span>voOstream<span class="token punctuation">,</span> <span class="token keyword">const</span> CData <span class="token operator">&amp;</span>vData<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
     <span class="token function">CData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
     <span class="token keyword">int</span> m_Data <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
     std<span class="token operator">::</span>string m_DataName<span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>

 std<span class="token operator">::</span>istream<span class="token operator">&amp;</span> <span class="token keyword">operator</span> <span class="token operator">>></span> <span class="token punctuation">(</span>std<span class="token operator">::</span>istream <span class="token operator">&amp;</span>vioIStream<span class="token punctuation">,</span> CData <span class="token operator">&amp;</span>voData<span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
     vioIStream <span class="token operator">>></span> voData<span class="token punctuation">.</span>m_Data <span class="token operator">>></span> voData<span class="token punctuation">.</span>m_DataName<span class="token punctuation">;</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>vioIStream<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">//检查输入是否成功</span>
         voData <span class="token operator">=</span> <span class="token function">CData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//输入失败，对象被赋予默认的状态</span>
     <span class="token keyword">return</span> vioIStream<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>

 std<span class="token operator">::</span>ostream<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>std<span class="token operator">::</span>ostream <span class="token operator">&amp;</span>voOstream<span class="token punctuation">,</span> <span class="token keyword">const</span> CData <span class="token operator">&amp;</span>vData<span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
     voOstream <span class="token operator">&lt;&lt;</span> vData<span class="token punctuation">.</span>m_Data <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> vData<span class="token punctuation">.</span>m_DataName <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
     <span class="token keyword">return</span> voOstream<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>

 CData Data1<span class="token punctuation">;</span>
 std<span class="token operator">::</span>cin <span class="token operator">>></span> Data1<span class="token punctuation">;</span>
 std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> Data1<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 在重载的输入运算符函数中，if语句检查读取操作是否成功，如果发生了IO错误，则运算符将给定的对象重置为默认状态。</p>
</li>
</ol>
<p>&lt;font size=”5” color=”orange’&gt;算术和关系运算符</p>
<hr>
<ol>
<li>通常情况下，我们把算术和关系运算符定义成非成员函数以允许对左侧或右侧对象进行交换。</li>
</ol>
<p><font size="5" color="orange">赋值运算符</font></p>
<hr>
<ol>
<li>不论形参的类型是什么，赋值运算符都必须定义为成员函数。而且复合赋值运算符（+=）通常情况下也应该这样做。它们都应该返回左侧运算对象的引用。</li>
</ol>
<p><font size="5" color="orange">下标运算符</font></p>
<hr>
<ol>
<li>下标运算符必须是成员函数。</li>
</ol>
<p><font size="5" color="orange">递增和递减运算符</font></p>
<hr>
<ol>
<li>递增和递减运算符应该同时定义前置版本和后置版本，而且通常应该被定义为类的成员。</li>
<li>为了与内置版本保持一致，前置运算符应该返回递增或递减后对象的引用，后置版本应该返回对象的原值（值而非引用）。</li>
<li><p>要想同时定义前置运算符和后置运算符，必须先解决一个问题：它们的重载函数的形式是一样的，无法区分。所以语法规定，后置版本的递增和递减运算符额外接受一个int类型的参数，这个参数的实参无须用户指定，由编译器自动为其传递一个值为0的实参：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">class</span> <span class="token class-name">CData</span>
 <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
     CData<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">//前置版本的递增运算符，返回引用</span>
     <span class="token punctuation">{</span>
         <span class="token operator">++</span>m_Data<span class="token punctuation">;</span>
         <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
     CData<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">--</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">//前置版本的递减运算符，返回引用</span>
     <span class="token punctuation">{</span>
         <span class="token operator">--</span>m_Data<span class="token punctuation">;</span>
         <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
     CData <span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">//后置版本的递增运算符，返回值</span>
     <span class="token punctuation">{</span>
         CData TempData <span class="token operator">=</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
         <span class="token operator">++</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
         <span class="token keyword">return</span> TempData<span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
     CData <span class="token keyword">operator</span><span class="token operator">--</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">//后置版本的递减运算符，返回值</span>
     <span class="token punctuation">{</span>
         CData TempData <span class="token operator">=</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
         <span class="token operator">--</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
         <span class="token keyword">return</span> TempData<span class="token punctuation">;</span>
     <span class="token punctuation">}</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
     <span class="token keyword">int</span> m_Data <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 隐式调用后置版本时无须传递实参0，但是显式调用时需要传递参数0，否则调用的将是前置版本：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> CData Data1<span class="token punctuation">;</span>
 Data1<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//调用后置版本的递增运算符</span>
 Data1<span class="token punctuation">.</span><span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//调用前置版本的递增运算符</span>
 Data1<span class="token punctuation">.</span><span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//调用后置版本的递增运算符</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<p><font size="5" color="orange">函数调用运算符</font></p>
<hr>
<ol>
<li><p>如果类重载了函数调用运算符，则我们可以像使用函数一样使用该类的对象：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">class</span> <span class="token class-name">CData</span>
 <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
     <span class="token keyword">void</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span>
     <span class="token punctuation">{</span>
         m_Data <span class="token operator">=</span> i<span class="token punctuation">;</span>
         std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">++</span>m_Data <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
     <span class="token punctuation">}</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
     <span class="token keyword">int</span> m_Data <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>

 CData Data1<span class="token punctuation">;</span>
 <span class="token function">Data1</span><span class="token punctuation">(</span><span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//调用CData类的调用运算符函数，输出41</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 即使Data1只是一个对象而非函数，我们也能调用该对象，因为调用该对象实际上是在运行重载的调用运算符。</p>
</li>
<li>函数调用运算符必须是成员函数。</li>
<li>当我们编写一个lambda后，编译器会将该表达式翻译成一个未命名类的未命名对象。</li>
<li><p>先看如下代码：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">class</span> <span class="token class-name">CShorterString</span>
 <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
     <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> std <span class="token operator">::</span>string <span class="token operator">&amp;</span>vS1<span class="token punctuation">,</span><span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span>vS2<span class="token punctuation">)</span>
     <span class="token punctuation">{</span>
         <span class="token keyword">return</span> vS1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> vS2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>

 std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> SVec<span class="token punctuation">{</span> <span class="token string">"The"</span><span class="token punctuation">,</span><span class="token string">"Furthest"</span><span class="token punctuation">,</span><span class="token string">"Distance"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
 std<span class="token operator">::</span><span class="token function">stable_sort</span><span class="token punctuation">(</span>SVec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> SVec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">CShorterString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 可能会感觉很奇怪，为什么stable_sort的第三个参数（谓词）可以传入一个无名对象呢？这是因为这个对象所在的类定义了调用运算符，当stable_sort在调用这个对象时，实际上会去调用它的调用运算符函数。也就是说该无名对象是一个可调用的对象，所以它能够当做谓词使用。</p>
</li>
<li>标准库定义了一组表示算术运算符、关系运算符和逻辑运算符的类，每个类分别定义了一个执行命名操作的调用运算符。例如，plus类定义了一个函数调用运算符用于对一对运算对象执行+的操作；modulus类定义了一个调用运算符执行二元的%操作；equal_to类执行==，等等。它们都是模板的形式：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>plus<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> IntAdd<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//可执行int加法的函数对象</span>
 std<span class="token operator">::</span>negate<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> IntNegate<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//可对int值取反的函数对象</span>
 <span class="token keyword">int</span> Sum <span class="token operator">=</span> <span class="token function">IntAdd</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//Sum = 30</span>
 Sum <span class="token operator">=</span> <span class="token function">IntNegate</span><span class="token punctuation">(</span>Sum<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//Sum = -30;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
 标准库定义的这种函数对象如下表：</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">算术</th>
<th>关系</th>
<th>逻辑</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">plus<type></type></td>
<td>equal_to<type></type></td>
<td>logical_and<type></type></td>
</tr>
<tr>
<td style="text-align:center">minus<type></type></td>
<td>not_equal_to<type></type></td>
<td>logical_or<type></type></td>
</tr>
<tr>
<td style="text-align:center">multiplies<type></type></td>
<td>greater<type></type></td>
<td>logical_not<type></type></td>
</tr>
<tr>
<td style="text-align:center">divides<type></type></td>
<td>greater_equal<type></type></td>
</tr>
<tr>
<td style="text-align:center">modulus<type></type></td>
<td>less<type></type></td>
</tr>
<tr>
<td style="text-align:center">negate<type></type></td>
<td>less_equal<type></type></td>
</tr>
</tbody>
</table>
<ol start="6">
<li>这些表示运算符的函数对象类通常用来替换算法中的默认运算符：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> IntVec<span class="token punctuation">{</span> <span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">5</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
 std<span class="token operator">::</span><span class="token function">sort</span><span class="token punctuation">(</span>IntVec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> IntVec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span>greater<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li>C++语言中有几种可调用的对象：函数、函数指针、lambda表达式、bind创建的对象、重载了函数调用运算符的类。</li>
<li>不同类型的可调用对象可能拥有同一种调用形式。调用形式指明了调用返回的类型以及传递给调用的实参类型。比如下面这几个可调用对象：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token comment" spellcheck="true">//普通函数</span>
 <span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> i <span class="token operator">+</span> j<span class="token punctuation">;</span> <span class="token punctuation">}</span>
 <span class="token comment" spellcheck="true">//lambda，其产生一个未命名的函数对象类</span>
 <span class="token keyword">auto</span> mod <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> i<span class="token operator">%</span>j<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
 <span class="token comment" spellcheck="true">//函数对象类</span>
 <span class="token keyword">class</span> <span class="token class-name">divide</span>
 <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
     <span class="token keyword">int</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span>
     <span class="token punctuation">{</span>
         <span class="token keyword">return</span> i <span class="token operator">/</span> j<span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
 它们的调用形式都是：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li>假设我们现在想要写一个简单的计算器，希望定义一个函数表来存储指向这些可调用对象的“指针”：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token comment" spellcheck="true">//构建从运算符名字到相应函数指针的映射关系，其中函数接受两个int、返回一个int</span>
 std<span class="token operator">::</span>map<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> CalMaps<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
 我们可以把add添加进去：<pre class="line-numbers language-cpp"><code class="language-cpp"> CalMaps<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token string">"+"</span><span class="token punctuation">,</span>add <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
 但是我们却无法把mod或divide添加进去（在VS里mod似乎可以~）：<pre class="line-numbers language-cpp"><code class="language-cpp"> CalMaps<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token string">"/"</span><span class="token punctuation">,</span><span class="token function">divide</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//错误，mod不是一个函数指针</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
 这是因为它们都有自己的类类型，并不是一个函数指针，所以无法作为值添加到CalMaps中。<br> 我们可以用function模板类来把这些调用对象统一成它们相同的调用形式：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
 我们可以：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> f1 <span class="token operator">=</span> add<span class="token punctuation">;</span>
 std<span class="token operator">::</span>function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> f1 <span class="token operator">=</span> mod<span class="token punctuation">;</span>
 std<span class="token operator">::</span>function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> f1 <span class="token operator">=</span> <span class="token function">divide</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
 所以我们可以解决这个问题了：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token comment" spellcheck="true">//构建从运算符名字到相应函数指针的映射关系，其中函数接受两个int、返回一个int</span>
 std<span class="token operator">::</span>map<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token punctuation">,</span> std<span class="token operator">::</span>function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">>></span> CalMaps<span class="token punctuation">;</span>
 CalMaps<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token string">"+"</span><span class="token punctuation">,</span>add <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 CalMaps<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token string">"%"</span><span class="token punctuation">,</span>mod <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 CalMaps<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token string">"/"</span><span class="token punctuation">,</span><span class="token function">divide</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<p><font size="5" color="orange">重载、类型转换与运算符</font></p>
<hr>
<ol>
<li>类型转换构造函数和类型转换运算符共同定义了类类型转换，也叫用户定义的类型转换。</li>
<li><p>类型转换运算符是类的一种特殊成员函数，它负责将一个类类型的值转换成其他类型。类型转换函数的一般形式如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">operator</span> <span class="token function">type</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p> 其中type表示除了void之外的任意类型，比如int、int*、int(*)(int, int)等等。</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">class</span> <span class="token class-name">CData</span>
 <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
     <span class="token function">CData</span><span class="token punctuation">(</span><span class="token keyword">int</span> vData<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">m_Data</span><span class="token punctuation">(</span>vData<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>      <span class="token comment" spellcheck="true">//类型转换构造函数，负责把int转换为CData</span>
     <span class="token keyword">operator</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> m_Data<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//类型转换运算符，负责将CData转换为int</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
     <span class="token keyword">int</span> m_Data <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>

 CData <span class="token function">DataObj</span><span class="token punctuation">(</span><span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 DataObj <span class="token operator">=</span> <span class="token number">41</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//首先将41隐式地转换为CData，然后调用合成的CData::operator=</span>
 <span class="token keyword">int</span> k <span class="token operator">=</span> DataObj <span class="token operator">+</span> <span class="token number">14</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//首先将DataObj隐式地转换为int，然后执行整数的加法</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>类型转换运算符既没有显式的返回类型，也没有形参，而且必须定义成类的成员函数。而且它通常不应该改变待转换对象的内容，所以通常也被定义成const成员。</li>
<li><p>在实践中，类很少提供类型转换运算符。因为在多数情况下，如果类型转换自动发生，使用该类的用户可能会感觉比较意外，而不是感觉受到了帮助。如果我们确实需要这种类型转换，但有不想让编译器进行自动转换（隐式转换），我们可以把这个类型转换运算符成员函数定义成显式的：用explicit声明：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">class</span> <span class="token class-name">CData</span>
 <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
     <span class="token function">CData</span><span class="token punctuation">(</span><span class="token keyword">int</span> vData<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">m_Data</span><span class="token punctuation">(</span>vData<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
     <span class="token keyword">explicit</span> <span class="token keyword">operator</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> m_Data<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//类型转换运算符，负责将CData转换为int</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
     <span class="token keyword">int</span> m_Data <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 这叫做显式的类型转换运算符。用户在需要类型转换时，需要使用static_cast<type>来强制转换：</type></p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span>DataObj<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">14</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//首先将DataObj显式地转换为int，然后执行整数的加法</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p> 这样用户就不会感觉到意外了吧！</p>
<p> 大多数情况下，编译器都不会自动执行显式类型转换运算符的，不过将其用作条件时除外。比如把DataObj用作if、while的条件，这时编译器会自动执行显式的类型转换运算符。</p>
</li>
<li>不要令两个类执行相同的类型转换：如果Foo类有一个接受Bar类对象的构造函数，则不要在Bar类中再定义转换目标是Foo类的类型转换运算符。因为这个构造函数和这个类型转换运算符完成的功能都是：把Bar类型转换成Foo类型。如果需要执行<code>Foo = Bar;</code>这种类似的转换，那么到底是用那个构造函数还是那个类型转换运算符呢？这就出现了二义性，程序将报错。</li>
<li>最好不要创建两个转换源都是算术类型的转换构造函数；最好不要创建两个转换对象都是算术类型的类型转换运算符函数。<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">class</span> <span class="token class-name">CData</span>
 <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
     <span class="token function">CData</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//最好不要创建两个转换源都是算术类型的转换构造函数</span>
     <span class="token function">CData</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token keyword">operator</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//最好不要创建两个转换对象都是算术类型的类型转换运算符函数</span>
     <span class="token keyword">operator</span> <span class="token keyword">double</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
 如果出现<code>CData(long);</code>这种形式的转换，那到底是用第一个构造函数还是第二个构造函数呢？会出现二义性错误。如果出现<code>long = CData;</code>这种形式的转换，那到底是用int形式的类型转换运算符还是double形式的类型转换运算符呢？也会出现二义性错误。</li>
<li>除了显式地向bool类型的转换之外，我们应该尽量避免定义类型转换函数，并尽可能地限制那些“显然正确”的非显式构造函数。</li>
<li><p>如果我们对同一个类既提供了算术类型的类型转换构造函数和类型转换运算符，还提供了重载的运算符，则将会遇到重载运算符和内置运算符的二义性问题：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">class</span> <span class="token class-name">CData</span>
 <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
     <span class="token function">CData</span><span class="token punctuation">(</span><span class="token keyword">int</span> vData<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">m_Data</span><span class="token punctuation">(</span>vData<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//类型转换构造函数</span>
     <span class="token keyword">operator</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> m_Data<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//类型转换运算符</span>
     CData<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span><span class="token keyword">const</span> CData<span class="token operator">&amp;</span> vData<span class="token punctuation">)</span> <span class="token punctuation">{</span> m_Data <span class="token operator">+</span><span class="token operator">=</span> vData<span class="token punctuation">.</span>m_Data<span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
 <span class="token keyword">private</span><span class="token operator">:</span>
     <span class="token keyword">int</span> m_Data <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>

 CData <span class="token function">DataObj</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">int</span> i <span class="token operator">=</span> DataObj <span class="token operator">+</span> <span class="token number">14</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//二义性错误</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 在执行<code>DataObj + 14</code>时，可以先把DataObj用类型转换运算符转换成int，再执行内置类型的加法运算；也可以先把14用类型转换构造函数转换成CData类型，再用重载的加法运算符来执行加法运算。这就出现了二义性。<br>&nbsp; </p>
</li>
</ol>
<hr>
<p>参考文献：《C++Primer第五版》</p>

            </div>

            <!-- Post Comments -->
            
    <!-- 使用 DISQUS_CLICK -->
<div id="disqus-comment">
    <div id="disqus_thread"></div>

<!-- add animation -->
<style>
	.disqus_click_btn {
            line-height: 30px;
            margin: 0;
            min-width: 50px;
            padding: 0 14px;
            display: inline-block;
            font-family: "Roboto", "Helvetica", "Arial", sans-serif;
            font-size: 14px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0;
            overflow: hidden;
            will-change: box-shadow;
            transition: box-shadow .2s cubic-bezier(.4, 0, 1, 1), background-color .2s cubic-bezier(.4, 0, .2, 1), color .2s cubic-bezier(.4, 0, .2, 1);
            outline: 0;
            cursor: pointer;
            text-decoration: none;
            text-align: center;
            vertical-align: middle;
            border: 0;
            background: rgba(158, 158, 158, .2);
            box-shadow: 0 2px 2px 0 rgba(0, 0, 0, .14), 0 3px 1px -2px rgba(0, 0, 0, .2), 0 1px 5px 0 rgba(0, 0, 0, .12);
            color: #fff;
            background-color: #7EC0EE;
            text-shadow: 0
        }
</style>
	
<div class="btn_click_load" id="disqus_bt"> 
    <button class="disqus_click_btn">点击查看评论</button>
</div>

<!--
<script type="text/javascript">
$('.btn_click_load').click(function() {
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'http-miccall-tech'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    document.getElementById('disqus_bt').style.display = "none";
});
</script>
-->
<script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://yoursite.com/2018/03/31/C++Primer第十四章重载运算与类型转换/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = 'http://yoursite.com/2018/03/31/C++Primer第十四章重载运算与类型转换/'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
</script>

<script type="text/javascript">
    $('.btn_click_load').click(function() {  //click to load comments
        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document;
            var s = d.createElement('script');
            s.src = '//http-miccall-tech.disqus.com/embed.js';
            s.setAttribute('data-timestamp', + new Date());
            (d.head || d.body).appendChild(s);
        })();
        $('.btn_click_load').css('display','none');
    });
</script>
</div>
<style>
    #disqus-comment{
        background-color: #eee;
        padding: 2pc;
    }
</style>


        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
                <li>Design: <a href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
            </ul>
            
            	<span id="busuanzi_container_site_pv">2019总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			
        </div>
    </div>
</body>



 	
</html>
