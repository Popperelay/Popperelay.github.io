<!DOCTYPE HTML>
<html>

<head><meta name="generator" content="Hexo 3.9.0">
	<link rel="bookmark" type="image/x-icon" href="/img/logo_miccall.png">
	 <link rel="shortcut icon" href="/img/logo_miccall.png">
	
			
    <title>
    Elays'Blog
    </title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <link rel="stylesheet" href="/css/mic_main.css">
    <link rel="stylesheet" href="/css/dropdownMenu.css">
    
    	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css">
    </noscript>
			    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<link rel="stylesheet" href="/css/prism-dark.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>
    
		
<!-- Layouts -->


<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<!--<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">-->
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/latest.js?config=TeX-MML-AM_CHTML">
</script>

<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_undefined.css">
<link rel="stylesheet" href="/css/typo.css">
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">MICCALL</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special">
            <ul class="menu links">
			<!-- Homepage  主页  --> 
			<li>
	            <a href="/" rel="nofollow">主页</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">分类</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="/categories/C/">C#</a></li><li><a class="category-link" href="/categories/C-语法/">C#语法</a></li><li><a class="category-link" href="/categories/C/">C++</a></li><li><a class="category-link" href="/categories/C语言/">C语言</a></li><li><a class="category-link" href="/categories/Graphics/">Graphics</a></li><li><a class="category-link" href="/categories/Math/">Math</a></li><li><a class="category-link" href="/categories/OpenGL/">OpenGL</a></li><li><a class="category-link" href="/categories/Unity/">Unity</a></li><li><a class="category-link" href="/categories/博客配置/">博客配置</a></li><li><a class="category-link" href="/categories/并行计算/">并行计算</a></li><li><a class="category-link" href="/categories/操作系统/">操作系统</a></li><li><a class="category-link" href="/categories/数据结构/">数据结构</a></li><li><a class="category-link" href="/categories/毕设/">毕设</a></li><li><a class="category-link" href="/categories/游戏开发/">游戏开发</a></li><li><a class="category-link" href="/categories/计算机系统/">计算机系统</a></li><li><a class="category-link" href="/categories/设计模式/">设计模式</a></li><li><a class="category-link" href="/categories/面试/">面试</a>
	                    </li></ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/gallery/" title="图库">
		                图库
		            </a>
		        </li>
		        
		        <li>
		            <a href="/tag/" title="搜索">
		                搜索
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
		            
		                <li><a href="https://github.com/miccall" class="icon fa-github"><span class="label">GitHub</span></a></li>
		            
		            
		            
		            
			</ul>
</nav>

        <div id="main">
            <div class="post_page_title_img" style="height: 25rem;background-image: url(https://github.com/Popperelay/Photos/blob/master/Photos/C++Primer%E7%AC%AC12%E7%AB%A0.jpg?raw=true);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;">
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2>C++Primer第十二章 动态内存</h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
				<!-- 目录 -->
				<p class="show-toc-btn" id="show-toc-btn" onclick="showToc();" style="display:none">
				<span class="btn-bg"></span>
				<span class="btn-text">文章导航</span>
				</p>
				<div id="toc-article" class="toc-article">
					<span id="toc-close" class="toc-close" title="隐藏导航" onclick="showBtn();">×</span>
					<strong class="toc-title">文章目录</strong>
					
			   </div>
			   <script type="text/javascript">
				function showToc(){
					var toc_article = document.getElementById("toc-article");
					var show_toc_btn = document.getElementById("show-toc-btn");
					toc_article.setAttribute("style","display:block");
					show_toc_btn.setAttribute("style","display:none");
					};
				function showBtn(){
					var toc_article = document.getElementById("toc-article");
					var show_toc_btn = document.getElementById("show-toc-btn");
					toc_article.setAttribute("style","display:none");
					show_toc_btn.setAttribute("style","display:block");
					};
			   </script>
				
				<script>
					(function(){
						if('{{ page.password }}'){
							if (prompt('请输入文章密码') !== '{{ page.password }}'){
								alert('密码错误！');
								history.back();
							}
						}
					})();
				</script>
				
                <p><font size="5" color="orange">概述</font></p>
<hr>
<ol>
<li>静态内存用来保存局部static对象、类static数据成员以及定义在任何函数之外的变量。栈内存用来保存定义在函数内的非static对象。分配在静态或栈内存中的对象由编译器自动创建和销毁。对于栈对象，仅在其定义的程序块运行时才存在；static对象在使用之前分配，在程序结束时销毁。</li>
<li>除了静态内存和栈内存，每个程序还拥有一个内存池。这部分内存被称作自由空间或堆。程序用堆来存储动态分配的对象，即那些在程序运行时分配的对象。动态对象的生存期由程序来控制，也就是说，当动态对象不再使用时，我们的代码必须显式地销毁它们。</li>
</ol>
<p><font size="5" color="orange">动态内存与智能指针</font></p>
<hr>
<ol>
<li>为了更容易、更安全地使用动态内存，新标准库提供了三种智能指针类型来管理动态对象：shared_ptr和unique_ptr。它们和普通指针的重要区别是它们负责自动释放所指向的对象。shared_ptr允许多个指针指向同一个对象；unique_ptr则独占所指向的对象。</li>
<li>标准库还定义了一个名为weak_ptr的伴随类，它是一种弱引用，指向shared_ptr所管理的对象。</li>
<li>shared_ptr、unique_ptr和weak_ptr都定义在头文件memory中。</li>
<li>智能指针其实是在普通指针上作了一些包装，包括自动释放内存、指向同一对象的指针指针数量（用智能指针类中的计数器保存）等等。</li>
<li>智能指针也是模板类，默认初始化的智能指针中保存着一个空指针：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> p1<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//shared_ptr，可以指向string对象，现在还是空指针</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li>使用智能指针的get成员函数可以获得对应的普通指针：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> p1<span class="token punctuation">;</span>
 <span class="token keyword">auto</span> p <span class="token operator">=</span> p1<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//p是string*类型</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li>shared_ptr独有的操作如下表：</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">make_shared<t>(args)</t></td>
<td>返回一个shared_ptr，指向一个动态分配的类型为T的对象，使用args初始化该对象</td>
</tr>
<tr>
<td style="text-align:center">shared_ptr<t>p(q)</t></td>
<td>p是shared_ptr q的拷贝，此操作会递增q中的计算器。q中的指针必须能转换为T*</td>
</tr>
<tr>
<td style="text-align:center">p=q</td>
<td>p和q都是shared_ptr，所保存的指针必须能相互转换。此操作会递减p的引用计数，递增q的引用计数；若p的引用计数变为0，则将其管理的原内存释放</td>
</tr>
<tr>
<td style="text-align:center">p.unique()</td>
<td>若p.use_count()为1，返回true，否则返回false</td>
</tr>
<tr>
<td style="text-align:center">p,use_count()</td>
<td>返回一个与p共享对象的智能指针数量；可能很慢，主要用于测试</td>
</tr>
</tbody>
</table>
<ol start="8">
<li>我们可以用make_shared函数代替new来生成一个指针，这样更安全，同时不需要匹配的delete操作，因为智能指针在计算器变为0时会自动调用delete：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> p1 <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
 当然用auto来保存make_shared的结果更简单：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">auto</span> p1 <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li>每个shared_ptr都有一个关联的计数器，通常称其为引用计数。无论何时我们拷贝一个shared_ptr，计数器都会增加，当我们给shared_ptr赋予一个新值或是shared_ptr被销毁（例如局部shared_ptr离开其作用域）时，计数器就会递减。一旦一个shared_ptr的计数器变为0，它就会自动释放自己所管理的对象。</li>
<li>当指向一个对象的最后一个shared_ptr被销毁时，shared_ptr类会自动销毁此对象。它是通过析构函数来完成销毁工作的。shared_ptr的析构函数会递减它所指向的对象的引用计数。如果引用计数变为0，shared_ptr的析构函数就会销毁对象，并释放它占用的内存。</li>
<li>如果将shared_ptr存放于一个容器中，而后不再需要全部元素，而只使用其中一部分，要记得用erase删除不再使用的那些元素，否则它们占用的内存将无法释放。</li>
<li>使用动态内存的一个常见原因是允许多个对象共享相同的状态。</li>
<li>使用new进行动态内存分配时，不带()的执行默认初始化，值是未定义的，带()的执行值初始化：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//*p的值是未定义的</span>
<span class="token keyword">int</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//*p2 = 0</span>
std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//本机输出-842150451</span>
std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p2 <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//输出0</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>默认情况下，如果new不能分配所要求的内存空间，它会抛出一个类型为bad_alloc的异常。我们可以改变使用new的方式来阻止它抛出异常：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">//如果分配失败，new抛出std::bad_alloc异常</span>
<span class="token keyword">int</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>nothrow<span class="token punctuation">)</span> <span class="token keyword">int</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//如果分配失败，new返回一个空指针，不抛出异常</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
我们称这种形式的new为定位new。定位new表达式允许我们向new传递额外的参数。这里我们传递的是标准库的一个名为nothrow的对象，告诉它不能抛出异常。bad_alloc和nothrow都定义在头文件new中。</li>
<li>通常情况下，编译器不能分辨一个指针指向的是静态还是动态分配的对象。类似的，编译器也不能分辨一个指针所指向的内存是否已经被释放了。</li>
<li>使用new和delete管理动态内存存在三个问题：<ul>
<li>忘记delete内存。忘记释放动态内存会导致人们常说的“内存泄漏”问题，因为这种内存永远不可能被归还给自由空间了。</li>
<li>使用已经释放掉的对象。通过在释放内存后将指针置位空，有时可以检测出这种错误（delete p; p = nullptr）。</li>
<li>同一块内存释放两次。</li>
</ul>
</li>
<li>坚持使用智能指针，就可以避免所有这些问题。对于一块内存，只有在没有任何智能指针指向它的情况下，智能指针才会自动释放它。</li>
<li><p>接受指针参数的智能指针构造函数时explicit的，我们不能进行内置指针到智能指针之间的隐式转换：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//正确：使用了直接初始化形式</span>
std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//错误：不能将普通指针隐式转换为智能指针</span>

std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//错误：不能将普通指针隐式转换为智能指针</span>
<span class="token punctuation">}</span>
std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">clone1</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//正确，显式创建智能指针</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>定义智能指针时还可以增加一个参数来代替delete，这个参数必须是一个可调用对象：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p1</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>vp<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">delete</span> vp<span class="token punctuation">;</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"delete"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
当智能指针p1离开其作用域时，如果其计数器变为0，将会执行这个可调用的lambda表达式，输出字符串delete。</li>
<li>智能指针还有一个名叫reset的成员函数：<ul>
<li><code>p.reset();</code> ：若p是唯一指向其对象的shared_ptr，reset会释放此对象</li>
<li><code>p.reset(q);</code>：令p指向指针q</li>
<li><code>p.reset(q, d);</code>：令p指向q，并且调用对象d而不是delete来释放q</li>
</ul>
</li>
<li><p>不要混合使用普通指针和智能指针：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> vp<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">process</span><span class="token punctuation">(</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//合法，但函数退出后p指向的内存会被释放，p称为悬空指针</span>
<span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>    
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当将一个shared_ptr绑定到一个普通指针时，我们就将内存的管理责任交给了这个shared_ptr。一旦这样做了，我们就不应该再使用内置指针来问shared_ptr所指向的内存了。</p>
</li>
<li>不要用智能指针的get成员函数返回的普通指针，去初始化另一个智能指针：<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> q <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">{</span>
    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">TempP</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//逻辑错误：两个独立的shared_ptr指向相同的内存</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> foo <span class="token operator">=</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//未定义：p指向的内存已经被释放了</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>发生异常后，智能指针指向的内存会被正常释放，但是普通指针指向的内存就永远不会被释放了（在delete之前发生异常）：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">sp</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//这段代码发生异常</span>
<span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//函数结束时，shared_ptr自动释放内存</span>

<span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//这段代码发生异常</span>
    <span class="token keyword">delete</span> p<span class="token punctuation">;</span>
<span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//发生异常后，p指向的内存永远不会被释放</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>无论是否发生异常，局部对象都会被销毁，所以发生异常后sp会被销毁，但是delete p永远执行不到。这个特性对建立局部网络连接的代码很有用，如果代码是这样的：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> SDestination<span class="token punctuation">;</span>
<span class="token keyword">struct</span> SConnection<span class="token punctuation">;</span>
SConnection <span class="token function">connect</span><span class="token punctuation">(</span>SDestination<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//打开连接</span>
<span class="token keyword">void</span> <span class="token function">disconnect</span><span class="token punctuation">(</span>SConnection<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//关闭连接</span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>SDestination <span class="token operator">&amp;</span>d<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    SConnection Conn <span class="token operator">=</span> <span class="token function">connect</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//使用连接</span>
    <span class="token comment" spellcheck="true">//如果我们在f退出前忘记调用disconnect，或者在调用它之前发生了异常，就无法关闭连接Conn了</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>为了保证函数退出时关闭连接，我们可以使用智能指针：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> SDestination<span class="token punctuation">;</span>
<span class="token keyword">struct</span> SConnection<span class="token punctuation">;</span>
SConnection <span class="token function">connect</span><span class="token punctuation">(</span>SDestination<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//打开连接</span>
<span class="token keyword">void</span> <span class="token function">disconnect</span><span class="token punctuation">(</span>SConnection<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//关闭连接</span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>SDestination <span class="token operator">&amp;</span>d<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    SConnection Conn <span class="token operator">=</span> <span class="token function">connect</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>SConnection<span class="token operator">></span> <span class="token function">p</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Conn<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>SConnection <span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">disconnect</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//使用连接</span>
    <span class="token comment" spellcheck="true">//即使我们在f退出前忘记调用disconnect，或者在调用它之前发生了异常，Conn也会被正确关闭</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>即使发生了异常或者忘记调用disconnect，连接也会被正常关闭，因为函数退出时会释放局部对象p，p在被销毁时会调用lambda表达式来关闭连接。</p>
</li>
<li>为了正确使用智能指针，我们必须坚持一些规范：<ul>
<li>不使用相同的内置指针初始化（或reset）多个智能指针</li>
<li>不delete get()返回的指针</li>
<li>不使用get()返回的指针去初始化或reset另一个智能指针</li>
<li>如果使用get返回的普通指针，记住当最后一个对应的智能指针被销毁后，这个普通指针就失效了</li>
<li>如果使用智能指针管理的资源不是new分配的内存，记住传递给它一个删除器（代替delete的可调用对象）</li>
</ul>
</li>
<li>与shared_ptr不同，某个时刻只能有一个unique_ptr指向一个给定对象。当unique_ptr被销毁时，它所指向的对象也被销毁。而且没有类似make_shader的标准库函数来返回一个unique_ptr。当我们定义一个unique_ptr时，需要将其绑定到一个new返回的指针上或默认初始化，因为它不支持拷贝和赋值操作（独占内存所致）：<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> p1<span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">//p1是一个指向int类型的空指针</span>
std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p2</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//p2指向一个值为42的int</span>
std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p3</span><span class="token punctuation">(</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//错误：unique_ptr不支持拷贝</span>
p1 <span class="token operator">=</span> p2<span class="token punctuation">;</span>                               <span class="token comment" spellcheck="true">//错误：unique_ptr不支持赋值</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>虽然不能拷贝或赋值unique_ptr，但可以通过release算法unique_ptr对指针的控制权，然后将其转移给另一个unique_ptr：<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//p2指向一个值为42的int</span>
std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p2</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//将p1的控制权转移给p2</span>
p1<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span>p2<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">//将p2的控制权转移给p1</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
如果我们不用另一个智能指针来保存release返回的普通指针，我们的程序就要负责delete掉该指针。</li>
<li>不能拷贝unique_ptr的规则有一个例外：我们可以拷贝或赋值一个将要被销毁的unique_ptr（因为通常会对它们指向移动拷贝或移动赋值，见13章）：<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">sp</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> sp<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//正确：可以对一个将要被销毁的unique_ptr赋值或拷贝</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>和shared_ptr类似，我们也可以像unique_ptr传递一个自定义的删除器，不同的是，定义时必须显式制定出删除器的模板类型：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">deleteFunc</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">delete</span> p<span class="token punctuation">;</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"delete"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>deleteFunc<span class="token punctuation">)</span><span class="token operator">*</span><span class="token operator">></span> <span class="token function">p1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">,</span> deleteFunc<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>weak_ptr是一种不控制所指向对象生存期的智能指针，它指向由一个shared_ptr管理的对象。将一个weak_ptr绑定到一个shared_ptr不会改变shared_ptr的引用计数。一旦最后一个指向对象的shared_ptr被销毁，对象就会被释放，即使有weak_ptr指向对象，对象也还是会被释放。</p>
<p>当我们创建一个weak_ptr时，要用一个shared_ptr来初始化它：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> sp <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token operator">::</span>weak_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">wp</span><span class="token punctuation">(</span>sp<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//wp弱共享sp，sp的引用计数未改变</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>weak_ptr特有的成员操作如下：</p>
<ul>
<li>w.use_count()：与w共享对象的shared_ptr的数量</li>
<li>w.expired()：若w.use_count()为0，返回true，否则返回false</li>
<li>w.lock()：如果expired为true，返回一个空的shared_ptr；否则返回一个指向w的对象的shared_ptr</li>
</ul>
<p>从上面可以看出weak_ptr所指向的对象可能不存在，所以我们不能使用weak_ptr直接访问对象，而必须调用lock：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> vSp <span class="token operator">=</span> wp<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//在if中使用vSp访问共享对象是安全的</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<p><font size="5" color="orange">动态数组</font></p>
<hr>
<ol>
<li>标准库包含一个名为allocator的类，允许我们将分配和初始化分离。使用allocator通常会提供更好的性能和更灵活的内存管理能力。</li>
<li>大多数应用应该使用标准库容器而不是动态分配的数组。使用容器更为简单、更不容易出现内存管理错误并且可能有更好的性能。</li>
<li>我们用new分配的动态数组并不是数组类型，所以不能对动态数组调用begin或end：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
 <span class="token keyword">auto</span> it <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">begin</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//正确：可以对数组类型调用begin函数</span>
 <span class="token keyword">int</span> <span class="token operator">*</span>b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
 <span class="token function">memset</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">auto</span> it2 <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">begin</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//错误：不能对动态数组调用begin函数</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>释放动态数组时，需要在delete之后、指针名之前加上一个[ ]：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> <span class="token operator">*</span>b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
 <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
 动态数组中的元素按逆序销毁，即最后一个元素先被销毁，然后是倒数第二个…。</li>
<li>标准库提供了一个可以管理new分配的数组的unique_ptr版本，需要在模板参数的对象类型后面跟一个方括号：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> <span class="token function">up</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 up<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//自动调用delete[]销毁其指针</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
 但是如果要使用shared_ptr来管理一个动态数组，必须提供自定义的删除器：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">sp</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> p<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 sp<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//使用我们提供的lambda释放数组，它使用delete[]</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p>unique_ptr管理的动态数组可以通过下标来访问元素，但是shared_ptr不可以，它没有定义下标运算符。而且智能指针类型不支持指针算术运算。因此shared_ptr为了访问数组中的元素，必须先用get获取一个内置指针，然后用它来访问素组元素：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> <span class="token function">up</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
     up<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>

 std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">sp</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> p<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
     <span class="token operator">*</span><span class="token punctuation">(</span>sp<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> i<span class="token punctuation">)</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>当分配一大块内存时，我们通常计划在这块内存还是那个按需构造对象。在此情况下，我们希望将内存分配和对象构造分离。这意味着我们可以分配大块内存，但只在真正需要时才真正执行对象创建操作。</li>
<li>标准库allocator类定义在头文件memory中，它帮助我们将内存分配和对象构造分离开来。allocator也是一个模板，它会根据给定的对象类型来确定恰当的内存大小和对齐位置：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>allocator<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> Alloc<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//可以分配string的allocator对象</span>
 <span class="token keyword">auto</span> <span class="token keyword">const</span> p <span class="token operator">=</span> Alloc<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//分配n个未初始化的string</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
 allocator类的成员操作如下表：</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">allocator<t> a</t></td>
<td>定义一个allocator对象，它可以为类型为T的对象分配内存</td>
</tr>
<tr>
<td style="text-align:center">a.allocate(n)</td>
<td>分配一段原始的、未构造的内存，保存n个类型为T的对象</td>
</tr>
<tr>
<td style="text-align:center">a.deallocate(p, n)</td>
<td>释放从T*指针p中地址开始的内存，这块内存保存了n个类型为T的对象；p必须是一个先前由allocate返回的指针，且n必须是p创建时所要求的大小。在调用deallocate之前，用户必须对每个在这块内存中创建的对象调用destroy</td>
</tr>
<tr>
<td style="text-align:center">a.construct(p, args)</td>
<td>p必须是一个类型为T*的指针，指向一块原始内存；args被传递给类型为T的构造函数，用来在p指向的内存中构造一个对象</td>
</tr>
<tr>
<td style="text-align:center">a.destroy(p)</td>
<td>p为T*类型的指针，此算法对p指向的对象执行析构函数</td>
</tr>
</tbody>
</table>
<ol start="9">
<li>allocator分配的内存是未构造的，我们需要在此内存中构造对象，而construct成员函数接受一个指针和零个或多个额外参数，在指针所指的位置构造一个元素：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">auto</span> q <span class="token operator">=</span> p<span class="token punctuation">;</span>
 Alloc<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>q<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//*q为空字符串</span>
 Alloc<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>q<span class="token operator">++</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//*q为10个字符c组成的字符串</span>
 Alloc<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>q<span class="token operator">++</span><span class="token punctuation">,</span> <span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//*q为字符串hello</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
 还未构造对象的情况下就使用原始内存是错误的：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>allocator<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> Alloc<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//可以分配string的allocator对象</span>
 <span class="token keyword">auto</span> <span class="token keyword">const</span> p <span class="token operator">=</span> Alloc<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//分配n个未初始化的string</span>
 std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//错误：程序崩溃，因为p指向未构造的内存</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li>当我们用完对象后，必须对每个构造的元素调用destroy来销毁它们。函数destroy接受一个指针，对指向的对象执行析构函数：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">while</span> <span class="token punctuation">(</span>q <span class="token operator">!=</span> p<span class="token punctuation">)</span>
    Alloc<span class="token punctuation">.</span><span class="token function">destroy</span><span class="token punctuation">(</span><span class="token operator">--</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li>销毁这些被构造出来的元素以后，我们就可以使用deallocate成员函数把内存归还给系统了（当然也可以拿这些内存再去构造新的对象）。所以allocator使用四部曲就是：allocate、construct、destroy、deallocate：<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>allocator<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> Alloc<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//可以分配string的allocator对象</span>
<span class="token keyword">auto</span> <span class="token keyword">const</span> p <span class="token operator">=</span> Alloc<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//分配n个未初始化的string</span>
<span class="token keyword">auto</span> q <span class="token operator">=</span> p<span class="token punctuation">;</span>
Alloc<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>q<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//*q为空字符串</span>
Alloc<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>q<span class="token operator">++</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//*q为10个字符c组成的字符串</span>
Alloc<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>q<span class="token operator">++</span><span class="token punctuation">,</span> <span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//*q为字符串hello</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>q <span class="token operator">!=</span> p<span class="token punctuation">)</span>
    Alloc<span class="token punctuation">.</span><span class="token function">destroy</span><span class="token punctuation">(</span><span class="token operator">--</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment" spellcheck="true">//销毁每个构造出来的对象</span>
Alloc<span class="token punctuation">.</span><span class="token function">deallocate</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">//第二个参数必须与allocate分配内存时指定的参数相同</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>标准库还为allocator类定义了两个伴随算法：copy和fill，用于在未初始化内存（原始内存）中创建对象，定义在头文件memory中：<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> SVec<span class="token punctuation">{</span> <span class="token string">"Hello"</span><span class="token punctuation">,</span><span class="token string">"World"</span><span class="token punctuation">,</span><span class="token string">"Nice"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
std<span class="token operator">::</span>allocator<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> Alloc<span class="token punctuation">;</span>
<span class="token keyword">auto</span> p <span class="token operator">=</span> Alloc<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span>SVec<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//通过拷贝SVec中的元素来构造原始内存从p开始的元素</span>
<span class="token keyword">auto</span> q <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">uninitialized_copy</span><span class="token punctuation">(</span>SVec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> SVec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//将原始内存中剩余的未构造元素初始化为字符串Same</span>
std<span class="token operator">::</span><span class="token function">uninitialized_fill_n</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> SVec<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"Same"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">uninitialized_copy(b, e, b2)</td>
<td>将迭代器b到e范围内的元素拷贝到迭代器b2指向的未构造的原始内存中</td>
</tr>
<tr>
<td style="text-align:center">uninitialized_copy_n(b, n, b2)</td>
<td>从迭代器b指向的元素开始，拷贝n个元素到b2指向的原始内存中</td>
</tr>
<tr>
<td style="text-align:center">uninitialized_fill(b, e, t)</td>
<td>在迭代器b到e的元素内存范围内构造对象，对象的值均为t的拷贝</td>
</tr>
<tr>
<td style="text-align:center">uninitialized_fill_n(b, n, t)</td>
<td>从迭代器b指向的元素内存开始创建n个对象，对象的值均为t的拷贝</td>
</tr>
</tbody>
</table>
<p><font size="5" color="orange">使用标准库：文本查询程序</font></p>
<hr>
<ol>
<li>-_-||，最近比较忙，比较忙。。。有时间再来补上了(*￣︶￣)</li>
</ol>
<p><font size="5" color="orange">概述</font></p>
<hr>
<ol>
<li>静态内存用来保存局部static对象、类static数据成员以及定义在任何函数之外的变量。栈内存用来保存定义在函数内的非static对象。分配在静态或栈内存中的对象由编译器自动创建和销毁。对于栈对象，仅在其定义的程序块运行时才存在；static对象在使用之前分配，在程序结束时销毁。</li>
<li>除了静态内存和栈内存，每个程序还拥有一个内存池。这部分内存被称作自由空间或堆。程序用堆来存储动态分配的对象，即那些在程序运行时分配的对象。动态对象的生存期由程序来控制，也就是说，当动态对象不再使用时，我们的代码必须显式地销毁它们。</li>
</ol>
<p><font size="5" color="orange">动态内存与智能指针</font></p>
<hr>
<ol>
<li>为了更容易、更安全地使用动态内存，新标准库提供了三种智能指针类型来管理动态对象：shared_ptr和unique_ptr。它们和普通指针的重要区别是它们负责自动释放所指向的对象。shared_ptr允许多个指针指向同一个对象；unique_ptr则独占所指向的对象。</li>
<li>标准库还定义了一个名为weak_ptr的伴随类，它是一种弱引用，指向shared_ptr所管理的对象。</li>
<li>shared_ptr、unique_ptr和weak_ptr都定义在头文件memory中。</li>
<li>智能指针其实是在普通指针上作了一些包装，包括自动释放内存、指向同一对象的指针指针数量（用智能指针类中的计数器保存）等等。</li>
<li>智能指针也是模板类，默认初始化的智能指针中保存着一个空指针：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> p1<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//shared_ptr，可以指向string对象，现在还是空指针</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li>使用智能指针的get成员函数可以获得对应的普通指针：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> p1<span class="token punctuation">;</span>
 <span class="token keyword">auto</span> p <span class="token operator">=</span> p1<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//p是string*类型</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li>shared_ptr独有的操作如下表：</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">make_shared<t>(args)</t></td>
<td>返回一个shared_ptr，指向一个动态分配的类型为T的对象，使用args初始化该对象</td>
</tr>
<tr>
<td style="text-align:center">shared_ptr<t>p(q)</t></td>
<td>p是shared_ptr q的拷贝，此操作会递增q中的计算器。q中的指针必须能转换为T*</td>
</tr>
<tr>
<td style="text-align:center">p=q</td>
<td>p和q都是shared_ptr，所保存的指针必须能相互转换。此操作会递减p的引用计数，递增q的引用计数；若p的引用计数变为0，则将其管理的原内存释放</td>
</tr>
<tr>
<td style="text-align:center">p.unique()</td>
<td>若p.use_count()为1，返回true，否则返回false</td>
</tr>
<tr>
<td style="text-align:center">p,use_count()</td>
<td>返回一个与p共享对象的智能指针数量；可能很慢，主要用于测试</td>
</tr>
</tbody>
</table>
<ol start="8">
<li>我们可以用make_shared函数代替new来生成一个指针，这样更安全，同时不需要匹配的delete操作，因为智能指针在计算器变为0时会自动调用delete：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> p1 <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
 当然用auto来保存make_shared的结果更简单：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">auto</span> p1 <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li>每个shared_ptr都有一个关联的计数器，通常称其为引用计数。无论何时我们拷贝一个shared_ptr，计数器都会增加，当我们给shared_ptr赋予一个新值或是shared_ptr被销毁（例如局部shared_ptr离开其作用域）时，计数器就会递减。一旦一个shared_ptr的计数器变为0，它就会自动释放自己所管理的对象。</li>
<li>当指向一个对象的最后一个shared_ptr被销毁时，shared_ptr类会自动销毁此对象。它是通过析构函数来完成销毁工作的。shared_ptr的析构函数会递减它所指向的对象的引用计数。如果引用计数变为0，shared_ptr的析构函数就会销毁对象，并释放它占用的内存。</li>
<li>如果将shared_ptr存放于一个容器中，而后不再需要全部元素，而只使用其中一部分，要记得用erase删除不再使用的那些元素，否则它们占用的内存将无法释放。</li>
<li>使用动态内存的一个常见原因是允许多个对象共享相同的状态。</li>
<li>使用new进行动态内存分配时，不带()的执行默认初始化，值是未定义的，带()的执行值初始化：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//*p的值是未定义的</span>
<span class="token keyword">int</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//*p2 = 0</span>
std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//本机输出-842150451</span>
std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p2 <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//输出0</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>默认情况下，如果new不能分配所要求的内存空间，它会抛出一个类型为bad_alloc的异常。我们可以改变使用new的方式来阻止它抛出异常：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">//如果分配失败，new抛出std::bad_alloc异常</span>
<span class="token keyword">int</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>nothrow<span class="token punctuation">)</span> <span class="token keyword">int</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//如果分配失败，new返回一个空指针，不抛出异常</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
我们称这种形式的new为定位new。定位new表达式允许我们向new传递额外的参数。这里我们传递的是标准库的一个名为nothrow的对象，告诉它不能抛出异常。bad_alloc和nothrow都定义在头文件new中。</li>
<li>通常情况下，编译器不能分辨一个指针指向的是静态还是动态分配的对象。类似的，编译器也不能分辨一个指针所指向的内存是否已经被释放了。</li>
<li>使用new和delete管理动态内存存在三个问题：<ul>
<li>忘记delete内存。忘记释放动态内存会导致人们常说的“内存泄漏”问题，因为这种内存永远不可能被归还给自由空间了。</li>
<li>使用已经释放掉的对象。通过在释放内存后将指针置位空，有时可以检测出这种错误（delete p; p = nullptr）。</li>
<li>同一块内存释放两次。</li>
</ul>
</li>
<li>坚持使用智能指针，就可以避免所有这些问题。对于一块内存，只有在没有任何智能指针指向它的情况下，智能指针才会自动释放它。</li>
<li><p>接受指针参数的智能指针构造函数时explicit的，我们不能进行内置指针到智能指针之间的隐式转换：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//正确：使用了直接初始化形式</span>
std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//错误：不能将普通指针隐式转换为智能指针</span>

std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//错误：不能将普通指针隐式转换为智能指针</span>
<span class="token punctuation">}</span>
std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">clone1</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//正确，显式创建智能指针</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>定义智能指针时还可以增加一个参数来代替delete，这个参数必须是一个可调用对象：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p1</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>vp<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">delete</span> vp<span class="token punctuation">;</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"delete"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
当智能指针p1离开其作用域时，如果其计数器变为0，将会执行这个可调用的lambda表达式，输出字符串delete。</li>
<li>智能指针还有一个名叫reset的成员函数：<ul>
<li><code>p.reset();</code> ：若p是唯一指向其对象的shared_ptr，reset会释放此对象</li>
<li><code>p.reset(q);</code>：令p指向指针q</li>
<li><code>p.reset(q, d);</code>：令p指向q，并且调用对象d而不是delete来释放q</li>
</ul>
</li>
<li><p>不要混合使用普通指针和智能指针：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> vp<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">process</span><span class="token punctuation">(</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//合法，但函数退出后p指向的内存会被释放，p称为悬空指针</span>
<span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>    
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当将一个shared_ptr绑定到一个普通指针时，我们就将内存的管理责任交给了这个shared_ptr。一旦这样做了，我们就不应该再使用内置指针来问shared_ptr所指向的内存了。</p>
</li>
<li>不要用智能指针的get成员函数返回的普通指针，去初始化另一个智能指针：<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> q <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">{</span>
    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">TempP</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//逻辑错误：两个独立的shared_ptr指向相同的内存</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> foo <span class="token operator">=</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//未定义：p指向的内存已经被释放了</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>发生异常后，智能指针指向的内存会被正常释放，但是普通指针指向的内存就永远不会被释放了（在delete之前发生异常）：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">sp</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//这段代码发生异常</span>
<span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//函数结束时，shared_ptr自动释放内存</span>

<span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//这段代码发生异常</span>
    <span class="token keyword">delete</span> p<span class="token punctuation">;</span>
<span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//发生异常后，p指向的内存永远不会被释放</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>无论是否发生异常，局部对象都会被销毁，所以发生异常后sp会被销毁，但是delete p永远执行不到。这个特性对建立局部网络连接的代码很有用，如果代码是这样的：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> SDestination<span class="token punctuation">;</span>
<span class="token keyword">struct</span> SConnection<span class="token punctuation">;</span>
SConnection <span class="token function">connect</span><span class="token punctuation">(</span>SDestination<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//打开连接</span>
<span class="token keyword">void</span> <span class="token function">disconnect</span><span class="token punctuation">(</span>SConnection<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//关闭连接</span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>SDestination <span class="token operator">&amp;</span>d<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    SConnection Conn <span class="token operator">=</span> <span class="token function">connect</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//使用连接</span>
    <span class="token comment" spellcheck="true">//如果我们在f退出前忘记调用disconnect，或者在调用它之前发生了异常，就无法关闭连接Conn了</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>为了保证函数退出时关闭连接，我们可以使用智能指针：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> SDestination<span class="token punctuation">;</span>
<span class="token keyword">struct</span> SConnection<span class="token punctuation">;</span>
SConnection <span class="token function">connect</span><span class="token punctuation">(</span>SDestination<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//打开连接</span>
<span class="token keyword">void</span> <span class="token function">disconnect</span><span class="token punctuation">(</span>SConnection<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//关闭连接</span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>SDestination <span class="token operator">&amp;</span>d<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    SConnection Conn <span class="token operator">=</span> <span class="token function">connect</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>SConnection<span class="token operator">></span> <span class="token function">p</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Conn<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>SConnection <span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">disconnect</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//使用连接</span>
    <span class="token comment" spellcheck="true">//即使我们在f退出前忘记调用disconnect，或者在调用它之前发生了异常，Conn也会被正确关闭</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>即使发生了异常或者忘记调用disconnect，连接也会被正常关闭，因为函数退出时会释放局部对象p，p在被销毁时会调用lambda表达式来关闭连接。</p>
</li>
<li>为了正确使用智能指针，我们必须坚持一些规范：<ul>
<li>不使用相同的内置指针初始化（或reset）多个智能指针</li>
<li>不delete get()返回的指针</li>
<li>不使用get()返回的指针去初始化或reset另一个智能指针</li>
<li>如果使用get返回的普通指针，记住当最后一个对应的智能指针被销毁后，这个普通指针就失效了</li>
<li>如果使用智能指针管理的资源不是new分配的内存，记住传递给它一个删除器（代替delete的可调用对象）</li>
</ul>
</li>
<li>与shared_ptr不同，某个时刻只能有一个unique_ptr指向一个给定对象。当unique_ptr被销毁时，它所指向的对象也被销毁。而且没有类似make_shader的标准库函数来返回一个unique_ptr。当我们定义一个unique_ptr时，需要将其绑定到一个new返回的指针上或默认初始化，因为它不支持拷贝和赋值操作（独占内存所致）：<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> p1<span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">//p1是一个指向int类型的空指针</span>
std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p2</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//p2指向一个值为42的int</span>
std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p3</span><span class="token punctuation">(</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//错误：unique_ptr不支持拷贝</span>
p1 <span class="token operator">=</span> p2<span class="token punctuation">;</span>                               <span class="token comment" spellcheck="true">//错误：unique_ptr不支持赋值</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>虽然不能拷贝或赋值unique_ptr，但可以通过release算法unique_ptr对指针的控制权，然后将其转移给另一个unique_ptr：<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//p2指向一个值为42的int</span>
std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p2</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//将p1的控制权转移给p2</span>
p1<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span>p2<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">//将p2的控制权转移给p1</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
如果我们不用另一个智能指针来保存release返回的普通指针，我们的程序就要负责delete掉该指针。</li>
<li>不能拷贝unique_ptr的规则有一个例外：我们可以拷贝或赋值一个将要被销毁的unique_ptr（因为通常会对它们指向移动拷贝或移动赋值，见13章）：<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">sp</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> sp<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//正确：可以对一个将要被销毁的unique_ptr赋值或拷贝</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>和shared_ptr类似，我们也可以像unique_ptr传递一个自定义的删除器，不同的是，定义时必须显式制定出删除器的模板类型：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">deleteFunc</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">delete</span> p<span class="token punctuation">;</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"delete"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>deleteFunc<span class="token punctuation">)</span><span class="token operator">*</span><span class="token operator">></span> <span class="token function">p1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">,</span> deleteFunc<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>weak_ptr是一种不控制所指向对象生存期的智能指针，它指向由一个shared_ptr管理的对象。将一个weak_ptr绑定到一个shared_ptr不会改变shared_ptr的引用计数。一旦最后一个指向对象的shared_ptr被销毁，对象就会被释放，即使有weak_ptr指向对象，对象也还是会被释放。</p>
<p>当我们创建一个weak_ptr时，要用一个shared_ptr来初始化它：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> sp <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token operator">::</span>weak_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">wp</span><span class="token punctuation">(</span>sp<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//wp弱共享sp，sp的引用计数未改变</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>weak_ptr特有的成员操作如下：</p>
<ul>
<li>w.use_count()：与w共享对象的shared_ptr的数量</li>
<li>w.expired()：若w.use_count()为0，返回true，否则返回false</li>
<li>w.lock()：如果expired为true，返回一个空的shared_ptr；否则返回一个指向w的对象的shared_ptr</li>
</ul>
<p>从上面可以看出weak_ptr所指向的对象可能不存在，所以我们不能使用weak_ptr直接访问对象，而必须调用lock：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> vSp <span class="token operator">=</span> wp<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//在if中使用vSp访问共享对象是安全的</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<p><font size="5" color="orange">动态数组</font></p>
<hr>
<ol>
<li>标准库包含一个名为allocator的类，允许我们将分配和初始化分离。使用allocator通常会提供更好的性能和更灵活的内存管理能力。</li>
<li>大多数应用应该使用标准库容器而不是动态分配的数组。使用容器更为简单、更不容易出现内存管理错误并且可能有更好的性能。</li>
<li>我们用new分配的动态数组并不是数组类型，所以不能对动态数组调用begin或end：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
 <span class="token keyword">auto</span> it <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">begin</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//正确：可以对数组类型调用begin函数</span>
 <span class="token keyword">int</span> <span class="token operator">*</span>b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
 <span class="token function">memset</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">auto</span> it2 <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">begin</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//错误：不能对动态数组调用begin函数</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>释放动态数组时，需要在delete之后、指针名之前加上一个[ ]：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> <span class="token operator">*</span>b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
 <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
 动态数组中的元素按逆序销毁，即最后一个元素先被销毁，然后是倒数第二个…。</li>
<li>标准库提供了一个可以管理new分配的数组的unique_ptr版本，需要在模板参数的对象类型后面跟一个方括号：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> <span class="token function">up</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 up<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//自动调用delete[]销毁其指针</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
 但是如果要使用shared_ptr来管理一个动态数组，必须提供自定义的删除器：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">sp</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> p<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 sp<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//使用我们提供的lambda释放数组，它使用delete[]</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p>unique_ptr管理的动态数组可以通过下标来访问元素，但是shared_ptr不可以，它没有定义下标运算符。而且智能指针类型不支持指针算术运算。因此shared_ptr为了访问数组中的元素，必须先用get获取一个内置指针，然后用它来访问素组元素：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> <span class="token function">up</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
     up<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>

 std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">sp</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> p<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
     <span class="token operator">*</span><span class="token punctuation">(</span>sp<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> i<span class="token punctuation">)</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>当分配一大块内存时，我们通常计划在这块内存还是那个按需构造对象。在此情况下，我们希望将内存分配和对象构造分离。这意味着我们可以分配大块内存，但只在真正需要时才真正执行对象创建操作。</li>
<li>标准库allocator类定义在头文件memory中，它帮助我们将内存分配和对象构造分离开来。allocator也是一个模板，它会根据给定的对象类型来确定恰当的内存大小和对齐位置：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>allocator<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> Alloc<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//可以分配string的allocator对象</span>
 <span class="token keyword">auto</span> <span class="token keyword">const</span> p <span class="token operator">=</span> Alloc<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//分配n个未初始化的string</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
 allocator类的成员操作如下表：</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">allocator<t> a</t></td>
<td>定义一个allocator对象，它可以为类型为T的对象分配内存</td>
</tr>
<tr>
<td style="text-align:center">a.allocate(n)</td>
<td>分配一段原始的、未构造的内存，保存n个类型为T的对象</td>
</tr>
<tr>
<td style="text-align:center">a.deallocate(p, n)</td>
<td>释放从T*指针p中地址开始的内存，这块内存保存了n个类型为T的对象；p必须是一个先前由allocate返回的指针，且n必须是p创建时所要求的大小。在调用deallocate之前，用户必须对每个在这块内存中创建的对象调用destroy</td>
</tr>
<tr>
<td style="text-align:center">a.construct(p, args)</td>
<td>p必须是一个类型为T*的指针，指向一块原始内存；args被传递给类型为T的构造函数，用来在p指向的内存中构造一个对象</td>
</tr>
<tr>
<td style="text-align:center">a.destroy(p)</td>
<td>p为T*类型的指针，此算法对p指向的对象执行析构函数</td>
</tr>
</tbody>
</table>
<ol start="9">
<li>allocator分配的内存是未构造的，我们需要在此内存中构造对象，而construct成员函数接受一个指针和零个或多个额外参数，在指针所指的位置构造一个元素：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">auto</span> q <span class="token operator">=</span> p<span class="token punctuation">;</span>
 Alloc<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>q<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//*q为空字符串</span>
 Alloc<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>q<span class="token operator">++</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//*q为10个字符c组成的字符串</span>
 Alloc<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>q<span class="token operator">++</span><span class="token punctuation">,</span> <span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//*q为字符串hello</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
 还未构造对象的情况下就使用原始内存是错误的：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>allocator<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> Alloc<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//可以分配string的allocator对象</span>
 <span class="token keyword">auto</span> <span class="token keyword">const</span> p <span class="token operator">=</span> Alloc<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//分配n个未初始化的string</span>
 std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//错误：程序崩溃，因为p指向未构造的内存</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li>当我们用完对象后，必须对每个构造的元素调用destroy来销毁它们。函数destroy接受一个指针，对指向的对象执行析构函数：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">while</span> <span class="token punctuation">(</span>q <span class="token operator">!=</span> p<span class="token punctuation">)</span>
    Alloc<span class="token punctuation">.</span><span class="token function">destroy</span><span class="token punctuation">(</span><span class="token operator">--</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li>销毁这些被构造出来的元素以后，我们就可以使用deallocate成员函数把内存归还给系统了（当然也可以拿这些内存再去构造新的对象）。所以allocator使用四部曲就是：allocate、construct、destroy、deallocate：<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>allocator<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> Alloc<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//可以分配string的allocator对象</span>
<span class="token keyword">auto</span> <span class="token keyword">const</span> p <span class="token operator">=</span> Alloc<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//分配n个未初始化的string</span>
<span class="token keyword">auto</span> q <span class="token operator">=</span> p<span class="token punctuation">;</span>
Alloc<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>q<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//*q为空字符串</span>
Alloc<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>q<span class="token operator">++</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//*q为10个字符c组成的字符串</span>
Alloc<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>q<span class="token operator">++</span><span class="token punctuation">,</span> <span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//*q为字符串hello</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>q <span class="token operator">!=</span> p<span class="token punctuation">)</span>
    Alloc<span class="token punctuation">.</span><span class="token function">destroy</span><span class="token punctuation">(</span><span class="token operator">--</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment" spellcheck="true">//销毁每个构造出来的对象</span>
Alloc<span class="token punctuation">.</span><span class="token function">deallocate</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">//第二个参数必须与allocate分配内存时指定的参数相同</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>标准库还为allocator类定义了两个伴随算法：copy和fill，用于在未初始化内存（原始内存）中创建对象，定义在头文件memory中：<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> SVec<span class="token punctuation">{</span> <span class="token string">"Hello"</span><span class="token punctuation">,</span><span class="token string">"World"</span><span class="token punctuation">,</span><span class="token string">"Nice"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
std<span class="token operator">::</span>allocator<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> Alloc<span class="token punctuation">;</span>
<span class="token keyword">auto</span> p <span class="token operator">=</span> Alloc<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span>SVec<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//通过拷贝SVec中的元素来构造原始内存从p开始的元素</span>
<span class="token keyword">auto</span> q <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">uninitialized_copy</span><span class="token punctuation">(</span>SVec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> SVec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//将原始内存中剩余的未构造元素初始化为字符串Same</span>
std<span class="token operator">::</span><span class="token function">uninitialized_fill_n</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> SVec<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"Same"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">uninitialized_copy(b, e, b2)</td>
<td>将迭代器b到e范围内的元素拷贝到迭代器b2指向的未构造的原始内存中</td>
</tr>
<tr>
<td style="text-align:center">uninitialized_copy_n(b, n, b2)</td>
<td>从迭代器b指向的元素开始，拷贝n个元素到b2指向的原始内存中</td>
</tr>
<tr>
<td style="text-align:center">uninitialized_fill(b, e, t)</td>
<td>在迭代器b到e的元素内存范围内构造对象，对象的值均为t的拷贝</td>
</tr>
<tr>
<td style="text-align:center">uninitialized_fill_n(b, n, t)</td>
<td>从迭代器b指向的元素内存开始创建n个对象，对象的值均为t的拷贝</td>
</tr>
</tbody>
</table>
<p><font size="5" color="orange">使用标准库：文本查询程序</font></p>
<hr>
<ol>
<li>-_-||，最近比较忙，比较忙。。。有时间再来补上了(*￣︶￣)</li>
</ol>
<p><font size="5" color="orange">概述</font></p>
<hr>
<ol>
<li>静态内存用来保存局部static对象、类static数据成员以及定义在任何函数之外的变量。栈内存用来保存定义在函数内的非static对象。分配在静态或栈内存中的对象由编译器自动创建和销毁。对于栈对象，仅在其定义的程序块运行时才存在；static对象在使用之前分配，在程序结束时销毁。</li>
<li>除了静态内存和栈内存，每个程序还拥有一个内存池。这部分内存被称作自由空间或堆。程序用堆来存储动态分配的对象，即那些在程序运行时分配的对象。动态对象的生存期由程序来控制，也就是说，当动态对象不再使用时，我们的代码必须显式地销毁它们。</li>
</ol>
<p><font size="5" color="orange">动态内存与智能指针</font></p>
<hr>
<ol>
<li>为了更容易、更安全地使用动态内存，新标准库提供了三种智能指针类型来管理动态对象：shared_ptr和unique_ptr。它们和普通指针的重要区别是它们负责自动释放所指向的对象。shared_ptr允许多个指针指向同一个对象；unique_ptr则独占所指向的对象。</li>
<li>标准库还定义了一个名为weak_ptr的伴随类，它是一种弱引用，指向shared_ptr所管理的对象。</li>
<li>shared_ptr、unique_ptr和weak_ptr都定义在头文件memory中。</li>
<li>智能指针其实是在普通指针上作了一些包装，包括自动释放内存、指向同一对象的指针指针数量（用智能指针类中的计数器保存）等等。</li>
<li>智能指针也是模板类，默认初始化的智能指针中保存着一个空指针：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> p1<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//shared_ptr，可以指向string对象，现在还是空指针</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li>使用智能指针的get成员函数可以获得对应的普通指针：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> p1<span class="token punctuation">;</span>
 <span class="token keyword">auto</span> p <span class="token operator">=</span> p1<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//p是string*类型</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li>shared_ptr独有的操作如下表：</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">make_shared<t>(args)</t></td>
<td>返回一个shared_ptr，指向一个动态分配的类型为T的对象，使用args初始化该对象</td>
</tr>
<tr>
<td style="text-align:center">shared_ptr<t>p(q)</t></td>
<td>p是shared_ptr q的拷贝，此操作会递增q中的计算器。q中的指针必须能转换为T*</td>
</tr>
<tr>
<td style="text-align:center">p=q</td>
<td>p和q都是shared_ptr，所保存的指针必须能相互转换。此操作会递减p的引用计数，递增q的引用计数；若p的引用计数变为0，则将其管理的原内存释放</td>
</tr>
<tr>
<td style="text-align:center">p.unique()</td>
<td>若p.use_count()为1，返回true，否则返回false</td>
</tr>
<tr>
<td style="text-align:center">p,use_count()</td>
<td>返回一个与p共享对象的智能指针数量；可能很慢，主要用于测试</td>
</tr>
</tbody>
</table>
<ol start="8">
<li>我们可以用make_shared函数代替new来生成一个指针，这样更安全，同时不需要匹配的delete操作，因为智能指针在计算器变为0时会自动调用delete：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> p1 <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
 当然用auto来保存make_shared的结果更简单：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">auto</span> p1 <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li>每个shared_ptr都有一个关联的计数器，通常称其为引用计数。无论何时我们拷贝一个shared_ptr，计数器都会增加，当我们给shared_ptr赋予一个新值或是shared_ptr被销毁（例如局部shared_ptr离开其作用域）时，计数器就会递减。一旦一个shared_ptr的计数器变为0，它就会自动释放自己所管理的对象。</li>
<li>当指向一个对象的最后一个shared_ptr被销毁时，shared_ptr类会自动销毁此对象。它是通过析构函数来完成销毁工作的。shared_ptr的析构函数会递减它所指向的对象的引用计数。如果引用计数变为0，shared_ptr的析构函数就会销毁对象，并释放它占用的内存。</li>
<li>如果将shared_ptr存放于一个容器中，而后不再需要全部元素，而只使用其中一部分，要记得用erase删除不再使用的那些元素，否则它们占用的内存将无法释放。</li>
<li>使用动态内存的一个常见原因是允许多个对象共享相同的状态。</li>
<li>使用new进行动态内存分配时，不带()的执行默认初始化，值是未定义的，带()的执行值初始化：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//*p的值是未定义的</span>
<span class="token keyword">int</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//*p2 = 0</span>
std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//本机输出-842150451</span>
std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p2 <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//输出0</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>默认情况下，如果new不能分配所要求的内存空间，它会抛出一个类型为bad_alloc的异常。我们可以改变使用new的方式来阻止它抛出异常：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">//如果分配失败，new抛出std::bad_alloc异常</span>
<span class="token keyword">int</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>nothrow<span class="token punctuation">)</span> <span class="token keyword">int</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//如果分配失败，new返回一个空指针，不抛出异常</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
我们称这种形式的new为定位new。定位new表达式允许我们向new传递额外的参数。这里我们传递的是标准库的一个名为nothrow的对象，告诉它不能抛出异常。bad_alloc和nothrow都定义在头文件new中。</li>
<li>通常情况下，编译器不能分辨一个指针指向的是静态还是动态分配的对象。类似的，编译器也不能分辨一个指针所指向的内存是否已经被释放了。</li>
<li>使用new和delete管理动态内存存在三个问题：<ul>
<li>忘记delete内存。忘记释放动态内存会导致人们常说的“内存泄漏”问题，因为这种内存永远不可能被归还给自由空间了。</li>
<li>使用已经释放掉的对象。通过在释放内存后将指针置位空，有时可以检测出这种错误（delete p; p = nullptr）。</li>
<li>同一块内存释放两次。</li>
</ul>
</li>
<li>坚持使用智能指针，就可以避免所有这些问题。对于一块内存，只有在没有任何智能指针指向它的情况下，智能指针才会自动释放它。</li>
<li><p>接受指针参数的智能指针构造函数时explicit的，我们不能进行内置指针到智能指针之间的隐式转换：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//正确：使用了直接初始化形式</span>
std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//错误：不能将普通指针隐式转换为智能指针</span>

std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//错误：不能将普通指针隐式转换为智能指针</span>
<span class="token punctuation">}</span>
std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">clone1</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//正确，显式创建智能指针</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>定义智能指针时还可以增加一个参数来代替delete，这个参数必须是一个可调用对象：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p1</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>vp<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">delete</span> vp<span class="token punctuation">;</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"delete"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
当智能指针p1离开其作用域时，如果其计数器变为0，将会执行这个可调用的lambda表达式，输出字符串delete。</li>
<li>智能指针还有一个名叫reset的成员函数：<ul>
<li><code>p.reset();</code> ：若p是唯一指向其对象的shared_ptr，reset会释放此对象</li>
<li><code>p.reset(q);</code>：令p指向指针q</li>
<li><code>p.reset(q, d);</code>：令p指向q，并且调用对象d而不是delete来释放q</li>
</ul>
</li>
<li><p>不要混合使用普通指针和智能指针：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> vp<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">process</span><span class="token punctuation">(</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//合法，但函数退出后p指向的内存会被释放，p称为悬空指针</span>
<span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>    
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当将一个shared_ptr绑定到一个普通指针时，我们就将内存的管理责任交给了这个shared_ptr。一旦这样做了，我们就不应该再使用内置指针来问shared_ptr所指向的内存了。</p>
</li>
<li>不要用智能指针的get成员函数返回的普通指针，去初始化另一个智能指针：<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> q <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">{</span>
    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">TempP</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//逻辑错误：两个独立的shared_ptr指向相同的内存</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> foo <span class="token operator">=</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//未定义：p指向的内存已经被释放了</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>发生异常后，智能指针指向的内存会被正常释放，但是普通指针指向的内存就永远不会被释放了（在delete之前发生异常）：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">sp</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//这段代码发生异常</span>
<span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//函数结束时，shared_ptr自动释放内存</span>

<span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//这段代码发生异常</span>
    <span class="token keyword">delete</span> p<span class="token punctuation">;</span>
<span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//发生异常后，p指向的内存永远不会被释放</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>无论是否发生异常，局部对象都会被销毁，所以发生异常后sp会被销毁，但是delete p永远执行不到。这个特性对建立局部网络连接的代码很有用，如果代码是这样的：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> SDestination<span class="token punctuation">;</span>
<span class="token keyword">struct</span> SConnection<span class="token punctuation">;</span>
SConnection <span class="token function">connect</span><span class="token punctuation">(</span>SDestination<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//打开连接</span>
<span class="token keyword">void</span> <span class="token function">disconnect</span><span class="token punctuation">(</span>SConnection<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//关闭连接</span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>SDestination <span class="token operator">&amp;</span>d<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    SConnection Conn <span class="token operator">=</span> <span class="token function">connect</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//使用连接</span>
    <span class="token comment" spellcheck="true">//如果我们在f退出前忘记调用disconnect，或者在调用它之前发生了异常，就无法关闭连接Conn了</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>为了保证函数退出时关闭连接，我们可以使用智能指针：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> SDestination<span class="token punctuation">;</span>
<span class="token keyword">struct</span> SConnection<span class="token punctuation">;</span>
SConnection <span class="token function">connect</span><span class="token punctuation">(</span>SDestination<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//打开连接</span>
<span class="token keyword">void</span> <span class="token function">disconnect</span><span class="token punctuation">(</span>SConnection<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//关闭连接</span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>SDestination <span class="token operator">&amp;</span>d<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    SConnection Conn <span class="token operator">=</span> <span class="token function">connect</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>SConnection<span class="token operator">></span> <span class="token function">p</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Conn<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>SConnection <span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">disconnect</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//使用连接</span>
    <span class="token comment" spellcheck="true">//即使我们在f退出前忘记调用disconnect，或者在调用它之前发生了异常，Conn也会被正确关闭</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>即使发生了异常或者忘记调用disconnect，连接也会被正常关闭，因为函数退出时会释放局部对象p，p在被销毁时会调用lambda表达式来关闭连接。</p>
</li>
<li>为了正确使用智能指针，我们必须坚持一些规范：<ul>
<li>不使用相同的内置指针初始化（或reset）多个智能指针</li>
<li>不delete get()返回的指针</li>
<li>不使用get()返回的指针去初始化或reset另一个智能指针</li>
<li>如果使用get返回的普通指针，记住当最后一个对应的智能指针被销毁后，这个普通指针就失效了</li>
<li>如果使用智能指针管理的资源不是new分配的内存，记住传递给它一个删除器（代替delete的可调用对象）</li>
</ul>
</li>
<li>与shared_ptr不同，某个时刻只能有一个unique_ptr指向一个给定对象。当unique_ptr被销毁时，它所指向的对象也被销毁。而且没有类似make_shader的标准库函数来返回一个unique_ptr。当我们定义一个unique_ptr时，需要将其绑定到一个new返回的指针上或默认初始化，因为它不支持拷贝和赋值操作（独占内存所致）：<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> p1<span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">//p1是一个指向int类型的空指针</span>
std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p2</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//p2指向一个值为42的int</span>
std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p3</span><span class="token punctuation">(</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//错误：unique_ptr不支持拷贝</span>
p1 <span class="token operator">=</span> p2<span class="token punctuation">;</span>                               <span class="token comment" spellcheck="true">//错误：unique_ptr不支持赋值</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>虽然不能拷贝或赋值unique_ptr，但可以通过release算法unique_ptr对指针的控制权，然后将其转移给另一个unique_ptr：<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//p2指向一个值为42的int</span>
std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p2</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//将p1的控制权转移给p2</span>
p1<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span>p2<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">//将p2的控制权转移给p1</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
如果我们不用另一个智能指针来保存release返回的普通指针，我们的程序就要负责delete掉该指针。</li>
<li>不能拷贝unique_ptr的规则有一个例外：我们可以拷贝或赋值一个将要被销毁的unique_ptr（因为通常会对它们指向移动拷贝或移动赋值，见13章）：<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">sp</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> sp<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//正确：可以对一个将要被销毁的unique_ptr赋值或拷贝</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>和shared_ptr类似，我们也可以像unique_ptr传递一个自定义的删除器，不同的是，定义时必须显式制定出删除器的模板类型：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">deleteFunc</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">delete</span> p<span class="token punctuation">;</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"delete"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>deleteFunc<span class="token punctuation">)</span><span class="token operator">*</span><span class="token operator">></span> <span class="token function">p1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">,</span> deleteFunc<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>weak_ptr是一种不控制所指向对象生存期的智能指针，它指向由一个shared_ptr管理的对象。将一个weak_ptr绑定到一个shared_ptr不会改变shared_ptr的引用计数。一旦最后一个指向对象的shared_ptr被销毁，对象就会被释放，即使有weak_ptr指向对象，对象也还是会被释放。</p>
<p>当我们创建一个weak_ptr时，要用一个shared_ptr来初始化它：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> sp <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token operator">::</span>weak_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">wp</span><span class="token punctuation">(</span>sp<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//wp弱共享sp，sp的引用计数未改变</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>weak_ptr特有的成员操作如下：</p>
<ul>
<li>w.use_count()：与w共享对象的shared_ptr的数量</li>
<li>w.expired()：若w.use_count()为0，返回true，否则返回false</li>
<li>w.lock()：如果expired为true，返回一个空的shared_ptr；否则返回一个指向w的对象的shared_ptr</li>
</ul>
<p>从上面可以看出weak_ptr所指向的对象可能不存在，所以我们不能使用weak_ptr直接访问对象，而必须调用lock：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> vSp <span class="token operator">=</span> wp<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//在if中使用vSp访问共享对象是安全的</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<p><font size="5" color="orange">动态数组</font></p>
<hr>
<ol>
<li>标准库包含一个名为allocator的类，允许我们将分配和初始化分离。使用allocator通常会提供更好的性能和更灵活的内存管理能力。</li>
<li>大多数应用应该使用标准库容器而不是动态分配的数组。使用容器更为简单、更不容易出现内存管理错误并且可能有更好的性能。</li>
<li>我们用new分配的动态数组并不是数组类型，所以不能对动态数组调用begin或end：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
 <span class="token keyword">auto</span> it <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">begin</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//正确：可以对数组类型调用begin函数</span>
 <span class="token keyword">int</span> <span class="token operator">*</span>b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
 <span class="token function">memset</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">auto</span> it2 <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">begin</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//错误：不能对动态数组调用begin函数</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>释放动态数组时，需要在delete之后、指针名之前加上一个[ ]：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> <span class="token operator">*</span>b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
 <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
 动态数组中的元素按逆序销毁，即最后一个元素先被销毁，然后是倒数第二个…。</li>
<li>标准库提供了一个可以管理new分配的数组的unique_ptr版本，需要在模板参数的对象类型后面跟一个方括号：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> <span class="token function">up</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 up<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//自动调用delete[]销毁其指针</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
 但是如果要使用shared_ptr来管理一个动态数组，必须提供自定义的删除器：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">sp</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> p<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 sp<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//使用我们提供的lambda释放数组，它使用delete[]</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p>unique_ptr管理的动态数组可以通过下标来访问元素，但是shared_ptr不可以，它没有定义下标运算符。而且智能指针类型不支持指针算术运算。因此shared_ptr为了访问数组中的元素，必须先用get获取一个内置指针，然后用它来访问素组元素：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> <span class="token function">up</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
     up<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>

 std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">sp</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> p<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
     <span class="token operator">*</span><span class="token punctuation">(</span>sp<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> i<span class="token punctuation">)</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>当分配一大块内存时，我们通常计划在这块内存还是那个按需构造对象。在此情况下，我们希望将内存分配和对象构造分离。这意味着我们可以分配大块内存，但只在真正需要时才真正执行对象创建操作。</li>
<li>标准库allocator类定义在头文件memory中，它帮助我们将内存分配和对象构造分离开来。allocator也是一个模板，它会根据给定的对象类型来确定恰当的内存大小和对齐位置：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>allocator<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> Alloc<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//可以分配string的allocator对象</span>
 <span class="token keyword">auto</span> <span class="token keyword">const</span> p <span class="token operator">=</span> Alloc<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//分配n个未初始化的string</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
 allocator类的成员操作如下表：</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">allocator<t> a</t></td>
<td>定义一个allocator对象，它可以为类型为T的对象分配内存</td>
</tr>
<tr>
<td style="text-align:center">a.allocate(n)</td>
<td>分配一段原始的、未构造的内存，保存n个类型为T的对象</td>
</tr>
<tr>
<td style="text-align:center">a.deallocate(p, n)</td>
<td>释放从T*指针p中地址开始的内存，这块内存保存了n个类型为T的对象；p必须是一个先前由allocate返回的指针，且n必须是p创建时所要求的大小。在调用deallocate之前，用户必须对每个在这块内存中创建的对象调用destroy</td>
</tr>
<tr>
<td style="text-align:center">a.construct(p, args)</td>
<td>p必须是一个类型为T*的指针，指向一块原始内存；args被传递给类型为T的构造函数，用来在p指向的内存中构造一个对象</td>
</tr>
<tr>
<td style="text-align:center">a.destroy(p)</td>
<td>p为T*类型的指针，此算法对p指向的对象执行析构函数</td>
</tr>
</tbody>
</table>
<ol start="9">
<li>allocator分配的内存是未构造的，我们需要在此内存中构造对象，而construct成员函数接受一个指针和零个或多个额外参数，在指针所指的位置构造一个元素：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">auto</span> q <span class="token operator">=</span> p<span class="token punctuation">;</span>
 Alloc<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>q<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//*q为空字符串</span>
 Alloc<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>q<span class="token operator">++</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//*q为10个字符c组成的字符串</span>
 Alloc<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>q<span class="token operator">++</span><span class="token punctuation">,</span> <span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//*q为字符串hello</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
 还未构造对象的情况下就使用原始内存是错误的：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>allocator<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> Alloc<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//可以分配string的allocator对象</span>
 <span class="token keyword">auto</span> <span class="token keyword">const</span> p <span class="token operator">=</span> Alloc<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//分配n个未初始化的string</span>
 std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//错误：程序崩溃，因为p指向未构造的内存</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li>当我们用完对象后，必须对每个构造的元素调用destroy来销毁它们。函数destroy接受一个指针，对指向的对象执行析构函数：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">while</span> <span class="token punctuation">(</span>q <span class="token operator">!=</span> p<span class="token punctuation">)</span>
    Alloc<span class="token punctuation">.</span><span class="token function">destroy</span><span class="token punctuation">(</span><span class="token operator">--</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li>销毁这些被构造出来的元素以后，我们就可以使用deallocate成员函数把内存归还给系统了（当然也可以拿这些内存再去构造新的对象）。所以allocator使用四部曲就是：allocate、construct、destroy、deallocate：<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>allocator<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> Alloc<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//可以分配string的allocator对象</span>
<span class="token keyword">auto</span> <span class="token keyword">const</span> p <span class="token operator">=</span> Alloc<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//分配n个未初始化的string</span>
<span class="token keyword">auto</span> q <span class="token operator">=</span> p<span class="token punctuation">;</span>
Alloc<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>q<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//*q为空字符串</span>
Alloc<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>q<span class="token operator">++</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//*q为10个字符c组成的字符串</span>
Alloc<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>q<span class="token operator">++</span><span class="token punctuation">,</span> <span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//*q为字符串hello</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>q <span class="token operator">!=</span> p<span class="token punctuation">)</span>
    Alloc<span class="token punctuation">.</span><span class="token function">destroy</span><span class="token punctuation">(</span><span class="token operator">--</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment" spellcheck="true">//销毁每个构造出来的对象</span>
Alloc<span class="token punctuation">.</span><span class="token function">deallocate</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">//第二个参数必须与allocate分配内存时指定的参数相同</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>标准库还为allocator类定义了两个伴随算法：copy和fill，用于在未初始化内存（原始内存）中创建对象，定义在头文件memory中：<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> SVec<span class="token punctuation">{</span> <span class="token string">"Hello"</span><span class="token punctuation">,</span><span class="token string">"World"</span><span class="token punctuation">,</span><span class="token string">"Nice"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
std<span class="token operator">::</span>allocator<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> Alloc<span class="token punctuation">;</span>
<span class="token keyword">auto</span> p <span class="token operator">=</span> Alloc<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span>SVec<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//通过拷贝SVec中的元素来构造原始内存从p开始的元素</span>
<span class="token keyword">auto</span> q <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">uninitialized_copy</span><span class="token punctuation">(</span>SVec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> SVec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//将原始内存中剩余的未构造元素初始化为字符串Same</span>
std<span class="token operator">::</span><span class="token function">uninitialized_fill_n</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> SVec<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"Same"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">uninitialized_copy(b, e, b2)</td>
<td>将迭代器b到e范围内的元素拷贝到迭代器b2指向的未构造的原始内存中</td>
</tr>
<tr>
<td style="text-align:center">uninitialized_copy_n(b, n, b2)</td>
<td>从迭代器b指向的元素开始，拷贝n个元素到b2指向的原始内存中</td>
</tr>
<tr>
<td style="text-align:center">uninitialized_fill(b, e, t)</td>
<td>在迭代器b到e的元素内存范围内构造对象，对象的值均为t的拷贝</td>
</tr>
<tr>
<td style="text-align:center">uninitialized_fill_n(b, n, t)</td>
<td>从迭代器b指向的元素内存开始创建n个对象，对象的值均为t的拷贝</td>
</tr>
</tbody>
</table>
<p><font size="5" color="orange">使用标准库：文本查询程序</font></p>
<hr>
<ol>
<li>-_-||，最近比较忙，比较忙。。。有时间再来补上了(*￣︶￣)</li>
</ol>
<p><font size="5" color="orange">概述</font></p>
<hr>
<ol>
<li>静态内存用来保存局部static对象、类static数据成员以及定义在任何函数之外的变量。栈内存用来保存定义在函数内的非static对象。分配在静态或栈内存中的对象由编译器自动创建和销毁。对于栈对象，仅在其定义的程序块运行时才存在；static对象在使用之前分配，在程序结束时销毁。</li>
<li>除了静态内存和栈内存，每个程序还拥有一个内存池。这部分内存被称作自由空间或堆。程序用堆来存储动态分配的对象，即那些在程序运行时分配的对象。动态对象的生存期由程序来控制，也就是说，当动态对象不再使用时，我们的代码必须显式地销毁它们。</li>
</ol>
<p><font size="5" color="orange">动态内存与智能指针</font></p>
<hr>
<ol>
<li>为了更容易、更安全地使用动态内存，新标准库提供了三种智能指针类型来管理动态对象：shared_ptr和unique_ptr。它们和普通指针的重要区别是它们负责自动释放所指向的对象。shared_ptr允许多个指针指向同一个对象；unique_ptr则独占所指向的对象。</li>
<li>标准库还定义了一个名为weak_ptr的伴随类，它是一种弱引用，指向shared_ptr所管理的对象。</li>
<li>shared_ptr、unique_ptr和weak_ptr都定义在头文件memory中。</li>
<li>智能指针其实是在普通指针上作了一些包装，包括自动释放内存、指向同一对象的指针指针数量（用智能指针类中的计数器保存）等等。</li>
<li>智能指针也是模板类，默认初始化的智能指针中保存着一个空指针：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> p1<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//shared_ptr，可以指向string对象，现在还是空指针</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li>使用智能指针的get成员函数可以获得对应的普通指针：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> p1<span class="token punctuation">;</span>
 <span class="token keyword">auto</span> p <span class="token operator">=</span> p1<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//p是string*类型</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li>shared_ptr独有的操作如下表：</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">make_shared<t>(args)</t></td>
<td>返回一个shared_ptr，指向一个动态分配的类型为T的对象，使用args初始化该对象</td>
</tr>
<tr>
<td style="text-align:center">shared_ptr<t>p(q)</t></td>
<td>p是shared_ptr q的拷贝，此操作会递增q中的计算器。q中的指针必须能转换为T*</td>
</tr>
<tr>
<td style="text-align:center">p=q</td>
<td>p和q都是shared_ptr，所保存的指针必须能相互转换。此操作会递减p的引用计数，递增q的引用计数；若p的引用计数变为0，则将其管理的原内存释放</td>
</tr>
<tr>
<td style="text-align:center">p.unique()</td>
<td>若p.use_count()为1，返回true，否则返回false</td>
</tr>
<tr>
<td style="text-align:center">p,use_count()</td>
<td>返回一个与p共享对象的智能指针数量；可能很慢，主要用于测试</td>
</tr>
</tbody>
</table>
<ol start="8">
<li>我们可以用make_shared函数代替new来生成一个指针，这样更安全，同时不需要匹配的delete操作，因为智能指针在计算器变为0时会自动调用delete：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> p1 <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
 当然用auto来保存make_shared的结果更简单：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">auto</span> p1 <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li>每个shared_ptr都有一个关联的计数器，通常称其为引用计数。无论何时我们拷贝一个shared_ptr，计数器都会增加，当我们给shared_ptr赋予一个新值或是shared_ptr被销毁（例如局部shared_ptr离开其作用域）时，计数器就会递减。一旦一个shared_ptr的计数器变为0，它就会自动释放自己所管理的对象。</li>
<li>当指向一个对象的最后一个shared_ptr被销毁时，shared_ptr类会自动销毁此对象。它是通过析构函数来完成销毁工作的。shared_ptr的析构函数会递减它所指向的对象的引用计数。如果引用计数变为0，shared_ptr的析构函数就会销毁对象，并释放它占用的内存。</li>
<li>如果将shared_ptr存放于一个容器中，而后不再需要全部元素，而只使用其中一部分，要记得用erase删除不再使用的那些元素，否则它们占用的内存将无法释放。</li>
<li>使用动态内存的一个常见原因是允许多个对象共享相同的状态。</li>
<li>使用new进行动态内存分配时，不带()的执行默认初始化，值是未定义的，带()的执行值初始化：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//*p的值是未定义的</span>
<span class="token keyword">int</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//*p2 = 0</span>
std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//本机输出-842150451</span>
std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p2 <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//输出0</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>默认情况下，如果new不能分配所要求的内存空间，它会抛出一个类型为bad_alloc的异常。我们可以改变使用new的方式来阻止它抛出异常：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">//如果分配失败，new抛出std::bad_alloc异常</span>
<span class="token keyword">int</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>nothrow<span class="token punctuation">)</span> <span class="token keyword">int</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//如果分配失败，new返回一个空指针，不抛出异常</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
我们称这种形式的new为定位new。定位new表达式允许我们向new传递额外的参数。这里我们传递的是标准库的一个名为nothrow的对象，告诉它不能抛出异常。bad_alloc和nothrow都定义在头文件new中。</li>
<li>通常情况下，编译器不能分辨一个指针指向的是静态还是动态分配的对象。类似的，编译器也不能分辨一个指针所指向的内存是否已经被释放了。</li>
<li>使用new和delete管理动态内存存在三个问题：<ul>
<li>忘记delete内存。忘记释放动态内存会导致人们常说的“内存泄漏”问题，因为这种内存永远不可能被归还给自由空间了。</li>
<li>使用已经释放掉的对象。通过在释放内存后将指针置位空，有时可以检测出这种错误（delete p; p = nullptr）。</li>
<li>同一块内存释放两次。</li>
</ul>
</li>
<li>坚持使用智能指针，就可以避免所有这些问题。对于一块内存，只有在没有任何智能指针指向它的情况下，智能指针才会自动释放它。</li>
<li><p>接受指针参数的智能指针构造函数时explicit的，我们不能进行内置指针到智能指针之间的隐式转换：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//正确：使用了直接初始化形式</span>
std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//错误：不能将普通指针隐式转换为智能指针</span>

std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//错误：不能将普通指针隐式转换为智能指针</span>
<span class="token punctuation">}</span>
std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">clone1</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//正确，显式创建智能指针</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>定义智能指针时还可以增加一个参数来代替delete，这个参数必须是一个可调用对象：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p1</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>vp<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">delete</span> vp<span class="token punctuation">;</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"delete"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
当智能指针p1离开其作用域时，如果其计数器变为0，将会执行这个可调用的lambda表达式，输出字符串delete。</li>
<li>智能指针还有一个名叫reset的成员函数：<ul>
<li><code>p.reset();</code> ：若p是唯一指向其对象的shared_ptr，reset会释放此对象</li>
<li><code>p.reset(q);</code>：令p指向指针q</li>
<li><code>p.reset(q, d);</code>：令p指向q，并且调用对象d而不是delete来释放q</li>
</ul>
</li>
<li><p>不要混合使用普通指针和智能指针：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> vp<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">process</span><span class="token punctuation">(</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//合法，但函数退出后p指向的内存会被释放，p称为悬空指针</span>
<span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>    
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当将一个shared_ptr绑定到一个普通指针时，我们就将内存的管理责任交给了这个shared_ptr。一旦这样做了，我们就不应该再使用内置指针来问shared_ptr所指向的内存了。</p>
</li>
<li>不要用智能指针的get成员函数返回的普通指针，去初始化另一个智能指针：<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> q <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">{</span>
    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">TempP</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//逻辑错误：两个独立的shared_ptr指向相同的内存</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> foo <span class="token operator">=</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//未定义：p指向的内存已经被释放了</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>发生异常后，智能指针指向的内存会被正常释放，但是普通指针指向的内存就永远不会被释放了（在delete之前发生异常）：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">sp</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//这段代码发生异常</span>
<span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//函数结束时，shared_ptr自动释放内存</span>

<span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//这段代码发生异常</span>
    <span class="token keyword">delete</span> p<span class="token punctuation">;</span>
<span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//发生异常后，p指向的内存永远不会被释放</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>无论是否发生异常，局部对象都会被销毁，所以发生异常后sp会被销毁，但是delete p永远执行不到。这个特性对建立局部网络连接的代码很有用，如果代码是这样的：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> SDestination<span class="token punctuation">;</span>
<span class="token keyword">struct</span> SConnection<span class="token punctuation">;</span>
SConnection <span class="token function">connect</span><span class="token punctuation">(</span>SDestination<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//打开连接</span>
<span class="token keyword">void</span> <span class="token function">disconnect</span><span class="token punctuation">(</span>SConnection<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//关闭连接</span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>SDestination <span class="token operator">&amp;</span>d<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    SConnection Conn <span class="token operator">=</span> <span class="token function">connect</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//使用连接</span>
    <span class="token comment" spellcheck="true">//如果我们在f退出前忘记调用disconnect，或者在调用它之前发生了异常，就无法关闭连接Conn了</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>为了保证函数退出时关闭连接，我们可以使用智能指针：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> SDestination<span class="token punctuation">;</span>
<span class="token keyword">struct</span> SConnection<span class="token punctuation">;</span>
SConnection <span class="token function">connect</span><span class="token punctuation">(</span>SDestination<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//打开连接</span>
<span class="token keyword">void</span> <span class="token function">disconnect</span><span class="token punctuation">(</span>SConnection<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//关闭连接</span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>SDestination <span class="token operator">&amp;</span>d<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    SConnection Conn <span class="token operator">=</span> <span class="token function">connect</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>SConnection<span class="token operator">></span> <span class="token function">p</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Conn<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>SConnection <span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">disconnect</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//使用连接</span>
    <span class="token comment" spellcheck="true">//即使我们在f退出前忘记调用disconnect，或者在调用它之前发生了异常，Conn也会被正确关闭</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>即使发生了异常或者忘记调用disconnect，连接也会被正常关闭，因为函数退出时会释放局部对象p，p在被销毁时会调用lambda表达式来关闭连接。</p>
</li>
<li>为了正确使用智能指针，我们必须坚持一些规范：<ul>
<li>不使用相同的内置指针初始化（或reset）多个智能指针</li>
<li>不delete get()返回的指针</li>
<li>不使用get()返回的指针去初始化或reset另一个智能指针</li>
<li>如果使用get返回的普通指针，记住当最后一个对应的智能指针被销毁后，这个普通指针就失效了</li>
<li>如果使用智能指针管理的资源不是new分配的内存，记住传递给它一个删除器（代替delete的可调用对象）</li>
</ul>
</li>
<li>与shared_ptr不同，某个时刻只能有一个unique_ptr指向一个给定对象。当unique_ptr被销毁时，它所指向的对象也被销毁。而且没有类似make_shader的标准库函数来返回一个unique_ptr。当我们定义一个unique_ptr时，需要将其绑定到一个new返回的指针上或默认初始化，因为它不支持拷贝和赋值操作（独占内存所致）：<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> p1<span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">//p1是一个指向int类型的空指针</span>
std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p2</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//p2指向一个值为42的int</span>
std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p3</span><span class="token punctuation">(</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//错误：unique_ptr不支持拷贝</span>
p1 <span class="token operator">=</span> p2<span class="token punctuation">;</span>                               <span class="token comment" spellcheck="true">//错误：unique_ptr不支持赋值</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>虽然不能拷贝或赋值unique_ptr，但可以通过release算法unique_ptr对指针的控制权，然后将其转移给另一个unique_ptr：<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//p2指向一个值为42的int</span>
std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p2</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//将p1的控制权转移给p2</span>
p1<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span>p2<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">//将p2的控制权转移给p1</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
如果我们不用另一个智能指针来保存release返回的普通指针，我们的程序就要负责delete掉该指针。</li>
<li>不能拷贝unique_ptr的规则有一个例外：我们可以拷贝或赋值一个将要被销毁的unique_ptr（因为通常会对它们指向移动拷贝或移动赋值，见13章）：<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">sp</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> sp<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//正确：可以对一个将要被销毁的unique_ptr赋值或拷贝</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>和shared_ptr类似，我们也可以像unique_ptr传递一个自定义的删除器，不同的是，定义时必须显式制定出删除器的模板类型：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">deleteFunc</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">delete</span> p<span class="token punctuation">;</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"delete"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>deleteFunc<span class="token punctuation">)</span><span class="token operator">*</span><span class="token operator">></span> <span class="token function">p1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">,</span> deleteFunc<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>weak_ptr是一种不控制所指向对象生存期的智能指针，它指向由一个shared_ptr管理的对象。将一个weak_ptr绑定到一个shared_ptr不会改变shared_ptr的引用计数。一旦最后一个指向对象的shared_ptr被销毁，对象就会被释放，即使有weak_ptr指向对象，对象也还是会被释放。</p>
<p>当我们创建一个weak_ptr时，要用一个shared_ptr来初始化它：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> sp <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token operator">::</span>weak_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">wp</span><span class="token punctuation">(</span>sp<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//wp弱共享sp，sp的引用计数未改变</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>weak_ptr特有的成员操作如下：</p>
<ul>
<li>w.use_count()：与w共享对象的shared_ptr的数量</li>
<li>w.expired()：若w.use_count()为0，返回true，否则返回false</li>
<li>w.lock()：如果expired为true，返回一个空的shared_ptr；否则返回一个指向w的对象的shared_ptr</li>
</ul>
<p>从上面可以看出weak_ptr所指向的对象可能不存在，所以我们不能使用weak_ptr直接访问对象，而必须调用lock：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> vSp <span class="token operator">=</span> wp<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//在if中使用vSp访问共享对象是安全的</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<p><font size="5" color="orange">动态数组</font></p>
<hr>
<ol>
<li>标准库包含一个名为allocator的类，允许我们将分配和初始化分离。使用allocator通常会提供更好的性能和更灵活的内存管理能力。</li>
<li>大多数应用应该使用标准库容器而不是动态分配的数组。使用容器更为简单、更不容易出现内存管理错误并且可能有更好的性能。</li>
<li>我们用new分配的动态数组并不是数组类型，所以不能对动态数组调用begin或end：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
 <span class="token keyword">auto</span> it <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">begin</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//正确：可以对数组类型调用begin函数</span>
 <span class="token keyword">int</span> <span class="token operator">*</span>b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
 <span class="token function">memset</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">auto</span> it2 <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">begin</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//错误：不能对动态数组调用begin函数</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>释放动态数组时，需要在delete之后、指针名之前加上一个[ ]：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> <span class="token operator">*</span>b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
 <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
 动态数组中的元素按逆序销毁，即最后一个元素先被销毁，然后是倒数第二个…。</li>
<li>标准库提供了一个可以管理new分配的数组的unique_ptr版本，需要在模板参数的对象类型后面跟一个方括号：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> <span class="token function">up</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 up<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//自动调用delete[]销毁其指针</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
 但是如果要使用shared_ptr来管理一个动态数组，必须提供自定义的删除器：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">sp</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> p<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 sp<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//使用我们提供的lambda释放数组，它使用delete[]</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p>unique_ptr管理的动态数组可以通过下标来访问元素，但是shared_ptr不可以，它没有定义下标运算符。而且智能指针类型不支持指针算术运算。因此shared_ptr为了访问数组中的元素，必须先用get获取一个内置指针，然后用它来访问素组元素：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> <span class="token function">up</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
     up<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>

 std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">sp</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> p<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
     <span class="token operator">*</span><span class="token punctuation">(</span>sp<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> i<span class="token punctuation">)</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>当分配一大块内存时，我们通常计划在这块内存还是那个按需构造对象。在此情况下，我们希望将内存分配和对象构造分离。这意味着我们可以分配大块内存，但只在真正需要时才真正执行对象创建操作。</li>
<li>标准库allocator类定义在头文件memory中，它帮助我们将内存分配和对象构造分离开来。allocator也是一个模板，它会根据给定的对象类型来确定恰当的内存大小和对齐位置：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>allocator<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> Alloc<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//可以分配string的allocator对象</span>
 <span class="token keyword">auto</span> <span class="token keyword">const</span> p <span class="token operator">=</span> Alloc<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//分配n个未初始化的string</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
 allocator类的成员操作如下表：</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">allocator<t> a</t></td>
<td>定义一个allocator对象，它可以为类型为T的对象分配内存</td>
</tr>
<tr>
<td style="text-align:center">a.allocate(n)</td>
<td>分配一段原始的、未构造的内存，保存n个类型为T的对象</td>
</tr>
<tr>
<td style="text-align:center">a.deallocate(p, n)</td>
<td>释放从T*指针p中地址开始的内存，这块内存保存了n个类型为T的对象；p必须是一个先前由allocate返回的指针，且n必须是p创建时所要求的大小。在调用deallocate之前，用户必须对每个在这块内存中创建的对象调用destroy</td>
</tr>
<tr>
<td style="text-align:center">a.construct(p, args)</td>
<td>p必须是一个类型为T*的指针，指向一块原始内存；args被传递给类型为T的构造函数，用来在p指向的内存中构造一个对象</td>
</tr>
<tr>
<td style="text-align:center">a.destroy(p)</td>
<td>p为T*类型的指针，此算法对p指向的对象执行析构函数</td>
</tr>
</tbody>
</table>
<ol start="9">
<li>allocator分配的内存是未构造的，我们需要在此内存中构造对象，而construct成员函数接受一个指针和零个或多个额外参数，在指针所指的位置构造一个元素：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">auto</span> q <span class="token operator">=</span> p<span class="token punctuation">;</span>
 Alloc<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>q<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//*q为空字符串</span>
 Alloc<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>q<span class="token operator">++</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//*q为10个字符c组成的字符串</span>
 Alloc<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>q<span class="token operator">++</span><span class="token punctuation">,</span> <span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//*q为字符串hello</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
 还未构造对象的情况下就使用原始内存是错误的：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>allocator<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> Alloc<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//可以分配string的allocator对象</span>
 <span class="token keyword">auto</span> <span class="token keyword">const</span> p <span class="token operator">=</span> Alloc<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//分配n个未初始化的string</span>
 std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//错误：程序崩溃，因为p指向未构造的内存</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li>当我们用完对象后，必须对每个构造的元素调用destroy来销毁它们。函数destroy接受一个指针，对指向的对象执行析构函数：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">while</span> <span class="token punctuation">(</span>q <span class="token operator">!=</span> p<span class="token punctuation">)</span>
    Alloc<span class="token punctuation">.</span><span class="token function">destroy</span><span class="token punctuation">(</span><span class="token operator">--</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li>销毁这些被构造出来的元素以后，我们就可以使用deallocate成员函数把内存归还给系统了（当然也可以拿这些内存再去构造新的对象）。所以allocator使用四部曲就是：allocate、construct、destroy、deallocate：<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>allocator<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> Alloc<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//可以分配string的allocator对象</span>
<span class="token keyword">auto</span> <span class="token keyword">const</span> p <span class="token operator">=</span> Alloc<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//分配n个未初始化的string</span>
<span class="token keyword">auto</span> q <span class="token operator">=</span> p<span class="token punctuation">;</span>
Alloc<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>q<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//*q为空字符串</span>
Alloc<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>q<span class="token operator">++</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//*q为10个字符c组成的字符串</span>
Alloc<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>q<span class="token operator">++</span><span class="token punctuation">,</span> <span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//*q为字符串hello</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>q <span class="token operator">!=</span> p<span class="token punctuation">)</span>
    Alloc<span class="token punctuation">.</span><span class="token function">destroy</span><span class="token punctuation">(</span><span class="token operator">--</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment" spellcheck="true">//销毁每个构造出来的对象</span>
Alloc<span class="token punctuation">.</span><span class="token function">deallocate</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">//第二个参数必须与allocate分配内存时指定的参数相同</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>标准库还为allocator类定义了两个伴随算法：copy和fill，用于在未初始化内存（原始内存）中创建对象，定义在头文件memory中：<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> SVec<span class="token punctuation">{</span> <span class="token string">"Hello"</span><span class="token punctuation">,</span><span class="token string">"World"</span><span class="token punctuation">,</span><span class="token string">"Nice"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
std<span class="token operator">::</span>allocator<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> Alloc<span class="token punctuation">;</span>
<span class="token keyword">auto</span> p <span class="token operator">=</span> Alloc<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span>SVec<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//通过拷贝SVec中的元素来构造原始内存从p开始的元素</span>
<span class="token keyword">auto</span> q <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">uninitialized_copy</span><span class="token punctuation">(</span>SVec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> SVec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//将原始内存中剩余的未构造元素初始化为字符串Same</span>
std<span class="token operator">::</span><span class="token function">uninitialized_fill_n</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> SVec<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"Same"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">uninitialized_copy(b, e, b2)</td>
<td>将迭代器b到e范围内的元素拷贝到迭代器b2指向的未构造的原始内存中</td>
</tr>
<tr>
<td style="text-align:center">uninitialized_copy_n(b, n, b2)</td>
<td>从迭代器b指向的元素开始，拷贝n个元素到b2指向的原始内存中</td>
</tr>
<tr>
<td style="text-align:center">uninitialized_fill(b, e, t)</td>
<td>在迭代器b到e的元素内存范围内构造对象，对象的值均为t的拷贝</td>
</tr>
<tr>
<td style="text-align:center">uninitialized_fill_n(b, n, t)</td>
<td>从迭代器b指向的元素内存开始创建n个对象，对象的值均为t的拷贝</td>
</tr>
</tbody>
</table>
<p><font size="5" color="orange">使用标准库：文本查询程序</font></p>
<hr>
<ol>
<li>-_-||，最近比较忙，比较忙。。。有时间再来补上了(*￣︶￣)</li>
</ol>
<p>&nbsp; </p>
<hr>
<p>参考文献：《C++Primer第五版》</p>

            </div>

            <!-- Post Comments -->
            
    <!-- 使用 DISQUS_CLICK -->
<div id="disqus-comment">
    <div id="disqus_thread"></div>

<!-- add animation -->
<style>
	.disqus_click_btn {
            line-height: 30px;
            margin: 0;
            min-width: 50px;
            padding: 0 14px;
            display: inline-block;
            font-family: "Roboto", "Helvetica", "Arial", sans-serif;
            font-size: 14px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0;
            overflow: hidden;
            will-change: box-shadow;
            transition: box-shadow .2s cubic-bezier(.4, 0, 1, 1), background-color .2s cubic-bezier(.4, 0, .2, 1), color .2s cubic-bezier(.4, 0, .2, 1);
            outline: 0;
            cursor: pointer;
            text-decoration: none;
            text-align: center;
            vertical-align: middle;
            border: 0;
            background: rgba(158, 158, 158, .2);
            box-shadow: 0 2px 2px 0 rgba(0, 0, 0, .14), 0 3px 1px -2px rgba(0, 0, 0, .2), 0 1px 5px 0 rgba(0, 0, 0, .12);
            color: #fff;
            background-color: #7EC0EE;
            text-shadow: 0
        }
</style>
	
<div class="btn_click_load" id="disqus_bt"> 
    <button class="disqus_click_btn">点击查看评论</button>
</div>

<!--
<script type="text/javascript">
$('.btn_click_load').click(function() {
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'http-miccall-tech'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    document.getElementById('disqus_bt').style.display = "none";
});
</script>
-->
<script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://yoursite.com/2018/03/11/C++Primer第十二章动态内存/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = 'http://yoursite.com/2018/03/11/C++Primer第十二章动态内存/'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
</script>

<script type="text/javascript">
    $('.btn_click_load').click(function() {  //click to load comments
        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document;
            var s = d.createElement('script');
            s.src = '//http-miccall-tech.disqus.com/embed.js';
            s.setAttribute('data-timestamp', + new Date());
            (d.head || d.body).appendChild(s);
        })();
        $('.btn_click_load').css('display','none');
    });
</script>
</div>
<style>
    #disqus-comment{
        background-color: #eee;
        padding: 2pc;
    }
</style>


        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
                <li>Design: <a href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
            </ul>
            
            	<span id="busuanzi_container_site_pv">2019总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			
        </div>
    </div>
</body>



 	
</html>
