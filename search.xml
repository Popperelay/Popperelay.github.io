<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[测试markdown]]></title>
    <url>%2F2017%2F11%2F06%2F%E6%B5%8B%E8%AF%95markdown%2F</url>
    <content type="text"><![CDATA[测试 first second third阿萨德 奥术大师多]]></content>
  </entry>
  <entry>
    <title><![CDATA[C++Primer第一章开始]]></title>
    <url>%2F2017%2F11%2F04%2FC%2B%2BPrimer%E7%AC%AC%E4%B8%80%E7%AB%A0%E5%BC%80%E5%A7%8B%2F</url>
    <content type="text"><![CDATA[编写一个简单的C++程序 在一些系统中，即使文件就在当前目录或文件夹中，也必须显式指出文件的位置。在此情况下，我们可以输入： 1$ .\prog1 “.”后面跟一个反斜线可以指出该文件在当前目录中。 运行GNU编译器的命令是g++： 1$ g++ -o prog1 prog1.cc 其中，$是系统提示符；-o prog1是编译器参数，指定可执行文件的文件名；prog1.cc是代码源文件名。 运行微软VS编译器的命令为cl： 1C:\User\me\Programs&gt; cl /EHsc prog1.cpp 其中，C:\User\me\Programs&gt;是系统提示符，表示当前处于哪个路径下；命令cl可以调用编译器；/EHsc是编译器选项，用来打开标准异常处理。 初识输入输出 术语“流”想要表达的是：随之时间的推移，字符是顺序生成或消耗的。 cerr通常用来输出警告和错误消息，clog用来输出程序运行时的一般性信息。如果是控制台程序的话，它俩和cout一样都是输出到控制台的。 如下语句： 1std::cout &lt;&lt; "Enter two numbers:" &lt;&lt; std::endl; 我们在输出语句中用了两次&lt;&lt;运算符。因为此运算符返回其左侧的运算对象，因此第一个运算符的结果成为了第二个运算符的左侧运算对象，即等价于： 1(std::cout &lt;&lt; "Enter two numbers:") &lt;&lt; std::endl; 其中std::endl被称为操纵符，写入endl的效果是结束当前行，并将于设备关联的缓冲区(buffer)中的内容刷到设备中。缓冲刷新操作可以保证到目前为止程序所产生的所有输出都真正写入输出流中，而不是仅停留在内存中等待写入流。所以： 程序员常常在调试时添加打印语句。这类语句应该保证“一直”刷新流。否则，如果程序崩溃，输出可能还留在缓冲区中，从而导致关于程序崩溃位置的错误推断。 标准库定义的所有名字都在命名空间std中。 注释简介 编译器会忽略注释，因此注释对程序的行为或性能不会有任何影响。 当我们修改代码时，不要忘记同时更新注释。 控制流 如下程序： 12345678910#include &lt;iostream&gt;int main() &#123; int sum = 0, value = 0; while (std::cin &gt;&gt; value) sum += value; std::cout &lt;&lt; "Sum is: " &lt;&lt; sum &lt;&lt; std::endl; return 0;&#125; 当遇到文件结束符（end-of-file），或遇到一个无效输入时（例如读入的值不是一个整数），istream对象的状态才会变为无效，才会退出上面的while循环。所以仅仅输入空格或者回车，是无法让上述循环终止的。可以输入一个字符来终止循环： 12341 2 3 4 56 7aSum is: 28 除此之外，还可以输入文件结束符。在Windows系统中，输入文件结束符的方法是Ctrl+Z，然后按回车（Enter键），Unix系统中（包括Mac OS X系统），文件结束符输入是用Ctrl+D。 121 2 3^ZSum is: 6 类简介 标准库头文件通常不带后缀（string.h不属于标准库头文件，string头文件才是）。 是旧的C头文件，对应的是基于char*的字符串处理函数（C++为了兼容C的标准库）；是位于std中的C++头文件，对应的是基于string类的字符串处理函数；是旧C头文件对应的std版本，所以也是基于char*的。 文件重定向： 1$ addIems &lt;infile&gt; outfile $是操作系统提示符，addItems代表程序的可执行文件addItems.exe，则上述命令会从一个名为infile的文件读取输入，并将输出结果写入到一个名为outfile的文件中。用这种方法，我们就不必每次运行程序都往控制台手动输入一堆数据了。&nbsp; 参考文献：《C++Primer第五版》]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++Primer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenGL28：阴影映射]]></title>
    <url>%2F2017%2F11%2F03%2FOpenGL28%E9%98%B4%E5%BD%B1%E6%98%A0%E5%B0%84%2F</url>
    <content type="text"><![CDATA[阴影的重要意义 阴影是光线被阻挡的结果，它能够使场景看起来真实很多，可以让观察者获得物体之间的空间位置关系。如下图所示： 图1 可以看到，有阴影的时候能够更容易的看出立方体是悬浮在地板上的。 当前实时渲染领域还没找到一种完美的阴影算法，目前有几种近似阴影技术，但他它们都有自己的弱点和不足。游戏中常用的技术是阴影贴图（shadow mapping），效果不错，而且相对容易实现，性能也挺高，比较容易扩展为更高级的算法，如 Omnidirectional Shadow Maps和 Cascaded Shadow Maps。 阴影映射原理 在绘制物体的某个片元时，要确定它是否在阴影中，就是要判断它是否被别的片元挡住了。而这个挡住其实是光线被挡住了，所以应该从光源位置看过去，看这个片元是否被其他片元挡住。如下图所示： 图2判断是否被遮挡可以用深度贴图来实现：从光源处看过去（相当于把摄像机调整到光源的位置，即更改观察矩阵和投影矩阵，只是不渲染场景颜色而已），渲染一次场景（开启深度测试），将场景的深度值渲染到自定义帧缓冲的深度纹理附件中，此时深度纹理中存储的深度值就是离光源（或者说摄像机）最近的深度值，然后再渲染一次场景，这次渲染过程中判断当前片元的深度是否比对应位置上深度纹理中的深度更靠近光源（在屏幕空间里就是深度值更小），如果不是则说明该片元被挡住了，在阴影里。如下图所示： 图3右图中，在光源看来C点和P点处在同一xy位置（以光源为原点的坐标系）上，但是深度z不同，P点的深度是0.9，C点的深度是0.4，存储在深度纹理中的应该是最靠近光源的0.4，在绘制点P时由于其深度值0.9比从深度纹理中取出的0.4大，所以判定点P被挡住了，应该位于阴影里。 综上，深度映射通过两个步骤完成： 渲染深度纹理。 正常渲染场景，同时采样深度纹理来判断片元是否在阴影中。 用代码表示如下：12345678910111213// 1. 首先渲染深度贴图glViewport(0, 0, SHADOW_WIDTH, SHADOW_HEIGHT);glBindFramebuffer(GL_FRAMEBUFFER, depthMapFBO); glClear(GL_DEPTH_BUFFER_BIT); ConfigureShaderAndMatrices(); RenderScene();glBindFramebuffer(GL_FRAMEBUFFER, 0);// 2. 像往常一样渲染场景，但这次使用深度贴图glViewport(0, 0, SCR_WIDTH, SCR_HEIGHT);glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);ConfigureShaderAndMatrices();glBindTexture(GL_TEXTURE_2D, depthMap);RenderScene(); 渲染深度纹理我们需要从光源的视角去渲染得到一张场景的深度纹理，最后需要用它来计算阴影。为了将场景的深度保存到纹理中，我们需要用到帧缓冲，并且为它添加深度纹理附件：1234567891011121314151617GLuint DepthMap; glGenTextures(1, &amp;DepthMap); glBindTexture(GL_TEXTURE_2D, DepthMap); glTexImage2D(GL_TEXTURE_2D, 0, GL_DEPTH_COMPONENT, WIDTH, HEIGHT, 0, GL_DEPTH_COMPONENT, GL_FLOAT, NULL); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST); glBindTexture(GL_TEXTURE_2D, 0); GLuint DepthMapFBO; glGenFramebuffers(1, &amp;DepthMapFBO); glBindFramebuffer(GL_FRAMEBUFFER, DepthMapFBO); glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_TEXTURE_2D, DepthMap, 0); glDrawBuffer(GL_NONE); glReadBuffer(GL_NONE); if (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE) std::cout &lt;&lt; "Framebuffer is not complete!" &lt;&lt; std::endl; glBindFramebuffer(GL_FRAMEBUFFER, 0); 上面的代码首先创建了一张GL_DEPTH_COMPONENT格式的纹理，然后将它绑定到帧缓冲的深度附件上。 接下来我们需要从光源视角去渲染场景。先来看看着色器怎么写吧：12345678910#version 330 corelayout (location = 0) in vec3 position;uniform mat4 LightSpaceMVP; //projection * view * modelvoid main()&#123; gl_Position = LightSpaceMVP * vec4(position,1.0f);&#125; 12345#version 330 corevoid main()&#123;&#125; 可以看到渲染深度纹理的着色器相当简单，在顶点着色器里只是需要一个在光源视角下的MVP矩阵（投影矩阵、观察矩阵和物体模型矩阵的乘积），来计算在光源视角下的顶点坐标。片元着色器可以是空的，因为我们只想得到深度，所以没有必要在片元着色器里输出颜色。【注】： 直接使用MVP矩阵，是为了避免每一个顶点着色器都去执行模型矩阵、观察矩阵、投影矩阵的乘法运算，减少GPU的运算量，只需要每帧在应用程序里计算一次MVP矩阵，然后传给顶点着色器即可。这样还减少了传输带宽，毕竟只需要给GPU传一个MVP矩阵，而不是三个矩阵。 加下来需要我们在应用程序里算好这个LightSpaceMVP矩阵了：123456789mat4 View = lookAt(lightPos, lightPos + lightDirection, vec3(0, 1, 0));mat4 Projection = ortho(-6.0, 6.0, -6.0, 6.0, 0.1, 20.0);mat4 LightSpaceVP = Projection * View;mat4 CubeModel;CubeModel = translate(CubeModel, glm::vec3(-1.0f, 0.0f, -1.0f));mat4 LightSpaceMVPCube = LightSpaceVP * CubeModel;mat4 PlaneModel;PlaneModel = mat4();mat4 LightSpaceMVPPlane = LightSpaceVP * PlaneModel; 场景里面有两个物体：地面和箱子，它们都需要在上面的着色器下绘制一次，由于它们的模型矩阵不同，所以它们的MVP矩阵需要分开算。观察矩阵通过平行光源的位置和方向来计算，投影矩阵是一个正交投影矩阵（因为场景里用的是平行光源）。 然后我们绑定自定义帧缓冲，激活着色器渲染场景，就可以渲染出深度纹理了：123456789101112glBindFramebuffer(GL_FRAMEBUFFER, DepthMapFBO);glClear(GL_DEPTH_BUFFER_BIT);GenerateDepthMap_Shader.Use();glUniformMatrix4fv(glGetUniformLocation(GenerateDepthMap_Shader.shaderProgram, "LightSpaceMVP"), 1, GL_FALSE, value_ptr(LightSpaceMVPCube));glBindVertexArray(cubeVAO);glDrawElements(GL_TRIANGLES, 36, GL_UNSIGNED_INT, 0);glUniformMatrix4fv(glGetUniformLocation(GenerateDepthMap_Shader.shaderProgram, "LightSpaceMVP"), 1, GL_FALSE, value_ptr(LightSpaceMVPPlane));glBindVertexArray(planeVAO);glDrawArrays(GL_TRIANGLES, 0, 6);glBindVertexArray(0); 我们可以用一张窗口四边形来渲染这张深度贴图：123456789glBindFramebuffer(GL_FRAMEBUFFER, 0);glClearColor(0.3f, 0.4f, 0.5f, 1.0f);glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); RenderDepthMap_Shader.Use();glBindVertexArray(windowQuadVAO);glBindTexture(GL_TEXTURE_2D, DepthMap);glDrawArrays(GL_TRIANGLES, 0, 6);glBindVertexArray(0); 渲染结果如下：所有源码在这里。 渲染阴影 我们先来看看着色器怎么写。 顶点着色器和正常渲染场景时一样，只是多了计算顶点在光源视角下的裁剪坐标这一步：123456789101112131415161718192021222324#version 330 corelayout (location = 0) in vec3 position;layout (location = 1) in vec2 texCoords;layout (location = 2) in vec3 normal;out vec2 VS_TexCoords;out vec3 VS_Normal;out vec3 VS_WorldPos;out vec4 VS_LightSpacePos;uniform mat4 u_LightSpaceMVP; //projection * view * modeluniform mat4 u_Model;uniform mat4 u_View;uniform mat4 u_Projection;void main()&#123; VS_TexCoords = texCoords; VS_Normal = transpose(inverse(mat3(u_Model))) * normal; VS_WorldPos = vec3(u_Model * vec4(position, 1.0f)); gl_Position = u_Projection * u_View * vec4(VS_WorldPos, 1.0f); VS_LightSpacePos = u_LightSpaceMVP * vec4(position, 1.0f);&#125; 其中u_LightSpaceMVP是光源视角下的模型矩阵、观察矩阵和投影矩阵的乘积。 将计算得到的顶点在光源视角下的裁剪坐标VS_LightSpacePos，传递给片元着色器，来计算阴影：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#version 330 corein vec2 VS_TexCoords;in vec3 VS_Normal;in vec3 VS_WorldPos;in vec4 VS_LightSpacePos;out vec4 Color;uniform sampler2D u_DiffuseMapSampler1;uniform sampler2D u_DepthMapSampler2;uniform vec3 u_LightPos;uniform vec3 u_LightDirection;uniform vec3 u_ViewPos;uniform vec3 u_LightColor;vec3 getDepthInLightSpace(vec4 vLightSpacePos)&#123; vec3 Temp = (vLightSpacePos / vLightSpacePos.w).xyz; Temp = Temp * 0.5 + 0.5; return Temp;&#125;void main()&#123; vec3 ObjectColor = texture(u_DiffuseMapSampler1, VS_TexCoords).rgb; float AmbientStrength = 0.3f; vec3 AmbientColor = AmbientStrength * ObjectColor; vec3 LightClipSpacePos = getDepthInLightSpace(VS_LightSpacePos); if(LightClipSpacePos.z &gt;= texture(u_DepthMapSampler2, LightClipSpacePos.xy).r + 0.01) &#123; Color = vec4(AmbientColor * ObjectColor, 1.0); return; &#125; vec3 Normal = normalize(VS_Normal); vec3 LightDir = normalize(-u_LightDirection); float DiffuseFactor = max(dot(Normal, LightDir), 0.0); vec3 DiffuseColor = DiffuseFactor * u_LightColor; vec3 ViewDir = normalize(u_ViewPos - VS_WorldPos); vec3 HalfDir = normalize(LightDir + ViewDir); float SpecularFactor = pow(max(dot(HalfDir, Normal), 0.0f), 32); vec3 SpecularColor = SpecularFactor * u_LightColor; Color = vec4((AmbientColor + DiffuseColor + SpecularColor) * ObjectColor, 1.0);&#125; 其中在片元着色器里，我们需要计算插值后的片元在光源视角下的深度：123456vec3 getDepthInLightSpace(vec4 vLightSpacePos)&#123; vec3 Temp = (vLightSpacePos / vLightSpacePos.w).xyz; Temp = Temp * 0.5 + 0.5; return Temp;&#125; 原理跟简单，就是模拟了一下透视除法，让xyz分量分别除以w分量（其实不除也可以，因为在我们的demo里用的是平行光，光源视角下的投影矩阵是正交投影，所以w分量其实是1，但是如果不是平行光，这一步还是必须要做的）。但是透视除法之后的坐标范围还是-1到1，而之后我们需要用这个坐标去查找之前的深度纹理，而且其z分量应该代表片元在光源视角下的深度，所以不应该有负数，我们需要把-1到1的范围映射到0到1，所以才有了：1Temp = Temp * 0.5 + 0.5; 然后我们就可以根据这个坐标（片元在光源视角下的裁剪坐标并且映射到了0到1的范围）的xy值，去之前保存下来的深度纹理里查找场景在这个xy位置上距离光源最近的深度值，如果当前片元在光源视角下的深度值大于从纹理中查找到的深度值，则说明这个片元被挡住了，应该在阴影里：12345if(LightClipSpacePos.z &gt;= texture(u_DepthMapSampler2, LightClipSpacePos.xy).r + 0.01)&#123; Color = vec4(AmbientColor * ObjectColor, 1.0); return;&#125; 这里对阴影的处理方式是让片元的颜色等于环境光颜色，不再对它做漫反射和镜面反射光照了。 对于不满足这个条件，即不在阴影里的片元，照常执行blinn-phong光照即可。 剩下的就是在应用程序里把着色器需要的顶点数据和uniform变量传进来就可以了，由于这些内容和之前的文章里几乎是一样的，所以不再赘述了，所有源码都在这里。 运行结果如下图所示： 改进阴影贴图 阴影fighting可以看到上面的阴影并不好，有很多条纹，这是由于深度贴图所能保存的精度有限，相邻的很多片元可能用的是同一个深度，如下图所示：可能表示的最大深度只有6位，那么图中0.9276355到0.9276364的部分都只能用0.927636来表示了，但是getDepthInLightSpace函数计算出来的片元深度精度通常更大，导致在比较时，0.9276355到0.927636的部分，比深度纹理中存储的0.927636小，不处于阴影中，而0.927636到0.9276364的部分比深度纹理中存储的0.927636更大，处于阴影中，所以会出现一半不在阴影中，而另一半在阴影中，而这种精度情况在每一个类似的精度范围内都会出现，所以造成了上图里的条纹状。【注：】 这里只是举了个例子，最大精度不一定是6位小数，也不一定是四舍五入，要视具体运行环境和硬件决定。 那么我们怎么避免这种深度精度问题呢？ 我们可以在判断条件上加一个很小的偏移量：12345if(LightClipSpacePos.z &gt;= texture(u_DepthMapSampler2, LightClipSpacePos.xy).r + 0.0009)&#123; Color = vec4(AmbientColor * ObjectColor, 1.0); return; &#125; 运行结果如下图所示：可以看到虽然很大程度上解决了条纹状问题，但是由于偏移量加得太小，在箱子的垂直表面上，坡度很大，导致上面还是有一些黑点，有两种方法可以解决：一种是加大偏移量，但是有可能会产生彼得潘效应（后文会介绍），另一种就是利用表面法线和光线的夹角来计算出一个偏移值，这样对于坡度大的地方偏移就大、对坡度小的地方偏移就很小：123456float Offset = max(0.0009, 0.0025 * (1.0 - dot(Normal, LightDir)));if(LightClipSpacePos.z &gt;= texture(u_DepthMapSampler2, LightClipSpacePos.xy).r + Offset)&#123; Color = vec4(AmbientColor * ObjectColor, 1.0); return; &#125; 运行结果如下： 但是，偏移量加多少合适需要多次微调，加少了会有黑点，加多了会有彼得潘效应，其实即使是上面的代码，运行程序后拉近看依然有彼得潘效应。想要调出合适的偏移量很难，很容易出现彼得潘效应。下面来看看什么是彼得潘效应。 彼得潘效应当偏移加的偏大时，可以看到阴影相对实际物体的偏移，如下图所示（这个偏移值加得很大0.01）：看起来像箱子漂浮在地面之上，但是实际上从顶点数据来看箱子是紧贴着地面的，这种错觉就是彼得潘效应（童话里彼得潘是个会飞的男孩……）。 经过代码实现，渲染阴影贴图时开启正面剔除依然不能消除彼得潘效应，只能用更精确的偏移值来让彼得潘效应更小，直到看不出来。 光视锥外的阴影在之前的片元着色器里，对于不在光源视角下的正交投影视锥里的片元，经过getDepthInLightSpace函数算出来的裁剪坐标绝对值将大于1，用这个坐标去索引深度纹理，当然得不到正确的深度值。因为默认深度纹理的环绕方式是repeat，所以导致在视锥之外的片元都处于阴影里，如下图所示： 有两个解决方案： 把正交投影矩阵的参数加大，让正交视锥能包含更大的区域。 如果当前正交视锥之外没有物体（或者没有需要投射阴影的物体），可以让视锥外的片元索引深度纹理得到的深度值总是1.0，这样这些片元就不会处在阴影里了。其实也就是想用绝对值大于1的坐标去索引深度纹理，总是得到1.0这个值，所以我们可以把深度纹理的环绕方式设为GL_CLAMP_TO_BORDER，让超出1.0的坐标永远得到的都是边界上的值，同时要设置边界颜色的r分量为1.0：1234glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER);GLfloat BorderColor[] = &#123; 1.0,0.0,0.0,1.0 &#125;;glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, BorderColor); 结果如下图所示： 可以发现在视锥横截面之外的片元都不再处于阴影里了，远处还有片元处于阴影里，是因为那块区域超过视锥的远平面，计算出来的深度值是大于1.0的，会永远比从深度纹理中取出来的值要大，所以会处于阴影里。有两种解决方案： 在正交投影矩阵里加大远平面的距离。 在片元着色器里计算裁剪坐标的时候，如果最后发现裁剪坐标的z值大于1.0，则把其z值强制更改为0：12345678vec3 getDepthInLightSpace(vec4 vLightSpacePos)&#123; vec3 Temp = (vLightSpacePos / vLightSpacePos.w).xyz; Temp = Temp * 0.5 + 0.5; if(Temp.z &gt; 1.0) Temp.z = 0.0; return Temp;&#125; 运行结果如下图：到此的所有源码都在这里。其中解开一些注释代码就能看到这一小节说过的各种结果。 PCF拉近了看，会发现阴影边缘走样很严重，有明显的锯齿，如下图所示：这是因为深度纹理的分辨率有限，多个片元可能对应同一个阴影，这样采样计算阴影时就会产生锯齿边。当然可以通过增加深度纹理分辨率的方式来降低锯齿块。但是这样会增加很多内存开销。 我们可以用一种叫做PCF（percentage-closer filtering）的技术来得到更柔和一点的阴影：对片元裁剪坐标的四周多次采样，对采样的结果（在或者不在阴影里）求均值。实现代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#version 330 corein vec2 VS_TexCoords;in vec3 VS_Normal;in vec3 VS_WorldPos;in vec4 VS_LightSpacePos;out vec4 Color;uniform sampler2D u_DiffuseMapSampler1;uniform sampler2D u_DepthMapSampler2;uniform vec3 u_LightPos;uniform vec3 u_LightDirection;uniform vec3 u_ViewPos;uniform vec3 u_LightColor;vec3 getDepthInLightSpace(vec4 vLightSpacePos)&#123; vec3 Temp = (vLightSpacePos / vLightSpacePos.w).xyz; Temp = Temp * 0.5 + 0.5; //远平面外的深度值更改为0.0 if(Temp.z &gt; 1.0) Temp.z = 0.0; return Temp;&#125;void main()&#123; vec3 ObjectColor = texture(u_DiffuseMapSampler1, VS_TexCoords).rgb; //Ambient Lighting float AmbientStrength = 0.3f; vec3 AmbientColor = AmbientStrength * ObjectColor; vec3 LightClipSpacePos = getDepthInLightSpace(VS_LightSpacePos); vec3 Normal = normalize(VS_Normal); vec3 LightDir = normalize(-u_LightDirection); //PCF阴影测试 float Offset = max(0.002, 0.0025 * (1.0 - dot(Normal, LightDir))); float Shadow = 0.0; vec2 texelSize = 1.0 / textureSize(u_DepthMapSampler2, 0); if(LightClipSpacePos.z != 0.0) &#123; for(int x = -1; x &lt;= 1; ++x) &#123; for(int y = -1; y &lt;= 1; ++y) &#123; if(LightClipSpacePos.z &gt;= texture(u_DepthMapSampler2, LightClipSpacePos.xy + vec2(x, y) * texelSize).r + Offset) Shadow += 1.0; &#125; &#125; &#125; Shadow /= 9.0; //Diffuse Lighting float DiffuseFactor = max(dot(Normal, LightDir), 0.0); vec3 DiffuseColor = DiffuseFactor * u_LightColor; //Specular Lighting vec3 ViewDir = normalize(u_ViewPos - VS_WorldPos); vec3 HalfDir = normalize(LightDir + ViewDir); float SpecularFactor = pow(max(dot(HalfDir, Normal), 0.0f), 32); vec3 SpecularColor = SpecularFactor * u_LightColor; Color = vec4((AmbientColor + (1.0 - Shadow) * (DiffuseColor + SpecularColor)) * ObjectColor, 1.0);&#125; 其中texelSize 是深度纹理中每个纹素的大小。 运行结果如下图所示：可以发现，阴影边缘确实较之前柔和了一些。 所有源码请看这里。 透视投影渲染深度贴图 之前用的是正交投影来渲染深度纹理，这对于平行光比较适用，但是对于点光源和聚光灯，透视投影更适合。只是透视投影渲染得到的深度纹理里的深度值是非线性的，有两种就解决方案： 在片元着色器里，计算片元在光源视角下的裁剪坐标时，手动做一次透视除法，这样也就变为非线性的深度。 不在片元着色器里计算片元的裁剪坐标，计算到它在观察空间里的深度就好了，然后把从深度纹理中的非线性深度转变为观察空间里的线性深度。怎么转换呢？可以参考《OpenGL15：深度测试》里说过的非线性深度公式：$$\begin{equation}F_{depth} = \frac{1/z - 1/near}{1/far - 1/near}\end{equation}$$12345float LinearizeDepth(float depth)&#123; float z = depth * 2.0 - 1.0; // Back to NDC return (2.0 * near_plane * far_plane) / (far_plane + near_plane - z * (far_plane - near_plane));&#125; &nbsp; 参考文献：LearnOpenGL]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>ShadowMap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[老张培训笔记第五课责任链模式和适配器模式]]></title>
    <url>%2F2017%2F08%2F31%2F%E8%80%81%E5%BC%A0%E5%9F%B9%E8%AE%AD%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%BA%94%E8%AF%BE%2F</url>
    <content type="text"><![CDATA[感谢老张！ 案例：实现员工请假系统，要求如下： 公司有三个级别的可以批假的员工，其批假权限为： TeamLeader：可以批准10天以内的请假。 ProjectLeader：可以批准20天以内的请假。 HR：可以批准30天以内的请假。 30天以上的假期不能批准，只能离职。 审批流程：先由TeamLeader进行审批，若权限不够则交由ProjectLeader处理，若权限还不够则交由HR处理。 分析上述案列，我们需要实现如下几个功能： 审批流程：TeamLeader→ProjectLeader→HR。 审批权限：每级都有自己独立的审批权限。 审批：审批动作本身。 最常见的方式 通常最容易想到的就是按C语言的方式在主程序里通过if-else的判断来实现这种逐级处理。 我们先把请假请求封装成一个类，当中有一个表示请假天数的成员变量（封装成类是为了后续需求变化考虑，因为可能请假可能不仅考虑到天数，还考虑到职位、在团队里的重要性等等）：12345678910class CLeaveRequest &#123;public: CLeaveRequest() &#123;&#125; CLeaveRequest(int vLeaveDays) : m_LeaveDays(vLeaveDays) &#123;&#125; int getLeaveDays() const &#123; return m_LeaveDays; &#125;private: int m_LeaveDays;&#125;; 我们再创建一个员工的基类（依赖倒置原则），它只有一个表示审批动作本身的函数，至于通不通过我们在主程序里通过if-else去实现：123456#include "LeaveRequest.h"class CEmployee&#123;public: virtual void approveLeaveV(const CLeaveRequest *vLeaveRequest) const = 0;&#125;; 然后实现员工类的3个子类，它们各自有自己具体的审批动作：123456789#include &lt;iostream&gt;#include "Employee.h"class CTeamLeader : public CEmployee&#123;public: virtual void approveLeaveV(const CLeaveRequest *vLeaveRequest) const override &#123; std::cout &lt;&lt; "The leave request of" &lt;&lt; vLeaveRequest-&gt;getLeaveDays() &lt;&lt; " days has been approved by team leader." &lt;&lt; std::endl; &#125;&#125;; 123456789#include &lt;iostream&gt;#include "Employee.h"class CProjectLeader : public CEmployee &#123;public: virtual void approveLeaveV(const CLeaveRequest *vLeaveRequest) const override &#123; std::cout &lt;&lt; "The leave request of" &lt;&lt; vLeaveRequest-&gt;getLeaveDays() &lt;&lt; " days has been approved by project leader." &lt;&lt; std::endl; &#125;&#125;; 123456789#include &lt;iostream&gt;#include "Employee.h"class CHR : public CEmployee &#123;public: virtual void approveLeaveV(const CLeaveRequest *vLeaveRequest) const override &#123; std::cout &lt;&lt; "The leave request of" &lt;&lt; vLeaveRequest-&gt;getLeaveDays() &lt;&lt; " days has been approved by HR." &lt;&lt; std::endl; &#125;&#125;; 然后我们在主函数里创建请求以及三类员工的对象：123456789#include "TeamLeader.h"#include "ProjectLeader.h"#include "HR.h"int main() &#123; CTeamLeader *pTeamLeader = new CTeamLeader; CProjectLeader *pProjectLeader = new CProjectLeader; CHR *pHR = new CHR; CLeaveRequest *pLeaveRequest = new CLeaveRequest(25); 然后从TeamLeader开始，使用if-else判断请假类里的天数是否满足他的天数限制，如果不满足，则看是否满足他的上司的天数限制，以此类推：1234567891011121314151617 if (pLeaveRequest-&gt;getLeaveDays() &lt; 10) &#123; pTeamLeader-&gt;approveLeaveV(pLeaveRequest); &#125; else &#123; if (pLeaveRequest-&gt;getLeaveDays() &lt; 20) &#123; pProjectLeader-&gt;approveLeaveV(pLeaveRequest); &#125; else &#123; if (pLeaveRequest-&gt;getLeaveDays() &lt; 30) &#123; pHR-&gt;approveLeaveV(pLeaveRequest); &#125; else &#123; std::cout &lt;&lt; "The only way to get " &lt;&lt; pLeaveRequest-&gt;getLeaveDays() &lt;&lt; " leave days to quit the company." &lt;&lt; std::endl; &#125; &#125; &#125;&#125; 程序输出的结果如下：1The leave request of 25 days has been approved by HR. 但是这多重if-else明显不符合开闭原则，审批条件和审批流程完全在客户端实现，即客户端和审批业务耦合太紧。 责任链模式 上面的实现不符合开闭原则，我们需要把审批条件以及审批流程移到CEmployee及其派生类中，降低客户端和业务类的耦合度。 怎么把审批流程移过去呢？审批是一级一级上交的，自己这级权限不够，就需要交给上级来处理，所以关键就是两点： 怎么知道自己权限不够？ 怎么知道自己上级是谁？ 我们先看怎么知道自己的上级，某个员工要知道自己的上级是谁，其实很简单，在员工基类里加一个表示上级的成员变量就可以了：1234567891011121314#include "LeaveRequest.h"class CEmployee&#123;public: CEmployee() :m_Superior(NULL) &#123;&#125; virtual void approveLeaveV(const CLeaveRequest *vLeaveRequest) const = 0; void setSuperior(CEmployee *vSuperior) &#123; m_Superior = vSuperior; &#125; const CEmployee* getSuperior() const &#123; return m_Superior; &#125;private: const CEmployee *m_Superior;&#125;; 每级员工都知道自己的权限天数是多少，不满足则交给他的上级m_Superior来处理：12345678910111213#include &lt;iostream&gt;#include "Employee.h"class CTeamLeader : public CEmployee&#123;public: virtual void approveLeaveV(const CLeaveRequest *vLeaveRequest) const override &#123; if (vLeaveRequest-&gt;getLeaveDays() &lt; 10) std::cout &lt;&lt; "The leave request of " &lt;&lt; vLeaveRequest-&gt;getLeaveDays() &lt;&lt; " days has been approved by team leader." &lt;&lt; std::endl; else if(getSuperior()) getSuperior()-&gt;approveLeaveV(vLeaveRequest); &#125;&#125;; 12345678910111213#include &lt;iostream&gt;#include "Employee.h"class CProjectLeader : public CEmployee &#123;public: virtual void approveLeaveV(const CLeaveRequest *vLeaveRequest) const override &#123; if (vLeaveRequest-&gt;getLeaveDays() &lt; 20) std::cout &lt;&lt; "The leave request of " &lt;&lt; vLeaveRequest-&gt;getLeaveDays() &lt;&lt; " days has been approved by project leader." &lt;&lt; std::endl; else if (getSuperior()) getSuperior()-&gt;approveLeaveV(vLeaveRequest); &#125;&#125;; 123456789101112#include &lt;iostream&gt;#include "Employee.h"class CHR : public CEmployee &#123;public: virtual void approveLeaveV(const CLeaveRequest *vLeaveRequest) const override &#123; if (vLeaveRequest-&gt;getLeaveDays() &lt; 30) std::cout &lt;&lt; "The leave request of " &lt;&lt; vLeaveRequest-&gt;getLeaveDays() &lt;&lt; " days has been approved by HR." &lt;&lt; std::endl; else std::cout &lt;&lt; "The only way to get " &lt;&lt; vLeaveRequest-&gt;getLeaveDays() &lt;&lt; " leave days to quit the company." &lt;&lt; std::endl; &#125;&#125;; 这时主函数就变得很简单了，只需要把请求交给底层的TeamLeader就行，它会自动逐级上交审批请求的：123456789101112131415#include "TeamLeader.h"#include "ProjectLeader.h"#include "HR.h"int main() &#123; CTeamLeader *pTeamLeader = new CTeamLeader; CProjectLeader *pProjectLeader = new CProjectLeader; CHR *pHR = new CHR; CLeaveRequest *pLeaveRequest = new CLeaveRequest(25); pTeamLeader-&gt;setSuperior(pProjectLeader); pProjectLeader-&gt;setSuperior(pHR); pTeamLeader-&gt;approveLeaveV(pLeaveRequest);&#125; 这就是责任链模式：在具有上下级关系的一串对象中，每一级对象都含有其直接上级对象的指针。这样就将请求的处理者组织成一条链，客户端无需关心请求的处理细节以及请求的传递，只需要将请求发送到链上，实现请求的发送者和处理者解耦。请求会沿着链向上传递。但是，很明显的，系统性能会受到一定影响。 但是上面代码里，三类员工的approveLeaveV函数有没有太像了？几乎只有一个10、20、30不同，外加审批通过后作出的反应不同（这里是输出的字符串不同）。这代码明显重复得太厉害了，确定写的时候没有CtrlC、CtrlV？有没有什么办法能够减少重复代码？如果能够把这段approveLeaveV函数代码移到基类CEmployee当然就可以减少每个子类重复写了，但是那两个不同的地方怎么处理？先看第一个不同地方：每一级员工的权限天数不一样，我们在基类里设置一个表示权限天数的变量就可以了，子类在创建后分别给这个变量赋以不同的值就OK：1234567891011class CEmployee&#123;public: ... void setMaxApproveDays(int vMaxApproveDays) &#123; m_MaxApproveDays = vMaxApproveDays; &#125; int getMaxApproveDays() const &#123; return m_MaxApproveDays; &#125; ...private: const CEmployee *m_Superior; int m_MaxApproveDays;&#125;; 那么第二个不同的地方：审批通过后的反应不同，这个我们可以用多态啊！在基类里设置一个表示审批通过的函数：12345678910class CEmployee&#123;public: ... virtual void approvePassedV(const CLeaveRequest *vLeaveRequest) const = 0; ...private: const CEmployee *m_Superior; int m_MaxApproveDays;&#125;; 把这两个不同的地方都用基类的变量或者虚函数处理掉以后，就可以把approvePassedV函数搬到基类了：1234567891011121314151617181920212223242526Employee.h:#include "LeaveRequest.h"class CEmployee&#123;public: CEmployee() :m_Superior(NULL), m_MaxApproveDays(0) &#123;&#125; void approveLeave(const CLeaveRequest *vLeaveRequest) const &#123; if (vLeaveRequest-&gt;getLeaveDays() &lt; getMaxApproveDays()) approvePassedV(vLeaveRequest); else if (getSuperior()) getSuperior()-&gt;approveLeave(vLeaveRequest); &#125; void setSuperior(CEmployee *vSuperior) &#123; m_Superior = vSuperior; &#125; const CEmployee* getSuperior() const &#123; return m_Superior; &#125; void setMaxApproveDays(int vMaxApproveDays) &#123; m_MaxApproveDays = vMaxApproveDays; &#125; int getMaxApproveDays() const &#123; return m_MaxApproveDays; &#125; virtual void approvePassedV(const CLeaveRequest *vLeaveRequest) const = 0;private: const CEmployee *m_Superior; int m_MaxApproveDays;&#125;; 子类会去分别重写这个虚函数：12345678910CTeamLeader.h:#include &lt;iostream&gt;#include "Employee.h"class CTeamLeader : public CEmployee&#123;public: virtual void approvePassedV(const CLeaveRequest *vLeaveRequest) const override &#123; std::cout &lt;&lt; "The leave request of " &lt;&lt; vLeaveRequest-&gt;getLeaveDays() &lt;&lt; " days has been approved by team leader." &lt;&lt; std::endl; &#125;&#125;; 12345678910CProjectLeader.h:#include &lt;iostream&gt;#include "Employee.h"class CProjectLeader : public CEmployee &#123;public: virtual void approvePassedV(const CLeaveRequest *vLeaveRequest) const override &#123; std::cout &lt;&lt; "The leave request of " &lt;&lt; vLeaveRequest-&gt;getLeaveDays() &lt;&lt; " days has been approved by project leader." &lt;&lt; std::endl; &#125;&#125;; 12345678910CHR.h:#include &lt;iostream&gt;#include "Employee.h"class CHR : public CEmployee &#123;public: virtual void approvePassedV(const CLeaveRequest *vLeaveRequest) const override &#123; std::cout &lt;&lt; "The leave request of " &lt;&lt; vLeaveRequest-&gt;getLeaveDays() &lt;&lt; " days has been approved by HR." &lt;&lt; std::endl; &#125;&#125;; 12345678910111213141516171819main.cpp:#include "TeamLeader.h"#include "ProjectLeader.h"#include "HR.h"int main() &#123; CTeamLeader *pTeamLeader = new CTeamLeader; CProjectLeader *pProjectLeader = new CProjectLeader; CHR *pHR = new CHR; CLeaveRequest *pLeaveRequest = new CLeaveRequest(25); pTeamLeader-&gt;setSuperior(pProjectLeader); pProjectLeader-&gt;setSuperior(pHR); pTeamLeader-&gt;setMaxApproveDays(10); pProjectLeader-&gt;setMaxApproveDays(20); pHR-&gt;setMaxApproveDays(30); pTeamLeader-&gt;approveLeave(pLeaveRequest);&#125; 这样一来，就减少了子类里重复的代码，看起来更简洁，扩展性也更好。主要是要通过这个过程了解怎样把子类的相似代码抽象到父类中，体会抽象、多态的思想，尽可能用更少的代码去实现相同的功能。 另一个案例 案例：某公司需要实现验证客户信息的功能（姓名、地址、电话号码、社保号码等），实现了一个抽象类来完成这些功能：123456class CInfoValidation &#123; virtual bool isValidName() = 0; virtual bool isValidAddress() = 0; virtual bool isValidPhoneNumber() = 0; virtual bool isValidSSN() = 0;&#125;; 为了加快开发进度，购买了别人的产品，其中提供了类CLegacyInfoValidation，但是只完成了部分功能，而且只有动态链接库和头文件，卖方没有提供源码：123456class CLegacyInfoValidation &#123;public: bool isNameValid(); bool isAddressValid(); bool isPhoneNumberValid();&#125;; 可见少了一个严重SSN的功能，而且卖方提供的接口和已有的抽象类接口不一致，那么应该怎么复用别人已经实现好的功能呢？ 最码农的做法 最直接也是最码农的做法，就是把自己抽象类的接口改成和别人接口形式一样，让自己的抽象类CInfoValidation 派生别人的类CLegacyInfoValidation ，再增加一个验证SSN的函数：123456#include "LegacyInfoValidation.h"class CInfoValidation : public CLegacyInfoValidation &#123;public: virtual bool isSSNValid() &#123;...&#125;&#125;; 这样就能在自己的抽象类里复用别人实现的其他3个功能了，但是这明显不符合开闭原则，改动了已有代码，导致程序中依赖原始接口的代码必须发生相应修改：123456bool ValidateInfo(CInfoValidation *vValidator) &#123; if (!vValidator-&gt;isValidName()) return false; if (!vValidator-&gt;isValidAddress()) return false; if (!vValidator-&gt;isValidPhoneNumber()) return false; if (!vValidator-&gt;isValidSSN()) return false;&#125; 其中vValidator调用的函数名都要改。。。 类适配器模式别人实现了前三个验证，公司自己实现第四个验证，想要复用别人的函数完全可以靠继承嘛！上面最码农的做法也是靠继承来复用的，但是它改变了原有的类设计，我们完全可以不改嘛，在自己原有的isValidName函数里调用别人的isNameValid函数：1234567891011121314#include "LegacyInfoValidation.h"class CInfoValidation :public CLegacyInfoValidation &#123; virtual bool isValidName() &#123; isNameValid(); &#125; virtual bool isValidAddress() &#123; isAddressValid(); &#125; virtual bool isValidPhoneNumber() &#123; isPhoneNumberValid(); &#125; virtual bool isValidSSN() = 0;&#125;; 这样程序中依赖原始接口的代码就不需要改变了（比如上面ValidateInfo函数中的方法调用就不需要改动了），但是这还是或多或少改动了原有的CInfoValidation 类代码。 如果想一点都不改动，只是增加新代码，也就是既想用CLegacyInfoValidation 类的三个方法，又想用CInfoValidation 类的isValidSSN方法，想用到两个类的方法，我们可以多重继承啊，派生一个新的类：12345678910111213141516171819202122#include "InfoValidation.h"#include "LegacyInfoValidation.h"class CInfoValidationAdapter : public CInfoValidation, private CLegacyInfoValidation&#123;public: virtual bool isValidName() override &#123; isNameValid(); &#125; virtual bool isValidAddress() override &#123; isAddressValid(); &#125; virtual bool isValidPhoneNumber() override &#123; isPhoneNumberValid(); &#125; virtual bool isValidSSN() &#123; if(...) return true; &#125;&#125;; 123456class CInfoValidation &#123; virtual bool isValidName() = 0; virtual bool isValidAddress() = 0; virtual bool isValidPhoneNumber() = 0; virtual bool isValidSSN() = 0;&#125;; 123456class CLegacyInfoValidation &#123;public: bool isNameValid(); bool isAddressValid(); bool isPhoneNumberValid();&#125;; 一样的，程序中依赖原始接口的代码还是不用改，比如之前的ValidateInfo方法中的函数调用，不过传入的CInfoValidation对象指针应该是来自新的CInfoValidationAdapter 类对象了，而不是原始的CInfoValidation 类对象。但是这基本上是在客户端才做出的改动，影响很小。 这就是类对象适配器：通过类继承来复用别的类的函数代码。 对象适配器模式 上面的代码有个比较麻烦的地方，新的类是通过多重继承得到的，当程序变得复杂以后，这可能会带来一些不必要的麻烦，比如野指针、类爆炸等等。 可以通过合成复用原则来解决这个问题，不派生CLegacyInfoValidation 类，而是使用该类对象作为新的类的成员变量，通过变量对象来使用CLegacyInfoValidation 的函数：12345678910111213141516171819202122232425#include "InfoValidation.h"#include "LegacyInfoValidation.h"class CInfoValidationAdapter : public CInfoValidation&#123;public: virtual bool isValidName() override &#123; m_LegacyValidator.isNameValid(); &#125; virtual bool isValidAddress() override &#123; m_LegacyValidator.isAddressValid(); &#125; virtual bool isValidPhoneNumber() override &#123; m_LegacyValidator.isPhoneNumberValid(); &#125; virtual bool isValidSSN() &#123; if (...) return true; &#125;private: CLegacyInfoValidation m_LegacyValidator;&#125; 为什么使用CLegacyInfoValidation 类对象作为成员变量，而不使用CInfoValidation类对象，这个道理很简单啊~。因为程序里原本可能会有很多依赖原有抽象类CInfoValidation的地方，我们让新类派生自CInfoValidation类，就可以使用多态了，原来存在依赖的代码不用做任何修改，只是在传入对象参数的时候，实参由原来的CInfoValidation类对象，改成了现在的CInfoValidationAdapter 子类对象而已。 这就是对象适配器模式：通过合成复用（对象成员），来复用别的类的函数代码。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>责任链模式适配器模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[老张培训笔记第四课外观模式、观察者模式和命令模式]]></title>
    <url>%2F2017%2F08%2F30%2F%E8%80%81%E5%BC%A0%E5%9F%B9%E8%AE%AD%E7%AC%94%E8%AE%B0%E7%AC%AC%E5%9B%9B%E8%AF%BE%2F</url>
    <content type="text"><![CDATA[感谢老张！ 案例：房间里有一台电视和一台空调，按下遥控器的Open键后，可以同时打开空调和电视。设计程序来实现该按键的功能。 最普通的解决方案 最普通也是最容易想到的方法，就是分别建一个电视类、空调类、遥控器类，在遥控器类里调用电视类和空调类的打开方法，然后在主程序里调用遥控器类：1234567891011TV.h:#pragma once#include &lt;iostream&gt;class CTV&#123;public: void open()&#123; std::cout &lt;&lt; "The TV is turned on." &lt;&lt; std::endl; &#125;&#125;; 1234567891011AirCondition.h:#pragma once#include &lt;iostream&gt;class CAirCondition&#123;public: void open()&#123; std::cout &lt;&lt; "The AirCondition is turned on." &lt;&lt; std::endl; &#125;&#125;; 12345678910111213RemoteController.h:#pragma once#include "TV.h"#include "AirCondition.h"class CRemoteController &#123;public: void onOpenClicked(CTV *vTV, CAirCondition *vAirCondition) &#123; vTV-&gt;open(); vAirCondition-&gt;open(); &#125;&#125;; 123456789101112131415main.cpp:#include &lt;iostream&gt;;#include "AirCondition.h"#include "TV.h"#include "RemoteController.h"int main() &#123; CTV *pTV = new CTV(); CAirCondition *pAirCondition = new CAirCondition(); CRemoteController *pRemoteController = new CRemoteController(); pRemoteController-&gt;onOpenClicked(pTV, pAirCondition); return 0;&#125; 不过这种方法很明显太粗糙了，首先CRemoteController 类的onOpenClicked直接依赖于某个具体对象，这种依赖性太强，让它在调用之前就事先确定了自己要调用的只有电视和空调，如果还要加些别的电器呢？就得去增加参数，修改函数体内容，不符合开闭原则。我们可以使用之前课程讲的依赖倒置原则，让该函数只依赖于抽象类：电视和空调的抽象父类CDevice：1234567Device.h:#pragma onceclass CDevice &#123;public: virtual void openV() = 0;&#125;; 123456789101112TV.h:#pragma once#include &lt;iostream&gt;#include "Device.h"class CTV :public CDevice &#123;public: virtual void openV() override &#123; std::cout &lt;&lt; "The TV is turned on." &lt;&lt; std::endl; &#125;&#125;; 123456789101112AirCondition.h:#pragma once#include &lt;iostream&gt;#include "Device.h"class CAirCondition :public CDevice &#123;public: virtual void openV() override &#123; std::cout &lt;&lt; "The AirCondition is turned on." &lt;&lt; std::endl; &#125;&#125;; 12345678910111213141516RemoteController.h:#pragma once#include &lt;vector&gt;#include "TV.h"#include "AirCondition.h"class CRemoteController &#123;public: void onOpenClicked(std::vector&lt;CDevice*&gt;&amp; vDevice) &#123; for each (CDevice* e in vDevice) &#123; e-&gt;openV(); &#125; &#125;&#125;; 1234567891011121314151617main.cpp:#include &lt;iostream&gt;;#include &lt;vector&gt;#include "AirCondition.h"#include "TV.h"#include "RemoteController.h"int main() &#123; std::vector&lt;CDevice*&gt; pDevice; pDevice.push_back(new CTV); pDevice.push_back(new CAirCondition); CRemoteController *pRemoteController = new CRemoteController(); pRemoteController-&gt;onOpenClicked(pDevice, 2); return 0;&#125; CRemoteController类的onOpenClicked函数现在只是依赖抽象类CDevice ，而不是具体的某个类，这样当房间里电器个数增加时，CRemoteController类不需要任何改变，将符合开闭原则。 但是，客户端程序（main）知道的太多了，因为是在客户端里创建房间内的物品，因此它需要知道房间里有哪些物品这个细节。 外观模式 我们需要把客户端创建物品的程序移出去，移到一个房间类CRoom里，让这个房间类来负责创建房间里的所有物品，而客户端程序不需要知道有哪些物品被创建了，只需要调用房间内类的一个接口就行，在这个接口里，房间里的所有物品执行打开函数：123456789101112131415161718192021#pragma once#include "AirCondition.h"#include "TV.h"class CRoom &#123;public: CRoom() &#123; m_pTV = new CTV; m_pAirCondition = new CAirCondition; &#125; void onEnterRoom() &#123; m_pTV-&gt;openV(); m_pAirCondition-&gt;openV(); &#125;private: CTV *m_pTV; CAirCondition *m_pAirCondition;&#125;; 12345678910#pragma once#include "Room.h"class CRemoteController &#123;public: void onOpenClicked(CRoom *vRoom) &#123; vRoom-&gt;onEnterRoom(); &#125;&#125;; 1234567891011#include &lt;iostream&gt;;#include "RemoteController.h"#include "Room.h"int main() &#123; CRoom *pRoom = new CRoom(); CRemoteController *pRemoteController = new CRemoteController(); pRemoteController-&gt;onOpenClicked(pRoom); return 0;&#125; 这样一来减轻了应用程序的负担，让应用程序不必知道房间里具体有什么东西。这其实就是外观模式：把一堆接口（/函数）组合到一个单独的类里。如下图所示：将一堆子系统组合起来，合到一个外观类里，客户端通过外观类来间接和内部的子系统打交道，这样客户端和子系统之间的复杂关系可以通过外观模式来简化，降低了系统的耦合度以及复杂程度，也提高了客户端使用的便捷性，使得客户端无须关心子系统的工作细节，通过外观角色即可调用相关功能。 不过外观模式显然不符合开闭原则，因为房间里物品增多时，需要去改变CRoom类，但是它把这种变化限制在CRoom里了，程序并没有发生连锁反应。所以，外观模式在一定程度上还是可以接受的。 迪米特法则 迪米特法则：一个软件应该尽可能少地与其他实体发生相互作用。 比如某系统与数据访问类之间的调用关系较为复杂，如下图：根据迪米特法则，在中间加一层Controller：很明显，系统复杂度降低了很多。 观察者模式 既然外观模式不符合开闭原则，那么我们从另一个角度考虑：我们从客户端发出了一个按键事件，然后需要空调、电视来响应这个事件。但是空调电视要怎么去接收这个事件呢？需要它们去时时刻刻监听事件，简单点，就是服务端CRemoteController里有一堆事件集合（每种事件一个集合），由客户端向这个事件集合里push事件，在最后服务端会让空调、电视等来执行这些事件。 但是这个事件集合是什么东东呢？ 比如我们把按遥控器开关键作为一个事件，但是不能把按开关键作为一个事件发给服务端，因为这只是一个动作，只发送一个动作过去，服务端并不知道由哪个具体对象来执行这个动作，所以我们可以发给服务端响应这个动作的对象（观察者）。这里响应按键的对象是空调、电视，也就是要把空调、电视等对象发送给服务端，这个时候的事件其实就是响应动作的对象，但是服务端需要的是事件集合，所以需要对空调、电视等等对象做一层抽象，抽象为CDevice，这样服务端所存储的事件集合，其实就可以是CDevice对象的集合（这个适合我觉得换个名字更好：观察者集合）。最后服务端执行集合里所有CDevice对象的openV函数，就可以完成对按键这个事件的响应了：1234567891011121314151617181920#pragma once#include &lt;vector&gt;#include "AirCondition.h"#include "TV.h"class CRoom &#123;public: CRoom() &#123; m_Devices.push_back(new CTV); m_Devices.push_back(new CAirCondition); &#125; std::vector&lt;CDevice*&gt; fetchDevices() &#123; return m_Devices; &#125;private: std::vector&lt;CDevice*&gt; m_Devices;&#125;; 12345678910111213141516171819202122#pragma once#include &lt;vector&gt;#include "TV.h"#include "AirCondition.h"class CRemoteController &#123;public: void onOpenClicked() &#123; for each (auto* e in m_pObservers) &#123; e-&gt;openV(); &#125; &#125; void registerObserver(CDevice *vDevice) &#123; m_pObservers.push_back(vDevice); &#125;private: std::vector&lt;CDevice*&gt; m_pObservers;&#125;; 123456789101112131415161718#include &lt;vector&gt;#include "AirCondition.h"#include "TV.h"#include "RemoteController.h"#include "Room.h"int main() &#123; CRemoteController *pRemoteController = new CRemoteController(); CRoom *pRoom = new CRoom; for each (CDevice *e in pRoom-&gt;fetchDevices()) &#123; pRemoteController-&gt;registerObserver(e); &#125; pRemoteController-&gt;onOpenClicked(); return 0;&#125; 在服务端里存储着观察者集合，由客户端向里面注册事件的观察者，最后由服务端调用注册好的所有观察者的公用函数（监听），这个过程就是观察者模式。 其实我们注意到，服务端其实只是用到了观察者对象的公用虚函数而已，不需要用到整个观察者对象，所以观察者集合还可以进一步变成函数指针集合，存储着电视、冰箱等子类重写的虚函数指针集合（例如指向子类重写的openV函数的指针）。 总结一下：观察者模式定义了对象间的一种一对多的依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。 发生改变的对象称为观察目标 被通知的对象称为观察者 一个观察目标可以对应多个观察者 观察者之间没有相互联系，可以根据需要增加和删除观察者，使得系统更易于扩展。 命令模式 现在需求变了：用户不仅可以按开关键，还可以通过其他按键控制空调风速、电视声音大小等等。这样就好像客户端发送了不同的命令，服务端接收到命令后取出命令来执行。但是同样的问题，客户端发送的打开命令，应该由哪个设备来执行呢？所以，打开命令还必须和一个设备相关联，可以把设备作为打开命令的成员：1234class CDevice &#123;public: virtual void openV() = 0;&#125;; 123456789#include &lt;iostream&gt;#include "Device.h"class CTV :public CDevice &#123;public: virtual void openV() override &#123; std::cout &lt;&lt; "The TV is turned on." &lt;&lt; std::endl; &#125;&#125;; 123456789#include &lt;iostream&gt;#include "Device.h"class CAirCondition :public CDevice &#123;public: virtual void openV() override &#123; std::cout &lt;&lt; "The AirCondition is turned on." &lt;&lt; std::endl; &#125;&#125;; 1234class CCommand &#123;public: virtual void executeV() = 0;&#125;; 12345678910111213141516#include "Command.h"#include "Device.h"class COpenCommand :public CCommand&#123;public: COpenCommand(CDevice *vDevice) &#123; m_pDevice = vDevice; &#125; virtual void executeV() override &#123; m_pDevice-&gt;openV(); &#125;private: CDevice *m_pDevice;&#125;; 1234567891011121314151617181920#include &lt;vector&gt;#include "Command.h"#include "Room.h"class CRemoteController &#123;public: void addCommand(CCommand *vCommand) &#123; m_pCommandSet.push_back(vCommand); &#125; void executeCommand() &#123; for each (auto* e in m_pCommandSet) &#123; e-&gt;executeV(); &#125; &#125;private: std::vector&lt;CCommand*&gt; m_pCommandSet;&#125;; 123456789101112131415#include "RemoteController.h"#include "Room.h"#include "OpenCommand.h"int main() &#123; CRemoteController *pRemoteController = new CRemoteController(); CRoom *pRoom = new CRoom; for each (CDevice *e in pRoom-&gt;fetchDevices()) &#123; pRemoteController-&gt;addCommand(new COpenCommand(e)); &#125; pRemoteController-&gt;executeCommand(); return 0;&#125; 客户端（main函数）发出打开命令（new COpenCommand(e)），在打开命令创建的时候就已经与房子里的具体物体关联上了，然后会把打开命令添加到服务端（CRemoteController），服务端里存储着一系列命令集合，服务端最后会执行所有命令，但是它并不知道命令是和谁相关的。产生命令的客户端就是生产者，而执行命令的一段是消费者。如下图所示（AI模块是生产者，产生AI命令，角色模块是消费，执行AI命令，中间是命令队列）：值得注意的是：在客户端对命令绑定具体对象时，绑定的是虚基类CDevice对象指针，而不是具体的某个电视或者空调对象，这样在产生命令的时候就只需要知道抽象类就可以了，而不必知道具体的消费者对象是哪些。所以这样一来就实现了生产者和消费者解耦：生产者生成自己的命令就好，不用管由哪些具体对象来消费命令，而消费者也不必知道命令的生成过程是怎样。 如果要增加一个关闭命令，需要更改或添加如下代码：在CDevice里增加关闭的函数接口：1virtual void closeV() = 0; 在CTV里重写关闭函数接口：123virtual void closeV() override &#123; std::cout &lt;&lt; "The TV is closed." &lt;&lt; std::endl;&#125; 在CAirCondition里重写关闭函数接口：123virtual void closeV() override &#123; std::cout &lt;&lt; "The AirCondition is closed." &lt;&lt; std::endl;&#125; 增加一个派生自CCommand的CCloseCommand类：1234567891011121314151617#pragma once#include "Command.h"#include "Device.h"class CCloseCommand : public CCommand &#123;public: CCloseCommand(CDevice *vDevice) &#123; m_pDevice = vDevice; &#125; virtual void executeV() override &#123; m_pDevice-&gt;closeV(); &#125;private: CDevice *m_pDevice;&#125;; 在客户端main函数里添加创建和发送关闭命令的代码：123456for each (CDevice *e in pRoom-&gt;fetchDevices())&#123; pRemoteController-&gt;addCommand(new COpenCommand(e)); pRemoteController-&gt;addCommand(new CCloseCommand(e));&#125;pRemoteController-&gt;executeCommand(); 程序运行的结果如下：1234The TV is turned on.The TV is closed.The AirCondition is turned on.The AirCondition is closed. 可以看出，命令模式实际上是把客户端发出的命令封装成了对象，而服务端存储着一堆命令集合，由客户端向这个集合里添加具体命令（和观察者模式很像，不过观察者模式在服务端存储的是观察者集合）。 外观模式、观察者模式、命令模式的比较 各自的优点和侧重点外观模式会将子系统的细节隐藏到外观对象中。观察者模式可以根据需要增加和删除观察者，使得系统更易于扩展。命令模式实现请求调用者和执行者之间的完全解耦。 每个模式都有其适用的环境，无法说哪一个设计模式一定比另一个设计模式更好。这是随着需求的变化而不同的。 需求变化时各自的缺点比如房间里新增了物品，那么增加相应的物品类是必不可少的，除此之外：外观模式需要修改已有的类CRoom，观察者模式需要在客户端增加一行代码， 注册新的物品为观察者，命令模式需要在客户端增加和新物品相关联的命令（如果所有物品都放在CRoom里，那就和外观模式一样需要去修改类CRoom了）。 那么是不是就是观察者模式好于命令模式，命令模式好于外观模式？当然不是的，比如需求变成增加了一种按键，这种情况下就不是观察者模式最好了。 总之，记住一点：对客户端的修改不易引起连锁反应，对客户端做出改动的危险往往低于对业务类的修改。在某种需求变化下，对非客户端程序改动越小的设计方案就是越好的。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>外观 观察 者命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fermi Asynchronous Texture Transfer]]></title>
    <url>%2F2017%2F08%2F20%2FFermi-Asynchronous-Texture-Transfer%2F</url>
    <content type="text"><![CDATA[简介 NVIDIA Fermi 架构里存在拷贝引擎硬件，专门用于GPU到CPU之间以DMA的方式进行双向数据传输。Quadro中高端显卡会有两个拷贝引擎硬件，一个用于从GPU上下载数据到CPU，一个用于CPU上传数据到GPU。如下图所示： CPU上异步纹理传输：CPU Asynchronous Texture Transfers 使用多个PBO异步传输数据的图示如下：代码如下：123456789101112131415GLuint pbo[2]; // The ping-pong pbo ? sunsigned int curPBO = 0;// Bind current pbo for app-&gt;pbo transferglBindBuffer(GL_PIXEL_UNPACK_BUFFER, pbo[curPBO]);GLubyte *ptr;ptr = (GLubyte *)glMapBufferRange(GL_PIXEL_UNPACK_BUFFER_ARB, 0, size, GL_MAP_WRITE_BIT | GL_MAP_INVALIDATE_BUFFER_BIT);memcpy(ptr, pData , width * height * sizeof(GLubyte) * nComponents);glUnmapBuffer(GL_PIXEL_UNPACK_BUFFER);glBindTexture(GL_TEXTURE_2D , texId);// Bind next pbo for upload from pbo to texture objectglBindBuffer(GL_PIXEL_UNPACK_BUFFER, pbo[1 - curPBO]);glTexSubImage2D(GL_TEXTURE_2D , 0, 0, 0, width , height, GL_RGBA, GL_UNSIGNED_BYTE, 0);glBindBuffer(GL_PIXEL_UNPACK_BUFFER, 0);glBindTexture(GL_TEXTURE_2D , 0);curPBO = 1 - curPBO; 注意这只是在单个渲染线程上，不同PBO的数据传输在并行执行，属于CPU异步输出。并没有用到GPU的Copy引擎。 GPU上异步纹理传输：GPU Asynchronous Texture Transfers GPU的Copy引擎硬件默认是不开启的，因为对于少量的数据传输，使用它会带来一些性能瓶颈。 为了触发Copy引擎，需要把数据传输(transfers)放在一个单独的线程里，这样GPU调度程序就会把渲染线程(render thread)发出的命令交由图形渲染引擎来完成，而数据传输线程(transfer thread)发出的命令会交由Copy引擎来并行执行。这就是GPU异步传输。图示如下： Implementation Details 多线程实现GPU异步传输时，需要为上传、渲染、下载分别建立一个单独的线程。下图是上传线程和渲染线程异步工作的图解：下图是渲染线程和下载线程异步工作的图解：值得注意的是我们是通过多张纹理数据来达到并行执行的效果，确保渲染线程在工作的同时，上传线程或下载线程会保持繁忙（busy）。 管理线程并发访问共享纹理为了管理线程到共享纹理的并发访问，需要为每个纹理创建类似signal这种同步原语。 OpenGL的绘制函数（glDraw*等）是异步的，所以函数返回时并不能保证渲染完成了，但是我们经常需要知道一些事会在什么时候完成，比如渲染线程需要知道纹理是什么时候上传完成的，它才能开始用这张纹理。这种信号交换由GL_ARB_Sync机制的同步对象（synchronization object）来负责管理，这些同步对象在不同的OpenGL上下文之间可以共享。一个上下文里创建的同步对象可以用来阻塞另一个上下文。 上传线程和渲染线程之间的同步机制如下图所示，渲染线程必须在上传线程传输完纹理数据后才能使用该纹理，渲染线程在使用某纹理的时候上传线程不能对该纹理传输数据：渲染线程和下载线程之间的同步机制如下图所示：其中 endUploadValid、endDownloadValid等用于避免线程之间出现忙等（？？？）。 Copy引擎注意事项 连接Copy引擎的OpenGL上下文也可以发送非非DMA命令，但是这些命令可能会和渲染线程分时，导致丢失并行性。如果序列化传输线程和渲染线程中的命令，可能会产生错误：“Pixeltransferis synchronizedwith 3Drendering.” Fermi的Copy引擎只允许pixel传输，而不允许vertex传输。 FBO和Copy引擎结合使用时，由于纹理附件和渲染缓存附件的验证，可能会带来一些性能瓶颈。出于这个原因，建议用glGetTexImage来下载数据，而非用glReadPixels从渲染缓存或者纹理附件里下载数据。 应该根据渲染时间和传输时间的比例来设置最佳共享纹理数，这需要很多次实验才能得出好的结果。两个时间平衡后，使用双缓冲纹理就足够了。 总结 上传数据时，在Quadro上比在GeForce上有更大的性能提升。 传输的纹理大小小于1MB时，Copy引擎带来的性能提升很小。 下载数据时，在GeForce上比在Quadro上有更大的性能提升。 对于渲染时间和传输时间平衡的应用程序，Copy引擎能够带来最大的性能提升。 参考文献：《OpenGL Insight》- Chapter29:Fermi Asynchronous Texture Transfers]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>异步传输</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Asyn Buffer Transfers]]></title>
    <url>%2F2017%2F08%2F20%2FAsyn-Buffer-Transfers%2F</url>
    <content type="text"><![CDATA[CPU和GPU之间的数据传输简介 调用OpenGL函数时，驱动程序会将其转换为一系列命令，并把这些命令添加到CPU端的命令队列中。这些命令会被GPU以异步的方式取出来执行。也就是说，OpenGL命令不一定会被立即执行，只是被放进了命令队列，实际的渲染执行都有可能在几帧以后了。 CPU和GPU之间的数据通过PCIe（PCI Express）总线来传输，是双向传输的。 CPU和GPU之间的数据传输是使用DMA机制来实现的。 pinned memory（固定内存）：固定内存也称作不可分页内存。由于不可以分页，所以操作系统不会将固定内存进行分页并交换到磁盘上，这块内存会始终驻留在物理内存中，不会被破坏或者重新定位。如果是分页的内存，CPU上的数据会先拷贝到一块不可见的pined memory（临时的页锁定内存）中，再传输拷贝到GPU中，会存在两次数据拷贝。malloc分配的是分页内存，cudaHostAlloc分配的是页锁定内存。使用pinned memory可以加速CPU和GPU之间的数据传输，性能可以提高两倍左右，但是不能滥用，因为固定内存驻留在物理内存中，如果固定内存很多，会导致系统内存被耗尽，程序无法正常运行，还会影响系统上其他应用程序的性能。用到的时候采取申请固定内存，不用的时候立即释放。 集成显卡（Integrated GPU）和CPU共享内核和内存空间，所以在CPU和GPU之间传输数据时不受限于PCIe总线的传输能力。但传输速度还是比不过对应的独立显卡（Discrete GPU）。 内存传输 CPU到GPU的数据传输函数使用glBufferData系列函数将数据从CPU传到GPU上时（即Buffer Object有可能存在于CPU，也可能存在于GPU上，由glBufferData函数的usage参数决定），会先将数据写到CPU内存（比如常用的GLfloat Verrtices[ ]）上，再由glBufferData函数将存储在CPU内存上的数据传到驱动（driver）的固定内存里，上传完之后，会立即以DMA的方式将数据从驱动的固定内存传到GPU内存上，同时glBufferData函数结束使命，函数返回。图示如下： 使用glMapBuffer函数可以得到驱动里固定内存的地址，直接将数据写到固定内存里，不用先把数据拷贝到CPU内存里，会比glBufferData函数更快。图示如下： Usage参数OpenGL可以把应用程序的数据最终存在CPU或者GPU上（存在CPU上时GPU通过PCIe总线来访问数据）。对于glBufferData和glMapBuffer函数，其usage参数可以帮助驱动程序（driver）决定最终要把数据存在哪个位置（不全由usage参数决定，驱动程序可能不会遵从usage指定的内容）。如下图所示： 隐式同步 驱动在绘制上一帧的数据（存在VBO里）时，可能应用程序已经想要开始传下一帧的数据了，如果用的同一个VBO，那么应用程序如果传下一帧数据就会破坏上一帧存在VBO里的数据，导致绘制结果不正确，所以OpenGL会存在一个隐式同步（Implict synchronization），等待驱动利用上一帧数据绘制完以后，应用程序才开始下一帧数据传输。如下图所示：这种隐式同步等待，可能会对程序程序性能造成严重损害（可能会增加好几毫秒的渲染时间）。 【注】： 绘制图形时，同时存在应用程序线程（负责发送OpenGL函数）和驱动程序线程（负责转换和处理OpenGL命令）。 应用程序线程里有调用glClear等等函数，驱动程序线程同样有glClear等等函数，这些函数是从应用程序传过来的，实际上在驱动里存储的是glClear等等函数的命令形式。 上传UpLoad 避免隐式同步的方法 缓冲对象循环链 （多缓冲） 重新分配缓存 使用glFenceSync、glClientWaitSync和glMapBufferRange函数来完全手动同步缓冲对象循环链（多缓冲）方法避免隐式同步之前会出现隐式同步，一个很重要的原因是应用程序线程和驱动程序线程使用的是同一个VBO，它们向同一块缓冲中写入和读取帧数据。所以，我们可以让它们循环使用不同的VBO来避免隐式同步：应用程序先向vbo[0]中写入帧数据，然后驱动程序在使用vbo[0]绘制的同时，应用程序向vbo[1]中传入帧数据，接下来驱动程序在使用vbo[1]绘制的同时，应用程序又向vbo[0]中写入帧数据……。如下图所示：重新分配缓存方法避免隐式同步上面是让两个线程分别操作两个不同的缓存对象，来避免隐式同步，其实还有另一种办法来保证应用线程的glSubBufferData函数和驱动线程的glDrawElements函数操作的不是同一个缓存：在应用程序调用glBufferSubData之前，先调用glBufferData函数在GPU上重新分配一块显存区域（新的VBO显存），用来接收后续glBufferSubData函数传过来的数据，原先的VBO显存不会被覆盖，依然可以为驱动线程的glDrawElements函数提供绘制图形的数据源。图示如下：驱动程序在调用glDrawElements绘制第n-1帧时，应用程序已经同时调用glBufferData函数在GPU上为VBO重新开辟了一段显存空间，然后用glBufferSubData为这块新的显存空间传输数据，但是glDrawElement还是用的原来的VBO显存在绘制，这样glDrawElements和glBufferSubData就是操作的不同的VBO缓存，就不会出现隐式同步了。【注】： 上图中左下角的memory block是指驱动程序里的固定内存，右下角VBO里的memory block是GPU显存。 glBufferData函数才会重新分配缓存空间，glBufferSubData不会。 除此之外，也可以使用glMapBufferRange函数配合 GL_MAP_INVALIDATE_BUFFER_BIT或者GLMAP INVALIDATE_RANGE_BIT参数，来让VBO对应的固定内存失效，也就是对VBO和固定内存进行解绑，固定内存将对VBO不可见，这时通过映射后的指针向固定内存里写入数据，但是却不会将固定内存的数据传到VBO里，也就是不会影响glDrawElements使用的VBO显存数据，这样就可以在传数据的同时，驱动线程也并行执行glDrawElements。当使用映射指针传输完数据后，调用glUnmapBuffer函数，会重新让固定内存对VBO可见，这时才会开始把固定内存里的数据传入到VBO里：1234glBindBuffer(GL_ARRAY_BUFFER , my_buffer_object);void *mydata_ptr = glMapBufferRange(GL_ARRAY_BUFFER , 0, data_size, GL_MAP_WRITE_BIT | GL_MAP_INVALIDATE_BUFFER_BIT);// Fill mydata_ptr with useful dataglUnmapBuffer(GL_ARRAY_BUFFER); 缺点但是上面两种方法只要和渲染操作一起同时使用，还是会造成高昂的同步代价（为什么？？？），而且使用glMapBufferRange里的这些参数标志，还会涉及到驱动器内存管理，这可能会带来10倍的性能消耗，所以不推荐使用这两种方式来避免隐式同步。可以使用接下来的异步缓存映射。 更好的方法：异步缓存映射方法避免隐式同步首先需要给glMapBufferRange函数传递 GL_MAP_UNSYNCHRONIZED_BIT标志，告诉OpenGL驱动不需要任何同步操作和重新分配内存操作，然后使用多个VBO缓存（通常3个就足够了，因为函数延迟一般不会超过两帧），每一帧使用各自的缓冲区进行数据读写和渲染。如下图所示：不过需要保证一个缓存区不会被多帧使用，比如第0帧在使用buffer[0]进行glDrawBufferRange，而第1帧也在使用buffer[0]进行glMapBufferRange。可以通过glFencSync和glClientWaitSync函数来实现：先调用glClientWaitSync函数对缓存对象对应的同步对象加锁，防止其他帧的函数也进来访问该缓存对象，使用glMapBufferRange函数取得的内存指针，写完数据后，开始绘制，绘制完后释放同步对象，这时其他帧的函数才能进来访问该缓存对象。123456789101112131415161718const int buffer_number = frame_number++ % 3;// Wait until buffer is free to use, in most cases this should not wait// because we are using three buffers in chain , glClientWaitSync// function can be used for check if the TIMEOUT is zeroGLenum result = glClientWaitSync(fences[buffer_number], 0, TIMEOUT);if (result == GL_TIMEOUT_EXPIRED || result == GL_WAIT_FAILED)&#123; // Something is wrong&#125;glDeleteSync(fences[buffer_number]);glBindBuffer(GL_ARRAY_BUFFER , buffers[buffer_number]);void *ptr = glMapBufferRange(GL_ARRAY_BUFFER , offset, size, GL_MAP_WRITE_BIT | GL_MAP_UNSYNCHRONIZED_BIT);// Fill ptr with useful dataglUnmapBuffer(GL_ARRAY_BUFFER);// Use buffer in draw operationglDrawArray(...);// Put fence into command queuefences[buffer_number] = glFenceSync(GL_SYNC_GPU_COMMANDS_COMPLETE, 0); 大多数情况下都是不需要同步的，因为我们还有第3个缓冲区，足够应用程序线程和驱动线程使用了。 其中glFenceSync函数用于发出信号，让阻塞在同步对象里的glWaitSync和glClientWaitSync命令变为非阻塞状态，返回释放的同步对象的名字；glWaitSync会导致OpenGL服务端被阻塞，直到指定的同步对象发出释放信号或者等待超时；glClientWaitSync会导致OpenGL客户端（应用程序）被阻塞，直到指定的同步对象发出释放信号或者等待超时。 下载Download 使用PBO下载数据大多数情况下我们都是从GPU上下载纹理到CPU，这时就需要用到glReadPixels和PBO了（直接glGetTexImage很慢）。先将数据渲染到纹理，再使用glReadPixels将纹理数据读入到PBO中，值得注意的是，在为PBO缓存对象分配内存空间时，即调用glBufferData时，需要指定usage参数为GL_*_READ形式，这样OpenGL就会把PBO放在驱动的固定内存里，可以直接被应用程序通过映射指针来访问。如下图所示：但是应用程序需要同步等待数据从GPU完全传输到驱动内存里以后，才可以调用glMapBuffer来访问驱动固定内存里的数据，那么怎么避免这个等待呢？ 在read和map之间做一些别的工作来避免闲置等待在调用glReadPixels函数后，做一些无关的CPU操作，等DMA数据传输完以后，再调用glMapBuffer函数。这种方法其实不实用，因为不好控制执行多少CPU操作数据才会传输完，而且这样做会增加代码的难度，难以写出高效的代码。 错帧调用map来避免闲置等待在调用glReadPixels函数的前一帧或者后两帧，再调用glMapBuffer函数。因为这时候数据通常都已经传输完了。这种方法也需要多缓冲来实现（用多缓冲来控制前一帧或者后两帧使用map来读取对应缓冲）。 信号锁明确告知数据传输完成时间点，结合多张纹理来避免闲置等待和上传时的异步缓存映射方法一样，使用信号锁。先调用glReadPixels函数，将数据从GPU传到驱动内存里，传输完后调用glFenceSync函数释放同步对象，在glMapBuffer之前，先判断同步对象是否被释放，如果被释放则说明数据已经全部从GPU传到了驱动内存里，立即开始映射数据到应用程序内存：1234567891011121314151617181920212223242526if (rb_tail != rb_head)&#123; const int tmp_tail = (rb_tail + 1) &amp; RB_BUFFERS_MASK; GLenum res = glClientWaitSync(fences[tmp_tail], 0, 0); if (res == GL_ALREADY_SIGNALED || res == GL_CONDITION_SATISFIED) &#123; rb_tail = tmp_tail; glDeleteSync(sc-&gt;_fence); glBindBuffer(GL_PIXEL_PACK_BUFFER, buffers[rb_tail ]); glMapBuffer(GL_PIXEL_PACK_BUFFER, GL_READ_ONLY); // Process data glUnmapBuffer(GL_PIXEL_PACK_BUFFER); &#125;&#125;const int tmp_head = (rb_head + 1) &amp; RB_BUFFERS_MASK;if (tmp_head != rb_tail)&#123; glReadBuffer(GL_BACK); glBindBuffer(GL_PIXEL_PACK_BUFFER, buffers[rb_head]); glReadPixels(0, 0, width , height, GL_BGRA, GL_UNSIGNED_BYTE , (void*)offset); fences[tmp_head] = glFenceSync(GL_SYNC_GPU_COMMANDS_COMPLETE, 0); //new add&#125;else&#123; // We are too fast&#125; 由于有多张纹理在同时从GPU传到CPU里，所以一个被阻塞，另一个可能还在继续传输数据，这样相当于同步等待的时间也没有被浪费，被其他纹理传输利用起来了。 在AMD显卡上，glUnmapBuffer有时候是同步的，如果需要异步，需要用AMD_pinned_memory扩展。在NVIDIA显卡上，先使用glReadPixels把数据读到一个缓存（GPU上的一个临时buffer）里，再使用glCopyBufferSubData把这个缓存里的数据拷贝到CPU缓存里，速度会快两倍：123glBindBuffer(GL_COPY_READ_BUFFER, source_buffer);glBindBuffer(GL_COPY_WRITE_BUFFER, dest_buffer);glCopyBufferSubData(GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, source_offset , write_offset , data_size); 多线程和共享上下文 线程和上下文每一个用到OpenGL函数的额外线程都需要有自己的上下文，并且需要显式地连接到第一个上下文以便共享OpenGL对象，驱动程序会为每一个线程创建一个命令队列。如下图所示： 多线程共享上下文时会的同步问题 由于多个线程之间没有隐式同步，可能会发生一个线程正在上传数据你，而另一个线程在用这些数据，这样可能会导致用的时候只上传了部分mesh或者部分实例化数据等等。 可能由于多个线程在驱动里共享上下文的原因， 会导致每帧的渲染时长增加0.5ms左右。 多线程共享上下文并不会让数据传输和渲染并行执行。 避免多线程共享上下文建议即使用到多个线程离线上传数据或任务时，也不要共享上下文。如下图所示：这幅图中没有画出驱动线程。在单线程环境下，客户端只有一个应用程序线程，同时负责将数据从CPU传输到驱动内存的任务，以及利用这些数据进行渲染的任务。在客户端有两个线程和一个上下文的环境下，应用程序线程负责将数据传输到驱动内存，同时渲染线程会比应用程序线程滞后一帧，渲染N-1帧的数据。可以看到多线程单上下文的环境下，帧渲染时长比单线程短了很多。 补充和总结 在渲染循环中，如果在某一帧使用glEnable改变了某个状态，由于OpenGL会发生一个漫长的状态验证过程，所以可能会增加很多渲染时间。 通常情况下，建议使用单线程和多缓冲（map时设置 GL_MAP_UNSYCHRONIZED_BIT标志），因为对于提升现有程序的性能它是一个更简单有效地方式。 参考文献：《OpenGL Insight》- Chapter28:Asynchronous Buffer Transfers]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>异步传输</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[老张培训笔记第三课工厂模式和单例模式]]></title>
    <url>%2F2017%2F07%2F18%2F%E8%80%81%E5%BC%A0%E5%9F%B9%E8%AE%AD%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%89%E8%AF%BE%2F</url>
    <content type="text"><![CDATA[感谢老张！ 案例：暴发户有几两汽车：Benz、Audi，上不同的车都会有对应的开车行为。 简单工厂 最简单的实现方式如下：12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;string&gt;class CCar &#123;public: virtual void driveV() = 0;&#125;;class CBenz : public CCar&#123;public: virtual void driveV() override&#123; std::cout &lt;&lt; "Driving Benz..." &lt;&lt; std::endl; &#125;&#125;;class CAudi : public CCar &#123;public: virtual void driveV() override &#123; std::cout &lt;&lt; "Driving Audi..." &lt;&lt; std::endl; &#125;&#125;;class CCarFactory &#123;public: CCar* createCar(std::string vCarName) &#123; if ("Benz" == vCarName) return new CBenz; else if ("Audi" == vCarName) return new CAudi; else return NULL; &#125;&#125;;int main() &#123; std::string CarName; std::cin &gt;&gt; CarName; CCarFactory CarFactory; CCar* Car = CarFactory.createCar(CarName); if(Car) Car-&gt;driveV(); return 0;&#125; 奔驰CBenz和奥迪CAudi都继承自基类车CCar。有一个专门的工厂类来负责实例对象的创建，被创建的实例都具有相同的父类，这就是简单工厂模式。 其优点是只需要提供车的名字，就可以在工厂类里创建出对应的车类，不用去关心具体的创建过程。让对象的业务（即开车），与对象的创建（即造车）分离开来，降低了系统的耦合度。但是缺点也是很明显的，它不符合开闭原则，因为用到了类似switch-case的if-else语句，当增加新的车类型时，需要去修改工厂类的代码。 工厂方法 简单工厂是把所有车的创建都放在一个工厂里完成，但是随着车类型越来越多，每种车还需要在工厂里生产、装配、维护，工序变得更复杂，无疑这个工厂太繁重了。一个解决方案是：每种车都由一个专属的工厂来生产，这些工厂又被一个boss工厂来管理。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;class CCar &#123;public: virtual void driveV() = 0;&#125;;class CBenz : public CCar&#123;public: virtual void driveV() override&#123; std::cout &lt;&lt; "Driving Benz..." &lt;&lt; std::endl; &#125;&#125;;class CAudi : public CCar &#123;public: virtual void driveV() override &#123; std::cout &lt;&lt; "Driving Audi..." &lt;&lt; std::endl; &#125;&#125;;class CAbstractFactory &#123;public: virtual CCar* createCar() = 0;&#125;;class CBenzFactory : public CAbstractFactory&#123;public: virtual CCar* createCar() override &#123; return new CBenz(); &#125;&#125;;class CAudiFactory : public CAbstractFactory &#123;public: virtual CCar* createCar() override &#123; return new CAudi(); &#125;&#125;;int main() &#123; CAbstractFactory* AbstractFactory = new CBenzFactory(); CCar* Car = AbstractFactory-&gt;createCar(); Car-&gt;driveV(); return 0;&#125; 当需要增加保时捷这种车时，只需要增加一个派生自CCar的CPorsche类，和一个派生自CAbstractFactory的CPorscheFactory工厂类。符合开闭原则。 但是上面的代码需要用户知道奔驰车对应的工厂类名是什么，无法直接通过字符串来创建对应的车，还是需要加如下的代码：12345678910CCar* createCar(const std::string&amp; vCarName) &#123; if ("Benz" == vCarName) &#123; CAbstractFactory* AbstractFactory = new CBenzFactory(); return AbstractFactory-&gt;createCar(); &#125; else if ("Audi" == vCarName) &#123; CAbstractFactory* AbstractFactory = new CAudiFactory(); return AbstractFactory-&gt;createCar(); &#125;&#125; 这样就还是无法满足开闭原则了。如果用户输入一个字符串，就直接给他创建一个对应的车该多好。需要让字符串和车联系在一起，很容易想到在车类里增加一个字符串变量m_CarName，标志这辆车的名字。如果用户输入的字符串和车对象里的名字匹配，就返回这辆车：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;class CCar &#123;private: std::string m_CarName;public: virtual void driveV() = 0; void setCarName(const std::string&amp; vCarName) &#123; m_CarName = vCarName; &#125; const std::string&amp; getCarName() const &#123; return m_CarName; &#125;&#125;;class CBenz : public CCar &#123;public: virtual void driveV() override &#123; std::cout &lt;&lt; "Driving Benz..." &lt;&lt; std::endl; &#125;&#125;;class CAudi : public CCar &#123;public: virtual void driveV() override &#123; std::cout &lt;&lt; "Driving Audi..." &lt;&lt; std::endl; &#125;&#125;;std::vector&lt;CCar*&gt; Cars;class CAbstractFactory &#123;public: virtual void createCar() = 0; CCar* getCar(std::string vCarName) &#123; for (int i = 0; i &lt; Cars.size(); i++) &#123; if (vCarName == Cars[i]-&gt;getCarName()) return Cars[i]; &#125; return NULL; &#125;&#125;;class CBenzFactory : public CAbstractFactory &#123;public: virtual void createCar() override &#123; CCar* Car = new CBenz(); Car-&gt;setCarName("Benz"); Cars.push_back(Car); &#125; CBenzFactory() &#123; createCar(); &#125;&#125;;class CAudiFactory : public CAbstractFactory &#123;public: virtual void createCar() override &#123; CCar* Car = new CAudi(); Car-&gt;setCarName("Audi"); Cars.push_back(Car); &#125; CAudiFactory() &#123; createCar(); &#125;&#125;;int main() &#123; CBenzFactory BenzFactory; CAudiFactory AudiFactory; CAbstractFactory* AbstractFactory = &amp;BenzFactory; CCar* Car = AbstractFactory-&gt;getCar("Porsche"); if (Car) Car-&gt;driveV(); return 0;&#125; 上面的代码是在每个工厂的构造函数里，把奥迪CAudi、奔驰CBenz等车创建好了存入仓库（即全局变量Cars）里，当用户需用某种车时，根据用户输入的字符串（车名）去仓库里找到这辆车返回给用户。具体方法时把用户输入的字符串和仓库里所有车的属性：车名，进行匹配。 当需要增加保时捷时，只需要添加保时捷类和保时捷工厂类：123456789101112131415161718class CPorsche :public CCar &#123; virtual void driveV() override &#123; std::cout &lt;&lt; "Driving Porsche" &lt;&lt; std::endl; &#125;&#125;;class CPorscheFactory :public CAbstractFactory &#123;public: virtual void createCar() override &#123; CCar* Car = new CPorsche(); Car-&gt;setCarName("Porsche"); Cars.push_back(Car); &#125; CPorscheFactory() &#123; createCar(); &#125;&#125;; 在main函数开头添加对保时捷工厂对象：1CPorscheFactory PoscheFactory; 很显然，这种设计是符合开闭原则的，并没有去改动已有的代码设计。但是需要将所有车对象都存储到仓库里，这无疑很占内存，如果暴发户在某一时刻只需要用到奔驰，但是上面的代码在这一刻实际上是奔驰、奥迪、宝马都已经生成了，是种内存浪费。其实上面的代码体现了对象池模式：事先将对象new好存储到对象池里，需要时从对象池里取出，不需要时放回对象池。对象池模式对需要频繁创建、销毁的对象很有好处，因为需要了去取，不需要了放回去，就省去了频繁的耗时好性能的new和delete操作（一次就好）。 而且上面的代码有个问题：工厂模式存在的初衷就是代替new，在用户需要时才立即创建对象，上面代码是在用户需要之前就创建好了。这其实是个致命的问题，如果有两个暴发户都需要奔驰车，那么他们去工厂里拿的将是同一辆车（取到的奔驰车对象的地址是一样的），这明显不对。还是应该每个人都去找奔驰厂商，让厂商给他们每个人都new一辆奔驰。 那我们这样考虑：当用户输入字符串时，去工业园区找对应的厂商（这里厂商的意思是具体的工厂对象，比如生产奔驰的工厂），让厂商立即造车。这样做就和new的功能一样了。更改一下上面的代码，取消车的字符串标志，移到厂商类里：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;class CCar &#123;public: virtual void driveV() = 0;&#125;;class CBenz : public CCar &#123;public: virtual void driveV() override &#123; std::cout &lt;&lt; "Driving Benz..." &lt;&lt; std::endl; &#125;&#125;;class CAudi : public CCar &#123;public: virtual void driveV() override &#123; std::cout &lt;&lt; "Driving Audi..." &lt;&lt; std::endl; &#125;&#125;;class CAbstractFactory &#123;private: std::string m_CarName;public: virtual CCar* createCar() = 0; void setCarName(const std::string&amp; vCarName) &#123; m_CarName = vCarName; &#125; const std::string&amp; getCarName() const &#123; return m_CarName; &#125;&#125;;std::vector&lt;CAbstractFactory*&gt; g_Factoris;class CBenzFactory : public CAbstractFactory &#123;public: virtual CCar* createCar() override &#123; return new CBenz(); &#125; CBenzFactory() &#123; setCarName("Benz"); g_Factoris.push_back(this); &#125;&#125;;class CAudiFactory : public CAbstractFactory &#123;public: virtual CCar* createCar() override &#123; return new CAudi(); &#125; CAudiFactory() &#123; setCarName("Audi"); g_Factoris.push_back(this); &#125;&#125;;class CFactoryProducer &#123;public: CAbstractFactory* getCar(std::string vCarName) &#123; for (int i = 0; i &lt; g_Factoris.size(); i++) &#123; if (vCarName == g_Factoris[i]-&gt;getCarName()) return g_Factoris[i]; &#125; return NULL; &#125;&#125;;int main() &#123; CBenzFactory BenzFactory; CAudiFactory AudiFactory; CFactoryProducer FactoryProducer; CCar* Car = FactoryProducer.getCar("Benz")-&gt;createCar(); if (Car) Car-&gt;driveV(); return 0;&#125; 由于无法在CAbstractFactory 类里直接使用CAbstractFactory *类型的全局变量g_Factoris，所以上面的代码增加了一个工厂生成器的类CFactoryProducer ，用来根据字符串找出对应的厂商。 上面的代码可以直接用字符串生成对应的车对象，符合开闭原则，而且和new的功能一样，对象是用户需要时才创建的。虽然在工业园区（即全局变量g_Factoris）里也需要事先保存所有的工厂对象，但是这比上一个方案要好一些，通常情况下车对象都比工厂对象要复杂、要大一些，工厂毕竟只需要new一个车对象就可以了，而车里可能还会添加很多其他的属性，诸如引擎、座椅、制动系统等等。 直接通过字符串来生成对象的工厂模式 而且这两个方案都有一个不好的地方：需要去遍历仓库里的所有车或者工业园区里的所有厂商，速度比较慢。能不能直接通过字符串去找到对应的厂商？可以的，这可以用map数据结构来实现，让字符串和对应的厂商类对象组成键值对，存入到map中。需要时直接根据字符串去map中找到对应的厂商。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;map&gt;class CCar &#123;public: virtual void driveV() = 0;&#125;;class CBenz : public CCar &#123;public: virtual void driveV() override &#123; std::cout &lt;&lt; "Driving Benz..." &lt;&lt; std::endl; &#125;&#125;;class CAudi : public CCar &#123;public: virtual void driveV() override &#123; std::cout &lt;&lt; "Driving Audi..." &lt;&lt; std::endl; &#125;&#125;;class CAbstractFactory &#123;public: virtual CCar* createCar() = 0;&#125;;std::map&lt;std::string, CAbstractFactory*&gt; g_FactoriesMap;class CBenzFactory : public CAbstractFactory &#123;public: virtual CCar* createCar() override &#123; return new CBenz(); &#125; CBenzFactory(const std::string vCarName) &#123; g_FactoriesMap[vCarName] = this; &#125;&#125;;class CAudiFactory : public CAbstractFactory &#123;public: virtual CCar* createCar() override &#123; return new CAudi(); &#125; CAudiFactory(const std::string vCarName) &#123; g_FactoriesMap[vCarName] = this; &#125;&#125;;class CFactoryProducer &#123;public: CAbstractFactory* getCar(std::string vCarName) &#123; if (g_FactoriesMap[vCarName]) &#123; return g_FactoriesMap[vCarName]; &#125; return NULL; &#125;&#125;;int main() &#123; CBenzFactory BenzFactory("Benz"); CAudiFactory AudiFactory("Audi"); CFactoryProducer FactoryProducer; CCar* Car = FactoryProducer.getCar("Audi")-&gt;createCar(); if (Car) Car-&gt;driveV(); return 0;&#125; 在上面的代码中用map来代替了之前的vector，这样就可以直接用字符串在map中找到对应的厂商了，不用去遍历map中的所有厂商。 上面的代码还有可以改进的地方： 所有的厂商可以通过一个模板类来生成，而不需要通过抽象工厂类CAbstractFactory来派生了（所有的车就不要通过模板来生成了，因为还需要通过派生来实现驾车行为的多态，而且可以通过奔驰类作为模板参数来生成对应的奔驰厂商，但是车没有合适的模板参数）。 可以把全局变量g_FactoriesMap封装到CFactoryProducer类里。 字符串和对应厂商注册到g_FactoriesMap这件事散落于产商的构造函数里，应该将它移到CFactoryProducer类里，毕竟现在g_FactoriesMap已经是它的数据成员了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;map&gt;class CCar &#123;public: virtual void driveV() &#123;&#125;;&#125;;class CBenz : public CCar &#123;public: virtual void driveV() override &#123; std::cout &lt;&lt; "Driving Benz..." &lt;&lt; std::endl; &#125;&#125;;class CAudi : public CCar &#123;public: virtual void driveV() override &#123; std::cout &lt;&lt; "Driving Audi..." &lt;&lt; std::endl; &#125;&#125;;template &lt;typename CarByFactory&gt;class CCarFactory;class CFactoryProducer &#123;private: std::map&lt;std::string, CCarFactory&lt;CCar&gt;*&gt; g_Factories;public: CCarFactory&lt;CCar&gt;* getCar(std::string vCarName) &#123; if (g_Factories[vCarName]) &#123; return g_Factories[vCarName]; &#125; return NULL; &#125; void registerFactory(const std::string&amp; vCarName, CCarFactory&lt;CCar&gt;* vFactory) &#123; g_Factories[vCarName] = vFactory; &#125;&#125;;CFactoryProducer g_FactoryProducer;template &lt;typename CarByFactory&gt;class CCarFactory &#123;public: CCarFactory(const std::string vCarName) &#123; g_FactoryProducer.registerFactory(vCarName, reinterpret_cast&lt;CCarFactory&lt;CCar&gt;*&gt;(this)); &#125; virtual CCar* createCarV() &#123; return new CarByFactory(); &#125;&#125;;int main() &#123; CCarFactory&lt;CBenz&gt; BenzFactory("Benz"); CCarFactory&lt;CAudi&gt; AudiFactory("Audi"); CCarFactory&lt;CCar&gt;* CarFactory = g_FactoryProducer.getCar("Audi"); if (CarFactory) &#123; CCar* Car = CarFactory-&gt;createCarV(); if (Car) Car-&gt;driveV(); &#125; return 0;&#125; 把这些类写到不同文件中，代码如下：1234567CCar.h:#pragma onceclass CCar &#123;public: virtual void driveV() &#123;&#125;; virtual ~CCar() &#123;&#125;&#125;; 123456789CAudi.h:#pragma once#include "CCar.h"class CAudi :public CCar&#123;public: virtual void driveV() override; ~CAudi() &#123;&#125;&#125;; 1234567CAudi.cpp#include "CAudi.h"#include &lt;iostream&gt;void CAudi::driveV() &#123; std::cout &lt;&lt; "Driving Audi..." &lt;&lt; std::endl;&#125; 123456789CBenz.h:#pragma once#include "CCar.h"class CBenz : public CCar &#123;public: virtual void driveV() override; ~CBenz()&#123;&#125;&#125;; 1234567CBenz.h:#include "CBenz.h"#include &lt;iostream&gt;void CBenz::driveV() &#123; std::cout &lt;&lt; "Driving Benz..." &lt;&lt; std::endl;&#125; 12345678910111213141516171819CCarFactory.h:#pragma once#include &lt;iostream&gt;#include "CCar.h"#include "CFactoryProducer.h"extern CFactoryProducer g_FactoryProducer;template &lt;typename CarByFactory&gt;class CCarFactory &#123;public: CCarFactory(const std::string vCarName) &#123; g_FactoryProducer.registerFactory(vCarName, reinterpret_cast&lt;CCarFactory&lt;CCar&gt;*&gt;(this)); &#125; virtual CCar* createCarV() &#123; return new CarByFactory(); &#125;&#125;; 1234567891011121314151617CFactoryProducer .h:#pragma once#include &lt;map&gt;class CCar;template &lt;typename CarByFactory&gt;class CCarFactory;class CFactoryProducer &#123;private: std::map&lt;std::string, CCarFactory&lt;CCar&gt;*&gt; g_Factories;public: CCarFactory&lt;CCar&gt;* getCar(std::string vCarName); void registerFactory(const std::string&amp; vCarName, CCarFactory&lt;CCar&gt;* vFactory);&#125;; 1234567891011121314151617CFactoryProducer.cpp#include "CFactoryProducer.h"#include "CCarFactory.h"#include "CCar.h"CCarFactory&lt;CCar&gt;* CFactoryProducer::getCar(std::string vCarName) &#123; if (g_Factories[vCarName]) &#123; return g_Factories[vCarName]; &#125; return NULL;&#125;void CFactoryProducer::registerFactory(const std::string&amp; vCarName, CCarFactory&lt;CCar&gt;* vFactory) &#123; g_Factories[vCarName] = vFactory;&#125;CFactoryProducer g_FactoryProducer; 1234567891011121314151617main.cpp:#include "CFactoryProducer.h"#include "CCarFactory.h"#include "CBenz.h"#include "CAudi.h"int main() &#123; CCarFactory&lt;CBenz&gt; AudiFactory("Benz"); CCarFactory&lt;CAudi&gt; BenzFactory("Audi"); CCarFactory&lt;CCar&gt;* CarFactory = g_FactoryProducer.getCar("Benz"); if (CarFactory) &#123; CCar* Car = CarFactory-&gt;createCarV(); if (Car) Car-&gt;driveV(); &#125; return 0;&#125; 上面代码有几个值得注意的地方： 模板类、模板函数的声明和定义应该放在一个文件中。 不要在头文件中定义全局变量。应该在cpp中定义，然后在头文件中用到时用extern声明一下。比如上面代码g_FactoryProducer在CFactoryProducer.cpp中定义，在CCarFactory.h中声明，扩大了该变量的作用域。 在模板类CCarFactory中，createCarV函数使用了关键字virtual修饰，就会为当前的实体类创建虚表和虚指针，比如在执行CCarFactory&lt;CBenz&gt; AudiFactory(&quot;Benz&quot;);时，构造函数会把虚指针指向CBenz生的模板类对象AudiFactory，虚指针指向的虚表里保存了AudiFactory对象的createCarV函数的入口地址，即使在执行registerFactory函数后，将AudiFactory对象指针强制转换为了CCarFactory*类型，但是虚指针指向的地址是不会变的，所以main函数中执行CarFactory-&gt;createCarV()函数时，还是调用的CCarFactory对象的createV函数，new的还是CBenz对象。这种模板类使用虚函数，来模拟多态的方式是很有意思的（其实多态本质上也是这种原理，可参考《virtual C++多态实现原理》一文）。 reinterpret_cast用于将一个指针强制转换为另一种毫不相干的指针类型，但是要慎用，可参考《reinterpret_cast的本质》一文。上面代码由于是从子类参数模板指针，转换为父类参数模板指针，无法像子类指针向父类指针那样自动转换，所以需要用reinterpret_cast来强制转换。 dynamic_cast用于类层次间的上行转换和下行转换，在下行转换时，会判断基类指针是否原本就是指向子类对象的，否则的话会返回NULL，所以它又称为类型安全的转换。 123456789101112131415class A &#123; virtual void f() &#123;&#125;&#125;;class B : public A &#123; virtual void f() &#123;&#125;&#125;;int main() &#123; A *pA = new A(); A *pA1 = new B(); B *pB = dynamic_cast&lt;B*&gt;(pA); //返回NULL B *pB1 = dynamic_cast&lt;B*&gt;(pA1); //返回的指针正确指向原先new出来的B对象 return 0;&#125; 注意使用dynamic_cast转换时，基类必须要有虚函数，因为它本身就是用于多态类型指针之间的转换。 在CFactoryProducer .h中对要使用的类进行了声明，而不是直接包含如下头文件： 12#include "CCarFactory.h"#include "CCar.h" 因为这样会造成CCarFactory.h头文件和CFactoryProducer .h头文件相互包含，会出错：C4430 缺少类型说明符-假定为int，原因可参考《编译链接错误》一文第6条。 还有一点需要注意的是CCarFactory实体类对象是写在main函数中的，并没有写作全局对象，这样可以保证在执行其构造函数时另一个全局变量g_FactoryProducer已经初始化。 Bug来了，单例来了 但是，上面程序中，我们是把CCarFactory实体类对象（AudiFactory等）写在main函数中的，将它们写到对应车类的cpp文件中更好，比如在CAudi.cpp中定义AudiFactory对象，因为毕竟改main函数也不符合开闭原则。这样一来程序就会有多个全局变量：AudiFactory、BenzFactory和g_FactoryProducer，运行程序会出错：读取访问权限冲突。这是因为C++全局变量初始化的顺序是不定的，在CCarFactory的构造函数中用到了g_FactoryProducer，这时候g_FactoryProducer可能还没有被初始化，导致程序运行出错。【温馨提示：要找到这个错误原因还是有一定难度的，但是如果养成良好的编码习惯，在使用g_FactoryProducer之前先判断其是否为空，就会很快发现问题所在】 很容易想到的解决方案就是：将g_FactoryProducer从对象改为指针，在CCarFactory构造函数中使用它之前先进行非空判断，如果空就初始化。增改代码如下：12CFactoryProducer.cpp: CFactoryProducer *g_FactoryProducer=new CFactoryProducer(); 123456789CCarFactory.h:extern CFactoryProducer *g_FactoryProducer;public: CCarFactory(const std::string vCarName) &#123; if (!g_FactoryProducer) g_FactoryProducer = new CFactoryProducer(); g_FactoryProducer-&gt;registerFactory(vCarName, reinterpret_cast&lt;CCarFactory&lt;CCar&gt;*&gt;(this)); &#125; 好像并没有什么问题，但是运行发现并没有输出任何结果。这是因为在CCarFactory.h中初始化g_FactoryProducer后，是向该g_FactoryProducer中注册信息，但是在CFactoryProducer.cpp中又为g_FactoryProducer赋予了另外不同的内存地址，导致前后两者的g_FactoryProducer并不是指向同一个对象，造成最后并没有结果输出。 解决这个问题的方法就是使用单例模式，让g_FactoryProducer只被创建一次（或者说只被初始化一次），所以我们需要将CFactoryProducer类改为单例类：1234567891011121314151617181920212223242526#pragma once#include &lt;map&gt;class CCar;template &lt;typename CarByFactory&gt;class CCarFactory;class CFactoryProducer &#123;private: std::map&lt;std::string, CCarFactory&lt;CCar&gt;*&gt; g_Factories; static CFactoryProducer* g_FactoryProducer; CFactoryProducer() &#123;&#125;public: CCar* getCar(std::string vCarName); void registerFactory(const std::string&amp; vCarName, CCarFactory&lt;CCar&gt;* vFactory); static CFactoryProducer* getInstance() &#123; if (!g_FactoryProducer) g_FactoryProducer = new CFactoryProducer(); return g_FactoryProducer; &#125;&#125;; 当然，以前和g_FactoryProducer相关的地方都要改。如果运行出错：LNK2001 无法解析的外部符号，有可能是我们没有在cpp中对静态变量g_FactoryProducer初始化（静态变量必须初始化以后才能用）：1CFactoryProducer* CFactoryProducer::g_FactoryProducer = NULL; 由于在getInstance函数中，会先判断g_FactoryProducer 是否存在，如果不存在就会立即创建，所以在CCarFactory类构造函数中调用registerFactory函数时g_FactoryProducer一定初始化过了，不会再出现之前的读取访问权限冲突（g_FactoryProducer还没有被初始化而导致的空指针）：1CFactoryProducer::getInstance()-&gt;registerFactory(vCarName, reinterpret_cast&lt;CCarFactory&lt;CCar&gt;*&gt;(this)); 其实上面CFactoryProducer类中的成员变量g_FactoryProducer不是必须的，因为它是静态变量，而且只在getInstance函数中使用到，所以可以直接在getInstance中初始化一个临时变量，然后返回即可：123456static CFactoryProducer* getInstance() &#123; static CFactoryProducer* g_FactoryProducer = NULL; if (!g_FactoryProducer) g_FactoryProducer = new CFactoryProducer(); return g_FactoryProducer;&#125; 下面给出工厂模式的所有源码：1234567CCar.h#pragma onceclass CCar &#123;public: virtual ~CCar() &#123;&#125; virtual void driveV() &#123;&#125;;&#125;; 123456789CAudi.h#pragma once#include "CCar.h"class CAudi :public CCar&#123;public: virtual void driveV() override; ~CAudi() &#123;&#125;&#125;; 12345678910CAudi.cpp#include "CAudi.h"#include &lt;iostream&gt;#include "CCarFactory.h"void CAudi::driveV() &#123; std::cout &lt;&lt; "Driving Audi..." &lt;&lt; std::endl;&#125;CCarFactory&lt;CAudi&gt; BenzFactory("Audi"); 123456789CBenz.h#pragma once#include "CCar.h"class CBenz : public CCar &#123;public: virtual void driveV() override; ~CBenz()&#123;&#125;&#125;; 12345678910CBenz.cpp#include "CBenz.h"#include &lt;iostream&gt;#include "CCarFactory.h"void CBenz::driveV() &#123; std::cout &lt;&lt; "Driving Benz..." &lt;&lt; std::endl;&#125;CCarFactory&lt;CBenz&gt; AudiFactory("Benz"); 12345678910111213141516171819CCarFactory.h#pragma once#include &lt;iostream&gt;#include "CCar.h"#include "CFactoryProducer.h"extern CFactoryProducer *g_FactoryProducer;template &lt;typename CarByFactory&gt;class CCarFactory &#123;public: CCarFactory(const std::string vCarName) &#123; CFactoryProducer::getInstance()-&gt;registerFactory(vCarName, reinterpret_cast&lt;CCarFactory&lt;CCar&gt;*&gt;(this)); &#125; virtual CCar* createCarV() &#123; return new CarByFactory(); &#125;&#125;; 123456789101112131415161718192021222324252627CFactoryProducer .h#pragma once#include &lt;map&gt;class CCar;template &lt;typename CarByFactory&gt;class CCarFactory;class CFactoryProducer &#123;private: std::map&lt;std::string, CCarFactory&lt;CCar&gt;*&gt; g_Factories; CFactoryProducer() &#123;&#125;public: CCar* getCar(std::string vCarName); void registerFactory(const std::string&amp; vCarName, CCarFactory&lt;CCar&gt;* vFactory); static CFactoryProducer* getInstance() &#123; static CFactoryProducer* g_FactoryProducer = NULL; if (!g_FactoryProducer) g_FactoryProducer = new CFactoryProducer(); return g_FactoryProducer; &#125;&#125;; 123456789101112131415CFactoryProducer.cpp#include "CFactoryProducer.h"#include "CCarFactory.h"#include "CCar.h"CCar* CFactoryProducer::getCar(std::string vCarName) &#123; if (g_Factories[vCarName]) &#123; return g_Factories[vCarName]-&gt;createCarV(); &#125; return NULL;&#125;void CFactoryProducer::registerFactory(const std::string&amp; vCarName, CCarFactory&lt;CCar&gt;* vFactory) &#123; g_Factories[vCarName] = vFactory;&#125; 12345678910main.cpp#include "CFactoryProducer.h"#include "CBenz.h"#include "CAudi.h"int main() &#123; CCar* Car = CFactoryProducer::getInstance()-&gt;getCar("Audi"); if (Car) Car-&gt;driveV(); return 0;&#125; 单例模式里释放单例对象 由于单例被创建的初衷，就是和main函数（或者整个程序）同生共死，当程序结束时，单例才完成它的使命。先看下面最简单的单例代码：1234567891011121314151617181920SingletonA.h:#include &lt;iostream&gt;class CSingletonA &#123;public: static CSingletonA *getInstance()&#123; if (!m_pInstance) m_pInstance = new CSingletonA; return m_pInstance; &#125; void print() &#123; std::cout &lt;&lt; "Singleton A" &lt;&lt; std::endl; &#125;private: static CSingletonA *m_pInstance; CSingletonA() &#123;&#125;&#125;; 1234SingletonA.cpp:#include "SingletonA.h"CSingletonA* CSingletonA::m_pInstance = NULL; 释放单例对象方法1：使用内部类对象我们注意到，上面代码中，单例对象指针m_pInstance是由new动态分配在堆上的，在程序结束时，分配在堆上的内存是不会自动由操作系统释放的，必须我们调用delete来释放。而delete的时间应该是在程序结束时，由于在程序结束时系统会自动释放一些分配在栈上的内存，所以我们可以在系统释放栈内存时调用delete。具体做法是：在CSingletonA里，加一个内部类，该内部类的析构函数里调用delete删除单例对象指针，然后定义一个该内部类对象：123456789101112131415161718192021222324252627282930313233SingletonA.h:#include &lt;iostream&gt;class CSingletonA &#123;public: class CGarbageCollection &#123; public: virtual ~CGarbageCollection() &#123; if (m_pInstance) delete m_pInstance; &#125; &#125;; static CSingletonA *getInstance()&#123; if (!m_pInstance) m_pInstance = new CSingletonA; return m_pInstance; &#125; void print() &#123; std::cout &lt;&lt; "Singleton A" &lt;&lt; std::endl; &#125; virtual ~CSingletonA() &#123; std::cout &lt;&lt; "Singleton A deleted" &lt;&lt; std::endl; &#125;private: static CSingletonA *m_pInstance; static CGarbageCollection m_GarbageCollection; CSingletonA() &#123;&#125;&#125;; 12345SingletonA.cpp:include "SingletonA.h"CSingletonA* CSingletonA::m_pInstance = NULL;CSingletonA::CGarbageCollection CSingletonA::m_GarbageCollection; 12345678main.cpp:#include "SingletonA.h"int main()&#123; CSingletonA::getInstance()-&gt;print(); return 0;&#125; 注意，内部类CGarbageCollection的对象m_GarbageCollection需要声明为静态的，这样它才会被存储在静态栈空间里，当程序结束（退出main函数）时，系统会释放m_GarbageCollection对象，调用其虚构函数，释放单例对象m_pInstance。所以输出结果如下：12Singleton ASingleton A deleted 释放单例对象方法2：不把单例对象写作指针类型当然，既然是因为单例对象被动态创建在堆上，导致它无法被系统自动释放其内存，那么我们也可以不把单例对象写作指针类型，直接用对象类型：123456789101112131415161718192021#include &lt;iostream&gt;class CSingletonA &#123;public: static CSingletonA* getInstance()&#123; return &amp;m_pInstance; &#125; void print() &#123; std::cout &lt;&lt; "Singleton A" &lt;&lt; std::endl; &#125; virtual ~CSingletonA() &#123; std::cout &lt;&lt; "Singleton A deleted" &lt;&lt; std::endl; &#125;private: static CSingletonA m_pInstance; CSingletonA() &#123;&#125;&#125;; 123#include "SingletonA.h"CSingletonA CSingletonA::m_pInstance; 由于单例对象m_pInstance不是new动态创建的，而是被分配在程序栈空间里的，所以当程序结束时，会自动释放该内存，调用其析构函数，main函数不变输出结果和之前一样。这种方法虽然简单，但是会让单例对象在程序一开始就被分配内存，直到程序结束，但是第一种方法，单例对象只是在程序第一次调用getInstance函数时才被创建出来。 单例继承如果我们的单例类需要被继承怎么办？看下面的例子（SingletonA的代码和上面使用内部类对象时的一样）：12345678910#include "SingletonA.h"class CSingletonB : public CSingletonA &#123;public: CSingletonB() &#123;&#125; void print() &#123; std::cout &lt;&lt; "Sigleton B" &lt;&lt; std::endl; &#125;&#125;; 在其构造函数CSingletonB() {}处，会发生编译错误：1error C2248: “CSingletonA::CSingletonA”: 无法访问 private 成员(在“CSingletonA”类中声明) 这是因为在执行CSingletonB 的构造函数时，会去访问父类CSingletonA 的构造函数，但是父类是一个单例类，其构造函数是私有的，这样子类就会访问不到，出现上面的编译错误。 单例继承1：保护的构造函数最容易想到的就是，把父类的构造函数声明为保护的，这样子类就可以访问到了：123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;class CSingletonA &#123;public: class CGarbageCollection &#123; public: virtual ~CGarbageCollection() &#123; if (m_pInstance) delete m_pInstance; &#125; &#125;; static CSingletonA *getInstance() &#123; if (!m_pInstance) m_pInstance = new CSingletonA; return m_pInstance; &#125; void print() &#123; std::cout &lt;&lt; "Singleton A" &lt;&lt; std::endl; &#125; virtual ~CSingletonA() &#123; std::cout &lt;&lt; "Singleton A deleted" &lt;&lt; std::endl; &#125;private: static CSingletonA *m_pInstance; static CGarbageCollection m_GarbageCollection;protected: CSingletonA() &#123;&#125;&#125;; 单例继承2：把子类声明为父类的友元类如果觉得把构造函数声明为保护的，封装性不好，可以把在父类中，把子类声明为其友元类，这样子类就可以访问到父类的任何私有成员或者函数了：1234567891011121314151617181920212223242526272829303132333435363738394041SingletonA.h:#include &lt;iostream&gt;namespace NameSpaceB &#123; class CSingletonB;&#125;namespace NameSpaceA &#123; class CSingletonA &#123; public: class CGarbageCollection &#123; public: virtual ~CGarbageCollection() &#123; if (m_pInstance) delete m_pInstance; &#125; &#125;; static CSingletonA *getInstance() &#123; if (!m_pInstance) m_pInstance = new CSingletonA; return m_pInstance; &#125; void print() &#123; std::cout &lt;&lt; "Singleton A" &lt;&lt; std::endl; &#125; virtual ~CSingletonA() &#123; std::cout &lt;&lt; "Singleton A deleted" &lt;&lt; std::endl; &#125; private: static CSingletonA *m_pInstance; static CGarbageCollection m_GarbageCollection; CSingletonA() &#123;&#125; friend class NameSpaceB::CSingletonB; &#125;;&#125; 12345SingletonA.cpp:#include "SingletonA.h"NameSpaceA::CSingletonA* NameSpaceA::CSingletonA::m_pInstance = NULL;NameSpaceA::CSingletonA::CGarbageCollection NameSpaceA::CSingletonA::m_GarbageCollection; 12345678910111213SingletonB.h:#include "SingletonA.h"namespace NameSpaceB &#123; class CSingletonB : public NameSpaceA::CSingletonA &#123; public: CSingletonB() &#123;&#125; void print() &#123; std::cout &lt;&lt; "Singleton B" &lt;&lt; std::endl; &#125; &#125;;&#125; 1234567891011main.cpp:#include "SingletonA.h"#include "SingletonB.h"int main()&#123; NameSpaceA::CSingletonA::getInstance()-&gt;print(); NameSpaceB::CSingletonB B; B.print(); return 0;&#125; 这里把父类CSingletonA和子类CSingletonB 分别放在了两个命名空间里，在父类中声明子类为其友元类：1friend class NameSpaceB::CSingletonB; 注意父类要访问到另一个命名空间里的子类，需要做如下前置声明，来扩大子类的作用域：123namespace NameSpaceB &#123; class CSingletonB;&#125; 程序运行后输出如下：1234Singleton ASingleton BSingleton A deletedSingleton A deleted]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>工厂模式单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[老张培训笔记第二课面向对象设计原则]]></title>
    <url>%2F2017%2F07%2F18%2F%E8%80%81%E5%BC%A0%E5%9F%B9%E8%AE%AD%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%BA%8C%E8%AF%BE%2F</url>
    <content type="text"><![CDATA[感谢老张！ 新增加代码的是否是必须的？判断标准是： 程序不会因为新增加的代码而发生连锁反应 新增加的代码不用了解源程序过多的细节 枚举就不是一个好的设计风格，因为枚举类型增加时，需要去修改原有的代码，需要去了解源程序与枚举相关的很多地方。 开闭原则：团队开发中，需求增加时，只增加自己的代码，不应该更改已有的代。即对扩展开放，对修改关闭。开闭原则是面向对象最重要的设计原则，其关键在于抽象。 案例：绘制圆和正方形。最粗暴的做法如下： 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;class CCircle &#123;public: void draw() &#123; std::cout &lt;&lt; "Drawing cirlce..." &lt;&lt; std::endl; &#125;&#125;;class CSquare &#123;public: void draw() &#123; std::cout &lt;&lt; "Drawing square..." &lt;&lt; std::endl; &#125;&#125;;int main() &#123; enum EShapeType &#123; Circle, Square &#125;; EShapeType shapeType[] = &#123; Circle, Square &#125;; for (int i = 0; i &lt; sizeof(shapeType) / sizeof(EShapeType); i++) &#123; switch (shapeType[i]) &#123; case Circle: CCircle circle; circle.draw(); break; case Square: CSquare square; square.draw(); break; default: break; &#125; &#125; return 0;&#125; 当需求增加时，比如再绘制一个三角形，那么需要加上或更改如下代码： 1234567891011121314151617181920212223242526272829303132class CTriangle &#123;public: void draw() &#123; std::cout &lt;&lt; "Drawing triangle..." &lt;&lt; std::endl; &#125;&#125;;int main() &#123; enum EShapeType &#123; Circle, Square, Triangle &#125;; EShapeType shapeType[] = &#123; Circle, Square, Triangle &#125;; for (int i = 0; i &lt; sizeof(shapeType) / sizeof(EShapeType); i++) &#123; switch (shapeType[i]) &#123; case Circle: CCircle circle; circle.draw(); break; case Square: CSquare square; square.draw(); break; case Triangle: CTriangle triangle; triangle.draw(); default: break; &#125; &#125; return 0;&#125; 增加的这些代码都是必须的吗？增加的Triangle类是必须的，毕竟多了一种图元，但是改动的枚举类型和增加的case语句是必须的吗？而且需求增加时，改动了原来已有的代码。尤其是程序比较大以后，可能有很多地方都与这些枚举类型有关，那么需求一变，和这些枚举相关的代码都需要随之作出改变，而且还需要事先比较了解整个程序，才能不把程序改坏。很显然不符合开闭原则。这一切的根源都在于枚举的使用，只要使用了枚举就必然伴随类似switch-case的语句，枚举一变，和枚举相关的地方都要变，关联太大，可能会有连锁反应。switch几乎都不符合开闭原则，但是如果switch的是系统枚举值，是无法避免的，系统枚举值很少的话也无伤大雅，这时的函数允许超过50行。 可以为这些图元定义一个虚基类CShape，通过虚基类指针以多态的方式来调用所有子类的绘制函数： 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;vector&gt;class CShape &#123;public: virtual void drawV() = 0;&#125;;class CTriangle : public CShape &#123;public: void drawV() override &#123; std::cout &lt;&lt; "Drawing triangle..." &lt;&lt; std::endl; &#125;&#125;;class CQuad : public CShape &#123;public: void drawV() override &#123; std::cout &lt;&lt; "Drawing Quad..." &lt;&lt; std::endl; &#125;&#125;;class CCircle :public CShape &#123;public: void drawV() override &#123; std::cout &lt;&lt; "Drawing circle..." &lt;&lt; std::endl; &#125;&#125;;int main() &#123; std::vector&lt;CShape*&gt; shapes; shapes.push_back(new CQuad()); shapes.push_back(new CCircle()); shapes.push_back(new CTriangle()); for (unsigned int i = 0; i &lt; shapes.size(); i++) &#123; shapes[i]-&gt;drawV(); &#125; return 0;&#125; 当要绘制的图元类型增加时，只需要增加一个继承自CShape的子类，再将其对象加入到vector容器里就ok。很明显没有枚举、switch-case牵一发动全身的麻烦。 符合开闭原则。 现实中，没有任何一个程序或软件100%符合开闭原则。因为需求千奇百怪，不可能考虑到每一种情况，不可能对每一种需求都做到开闭原则。比如4中的程序，如果需求变为：按用户指定的顺序来绘制所有图元。此时4中的程序就必须针对该需求作出改变了，实现代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;class CShape &#123;private: int priority;public: virtual void drawV() = 0; void setPriority(int iPriority) &#123; priority = iPriority; &#125; friend bool operator&lt;(const CShape&amp; iShape1, const CShape&amp; iShape2) &#123; return iShape1.priority &lt; iShape2.priority; &#125; friend bool priorityLess(CShape* shape1, CShape* shape2) &#123; return *shape1 &lt; *shape2; &#125;&#125;;class CTriangle : public CShape&#123;public: CTriangle(int iPriority) &#123; setPriority(iPriority); &#125; void drawV() override &#123; std::cout &lt;&lt; "Drawing triangle..." &lt;&lt; std::endl; &#125;&#125;;class CQuad : public CShape &#123;public: CQuad(int iPriority) &#123; setPriority(iPriority); &#125; void drawV() override &#123; std::cout &lt;&lt; "Drawing Quad..." &lt;&lt; std::endl; &#125;&#125;;class CCircle :public CShape &#123;public: CCircle(int iPriority) &#123; setPriority(iPriority); &#125; void drawV() override &#123; std::cout &lt;&lt; "Draw circle..." &lt;&lt; std::endl; &#125;&#125;;int main() &#123; std::vector&lt;CShape*&gt; shapes; shapes.push_back(new CQuad(2)); shapes.push_back(new CCircle(1)); shapes.push_back(new CTriangle(3)); sort(begin(shapes), end(shapes), priorityLess); for (unsigned int i = 0; i &lt; 3; i++) &#123; shapes[i]-&gt;drawV(); &#125; return 0;&#125; 上面的程序值得注意的是： 可以使用STL中的sort函数对类对象进行排序，不过需要重载&lt;运算符，因为sort内部是将两个对象进行小于比较来排序的（或者直接用自定义的比较函数作为sort的第三个参数来排序）。 使用sort进行排序，必须是针对对象，而不能是对象指针，否则将会是对指针进行排序，指针实际上是4个字节的整型数据，也就是在对整型数据排序了，这样就根本不会进入到对&lt;符号的重载函数里。但是要实现多态，必须使用对象指针或者引用，所以上面的程序给sort函数指定了第三个参数：priorityLess函数，执行sort函数时会先调用该函数，在该函数里将对象指针shape1、shape2转换为对象shape1、shape2，再将这两个对象进行小于比较，这样就会进入到自定义的&lt;符号重载函数里，按照优先级priority来确定对象的小于关系是否成立。这样就能正常工作了，如果没有priorityLess函数，将是对对象指针这个int型数据在进行排序，多次运行程序时将得到不同的结果，显然是错误的。 在实际开发中，需要通过重构不断改善原有的设计（这是很频繁的）。 重构的目标是：需求变化时尽量满足开闭原则。 在敏捷开发中应该拒绝不成熟的抽象，避免过度设计。 案例：母亲给孩子讲故事。 12345678910111213141516#include &lt;iostream&gt;class CBook &#123;public: void getContent() &#123; std::cout &lt;&lt; "This is a book..." &lt;&lt; std::endl; &#125;&#125;;class CMother &#123;public: void read(CBook *vBook) &#123; std::cout &lt;&lt; "Mother is reading: "; vBook-&gt;getContent(); &#125;&#125;; 大多数初学者的实现方案都会是像上诉代码一样，这种设计是有问题的。CMother为什么要依赖于CBook呢？母亲除了给孩子读书，就不能读报纸这些了吗？如果要求母亲除了读书还能读报，最粗暴的就是再增加一个CNewspaper类，然后给read函数增加一个CNewspaper指针。很明显，这不符合开闭原则，需求增加时，改变了原有的CMother类。 可以考虑用抽象，将书、报纸等抽象出一个虚基类：出版物类CPublication，让CMother的read函数依赖于这个抽象类，而非具体的类，这样所有继承自这个抽象类的书、报纸等等子类都能被母亲类阅读了： 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;class CPublication &#123;public: virtual void getContentV() = 0;&#125;;class CBook : public CPublication&#123;public: virtual void getContentV() override &#123; std::cout &lt;&lt; "This is a book..." &lt;&lt; std::endl; &#125;&#125;;class CNewspaper : public CPublication &#123;public: virtual void getContentV() override &#123; std::cout &lt;&lt; "This is a newspaper..." &lt;&lt; std::endl; &#125;&#125;;class CMother &#123;public: void read(CPublication *vPublication) &#123; std::cout &lt;&lt; "Mother is reading: "; vPublication-&gt;getContentV(); &#125;&#125;; 像上面代码CMother类的read函数一样，代码不依赖于具体类，而是依赖于抽象的类，这就是依赖倒置原则。 开闭原则是面向对象设计的目标，依赖倒置原则是实现开闭特性的主要手段。 案例：纠结的正方形和矩形。讲道理，正方形是矩形的特例，让正方形派生自矩形，好像没有什么不对： 12345678910111213141516171819202122232425#include &lt;iostream&gt;class CRectangle &#123;private: double m_Width; double m_Height;public: virtual void setWidthV(double w) &#123; m_Width = w; &#125; virtual void setHeightV(double h) &#123; m_Height = h; &#125; double getArea() &#123; return m_Width*m_Height; &#125;&#125;;class CSquare : public CRectangle &#123;public: void setWidthV(double w) &#123; CRectangle::setWidthV(w); CRectangle::setHeightV(w); &#125; void setWidthH(double h) &#123; CRectangle::setWidthV(h); CRectangle::setHeightV(h); &#125;&#125;; 若现在有一个函数： 12345void g(CRectangle* vioRect) &#123; vioRect-&gt;setWidthV(5); vioRect-&gt;setHeightV(4); assert(vioRect-&gt;getArea() == 20);&#125; 如果外界传给函数g的实参是一个CSquare类指针，但是函数内部并不知道传入的是正方形，还是当做普通矩形来处理，这样一来assert语句将无法通过。也就是说对普通的基类对象可以通过，但是换成子类却无法通过。根源在于在基类CRectangle中长度和宽度的设置互不影响，但是子类CSquare不满足这个条件，实际上就不应该把正方形作为矩形的子类，应该分为两个独立的类。 这个正方形和矩形的例子体现了Liskov替换原则：把基类替换成它的子类，程序不应该产生任何错误和异常。这是判断抽象是否正确的重要依据。 案例：业务需要数据库操作。最粗暴的就不赘述了。由于可能会有多种数据库，我们将多种数据库先抽象出一个数据库的基类：CDBUtility。 1234567891011121314151617181920#include &lt;iostream&gt;class CDBUtility &#123;public: virtual void buildConnectionV() = 0;&#125;;class CMySQLUtility : public CDBUtility&#123;public: virtual void buildConnectionV() override &#123; std::cout &lt;&lt; "Building connection to MySQL..." &lt;&lt; std::endl; &#125;&#125;;class COracleUtility : public CDBUtility &#123;public: virtual void buildConnectionV() override &#123; std::cout &lt;&lt; "Building connection to Oracle..." &lt;&lt; std::endl; &#125;&#125;; 如果现在业务需要使用Oracle数据库，可以让业务类继承COracleUtility 类，就可以使用这个类中的方法了： 123456class CCustomerDAO : public COracleUtility &#123;public: void doSomething() &#123; buildConnectionV(); &#125;&#125;; 但是这种派生是不符合开闭原则的，当业务使用的数据库发生变化时，需要去更改业务类所继承的父类，改动了原有的CCustomerDAO 类代码。而且让业务类继承数据库类，看着就怪怪的。 应该让数据库类成为业务类的成员变量，通过这个成员变量去使用数据库类中的方法： 123456789101112class CCustomerDAO&#123;private: CDBUtility* m_pDBUtility;public: void setDBUtility(CDBUtility *vUtility) &#123; m_pDBUtility = vUtility; &#125; void doSomething() &#123; m_pDBUtility-&gt;buildConnectionV(); &#125;&#125;; 可以在main函数中动态地指定业务使用何种数据库： 123456int main() &#123; CCustomerDAO CustomerDAO; CustomerDAO.setDBUtility(new COracleUtility()); CustomerDAO.doSomething(); return 0;&#125; 这样一来无论业务使用何种数据库，只需要在main函数中修改传入的数据库类型即可，而不用去更改原有的类设计。不过这时候main函数不符合开闭原则了，需要修改main函数，后面会讲如何使main函数符合开闭原则的方法。 这个例子体现了合成复用的原则：尽量使用对象成员，而不是继承的方式来达到复用的目的。 绘制图元的一种具体实现方案如下：先将图元转化为像素点，再绘制出所有像素点。代码设计如下： 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;vector&gt;class CShape &#123;private: std::vector&lt;std::pair&lt;int, int&gt;&gt; m_Pixels;public: virtual void generatePixelV() = 0; void drawShape() &#123; generatePixelV(); std::cout &lt;&lt; "Drawing pixels on window..." &lt;&lt; std::endl; &#125;&#125;;class CRectangle : public CShape&#123;public: virtual void generatePixelV() override &#123; std::cout &lt;&lt; "Generating pixels on rectangle..." &lt;&lt; std::endl; &#125;&#125;;class CTriangle : public CShape &#123;public: virtual void generatePixelV() override &#123; std::cout &lt;&lt; "Generating pixels on triangle..." &lt;&lt; std::endl; &#125;&#125;; 现在需求变为：在不同操作系统上，比如windows和linux，实现不同图元的绘制。 前面的虚基类只针对不同图元生成像素点给出了虚函数接口，现在再针对不同操作系统上绘制像素点来增加一个接口： 123456789101112131415class CShape &#123;private: std::vector&lt;std::pair&lt;int, int&gt;&gt; m_Pixels;public: virtual void generatePixelV() = 0; void drawShape() &#123; generatePixelV(); _drawPixelsV(); &#125;protected: virtual void _drawPixelsV() = 0;&#125;; 在Windows上绘制矩形就可以用下面的类来实现： 1234567891011class CRectangleOnWindows : public CShape&#123;public: virtual void generatePixelV() override &#123; std::cout &lt;&lt; "Generating pixels on rectangle..." &lt;&lt; std::endl; &#125;protected: virtual void _drawPixelsV() override &#123; std::cout &lt;&lt; "Drawing pixels on windows..." &lt;&lt; std::endl; &#125;&#125;; 在Linux上绘制矩形用下面的类： 1234567891011class CRectangleOnLinux : public CShape &#123;public: virtual void generatePixelV() override &#123; std::cout &lt;&lt; "Generating pixels on rectangle..." &lt;&lt; std::endl; &#125;protected: virtual void _drawPixelsV() override &#123; std::cout &lt;&lt; "Drawing pixels on linux..." &lt;&lt; std::endl; &#125;&#125;; 问题很明显了，还有在window和linux上绘制三角形、圆的类还没写呢，如果有m个图元要在n个平台上绘制，那么就会有m*n个类。导致这个问题的根本原因就在于：在一个基类里面有两个独立的变化，通过继承来实现这两种变化，类的数量肯定会很多。 解决方案就是把这两个对立的变化分别作为两个基类： 1234567891011121314151617class CShape &#123;private: std::vector&lt;std::pair&lt;int, int&gt;&gt; m_Pixels;public: virtual void generatePixelV() = 0; void drawShape() &#123; generatePixelV(); std::cout &lt;&lt; "Drawing pixels on kinds of platform..." &lt;&lt; std::endl; &#125;&#125;;class CPlatform &#123;public: virtual void drawPixels(const std::vector&lt;std::pair&lt;int, int&gt;&gt;&amp; vPixels) = 0;&#125;; 那么这两个基类如何联系起来呢？让CShape继承CPlatform？显然不合常理。让子类去多重继承这两个基类？这样的话子类就需要去同时实现generatePixelV()和drawPixels()这两个虚函数接口，实现在不同平台下绘制不同图元又会产生出m*n个子类。而且合成复用原则建议少用继承，所以这里可以考虑遵循合成复用原则：将CPlatform类对象作为CShape类的成员变量： 12345678910111213141516171819202122class CShape &#123;private: std::vector&lt;std::pair&lt;int, int&gt;&gt; m_Pixels; CPlatform* m_Platform;public: virtual void generatePixelV() = 0; void drawShape() &#123; generatePixelV(); m_Platform-&gt;drawPixels(m_Pixels); &#125; void setPlatform(CPlatform* vPlatform) &#123; m_Platform = vPlatform; &#125;&#125;;class CPlatform &#123;public: virtual void drawPixels(const std::vector&lt;std::pair&lt;int, int&gt;&gt;&amp; vPixels) = 0;&#125;; 这两个基类的各自的子类只要实现一个虚函数就可以了，互不影响： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;vector&gt;class CPlatform &#123;public: virtual void drawPixels(const std::vector&lt;std::pair&lt;int, int&gt;&gt;&amp; vPixels) = 0;&#125;;class CShape &#123;private: std::vector&lt;std::pair&lt;int, int&gt;&gt; m_Pixels; CPlatform *m_pPlatform;public: virtual void generatePixelV() = 0; void drawShape() &#123; generatePixelV(); m_pPlatform-&gt;drawPixels(m_Pixels); &#125; void setPlatform(CPlatform* vPlatform) &#123; m_pPlatform = vPlatform; &#125;&#125;;class CRectangle : public CShape&#123;public: virtual void generatePixelV() &#123; std::cout &lt;&lt; "Generating pixels on rectangle..."; &#125;&#125;;class CCircle : public CShape &#123;public: virtual void generatePixelV() &#123; std::cout &lt;&lt; "Generating pixels on circle..."; &#125;&#125;;class CWindows : public CPlatform &#123;public: virtual void drawPixels(const std::vector&lt;std::pair&lt;int, int&gt;&gt;&amp; vPixels) &#123; std::cout &lt;&lt; "Drawing pixels on windows..." &lt;&lt; std::endl; &#125;&#125;;class CLinux : public CPlatform &#123;public: virtual void drawPixels(const std::vector&lt;std::pair&lt;int, int&gt;&gt;&amp; vPixels) &#123; std::cout &lt;&lt; "Drawing pixels on linux..." &lt;&lt; std::endl; &#125;&#125;; 在主函数中可以通过设置子类对象的m_pPlatform变量来指定在哪个平台下绘制图元： 123456789101112131415int main() &#123; CRectangle Rect; Rect.setPlatform(new CWindows()); Rect.drawShape(); Rect.setPlatform(new CLinux()); Rect.drawShape(); CCircle Circle; Circle.setPlatform(new CWindows()); Circle.drawShape(); Circle.setPlatform(new CLinux()); Circle.drawShape(); return 0;&#125; 运行结果如下： 1234Generating pixels on rectangle...Drawing pixels on windows...Generating pixels on rectangle...Drawing pixels on linux...Generating pixels on circle...Drawing pixels on windows...Generating pixels on circle...Drawing pixels on linux... 优势很明显，只用m+n个类再加上两个基类，就可以完成在m个平台上绘制n个图元的工作。 这用的实际上就是桥接模式。 桥接模式：独立的变化因素应该封装到独立的类中。比如需要在不同的操作系统上绘制矩形、圆、三角形等图元。操作系统是一个独立的变化因素，应该将它单独封装到一个类中，提供在不同操作系统上画像素点的方法。图元是另一个独立的变化因素，也应该将它单独封装到一个类中，提供将不同图元转化为像素点的方法。 函数不应该超过50行，类不应该超过400行。 小结： 开闭原则是面向对象设计的最基本原则 依赖倒置原则是实现开闭原则的主要手段，其实就是抽象、多态。 Liskov替换原则用来判断抽象是否正确，保证依赖倒置的正确性。 但完全通过集成来实现开闭原则，可能导致类爆炸，可以用合成复用原则来解决，它是实现开闭原则的另一种手段。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>面向对象设计原则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[老张培训笔记第一课码农]]></title>
    <url>%2F2017%2F07%2F10%2F%E8%80%81%E5%BC%A0%E5%9F%B9%E8%AE%AD%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%80%E8%AF%BE%2F</url>
    <content type="text"><![CDATA[感谢老张！ 用设计模式去解决一些实际问题。 团队交流的重要性不亚于个人的编码能力。 若有一个简单的函数要实现几十个int型数据的加法，最粗暴的写法如下：1234567int Add(int n) &#123; int sum = 0; for (int i = 0; i &lt; n; i++) &#123; sum += i; &#125; return sum;&#125; 但是如果需求变成几十个float型数据相加呢，是不是需要把上面函数中的int都换为float，如果还增加了double、char等等呢，需要重复写上诉代码？ 很显然，这样做就真的是码农了，花大把时间做体力活。应该使用模板，如下：12345678template &lt;typename T&gt;T Add(T n) &#123; T sum = 0; for (T i = 0; i &lt; n; i++) &#123; sum += i; &#125; return sum;&#125; 这样就可以很方便的调用Add(100)，Add(100.0f)，Add(‘!’)等等了。值得注意的是，在模板函数中声明变量时必须同时赋值来初始化，如上面程序中的T sum=0; 码农的定义：需求变化时，会有很多体力活要做。 对同一个功能，应该用更少的代码去实现。 多调试团队里其他人的代码，包括bug。 函数不能超过50行，这样函数的功能就会比较单一，方便给函数起名字，这样一来也能减少甚至达到不写注释。 在代码中应该尽量不要写注释，但注释不同于文档。注释是在说明变量代表什么，函数实现了什么功能，文档是在说明为什么这么设计，比如该函数为什么是私有的或者保护的。 在写代码中，不要ctrl+c、ctrl+v，也不要copy团队里其他人的代码，要使用别人的代码时，应该只需要调用别人预留的函数接口，而非具体的代码实现。 做起来像体力活的东西都需要改进。 用不同的设计模式来解决同一个问题。 问题示例：写日子文件。很多人的做法是仅仅实现了往文件里写东西的功能，但是没有考虑到效率问题，每收到一条log就打开文件、写文件、关闭文件。应该增加一个缓冲区，将日志信息先放到缓冲区中，每隔一段时间将缓冲区里的内容一起写入日志文件。 具体的实现细节应该隐藏在类内部，外部只需要知道类的功能是什么。 类的成员变量都应该尽量是私有的。甚至接口、虚基类里的成员变量也应该尽量私有（非保护）。为私有成员变量添加get、set函数，这样可以在get、set函数中对变量的读取、写入添加一些条件限制。 比如某个私有成员变量m_Money，只有当它的值大于1000时，才允许被读取到外界： 123456int getMoney() &#123; if (m_Money &gt; 1000) return m_Money; else return -1;&#125; 如果将m_Money直接写为公有的，那么外界就可以直接读取到该变量，但是如果增加了上面这个读取条件限制，那么就需要在每个读取该变量的地方，加上条件限制，很显然体力活又来了。这就是为何需要将成员变量写为私有的原因。 如下代码： 1234567vector&lt;int&gt; getMoney() &#123; vector&lt;int&gt; array; for (int i = 0; i &lt; 100; i++) &#123; array.push_back(i); &#125; return array;&#125; 这样的函数是不够好的，因为它向外界暴露了函数内部数据的存储方式为vector，如果哪天把vector改为了List，那么外界所有调用该函数的地方可能都需要随之改变，把外界的vector改为List，体力活又来了。 如果想返回vector里的所有数据，通常get函数会接收一个输入输出参数，比如数组，来存储vector里的所有数据。当然，这样好的设计风格确实带来了数据复制时的性能开销。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>码农</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++浅层拷贝和深层拷贝]]></title>
    <url>%2F2017%2F05%2F31%2FC%2B%2B%E6%B5%85%E5%B1%82%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E5%B1%82%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[拷贝构造函数 什么是拷贝构造函数拷贝构造函数是一种特殊的构造函数，其形参是本类对象的引用。它的作用是：在建立一个新对象时，使用一个已经存在的对象去初始化这个新对象。例如：1Point p2(p1); 在建立新对象p2时，用已经存在的对象p1去初始化新对象p2，在这个过程中就要调用拷贝构造函数。 拷贝构造函数的特点拷贝构造函数具有以下特点： 因为它也是一种构造函数，所以其函数名与类名相同，并且没有返回值类型。 只有一个参数，并且是同类对象的引用。 每个类都必须有一个拷贝构造函数。如果我们没有自定义某个类的拷贝构造函数，那么系统会自动生成一个默认的拷贝构造函数，用于复制出数据成员值完全相同的新对象。 拷贝构造函数的一般形式自定义拷贝构造函数的一般形式如下：123类名(const 类名&amp; 对象名)&#123; ...&#125; 例如：12345678910111213class Point &#123;private: int x, y;public: Point(int a, int b) &#123; x = a; y = b; &#125; Point(const Point&amp; p) &#123; x = 2 * p.x; y = 2 * p.y; &#125;&#125;; 什么时候会调用拷贝构造函数有3种情况下会调用拷贝构造函数： 用一个对象去初始化另一个对象时。如下： 12Point p2(p1);Point p3=p1; 类对象作为函数参数时。如下： 12void func(Point p)&#123;&#125; 调用函数func，实参传入形参时会调用拷贝构造函数来初始化形参p。 函数返回值是类对象时。如下：12345678910Point func()&#123; Point p1(10,20); return p1;&#125; int main()&#123; Point p2; p2 = func(); return 0;&#125; 执行语句return p1时，将会调用拷贝构造函数将p1的值复制到一个临时对象中，这个临时对象是编译系统在主程序中临时创建的，函数运行结束时对象p1消失，但临时对象将会通过语句p2=func()将它的值赋给对象p2，执行完这个语句后，临时对象的使命也就完成了，该临时对象便自动消失了。 浅层拷贝构造函数 编译器会提供默认的拷贝构造函数，但它只是把传递进来的对象的每个成员复制到新对象的成员变量中去，两个对象的变量共享内存区域，我们把这种拷贝叫做浅层拷贝。 如果浅层拷贝的两个对象共享指针变量，那么当其中一个对象释放掉该存放指针变量的内存空间时，另一个对象的该指针变量就变成了野指针（迷途指针），会报错。如下所示：1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;using namespace std;class Point &#123;private: int *x;public: Point(int a) &#123; x = new int(); *x = a; &#125; ~Point() &#123; cout &lt;&lt; "delete" &lt;&lt; endl; delete x; x = NULL; &#125; Point(const Point&amp; p) &#123; x = p.x; &#125; int getX() &#123; return *x; &#125;&#125;;int main() &#123; Point *p1 = new Point(14); Point p2 = *p1; delete p1; cout &lt;&lt; p2.getX() &lt;&lt; endl; return 0;&#125; 当删除p1之后，p1和p2共用的指针x就会通过析构函数被释放掉，在执行cout &lt;&lt; p2.getX() &lt;&lt; endl;将无法得到想要的值14（会得到一个随机内存的值，可能会很大），在main函数结束时，程序会调用p2的析构函数再次释放指针x，但是x在此之前已经被释放掉了，所以程序会报错。程序输出结果如下：123delete-572662307delete 去掉上面程序中的拷贝构造函数也是一样的错误，因为程序默认的拷贝构造函数就是浅层拷贝，跟上面程序中的拷贝构造函数几乎是一样的。 深层拷贝构造函数 为了解决浅层拷贝导致的野指针问题，必须创建自己的拷贝构造函数，并且在函数里为成员变量分配内存。这样两个对象的成员变量都各自拥有自己的内存区域。这就是深层拷贝，可以使拷贝结果与拷贝源不共用内存。如下所示：123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;using namespace std;class Point &#123;private: int *x;public: Point(int a) &#123; x = new int(); *x = a; &#125; ~Point() &#123; cout &lt;&lt; "delete" &lt;&lt; endl; delete x; x = NULL; &#125; Point(const Point&amp; p) &#123; x = new int(); *x = *(p.x); &#125; int getX() &#123; return *x; &#125;&#125;;int main() &#123; Point *p1 = new Point(14); Point p2 = *p1; delete p1; cout &lt;&lt; p2.getX() &lt;&lt; endl; return 0;&#125; 在拷贝构造函数Point(const Point&amp; p)中，对当前类对象的成员变量又重新分配了内存空间，并且完成了变量内容复制（注意不要写成x=p.x，否则指针相同导致对应的变量还是共用的一个地址），程序运行正常，输出结果如下：123delete14delete 当释放p1调用析构函数时，释放的是p1的指针变量x，并不会影响到p2的指针变量x，因为深层拷贝下p1和p2的成员变量x不再共用内存。&nbsp; 参考文献：《C++基础–浅层及深层拷贝构造函数》]]></content>
  </entry>
  <entry>
    <title><![CDATA[C++ const详解]]></title>
    <url>%2F2017%2F05%2F30%2FC%2B%2Bconst%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[被const修饰的东西（包括变量、函数、返回值等等）都强制为只读的，可以防止外界意外地改动，可以提高程序的健壮性，所以我们可能经常看到一句话：“Use const whenever you need”。 用const修饰变量 对于const int *m;，const修饰的是整型变量*m，不是指针变量m，所以*m是不可变的，m是可变的，即： 1234const int *m;int *n;m = n; //合法，m所指向的对象是可变的*m = 14; //不合法，m指向的对象的内容是不可变的 const int *m和int const *m是一样的。 对于int * const m;，const修饰的是指针变量m，所以m是不可变的，但*m是可变的，即： 12345int p;int * const m = &amp;p;int *n;m = n; //不合法，m所指向的对象是不可变的*m = 14; //合法，m指向的对象的内容是可变的 而且int * const m是必须在定义时赋初值的，否则m将指向随机的内存地址，这个内存地址是可能会变的，即m会变，则不符合const修饰的只读属性，所以必须在定义时为其指定一个确切的地址，而且一经赋值就不能再变了。 对于const int m，const修饰的是m，m的值是不可变的，如下： 1234int n;const int m = n;int p = m; //合法，因为p是m的复制，不共用地址，不是同一个变量，可以有不同的读写属性int&amp; q = m; //不合法，因为p和m共用地址，是同一个变量，但p和m却具有不同的读写属性，不合语义 在定义m时也是需要赋初值的，因为m的值是一经确定不能再改变的，它需要从一开始就知道自己的值是多少，不能后续再通过赋值语句来确定自己的值，即m = 14;是非法的。int&amp; q = m不合法是因为m是只读的，q是可读可写的，但是m和q共用一个地址，实际上是同一个变量，但却有不同的读写属性，即可以通过改变q来改变m的值，这是不符合const语义的，所以它不合法。而int p = m合法是因为p是m的复制，和m不共用地址，不是同一个变量，可以拥有不同的读写属性，改变p并不会影响到m。 【注】： 上面的const int *m可以不用赋初值，是因为const虽然修饰的是*m，*m是不可以直接赋值改变的，但是指针m指向的内容（即*m）是可以通过改变m来间接改变的： 1234567const int *k;int m = 10;int n = 20;k = &amp;m;cout &lt;&lt; *k &lt;&lt; endl;k = &amp;n;cout &lt;&lt; *k &lt;&lt; endl; 输出如下： 121020 用const修饰函数参数 如果函数参数需要作输出参数用，那么该参数就不能用const修饰，因为一旦用const修饰，该参数就无法在函数内部做任何改变，输入的是什么值，输出的将还是同样的值，强制对该参数赋值会编译报错，无法达到向函数外输出有效数据的作用。但是如果函数参数只作输入参数用，使用const修饰可以保证函数内部不会意外改动该参数，尤其是当函数参数是地址、引用等地址类型时，使用const能够起到保护作用，使函数实参不会被改变。如下：1void copyString(char* strDest, const char* strSrc); strSrc是输入参数，在字符串复制时并不希望改变它，所以用const将它修饰为只读的，函数内部如果企图改变strSrc的内容，编译器将报错。strDest是输出参数，将复制过后的字符串传到函数外部的对应实参。 对于采用值传递的参数，由于函数会自动产生临时变量来复制实参，此时的函数参数（形参）和其实参具有不同的地址，即实参已经受到了保护，形参改变时并不会影响到其实参，所以无需加const修饰。例如：1void func1(int x); 不需要用const来修饰采用值传递的形参x：1void func(const int x); 同样地，无需将void func(A a)写为void func(const A a)，A为我们自定义的类、结构体等数据类型，非C++基本数据类型。 对于非C++基本数据类型的参数而言，像void func(A a)这样直接传递对象效率会比较低，因为函数内部会再产生一个A类型的临时对象a来复制对应实参，而临时对象将会产生构造、复制、析构等时间内存开销。为了提高效率，可以将函数改为：1void func(A&amp; a); 这样函数参数将采用址传递，形参只是实参的别名，共用同一个地址空间，不会产生临时对象。但是a可能只需要做输入参数用，并不希望函数内部改变参数a的内容，这时就可以将参数a用const来修饰为只读的：1void func(const A&amp; a); 这样既达到了提高效率的目的，也保护了参数a对应的实参。那么为了提高效率是否应该将void func(int x);改为void func(int&amp; x);呢？不需要的，因为C++基本数据类型在赋值/复制时没有构造、析构的过程，复制也非常快，基本类型的值传递和引用传递效率几乎一致。注：这里x只作输入参数用，如果需要作输出参数，还是要采用址传递的。 综上： 对于非基本数据类型的输入参数，应该将“值传递”的方式改为“const 引用传递”来提高效率。例如将void func(A a);改为void func(const A&amp; a);。 对于基本数据类型的输入参数，不需要做上述改变，否则既不能提高效率也降低了函数的可读性。例如不要将void func(int x);改为void func(const int&amp; x);。 用const修饰函数返回值 如果函数返回值采用值传递方式，用const修饰是没有价值的，因为函数会把返回值复制到外部的临时变量中，对函数内部的返回变量已经起到了保护作用。如果函数返回值采用址传递方式，比如指针，用const修饰返回值，能够保证函数返回值（即指针）的内容不能被修改，该返回值只能赋给const修饰的同类型指针。 若返回值是非基本数据类型，将A get();改为const A&amp; get()确实可以提高效率，但是要注意函数到底是想返回一个对象的拷贝还是对象的别名，不然程序容易出错。比如外界想对get函数返回的对象值作进一步处理，但是又不想影响到A对象中的成员，那么无论使用A&amp; get()还是const A&amp; get()都达不到效果，还是得使用A get()。其实函数返回值采用引用传递的场合并不多，一般出现在类的赋值函数中，目的是为了实现链式表达式。如下：123456789class A &#123; const A&amp; operator= (const A&amp; other);&#125;;int main()&#123; A a, b, c; a = b = c; //合法 (a = b) = c; //不合法&#125; 在a=b=c时，先执行b=c，返回值是const A类型，再将它作为参数传给other，最后赋值给A类型的a；但是在(a=b)=c时，先执行a=b，返回值是const A类型，接下来会将c作为参数传给other，最后赋值给const A类型，这与const变量只读冲突，所以是不合法的。 用const修饰成员函数 用const修饰成员函数用于保证函数内部不会修改数据成员，且不能调用其他非const成员函数（因为其他非const成员函数可能会修改数据成员）。如下：123456789101112131415class Test&#123;private: int value;public: Test() &#123; value = 100; &#125; int&amp; GetValue() const;&#125;;int&amp; Test::GetValue() const&#123; return value; //value此时具有const属性，不合法&#125; 由于每个非static非const的成员函数都有一个隐含的this，所以用const修饰函数相当于是在修饰this，由于函数的作用域只在函数内部，所以只在函数内部时this指针是const类型的，是只读的，也就是说在const修饰的函数内部，this的任何成员变量和成员函数都是只读的。所以上面GetValue函数里，value（即this.value）也是const类型的，返回的是const int类型，但函数指定的返回值却是int&amp;，这与前面讲的int&amp; q = m是一样的道理，不合法。 可以这样改： 把变量声明int value改为mutable int value，因为mutable修饰的变量是易变的，是const的反义词，可以在const函数中被修改。 将return value改为return const_cast&lt;int&amp;&gt;(value)，因为const_value去掉了const性质（其实是去掉了指向value指针的const性质，可以间通过前文说的间接方式来改变value的值，value自身的const属性是去不掉的）。 将函数改为const int&amp; Test::GetValue() const。 将函数改为int Test::GetValue() const。 将函数后面的const去掉。 return的不是成员变量，即如下：12345int&amp; Test::GetValue() const&#123; int tempValue = value; return tempValue;&#125; 对于第4种将&amp;去掉，其原理与上面讲的int p = m是一致的，非地址类型是直接复制的，前后不是同一个变量，可以有不同的读写属性。 如果将value改为指针类型，如下程序：12345678910111213141516class Test&#123;private: int *value;public: Test() &#123; value = new int(); *value = 100; &#125; int* GetValue() const;&#125;;int* Test::GetValue() const&#123; return value; //value此时具有const属性&#125; 上面程序是不会报错的，但是函数返回的是指针，与上文返回引用有什么不同吗？上文返回引用是报错的。这是因为这里返回的指针，而函数返回类型也是指针类型的，指针本身就相当于一个4字节的整型变量，存储着其他变量的地址，所以这里还是相当于上面第4种修改方式，是两个int型变量之间的复制。如果把程序改成下面这样是会出错的：123456789101112131415class Test&#123;private: int value;public: Test() &#123; value = 100; &#125; int* GetValue() const;&#125;;int* Test::GetValue() const&#123; return &amp;value; //value此时具有const属性，不合法&#125; 原理还是一样的，const int类型的返回值value和函数返回的int*类型的临时变量具有相同的地址，实际上是同一个变量，但却具有不同的读写属性，返回的临时变量是可写的，但value只读，所以是不合法的。&nbsp; 参考文献：C++ const修饰成员函数]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>const</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《GPP》第一章 架构、性能和游戏]]></title>
    <url>%2F2017%2F05%2F25%2FGPP%E7%AC%AC%E4%B8%80%E7%AB%A0%E6%9E%B6%E6%9E%84%E6%80%A7%E8%83%BD%E5%92%8C%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[软件架构 衡量一个设计好坏的方法就是看它应对变化的灵活性。 如果两块代码耦合，意味着我们必须同时了解这两块代码，如果让它们解耦，那么只需了解其一。耦合得越低，更改所波及的范围就会越小。 好架构的代价 解耦意味着我们在进行扩展时仅需理解少量代码，但同时抽象却也增加了理解代码的难度。 如果过度关注代码的设计架构，便会得到一个架构已经失控的代码库。我们会看到接口和抽象无处不在。插件系统、抽象基类、虚方法众多，还有各种的扩展点。我们将花费大量时间去找到有实际功能的代码。要避免过度设计。 性能和速度 使用接口，能够让代码可以与任何实现这些接口的类进行工作，而不是使用具体类。 模板元编程可以让我们获得抽象接口而没有任何运行时开销，在编译期间就能决定在模板实例化时调用哪个类。 性能优化总是在某些假设下进行的。 软件架构好，灵活性高，但是会降低游戏性能，一种折中的办法是保持代码的灵活性，直到设计稳定下来，然后去除一些抽象，以提高游戏性能。 坏代码中的好代码 只是为了验证游戏想法、迟早会扔掉的一些代码，在编写时不必在意设计架构。 我们需要确保那些使用一次性代码的人明白这种一次性代码看起来能够运行，但是它却不可维护，必须被重写。让boss明白原型代码只能用1次，以后要接着用就不要要求快速原型。 有一个小技巧确保我们的原型代码不会变成真正的代码，就是使用不同于我们游戏使用的语言来编写。这样的话，我们就必须用游戏使用的语言重写一遍了。 简单性 保持简单性，代码量就会变少。这意味着更改代码时，我们的脑袋里只需装载更少的代码。 但是一个好的解决方案并不是更少的实际代码量，而是对代码的升华。 Blaise Pascal曾说：“我会写一封更简短的信，但我没有足够的时间。” Antoine de Saint-Exupery（书，小王子）：“极臻完美，并非无以复加，而是简无可减。” More.. 抽象和解耦能够使我们的程序开发变得更快和更简单。但不要浪费时间来做这件事，除非我们确信存在问题的代码需要这种灵活性。 在我们的开发周期中要对性能进行思考和设计，但是要推迟那些降低灵活性的、底层的、详尽的优化，能晚则晚。 如果我们将要删除代码，那么不要浪费时间将它整理得很整洁。摇滚明星把酒店弄得很乱是因为他们知道第二天就要结账走人。 在游戏发布前的两个月并不是我们开始担心“游戏的FPS只有1帧”问题的时候。&nbsp; 参考文献：Nystrom R. Game Programming Patterns[M]. ?:Genever Benning, 2014.11.]]></content>
      <categories>
        <category>游戏设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[OpenGL27：Gamma校正]]></title>
    <url>%2F2017%2F05%2F24%2FOpenGL27Gamma%E6%A0%A1%E6%AD%A3%2F</url>
    <content type="text"><![CDATA[现在的很多监视器都是阴极射线管显示器（CRT）或者LED显示器，它们在显示颜色时并非按照线性方式工作，我们在程序中输出的颜色，最终显示到屏幕上亮度会减弱，这对于计算光照和实时渲染的图形质量有一定影响，需要我们进行Gamma校正。 Gamma校正的概念及意义 我们在自己的图形程序中认为颜色(1.0,0.0,0.0)的红色强度应该是颜色(0.5,0.0,0.0)的两倍，但是实际上显示设备对于输入的原始值，是按照2.2次幂的的指数形式（简称Gamma指数变换）进行处理的，即$C_{out}=C_{in}^{2.2}$，其中2.2是Gamma系数，不同显示器的Gamma系数值会略有不同，通常在2.0到2.4之间。所以程序中红色分量增大到了2倍，但是显示器显示出来的红色亮度并不是2倍，而是暗一些，比2倍低（因为原始颜色值都是在0到1之间的小数）。显示器所做的这种Gamma指数变换如下图所示： 图1图中间的点线是我们在图形程序中通常认定的线性颜色，即我们希望在程序中颜色分量（横轴）增加的同时显示器显示出来的亮度也会同比例增加。当显示器接收了来自程序的线性原始值后，会进行上诉的指数运算，完成Gamma变换，然后输出图中下方实线所示的非线性颜色，除了0和1这两个端点以外，其他颜色分量的亮度都会降低。 【注】：线性颜色可以通俗地理解为我们最终想要的颜色。 所以，要想最终显示器按照我们在程序中预期的中间线性颜色来输出，我们需要在显示器执行Gamma指数变换之前，先做一个Gamma指数变换的逆变换：$C_{corrected}=C_{in}^{1.0/2.2}$，这样最终输出的颜色才会是我们在程序中指定的颜色，这个逆变换称为Gamma校正（Gamma Correction），对应图1中最上面的短划线。Gamma系数取2.2进行校正在大多数显示器上效果都比较理想。例如颜色(0.5，0.0，0.0)进行Gamma校正后会变为：$(0.5,0.0,0.0)^{1/2.2}=(0.73,0.0,0.0)$，校正后的颜色接下来会被发送给显示器，由于现实器会对输入的颜色做Gamma指数变换，所以最显示出来的颜色是：$(0.73,0.0,0.0)^{2.2}={0.5,0.0,0.0}$，与我们在程序中最初想要输出的颜色一致。 下图是Gamma变换前后的效果图，可以看到Gamma变换后的亮度增大了，恢复为程序想要的正常颜色。 图2 在程序中使用Gamma校正 有两种在场景中应用Gamma校正的方式： 使用OpenGL内置的sRGB帧缓冲。使用glEnable(GL_FRAMEBUFFER_SRGB)开启sRGB帧缓冲，告诉OpenGL每个后续的绘制命令里，在颜色存储到颜色缓冲之前都先校正sRGB颜色，即OpenGL会自动使用硬件为自定义帧缓冲和默认帧缓冲执行Gamma校正。sRGB这个颜色空间大致对应于Gamma2.2。 值得注意的是，Gamma校正应该放在最后一步，即把颜色输出给默认帧缓冲的前一步。如果在最后输出给屏幕之前就进行Gamma校正，那么后续操作都将是在操作不正确的颜色值（非线性的颜色值）。例如，如果使用多个帧缓冲，同时想要在两个帧缓冲之间传递的中间结果依然是线性颜色，那么只应该给最后的那个帧缓冲应用Gamma校正。 自己在像素着色器的最后使用程序进行Gamma校正。如下代码所示：12345void main()&#123; ... float gamma=2.2; color = vec4(pow(resultColor.rgb, vec3(1.0/gamma)), 1.0f);&#125; 该方法有个问题就是为了保持场景中所有物体都应用了Gamma校正，必须在每个像素着色器里加上该Gamma校正。解决方案是使用后处理，在后处理窗口四边形上应用Gamma校正，这样就只用做一次Gamma校正就好了。 并非任何时候都要进行Gamma校正 我们在本地资源管理器中通过看图软件打开一张图片，想要通过图形程序显示和这张图片一模一样的效果，即看图软件中图片的颜色是我们想要的最终颜色，是线性颜色。由于图片显示到屏幕上会经过Gamma指数变换，所以内存中实际存储的图片颜色数据是经过Gamma校正以后的，因为这样才能在显示器上显示我们想要的线性颜色。换句话说，绘图或者编辑图片的过程就是对内存中颜色数据进行人为的Gamma校正。 如果我们在图形程序中做了Gamma校正，那么最终图形程序在显示器上显示的就是经过两次Gamma校正和一次Gamma指数变换后的非线性颜色（对应图1中最上面的短划线），但是本地看图软件打开的图片是线性颜色，这就会造成图形程序最终显示的图片比看本地看图软件打开的图片更亮，不是我们想要的一模一样的效果，如下图所示： 图3为了解决这个问题，我们可以首先使用Gamma指数变换把sRGB纹理的纹素值变回线性空间，再继续其他光照计算等等，最后再做一次Gamma校正，然后输出给帧缓冲：12float gamma=2.2;vec3 diffuseColor = pow(texture(diffuse, texCoords).rgb, vec3(gamma)); 为每个sRGB空间的纹理做这件事很麻烦，幸运的是，OpenGL为我们提供了GL_SRGB和GL_SRGB_ALPHA内部纹理格式，使用这两种内部纹理格式，OpenGL会自动将颜色校正到线性空间中。可以这样定义一个sRGB纹理：1glTexImage2D(GL_TEXTURE_2D, 0, GL_SRGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, image); 值得注意的是，不是所有纹理都在sRGB空间中，比如diffuse漫反射纹理几乎都是在sRGB空间，但是specular镜面贴图和法线贴图几乎都在线性空间中，因为这样比较容易获取光照参数，如果把镜面贴图和法线贴图都存储为sRGB纹理的话，光照就废了。 Gamma校正对光照衰减的影响 光照衰减的物理公式应该是二次的，比如之前文章里介绍的二次衰减方程，简化版如下：1float attenuation = 1.0 / (distance * distance); 还可以用不太标准的双曲线函数来实现光源衰减：1float attenuation = 1.0 / distance; 但是有趣的是，在不使用Gamma校正时，双曲线函数比二次函数有更好的衰减效果；使用Gamma校正时，二次函数比双曲线函数有更好的衰减效果。如下图所示： 图4这是因为不应用Gamma校正时，经过显示器Gamma指数变换后二次函数衰减方程变为$(1.0/distance^2)^{2.2}$，双曲线函数变为$(1.0/distance)^{2.2}=1.0/distance^{2.2}$，这和物体公式很接近，所以不应用Gamma校正时，二次衰减方程衰减得会非常快，而双曲线函数的衰减效果比较好。 总之，Gamma校正使我们可以在线性颜色空间中进行操作，因为线性空间更符合物理世界，使大多数物理公式都可以获得较好的效果，比如真实的二次光照衰减方程。&nbsp; 参考文献：LearnOpenGL]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>Gamma校正</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenGL26：Blinn-Phong模型]]></title>
    <url>%2F2017%2F05%2F24%2FOpenGL26Blinn-Phong%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[Phong模型的缺陷 在《OpenGL10：光照基础Phong模型》中，我们使用了Phong模型来模拟光照效果，但是在镜面高光系数很低（比如0.5），即镜面光半径很大的时候，它的镜面反射会失效，如下图所示：可以看到，镜面区域边缘迅速减弱并截止，出现这个问题的原因是视线向量和反射光向量之间的夹角大于90度了，根据Phong模型中max(dot(reflectDir, viewDir), 0);，夹角大于90度时，镜面反射系数会被设置为0，所以一旦视线方向和反射光之间夹角大于90度，镜面光就会突然消失，变为0，产生镜面光硬边缘。但是大于90度变为0这只适用于漫反射光，而不适用于镜面光。计算漫反射光需要的夹角是入射方向和法线之间的夹角，大于90度时，入射光转到了物体背面，变为0；但是计算镜面反射光需要的夹角是视线方向和反射光方向之间的夹角，大于90度时，光线不一定转到了物体背面，如下图：所以对于镜面光，不能在夹角大于90度时令镜面光反射系数变为0。 当镜面高光系数较大时，高光比较集中，当高光突变为0时还有很强的漫反射光存在，所以人眼观察到的镜面光硬边缘不明显；但是当镜面高光系数较小时，高光半径会很大，高光在边缘处突变为0时漫反射强度很弱，镜面光成分较高，此时的镜面光硬边缘就会很明显。 Blinn-Phong模型 1977年James F. Blinn提出了Blinn-Phong模型，它是对Phong模型的改进：放弃反射光向量，改用半程向量，半程向量是入射光线向量与视线向量的和向量，再归一化之后的单位向量。如下图中的向量H：Blinn-Phong模型不再使用法线与反射向量的夹角来计算镜面光，而是使用半程向量和法线向量之间的夹角。半程向量越靠近法线向量，人眼观察到的镜面光强度越大。只要不从物体背面去看，半程向量和法线向量之间的夹角永远都小于等于90度。 Blinn-Phong模型的代码实现 Phong模型计算镜面光的代码如下：1234vec3 reflectDir = normalize(reflect(-lightDir, normal));vec3 viewDir = normalize(viewPos - positionInWorld); float specularFactor = pow(max(dot(reflectDir, viewDir), 0.0), 1); vec3 specularColor = specularFactor * lightColor; Blinn-Phong模型舍弃反射光向量，使用半程向量，代码如下：1234vec3 viewDir = normalize(viewPos - positionInWorld);vec3 halfDir = normalize(lightDir + viewDir);float specularFactor = pow(max(dot(halfDir, normal), 0.0f), 1);vec3 specularColor = specularFactor * lightColor; 可以发现Blinn-Phong模型除了表现效果更真实以外，还有个很大的优势：不用去计算复杂的反射光向量，降低了计算量，相比Phong模型性能更高。 当镜面高光系数为0.5时，Phong模型表现效果如第一幅图。Blinn-Phong模型表现效果如下图：由于半程向量和法线向量之间的夹角通常会比视线向量和反射向量之间的夹角更小，即余弦值更大，所以相同镜面高光系数下，Blinn-Phong模型的镜面光会比Phong模型更亮，Blinn-Phong模型要达到和Phong模型一样的效果，需要增大镜面高光系数，通常是Phong模型中的镜面高光系数的2到4倍。 所有源码请看这里。 &nbsp; 参考文献：LearnOpenGL]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>Blinn-Phong</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[交流中的启迪]]></title>
    <url>%2F2017%2F05%2F23%2F%E4%BA%A4%E6%B5%81%E4%B8%AD%E7%9A%84%E5%90%AF%E8%BF%AA%2F</url>
    <content type="text"><![CDATA[求取一个物体从某点看过去的轮廓（边缘检测）物体的边缘是由很多三角面片的边组成的，某条边是不是位于轮廓上，可以通过其三角形法线与视线方向向量的点乘来计算。如下图所示：每条边会被两个三角形共享，如果视线方向与其中一个三角形的点乘是正数，与另一个三角形的点乘是负数，则共享该边的两个三角形一个能被看见一个被挡住了，说明该边就是位于轮廓上。 此方法其实和冯氏漫反射光照很像。可以在几何着色器里实现，几何着色器可以接收类型为triangles_adjacency的图元，即接收一个三角面片的三个顶点和该三角面片的三个邻接顶点，如下图所示：根据这六个点计算出三角面片和其邻接面片的法线，用上述方法即可判断该三角面片的三条边是否有位于轮廓上。邻接顶点需要在CPU上事先算好（可以先存储由边构成的三角形，再判断当前边属于哪些三角形，再取出所属的邻接三角形的邻接顶点），存入顶点数据中传给顶点着色器。交流来源：师兄王振参考文献：《边缘检测》]]></content>
      <tags>
        <tag>交流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[毕设笔记]]></title>
    <url>%2F2017%2F05%2F22%2F%E6%AF%95%E8%AE%BE%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[在投影变换的过程中，就会剔除掉所有在视见体之外的片段，它们是不会从顶点着色器进入片元着色器的。也就是说那些在视见体之外的片段不会执行片元着色器。 深度测试是在片元着色器的过程中的，即使是那些被挡住的片段也是会执行片元着色器里的内容（比如片元着色器里的所有光照计算），很明显的证明例子就是延迟着色，延迟着色的优点就是剔除掉了对那些被遮挡的片段的光照计算。虽然被遮挡的和没被遮挡的片段都会执行光照计算，但是最后留在帧缓冲里的都是没被遮挡的片段，因为开启了深度测试。 透视除法也是在片元着色器之前的。当我们在顶点着色器输出一个裁剪空间顶点位置到gl_Position时，OpenGL会自动进行一个透视除法，将裁剪空间坐标范围的-w到w转换为-1到1。这要通过将x、y、z元素除以w元素来实现。 纹理采样时，纹理坐标是在每一个纹素的中心位置采样的。比如一张1024 * 768的纹理，如果传入的纹理坐标范围是0~1，那么采样最左下角的纹理坐标应该是（1/1024*0.5，1/768*0.5），它的右边的纹理坐标应该是（1/1024*1.5，1/768*1.5）。 片段坐标gl_FragCoord也是这样。 memset函数不能对数组置0和-1以外的值。 CPU上的结构体可以有构造函数，但是GPU上着色器里的结构体内不能有任何函数。想要对着色器里的结构体初始化，只能到CPU上进行。 如果前面有用过glActiveTexture()，那么后面绑定纹理时，也必须得用该函数激活对应的纹理单元，即使这时只有一个纹理要绑定（或者说要去采样）。如果前面激活了GL_TEXTURE0，且用完纹理后解绑了，那么后面绑定时可以再激活绑定到GL_TEXTURE0上；如果没有解绑，就得绑定到其他没用过的纹理单元上。 使用完纹理后，一定要记得立即解绑，否则可能出现很诡异的结果。 shader里的着色器缓冲对象SSBO和uniform缓冲对象UBO等等，有std140或者std430的修饰时，一定要注意字节对齐。 比如下面这个着色器里的缓冲对象SSBO： 12345678struct Light&#123; vec3 Position; //世界坐标 vec3 Color; float radius; //光体积半径&#125;;layout (std430, binding = 3) buffer LightsData&#123; Light lights[];&#125;; 因为buffer里的成员是结构体，而根据std140和std430的对齐规则，结构体对齐值应该是结构体内最大成员的对齐值，所有上面结构体Light的对齐值就应该是vec4，即16字节对齐（vec3需要按vec4算）。也就是说GPU每次是按16字节一起读的，所以为了值正确，我们需要把上述结构体改为： 123456struct Light&#123; vec3 Position; //世界坐标 float none; //用作16字节对齐 vec3 Color; float radius; //光体积半径&#125;; 或者： 12345struct Light&#123; vec4 Position; //世界坐标 vec3 Color; float radius; //光体积半径&#125;; 如果还是原来的Light结构体的话，读vec3类型的Position时，会一次直接读走32个字节（vec4），这样就把Position后面的Color的前4个字节读走了，导致Position和Color的值都不正确。所以我们可以把Position改成vec4，或者在它后面添加一个float，来补足16字节。后面vec3类型的Color和float类型的radius正好组成16字节，可以一次读走，每个成员数据在读的时候没有被中断而分成两半，所以这样读出来的值才是正确的。 使用glTexImage2D函数生成图片后一定要设置图片的过滤方式，否则图片不会显示。 实验证明，如果不使用glClear清除深度缓冲，OpenGL默认深度值是0.0。使用该函数清除了深度缓冲之后，才会将深度值设为1.0。所以如果一直不使用glClear(GL_DEPTH_BUFFER_BIT)，而且开启了深度测试，将会黑屏，画不出来任何东西，因为深度值是0.0，每个片段都无法通过深度测试。 如果在自定义的帧缓冲里有深度测试，一定要给自定义的帧缓冲绑定深度附件（渲染缓冲或者纹理附件都可以），否则深度测试无效。傻B又惨痛的教训~~ 某个变量在shader里没有被赋值给别的变量，那么它就不会被NSight显示出正确的值。想要看出它的正确值，只有把它再赋值给另一个变量了，观察另一个变量的值是多少。如下面的程序： 123for(int i = 0; i &lt; 5; i++)&#123; ...&#125; 在循环过程中，由于i没有被赋值给别的变量，所以NSight所显示出来的i值就一直是0，如果想看到i的值，可以加一行代码，如下： 1234for(int i = 0; i &lt; 5; i++)&#123; int j = i; ...&#125; 用NSight调试可以看到，i的值虽然一直都是0，但是j的值却会从0变到4。 这个结论不一定正确，只是经验之谈。不过却提供了一种调试的方法，当发现NSight给出的值明显不正确时（它可能给出的是0或者？？？等等），可以把它赋给另一个变量，就可以看到正确的值了。 GPU对于if-else的处理，并不像LearnOpenGL中（Deferred Shading那一节）讲得那样：为了GPU高度并行if分支和else分支都会被执行，执行完之后再回滚。做实验如下： 123456789101112 #version 430 core out vec4 color; void main()&#123; if(true)&#123; color=vec4(1,0,0,1); &#125; else&#123; while(true)&#123;&#125; &#125;&#125; 如果if和else分支都执行，那么程序将陷入死循环，但是实际运行结果是屏幕上会出现红色矩形（该着色器用于绘制一个矩形），说明else分支没有被执行。如果把程序改成如下，将会陷入死循环（实验的结果就是重启电脑吧！卡住了！）： 12345678910111213#version 430 coreout vec4 color;void main()&#123; if(true)&#123; while(true)&#123;&#125; color=vec4(1,0,0,1); &#125; else&#123; while(true)&#123;&#125; &#125;&#125; 自定义程序实现的前置深度测试：比如我们需要对一个模型进行很多很复杂的光照计算，为了不让被遮挡住的片元也去进行光照计算（因为被遮挡的片元颜色是不会显示出来的，它所进行的关照计算对最后的显示结果是多余的），我们可以采用延迟着色（Deferred Shading）或前向着色（forward shading）。延迟着色很好理解，而对于前向着色，为了不让被遮挡的片元也进行光照计算，我们也可以向延迟着色一样，把光照阶段剥离出来：先开启深度测试把模型绘制一遍，把深度值保存到深度纹理中，这样在深度纹理中的深度值就是模型最靠近摄像机的片元的深度值了（这是第一个pass）；接着我们再把模型绘制一遍，在这次绘制中，我们先在片元着色器里，判断当前片元的深度值是否大于深度纹理中对应位置的深度值，如果是则直接返回，不用再进行接下来的光照计算，否则照常进行光照计算，赋予片元光照下的颜色值： 1234567void main()&#123; if(gl_FragCoord.z &gt; texture(TexForDepth, vec2(gl_FragCoord.x/1024.0f, gl_FragCoord.y/768.0f)).r )&#123; return; &#125; //执行光照计算 ...&#125; 这样一来，就只有最后会被显示到窗口上的片元才会去执行光照计算，大大减少了光照计算的次数。 但是在实际运用中，按照上诉代码来实现前置深度测试，会出现如下图所示的抖动现象：这通常是由于计算机对浮点数精度表示的不准确而造成的，我们在条件判断的时候加上一个很小的误差就能解决这个问题了： 1234567void main()&#123; if(gl_FragCoord.z &gt; texture(TexForDepth, vec2(gl_FragCoord.x/1024.0f, gl_FragCoord.y/768.0f)).r + 0.00001)&#123; return; &#125; //执行光照计算 ...&#125; 结果如下： GLFW的回调函数：按键回调函数、鼠标位置回调函数、鼠标滚轮回调函数等等，都是在事件触发之后才会执行的。也就是说鼠标放在窗口里不动，是不会调用鼠标位置回调函数的。 类的私有构造函数是不会被执行的。比如单例模式中的私有构造函数。 在单例模式中，返回的实例对象最好是指针类型的，如果是直接返回静态的实例对象，那么在其他地方对返回的这个实例对象的修改是不会影响到原单例类的实例对象的： 1234567891011单例类A：static A getInstance()&#123; return m_Instance;&#125;void init()&#123; m_Count = 10;&#125;其他类B：A::getInstance().init();另一个类C：cout&lt;&lt;A::getInstance().m_Count&lt;&lt;endl; A只是返回了实例对象，而不是对象指针，也就是说B类中通过getInstance得到的对象和A类中的m_Instance不是同一个对象，所以即使在B类中对成员变量m_Count做了初始化，但是m_Instance是没有任何变化的，所以在C类里再去得到m_Instance实例对象的m_Count属性，输出将会是0。应该改为： 123static A* getInstance()&#123; return &amp;m_Instance;&#125; 可能出现黑屏的原因： 没有清空颜色缓冲，即没有使用glClearColor和glClear函数。 绘制时不在默认帧缓冲上。 用到了但是没有给着色器传入模型矩阵、观察矩阵和投影矩阵。 没有激活着色器程序 OpenGL默认使用glEnable(GL_MULTISAMPLE)开启多重采样，想要关闭多重采样，需要注释掉glfwWindowHint(windon, 4);，只使用glDisable(GL_MULTISAMPLE)是不够的。 复制帧缓冲时，如果帧缓冲上有多个纹理附件，需要使用glReadBuffer和glDrawBuffer函数指定附件来一个一个地复制： 12345678910111213141516171819glBindFramebuffer(GL_READ_FRAMEBUFFER, m_DeferredFBO);glReadBuffer(GL_COLOR_ATTACHMENT0);glBindFramebuffer(GL_DRAW_FRAMEBUFFER, m_CommonFBO);glDrawBuffer(GL_COLOR_ATTACHMENT0);glBlitFramebuffer(0, 0, WIDTH, HEIGHT, 0, 0, WIDTH, HEIGHT, GL_COLOR_BUFFER_BIT, GL_NEAREST);glBindFramebuffer(GL_READ_FRAMEBUFFER, m_DeferredFBO);glReadBuffer(GL_COLOR_ATTACHMENT1);glBindFramebuffer(GL_DRAW_FRAMEBUFFER, m_CommonFBO);glDrawBuffer(GL_COLOR_ATTACHMENT1);glBlitFramebuffer(0, 0, WIDTH, HEIGHT, 0, 0, WIDTH, HEIGHT, GL_COLOR_BUFFER_BIT, GL_NEAREST);glBindFramebuffer(GL_READ_FRAMEBUFFER, m_DeferredFBO);glReadBuffer(GL_COLOR_ATTACHMENT2);glBindFramebuffer(GL_DRAW_FRAMEBUFFER, m_CommonFBO);glDrawBuffer(GL_COLOR_ATTACHMENT2);glBlitFramebuffer(0, 0, WIDTH, HEIGHT, 0, 0, WIDTH, HEIGHT, GL_COLOR_BUFFER_BIT, GL_NEAREST);glBindFramebuffer(GL_FRAMEBUFFER, 0); 运行时屏幕上出现分块的原因： 没有清空存储影响光源编号的SSBO缓存。 取影响光源编号时，不能根据是否等于-1（没有存储编号时的默认值）来判断是否终止取光源操作。因为对于数组tiles[768][100]，若tiles[2]中都存满了，即tiles[2][99]都是有值不等于-1的，那么会继续去取tiles[2][100]，这时其实取的是tiles[3][0]，即取到了下一个分块的影响光源编号，导致第2个分块的影响光源多算了，出现明显的分块现象。 存储分块影响光源编号的内存空间太小。]]></content>
      <categories>
        <category>毕设</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[项目中遇到的C++特性问题]]></title>
    <url>%2F2017%2F05%2F09%2FC%2B%2B%E7%89%B9%E6%80%A7%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[多态使用基类实现多态时，是使用基类指针，而不是基类对象：123456789101112131415class A&#123; virtual print()&#123; cout &lt;&lt; "A" &lt;&lt;endl; &#125;&#125;;class B : public A&#123; print()&#123; cout &lt;&lt; "B" &lt;&lt;endl; &#125;&#125;;int main()&#123; A a = B(); a.print(); return 0;&#125; 上面程序输出结果将是B，并没有实现多态。这是因为定义的是基类A的对象，将B对象赋值给它，只会赋值成员变量，并不会将成员函数也一起赋值给它，所以对象a还是使用的A类的print函数。但是改为：1A* a = &amp;B(); a将指向B对象地址，再调用print函数时，执行的将是B类的print函数。&nbsp; C++数组越界问题如下代码：123int c[5];c[7] = 123;cout &lt;&lt; c[7] &lt;&lt; endl; 在运行过程中编译器是不会报数组越界的错误的，这是因为c[7]的地址很可能还在程序栈空间中，如果是访问c[1000]就会出现数组越界的错误，因为c[1000]的地址可能已经超出了程序栈空间，非法访问其它地址。 不过在GLSL里面编译时是会出现数组越界错误的。但是下面这样GLSL也不会报错：123int c[5];int i = 7;c[i] = 123; 因为i是变量，在编译时无法确定它的值，所以不会报错，在运行时无论i多大glsl都不会报错。 如果定义int a[3][4];，那么a[1][4]其实是等于a[2][0]。 纯虚基类（抽象类）里的私有成员变量 为了程序更好的设计风格和可修改性，应该尽量把类里的成员变量声明为私有的。对于纯虚基类也是如此，代码示例如下：1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;using namespace std;class A &#123;private: int m_N;public: virtual void draw() = 0; A() &#123; m_N = 400; &#125; int getN() &#123; return m_N; &#125;&#125;;class B : public A &#123;public: void draw() &#123; &#125; void print() &#123; cout &lt;&lt; getN() &lt;&lt; endl; &#125;&#125;;int main() &#123; B b; b.print(); return 0;&#125; 运行结果如下：1400 虚基类里的成员变量也应该是私有的，虽然无法被子类继承，但是公有的成员函数是可以继承的，子类可以通过继承自虚基类的getN函数，来间接访问虚基类的私有成员变量。 值得注意的是继承自父类的成员函数，是可以访问父类的私有成员变量的。 成员函数中用本类对象作为参数 如果在类的成员函数里，其参数是本类对象，那么在函数内部可以通过对象名.的方式来直接访问私有成员变量：1234567891011class A &#123;private: int n;public: A() &#123; n = 100; &#125; int add(A a) &#123; return n + a.n; &#125;&#125;; 上面的代码是可以正常工作的，形参a可以直接用a.n来访问其私有成员变量。 但是参数如果是别的类的对象，就没有访问权限了：1234567891011121314151617181920class B &#123;private: int m;public: B() &#123; m = 200; &#125;&#125;;class A &#123;private: int n;public: A() &#123; n = 100; &#125; int add(B b) &#123; return n + b.m; &#125;&#125;; 上面的代码会报错：B::m不可访问。 值得注意的是如果函数是处于类内部的友元函数（虽然它不是类的成员函数），也是可以直接访问到本类的私有成员变量的。这在重载运算符中有实际应用：12345678910class CShape &#123;private: int priority;public: friend bool operator&lt;(const CShape&amp; iShape1, const CShape&amp; iShape2);&#125;bool operator&lt;(const CShape&amp; iShape1, const CShape&amp; iShape2) &#123; return iShape1.priority &lt; iShape2.priority;&#125; 上面的代码用友元函数重载了&lt;运算符，函数里可以直接通过对象名访问到其所在类的私有成员变量。 多态分配内存的对象指针在实现多态时，需要用到基类指针，如果需要为基类指针用new动态分配内存，可以使用指向指针的指针：1234CShape **shapes = new CShape*[3];shapes[0] = new CQuad();shapes[1] = new CCircle();shapes[2] = new CTriangle(); 其中CShape是基类，CQuad、CCircle、CTriangle都是其子类。值得注意的是，new运算符返回的是指针，所以shapes[0]也应该是一个指针。如果用CShape *shapes = new CShape[3];，那么shapes[0]将会是一个CShape对象，这很好理解，和下述代码一样：12int *array = new int[3];array[0] = 10; 其中array[0]就是一个整型，而非指针，同理上面的shapes[0]也是对象，而非指针。但是如果想要shapes[0]代表一个指针的话，就得将等号右边的new CShape[3]改为new CShape*[3]，等号左边改为指向指针的指针，*shapes表示一个CShape对象，**shapes才表示指向CShape对象的指针。]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++特性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[项目中遇到的C++编译链接错误]]></title>
    <url>%2F2017%2F05%2F09%2FC%2B%2B%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[编译时出现重定义，可参考这篇文章 链接时出现LINK1120：无法解析的外部符号，这种情况通常都是没有包含对应的库文件，或者库文件没有包含正确。库文件包括.lib和.dll。 链接过程中出现读取访问冲突，很可能是空指针造成的。如果是在调用OpenGL函数的时候出现该问题，无法访问某个地址，则很有可能是在初始化GLEW之前就调用了该函数。要知道没有初始化GLEW，有可能某些OpenGL函数是无法使用的（版本问题）。 使用静态成员变量时出现无法解析的外部符号：原因是静态成员变量必须在类外进行初始化，否则的话是不会给它们分配内存空间的。 c++对bool变量的默认值是没有规定的，根据编译器不同，可能默认是true，也可能是false，应该自己显示对bool变量赋初始值，不要让编译来决定。 如下代码： 123456test1.h:#pragma once#include "test2.h"class A &#123;&#125;; 1234test1.cpp:#include "test1.h"int n = 10; 1234567891011test2.h:#pragma once#include "test1.h"#include &lt;iostream&gt;extern int n;class B &#123;public: void draw() &#123; std::cout &lt;&lt; n &lt;&lt; std::endl; &#125;&#125;; 程序时可以正常编译通过的，输出10。但是下面的程序却无法通过： 1234test1.cpp:#include "test1.h"A a; 12345678910test2.h:#pragma once#include "test1.h"#include &lt;iostream&gt;extern A a;class B &#123;public: void draw() &#123; &#125;&#125;; 编译报错：C4430 缺少类型说明符 - 假定为 int。注意: C++ 不支持默认int。 这是因为C++头文件加载的顺序是不定的，有可能在加载test2之前，test1就已经加载好了，那么#include “test1.h”这句将不再起作用，由于test1.h和test2.h是两个独立的编译单元，test2又没有去加载test1，导致test2中无法识别类A，出现上诉错误。但是前面用int n是不报错的，因为int是系统基础类型，肯定认识它。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>编译链接错误</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C测试笔记]]></title>
    <url>%2F2017%2F04%2F19%2FC%E6%B5%8B%E8%AF%95%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[C语言中默认没有bool类型。需要加上stdbool.h头文件以后才能使用bool类型。 符号常量（用define定义的）和变量不同，符号常量是不占内存的，只是一个临时符号，预编译后这个符号就不存在了。 变量名实际上是以一个名字代表的一个存储地址。编译链接时，编译系统会给每一个变量名分配对应的内存地址。 常变量（用const定义的）和常量不同，常变量具有变量的基本属性，有类型，占存储单元，而常量只是一个数，没有名字不占内存。 编码中常用的字符’1’、’A’等等，在内存中是以ASCII码存储的，占一个字节。字符’1’和整数1是不同的，整数1是以整数存储方式（二进制补码）存储的，占4个字节。例如： 1234char c = '1';printf("%d",c);char a = 1;printf("%d",a); 输出结果是49和1。 字符型char也有signed和unsigned。 表达式如下： 1printf("%7.2f\n",12.345678f); 输出结果如下： 112.35 整数部分12前面还有两个空格，%7.2表示输出结果总共占7列（包括小数点），保留两位小数并且会有四舍五入。 c语言中没有string类型，但是却可以使用strlen、’strcpy’等字符串函数： 123456789#include &lt;stdio.h&gt;int main() &#123; char str[4] = "acd"; char str1[4]; strcpy(str1,str); printf("%d\n",strlen(str)); printf("%s",str1); return 0;&#125; 输出结果是： 123adc 注意上面字符数组str的长度是4，这样赋值后C语言会自动在末尾添加一个\0。末尾有’\0’的字符数组才相当于字符串，才可以使用这些字符串函数。如果把str数组的长度改为3，是得不到正确结果的： 12char str[3] = "acd"; //不能正常使用字符串函数char str[] = "acd"; //可以正常使用字符串函数 使用这些字符串函数时不需要加额外的头文件。 float型小数只能保证6位有效数字，double型小数只能保证15位有效数字。 printf(&quot;%-10.6f&quot;, a);是左对齐的，不足的列数在右端用空格补齐；printf(&quot;%10.6f&quot;, a);是右对齐的，不足的列数在左端用空格补齐。 指数格式输出： 1printf("%e\n", 123.456); 输出结果是： 11.234560e+002 如果想输出‘%’，应该使用两个’%’： 1printf("%%"); 如果是scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);，则应该像这样输入1 2 3，以空格或者回车来分隔每个输入的数据。但如果是scanf(&quot;%d,%d,%d&quot;, &amp;a, &amp;b, &amp;c);，则需要像这样输入1,2,3，需要加上逗号。 C语言中求log_10 x 的函数是log10，也有log函数，不过它求的是lnx。 求最大公约数的核心思想：对于辗转相除法（欧几里德算法），核心点在于m、n和m%n的最大公约数是相等的，一直除余到0后，得到的除数或者说被除数就是最大公约数： 1234567891011121314int gcd(int m,int n)&#123; if(m&lt;n)&#123; int t; t=m; m=n; n=t; &#125; while(m%n!=0)&#123; int k=n; n=m%n; m=k; &#125; return n;&#125; 对于更相减损法，核心点在于m、n和m-n的最大公约数是相等的，一直相减到差是0后，得到的减数或者说被减数就是最大公约数： 1234567891011121314151617181920int gcd(int m,int n)&#123; if(m&lt;n)&#123; int t; t=m; m=n; n=t; &#125; int k; while((k=m-n)!=0)&#123; if(k&gt;n)&#123; m=k; &#125; else&#123; m=n; n=k; &#125; &#125; return m;&#125; 仔细想一想，其实辗转相除法和更相减损法的核心思想是一样的，更相减损法是两个数和它们的差的公约数相等，辗转相除法不过是多做了几次差变成了余数而已。 最小公倍数就是两个数的成绩除以最大公约数。 虽然通常情况下不能定义数组的大小为变量，即a[n]是非法的，只能是a[10]这种的；但是在自定义函数中，如果数组大小n是函数的参数，那么a[n]是合法的： 12345678910111213141516171819 #include &lt;stdio.h&gt; void func(int n); int main() &#123; int n = 10; func(n); return 0; &#125; void func(int n) &#123; int a[n]; int i; for (i = 0; i&lt;n; i++) &#123; a[i] = i; &#125; for (i = 0; i&lt;n; i++) &#123; printf("%d ", a[i]); &#125;&#125; 输出结果是： 10 1 2 3 4 5 6 7 8 9 如下程序： 1234567891011 #include &lt;stdio.h&gt; int main() &#123; char a[]=&#123;'i',' ','a','m',' ','a',' ','b','o','y'&#125;; char b[]=&#123;'i',' ','a','m',' ','a',' ','b','o','y','\0'&#125;; char c[]="i am a boy"; printf("%s\n",a); printf("%s\n",b); printf("%s\n",c); return 0;&#125; 输出结果是： 123i am a boy?@i am a boyi am a boy 说明使用{ }对字符数组赋值时，系统不会自动在末尾加’\0’，而使用” “的形式对字符数组赋值时，系统会自动在末尾加’\0’。末尾有’\0’的字符数组才相当于字符串。 一次输入多个字符串时，以空格分隔开： 12char str1[5],str2[5],str3[5];scanf("%s%s%s",str1,str2,str3); 输入是应该像下面这样： 1How are you? 如果只定义了一个char str[15]; scanf(&quot;%s&quot;,str);，如果还是像上面那样输入，因为是以空格作为字符串分隔标志的，所以传入str的就只有How。 字符串输入函数gets(str);可以接受字符串中有空格。 strncpy(str1, str2, n);表示用字符串str2的前n个字符复制到str1中，取代str1的前n个字符。如下面的程序： 1234char str1[]="i am a boy"; char str2[]="she is"; strncpy(str1,str2,6); printf("%s\n",str1); 输出结果是： 1she is boy 将字符串转换为小写的函数：strlwr(str)。将字符串转化为大写的函数：strupr(str)。注意它们的返回类型是void。 魔方阵：各行、各列、对角线的和都相等的n*n矩阵（矩阵元素是从1到n*n）。注意偶数阶（n为偶数）的魔方阵是不存在的。 求解魔方阵的算法如下： 把1放在第一行的中间位置 从2开始直到n*n的数，准备放在前一个数的右上角（行减1，列加1）。如果行减到小于0，则行变为n-1，如果列加到大于n-1，则列变为0。 如果要放置的位置已经被占了，则把这个数直接放在上一个数的下面（行加1，列不变）。 实现代码如下： 1234567891011121314151617181920212223242526272829303132333435void MagicMatrix(int n)&#123; //n不要大于10 if(n%2==0)&#123; printf("not!\n"); return; &#125; int a[10][10]=&#123;0&#125;; int i,j; int k=n/2; int col=k,row=0; int lastRow,lastCol; a[0][k]=1; for(i=2;i&lt;=n*n;i++)&#123; lastRow=row; lastCol=col; col++; if(col&gt;n-1) col=0; row--; if(row&lt;0) row=n-1; if(a[row][col]==0) a[row][col]=i; else&#123; row = lastRow+1; col = lastCol; a[row][col]=i; &#125; &#125; for(i=0;i&lt;n;i++)&#123; for(j=0;j&lt;n;j++)&#123; printf("%d ",a[i][j]); &#125; printf("\n"); &#125; &#125; C语言中memset函数的头文件是string.h。 汉诺塔问题：A塔上有64个盘子，大的在下，小的在上，还有两座空的B塔和C塔。每次只移动一个盘子，而且移动过程中所有塔都是大盘在下，小盘在上，要求把A盘上的64个盘子移到C盘。 分析：这是一个递归问题。 要从A移动n个盘子到C，需要先把n-1个盘子移动到B， 然后把A最下面的大盘子移动到C， 再把B上的n-1个盘子移动到C。 移动n-1个盘子，这就是递归问题。只不过是从哪个盘子移动到哪个盘子变了而已，第二步是从A移动到C，第三步是从B移动到C，这个我们在递归调用的时候调整一下参数顺序就ok了。 代码实现如下： 1234567891011121314151617#include &lt;stdio.h&gt;void Hanoi(int n,char one,char two,char three);int main() &#123; Hanoi(3,'A','B','C'); return 0;&#125;void Hanoi(int n,char one,char two,char three)&#123; if(n==1)&#123; printf("%c-&gt;%c\n",one,three); return; &#125; Hanoi(n-1,one,three,two); printf("%c-&gt;%c\n",one,three); Hanoi(n-1,two,one,three);&#125; 输出结果如下： 1234567A-&gt;CA-&gt;BC-&gt;BA-&gt;CB-&gt;AB-&gt;CA-&gt;C C语言变量存储类别有4种：自动的（auto）、静态的（static）、寄存器的（ register）、外部的（extern）。 静态局部变量（在函数中定义的static变量）是在编译时赋初值的，即只赋值一次，以后每次调用函数时不再重新赋初值，而是保留上一次函数调用结束后的值。如果不对静态局部变量赋初值，编译时会自动赋为0或者空字符\0，但是如果不对自动变量赋初值，它的值就会是不确定的。因为静态局部变量是存放在静态存储区的，程序执行过程中不会改变位置，而自动变量是存放在动态存储区的，在每次函数结束后都会释放存储单元，下次调用时又重新分配存储单元，而所分配的存储单元中的内容是不可知的。 寄存器变量使用register声明的变量，如下： 1register int i; 寄存器变量用于存储那些使用非常频繁的变量，比如在10000次循环中每次都要用到的变量。其实现在的编译系统通常都能识别使用频繁的变量，从而自动把这些变量放到寄存器里，不需要程序设计者指定。所以用register声明变量的必要性不大。 extern外部变量：其实用extern声明的外部变量是强制把变量的作用域扩大了。比如在同一个文件中，变量在后面声明的，但是在前面就想要用到这个变量，那么可以在用这个变量时，使用extern声明一下这个变量，把它的作用域扩展到此声明处。如下： 12345678910int main()&#123; extern int A,B,C; ...&#125;int A,B,C;int max(int a, int b)&#123; ...&#125; 还可以使用extern把全局变量的作用域扩展到另一个文件：比如在一个程序文件中声明了全局变量Num，在另一个程序文件里也想使用这个变量，那么可以在另一文件中用extern对Num扩大作用域，即extern Num;。在编译连接时，系统会由此知道Num有外部链接，就会从别的文件找到已定义的Num变量，并把作用域扩展到本文件。 把全局变量的作用域强制限制在本文件，可以使用static关键字声明。这样有利于不同文件独立，即使在不同文件中定义了同名的全局变量，甚至使用了extern关键字，都会互不影响。 注意对于全局变量来说，无论是否用static关键字声明，它都是存储在静态存储区的，这一点和局部变量不同： 对局部变量用static关键字声明，会把它分配在静态存储区，该变量在整个程序执行期间不释放其存储单元，知道程序结束。 对全局变量用static声明，是限制该变量的作用域只限于本文件模块（即被声明的文件中）。 【注】：全局变量是指在函数外部定义的变量，不一定是在文件开头处定义的外部变量。也就是说这里的全局变量就是外部变量。 在函数定义时用static声明，是把该函数作为静态函数，限制在本文件中使用，如果在函数定义时用extern声明，则该函数可以在其他文件中使用，在其他文件中使用时需要先用extern声明该函数，表示该函数是在其他文件中定义的。其实在C语言中可以省写extern，因为函数在本质上就是外部的。可以知道，函数原型声明其实就是扩大函数的作用域（到本文件的该函数前面区域，甚至扩大到其他文件都可以）。函数原型会通知编译系统，该函数在本文件稍后定义，或在另一文件中定义。利用函数原型扩展函数作用域最常见的例子就是#include &lt;....h&gt;，因为通常在 #include指定的头文件中包含了很多函数原型，以此来扩展函数作用域到本文件。 变量名其实就是地址的别名，可以通过变量名直接访问到对应地址中的内容；而指针是另一个变量，它存储着别的变量所对应的地址，访问时，指针变量会根据自己对应的地址去取出地址里的内容，而这个内容就是另一个变量的地址，再根据取出来的这个地址，就可以去访问另一个变量里存储的内容了。总之，通常所说的指针是一个存储着别人的地址的变量。 如果指针是字符型的，那么指针加1，是使它存储的地址值加1；如果是整型的，那么指针加1，是使它存储的地址值加4。 指针运算符*和自加运算符++是同等优先级的，所以*p++等价于*(p++)，都是先取*p，再使p加1。*(++p)是先使p加1，再取*。 对于二维数组a[m][n]来说，a表示首行（第0行）的首地址，a+1表示第1行的首地址，就是指向a[1]，和&amp;a[1]等价。注意对于二维数组来说，a[i]只是第i行的首地址，是个指针，a[i]和*(a+i)等价，a[i][j]和*(*(a+i)+j)等价。要表示二维数组中某个元素的值，应该是两层指针*。还有，&amp;a[0]与a等价，都是指向第0行的，a[0]是指向第0行第0列的；&amp;a[1]与a+1等价，都是指向第1行的。总之a、a+i等是二维指针，有两个**，a[0]等是一维指针，有1个*。如下面的程序： 1234int a[2][2]=&#123;0&#125;;printf("%d\n",a);printf("%d\n",*a);printf("%d\n",**a); 输出结果如下： 123268672026867200 可以使用指针指向的字符串来代替printf函数中的格式字符串： 123char* format;format = "a=%d,b=%f\n";printf(format,a,b); 它相当于： 1printf("a=%d,b=%f\n",a,b); 只要改变format所指向的字符串，就可以改变输入输出的格式，这种printf称为可变格式输出函数。当然用字符数组代替上面的指针也是可以的。 函数指针：指向函数代码存储空间首地址的指针。如下： 1int (*p)(int,int); 这个p就是指向函数的指针变量，它可以指向函数类型为int且有两个int型参数的函数。除了用函数名来调用函数，我们还可以通过函数指针来调用函数： 1234567891011121314#include &lt;stdio.h&gt;int max(int a,int b);int main() &#123; int a=1,b=2; int(*p)(int,int); p=max; printf("max is %d\n",(*p)(a,b)); return 0;&#125;int max(int a,int b)&#123; return a&gt;b?a:b;&#125; 其实就是用函数指针*p代替了函数名max而已。 函数指针可以作为其他函数的参数，这样在不同情况下通过传入不同的实参，就能实现调用不同的函数。 int *p[4]和int (*p)[4]是不一样的，前者是指针数组（有4个指针的数组），后者是指向一维数组的指针变量。 带参数的main函数： 123int main(int argc, char* argv[])&#123; ...&#125; main函数也是可以带有参数的，argc是argument count的缩写，表示参数个数，argv是argument vector的缩写，是一个char*指针数组，数组中的每一个元素指向命令行中的一个字符串。由于main函数是有操作系统调用的，所以它的参数也是由操作系统提供。通常在命令行状态下，我们可以通过类似DOS界面给main函数指定参数。在DOS下的命令行一般形式是： 1可执行文件名 参数1 参数2......参数n 它们之间用空格分开。可执行文件里应该包含main函数，且实际上应该还要包含文件路径。如果我们给出的命令行像这样： 1file1 China Beijing main函数像这样： 12345678int main(int argc, char* argv[])&#123; while(argc&gt;1)&#123; ++argv; printf("%s\n",argv); --argc; &#125; return 0;&#125; 执行程序后会输出如下： 12ChinaBeijing C语言里的动态分配内存相关函数（声明在stdlib.h头文件中）： malloc函数：函数原型是：void* malloc(unsigned int size);，用于在内存的动态存储区中分配一个长度为size字节的连续空间。 calloc函数：函数原型是：void* calloc(unsigned n, unsigned size);，用于在内存的动态存储区分配n个长度为size字节的连续空间。例如：p=calloc(50,4);。 free函数：函数原型是：void free(void* p);，用于释放指针变量p所指向的动态空间。 realloc函数：函数原型是：void* realloc(void* p, unsigned int size);，用于改变指针p所指向的动态空间的大小为size字节。 约瑟夫环：n个人围成一圈，从任意某个人从1开始报数，报到第m个的人拖出去，剩下的人接着从1开始报数，报到第m个的人再拖出去，……，如此循环，问最后一个人是原来的第几个人。该问题可用数学方法解决，也可用循环链表实现。 下面的程序是正确的： 1234int* p; p=malloc(sizeof(int)); p[2]=200; printf("%d\n",p[2]); 但是如果把第二行去掉，会报错，这是因为没有指明指针p指向哪个位置，p[2]是无意义的。 使用union声明的共用体，它里面的所有成员都是从同一个位置开始存放的（覆盖技术）。每一瞬间只能存放一个成员。 用typedef声明新类型名： 123456789101112131415161718192021222324252627282930313233typedef int Interger; //指定用Integer为类型名，作用与int相同``` 45. 文件分为ASCII文件和二进制文件。比如整数10000，用ASCII码存储到文件时，占用5个字节；而以二进制形式存储到文件时，只占用4个字节。46. C语言使用`File* fopen(文件名，文件打开方式);`来打开文件；使用`int fclose(File*)`来关闭文件；使用`char fgetc(File*)`来从文件读取一个字符，使用`char fputc(char, File*)`来把一个字符写入到文件。使用`char* fgets(char* str, int n, File* fp) `来从文件读取n-1个字符到str字符串中（末尾加'\0'）。使用`int fputs(str, fp)`来把字符串输出到文件。 例如，从一个文件中读取数据写入到另一个文件中：```c++ #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() &#123; FILE *fin,*fout; char ch; fin=fopen("test1.txt","r"); if(fin==NULL)&#123; printf("open file1 failed!\n"); &#125; fout=fopen("test2.txt","w"); if(fout==NULL)&#123; printf("open file2 failed\n"); &#125; while(!feof(fin))&#123; ch=fgetc(fin); fputc(ch,fout); &#125; fclose(fin); fclose(fout); return 0; &#125; 上面是对文件以字符的形式进行输入输出，还可以格式化的方式读写文件： fprintf函数： 1fprintf(fout, "%d%f", i, f); fscanf函数： 1fscanf(fin, "%d%f", &amp;i, &amp;f); 由于fprintf函数在输出时要将内存中的二进制转换为字符，fscanf函数在输入时要将文件中的ASCII码字符转换为二进制在保存到内存变量中，这种转换要花费很多时间，所以我们通常使用fread和fwrite函数来代替他俩进行二进制的读写。 fread函数一次从文件中读取一个数据块，fwrite函数向文件写一个数据块。它们都是以二进制形式进行读写的。 fread函数原型：fread(buffer, size, count, fp);buffer是存储从文件读出的数据的内存起始地址，size是每个数据项的字节数，count要读取的数据项个数，fp是文件指针。 fwrite函数原型：fwrite(buffer, size, count, fp);buffer是准备写入文件的内存数据的内存起始地址，size、count、fp同上。 更改文件读写位置的相关函数： void rewind(FILE* fp)函数：强制将文件读写位置更改为文件开头。 fseek函数：函数原型是：fseek(文件指针，位移量，起始点);起始点有0、1、2三个选项，0表示文件开头，1表示当前位置，2表示文件末尾。位移量是以起始点为基准，向前移动的字节数。注意位移量数据类型是long型。例如： 1fseek(fp, 100L, 0); long ftell(FILE* p)函数：读出当前的文件读写位置。返回的是当前位置相对于文件开头的位移量。 牛顿迭代法求方程f(x)=0的根，实际上是从估计值x0开始，不断对fx切线方程，该切线与x轴（y=0）的交点x1会比x0更加精确（更容易使得f(x)=0），然后以x2求fx的切线，得到与x轴的交点x3…直到前后两次交点的差值满足一定的精度（小于某个值）。 long类型通常是4个字节。]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++里XXX重定义]]></title>
    <url>%2F2017%2F03%2F15%2FC%2B%2B%E9%87%8D%E5%AE%9A%E4%B9%89%2F</url>
    <content type="text"><![CDATA[有时候我们编译工程会出现重定义的编译错误，在同一个源文件里定义两个相同的变量就不说了，这是最低级的错误。我们来说一下其他可能造成重定义的原因和解决办法。 没有在头文件最前面加#pragma once：如果我们在同一个文件中包含了某个头文件两次：12#include "A.h"#include "A.h" 那么在A里面定义的变量就会出现重定义的错误。 我们在某个文件中包含了A.h和B.h，但是在B.h里面也包含了A.h，那么就会造成A.h里面变量的重定义。 这种重复包含头文件，就会造成头文件被重复编译，出现重定义的编译错误。即使没有出现重定义的错误，但是这样重复编译头文件，也会使编译效率低下。一个解决办法是在头文件前面加上#pragma once，它的意思是让该头文件只编译一次。 但是如果在不同的头文件中定义了相同的类型，即使是加上了#pragma once，也会出现重定义。如下：1234567891011121314----A.h文件：-----#pragma onceint A; //全局变量----B.h文件：-----#pragma onceint A; //同样的全局变量----主程序：------#include "A.h"#include "B.h"int main() &#123; return 0;&#125; 还有一种会出现重定义的可能是在映射虚拟盘的时候，可参考这篇文章。 其实避免上述重定义的最好解决办法是使用#ifndef/#define/#endif，以这样的方式来保证头文件里的相同内容只被编译一次：1234567891011121314151617181920----A.h文件：-----#ifndef A_H#define A_Hint A; //全局变量...#endif // !A_H----B.h文件：-----#ifndef A_H#define A_Hint A; //同样的全局变量...#endif // !A_H----主程序：------#include "A.h"#include "B.h"int main() &#123; return 0;&#125; 这样int A就不会被多次编译了。要实现整个头文件只被编译一次（代替#pragma once的作用），可以这样做（把原来的整个头文件放在#define 和#endif的中间）：123456789//#pragma once#ifndef A_H#define A_Hclass A &#123; ...&#125;;#endif // !A_H 使用#ifndef虽然比较古老，但是却有很好的稳定性和可移植性。&nbsp; 参考文献：http://www.cnblogs.com/baiyanhuang/archive/2009/09/17/1730732.htmlhttp://blog.csdn.net/abc5382334/article/details/18052757]]></content>
      <categories>
        <category>调试错误集锦</category>
      </categories>
      <tags>
        <tag>重定义错误</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenGL25：反走样初步]]></title>
    <url>%2F2017%2F03%2F09%2FOpenGL25%E5%8F%8D%E8%B5%B0%E6%A0%B7%E5%88%9D%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[锯齿效果 在我们的渲染中，可能会遇到模型边缘有锯齿的问题。锯齿边出现的原因是由顶点数据像素化成为片段的方式引起的。比如直线上的点是连续的，而屏幕上的像素却是离散的，用屏幕上的像素来近似表示直线段，必然会出现锯齿效果（可参考《基本光栅图形生成技术》一文中的直线扫描转换）。 下面是一个简单的立方体，可以看到它有锯齿边的效果：放大后会更明显：很明显能看到边是由像素所构成的，这种现象叫做走样（Aliasing）。有很多技术能够减少走样，产生更平滑的边缘，这些技术叫做抗锯齿技术（Anti-aliasing，也被称为反走样技术）。&nbsp; 超级采样抗锯齿技术超级采样反走样技术（Super-Sampled Anti-Aliasing，SSAA），是通过以更高的分辨率来采样图形，然后再显示在低分辨率的设备上，从而减少失真的方法。例如下图表示了增加分辨率后，绘制直线的差别：通过将高分辨率的图形，显示在低分辨率的设备上，确实能有效减轻走样现象，但是存在的弊端就是：要为这些多出来的像素，进行更多的计算，并且内存开销很大。这是一种比较传统的方法。&nbsp; 多重采样抗锯齿技术多重采样抗锯齿技术（Multi-Sampled Anti-Aliasing，MSAA）是对SSAA的改进，改进之处在于执行像素着色器的次数并没有明显增加，对边缘部分却进行了很好的反走样。多采样相对于单采样，单采样在一个像素上，以像素中心为标准，当光栅化时，如果这个中心采样点在图元内部，那么就生成这个像素对应的片段，否则如果采样点不在图元内部，那么就不生成对应片段。而多采样，是在每个像素上进行细分，在每个像素上分出更多的子采样点（sub-sample），如下图所示：当图元覆盖了像素中的子采样点时，则会执行像素着色器。像素着色器的执行不是以子采样点为单位，也就是说不管有多少个子采样点，这个像素只执行一次像素着色器。执行的结果会存储到每个被覆盖的子样本中（没有被覆盖的子样本还是保持背景色）。最终的像素颜色将取为像素里这些子采样点颜色的平均值。 例如上图中，三角形图元覆盖了某个像素中的2个采样点，那么这个像素的最终颜色由三角形覆盖的2个采样点的颜色和另外两个采样点的颜色（可能是glClearColor指定的颜色）的均值决定。 下图是单采样对应的光栅化过程：下图是多采样对应的光栅化过程：用过多采样，绘制的三角形的边缘部分，因为有了和背景颜色的混合，从而减轻了走样现象，如下图所示：开启MSAA以后，不仅颜色会多采样，深度和模板测试也同样会多采样，每个子样本都会去存储颜色值、深度值和模板值。也就是说所需要的颜色、深度和模板缓冲大小都会增加。&nbsp; 在OpenGL中使用MSAA为了在OpenGL中使用MSAA，我们需要一个更大的缓冲来存储多采样点的采样结果，称之为多样本缓冲。 我们所使用的GLFW窗口系统就给我们提供了这个多样本缓冲，来代替默认的颜色缓冲。我们需要用glfwWindowHint来设置：1glfwWindowHint(GLFW_SAMPLES, 4); 它会告诉OpenGL。每个像素使用一个包含4个子样本的颜色缓冲。 接下来我们需要使用glEnable函数来开启多采样：1glEnable(GL_MULTISAMPLE); 由于实际的多采样算法在OpenGL驱动光栅化里已经实现了，所以我们不需要做别的了。运行效果如下：可以看到还是有很明显的抗锯齿效果的。 直接使用glEnable开启多采样，实现反正样的源码请看这里。 离屏MSAA 有的时候需要让MSAA的效果渲染到我们自定义的帧缓冲中。 我们首先为自定义的帧缓冲创建多采样纹理，来存储多采样结果。 多采样纹理附件创建多采样纹理和普通纹理的不同之处在于，使用glTexImage2DMultisample函数来代替glTexImage2D，而且纹理目标得改为GL_TEXTURE_2D_MULTISAMPLE：123456789glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, tex);glTexImage2DMultisample(GL_TEXTURE_2D_MULTISAMPLE, samples, GL_RGB, width, height, GL_TRUE);glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, 0);``` 第二个参数samples是我们打算让纹理拥有的样本数。最后一个参数设置为`GL_TRUE`，可以让图像上的每一个纹理像素使用相同的样本位置，以及同样的子样本数量。创建好多采样纹理后，我们还是使用`glFramebufferTexture2D`函数来把它附加到帧缓冲上，不过纹理类型改为`GL_TEXTURE_2D_MULTISAMPLE`：```c++glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D_MULTISAMPLE, tex, 0); 多采样渲染缓冲对象附件除了多采样纹理附件外，我们还可以使用渲染缓冲对象rbo。跟以前不同的是，在为渲染缓冲分配内存的时候，要将glRenderbufferStorage改为glRenderbufferStorageMultisample：1glRenderbufferStorageMultisample(GL_RENDERBUFFER, 4, GL_DEPTH24_STENCIL8, width, height); 注意上面的4就是我们设置的样本数量。 渲染到多采样帧缓冲绑定我们自定义的帧缓冲以后，正常绘制就能把颜色、深度、模板等信息写入多采样帧缓冲。但是多采样缓冲有点特别，不能直接使用渲染得到的缓冲图像，比如在着色器中进行采样作后处理。 这是因为多采样图像包含了比普通图像更多的信息，我们需要压缩（或还原）图像。通常用glBlitFramebuffer函数来还原多采样帧缓冲，它会从一个帧缓冲中复制一个区域粘贴到另一个帧缓冲里，同时会将多采样缓冲还原。 glBlitFramebuffer函数把一个4屏幕坐标源区域传递到另一个也是4空间坐标的目标区域。在这之前，我们需要先设置读缓冲区（源区域）和写缓冲区（目标区域）：123glBindFramebuffer(GL_READ_FRAMEBUFFER, multisampledFBO);glBindFramebuffer(GL_DRAW_FRAMEBUFFER, 0);glBlitFramebuffer(0, 0, width, height, 0, 0, width, height, GL_COLOR_BUFFER_BIT, GL_NEAREST); 编译运行后，我们将得到和之前一样的结果，边缘锯齿明显减少了：【注】： 渲染到自定义的帧缓冲时，不需要使用glfwWindowHint和开启反走样。因为在指定缓冲附件的时候，我们已经指明了使用多采样缓冲附件。 渲染到自定义帧缓冲的反走样源码（不用开启OpenGL的反走样）在这里。 多采样纹理转换为普通2D纹理 上面我们把多采样缓冲还原到默认缓冲了，可以正常渲染出MSAA效果。但是如果我们不想还原到默认缓冲，需要继续做后处理怎么办？原理其实一样的，我们就不还原到默认缓冲，而是还原到另一个自定义的帧缓冲，只是这次的帧缓冲使用正常的缓冲附件，而非多采样缓冲附件。伪代码如下：1234567891011121314151617181920212223242526//创建多采样的fboGLuint msFBO;...//创建正常的fboGLuint intermediateFBO;...while(!glfwWindowShouldClose(window))&#123; ... glBindFramebuffer(msFBO); ClearFrameBuffer(); DrawScene(); // 将多采样缓冲还原到普通的自定义帧缓冲 glBindFramebuffer(GL_READ_FRAMEBUFFER, msFBO); glBindFramebuffer(GL_DRAW_FRAMEBUFFER, intermediateFBO); glBlitFramebuffer(0, 0, width, height, 0, 0, width, height, GL_COLOR_BUFFER_BIT, GL_NEAREST); // 将得到的普通自定义帧缓冲的纹理图贴到屏幕四边形上 glBindFramebuffer(GL_FRAMEBUFFER, 0); ClearFramebuffer(); glBindTexture(GL_TEXTURE_2D, screenTexture); DrawPostProcessingQuad(); ...&#125; 如果我们实现之前在《OpenGL19：帧缓冲》中的后处理效果，比如模糊kernel，结果会像这样： 将多采样纹理转换为普通2D纹理，实现反走样的所有源码请看这里。 由于屏幕纹理重新变回了只有一个采样点的普通纹理，有些后处理，比如边缘检测（edge-detection）将会再次导致锯齿边问题。为了修正此问题，我们应该对这个屏幕纹理进行模糊处理，或者自定义抗锯齿算法。 注意开启多采样会明显降低性能，样本越多越明显，MSAA4是最常用的。 自定义反走样算法 其实也可以直接把一个多采样纹理图像传到着色器里，就是不需要先还原。这个时候我们就得将uniform采样器定义为sampler2DMS了，而不是sampler2D：1uniform sampler2DMS screenTextureMS; 然后使用texelFetch函数来获取每个样本的信息（比如样本颜色）：1vec4 colorSample = texelFetch(screenTextureMS, TexCoords, 3); 3是指我们想获取像素中第4个样本的信息。 获取到像素中每个样本的信息后，我们就可以自定义反走样算法，来决定如何生成最终的像素颜色。能够获取到MSAA中每个样本的颜色、深度、模板等信息，有时候还是很需要的！&nbsp; 参考文献：LearnOpenGL]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>反走样</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenGL24：实例化]]></title>
    <url>%2F2017%2F02%2F06%2FOpenGL24%E5%AE%9E%E4%BE%8B%E5%8C%96%2F</url>
    <content type="text"><![CDATA[假如我们有一个许多模型的场景，而这些模型的顶点数据都一样，只是进行了不同的世界空间的变换。想象一下，有一个场景中充满了草：每根草都是几个三角形组成的。最终一次渲染循环中可能有成千上万个草需要绘制。渲染多个物体的时候，代码类似下面这样：12345for(GLuint i = 0; i &lt; amount_of_models_to_draw; i++)&#123; DoSomePreparations(); //在这里绑定VAO、绑定纹理、设置uniform变量等 glDrawArrays(GL_TRIANGLES, 0, amount_of_vertices);&#125; 像这样多次绘制同一个模型，很快会达到一个瓶颈，这是因为我们调用的glDrawArrays或glDrawElements这样的函数（Draw Call）过多。因为在使用它们绘制之前，必须做一些准备工作，比如告诉GPU从哪个缓冲读取数据，以及在哪里 找到顶点属性，所有这些命令从CPU到GPU是需要花费时间的，会使CPU到GPU的总线变慢。 如果能够一次就绘制多个模型就好了，这就是实例化。 实例化 实例化（Instancing）是一种只调用一次渲染函数却能绘制出很多物体的技术，它节省渲染物体时从CPU到GPU的通信时间，只需要做一次即可。 要使用实例化渲染，我们必须将glDrawArrays和glDrawElements各自改为glDrawArraysInstanced和glDrawElementsInstanced。它们相比各自之前的函数，只是多了一个参数，叫做实例数量，它设置我们打算渲染的实例的数量。 我们使用这个函数确实可以一次渲染很多个相同的物体，但是它们都会处在同一个位置，我们只能看到一个物体。不过GLSL为我们提供了一个内置变量gl_InstanceID，表示当前绘制的实例序号，初始值是0。我们可以利用这个当前实例序号，去索引一个位置数组，来把每个实例放在不同的位置上。 下面我们使用实例化来一次绘制100个方块。首先我们设置好方块的顶点数据：1234567891011//方块的顶点数据GLfloat quadVertices[] = &#123; // ---位置--- ------颜色------- -0.05f, 0.05f, 1.0f, 0.0f, 0.0f, 0.05f, -0.05f, 0.0f, 1.0f, 0.0f, -0.05f, -0.05f, 0.0f, 0.0f, 1.0f, -0.05f, 0.05f, 1.0f, 0.0f, 0.0f, 0.05f, -0.05f, 0.0f, 1.0f, 0.0f, 0.05f, 0.05f, 0.0f, 1.0f, 1.0f&#125;; 接下里是我们的顶点着色器：1234567891011#version 330 corelayout (location=0) in vec2 position;layout (location=1) in vec3 color;out vec3 fColor;uniform vec2 offsets[100];void main()&#123; gl_Position = vec4(position + offsets[gl_InstanceID], 0.0f, 1.0f); fColor = color;&#125; 在顶点着色器中，我们设置了一个uniform数组，它是在主程序里被赋值的，表示了100个方块的位置。它在主程序中是这样被赋值的：123456789101112131415//100个方块的位置vec2 quadOffsets[100];int index = 0;for (GLfloat y = -0.9; y &lt;= 0.9; y += 0.2) &#123; for (GLfloat x = -0.9; x &lt;= 0.9; x += 0.2) &#123; quadOffsets[index].x = x; quadOffsets[index].y = y; index++; &#125;&#125;... quad_shader.Use();for (int i = 0; i &lt; 100; i++) &#123; glUniform2f(glGetUniformLocation(quad_shader.shaderProgram, ("offsets[" + IntToString(i) + "]").c_str()), quadOffsets[i].x, quadOffsets[i].y);&#125; 其中IntToString是我们用于把整数变成字符串的自定义函数：123456//把int类型转换为string类型string IntToString(int number) &#123; ostringstream outs; outs &lt;&lt; number; return outs.str();&#125; 像素着色器就很简单了，显示从顶点着色器接收的颜色即可：1234567#version 330 corein vec3 fColor;out vec4 color;void main()&#123; color=vec4(fColor, 1.0f);&#125; 最后我们使用glDrawArraysInstanced函数来一次绘制100个方块：123glBindVertexArray(quadVAO);glDrawArraysInstanced(GL_TRIANGLES, 0, 6, 100);glBindVertexArray(0); 编译运行后的结果如下： 实例化数组 前面我们使用了100个uniform来标识方块的不同位置，但是uniform数量是有上线的，想要绘制更多方块显然不能再使用uniform了。解决这个问题的另一个可替代方案是实例化数组（Instanced Array），它用顶点属性来存储这些方块的位置。下面我们在顶点着色器中加入方块位置属性：12345678910#version 330 corelayout (location = 0) in vec2 position;layout (location = 1) in vec3 color;layout (location = 2) in vec2 offset;out vec3 fColor;void main()&#123; gl_Position = vec4(position + offset, 0.0f, 1.0f); fColor = color;&#125; 我们不再使用gl_InstanceID，而是直接使用offset属性。 我们需要把100个方块的位置存储到另一个顶点缓冲对象里，同时解析这些数据，告诉GPU怎么读取识别：12345678910//将100个方块位置存储到另一个顶点缓冲对象中GLuint instanceVBO;glGenBuffers(1, &amp;instanceVBO);glBindBuffer(GL_ARRAY_BUFFER, instanceVBO);glBufferData(GL_ARRAY_BUFFER, sizeof(quadOffsets), &amp;quadOffsets, GL_STATIC_DRAW);glEnableVertexAttribArray(2);glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, 2 * sizeof(GL_FLOAT), (GLvoid*)0);glBindBuffer(GL_ARRAY_BUFFER, 0);//声明顶点的2号属性是一个实例数组，每1个实例更新内容glVertexAttribDivisor(2, 1); GPU在读取顶点数据时，通常是每一个顶点就会往后面去重新读取新的顶点数据，比如glVertexAttribPointer函数指定步长为5个float，那么每读一个顶点，指针就会往后移动5个浮点数，再读下一个顶点。但是我们的方块位置offset明显不是给单独的一个顶点用的，而是同属一个方块的6个顶点共用一个方块位置数据offset。上面的glVertexAttribDivisor(2, 1);就是在告诉OpenGL每绘制一个实例（方块）才更新一次2号属性offset的内容。它的第一个参数是顶点属性号；第二个参数是属性除数（attribute divisor），默认属性除数是0，表示每个顶点更新一次属性内容，设置为1表示OpenGL会在开始渲染一个新的实例时才去更新属性内容，设置为2表示每2个实例更新内容，以此类推。把属性除数设置为非0，我们可以高效地告诉OpenGL对应的顶点属性是一个实例数组（instanced array）。 我们依然使用glDrawArraysInstanced绘制100个方块，会得到和之前一样的结果，但是速度会快很多。这次是使用实例数组实现的，它让我们可以绘制更多的相同实例，而不受uniform数量上线限制。 我们还可以使用gl_InstanceID从右上向左下缩小每个四边形：1234void main()&#123; gl_Position = vec4(position * (gl_InstanceID / 100.0f) + offset, 0.0f, 1.0f); fColor = color;&#125; 编译运行后的结果如下：所有源码在这里。 Demo：小行星带 想象一下，在一个场景中一个很大的行星（从这里下载），行星周围有一圈小行星带。这样一个小行星带可能包含成千上万的石块(从这里下载)，对于多达数显卡来说一个一个地渲染几乎是难以完成的渲染任务。但是对于实例化渲染来说却不在话下，每个小行星都可以使用一个模型来表示，经过一个变换矩阵后他们就是一个独一无二的小行星了。 老方法绘制小行星带我们先使用老办法，一个一个地渲染出这些石块：由于行星周围的陨石块在不同的位置，所以我们给这些陨石块设置不同的模型矩阵：123456789101112131415161718192021222324252627//1000个陨石块的模型矩阵GLuint amount = 1000;mat4* modelMatrices = new mat4[amount];srand(glfwGetTime());GLfloat radius = 20.0f;GLfloat offset = 2.5f;for (GLuint i = 0; i &lt; amount; i++) &#123; mat4 model; /********平移*********/ GLfloat angle = (GLfloat)i / amount* 360.0f; //获得一个在-offset到offset之间的随机数 GLfloat displacement = (rand() % (GLint)(2 * offset * 100)) / 100.0f - offset; GLfloat x = sin(angle)*radius + displacement; displacement = (rand() % (GLint)(2 * offset * 100)) / 100.0f - offset; GLfloat y = displacement*0.4; displacement = (rand() % (GLint)(2 * offset * 100)) / 100.0f - offset; GLfloat z = cos(angle)*radius + displacement; model = translate(model, vec3(x, y, z)); /********旋转*********/ GLfloat rotAngle = rand() % 360; model = rotate(model, rotAngle, vec3(0.4f, 0.6f, 0.8f)); /********缩放*********/ GLfloat scaleSize = (rand() % 20) / 100.0f + 0.05f; model = scale(model, vec3(scaleSize)); modelMatrices[i] = model;&#125; 这段代码看起来挺吓的，其实做的事很简单：先计算得到一个在-offset到offset之间的随机数，然后圆圈上的某个随机点以这个offset偏移为x、y、z方向偏移，得到陨石块的最终位置（在y方向上的偏移量只有0.4倍，可以让这个环带成为扁平的）。接着就是随机的旋转和缩放变换了。总共随机生成了1000个模型矩阵，每个陨石块一个，代表了陨石块在世界空间里的位置。 然后我们加载行星和石块的模型文件：12Model planet("planet/planet.obj");Model rock("rock/rock.obj"); 顶点着色器和像素着色器都很简单，可参考后面的源码。 定义的着色器类对象如下：1shader planetAndRock_shader("planet.vertex", "planet.fragment"); 接下里我们就可以绘制小行星和它周围的陨石了：12345678910111213141516planetAndRock_shader.Use();mat4 view = mycamera.GetViewMatrix();mat4 projection = perspective(radians(mycamera.cameraFov), (GLfloat)WIDTH / (GLfloat)HEIGHT, 0.1f, 100.0f);glUniformMatrix4fv(glGetUniformLocation(planetAndRock_shader.shaderProgram, "view"), 1, GL_FALSE, value_ptr(view));glUniformMatrix4fv(glGetUniformLocation(planetAndRock_shader.shaderProgram, "projection"), 1, GL_FALSE, value_ptr(projection));//绘制小行星mat4 model;model = translate(model, vec3(0.0f, -5.0f, 0.0f));model = scale(model, vec3(3.0f, 3.0f, 3.0f));glUniformMatrix4fv(glGetUniformLocation(planetAndRock_shader.shaderProgram, "model"), 1, GL_FALSE, value_ptr(model));planet.Draw(planetAndRock_shader);//绘制小行星周边的陨石带for (int i = 0; i &lt; amount; i++) &#123; glUniformMatrix4fv(glGetUniformLocation(planetAndRock_shader.shaderProgram, "model"), 1, GL_FALSE, value_ptr(modelMatrices[i])); rock.Draw(planetAndRock_shader);&#125; 编译运行后的结果如下：用老办法渲染小行星带的所有源码在这里。 这个场景包含1001次渲染函数调用，每帧渲染1001个模型。但是当我们开始增加数量的时候，很快会注意到帧数下降得很厉害，amount设置为2000的时候，场景明显出现卡顿。上升到100000时，场景已经卡得很难移动了。 下面我们使用实例化来渲染同样的场景。 实例化绘制小行星带由于行星不需要实例化绘制，而岩石需要。所以行星和陨石得分别使用各自的一套着色器了。 行星的着色器不变。陨石的顶点着色器相比行星的顶点着色器，增加了一个mat4类型的顶点属性，表示陨石的模型矩阵（同时不需要再使用uniform类型的模型矩阵了）：12345678910111213#version 330 corelayout (location = 0) in vec3 position;layout (location = 2) in vec2 texCoords;layout (location = 3) in mat4 instanceMatrix;out vec2 TexCoords;uniform mat4 view;uniform mat4 projection;void main()&#123; gl_Position = projection * view * instanceMatrix * vec4(position, 1.0f); TexCoords = texCoords;&#125; 这样一来，我们就将成千上万个陨石的模型矩阵，存储为顶点属性。可以在主程序里一次把所有陨石的模型矩阵发送给GPU，而不像在使用uniform模型矩阵时每绘制一个陨石，都需要从CPU把模型矩阵发送给GPU，所以使用实例化绘制同种物体明显会提升渲染效率。 除了在模型加载类里给陨石mesh绑定并解析顶点位置、法线、纹理坐标等，现在我们还需要绑定、发送数据并解析第3个顶点属性：陨石的模型矩阵instanceMatrix（实例数组）。不过有一点需要注意，虽然我们在顶点着色器里给instanceMatrix的location编号为3，但是GLSL要求顶点属性被允许的最大数据量是vec4，所以mat4类型的instanceMatrix和4个vec4相等，即相当于是4个顶点属性：3、4、5、6。在主程序里被赋值时，应该以这4个属性编号，分4次为instanceMatrix矩阵赋值：1234567891011121314151617181920212223242526Model rock("rock/rock.obj");//将陨石位置作为实例数组，作为新的顶点属性数据，每个实例更新一次for (GLuint i = 0; i &lt; rock.meshes.size(); i++) &#123; GLuint VAO = rock.meshes[i].VAO; GLuint VBO; glBindVertexArray(VAO); glGenBuffers(1, &amp;VBO); glBindBuffer(GL_ARRAY_BUFFER, VBO); glBufferData(GL_ARRAY_BUFFER, amount * sizeof(mat4), &amp;modelMatrices[0], GL_STATIC_DRAW); glEnableVertexAttribArray(3); glVertexAttribPointer(3, 4, GL_FLOAT, GL_FALSE, 4 * sizeof(vec4), (GLvoid*)0); glEnableVertexAttribArray(4); glVertexAttribPointer(4, 4, GL_FLOAT, GL_FALSE, 4 * sizeof(vec4), (GLvoid*)(sizeof(vec4))); glEnableVertexAttribArray(5); glVertexAttribPointer(5, 4, GL_FLOAT, GL_FALSE, 4 * sizeof(vec4), (GLvoid*)(2 * sizeof(vec4))); glEnableVertexAttribArray(6); glVertexAttribPointer(6, 4, GL_FLOAT, GL_FALSE, 4 * sizeof(vec4), (GLvoid*)(3 * sizeof(vec4))); glVertexAttribDivisor(3, 1); glVertexAttribDivisor(4, 1); glVertexAttribDivisor(5, 1); glVertexAttribDivisor(6, 1); glBindVertexArray(0);&#125; 上面通过4次glVertexAttribDivisor函数将instanceMatrix顶点属性设置为了实例数组。不要忘了还要把MeshLoader类的meshes成员和Mesh类的VAO成员改成公有的（public）（这样改还是很破坏模块独立性的，为了简单起见就这样吧~！）。 陨石的像素着色器和行星的一样，可参见文后的源码。为陨石和行星定义的着色器类对象如下：12Model planet("planet/planet.obj");Model rock("rock/rock.obj"); 然后我们可以在渲染循环里使用glDrawElementsInstanced函数绘制成千上万的陨石了：12345678910//绘制小行星周边的陨石带rock_shader.Use();glUniformMatrix4fv(glGetUniformLocation(rock_shader.shaderProgram, "view"), 1, GL_FALSE, value_ptr(view));glUniformMatrix4fv(glGetUniformLocation(rock_shader.shaderProgram, "projection"), 1, GL_FALSE, value_ptr(projection));for (int i = 0; i &lt; rock.meshes.size(); i++) &#123; glBindVertexArray(rock.meshes[i].VAO); glBindTexture(GL_TEXTURE_2D, rock.meshes[i].textures[0].id); glDrawElementsInstanced(GL_TRIANGLES, rock.meshes[i].indices.size(), GL_UNSIGNED_INT, 0, amount); glBindVertexArray(0);&#125; 绘制行星的代码和之前一样，不再赘述了。 编译运行后的结果和使用老方法绘制的结果一样，不过速度变快了。不实例渲染我们可以流畅渲染1000到1500个陨石；而使用了实例渲染，我们可以渲染100000个陨石！每个模型有576个顶点，这就是5千7百万个顶点，但是帧率几乎没有下降（有些渲染性能不太好的机器可能会下降一点）。调整为100000陨石后编译运行的结果如下： 实例渲染通常用来渲染草、草虫、粒子以及想小行星带这样的场景，基本上只要场景中有很多重复物体，使用实例渲染都会获得好处。 实例化绘制小行星带的所有源码在这里。&nbsp; 参考文献：LearnOpenGL]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>实例化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenGL23：几何着色器]]></title>
    <url>%2F2017%2F02%2F05%2FOpenGL23%E5%87%A0%E4%BD%95%E7%9D%80%E8%89%B2%E5%99%A8%2F</url>
    <content type="text"><![CDATA[在顶点和片段着色器之间有一个可选的着色器，叫做几何着色器（Geometry Shader）。 几何着色器 几何着色器以一个或多个基本图形的顶点作为输入，比如一个点或者三角形。几何着色器可以将这些顶点转变为完全不同的基本图形，可以生成比原来多得多的顶点，再把这些顶点发送到下一个着色器阶段。 我们直接来看一个几何着色器的例子：12345678910111213#version 330 corelayout (points) in;layout (line_strip, max_vertices = 2) out;void main() &#123; gl_Position = gl_in[0].gl_Position + vec4(-0.1, 0.0, 0.0, 0.0); EmitVertex(); gl_Position = gl_in[0].gl_Position + vec4(0.1, 0.0, 0.0, 0.0); EmitVertex(); EndPrimitive();&#125; 在几何着色器中，我们需要声明输入的基本图形（primitive）类型，这个输入是我们从顶点着色器中接收到的。需要在in关键字前面声明一个layout标识符，括号里表示可以从一个顶点着色器接收的基本图形。可以有以下基本图形值：这是我们能够给渲染函数的几乎所有的基本图形。如果我们在主程序中选择以GL_TRIANGLES方式绘制顶点，我们就要把这里的输入修饰符设置为triangles。括号里的数字代表对应基本图形的最少顶点数。 当我们需要指定几何着色器所输出的基本图形类型时，我们就在out关键字前面加一个layout标识符。和输入layout标识符一样，输出的layout标识符也可以接受以下基本图形值： points line_strip triangle_strip 使用这三个输出修饰符，我们可以从输入的基本图形创建任何我们想要的形状。为了生成一个三角形，我们定义一个triangle_strip作为输出标识符，然后在其main函数里输出3个顶点，就能够输出一个三角形。同时，我们需要指定几何着色器能够输出的顶点数量的最大值（如果超出了这个数值，OpenGL就会忽略剩下的顶点），如上面的line_strip, max_vertices=2，表示我们将使用2个顶点输出一个line_strip。【注】： line_strip就是首位相连的线条。线条是把多个点链接起来表示出一个连续的线，它最少有两个点来组成。后一个点在前一个新渲染的点后面渲染。line_strip如下图所示：在上面的着色器里，当然不能得到上图的线条，因为输出顶点数量的最大值被我们设置为了2，只能输出一个线段。 顶点着色器的数据是通过什么传递到几何着色器的呢？GLSL为我们提供了一个内置变量gl_in，它的内部像这样：123456in gl_Vertex&#123; vec4 gl_Position; float gl_PointSize; float gl_ClipDistance[];&#125; gl_in[]; 它被声明为一个借口块，表示从顶点着色器接收的顶点数组。其中就包含了与顶点着色器输出相似的位置向量gl_Position。要注意gl_in是一个数组，因为几何着色器一次接收一个基本图形的所有顶点来填充gl_in数组，作为它的输入。 使用来自顶点着色器的顶点数据，我们可以开始输出新的顶点数据了。这需要通过EmitVertex函数（输出一个顶点）和EndPrimitive函数（结束基本图形）来实现。&nbsp; 使用几何着色器把点转化为线这里我们用一个demo：在几个着色器里接收一些点的输入，转化为线条输出，来完整地使用一次几何着色器。 首先我们在顶点着色器里定义4个顶点的顶点数据：123456789101112131415161718GLfloat pointsVertices[] = &#123; //位置坐标 0.5f, 0.5f, 0.5f,-0.5f, -0.5f,-0.5f, -0.5f, 0.5f,&#125;;//点的pointsVAO和数据解析GLuint pointsVAO, pointsVBO;glGenVertexArrays(1, &amp;pointsVAO);glBindVertexArray(pointsVAO);glGenBuffers(1, &amp;pointsVBO);glBindBuffer(GL_ARRAY_BUFFER, pointsVBO);glBufferData(GL_ARRAY_BUFFER, sizeof(pointsVertices), &amp;pointsVertices, GL_STATIC_DRAW);glEnableVertexAttribArray(0);glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 2 * sizeof(GL_FLOAT), (GLvoid*)0);glBindVertexArray(0); 然后是我们的几何着色器（写在points.geometry）：1234567891011#version 330 corelayout (points) in;layout (line_strip,max_vertices=2) out;void main()&#123; gl_Position = gl_in[0].gl_Position + vec4(-0.1f,0.0f,0.0f,0.0f); EmitVertex(); gl_Position = gl_in[0].gl_Position + vec4(0.1f,0.0f,0.0f,0.0f); EmitVertex(); EndPrimitive();&#125; 在该几何着色器里，我们接收的输入是点这种基本图形的顶点，输出是线条这种基本图形，同时指定输出的图形最多由两个顶点组成。在main函数里，我们先把接收到的第一个顶点向x方向移动-0.1，把得到的新顶点用EmitVertex函数发送出去；接着再把第一个顶点向x方向移动0.1，把得到的新顶点用EmitVertex函数发送出去，两个顶点发完了，我们的线条这个基本图形到此结束。注意，由于这里几何着色器的输入基本图形是点points，所以它每次得到的来自顶点着色器的输入顶点只有1个，而不是4个，这4个顶点是分4次传到几何着色器里的；如果输入基本图形是triangles，那么几何着色器每次得到的顶点个数就是3个。 当然，不要忘了，我们的着色器类得改改了。得把几何着色器也加进来，编译后附加到着色器程序对象上：1234567891011const GLchar* geometryShaderSource = GetShaderSourceFromFile(geometryPath);GLuint geometryShader;geometryShader = glCreateShader(GL_GEOMETRY_SHADER);glShaderSource(geometryShader, 1, &amp;geometryShaderSource, NULL);glCompileShader(geometryShader);glGetShaderiv(geometryShader, GL_COMPILE_STATUS, &amp;success);if (!success) &#123; glGetShaderInfoLog(geometryShader, 512, NULL, infolog); cout &lt;&lt; "geometry shader compilation failed" &lt;&lt; infolog &lt;&lt; endl;&#125;glAttachShader(shaderProgram, geometryShader); 然后在主程序里定义着色器类对象：12//定义自定义着色器类shader的对象shader points_shader("points.vertex", "points.fragment", "points.geometry"); 最后我们在渲染循环里绘制4个顶点：1234points_shader.Use();glBindVertexArray(pointsVAO);glDrawArrays(GL_POINTS, 0, 4);glBindBuffer(GL_UNIFORM_BUFFER, 0); 编译运行后的结果如下：还是很神奇的！因为我们渲染时是用的GL_POINTS，但是却能够根据这些点绘制出几个线条，这都是几何着色器的功劳。&nbsp; 使用几何着色器把点画成房子绘制点和线好像挺枯燥的，所以我们将在每个点上使用几何着色器绘制一个房子。它是由几个三角形构成的，如下图所示：在OpenGL里这样挨在一起的三角形，用trangle_strip绘制起来更搞笑，因为它所需要的顶点更少。所以我们把几何着色器里的输出基本图形设置为triangle_strip。这个房子总共有5个顶点，使用triangle_strip时，每3个毗邻的顶点都会构成一个三角形，所以得到这些三角形：（1,2,3）、（2,3,4）、（3,4,5）。其实有N个顶点就能得到N-2个三角形。注意，上图的房子里只有中间的蓝色点才是来自顶点着色器的输入，而房子的5个顶点都是根据这个蓝色点，在几何着色器里生成的：1234567891011121314151617#version 330 corelayout (points) in;layout (triangle_strip,max_vertices=5) out;void main()&#123; gl_Position = gl_in[0].gl_Position + vec4(-0.2f, -0.2f, 0.0f, 0.0f);// 1:左下角 EmitVertex(); gl_Position = gl_in[0].gl_Position + vec4( 0.2f, -0.2f, 0.0f, 0.0f);// 2:右下角 EmitVertex(); gl_Position = gl_in[0].gl_Position + vec4(-0.2f, 0.2f, 0.0f, 0.0f);// 3:左上 EmitVertex(); gl_Position = gl_in[0].gl_Position + vec4( 0.2f, 0.2f, 0.0f, 0.0f);// 4:右上 EmitVertex(); gl_Position = gl_in[0].gl_Position + vec4( 0.0f, 0.4f, 0.0f, 0.0f);// 5:屋顶 EmitVertex(); EndPrimitive();&#125; 因为要从一个输入顶点变成5个顶点连线构成的房子，所以几何着色器的输出需要加上标识符layout (triangle_strip, max_vertices = 5) out;。 顶点着色器如下：123456#version 330 corelayout (location=0) in vec2 position;void main()&#123; gl_Position = vec4(position, 0.0f, 1.0f);&#125; 像素着色器如下：123456#version 330 coreout vec4 color;void main()&#123; color= vec4(1.0f, 0.0f, 0.0f, 1.0f);&#125; 编译运行后的结果如下：这4个房子都一个颜色，现在我们让每个房子都有不同的颜色。我们给每个顶点再加上一个颜色属性，同时更新对顶点属性数据的解析：1234567891011121314151617181920GLfloat pointsVertices[] = &#123; //位置坐标 //颜色 0.5f, 0.5f, 1.0f, 0.0f, 0.0f, 0.5f,-0.5f, 0.0f, 1.0f, 0.0f, -0.5f,-0.5f, 0.0f, 0.0f, 1.0f, -0.5f, 0.5f, 1.0f, 1.0f, 0.0f&#125;;//点的pointsVAO和数据解析GLuint pointsVAO, pointsVBO;glGenVertexArrays(1, &amp;pointsVAO);glBindVertexArray(pointsVAO);glGenBuffers(1, &amp;pointsVBO);glBindBuffer(GL_ARRAY_BUFFER, pointsVBO);glBufferData(GL_ARRAY_BUFFER, sizeof(pointsVertices), &amp;pointsVertices, GL_STATIC_DRAW);glEnableVertexAttribArray(0);glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 5 * sizeof(GL_FLOAT), (GLvoid*)0);glEnableVertexAttribArray(1);glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 5 * sizeof(GL_FLOAT), (GLvoid*)(2 * sizeof(GL_FLOAT)));glBindVertexArray(0); 接着在顶点着色器中，增加输入变量来接收这个颜色属性，并且我们使用接口块来把顶点颜色发送给几何着色器：123456789101112#version 330 corelayout (location=0) in vec2 position;layout (location=1) in vec3 color;out VS_OUT&#123; vec3 color;&#125; vs_out;void main()&#123; gl_Position = vec4(position, 0.0f, 1.0f); vs_out.color = color;&#125; 当然也可以不使用接口块，直接使用out vec3 color也是可以的。 接下里需要在几何着色器中声明同样的接口块（块名相同，块变量可以不同名）：123in VS_OUT&#123; vec3 color;&#125; gs_in[]; 注意这里的块变量是一个数组，这是因为几何着色器一次接收的是组成基本图形的所有顶点，可能会有多个顶点被一次传到几何着色器里（现在我们是layout (points) in;，只有一个顶点被传过来，即gs_in[0]）。 我们最后需要把颜色输出给像素着色器，所以还需要在几何着色器里声明一个输出颜色向量：1out vec3 fcolor; 接下来我们在几何着色器的main函数里，让这个输出颜色向量等于来自顶点着色器的颜色向量：1234567891011121314void main()&#123; fcolor = gs_in[0].color; gl_Position = gl_in[0].gl_Position + vec4(-0.2f, -0.2f, 0.0f, 0.0f);// 1:左下角 EmitVertex(); gl_Position = gl_in[0].gl_Position + vec4( 0.2f, -0.2f, 0.0f, 0.0f);// 2:右下角 EmitVertex(); gl_Position = gl_in[0].gl_Position + vec4(-0.2f, 0.2f, 0.0f, 0.0f);// 3:左上 EmitVertex(); gl_Position = gl_in[0].gl_Position + vec4( 0.2f, 0.2f, 0.0f, 0.0f);// 4:右上 EmitVertex(); gl_Position = gl_in[0].gl_Position + vec4( 0.0f, 0.4f, 0.0f, 0.0f);// 5:屋顶 EmitVertex(); EndPrimitive();&#125; 由于房子的5个顶点都是相同的颜色，都等于对应的顶点着色器的输出颜色，所以只需要做一次fcolor = gs_in[0].color;即可，后面几何着色器使用EmitVertex函数发送顶点时，都会包含最新的out变量fcolor的值。 在像素着色器里，片段颜色应该是等于接收到的顶点颜色了，房子内部的点就由像素着色器自己去插值了：1234567#version 330 corein vec3 fcolor;out vec4 color;void main()&#123; color= vec4(fcolor, 1.0f);&#125; 编译运行后的结果如下：如果我们还想给房子的屋顶上加点白色，就像落了雪一样，其实也就是说房子的5个顶点不是同一个颜色了，屋顶顶点变成了白色。我们只需要做如下改变即可：123456789101112131415void main()&#123; fcolor = gs_in[0].color; gl_Position = gl_in[0].gl_Position + vec4(-0.2f, -0.2f, 0.0f, 0.0f);// 1:左下角 EmitVertex(); gl_Position = gl_in[0].gl_Position + vec4( 0.2f, -0.2f, 0.0f, 0.0f);// 2:右下角 EmitVertex(); gl_Position = gl_in[0].gl_Position + vec4(-0.2f, 0.2f, 0.0f, 0.0f);// 3:左上 EmitVertex(); gl_Position = gl_in[0].gl_Position + vec4( 0.2f, 0.2f, 0.0f, 0.0f);// 4:右上 EmitVertex(); gl_Position = gl_in[0].gl_Position + vec4( 0.0f, 0.4f, 0.0f, 0.0f);// 5:屋顶 fcolor = vec3(1.0f, 1.0f, 1.0f); EmitVertex(); EndPrimitive();&#125; 让屋顶顶点的输出颜色等于白色即可。 编译运行后的结果如下：所有源码在这里。 可以看到，使用几何着色器，可以使用最简单的基本图形就能获得漂亮的新玩意。因为这些形状是在GPU这种超快硬件上动态生成的，这要比使用顶点缓冲自己定义这些形状更为高效。几何缓冲在简单的经常被重复的形状（比如体素的世界和室外的草地）上，是一种非常强大的优化工具。 Demo：爆破物体 下面我们使用几何着色器来实现纳米铠甲的爆破效果。其实就是在几何着色器里让每个三角形面片沿着法线向外移动了一段距离，好像纳米铠甲爆炸了一样。也就是在几何着色器里，三角形的每个顶点沿着法线向外移动了一段距离。 这时的几何着色器接收的基本图形应该是三角形，输出的应该也是三角形。所以：1234#version 330 corelayout (triangles) in;layout (triangle_strip, max_vertices = 3) out;... 由于我们要使用纳米铠甲这个模型，我们需要从顶点着色器里接收顶点的法线、世界坐标、纹理坐标等属性，在几何着色器里处理完毕后再把它们输出给像素着色器（可以参考《OpenGL14：模型加载》） 一文中的顶点着色器和像素着色器）。所以在几何着色器里我们用接口块VS_OUT来接收来自顶点着色器的顶点属性，并且设置对应的输出变量：12345678in VS_OUT&#123; vec3 Normal; vec3 positionInWorld; vec2 TexCoords;&#125; gs_in[];out vec3 Normal;out vec3 positionInWorld;out vec2 TexCoords; 由于三角形的每个顶点需要沿着三角形的法线，向外移动一段距离，所以我们需要先算出三角形的法线，我们把它写在GetNormal中：12345vec3 GetNormal()&#123; vec3 a = vec3(gl_in[0].gl_Position) - vec3(gl_in[1].gl_Position); vec3 b = vec3(gl_in[1].gl_Position) - vec3(gl_in[2].gl_Position); return normalize(cross(a, b));&#125; 然后我们用explode函数来计算顶点沿着法线向外移动一段距离后的位置：12345vec4 explode(vec4 position, vec3 normal)&#123; float magnitude = 2.0f; vec3 direction = normal * magnitude * ((sin(time) + 1.0f)/2.0f); return position + vec4(direction, 0.0f);&#125; 它接收两个参数：顶点原来的位置和法线向量。上面我们乘了一个时间变量time，来实现动态的爆炸效果。这个time变量是个uniform变量，需要从主程序给它赋值：1uniform float time; 在几何着色器的main函数里，只需要改变三个顶点的位置为爆炸后的位置，顶点的法线、世界坐标、纹理坐标等原样输出即可。需要在main函数里发送3次顶点：1234567891011121314151617181920212223void main()&#123; vec3 normal = GetNormal(); gl_Position = explode(gl_in[0].gl_Position, normal); Normal = gs_in[0].Normal; positionInWorld = gs_in[0].positionInWorld; TexCoords = gs_in[0].TexCoords; EmitVertex(); gl_Position = explode(gl_in[1].gl_Position, normal); Normal = gs_in[1].Normal; positionInWorld = gs_in[1].positionInWorld; TexCoords = gs_in[1].TexCoords; EmitVertex(); gl_Position = explode(gl_in[2].gl_Position, normal); Normal = gs_in[2].Normal; positionInWorld = gs_in[2].positionInWorld; TexCoords = gs_in[2].TexCoords; EmitVertex(); EndPrimitive();&#125; 不要忘了在主程序中对time变量赋值，而且顶点着色器也得作出相应调整（改成接口块）。编译运行后的结果如下：全部源码在这里。 显示法向量 下面我们将使用几何着色器来显示纳米铠甲每个顶点的法线向量。当编写光照着色器的时候，经常会遇到奇怪的视频输出问题，很难分辨是哪里出了问题。通常是因为不正确地加载了顶点数据，以及给它们指定了不合理的顶点属性，或者是在着色器中不合法的管理，导致产生了不正确的法线向量。我们希望可以用某种方式检测出法线向量是否正确，而我们这里的把法向量显示出来就是一种不错的方法。 显示法线向量的思路：先不使用几何着色器，正常绘制物体；然后使用我们用于显示法线向量的几何着色器，再绘制一次物体，这次只绘制物体上顶点的法线，不会绘制物体的面片。看起来就像这样：1234lightObject.Use();mymodel.Draw(lightObject);normalDisplay.Use();mymodel.Draw(normalDisplay); 我们先写一个显示法线的顶点着色器（写在normalDisplay.vertex中）：123456789101112131415161718//顶点着色器#version 330 corelayout (location=0) in vec3 position; //顶点位置属性的位置值为0layout (location=1) in vec3 normal; //顶点法线属性的位置值为1out VS_OUT&#123; vec3 Normal;&#125; vs_out;//模型矩阵uniform mat4 model;//观察矩阵uniform mat4 view;//投影矩阵uniform mat4 projection;void main()&#123; gl_Position = projection * view * model * vec4(position,1.0f); vs_out.Normal = normalize(vec3(projection * view * vec4(mat3(transpose(inverse(model))) * normal, 1.0f)));&#125; 注意，这里的法线向量我们将它变换到裁剪空间了，因为接下来显示法线向量也是在裁剪空间中进行的。而在对模型的光照处理时，这些法线是在世界空间下，不会乘以proection和view，因为点光源等等计算向量夹角是在世界坐标系下进行的。 接着我们在几何着色器里接收三角形基本图元，但是输出的是线条。在main函数里，三角形的每个顶点和它法线方向上指定距离的某个点，构成一个线段基本图元。这样进行3次EndPrimitive()就能产生3条线段，输出的最大顶点数就是6（写在normalDisplay.geometry中）：1234567891011121314151617181920212223242526272829#version 330 corelayout (triangles) in;layout (line_strip, max_vertices = 6) out;in VS_OUT &#123; vec3 Normal;&#125; gs_in[];const float MAGNITUDE = 0.1f;void main()&#123; gl_Position = gl_in[0].gl_Position; EmitVertex(); gl_Position = gl_in[0].gl_Position + vec4(gs_in[0].Normal, 0.0f) * MAGNITUDE; EmitVertex(); EndPrimitive(); gl_Position = gl_in[1].gl_Position; EmitVertex(); gl_Position = gl_in[1].gl_Position + vec4(gs_in[1].Normal, 0.0f) * MAGNITUDE; EmitVertex(); EndPrimitive(); gl_Position = gl_in[2].gl_Position; EmitVertex(); gl_Position = gl_in[2].gl_Position + vec4(gs_in[2].Normal, 0.0f) * MAGNITUDE; EmitVertex(); EndPrimitive();&#125; MAGNITUDE是为了控制绘制的法线向量的长度。 至于像素着色器就很简单了，让这些法线线段显示一个颜色即可（写在normalDisplay.fragment中）：123456#version 330 coreout vec4 color;void main()&#123; color = vec4(1.0f, 1.0f, 0.0f, 1.0f);&#125; 然后在主程序里，两次使用着色器类对象，一次用于绘制模型物体，接着另一次用于绘制模型顶点的法线向量：1234567lightObject.Use();...mymodel.Draw(lightObject);...normalDisplay.Use();...mymodel.Draw(normalDisplay); 编译运行后的结果如下： 所有源码在这里。&nbsp; 参考文献：LearnOpenGL]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>几何着色器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenGL22：高级GLSL]]></title>
    <url>%2F2017%2F01%2F25%2FOpenGL22%E9%AB%98%E7%BA%A7GLSL%2F</url>
    <content type="text"><![CDATA[本文将会讨论一些GLSL内置变量、接口块和uniform缓冲对象。&nbsp; GLSL的内置变量GLSL有几个以gl_为前缀的变量，我们可以用它们来实现对着色器的输入输出数据。其中两个我们已经接触过：gl_Position和gl_FragCoord，前一个是顶点着色器的输出向量，后一个是像素着色器的变量。接下里我们再多了解几个内置变量。 顶点着色器的内置变量我么已经了解到gl_Position是顶点着色器裁剪空间输出的位置向量，如果想让窗口上渲染出东西，必须使用它，否则我们什么都看不到。除此之外，还有几个顶点着色器的内置变量： 内置变量gl_PointSize渲染的基本图形不仅可以是我们常用的GL_TRIANGLES，还可以是GL_POINTS，顾名思义，它是渲染每一个顶点。除了在主程序中可以使用glPointSize函数来设置这个点的大小以外，我们还可以在顶点着色器里通过内置输出变量gl_Pointsize来设置点的大小。 gl_Pointsize是一个float变量。要使用它我们必须要先开启OpenGL的GL_PROGRAM_POINT_SIZE，因为在着色器中影响点的大小默认是关闭的：1glEnable(GL_PROGRAM_POINT_SIZE); 现在我们来画几个点，着色器都很简单：点的顶点着色器（写在points.vertex中）：1234567#version 330 corelayout (location=0) in vec3 position; void main()&#123; gl_Position = vec4(position, 1.0f); gl_PointSize = position.z * 10;&#125; 这里我们让内置变量gl_PointSize（也就是顶点大小）等于顶点z坐标的10倍。 点的像素着色器（points.fragment）： 123456#version 330 coreout vec4 color; void main()&#123; color= vec4(1.0f, 0.0f, 0.0f, 1.0f);&#125; 完整源码在这里。 编译运行后的结果如下：可以看到z值越大的点越大。想象一下，每个顶点表示出来的点的大小不同，如果用在像粒子生成之类的技术里会挺有意思的。 内置变量gl_VertexID顶点着色器给我们提供了一个有趣的输入变量gl_VertexID，它是只读的。 gl_VertexID是个整型变量，它存储着我们绘制的当前顶点的ID。当进行索引渲染（indexed rendering，使用glDrawElements函数绘制）时，这个变量保存着当前绘制顶点的索引；如果用的不是索引绘制（使用glDrawArrays函数绘制），这个变量保存的是从渲染开始直到当前处理的这个顶点（当前顶点）的编号。 片段着色器的内置变量 内置变量gl_FragCoord在《OpenGL15：深度测试》中，我们已经用过gl_FragCoord了，因为它的z值表示片段的深度值。 gl_FragCoord的x和y元素是当前片段的窗口空间坐标，它的起始处（原点）是窗口的左下角。 gl_FragCoord变量的一个常用方式是与一个不同的片段计算出来的视频输出进行对比，通常在技术演示中常见。比如我们可以把物体分为两部分，某个x值左侧渲染一个输出，右侧渲染另一个输出。如下面的像素着色器：12345678void main()&#123; if(gl_FragCoord.x &lt; 400)&#123; color = vec4(1.0f, 0.0f, 0.0f, 1.0f); &#125; else&#123; color = vec4(0.0f, 1.0f, 0.0f, 1.0f); &#125;&#125; 我们用这个像素着色器代码绘制一个立方体，源码不再赘述了，之前的文章里有很多，编译运行后的结果如下： 内置变量gl_FrontFacing像素着色器另一个有意思的输入变量是gl_FrontFacing。在《OpenGL18：背面剔除》中，我们知道OpenGL可以根据顶点绘制顺序弄清楚一个面是正面还是背面。如果我们不使用面剔除，那么gl_FrontFacing变量能告诉我们当前片段是某个正面的一部分还是背面的一部分。 gl_FrontFacing变量是一个布尔值，如果当前片段时正面的一部分那么就是true，否则就是false。这样我们可以创建一个立方体，里面和外面使用不同的纹理：1234567891011121314#version 330 coreout vec4 color;in vec2 TexCoords; uniform sampler2D frontTexture;uniform sampler2D backTexture; void main()&#123; if(gl_FrontFacing) color = texture(frontTexture, TexCoords); else color = texture(backTexture, TexCoords);&#125; 编译运行后，如果我们移动摄像机到箱子的一角里，就能看到里面和外面使用的是不同的纹理：注意不要开启面剔除，否则摄像机进入箱子后，不会看到箱子的任何部分。 内置变量gl_FragDepth输入变量gl_FragCoord让我们可以读得当前片段的窗口空间坐标和深度值。但是GLSL给我们提供了一个叫做gl_FragDepth的变量，我们可以用它在着色器中设置像素的深度值（片段的窗口空间坐标是没法改变的）：1gl_FragDepth = 0.0f; //现在片段的深度值被设为0 如果着色器中没有显式设置gl_FragDepth的值，它就会自动采样gl_FragCoord.z的值。 我们自己设置深度值有一个显著缺点，因为只要我们在像素着色器中对gl_FragDepth写入什么，OpenGL就会关闭所有的前置深度测试，因为在我们运行片段着色器之前，OpenGL搞不清楚像素的深度值，因为片段着色器可能会完全改变这个深度值。因此需要考虑到gl_FragDepth写入所带来的性能的下降。 然而从OpenGL4.2起，我们仍然可以对二者进行一定的调和，这需要在片段着色器的顶部使用深度条件（depth condition）来重新声明gl_FragDepth：1layout (depth_&lt;condition&gt;) out float gl_FragDepth; condition可以使用下面的值：下面是一个在像素着色器里增加深度值得例子，不过仍可开启前置深度测试：123456789#version 330 corelayout (depth_greater) out float gl_FragDepth;out vec4 color; void main()&#123; color = vec4(1.0f); gl_FragDepth = gl_FragCoord.z + 0.1f;&#125; 一定要记住这个功能只能在OpenGL4.2以上版本才有。&nbsp; 接口块到目前为止，每次我们打算从顶点着色器向片段着色器发送数据，我们都会声明一个相互匹配的输出/输入变量。但是随着应用变得越来越大，我们也许会打算发送的不仅仅是变量，最好还可以包括数组和结构体等。 为了帮助我们组织这些变量，GLSL为我们提供了一些叫做接口块（Interface Blocks）的东西，好让我们能够组织这些变量。声明接口块和声明结构体比较像，只是结构使用struct关键字，而接口块使用in和out关键字来定义一个输入或输出块。示例如下：123456789101112131415161718#version 330 corelayout (location = 0) in vec3 position;layout (location = 1) in vec2 texCoords;uniform mat4 model;uniform mat4 view;uniform mat4 projection;out VS_OUT&#123; vec2 TexCoords;&#125; vs_out;void main()&#123; gl_Position = projection * view * model * vec4(position, 1.0f); vs_out.TexCoords = texCoords;&#125; 我们声明了一个叫做vs_out的接口块，它把我们需要发送给下个阶段着色器的所有输出变量组合起来。 然后我们还需要在像素着色器中声明一个输入接口块，快名应该是一样的，但是实例名可以不一样：1234567891011121314#version 330 coreout vec4 color;in VS_OUT&#123; vec2 TexCoords;&#125; fs_in;uniform sampler2D texture;void main()&#123; color = texture(texture, fs_in.TexCoords);&#125; 如果两个接口块的快名一致，它们对应的输入和输出就会匹配起来。&nbsp; Uniform缓冲对象UBO在之前的文章中，我们肯定有感受：箱子、地面等等不同的物体，它们使用不同的着色器，但是每种着色器里都有相同的uniform变量：观察矩阵view和投影矩阵projection。我们之前的做法是为每种着色器都设置这些uniform变量的值。既然对于每个着色器来说它们都是一样的，那为何还多次设置它们呢？ OpenGL为我们提供了一个叫做uniform缓冲对象（uniform buffer object）的工具，使我们能够声明一系列的全局uniform变量，它们会在几个着色器程序中保持一致。当使用uniform缓冲对象时相关的uniform就只需设置一次了。但是我们还是需要为每个着色器手动设置uniform块，只是不需要在主程序里为这些uniform变量重复赋值了。 如何在多个着色器之间简洁地共享变量，GLSL中可以通过uniform buffer来实现。实现思路是：在多个着色器中定义相同的uniform块（就是上面的接口块，但是使用uniform关键词），然后将这些uniform块绑定到对应的uniform缓冲对象ubo，而uniform缓冲对象中实际存储这些需要共享的变量。着色器中的uniform块和主程序中的uniform缓冲对象，是通过OpenGL的绑定点（binding points）连接起来的，它们的关系如下图所示：使用时，每个shader中定义的uniform块有一个索引，通过这个索引连接到OpenGL的绑定点x；而主程序中创建uniform缓冲对象，传递数据后，将这个UBO绑定到对应的绑定点x，这样shader中的uniform块就和主程序中的UBO连续起来了，我们在主程序中操作UBO的数据，就能够在不同着色器之间共享了。例如上图中，着色器A和着色器B中的Matrices的索引都指向绑定点0，他们共享主程序的uboMatrices这个UBO的数据。同时着色器A的Lights和着色器B的Data，分别指向不同的UBO。 下面是一个使用uniform块的着色器例子：1234567891011121314#version 330 corelayout (location = 0) in vec3 position;layout (std140) uniform Matrices&#123; mat4 projection; mat4 view;&#125;;uniform mat4 model;void main()&#123; gl_Position = projection * view * model * vec4(position, 1.0);&#125; 这里我们声明了一个叫做Matrices的uniform块，它存储两个4x4矩阵。在uniform块中的变量可以直接获取，而不用使用块名作为前缀。 但是上面的layout (std140)是什么意思呢？它的意思是说为当前的uniform块的内容使用特定的内存布局，这个声明实际上就是在设置uniform块布局（uniform block layout）。&nbsp; Uniform块布局在主程序中对UBO的实现（或者说数据填充），依赖于着色器中uniform块的内存布局。uniform块的内存布局有四种形式：shared、packed、std140、std430（GLSL4.3以上才支持），默认是shared共享内存布局。 我们先来了解一下字节对齐的概念： 字节对齐的概念字节对齐的一个经典案例就是C语言中的结构体变量，例如下面的结构体：12345struct StructExample &#123; char c; int i; short s; &#125;; 估计他占用内存大小是多少字节？如果int占用4字节，short占用2字节，char占用1字节，那么整体大小等于1+4+2=7字节吗？ 答案是否定的。在Windows平台上测试的结果是占用12个字节。这是因为结构体里的变量存在字节对齐（或者叫字节补齐）的概念。实际上上述结构体的内存布局为：12345struct StructExample &#123; char c; // 0 bytes offset, 3 bytes padding int i; // 4 bytes offset short s; // 8 bytes offset, 2 bytes padding&#125;; // End of 12 bytes 内存布局如下图所示：字节对齐的一个重要原因是为了使机器访问更迅速。例如在32位字长的机器中，每次会读取4个字节数据，所以将字节对齐到0x0000、0x0004、0x0008、0x000C等，将使读取更加迅速。否则，如果上面的结构体里，字符c后面不填充三个字节而直接紧邻int，那么int将会跨越两个字长（0x0000和0x0004，32位机中4个字节为一个字），就需要两次读取操作，影响效率。还有一些更详细的原因，可参考SO Purpose of memory alignment。 关于字节对齐，需要记住以下几个要点： 每个基本变量的起始位置，一定是自己长度的整数倍（对齐） 对齐后的总长度必须是最长元素长度的整数倍，不够的话用额外的字节补齐 复杂类型（结构体、联合等）以其中的最长成员的长度对齐。 上面的结构体中，int变量的起始地址应该是自身长度4的整数倍，为了int类型对齐，需要在char后面填充3个字节。这样一来，char、int、short总共占了10字节，但是总长度需要是最长元素int长度4的整数倍，所以需要在末尾再补上2个字节，让总长度达到12字节。 std140的字节对齐std140内存布局同样存在字节对齐的概念，可以参考官方文档获取完整描述。常用标量int、float、bool等要求4字节对齐。4字节也被作为一个基础值N，下面是几个常用的类型的字节对齐要求：例如一个复杂的uniform块定义如下：123456789101112131415layout (std140) uniform ExampleBlock&#123; // base alignment ---------- // aligned offset float value; // 4 // 0 vec3 vector; // 16 // 16 (必须是16的倍数，因此 4-&gt;16) mat4 matrix; // 16 // 32 (第 0 行) // 16 // 48 (第 1 行) // 16 // 64 (第 2 行) // 16 // 80 (第 3 行) float values[3]; // 16 (数组中的标量与vec4相同) //96 (values[0]) // 16 // 112 (values[1]) // 16 // 128 (values[2]) bool boolean; // 4 // 144 int integer; // 4 // 148&#125;; 根据std140布局规则，使用计算出来的偏移量，我们可以用glBufferSubData这样的函数来传递数据并填充缓冲。虽然不是很高效，但std140布局可以保证在每个程序中声明的这个uniform块的布局保持一致。&nbsp; 使用uniform缓冲首先我们需要使用glGenBuffers函数创建一个uniform缓冲对象，然后绑定到GL_UNIFORM_BUFFER目标上，接着需要调用glBufferData函数来给它分配足够的内存空间：123456//创建uniform缓冲对象GLuint ubo;glGenBuffers(1, &amp;ubo);glBindBuffer(GL_UNIFORM_BUFFER, ubo);glBufferData(GL_UNIFORM_BUFFER, 150, NULL, GL_STATIC_DRAW);glBindBuffer(GL_UNIFORM_BUFFER, 0); 以后当我们打算往缓冲中更新或插入数据，我们就绑定一下该缓冲对象uboExampleBlock，并使用glBufferSubData来更新它的内存。 我们可以使用glUniformBlockBinding函数来把uniform块绑定到一个指定的绑定点上。在此之前，我们需要先用glGetUniformBlockIndex函数来获取指定着色器中uniform块的索引位置：123//把uniform块绑定到绑定点2GLuint uniform_index = glGetUniformBlockIndex(cube_shader.shaderProgram, "Matrices");glUniformBlockBinding(cube_shader.shaderProgram, uniform_index, 2); glGetUniformBlockIndex的第一个参数是着色器程序对象，第二个参数就是该着色器里的块名称。glUniformBlockBinding函数的第一个参数也是着色器程序对象，第二个参数是uniform块索引，第三个参数是绑定点。注意，我们必须对每个着色器的uniform块都要做这件事。 【注】： 从OpenGL4.2起，也可以在着色器中通过添加另一个局部标识符来存储一个uniform块的绑定点，就不用我们调用glGetUniformBlockIndex和glUniformBlockBinding了。如下所示：1layout(std140, binding = 2) uniform Lights &#123; ... &#125;; 添加一个binding标识符就能指定了uniform块的绑定点了。 然后我们还需要把uniform缓冲对象绑定到同样的绑定点上，可以使用glBindBufferBase函数或glBindBufferRange函数来完成：123glBindBufferBase(GL_UNIFORM_BUFFER, 2, uboExampleBlock);// 或者glBindBufferRange(GL_UNIFORM_BUFFER, 2, uboExampleBlock, 0, 150); 函数glBindBufferBase的第一个参数是绑定目标，这里当然是uniform缓冲；第二个参数是绑定点，第三个参数就是uniform缓冲对象。函数glBindBufferRange多了两个参数，可以指定把一定范围内的uniform缓冲绑定到一个绑定点上。所以使用glBindBufferRange函数，能够将让一个uniform缓冲对象对应多个uniform块。 最后我们可以开始想uniform缓冲中添加数据了。可以使用glBufferSubData函数来实现。例如为了更新之前那个uniform块里的boolean变量，我们可以使用下面的代码：1234glBindBuffer(GL_UNIFORM_BUFFER, uboExampleBlock);GLint b = true; // GLSL中的布尔值是4个字节，因此我们将它创建为一个4字节的整数glBufferSubData(GL_UNIFORM_BUFFER, 144, 4, &amp;b);glBindBuffer(GL_UNIFORM_BUFFER, 0); &nbsp; Demo下面我们上一个Demo，使用uniform缓冲对象。将观察矩阵view和投影矩阵projection放到uniform块中。由于模型矩阵是频繁变化的，在不同的着色器里模型矩阵的值可能不同，所以不需要把模型矩阵model也放入uniform块中。uniform块中存储着的应该是被大多数着色器共享的uniform变量，在这些着色器里的值都应该一样才行。 我们将在窗口上绘制红、绿、蓝、黄4个立方体，它们有各自的像素着色器，共用一个顶点着色器（当然也可以是4个顶点着色器，不过它们的代码是一样的）。它们的代码很简单，可参考文末的源码汇总。 写好4个立方体各自的着色器之后，我们给它们各自创建一个着色器类对象：12345//定义自定义着色器类shader的对象shader redCube_shader("cube.vertex", "redCube.fragment");shader greenCube_shader("cube.vertex", "greenCube.fragment");shader blueCube_shader("cube.vertex", "blueCube.fragment");shader yellowCube_shader("cube.vertex", "yellowCube.fragment"); 接下里我们把每个着色器程序里的uniform块Matrices绑定到绑定点2上（其他绑定点也可以）：12345678910111213//把uniform块绑定到绑定点2//红方块的uniform块GLuint uniform_index = glGetUniformBlockIndex(redCube_shader.shaderProgram, "Matrices");glUniformBlockBinding(redCube_shader.shaderProgram, uniform_index, 2);//绿方块的uniform块uniform_index = glGetUniformBlockIndex(greenCube_shader.shaderProgram, "Matrices");glUniformBlockBinding(greenCube_shader.shaderProgram, uniform_index, 2);//蓝方块的uniform块uniform_index = glGetUniformBlockIndex(blueCube_shader.shaderProgram, "Matrices");glUniformBlockBinding(blueCube_shader.shaderProgram, uniform_index, 2);//黄方块的uniform块uniform_index = glGetUniformBlockIndex(yellowCube_shader.shaderProgram, "Matrices");glUniformBlockBinding(yellowCube_shader.shaderProgram, uniform_index, 2); 还需要创建一个uniform缓冲对象，并且把它绑定到相同的绑定点2上：123456789//将uniform缓冲对象绑定到相同的绑定点2 //创建uniform缓冲对象GLuint ubo;glGenBuffers(1, &amp;ubo);glBindBuffer(GL_UNIFORM_BUFFER, ubo);glBufferData(GL_UNIFORM_BUFFER, 150, NULL, GL_STATIC_DRAW);glBindBuffer(GL_UNIFORM_BUFFER, 0); //绑定ubo到绑定点2glBindBufferBase(GL_UNIFORM_BUFFER, 2, ubo); 这样一来，每个着色器里的uniform块Matrices就都和这个uniform缓冲对象ubo连接在一起了。 然后我们就可以在渲染循环里给这个uniform缓冲对象填充数据了（使用glBufferSubData函数），也就是给uniform块的view矩阵和projection矩阵赋值：1234567//为uniform缓冲对象填充数据mat4 view = mycamera.GetViewMatrix();mat4 projection = perspective(radians(mycamera.cameraFov), (GLfloat)WIDTH / (GLfloat)HEIGHT, 0.1f, 100.0f);glBindBuffer(GL_UNIFORM_BUFFER, ubo);glBufferSubData(GL_UNIFORM_BUFFER, 0, sizeof(mat4), value_ptr(view));glBufferSubData(GL_UNIFORM_BUFFER, sizeof(mat4), sizeof(mat4), value_ptr(projection));glBindBuffer(GL_UNIFORM_BUFFER, 0); 最后当然就是绘制这4个立方体：1234567891011121314151617181920212223242526272829//绘制红绿蓝黄四个立方体//红色立方体redCube_shader.Use();mat4 model;model = translate(model, vec3(-0.75f, 0.75f, 0.0f));glUniformMatrix4fv(glGetUniformLocation(redCube_shader.shaderProgram, "model"), 1, GL_FALSE, value_ptr(model));glBindVertexArray(cubeVAO);glDrawElements(GL_TRIANGLES, 36, GL_UNSIGNED_INT, 0);//绿色立方体greenCube_shader.Use();model = mat4();model = translate(model, vec3(-0.75f, -0.75f, 0.0f));glUniformMatrix4fv(glGetUniformLocation(greenCube_shader.shaderProgram, "model"), 1, GL_FALSE, value_ptr(model));glBindVertexArray(cubeVAO);glDrawElements(GL_TRIANGLES, 36, GL_UNSIGNED_INT, 0);//蓝色立方体blueCube_shader.Use();model = mat4();model = translate(model, vec3(0.75f, 0.75f, 0.0f));glUniformMatrix4fv(glGetUniformLocation(blueCube_shader.shaderProgram, "model"), 1, GL_FALSE, value_ptr(model));glBindVertexArray(cubeVAO);glDrawElements(GL_TRIANGLES, 36, GL_UNSIGNED_INT, 0);//黄色立方体yellowCube_shader.Use();model = mat4();model = translate(model, vec3(0.75f, -0.75f, 0.0f));glUniformMatrix4fv(glGetUniformLocation(yellowCube_shader.shaderProgram, "model"), 1, GL_FALSE, value_ptr(model));glBindVertexArray(cubeVAO);glDrawElements(GL_TRIANGLES, 36, GL_UNSIGNED_INT, 0); 编译运行后的结果如下：所有源码请看这里。&nbsp; 使用uniform缓冲对象的好处uniform缓冲对象比单独的uniform有很多好处： 一次设置多个uniform比一次设置一个速度快。 如果打算改变一个横跨多个着色器的uniform，只需要在uniform缓冲中更改一次。 使用uniform缓冲对象让我们可以在着色器中使用更多的uniform。因为OpenGL对uniform缓冲对象最大个数比uniform最大个数大。&nbsp; shared共享内存布局同std140内存布局方式不一样，shared方式的内存布局依赖于具体实现，因此我们无法提前根据某种字节对齐规范计算出UBO中变量的位移偏量和整体大小，所以在使用shared方式时，我们需要多次利用OpenGL的函数来查询UBO的信息。如下面的部分程序所示：1234567891011#version 330 core// 使用默认shared​方式的UBOuniform mixColorSettings &#123; vec4 anotherColor; float mixValue;&#125;;out vec4 color;void main()&#123; color = mix(vec4(0.0, 0.0, 1.0, 1.0), anotherColor, mixValue);&#125; 123456789101112131415// 通过查询获取uniform buffer中各个变量的索引和位移偏量const GLchar* names[] = &#123; "anotherColor", "mixValue"&#125;;GLuint indices[2];glGetUniformIndices(redShader.programId, 2, names, indices);GLint offset[2];glGetActiveUniformsiv(redShader.programId, 2, indices, GL_UNIFORM_OFFSET, offset);// 使用获取的位移偏量更新数据glm::vec4 anotherColor = glm::vec4(0.0f, 1.0f, 1.0f, 1.0f);GLfloat mixValue = 0.5f;glBindBuffer(GL_UNIFORM_BUFFER, colorUBOId);glBufferSubData(GL_UNIFORM_BUFFER, offset[0], sizeof(glm::vec4), glm::value_ptr(anotherColor));glBufferSubData(GL_UNIFORM_BUFFER, offset[1], sizeof(glm::vec4), &amp;mixValue);glBindBuffer(GL_UNIFORM_BUFFER, 0); &nbsp; 参考文献：LearnOpenGL]]></content>
  </entry>
  <entry>
    <title><![CDATA[OpenGL21：缓冲对象及其相关函数]]></title>
    <url>%2F2017%2F01%2F23%2FOpenGL21%E7%BC%93%E5%86%B2%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[缓冲对象的概念在OpenGL中，缓冲对象（buffer object）是OpenGL的绘制上下文，是GPU分配的，完成未格式化数据区域的存储，例如完成顶点数据、帧缓冲数据的存储。 缓冲对象中的数据实际上就是原始的字节流，例如我们在程序中指定顶点属性数据，然后使用glBufferData这个函数将数据从CPU传送至GPU中，这一步只完成了数据的上传，关于这份数据，OpenGL是不知道其具体格式的，因此在实际使用中还必须告诉OpenGL如何具体使用这些数据，这是通过glVertexAttribPointer这样的函数来完成的。 每个缓冲对象，必须绑定到一个具体的目标（target）后，OpenGL才知道如何具体操作这个缓冲对象，例如绑定到GL_ARRAY_BUFFER，OpenGL使用这个缓冲对象作为顶点属性数据；例如绑定到GL_ELEMENT_ARRAY_BUFFER，则OpenGL使用这个缓冲对象的数据作为索引绘图的索引数据。 缓冲对象的数据，也存在读写、复制、清除等操作，同时缓存对象在适当时候也可以使用glDeleteBuffers这类函数释放。&nbsp; 数据从CPU传递到GPU内存的函数把数据从CPU传递到GPU的函数有：glBufferData函数、glBufferSubData函数、glMapBuffer和memcpy函数。 glBufferData函数函数原型为：glBufferData(GLenum target, GLsizeiptr size, const void* data, GLenum usage) glBufferData函数可以把数据从CPU传递到GPU，并且能够在GPU上开辟一块大小等于其第二个参数的内存，然后把来自CPU的数据存储到这片内存里。如果第三个参数data传递的是NULL，那么OpenGL只会帮我们分配内存，而不会填充它。这对后面的glBufferSubData函数很有用。 glBufferSubData函数函数原型为：glBufferSubData(GLenum targrt, GLintptr offset, GLsizeiptr size, const void* data) glBufferSubData函数也可以把数据从CPU传递到GPU，但是它不会再GPU上开辟内存，所以在调用该函数之前，必须调用glBufferData函数分配好足够的内存，然后该函数才能把来自CPU的数据放到这片内存的指定位置。 glBufferData函数是从开辟的内存的起始地址开始，把所有数据一次性地填充到这片内存里，而glBufferSubData函数是从开辟的内存的offset位置开始，把数据填充到这片内存的指定位置上，只要不越界就可以（不超过开辟的内存的结束地址）。例如：1glBufferSubData(GL_ARRAY_BUFFER, 24, sizeof(data), &amp;data); // 范围： [24, 24 + sizeof(data)] glMapBuffer和memcpy函数使用glMapBuffer函数可以返回一个当前绑定缓冲的内存的地址，是一个指针，我们可以把这个返回的内存地址作为memcpy函数的参数，从而把数据传递到该内存地址所指定的位置：1234567glBindBuffer(GL_ARRAY_BUFFER, buffer);// 获取当前绑定缓存buffer的内存地址void* ptr = glMapBuffer(GL_ARRAY_BUFFER, GL_WRITE_ONLY);// 向缓冲中写入数据memcpy(ptr, data, sizeof(data));// 完成够别忘了告诉OpenGL我们不再需要它了glUnmapBuffer(GL_ARRAY_BUFFER); 别忘了调用glUnmapBuffer函数告诉OpenGL我们已经用完指针了，需要解映射，这样这个地址指针将不再可用。 把数据直接映射到缓冲区上使用glMapBuffer很有用，因为它不用把它存储在临时内存里，可以从文件读取数据然后直接复制到缓冲的内存里。而glBufferData和glBufferSubData是需要先开辟临时内存，再存储到对应的缓冲内存里。&nbsp; 分批处理顶点数据使用glVertexAttribPointer函数可以指定缓冲中顶点数组的属性的布局（layout）。我们之前一直是把顶点属性交叉存放在顶点数组里的，比如123123123123这种交叉布局，这个时候是使用glBufferData函数来传递数据，，而且每种属性下glVertexAttribPointer函数的步长参数stride应该设置为sizeof(123)，即所有属性大小之和。注：1、2、3可能还是几个GL_FLOAT大小。 其实我们还可以把顶点属性连续放置，比如111222333这种批量方式，这时传递数据应该使用glBufferSubData函数了，使用该函数指定每种属性的起始位置和该属性的所有数据大小。示例如下：1234567GLfloat positions[] = &#123; ... &#125;;GLfloat normals[] = &#123; ... &#125;;GLfloat tex[] = &#123; ... &#125;;// 填充缓冲glBufferSubData(GL_ARRAY_BUFFER, 0, sizeof(positions), &amp;positions);glBufferSubData(GL_ARRAY_BUFFER, sizeof(positions), sizeof(normals), &amp;normals);glBufferSubData(GL_ARRAY_BUFFER, sizeof(positions) + sizeof(normals), sizeof(tex), &amp;tex); 在使用glVertexAttribPointer函数解析顶点数据时，每种属性下的步长就应该是对应属性的GL_FLOAT大小了。而且偏移量应该是批量属性开始的位置，不再像是交叉属性在第一组里的偏移量：1234glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(GLfloat), 0); glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(GLfloat), (GLvoid*)(sizeof(positions))); glVertexAttribPointer( 2, 2, GL_FLOAT, GL_FALSE, 2 * sizeof(GLfloat), (GLvoid*)(sizeof(positions) + sizeof(normals))); 当然，选用哪种方式全凭喜好了，效率上没有多大区别。&nbsp; 复制缓冲当我们的缓冲被数据填充以后，可能打算让其他缓冲也能够分享这些数据或者打算把缓冲的内容复制到另一个缓冲里。glCopyBufferSubData函数让我们能够相对容易地把一个缓冲里的数据复制到另一个缓冲里。函数原型如下：1void glCopyBufferSubData(GLenum readtarget, GLenum writetarget, GLintptr readoffset, GLintptr writeoffset, GLsizeiptr size); readtarget和writetarget是复制的来源缓冲目标和目的缓冲目标，例如我们可以从VERTEX_ARRAY_BUFFER复制到VERTEX_ELEMENT_ARRAY_BUFFER。该函数的意思就是从源目标readtarget缓冲的readoffset位置开始，复制size大小的数据到目的目标writetarget缓冲的writeoffset位置开始的内存区里。 但是如果我们的源和目的都是顶点数组缓冲(GL_VERTEX_ARRAY_BUFFER)怎么办？我们显然不能把源和目的都设置为它。为此，OpenGL 给我们设了额外的两个缓冲目标：GL_COPY_READ_BUFFER和GL_COPY_WRITE_BUFFER。这时我们可以使用下面的代码来实现两个顶点数组缓冲之间的数据复制：1234GLfloat vertexData[] = &#123; ... &#125;;glBindBuffer(GL_COPY_READ_BUFFER, vbo1);glBindBuffer(GL_COPY_WRITE_BUFFER, vbo2);glCopyBufferSubData(GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, 0, 0, sizeof(vertexData)); 也可以只把目标缓冲设为GL_COPY_WRITE_BUFFER，如下代码：1234GLfloat vertexData[] = &#123; ... &#125;;glBindBuffer(GL_ARRAY_BUFFER, vbo1);glBindBuffer(GL_COPY_WRITE_BUFFER, vbo2);glCopyBufferSubData(GL_ARRAY_BUFFER, GL_COPY_WRITE_BUFFER, 0, 0, sizeof(vertexData)); 下一篇文章里我们将会讨论uniform缓冲对象，到时候我们会充分利用glBufferSubData函数。&nbsp; 参考文献：LearnOpenGL]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>缓冲对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenGL20：立方体贴图]]></title>
    <url>%2F2017%2F01%2F22%2FOpenGL20%E7%AB%8B%E6%96%B9%E4%BD%93%E8%B4%B4%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[立方体贴图概念及采样方法立方体贴图包含6个2D纹理，每个2D纹理是立方体的一个面，也就是说它是一个有贴图的立方体。使用立方体贴图可以实现很多有意思的效果，比如天空盒、环境映射等等。 对于2D纹理，可以通过纹素的2D坐标来采样，那么立方体纹理怎样采样呢？它的采样方式类似下图：如果立方体的中心位于原点上，那么可以通过原点到立方体表面片段的向量来采样，如上图中的橘黄色向量。也就是说，我们可以直接使用片段的位置向量（或者说片段坐标）来进行采样，在顶点着色器里将片段的位置坐标直接赋值给输出变量纹理坐标：1234void main()&#123; gl_Position = position; TexCoords = position;&#125; 利用(s,t,r)采样时，首先根据(s,t,r)中模最大的分量决定在哪个面采样，然后使用剩下的2个坐标在对应的面上做2D纹理采样。例如，如果(s,t,r)中s分量的模最大，且符号为正，则决定选取+x面作为采样的2D纹理，然后使用(t,r)坐标在+x面上做2D纹理采样。 这6个面在OpenGL中指定如下：这几个枚举常量其实是连续的，可以循环遍历，在OpenGL中它们定义如下：123456#define GL_TEXTURE_CUBE_MAP_POSITIVE_X 0x8515#define GL_TEXTURE_CUBE_MAP_NEGATIVE_X 0x8516#define GL_TEXTURE_CUBE_MAP_POSITIVE_Y 0x8517#define GL_TEXTURE_CUBE_MAP_NEGATIVE_Y 0x8518#define GL_TEXTURE_CUBE_MAP_POSITIVE_Z 0x8519#define GL_TEXTURE_CUBE_MAP_NEGATIVE_Z 0x851A &nbsp; 创建立方体贴图既然立方体贴图有6个纹理，那么我们需要把这6张纹理都加载进来，生成一个最终的立方体纹理贴图。我们把这部分代码写入自定义类CubemapLoader的loadCubemap方法中： 首先，创建立方体贴图对象和创建普通纹理一样，只是绑定目标变成了GL_TEXTURE_CUBE_MAP：123GLuint cubemap;glGenTextures(1, &amp;cubemap);glBindTexture(GL_TEXTURE_CUBE_MAP, cubemap); 接下来我们加载立方体贴图的6张纹理：123456int width, height;unsigned char* image;for (int i = 0; i &lt; facePaths.size(); i++) &#123; image = SOIL_load_image(facePaths[i], &amp;width, &amp;height, 0, SOIL_LOAD_RGB); glTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, image);&#125; 其中facePaths是函数loadCubemap的参数，指明6张纹理的路径。在使用glTexImage2D函数生成纹理时，目标应该是具体的立方体的某个面。由于立方体的每个面都有一个常数来表示，而且是连续的，所以我们就用GL_TEXTURE_CUBE_MAP_POSITIVE_X和迭代遍历i来循环遍历了。 接着需要设置立方体纹理贴图的参数，环绕方式和过滤方式设置如下：12345glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR);glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_LINEAR); 将立方体贴图在S、T、R方向上的环绕方式设为了GL_CLAMP_TO_EDGE，这是指明当(s,t,r)坐标没有落在哪个面，而是落在两个面之间时，采样为边缘的纹理值。 完整的CubemapLoader类可见后面的源码。&nbsp; 立方体贴图应用之天空盒我们之前的场景背景一直都是用的glClearColor，现在我们想让场景的背景是一片天空。而立方体贴图完全满足这个要求，我们在场景中绘制一个使用cubemap纹理的立方体，将这个立方体总是置于场景外围，让玩家感觉好像场景很长大，触不可及像天空一样，但是实际上他还是在一个小盒子中。我们要用到的天空盒子贴图可在这里下载。 天空盒也是一个立方体，当然也需要为它设置顶点属性，VAO以及顶点数据解析。顶点数据如下，其它的可参考后面的主程序源码：12345678910111213141516171819202122232425262728293031323334//天空盒的顶点坐标GLfloat skyboxVertices[] = &#123; //位置坐标 //立方体前面 1.0f, 1.0f, 1.0f, 1.0f,-1.0f, 1.0f, -1.0f,-1.0f, 1.0f, -1.0f, 1.0f, 1.0f, //立方体后面 1.0f, 1.0f,-1.0f, 1.0f,-1.0f,-1.0f, -1.0f,-1.0f,-1.0f, -1.0f, 1.0f,-1.0f, //立方体上面 1.0f, 1.0f, 1.0f, 1.0f, 1.0f,-1.0f, -1.0f, 1.0f,-1.0f, -1.0f, 1.0f, 1.0f, //立方体下面 1.0f,-1.0f, 1.0f, 1.0f,-1.0f,-1.0f, -1.0f,-1.0f,-1.0f, -1.0f,-1.0f, 1.0f, //立方体右面 1.0f, 1.0f, 1.0f, 1.0f, 1.0f,-1.0f, 1.0f,-1.0f,-1.0f, 1.0f,-1.0f, 1.0f, //立方体左面 -1.0f, 1.0f, 1.0f, -1.0f, 1.0f,-1.0f, -1.0f,-1.0f,-1.0f, -1.0f,-1.0f, 1.0f&#125;; 这里我们让这个天空盒的坐标绝对值都取为1，好让它填充满整个窗口。 然后我们生成天空盒的立方体贴图，需要加载6个纹理：12345678910//立方体贴图的6个纹理的路径vector&lt;const GLchar*&gt; facePaths;facePaths.push_back("skybox/right.jpg");facePaths.push_back("skybox/left.jpg");facePaths.push_back("skybox/top.jpg");facePaths.push_back("skybox/bottom.jpg");facePaths.push_back("skybox/back.jpg");facePaths.push_back("skybox/front.jpg");CubemapLoader cubemapLoader;GLuint cubemap = cubemapLoader.loadCubemap(facePaths); 要画出这个天空盒，我们还需要给它写顶点着色器（写在cubemap.vertex中）和像素着色器（写在cubemap.fragment中）：1234567891011#version 330 corelayout (location=0) in vec3 position;out vec3 TexCoords;uniform mat4 view;uniform mat4 projection;void main()&#123; gl_Position = projection * view * vec4(position,1.0f); TexCoords = position;&#125; 天空盒子不需要从模型坐标系到世界坐标系的平移、旋转、缩放，所以这里就没有写model矩阵。其实OpenGL是会自动给乘上一个model单位矩阵的。我们还让纹理坐标直接等于片段的位置坐标，因为此时的天空盒子中心是在原点的，可以直接使用片段的位置向量作为采样向量。注意纹理坐标是3维的。123456789#version 330 corein vec3 TexCoords;out vec4 color;uniform samplerCube cubemap;void main()&#123; color = texture(cubemap,TexCoords);&#125; 像素着色器很简单，直接让片段最终颜色等于立方体贴图采样的纹素颜色就可以。 当然，肯定还需要给天空盒子定义一个着色器类对象：1shader skybox_shader("cubemap.vertex", "cubemap.fragment"); 接下来我们在渲染循环里绘制这个天空盒子。在绘制天空盒子之前，我们需要关闭面剔除，否则天空盒子不会显示，因为我们现在是正处于天空盒子内部的，如果不关闭面剔除，它的每个面都将被剔除掉；而且还要禁用深度写入，否则场景中的其他物体都会被天空盒子覆盖掉，其他物体将不能通过深度测试而被抛弃：123//Draw skyboxglDisable(GL_CULL_FACE);glDepthMask(GL_FALSE); 接下来就是和绘制普通立方体一样，来绘制天空盒了：12345678910skybox_shader.Use();mat4 view = mycamera.GetViewMatrix();mat4 projection = perspective(radians(mycamera.cameraFov), (GLfloat)WIDTH / (GLfloat)HEIGHT, 0.1f, 100.0f);glUniformMatrix4fv(glGetUniformLocation(skybox_shader.shaderProgram, "view"), 1, GL_FALSE, value_ptr(view));glUniformMatrix4fv(glGetUniformLocation(skybox_shader.shaderProgram, "projection"), 1, GL_FALSE, value_ptr(projection));glBindVertexArray(skyboxVAO);glBindTexture(GL_TEXTURE_CUBE_MAP, cubemap);glDrawElements(GL_TRIANGLES, 36, GL_UNSIGNED_INT, 0);glDepthMask(GL_TRUE);glEnable(GL_CULL_FACE); 后面再照常绘制其他物体就可以了。 编译运行后的结果如下：移动摄像机，会发现天空盒子也会跟着移动，给人的感觉确实就是个盒子，而不是一片浩瀚的天空。要解决这个问题，我们需要让天空盒子不会随着摄像机移动而移动。天空盒子之所以会移动，是因为在它的顶点着色器中顶点坐标乘上了观察矩阵view，这个观察矩阵是随着摄像机移动而改变的。我们可以去掉观察矩阵的平移部分，把4x4的矩阵改成3x3即可（线性代数知识）。我们在主程序中完成这个操作，然后把新的观察矩阵发送给顶点着色器：12mat4 view = mat4(mat3(mycamera.GetViewMatrix()));glUniformMatrix4fv(glGetUniformLocation(skybox_shader.shaderProgram, "view"), 1, GL_FALSE, value_ptr(view)); 这样编译运行后的结果就正常了：&nbsp; 优化上面再绘制天空包围盒时，我们首先禁用了深度缓冲写入，再绘制包围盒，让它处于场景外围，这样做虽然能正常工作，缺点是如果场景中有的物体挡住了天空，按照上面的绘制方式，这部分被挡住的天空还是被绘制了，只是后来又被其他物体（比如场景中的箱子）覆盖了，这导致了不必要的着色器调用，是一种性能上的损失。 所以，绘制天空盒时，我们还是得允许深度写入。但是我们想办法让天空盒的深度最大（1.0），因为它是最外围的。如果有物体挡住了它，被遮挡住的天空盒部分将无法通过深度测试，会被丢弃。那么如何让天空盒的每一个片段的深度值都等于1.0呢？我们在天空盒的顶点着色器中做如下操作：12345void main()&#123; vec4 pos = projection * view * vec4(position,1.0f); gl_Position = pos.xyww; TexCoords = position;&#125; 我们把顶点坐标的z值改成了w。正如我们以前就知道的，z值代表了该片段的深度值。在投影变换之后OpenGL会进行透视除法，顶点的x、y、z都会去除以w，因为我们把z值变成了w，所以透视除法的结果就是每个顶点的z值都变成了1.0。 注意这时我们应该改变一下通过深度测试的条件：应该是小于等于时通过深度测试，而不是默认的小于，否则下一次渲染循环的天空深度值因为等于1.0，和深度缓冲的深度值里一样，将会被丢弃，导致天空无法显示出来：12//深度测试函数glDepthFunc(GL_LEQUAL); 所有源码在这里。&nbsp; 环境映射我们使用立方体贴图能够渲染的不只是天空盒，可以是任何大环境，比如一个山谷、一个空间内部等等。我们可以利用这些带有场景的立方体贴图，让物体可以反射或折射周围的环境。像这样使用了环境立方体贴图的技术叫做环境贴图技术，其中最重要的是反射和折射。由于我们着重关注怎么让物体反射和折射环境，所以我们还是使用之前的天空盒，让箱子反射和折射天空。 反射反射是一个物体（或物体的，某部分）反射（Reflect）它周围环境的属性，比如物体的颜色多少有些等于它周围的环境，这要基于观察者的角度。 下图展示了如何计算反射向量，然后使用这个反射向量去立方体贴图中采样：计算反射向量的方法已经在《OpenGL10：光照基础Phong模型》 里讲过了，原理很简单，我们直接上代码：12345678910111213#version 330 corein vec3 Normal;in vec3 PositionInWorld;out vec4 color;uniform vec3 cameraPos;uniform samplerCube cubemap;void main()&#123; vec3 I = normalize(PositionInWorld - cameraPos); vec3 R = reflect(I,normalize(Normal)); color = texture(cubemap,R);&#125; 对应的顶点着色器为：123456789101112131415#version 330 corelayout (location=0) in vec3 position;layout (location=1) in vec3 normal;out vec3 Normal;out vec3 PositionInWorld;uniform mat4 model;uniform mat4 view;uniform mat4 projection;void main()&#123; gl_Position = projection * view * model * vec4(position,1.0f); Normal = mat3(transpose(inverse(model))) * normal; PositionInWorld = vec3(model * vec4(position,1.0f));&#125; 既然要用到法线向量，那还得给立方体顶点添加法线数据：12345678910111213141516171819202122232425262728293031323334//立方体顶点的坐标、法线向量GLfloat cubeVertices[] = &#123; //位置坐标 //法线 //立方体前面 0.5f, 0.5f, 0.5f, 0, 0, 1, 0.5f,-0.5f, 0.5f, 0, 0, 1, -0.5f,-0.5f, 0.5f, 0, 0, 1, -0.5f, 0.5f, 0.5f, 0, 0, 1, //立方体后面 0.5f, 0.5f,-0.5f, 0, 0,-1, 0.5f,-0.5f,-0.5f, 0, 0,-1, -0.5f,-0.5f,-0.5f, 0, 0,-1, -0.5f, 0.5f,-0.5f, 0, 0,-1, //立方体上面 0.5f, 0.5f, 0.5f, 0, 1, 0, 0.5f, 0.5f,-0.5f, 0, 1, 0, -0.5f, 0.5f,-0.5f, 0, 1, 0, -0.5f, 0.5f, 0.5f, 0, 1, 0, //立方体下面 0.5f,-0.5f, 0.5f, 0,-1, 0, 0.5f,-0.5f,-0.5f, 0,-1, 0, -0.5f,-0.5f,-0.5f, 0,-1, 0, -0.5f,-0.5f, 0.5f, 0,-1, 0, //立方体右面 0.5f, 0.5f, 0.5f, 1, 0, 0, 0.5f, 0.5f,-0.5f, 1, 0, 0, 0.5f,-0.5f,-0.5f, 1, 0, 0, 0.5f,-0.5f, 0.5f, 1, 0, 0, //立方体左面 -0.5f, 0.5f, 0.5f, -1, 0, 0, -0.5f, 0.5f,-0.5f, -1, 0, 0, -0.5f,-0.5f,-0.5f, -1, 0, 0, -0.5f,-0.5f, 0.5f, -1, 0, 0&#125;; 当然，对应的数据解析也得作调整了，不再赘述。环境反射的所有源码在这里。 编译运行后的结果如下：可以看到我们得到了一个镜子一样的箱子，完美地反射了周围的天空盒。如果是球模型，会更明显： 折射环境映射的另一个形式是折射。如下图所示：我们可以通过折射向量R来从立方体贴图上采样。 折射可以通过GLSL的内置函数refract来计算，它需要3个参数：观察向量、法线向量、折射指数：1234567void main()&#123; //折射 float ratio = 1.00/1.52; vec3 I = normalize(PositionInWorld - cameraPos); vec3 R = refract(I,normalize(Normal),ratio); color = texture(cubemap,R);&#125; 折射指数决定了一个材质上光线扭曲的数量，每个材质都有自己的折射指数。下表是常见的折射指数：编译运行后的结果如下：环境折射的所有源码在这里。&nbsp; 动态环境贴图现在我们的环境立方体贴图还只是静态的。但是如果我们有个镜子一样的物体，它周围有多个物体，当移动摄像机或者移动镜子物体时，它所反射/折射的环境应该是变化挺大的，用静态的立方体贴图显然不够逼真。 可以使用帧缓冲为镜子物体的所有6个不同角度创建一个场景的纹理，把它们每次渲染迭代存储为一个立方体贴图。之后我们可以使用这个（动态生成的）立方体贴图来创建真实的反射和折射表面。这种方法叫做动态环境映射（Dynamic Environment Mapping），因为我们动态地创建了一个物体的以其四周为参考的立方体贴图，并把它用作环境贴图。 这种方法看起来效果很好，但是有一个缺点：我们必须为每个物体渲染场景6次，这需要非常大的开销。我们还是应该尽量使用静态的天空盒子，尽量减少动态环境贴图的使用。想要在不降低执行效率的情况下实现动态环境贴图还需要很多巧妙的技巧。&nbsp; 参考文献：LearnOpenGL]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>天空盒子</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenGL19：帧缓冲]]></title>
    <url>%2F2017%2F01%2F21%2FOpenGL19%E5%B8%A7%E7%BC%93%E5%86%B2%2F</url>
    <content type="text"><![CDATA[颜色缓冲、深度缓冲、模板缓冲统称帧缓冲。到目前为止，我们在使用OpenGL渲染时，最终的目的地都是默认的帧缓冲区，实际上OpenGL也允许我们创建自定义的帧缓冲区。使用自定义的帧缓冲区，可以实现镜面、离屏渲染，以及很酷的后处理效果。&nbsp; 帧缓冲FBO概念在OpenGL中，渲染管线中的顶点、纹理等经过一系列处理后，最终显示在2D屏幕上，渲染管线的最终目的地就是帧缓冲区。帧缓冲包括颜色缓冲区、深度缓冲区、模板缓冲区。默认的缓冲区由窗口系统创建，例如我们一直使用GLFW库来完成这项任务。这个默认的帧缓冲区，就是目前我们一直使用的绘图命令的作用对象， 称之为窗口系统提供的帧缓冲区。 OpenGL也允许我们手动创建一个帧缓冲区，并将渲染结果重定向到这个缓冲区。在创建时允许我们自定义帧缓冲区的一些特性，这个自定义的帧缓冲区，称之为应用程序帧缓冲区。 和默认的帧缓冲区一样，自定义的帧缓冲区也包含颜色缓冲、深度和模板缓冲，这些逻辑上的缓冲区在FBO中称之为附件（可附加的文件，Attachment），它们是可以附加到FBO的数组内存空间。 FBO中包含两种类型的附件：纹理图像、渲染缓冲（renderbuffer）对象。之所以用附加这个词，表达的是FBO可以附加多个缓冲区，而且可以灵活地在缓冲区间切换，一个重要的概念是附加点（其实就是指针）。FBO中可以包含多个颜色附加点，但只能有一个深度和模板附加点，如下图所示：从图中可以看到FBO本身并不包含任何缓冲对象，实际上是通过附加点指向实际缓冲对象的。这样FBO就可以快速地切换缓冲对象。&nbsp; 创建帧缓冲FBO和创建其他缓冲对象一样，使用glGenFramebuffers函数创建FBO如下：123//创建FBOGLuint fbo;glGenFramebuffers(1, &amp;fbo); 然后我们需要将创建的fbo绑定到目标对象（读帧缓冲/写帧缓冲/读写帧缓冲）：1glBindFramebuffer(GL_FRAMEBUFFER, fbo); 绑定到目标GL_FRAMEBUFFER后，接下来所有的读、写帧缓冲操作都会影响到当前绑定的帧缓冲，并且该缓冲区可以执行读和写操作。绑定的目标还可以是GL_READ_FRAMEBUFFER，这时该帧缓冲区只能执行读操作，比如glReadPixels；目标还可以是GL_DRAW_FRAMEBUFFER，这时该帧缓冲区允许进行渲染、清空等等写入操作。大多数时候我们都用的GL_FRAMEBUFFER。 构建一个完整的帧缓冲FBO必须满足以下条件： 至少附加一个附件（或者说缓冲区，就是颜色、深度、模板缓冲等） 至少有一个颜色附件 所有的附件必须完整（预分配了内存） 每个缓冲区的采样数需要一致 从上面可以看到，我们需要为帧缓冲创建一些附件，还需要把这些附件添加到帧缓冲上。当我们做完上面的所有条件后，我们可以使用glCheckFramebufferStatus函数来检查FBO是否完整：12if(glCheckFramebufferStatus(GL_FRAMEBUFFER) == GL_FRAMEBUFFER_COMPLETE) ... 后续的所有渲染操作将渲染到当前绑定的帧缓冲所附加的对应缓冲中。由于我们这里的帧缓冲是自己创建的，不是默认的帧缓冲，渲染命令对窗口的视频输出不会产生任何影响，所以称为离屏渲染（off-screen rendering）。为了让所有的渲染操作对主窗口产生影响，我们必须在最后通过绑定帧缓冲到0（即默认帧缓冲），来激活默认帧缓冲，才能才窗口上实现最终的绘制效果：1glBindFramebuffer(GL_FRAMEBUFFER, 0); &nbsp; 前面提到了，我们需要把一个或多个附件附加到帧缓冲上。一个附件其实就是一个指向颜色缓冲（或深度缓冲、或模板缓冲）的指针。有两张类型的附件（缓冲区）：纹理、渲染缓冲对象。 附件：纹理当把一个纹理附加到帧缓冲上的时候，所有渲染命令会写入到该纹理上，就像它是一个普通的颜色/深度/模板缓冲一样。使用纹理的好处是，所有渲染操作的结果都会被存储为一个纹理图像，这样我们就可以在着色器中访问并使用这个渲染出来的纹理，可以实现很多特效。 创建一个用于附加到帧缓冲的纹理，和创建普通纹理差不多：1234567//创建纹理附件GLuint texAttachment;glGenTextures(1, &amp;texAttachment);glBindTexture(GL_TEXTURE_2D, texAttachment);glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, NULL);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); 主要区别是： 我们把纹理大小设置为渲染窗口的大小。因为后边把这张纹理绘入到默认帧缓冲里，让这张纹理铺满整个渲染窗口，以达到和只使用默认帧缓冲一样的效果 在glTexImage2D函数中，传入NULL作为纹理的data数据。因为我们只需要分配内存，不会用加载的纹理数据去填充它，纹理填充会在渲染到帧缓冲的时候自动完成。 不用关心环绕方式和Mipmap。因为在作为帧缓冲的纹理附件时，大多数时候都不需要它们。 【注】： 如果打算渲染到一个当前渲染窗口大一点或者小一点的纹理上，需要使用glViewport函数调整当前的渲染窗口。因为最好让渲染窗口和纹理附件尺寸大小一致。 创建完纹理附件后，还需要把它附加到帧缓冲上：12345678910111213141516 //将纹理附件附加到帧缓冲上 glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, texAttachment, 0);``` 该函数参数说明如下： - 第一个参数target：我们所创建的帧缓冲类型（读/写/读写的帧缓冲）。- 第二个参数attachment：指明我们所要附加的附件类型。这里我们附加的是一个颜色附件。后面那个0表示我们可以附加1个以上的颜色附件。- 第三个参数textarget：指明希望附加的纹理类型- 第四个参数level：指明多级渐远纹理的层级，这里设置为0就可以。除了可以把纹理附件附加为帧缓冲的颜色缓冲外，还可以作为深度缓冲和模板缓冲。如果是要附加为深度缓冲，需要把`glFramebufferTexture2D`函数的第二个参数附件类型指定为`GL_DEPTH_ATTACHMENT`，而且用`glTexImage2D`函数生成纹理时，纹理格式和内部格式不再是`GL_RGB`了，而是`GL_DEPTH_COMPONENT`，这样才可以存储为深度缓冲所需要的存储格式；如果是要附加为模板缓冲，需要把附件类型指定为`GL_STENCIL_ATTACHMENT`，把纹理格式和内部格式指定为`GL_STENCIL_INDEX`。还可以把纹理附件同时作为帧缓冲的深度缓冲和模板缓冲。这样纹理的每32位数值就包含了24位的深度信息和8位的模板信息，这时需要把附件类型指定为`GL_DEPTH_STENCIL_ATTACHMENT`，生成纹理时内部格式应该指定为`GL_DEPTH24_STENCIL8`，纹理格式应该设置为`GL_DEPTH_STENCIL`，如下所示：```c++glTexImage2D( GL_TEXTURE_2D, 0, GL_DEPTH24_STENCIL8, 800, 600, 0, GL_DEPTH_STENCIL, GL_UNSIGNED_INT_24_8, NULL );glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_TEXTURE_2D, texture, 0); &nbsp; 附件：渲染缓冲对象除了纹理附件，另外一种附件是渲染缓冲对象。和纹理图像一样，渲染缓冲对象也是一个缓冲，它可以是一堆字节、整数、像素或者其他东西。渲染缓冲对象的一大优点是：它以OpenGL原生渲染格式存储它的数据，因此在离屏渲染到帧缓冲的时候，这些数据就相当于被优化过的了。 渲染缓冲对象将所有渲染数据直接存储到它们的缓冲里，而不会进行针对特定纹理格式的任何转换，这样它们就成了一种可快速可写的存储介质了。然而，渲染缓冲对象是只写的，不能修改它们（就是只能写一次，后面不能再修改了）。可以用glReadPixels函数去读取。 因为它所存储的数据已经是原生格式了，在写入或把它们的数据简单地拷贝到其他缓冲的时候会非常快。所以使用渲染缓冲对象时，像切换缓冲这种操作会变得异常高速。我们在每个渲染循环末尾使用的那个glfwSwapBuffers函数，同样可以缓冲对象实现：我们简单地写入到一个渲染缓冲对象，最后交换到另一个里。渲染缓冲对象对于这种切换缓冲的操作来说很完美。 创建渲染缓冲对象创建渲染缓冲对象和创建一般的缓冲对象类似：12GLuint rbo;glGenRenderbuffers(1, &amp;rbo); 接下来需要绑定到渲染缓冲上，这样所有后续渲染操作都会影响到当前绑定的渲染缓冲对象：1glBindRenderbuffer(GL_RENDERBUFFER, rbo); 大多数时候，我们不需要从深度和模板缓冲中读取数据，不需要进行采样，只要能进行深度和模板测试就可以，而渲染缓冲对象通常是只写的，所以它经常作为深度和模板附件来使用，优点是它们等于是被优化过的。 我们可以调用glRenderbufferStorage函数为rbo预分配内存空间，这里把rbo存储为24位深度缓冲和8位模板缓冲的格式：1glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH24_STENCIL8, 800, 600); 【注】： 渲染缓冲对象是专门被设计用于图像的，而不是通用目的的数据缓冲。 最后需要把帧缓冲对象附件附加到帧缓冲上：1glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_RENDERBUFFER, rbo); 在帧缓冲项目中，渲染缓冲对象可以提供一些优化，但更重要的是知道何时使用渲染缓冲对象，何时使用纹理附件。通常的规则是：如果永远都不需要从特定的缓冲中进行采样，渲染缓冲对象对特定缓冲是更明智的选择；如果需要从比如颜色或深度这样的特定缓冲中采样数据的话，最好还是使用纹理附件。&nbsp; 渲染到纹理现在我们来上个demo，把场景渲染到一个颜色纹理上（这个纹理是附加到我们创建的帧缓冲上的），然后我们把纹理绘制到一个简单的四边形上（这个四边形铺满整个屏幕）。最后输出的图像看似和没用帧缓冲一样，但是其实是直接输出到了一个单独的四边形上面。后面会看到这样做的好处。 首先，我们需要创建一个帧缓冲对象，并绑定它：1234//创建FBOGLuint fbo;glGenFramebuffers(1, &amp;fbo);glBindFramebuffer(GL_FRAMEBUFFER, fbo); 接下来创建一个纹理附件，它将附加为帧缓冲的颜色缓冲：12345678910//创建纹理附件GLuint texColorBuffer;glGenTextures(1, &amp;texColorBuffer);glBindTexture(GL_TEXTURE_2D, texColorBuffer);glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, NULL);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);glBindTexture(GL_TEXTURE_2D, 0);//将纹理附件附加到帧缓冲上glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, texColorBuffer, 0); 我们还想让OpenGL可以进行深度测试和模板测试，所以我们还需要向帧缓冲中添加一个深度和模板附件。由于我们只采样颜色缓冲，并不采样深度缓冲，所以深度附件可以用渲染缓冲对象来实现。 创建并绑定渲染缓冲对象，同时预分配内存空间：123456//创建渲染缓冲对象GLuint rbo;glGenRenderbuffers(1, &amp;rbo);glBindRenderbuffer(GL_RENDERBUFFER, rbo);glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH24_STENCIL8, width, height);glBindRenderbuffer(GL_RENDERBUFFER, 0); 然后需要把渲染缓冲对象附加到帧缓冲上：12//将渲染缓冲对象附加到帧缓冲上glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_RENDERBUFFER, rbo); 接下里我们检查一下帧缓冲是否真的做完整了，如果没有就打印一个错误消息：1234//检查帧缓冲是否完整if (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE) &#123; std::cout &lt;&lt; "Framebuffer is not complete!" &lt;&lt; std::endl;&#125; 接着我们就可以把场景渲染到我们所创建的帧缓冲上了。一般按照以下步骤来做： 绑定帧缓冲为我们所创建的帧缓冲对象，好场景渲染到我们自己的帧缓冲里。 像往常那样渲染场景 绑定帧缓冲到默认帧缓冲（就是绑定为0） 绘制一个四边形，让它平铺到整个屏幕上，使用前面渲染出来的纹理附件（也就是我们的帧缓冲里的颜色缓冲）作为这个四边形的纹理。 为了绘制出铺满窗口的四边形，我们先定义四边形的顶点属性如下：1234567891011//窗口四边形的顶点坐标、纹理坐标GLfloat windowQuadVertices[] = &#123; //位置坐标 1.0f, 1.0f, 1.0f,1.0f, 1.0f,-1.0f, 1.0f,0.0f, -1.0f, 1.0f, 0.0f,1.0f, -1.0f, 1.0f, 0.0f,1.0f, 1.0f,-1.0f, 1.0f,0.0f, -1.0f,-1.0f, 0.0f,0.0f&#125;; 该四边形的VAO绑定和数据解析如下：123456789101112//窗口四边形windowQuadVAO和数据解析GLuint windowQuadVAO, windowQuadVBO;glGenVertexArrays(1, &amp;windowQuadVAO);glBindVertexArray(windowQuadVAO);glGenBuffers(1, &amp;windowQuadVBO);glBindBuffer(GL_ARRAY_BUFFER, windowQuadVBO);glBufferData(GL_ARRAY_BUFFER, sizeof(windowQuadVertices), windowQuadVertices, GL_STATIC_DRAW);glEnableVertexAttribArray(0);glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 4 * sizeof(GL_FLOAT), (GLvoid*)0);glEnableVertexAttribArray(1);glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 4 * sizeof(GL_FLOAT), (GLvoid*)(2 * sizeof(GLfloat)));glBindVertexArray(0); 再给这个四边写一个顶点着色器和像素着色器：四边形的顶点着色器（写在quad.vertex中）123456789#version 330 corelayout (location=0) in vec2 position;layout (location=1) in vec2 texCoords;out vec2 TexCoords;void main()&#123; gl_Position = vec4(position,0.0f,1.0f); TexCoords = texCoords;&#125; 四边形的像素着色器（写在quad.fragment中）：123456789#version 330 corein vec2 TexCoords;out vec4 color;uniform sampler2D texture1;void main()&#123; color = texture(texture1,TexCoords);&#125; 为四边形创建的着色器对象如下：1shader windowQuad_shader("quad.vertex", "quad.fragment"); 然后在渲染循环中，我们先把帧缓冲切换为我们自己创建的帧缓冲：12345glBindFramebuffer(GL_FRAMEBUFFER, fbo);glClearColor(0.3f, 0.4f, 0.5f, 1.0f);glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);glEnable(GL_DEPTH_TEST);glEnable(GL_CULL_FACE); 切换成我们自己的帧缓冲对象fbo，同时刷新颜色缓冲、深度缓冲，并且开启深度测试和面剔除。接下来就是照常渲染场景。 场景渲染完后，我们再切换到默认帧缓冲：1234//将帧缓冲切换为默认帧缓冲glBindFramebuffer(GL_FRAMEBUFFER, 0);glClearColor(1.0f, 1.0f, 1.0f, 1.0f);glClear(GL_COLOR_BUFFER_BIT); 由于我们只需要把一张二维纹理渲染到二维四边形上，所以不需要深度测试和面剔除，应该关掉：12glDisable(GL_DEPTH_TEST);glDisable(GL_CULL_FACE); 接下来就是渲染这个铺满窗口的四边形了：1234windowQuad_shader.Use();glBindVertexArray(windowQuadVAO);glBindTexture(GL_TEXTURE_2D, texColorBuffer);glDrawArrays(GL_TRIANGLES, 0, 6); 在渲染四边形之前，我们给它绑定了在自定义帧缓冲中已经渲染好的纹理（附件）。 编译运行后的结果如下：全部源码在这里。&nbsp; 后期处理现在，我们把整个场景渲染到了一个单独的纹理上，只需要简单操纵纹理数据，我么就能创建一些有趣的效果。下面，会展示出一些流行的后期处理（Post-processing）特效。 反相我们已经在纹理上存储了渲染输出的每个颜色，可以在四边形的像素着色器中用1减去每个颜色，就能得到这些颜色的反射：123void main()&#123; color = 1.0 - texture(texture1,TexCoords);&#125; 编译运行后的结果如下：想象一下，如果不先把场景渲染到纹理上，而是用我们之前的直接渲染到默认帧缓冲里，要实现这种效果，那我们就得在每一种着色器中去做上面的反色操作（每一种物体可能都有它们各自的着色器）。 灰度另一个有意思的效果是把整个场景图像变成黑白的。实现它的简单方式是获得每一个颜色分量，然后将它们平均化：12345void main()&#123; color = texture(texture1,TexCoords); float average = (color.r + color.g + color.b)/3; color = vec4(average,average,average,1.0f);&#125; 编译运行后的结果如下：&nbsp; 在单独纹理图像上进行后处理的另一个好处是我们可以从纹理的其他部分进行采样。比如我们可以从当前纹理值的周围采样多个纹理值。这样我们可以使用一些图像处理技巧，来实现很多后处理效果。比如接下来的后处理效果中的Kernel效果。 Kernel effectskernel是一个长得有点像一个小矩阵的数值数组，通常是一个3x3的矩阵，而且所有元素加起来的和通常等于1。 锐化Kernel：麻醉效果下面是一个锐化Kernel的例子：$$\begin{bmatrix}-1 &amp; -1 &amp; -1 \\ -1 &amp; 9 &amp; -1 \\ -1 &amp; -1 &amp; -1 \end{bmatrix}$$通过Kernel矩阵，将当前纹素扩展到周围9个纹素，然后通过加权和得到最终的当前片段颜色。 为了得到当前片段周围的9个纹素值，我们需要知道这9个纹素的坐标是多少，然后才能通过采样取得纹素值。所以，我们先定义一个纹理坐标偏移量，就是这9个纹理坐标离中心纹素坐标的偏移量：1234567891011121314151617//离中心纹素的s或t距离const float offset = 1.0/300;void main()&#123; //9个纹素的坐标偏移量 vec2 offsets[9] =vec2[]( vec2(-offset, offset), // top-left vec2(0.0f, offset), // top-center vec2(offset, offset), // top-right vec2(-offset, 0.0f), // center-left vec2(0.0f, 0.0f), // center-center vec2(offset, 0.0f), // center-right vec2(-offset, -offset), // bottom-left vec2(0.0f, -offset), // bottom-center vec2(offset, -offset) // bottom-right ); ... 接着我们就可以用这9个纹素坐标偏移量，采样得到周围9个纹素值了：12345//当前纹素周围的9个纹素vec3 sampleTex[9];for(int i=0;i&lt;9;i++)&#123; sampleTex[i] = vec3(texture(texture1,TexCoords.st + offsets[i]));&#125; 我们定义的Kernel矩阵如下：12345float kernel[9] = float[]( -1, -1, -1, -1, 9, -1, -1, -1, -1); 片段的最终颜色应该是在Kernel矩阵作用下的，9个周围像素的加权和：123456vec3 col;//kernel矩阵作用下的加权和for(int i=0;i&lt;9;i++)&#123; col += sampleTex[i] * kernel[i];&#125;color = vec4(col,1.0f); 四边形的像素着色器完整源码如下：123456789101112131415161718192021222324252627282930313233343536373839#version 330 corein vec2 TexCoords;out vec4 color;uniform sampler2D texture1;//离中心纹素的s或t距离const float offset = 1.0/300;void main()&#123; //9个纹素的坐标偏移量 vec2 offsets[9] =vec2[]( vec2(-offset, offset), // top-left vec2(0.0f, offset), // top-center vec2(offset, offset), // top-right vec2(-offset, 0.0f), // center-left vec2(0.0f, 0.0f), // center-center vec2(offset, 0.0f), // center-right vec2(-offset, -offset), // bottom-left vec2(0.0f, -offset), // bottom-center vec2(offset, -offset) // bottom-right ); //当前纹素周围的9个纹素 vec3 sampleTex[9]; for(int i=0;i&lt;9;i++)&#123; sampleTex[i] = vec3(texture(texture1,TexCoords.st + offsets[i])); &#125; float kernel[9] = float[]( -1, -1, -1, -1, 9, -1, -1, -1, -1 ); vec3 col; //kernel矩阵作用下的加权和 for(int i=0;i&lt;9;i++)&#123; col += sampleTex[i] * kernel[i]; &#125; color = vec4(col,1.0f);&#125; 编译运行后的结果如下：这是一个锐化的Kernel，就好像玩家吞了麻醉剂产生的幻觉一样。 kernel模糊效果Blur创建模糊效果的kernel如下：$$\begin{bmatrix} 1 &amp; 2 &amp; 1 \\ 2 &amp; 4 &amp; 2 \\ 1 &amp; 2 &amp; 1 \end{bmatrix} / 16$$我们像素着色器里的kernel数组现在变成：12345float kernel[9] = float[]( 1.0 / 16, 2.0 / 16, 1.0 / 16, 2.0 / 16, 4.0 / 16, 2.0 / 16, 1.0 / 16, 2.0 / 16, 1.0 / 16 ); 编译运行后的结果如下： kernel边缘检测效果边缘检测的kernel矩阵如下，和锐化kernel有点像：$$\begin{bmatrix} 1 &amp; 1 &amp; 1 \\ 1 &amp; -8 &amp; 1 \\ 1 &amp; 1 &amp; 1 \end{bmatrix}$$现在的kernel数组变为：12345float kernel[9] = float[]( 1, 1, 1, 1,-8, 1, 1, 1, 1); 编译运行后的结果如下：当偏移量offset不同时，效果会有所改变。更多kernel效果可查看Image Kernels。&nbsp; 参考文献：LearnOpenGL]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>帧缓冲</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenGL18：背面剔除]]></title>
    <url>%2F2017%2F01%2F18%2FOpenGL18%E8%83%8C%E9%9D%A2%E5%89%94%E9%99%A4%2F</url>
    <content type="text"><![CDATA[对于一个立方体，从任何一个方向最多只能看到3个面，那我们为何还需要去绘制那3个看不到的面呢？如果我们可以以某种方式丢弃它们，那我们至少会为像素着色器提高50%的性能！我们如何知道哪个面是能看到的（即正面，朝向观察者），哪个面是不能看到的（即背面，背对观察者）呢？ 【注】： 一个三角形相对于观察者只可能是正面或者背面，不可能既是正面又是背面 这里所说的正面背面都是相对于封闭形状来说的，能够看到的是正面，被挡住的是背面。 后面说到的三角形，请带入封闭形状里考虑，不然一个单独的三角形是不存在正面、背面之说的。&nbsp; 顶点绕序我们需要丢弃背对观察者的三角形片元，那如何确定一个面是否背对观察者呢？OpenGL使用顶点绕序（winding order）来解决这个问题。 顶点绕序就是当几何对象细分为三角形时，三角形顶点相对于中心的定义顺序，如下图所示：左图中的顶点绕序是顺时针的，右边是逆时针的。 默认情况下，OpenGL认为三角形的正面都是逆时针的顶点绕序，顺时针的顶点绕序都是三角形的背面，背对观察者。 我们在定义顶点属性数据时，需要从三角形的正面看过去（保证能够看到三角形），以逆时针绕序进行定义。如下图所示：右边的三角形顶点和左边的三角形顶点都是以逆时针顺序进行定义的，它们在各自的方向上都能被看到：右边的三角形从右边能够被看到，左边的三角形从左边能够被看到。但是如果现在观察点在右边，OpenGL会根据三角形顶点被定义的顺序，来计算相对于观察者来说这个顺序是逆时针还是顺时针。如果是逆时针，说明该面是正面，朝向观察者；如果是顺时针，说明该面是背面，背对观察者。根据三角形顶点的本身绕序，来计算相对于观察者的相对绕序（即相对于观察者是逆时针/顺时针），这是在光栅化阶段由OpenGL自动完成的。&nbsp; 在OpenGL中使用背面剔除首先，我们需要把立方体每个面的顶点按逆时针顺序去定义。注意，一定要从正面去看立方体的每个面，这时再去确定逆时针顺序的顶点。由于我们是用索引去绘制立方体，所以只需要按逆时针指定索引就可以了:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//三角形顶点的坐标、纹理坐标GLfloat cubeVertices[] = &#123; //位置坐标 //纹理坐标 //立方体前面 0.5f, 0.5f, 0.5f, 1.0f,1.0f, 0.5f,-0.5f, 0.5f, 1.0f,0.0f, -0.5f,-0.5f, 0.5f, 0.0f,0.0f, -0.5f, 0.5f, 0.5f, 0.0f,1.0f, //立方体后面 0.5f, 0.5f,-0.5f, 1.0f,1.0f, 0.5f,-0.5f,-0.5f, 1.0f,0.0f, -0.5f,-0.5f,-0.5f, 0.0f,0.0f, -0.5f, 0.5f,-0.5f, 0.0f,1.0f, //立方体上面 0.5f, 0.5f, 0.5f, 1.0f,1.0f, 0.5f, 0.5f,-0.5f, 1.0f,0.0f, -0.5f, 0.5f,-0.5f, 0.0f,0.0f, -0.5f, 0.5f, 0.5f, 0.0f,1.0f, //立方体下面 0.5f,-0.5f, 0.5f, 1.0f,1.0f, 0.5f,-0.5f,-0.5f, 1.0f,0.0f, -0.5f,-0.5f,-0.5f, 0.0f,0.0f, -0.5f,-0.5f, 0.5f, 0.0f,1.0f, //立方体右面 0.5f, 0.5f, 0.5f, 1.0f,1.0f, 0.5f, 0.5f,-0.5f, 1.0f,0.0f, 0.5f,-0.5f,-0.5f, 0.0f,0.0f, 0.5f,-0.5f, 0.5f, 0.0f,1.0f, //立方体左面 -0.5f, 0.5f, 0.5f, 1.0f,1.0f, -0.5f, 0.5f,-0.5f, 1.0f,0.0f, -0.5f,-0.5f,-0.5f, 0.0f,0.0f, -0.5f,-0.5f, 0.5f, 0.0f,1.0f&#125;;//顶点索引GLuint cubeIndices[] = &#123; //立方体前面 0,3,1, 1,3,2, //立方体后面 4,5,7, 5,6,7, //立方体上面 8,9,11, 9,10,11, //立方体下面 12,15,13, 13,15,14, //立方体右面 16,19,17, 17,19,18, //立方体左面 20,21,23, 21,22,23&#125;; 然后，我们需要开启面剔除：12//开启面剔除glEnable(GL_CULL_FACE); 编译运行后，所有不是正面朝向观察者的面都会被丢弃，尝试移动摄像机到箱子里面，会发现看不到箱子了：如果不开启背面剔除，运行的结果会是这样：目前，因为使用了背面剔除，在渲染片段上我们节约了超过50%的性能，但记住这只对像立方体这样的封闭形状有效。 所有源码在这里。&nbsp; 更多剔除 还可以剔除正面OpenGL默认是剔除背面三角形，但是也可以使用glCullFace函数来剔除正面等：1glCullFace(GL_FRONT); 该函数的参数有一下三个可选项： GL_BACK：只剔除背面 GL_FRONT：只剔除正面 GL_FRONT_AND_BACK：剔除正面和背面 正面也可以是顺时针之前我们使用逆时针来代表正面，其实也可以通过glCullFace函数来设置顺时针代表正面：1glFrontFace(GL_CW); 默认值是GL_CCW，表示逆时针，GL_CW表示顺时针。&nbsp; 参考文献：LearnOpenGL]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>背面剔除</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenGL17：混合]]></title>
    <url>%2F2017%2F01%2F17%2FOpenGL17%E6%B7%B7%E5%90%88%2F</url>
    <content type="text"><![CDATA[在OpenGL中，物体透明技术通常被叫做混合（Blending）。&nbsp; 透明透明是指物体自身颜色与它背面物体颜色不同程度的混合，而在OpenGL中就是使用混合技术来实现的，将当前要绘制的物体的颜色和颜色缓冲区中已经绘制了的物体颜色进行混合，最终决定当前物体的颜色。下图是一副全透明和半透明的窗子：物体的透明度是由片段颜色的alpha值（颜色向量的第4个元素）决定的，全透明的alpha值是0.0即透明度是100%，不透明的alpha值是1.0即透明度是0%。&nbsp; 丢弃片段来实现全透明有些纹理是纹理部分要么全透明，要么不透明，不存在半透明的部分。如下面的草纹理，它没有半透明的部分：对于这种纹理，我们可以直接丢弃全透明部分的片段，没有必要将它存储到颜色缓冲中，更没有必要使用混合技术。 首先，我们需要更改一下SOIL加载图片的方式，我们需要以RGBA的方式去加载带有alpha值的纹理（如果某些像素没有alpha值将会被设为1.0）：12//加载纹理图像unsigned char* image = SOIL_load_image(texturePath, &amp;imageWidth, &amp;imageHeight, 0, SOIL_LOAD_RGBA); 不要忘记还要改变OpenGL生成纹理的方式：12//生成2D纹理glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, imageWidth, imageHeight, 0, GL_RGBA, GL_UNSIGNED_BYTE, image); 绘制草的着色器很简单，仅仅是让片段颜色等于纹素颜色而已，代码如下：顶点着色器（写在grass.vertex中）：1234567891011121314#version 330 corelayout (location=0) in vec3 position;layout (location=1) in vec2 texCoords;out vec2 TexCoords;uniform mat4 model;uniform mat4 view;uniform mat4 projection;void main()&#123; gl_Position = projection * view * model * vec4(position,1.0f); TexCoords = vec2(texCoords.x ,1 - texCoords.y); &#125; 像素着色器（写在grass.fragment中）：123456789#version 330 corein vec2 TexCoords;out vec4 color;uniform sampler2D texture1;void main()&#123; color = texture(texture1,TexCoords);&#125; 设置草平面的顶点属性如下：123456789101112//草平面的顶点属性（位置坐标、纹理坐标）GLfloat grass_vertices[] = &#123; //顶点位置坐标 //纹理坐标 0.5f, 0.5f, 0.0f, 1.0f,1.0f, 0.5f,-0.5f, 0.0f, 1.0f,0.0f, -0.5f, 0.5f, 0.0f, 0.0f,1.0f, 0.5f,-0.5f, 0.0f, 1.0f,0.0f, -0.5f, 0.5f, 0.0f, 0.0f,1.0f, -0.5f,-0.5f, 0.0f, 0.0f,0.0f,&#125;; 接下来需要对它进行VAO绑定和数据解析：123456789101112//草平面顶点数据的绑定和解析GLuint grassVAO, grassVBO;glGenVertexArrays(1, &amp;grassVAO);glBindVertexArray(grassVAO);glGenBuffers(1, &amp;grassVBO);glBindBuffer(GL_ARRAY_BUFFER, grassVBO);glBufferData(GL_ARRAY_BUFFER, sizeof(grass_vertices), grass_vertices, GL_STATIC_DRAW);glEnableVertexAttribArray(0);glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 5 * sizeof(GL_FLOAT), (GLvoid*)0);glEnableVertexAttribArray(1);glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 5 * sizeof(GL_FLOAT), (GLvoid*)(3 * sizeof(GL_FLOAT)));glBindVertexArray(0); 还需要加载草纹理：12TextureLoader texLoader;GLuint grassTexture = texLoader.LoadTexture("grass.png"); 由于要绘制多株草，我们给每株草设置不同的位置：1234567//草的位置vector&lt;vec3&gt; grass_location;grass_location.push_back(vec3(-1.5f, 0.0f, -0.48f));grass_location.push_back(vec3(1.5f, 0.0f, 0.51f));grass_location.push_back(vec3(0.0f, 0.0f, 0.7f));grass_location.push_back(vec3(-0.3f, 0.0f, -2.3f));grass_location.push_back(vec3(0.5f, 0.0f, -0.6f)); 为了绘制草所定义的着色器对象如下：1shader grass_shader("grass.vertex", "grass.fragment"); 最后就是在渲染循环里绘制几株草了：12345678910//绘制几株草glBindVertexArray(grassVAO);glBindTexture(GL_TEXTURE_2D, grassTexture);for (int i = 0; i &lt; grass_location.size(); i++) &#123; model = mat4(); model = translate(model, grass_location[i]); glUniformMatrix4fv(glGetUniformLocation(grass_shader.shaderProgram, "model"), 1, GL_FALSE, value_ptr(model)); glDrawArrays(GL_TRIANGLES, 0, 6);&#125;glBindVertexArray(0); 编译运行后的结果如下：出现这种结果是因为OpenGL默认是不知道如何处理alpha值得，需要我们自己来设置。在像素着色器中，当片段的alpha值小于某一指定值时，就使用discard命令丢弃它。discard是GLSL为我们提供的用于丢弃片段的命令：123456789101112#version 330 corein vec2 TexCoords;out vec4 color;uniform sampler2D texture1;void main()&#123; vec4 texColor = texture(texture1,TexCoords); if(texColor.a &lt; 0.1) discard; color=texColor;&#125; 编译运行后的结果如下：可以看到绘制出来的每张草纹理上方会有一个白边，这是因为我们的纹理设置得是REPEAT环绕方式，在采样纹理边缘的时候，OpenGL会在该边缘和环绕的下一张重复纹理的边缘之间插值，这里上方的白边就是草纹理的透明上边缘和下边缘（绿色）插值的结果。为了防止四周这种白边的出现，我们需要把纹理环绕方式设置为GL_CLAMP_TO_EDGE：123//设置纹理s和t方向的环绕方式glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE); 编译运行后的结果如下：草确实没有了白边，但是地面很诡异了，地面纹理边缘也被拉伸了。地面纹理和草纹理应该是不同的环绕方式，所以，我们给TextureLoader类的LoadTexture函数加一个参数，表示s和t方向上的环绕方式，函数声明如下：1GLuint LoadTexture(const GLchar* texturePath, GLint wrap_st = GL_REPEAT); 在LoadTexture函数的实现中，就用这个wrap_st参数来设置纹理环绕方式：123//设置纹理s和t方向的环绕方式glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, wrap_st);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, wrap_st); 现在加载草纹理和地面纹理应该是这样：123TextureLoader texLoader;GLuint grassTexture = texLoader.LoadTexture("grass.png", GL_CLAMP_TO_EDGE);GLuint planeTexture = texLoader.LoadTexture("container.jpg"); 编译运行后的结果如下：所有源码在这里。&nbsp; 混合原理上诉丢弃片段的方式，虽然可以实现全透明效果，但是不能渲染半透明图像。为了能够实现半透明，我们需要先开启混合：12//开启混合glEnable(GL_BLEND); 混合方程OpenGL是按照以下混合方程进行混合的：$$\begin{equation}Result=source*sFactor+destination*dFactor\end{equation}$$source是源颜色向量，是将要绘制的纹理的颜色向量；destination是目标颜色向量，是存储在颜色缓冲中当前位置的颜色向量。sFactor和dFactor分别是对源颜色目标颜色的影响系数。 系数着色器运行完成并且所有的测试都通过以后，混合方程才开始执行。方程中的源和目标颜色会自动被OpenGL设置，而源和目标颜色的影响因子是由我们来设置的。比如现在有以下两个方块（或者说放大了的片段）：我们希望在红色方块上绘制绿色方块。红色方块将是目标颜色（它会先进入颜色缓冲中），绿色方块将是源颜色。如果我们把源颜色影响因子设为源颜色的alpha值0.6， 把目标颜色影响因子设为剩下（1-0.6），那么混合方程将是：$$\begin{equation}Result =\begin{pmatrix}0.0 \\1.0 \\0.0 \\0.6\end{pmatrix}* 0.6 +\begin{pmatrix}1.0 \\0.0 \\0.0 \\1.0 \\\end{pmatrix}* (1 - 0.6)\end{equation}$$最终方块将包含60%的绿色和40的红色： 设置源和目标颜色的影响因子我们使用glBlendFunc函数来设置这两个影响因子，函数原型如下：1void glBlendFunc(GLenum sfactor, GLenum dfactor) 这两个参数可以设置为下列选项：为了获得混合效果，把源颜色的alpha给源因子，1-alpha给目标因子：1glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); glBlendFunc函数是为R、G、B、A这四个分量都设置了相同的影响因子。其实我们还可以不用混合方程，直接使用glBlendFuncSeperate函数为最终颜色的每个分量设置一个值，例如：1glBlendFuncSeperate(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA,GL_ONE, GL_ZERO); 混合方程不止于加我们之前给的混合方程是源颜色和目标颜色按比例相加，其实还可以是减、逆序减。这需要用到glBlendEquation函数。函数原型如下：1void glBlendEquation(GLenum mode) 它的参数有以下选项： GL_FUNC_ADD：相加，这是默认的，$Result = Src + Dst$。 GL_FUNC_SUBTRACT：相减，$Result = Src - Dst$。 GL_FUNC_REVERSE_SUBTRACT：反过来相减，$Result = Dst - Src$。通常可以省略glBlendEquation函数，因为大多数时候我们需要的混合效果都是相加的，这恰好是默认的。&nbsp; 渲染半透明纹理现在我们开始用OpenGL来渲染下面这个半透明的窗子： 首先我们需要开启混合，并设置合适的混合方程：1234//开启混合glEnable(GL_BLEND);//混合方程glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); 这里是让源颜色影响因子等于源颜色的alpha值，目标颜色的影响因子等于1-源颜色的alpha。 现在我们是用混合来绘制半透明窗子的，不需要丢弃片段了，将像素着色器改回来：12345678910111213#version 330 corein vec2 TexCoords;out vec4 color;uniform sampler2D texture1;void main()&#123; /*vec4 texColor = texture(texture1,TexCoords); if(texColor.a &lt; 0.1) discard; color=texColor;*/ color = texture(texture1,TexCoords);&#125; 编译运行后的结果如下：&nbsp; 但是有个很明显的问题，前面的窗子并不能透明显示后面的窗子。这是因为深度测试并不关心alpha值，所以前面的窗子就会挡住后面的窗子，即使前面的窗子是透明的，它也会把后面窗子被挡住的片段丢弃。 由远及近地绘制透明物体对于包含不透明和透明物体的场景，绘制顺序应该是： 首先绘制不透明物体 先绘制离摄像机远的透明物体，再绘制近的透明物体 如果由远及近地绘制透明物体，那么在绘制近一些的透明物体时，就会混合远处的透明物体，最终会产生正确的结果。 几个窗子的位置如下：1234567//窗子的位置vector&lt;vec3&gt; window_location;window_location.push_back(vec3(-1.5f, 0.0f, -0.48f));window_location.push_back(vec3(1.5f, 0.0f, 0.51f));window_location.push_back(vec3(0.0f, 0.0f, 0.7f));window_location.push_back(vec3(-0.3f, 0.0f, -2.3f));window_location.push_back(vec3(0.5f, 0.0f, -0.6f)); 我们以窗子到摄像机的距离作为键，以窗子的位置作为键对应的值，会 建键值对数据结构map，map会自动对键进行排序，也就是map会自动排序窗子到摄像机的距离。【注】： map是STL库中的数据结构，是键值对的集合，可以用键作为下标来访问对应的值。 在渲染循环中，我们创建一个map，并且把窗子到摄像机的距离作为键，把当前窗子作为键对应的值：12345678910111213141516 //把多个窗子位置存入map数据结构中，以窗子到摄像机的距离为键 map&lt;float, vec3&gt; sortedWindow; for (int i = 0; i &lt; window_location.size(); i++) &#123; GLfloat distance = length(mycamera.cameraPos - window_location[i]); sortedWindow[distance] = window_location[i]; &#125;``` 在绘制时，我们逆序遍历这个map，就能由远及近地绘制出每个窗子：```c++ //逆序访问键值对map，由远及近地绘制透明窗子 for (map&lt;float, vec3&gt;::reverse_iterator it = sortedWindow.rbegin(); it != sortedWindow.rend(); ++it) &#123; model = mat4(); model = translate(model, it-&gt;second); glUniformMatrix4fv(glGetUniformLocation(grass_shader.shaderProgram, "model"), 1, GL_FALSE, value_ptr(model)); glDrawArrays(GL_TRIANGLES, 0, 6); &#125; reverse_iterator是逆序迭代器，it-&gt;second是键值对中的第二个元素，这里就是键对应的值，窗子的位置。 编译运行后的结果如下： 全部源码在这里。 在这个场景里，我们是按照窗子到摄像机的距离来由远及近地排序的，但是这种方法不是通用的。我们这个场景里所有的窗子都是相互平行，没有交叉折叠的，如果物体比较奇怪复杂，就需要其他排序方式了。对场景中的物体进行排序是很有难度的，完美地渲染带透明和不透明物体的场景也不那么容易，如果感兴趣可以了解一些更高级的技术，比如次序无关透明度（order independent transparency）。&nbsp; 参考文献：LearnOpenGL]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>混合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenGL16：模板测试]]></title>
    <url>%2F2017%2F01%2F15%2FOpenGL16%E6%A8%A1%E6%9D%BF%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[什么是模板测试当像素着色器处理完片段之后，深度测试之前，模板测试（stencil test）就开始执行了，和深度测试一样，它能丢弃一些片段：如果片段的模板值和当前模板缓冲区的对应位置上的模板值，满足指定关系，则不会被丢弃。这就是模板测试。仍然保留下来的片段将进入深度测试阶段，深度测试又会丢弃一些片段。 在渲染管线里包括很多种测试，它们的执行顺序如下图：&nbsp; 模板缓冲模板缓冲类似于颜色缓冲和深度缓冲，不过模板值通常是8位的，每个片段可以有256种不同的模板值（最大值255） 模板缓冲的作用下面举一个模板缓冲的简单例子：左边的场景在中间的模板作用下，只有对应模板值为1的片段才会被显示，不为1的片段都被丢弃了，最终呈现右图的结果。 可以看到，使用模板缓冲，我们可以根据模板值对决定是否丢弃特定的片段。&nbsp; 使用模板缓冲使用模板缓冲的步骤一般如下： 开启模板测试 绘制模板，写入模板缓冲（不写入color buffer和depth buffer） 关闭模板缓冲写入 利用模板缓冲中的值，绘制后续场景 首先我们需要开启模板测试：1glEnable(GL_STENCIL_TEST); 而且像颜色缓冲和深度缓冲一样，每次渲染循环之前，需要先清空模板缓冲：1glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT); 同样，和深度测试的glDepthMask函数一样，模板缓冲也有一个类似的函数glStencilMask，它用于控制模板缓冲区的写入，使用位掩码的方式决定是否可以写入模板缓冲区。使用的较多的是0x00表示禁止写入，0xFF表示允许任何写入：1234567// 0xFF == 0b11111111//此时，模板值与它进行按位与运算结果是模板值，模板缓冲可写glStencilMask(0xFF);// 0x00 == 0b00000000 == 0//此时，模板值与它进行按位与运算结果是0，模板缓冲不可写glStencilMask(0x00); 模板函数和深度测试一样，对于模板测试，我们也可以选择在什么条件下通过模板测试（使用glStencilFunc函数来完成），而且还可以选择以何种方式更新模板缓冲（比如通过模板测试后模板值不变、讲模板值变为0或者替换为另一个值等等，这使用glStencilOp函数来完成）。 glStencilFunc函数（指定模板测试通过条件）：函数原型：void glStencilFunc(GLenum func,GLint ref,GLuint mask)： 参数func：和深度测试一样，指定在什么条件通过模板测试，可用选项有：GL_NEVER、GL_LEQUAL、GL_GREATER、GL_GEQUAL、GL_EQUAL、GL_NOTEQUAL、GL_ALWAYS。 参数ref：和当前模板模板缓冲中的值stencil进行比较的指定值。 参数mask：指定一个遮罩，在比较时，分别与指定值ref和缓冲中的模板值stencil进行按位与操作，初始值为1。 【注】： 比较的方式是：如果func指定的是在GL_LESS条件下通过测试，其实是在(ref &amp; mask) &lt; (stencil &amp; mask)的条件下才通过测试；如果指定的是GL_GEQUAL，就相当于(ref &amp; mask) &gt;= (stencil &amp; mask)。 为了比较时简单直接，我们通常将mask设为0xFF： 1glStencilFunc(GL_EQUAL, 1, 0xFF); 表示当前模板缓冲区中值为1的部分通过模板测试，这部分片元将被保留，其余的则被丢弃。 glStencilOp函数（指定模板缓冲更新方式）：函数原型：void glStencilOp(GLenum sfail, GLenum dpfail, GLenum dppass)： 参数sfail：如果模板测试失败将采取的动作 参数dpfail：如果模板测试通过，但是深度测试失败时采取的动作 参数dppass：如果模板测试和深度测试都通过，将采取的动作 这三个参数是同一种枚举类型，每个参数都可以使用下列任何一个动作，来更新模板缓冲：&nbsp; 绘制矩形模板首先我们设置好矩形的顶点属性并解析：12345678910//模板矩形的顶点坐标GLfloat stencilRectVertices[] = &#123; 0.5f, 0.5f, 0.0f, 0.5f, -0.5f, 0.0f, -0.5f, 0.5f, 0.0f, -0.5f, 0.5f, 0.0f, 0.5f, -0.5f, 0.0f, -0.5f, -0.5f, 0.0f&#125;; 12345678910//模板矩形stencilRectVAO和数据解析GLuint stencilRectVAO, stencilRectVBO;glGenVertexArrays(1, &amp;stencilRectVAO);glBindVertexArray(stencilRectVAO);glGenBuffers(1, &amp;stencilRectVBO);glBindBuffer(GL_ARRAY_BUFFER, stencilRectVBO);glBufferData(GL_ARRAY_BUFFER, sizeof(stencilRectVertices), &amp;stencilRectVertices, GL_STATIC_DRAW);glEnableVertexAttribArray(0);glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(GL_FLOAT), (GLvoid*)0);glBindVertexArray(0); 画这个模板矩形，当然也需要着色器（最简单的那种着色器就可以）：模板矩形的顶点着色器（写在stencilRect.vertex中）：123456#version 330 corelayout (location=0) in vec3 position;void main()&#123; gl_Position = vec4(position,1.0f);&#125; 模板矩形的像素着色器（写在stencilRect.fragment中）123456#version 330 coreout vec4 color;void main()&#123; color = vec4(1.0f);&#125; 当然，需要开启模板缓冲：1glEnable(GL_STENCIL_TEST); 在渲染循环开始的时候，清除模板缓冲区：1glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT); 我们将要绘制一个矩形，用它来更新模板缓冲，但是不希望这个矩形被显示出来，所以绘制矩形之前需要先用掩码禁用颜色缓冲和深度缓冲：12glColorMask(GL_FALSE, GL_FALSE, GL_FALSE, GL_FALSE);glDepthMask(GL_FALSE); 然后我们使用位掩码设置允许模板缓冲区写入：1glStencilMask(0xFF); 接下来我们设置将要绘制的矩形片段总是通过模板测试，而且通过测试之后，把对应模板值设为1：12glStencilFunc(GL_ALWAYS, 1, 0xFF);glStencilOp(GL_KEEP, GL_KEEP, GL_REPLACE); 当矩形片段通过模板测试和深度测试后，会用函数glStencilFunc的ref参数（这里是1）来替换对应模板值。 接下来我们就可以来画这个矩形了（注意，由于禁用了颜色缓冲和深度缓冲，这个矩形不会被画到窗口上，只是被画到了模板缓冲里）：123stencilRect_shader.Use();glBindVertexArray(stencilRectVAO);glDrawArrays(GL_TRIANGLES, 0, 6); 矩形模板已经绘制好了，接下来我们开始绘制上一篇文章里的箱子和地面。 肯定需要先把禁用了的颜色缓冲和深度缓冲重新开启：12glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);glDepthMask(GL_TRUE); 绘制箱子和地面的时候，应该不会去改变模板缓冲中的值，所以我们禁用模板缓冲区写入：1glStencilMask(0x00); 我们希望用矩形模板来绘制箱子和地面，只有被包含在矩形内的部分才被绘制出来，其余的被丢弃。由于在模板缓冲中已经被我们绘制了一个矩形（由好多1构成的一个矩形），所以绘制箱子和地面时，我们设置片段模板值等于1时才通过模板测试（模板值不会改变）：12glStencilFunc(GL_EQUAL, 1, 0xFF);glStencilOp(GL_KEEP, GL_KEEP, GL_KEEP); 接下来就按照上一篇文章里的方式来绘制箱子和地面即可：编译运行后的结果如下：全部源码在这里。&nbsp; 物体轮廓outline接下来我们再使用模板测试来实现一个很有意识的效果：物体轮廓（object outline），如下图这样：给箱子添加轮廓的大致思路如下： 绘制出箱子，绘制时允许模板缓冲写入。这样就能在绘制箱子的同时，把箱子画入模板缓冲里（注意是窗口上二维显示的箱子，不是空间三维的箱子），其实就是一堆数字1。 绘制出地面，绘制时禁用模板缓冲。因为我们的模板跟地面没关系，不希望在绘制地面时受到影响。 禁用模板缓冲，绘制稍微大一点的纯色箱子（或者其他想要的边框颜色都行），同时设置模板值不等于1的片段无法通过模板测试，将会被丢弃。这样我们就能给之前的箱子绘出一个边框了。 绘制箱子因为我们要在绘制箱子的同时，把箱子模板画入模板缓冲中，所以需要先设置模板测试总是通过，并且通过后用1替换模板值，当然还需要允许模板缓冲写入：12345//Draw Cube，绘制箱子的同时绘制箱子模板glStencilFunc(GL_ALWAYS, 1, 0xFF);glStencilOp(GL_KEEP, GL_KEEP, GL_REPLACE);glStencilMask(0xFF);... 剩下的就是照常绘制箱子了，不再赘述，可参考文末的源码。 绘制地面绘制地面的时候，模板缓冲应该不受影响，所以需要先禁用模板缓冲写入：123//Draw Plane，绘制地面时应禁用模板写入glStencilMask(0x00);... 接下里就是照常绘制地面了，不再赘述。 绘制箱子轮廓绘制箱子轮廓，其实就是绘制一个模板值不等于1的稍微大一点的箱子。需要设置模板测试通过的条件是模板值不等于1：1glStencilFunc(GL_NOTEQUAL, 1, 0xFF); 而且，利用箱子模板绘制箱子轮廓时，模板缓冲不能受到影响，需要禁用模板缓冲写入：1glStencilMask(0x00); 接下来就是照常绘制稍微大一点的箱子了，这里我们是绘制一个1.1倍大小的箱子，可参见文末源码。而且这个稍大的边框箱子和实际箱子不是同一套着色器，因为它们的颜色不同（实际箱子是纹理颜色，而边框箱子我们用的纯色，着色器代码也可参见文末源码）。 最后，绘制完箱子轮廓后，不要忘了重新允许模板缓冲写入：1glStencilMask(0xFF); 其实，每当改变深度缓冲、模板缓冲等写入方式时，利用完了让它们恢复到最初状态是个很好的习惯，不容易出错。 编译运行后的结果如下：可以看到下轮廓和地面交界的地方，轮廓只显示了很细的一条线，这是因为下轮廓片段的深度值大于交界处地面片段的深度值，被挡住了，在深度测试时被丢弃了。解决办法是在画轮廓时关闭深度测试：12glDisable(GL_DEPTH_TEST); //保证轮廓不被挡住... 轮廓画完了以后，不要忘了重新开启深度测试：1glEnable(GL_DEPTH_TEST); 编译运行后的结果如下：&nbsp; 箱子轮廓的所有源码在这里。&nbsp; 参考文献：LearnOpenGL]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>模板测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenGL15：深度测试]]></title>
    <url>%2F2017%2F01%2F14%2FOpenGL15%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[使用深度缓冲所存储的深度值，可以确定一个片段是否被其他片段遮挡。 什么是深度测试深度缓冲区、颜色缓冲区和窗口像素是一一对应的，也就是说窗口上的每一个像素都有一个颜色值和一个深度值。颜色缓冲区存储的是像素的颜色信息，而深度缓冲区存储的是像素的深度信息。 在决定是否绘制一个片段时，首先让该片段的深度值与当前深度缓冲区对应位置上的深度值作比较，如果小于深度缓冲区中的值，则用该片段的颜色值和深度值去更新颜色缓冲区和深度缓冲区；否则，说明三维空间中该片段在对应屏幕像素后面，被挡住了，将丢弃该片段。这个过程就叫做深度测试（Depth Testing）。&nbsp; 在OpenGL中使用深度测试深度缓冲区一般由窗口管理系统（例如GLFW）来自动创建，深度值一般是16位、24位或32位，位数越高，深度的精确度越高。大多数系统的深度缓冲区都是24位。 要在OpenGL中使用深度测试，需要先开启深度测试，因为默认是关闭的：1glEnable(GL_DEPTH_TEST); 而且在每一次渲染循环开始之前，还需要清除深度缓冲区，否则深度缓冲区将保留上一次进行深度测试时所写的深度值：1glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); 有的时候我们需要进行深度测试，但不希望更新深度缓冲区，这时可以用glDepthMask函数将深度掩码设置为GL_FALSE来关闭深度缓冲区写入：1glDepthMask(GL_FALSE); 【注】： 使用glDepthMask函数来关闭深度缓冲区写入，只在深度测试被启用的时候有效。 深度测试函数上面说片段深度值小于深度缓冲区对应深度值的时候，深度测试通过。其实也可以是其他关系，比如大于、等于等等。这就需要我们使用’glDepthFunc’函数来设置什么时候通过深度测试了，因为默认情况下是小于的时候才通过深度测试：1glDepthFunc(GL_LESS); 除了小于GL_LESS以外，还有其他比较运算符：下面我们把glDepthFunc函数的参数设为GL_ALWAYS来看看效果，源码请看这里。 编译运行后的结果如下：可以看到GL_ALWAYS和我们没有启用深度测试得到了相同的效果。深度测试总是通过，所以后绘制的片段肯定会覆盖之前绘制的片段。在上面的程序中我们先绘制立方体，再绘制的地面，所以地面就把立方体遮住了。把参数设为GL_LESS后的结果如下：&nbsp; 可视化深度值深度测试是在像素着色器运行之后（也在模板测试运行之后），在屏幕空间中执行的。屏幕空间坐标与OpenGL的glViewport函数定义的视口（viewport）直接相关，可以在像素着色器中通过GLSL的内置变量gl_FragCoord来获取片段的屏幕空间坐标。gl_FragCoord的x和y元素表示片段的屏幕空间坐标（(0,0)是左下角），而它的z元素就是片段的实际深度值。 我们把地面的顶点坐标更改如下：1234567891011//地面的顶点坐标、纹理坐标GLfloat planeVertices[] = &#123; //位置坐标 //纹理坐标 5.0f, -0.05f, 5.0f, 2.0f, 0.0f, -5.0f, -0.05f, 5.0f, 0.0f, 0.0f, -5.0f, -0.05f, -5.0f, 0.0f, 2.0f, 5.0f, -0.05f, 5.0f, 2.0f, 0.0f, -5.0f, -0.05f, -5.0f, 0.0f, 2.0f, 5.0f, -0.05f, -5.0f, 2.0f, 2.0f&#125;; 地面在y方向上更靠近摄像机了（摄像机在y=0的位置上）。 再把像素着色器更改如下：12345678910#version 330 corein vec2 TexCoords;out vec4 color;uniform sampler2D texture1;void main()&#123; //color = texture(texture1,TexCoords); color = vec4(vec3(gl_FragCoord.z),1.0f);&#125; 我们让箱子和地面不输出纹理颜色，而只是输出深度值。源码在这里。得到结果如下：可以看到地面靠近摄像机的地方有些黑色，说明深度值比较小，但是黑色部分很少。它向白色的过渡变化并不是均匀的，近的地方深度值变化很快，只远离几英寸就让暗色完全变亮了，剩余的部分大多都是亮色。 这是因为片段在屏幕空间里的深度值和它们在三维空间里的z值并不是线性关系。z很小的时候（准确的是靠近摄像机的时候），片元的深度值变化得会很快，能够很好地反映出摄像机近处物体的空间位置关系；但是当z比较大的时候，物体远离摄像机，远处的物体谁在前谁在后通常都不会太影响我们的视觉效果，这时远离摄像机的片元的深度值就不需要变化那么快了。而OpenGL的深度值恰好符合这种视觉规律：z较小时深度变化快，z较大时深度变化慢。 通常深度值$F_depth$和z具有如下关系：$$\begin{equation}F_{depth} = \frac{1/z - 1/near}{1/far - 1/near}\end{equation}$$ 【注】： 从公式里可以看出，更准确地应该是越靠近近裁剪面，深度值变化越快。因为近裁剪面通常是0.1，相距摄像机很近，所以通常才说成越靠近摄像机深度值变化越快。 在下图中可以看到z值和对应的深度缓冲值的非线性关系：&nbsp; 深度冲突z-fighting两个平面或三角形相互接近通常会出现一种视觉失真，深度缓冲没有足够的精确度来弄清哪个形状在前，哪个形状在后（比如两个三角形实际深度是0.801和0.802，但是如果24位深度缓冲只能精确到0.80，那就无法分清这两个三角形谁在前谁在后）。结果就是两个形状持续地交换顺序，产生了诡异的差错样式。这叫做z-fighting，就像两个形状为了显示在上面而打架。 使用最开始的代码，让箱子和地面显示不同的纹理，我们把摄像机移动到箱子里面，就会看到下图所示的这种深度冲突效果（箱子的底部和地面持续地相互交换，产生了锯齿样式）：&nbsp; 减弱z-fighting深度冲突z-fighting是深度缓冲区中常见的问题，通常当物体越远的时候越严重（因为越远的地方深度变化越慢，深度值越接近，精确度低）。z-fighting至今无法完全避免，但是有些技术能够帮助我们减弱z-fighting 永远不要把物体放得彼此太近，不要让物体间的三角形重合。两个物体间留有一小段用户难以观察到的距离，可以完美地避免z-fighting。但是，这需要我们手工干涉每个物体以及仔细测试才能确保场景中的物体没有产生z-fighting。 把近平面设置得尽可能远。因为近裁剪面附近深度变化很快，精确度很高，因此尽可能让近裁剪面远一些（也就是尽可能靠近场景中的物体）的话，会使整个裁剪范围内的精确度变高一些。但是这种方式会使距离观察者较近的物体被裁剪掉，所以需要不断调整才能找到一个合适的近裁剪面参数。 使用更高位数的深度缓冲区，通常使用的深度缓冲区是24位的，但现在显卡支持32位深度值，这会让深度值得精度提高很多。但是同时也带来了一些更大的运算开销。&nbsp; 参考文献：LearnOpenGL]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>深度测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenGL14：模型加载]]></title>
    <url>%2F2017%2F01%2F12%2FOpenGL14%E6%A8%A1%E5%9E%8B%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[之前我们的场景里用的全都是小方块，现在我们想要去加载一些其他模型。我们是无法像定义小方块一样，用程序去手动地指定房子、人这些复杂模型的顶点、法线和纹理坐标。这些复杂模型通常是由美工用Blender、3DS Max和Maya这些建模软件来制作的，我们要做的只是把这些已经做好的模型打入到我们的应用程序中。在建模软件导出模型文件时，会自动生成模型的所有顶点坐标、顶点法线和纹理坐标，而我们需要去解析这些导出的模型文件，并将其中的模型数据存储为OpenGL能够使用的数据。 由于导出的模型文件通常有几十种格式，为每种格式都写一种解析方式是很麻烦的。这里我们直接使用市面上一个很流行的模型加载库，叫做Assimp。&nbsp; 模型加载库AssimpAssimp是一个常用的模型加载库，全称是Open Asset Import Library。它可以导入几十种不同格式的模型文件（也可以导出部分模型格式），并且可以把不同的模型文件都转换为一个统一的数据结构，所以无论我们导入哪种格式的模型文件，都可以用同一个方式去访问我们需要的模型数据。它能读取以下格式的模型文件： Autodesk ( .fbx ) Collada ( .dae ) glTF ( .gltf, .glb ) Blender 3D ( .blend ) 3ds Max 3DS ( .3ds ) 3ds Max ASE ( .ase ) Wavefront Object ( .obj ) Industry Foundation Classes (IFC/Step) ( .ifc ) XGL ( .xgl,.zgl ) Stanford Polygon Library ( .ply ) AutoCAD DXF ( .dxf ) LightWave ( .lwo ) LightWave Scene ( .lws ) Modo ( .lxo ) Stereolithography ( .stl ) DirectX X ( .x ) AC3D ( .ac ) Milkshape 3D ( .ms3d ) TrueSpace ( .cob,.scn ) Biovision BVH ( .bvh ) CharacterStudio Motion ( .csm ) Ogre XML ( .xml ) Irrlicht Mesh ( .irrmesh ) Irrlicht Scene ( .irr ) Quake I ( .mdl ) Quake II ( .md2 ) Quake III Mesh ( .md3 ) Quake III Map/BSP ( .pk3 ) Return to Castle Wolfenstein ( .mdc ) Doom 3 ( .md5* ) Valve Model ( .smd,.vta ) Open Game Engine Exchange ( .ogex ) Unreal ( .3d ) BlitzBasic 3D ( .b3d ) Quick3D ( .q3d,.q3s ) Neutral File Format ( .nff ) Sense8 WorldToolKit ( .nff ) Object File Format ( .off ) PovRAY Raw ( .raw ) Terragen Terrain ( .ter ) 3D GameStudio (3DGS) ( .mdl ) 3D GameStudio (3DGS) Terrain ( .hmp ) Izware Nendo ( .ndo ) 还能导出几种常见格式的模型： Collada ( .dae ) Wavefront Object ( .obj ) Stereolithography ( .stl ) Stanford Polygon Library ( .ply ) Assimp生成的模型数据结构当Assimp导入一个模型文件时，它会加载整个模型文件到一个scene对象，它包含了所有被导入的模型和场景数据（一个模型文件可能包含多个模型或场景）。Assimp会为这个模型文件中的所有场景节点、模型节点都生成一个对应的数据结构，每个节点包含着存储在scene对象中的数据的索引，有的可能还包含几个子节点。下图展示了一个简化的Assimp生成的模型数据结构： 所有的模型、场景数据都包含在scene对象中，如所有的材质和Mesh。而且，场景的根节点应用也在这个scene对象中。 场景的根节点包含很多子节点和很多指向scene对象中的Mesh网格数据的引用。因为根节点的mMeshes数组才包含着实际的网格对象，其他节点的mMeshes数组的值都只是根节的mMeshes的索引。 一个mesh由顶点、边、面片组成，它包含了渲染所需的所有相关数据，比如顶点位置、法线向量、纹理坐标、面片、材质等，一个mesh是一个可绘制的独立实体，如一条手臂、一条腿。 一个mesh会包含多个面片Face。一个面片表示渲染中的一个最基本的图元（如点、线、三角面片、矩形面片）。一个面片记录了一个图元的顶点索引，通过这个索引，可以在mMeshes中寻找到对应的顶点位置数据。因为顶点和索引是分开的，所以我们很容易使用索引缓冲来进行高速渲染。 一个mesh还会包含一个材质对象，用于指定物体的一些材质属性，如颜色、纹理贴图（漫反射贴图、镜面反射贴图等）。 我们后面会用上诉的数据结构来创建我们自己的Model类和Mesh类，用于加载和保存那些导入的模型。我们不需要去渲染整个模型的所有数据，而只是去渲染这个模型所包含的所有独立的Mesh。 构建Assimp要使用Assimp模型加载库，我们需要先构建它。下载地址在这里。最好我们自己用CMake去编译Assimp库，因为Assimp官方的已编译库不能很好地在所有平台上正常运行。具体编译、构建和链接过程可以回顾《OpenGL1：OpenGL概述及环境配置》。 下面给出一些编译Assimp时可能遇到的问题： 在使用CMake进行Configure时，可能遇到如下错误：1Could not locate DirecXCMake Error at cmake-modules/FindPkgMacros.cmake:110 (message):Required library DirectX not found! Install the library (including dev packages) and try again. If the library is already installed, set the missing variables manually in cmake. 这是因为你之前没有安装过DirectX SDK，那么下载安装吧！ 在安装DirectX SDK时，可能会遇到一个错误码为S1023的错误。解决步骤如下： 在命令行窗口运行下面两行命令：12MsiExec.exe /passive /X&#123;F0C3E5D1-1ADE-321E-8167-68EF0DE699A5&#125;MsiExec.exe /passive /X&#123;1D8E6291-B0D5-35EC-8441-6616F567A0F7&#125; 删除掉Visual C++ 2010 Redistributable Package。如下图所示： 安装DirectX SDK 重新安装Visual C++ 2010 Redistributable Package。可以在这里下载到。注意x64系统需要安装vcredist_x86.exe和vcredist_x64.exe两个版本。 【注】： 使用默认配置构建的Assimp是一个动态库，所以我们需要把编译出来的assimpd.dll文件拷贝到我们自己的源文件所在的目录里。 如果想要让Assimp使用多线程来提高性能，可以使用Boost库来编译Assimp。在Boost安装页面，可以找到关于Boost的完整安装介绍。&nbsp; 网格类Mesh使用Assimp可以把多种不同格式的模型加载到程序中，但是一旦载入，它们就都被存储为Assimp自己的数据结构。我们需要将其转变为OpenGL可读的数据，才能用OpenGL来渲染物体。 绘制网格所需数据一个网格代表一个可绘制的实体，我们把Assimp加载的模型转变成很多个网格，分别绘出这些网格，就能绘制出整个模型。现在我们来自定义一个自己的网格类，便于转换Assimp的数据结构为OpenGL可读的数据结构。一个网格应该至少需要一组顶点，每个顶点包含一个位置向量、一个法线向量、一个纹理坐标，还需要包含顶点索引以及用纹理（漫反射贴图、镜面贴图）形式表现的材质数据。 那我们先来定义一个顶点：12345struct Vertex &#123; vec3 position; vec3 normal; vec2 texCoords;&#125;; 顶点中包含了顶点位置、法线和纹理坐标。 接着我们来定义绘制网格所需要的纹理：1234struct Texture &#123; GLuint id; string samplerName;&#125;; 纹理中包含了纹理加载后的ID，和在像素着色器（在文末有像素着色器代码，和上一篇文章几乎一样）中纹理所对应的采样器名称。 建立网格类然后，我们可以开始建立Mesh类了：12345678class Mesh &#123;public: vector&lt;Vertex&gt; vertices; vector&lt;GLuint&gt; indices; vector&lt;Texture&gt; textures; float shininess; ...&#125; 它包含了绘制网格所需的一堆顶点、顶点索引和纹理，它们都是vector类型（使用vector需要包含vector文件#include &lt;vector&gt;），还包含了计算镜面光时所需要的镜面反射系数。这些顶点位置、纹理等等都是从Assimp加载后的数据里面得到的（在后面自定义的模型加载类ModelLoader里通过参数传递到Mesh类里）。 我们可以在Mesh类的构造函数里，用传递过来的参数初始化这些顶点、纹理：1234567Mesh(vector&lt;Vertex&gt; vertices, vector&lt;GLuint&gt; indices, vector&lt;Texture&gt; textures, float shininess) &#123; this-&gt;vertices = vertices; this-&gt;indices = indices; this-&gt;textures = textures; this-&gt;shininess = shininess; ...&#125; 和之前的绘制流程一样，在绘制之前先对这些数据绑定VAO、VBO、EBO以及解析顶点数据，我们把它写在PrepareBeforeDraw函数里：12345678910111213141516171819GLuint VAO, VBO, EBO;//在绘制之前的绑定、发送数据、解析等准备工作void PrepareBeforeDraw() &#123; glGenVertexArrays(1, &amp;VAO); glGenBuffers(1, &amp;VBO); glGenBuffers(1, &amp;EBO); glBindVertexArray(VAO); glBindBuffer(GL_ARRAY_BUFFER, VBO); glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO); glBufferData(GL_ARRAY_BUFFER, vertices.size() * sizeof(Vertex), &amp;vertices[0], GL_STATIC_DRAW); glBufferData(GL_ELEMENT_ARRAY_BUFFER, indices.size() * sizeof(GLuint), &amp;indices[0], GL_STATIC_DRAW); glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (GLvoid*)0); glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (GLvoid*)offsetof(Vertex, normal)); glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, sizeof(Vertex), (GLvoid*)offsetof(Vertex, texCoords)); glEnableVertexAttribArray(0); glEnableVertexAttribArray(1); glEnableVertexAttribArray(2); glBindVertexArray(0);&#125; 然后在构造函数里调用该函数：1234567Mesh(vector&lt;Vertex&gt; vertices, vector&lt;GLuint&gt; indices, vector&lt;Texture&gt; textures, float shininess) &#123; this-&gt;vertices = vertices; this-&gt;indices = indices; this-&gt;textures = textures; this-&gt;shininess = shininess; PrepareBeforeDraw();&#125; 绘制网格所需的数据以及绑定解析好了，接下来就可以绘制网格了：1234567891011void Draw(shader myshader) &#123; for (GLuint i = 0; i &lt; textures.size(); i++) &#123; glActiveTexture(GL_TEXTURE0 + i); glBindTexture(GL_TEXTURE_2D, textures[i].id); glUniform1i(glGetUniformLocation(myshader.shaderProgram, ("material." + textures[i].samplerName).c_str()), i); &#125; glUniform1f(glGetUniformLocation(myshader.shaderProgram, "material.shininess"), shininess); glBindVertexArray(VAO); glDrawElements(GL_TRIANGLES, indices.size(), GL_UNSIGNED_INT, 0); glBindVertexArray(0);&#125; 先对每一张纹理激活纹理单元和设置对应的uniform采样器，再设置uniform镜面反射系数的值，最后再次绑定VAO调用glDrawElements函数就可以绘制出整个网格了。&nbsp; 模型加载类ModelLoader我们需要使用Assimp把模型文件加载到我们的程序里，再读出一些Assimp数据（比如顶点、索引、纹理等 ）传到Mesh里用以绘制（这里我们使用纳米铠甲的模型）。 加载模型文件要使用Assimp，除了编译链接好以外，还需要在我们的程序中包含以下头文件：12345//Assimp#include &lt;Assimp/Importer.hpp&gt;#include &lt;Assimp/scene.h&gt;#include &lt;Assimp/postprocess.h&gt;using namespace Assimp; 然后我们在自定义的LoadModel函数里使用Assimp的Importer对象的ReadFile函数，来把模型文件读取到场景对象中：123456789101112const aiScene* scene;void LoadModel(string path) &#123; //用Assimp加载模型文件到场景对象中 Importer importer; scene = importer.ReadFile(path, aiProcess_Triangulate | aiProcess_FlipUVs); if (!scene || !scene-&gt;mRootNode || scene-&gt;mFlags == AI_SCENE_FLAGS_INCOMPLETE) &#123; cout &lt;&lt; "Error:Assimp:" &lt;&lt; importer.GetErrorString() &lt;&lt; endl; return; &#125; ...&#125; 首先定义Importer对象，Importer对象的ReadFile函数里第一个参数指明模型文件的路径，第二个参数是后处理选项。除了可以简单加载文件外，Assimp运行我们定义几个选项来强制Assimp去对导入的数据做一些额外的计算或操作： aiProcess_Triangulate：告诉Assimp如果模型不是（全部）由三角形组成，应该转换所有的模型的原始几何形状为三角形。 aiProcess_FlipUVs：基于y轴翻转纹理坐标（在OpenGL5：纹理一文中说过OpenGL会将大多数图像沿着y轴翻转，不翻转回来的话会导致画出来的图像是上下颠倒的，这里做了这个处理后顶点着色器就不用再1-纹理y坐标了）。 aiProcess_GenNormals：如果模型没有包含法线向量，就为每个顶点创建法线。 aiProcess_SplitLargeMeshes：把大的网格分成几个小的夏季网格，当渲染一个有最大数量顶点的限制或者只能处理小块网格时会很有用。 aiProcess_OptimizeMeshes：和上一个选项相反，它把几个网格结合为一个更大的网格，以减少绘制函数调用次数的方式来实现优化。 更多更详细的后处理内容可以在这里找到。 ReadFile函数返回一个aiScene指针对象，将加载的模型数据都存储在这个返回的场景对象指针中（Assimp的很多变量和方法名称都带有ai标识）。接着通过场景对象指针是否为空、场景对象的根结点是否为空和场景的加载标志flag是否为非完整加载AI_SCENE_FLAGS_INCOMPLETE来判断Assimp加载是否成功，如果不成功，使用加载器Importer对象的GetErrorString函数来返回错误报告。 遍历aiMesh现在所有的模型数据都存储在场景对象指针中，但是这些数据并不是配对的，我们不知道哪些材质（材质里有纹理）应该属于哪些mesh，就无法给每个mesh对应上正确的纹理贴图。所以我们需要去遍历每一个mesh，取出它里面的顶点、法线、纹理等等。 首先定义一个全局遍历meshes，用于存储遍历出来的每一个mesh：1vector&lt;Mesh&gt; meshes; 遍历所有mesh的方法有两种，一种是直接遍历场景对象指针scene下的所有mesh：1234567//遍历所有meshvoid TraverseNode(aiNode* node) &#123; //方法1：直接遍历场景对象指针scene中的所有mesh for (int i = 0; i &lt; scene-&gt;mNumMeshes; i++) &#123; meshes.push_back(ProcessMesh(scene-&gt;mMeshes[i])); &#125;&#125; 另外一种是从根结点开始递归遍历子结点，取出每一个结点包含的所有mesh。12345678910111213//遍历所有meshvoid TraverseNode(aiNode* node) &#123; //方法2：递归每个结点 //取出自身结点中的所有mesh for (GLuint i = 0; i &lt; node-&gt;mNumMeshes; i++) &#123; aiMesh* aimesh = scene-&gt;mMeshes[node-&gt;mMeshes[i]]; meshes.push_back(ProcessMesh(aimesh)); &#125; //递归遍历子节点 for (GLuint i = 0; i &lt; node-&gt;mNumChildren; i++) &#123; TraverseNode(node-&gt;mChildren[i]); &#125;&#125; 在每一个结点中存储的mesh，都只是场景对象scene包含的mesh的一个索引。所以需要使用形如scene-&gt;mMeshes[node-&gt;mMeshes[i]]的方式去scene中获得真正的mesh。 从aiMesh中提取数据转换为Mesh类对象函数ProcessMesh是我们的自定义函数，用于从Assimp加载的aiMesh里提取出顶点、索引、纹理等，转变为Mesh类对象。 先在ProcessMesh函数里定义我们的Mesh所需要的顶点、索引和纹理：1234567//把Assimp的aiMesh转换为我们自定义的MeshMesh ProcessMesh(aiMesh* aimesh) &#123; vector&lt;Vertex&gt; vertices; vector&lt;GLuint&gt; indices; vector&lt;Texture&gt; textures; ...&#125; 【注】： 这里的Vertex、Texture都是在Mesh类之前定义的结构体，所以需要先包含mesh.h：#include &quot;mesh.h&quot; 接下来我们取出aiMesh中所有顶点的位置、法线、纹理坐标等顶点属性，赋值给我们自定义的顶点结构体：12345678910111213//获取aiMesh中的所有顶点数据（包括顶点位置、法线向量、纹理坐标）for (GLuint i = 0; i &lt; aimesh-&gt;mNumVertices; i++) &#123; Vertex vertex; vertex.position = vec3(aimesh-&gt;mVertices[i].x, aimesh-&gt;mVertices[i].y, aimesh-&gt;mVertices[i].z); vertex.normal = vec3(aimesh-&gt;mNormals[i].x, aimesh-&gt;mNormals[i].y, aimesh-&gt;mNormals[i].z); if (aimesh-&gt;mTextureCoords[0]) &#123; vertex.texCoords = vec2(aimesh-&gt;mTextureCoords[0][i].x, aimesh-&gt;mTextureCoords[0][i].y); &#125; else &#123; vertex.texCoords = vec2(0.0f, 0.0f); &#125; vertices.push_back(vertex);&#125; 【注】： Assimp允许一个模型的每个顶点有8个不同的纹理坐标，所以mTextureCoords是2维的，第一维指明是那组纹理坐标，第二维才指明是某组的哪一个纹理坐标。这里我们只关心顶点的第一组纹理坐标，所以第一维是0。 当然，每次循环完后，不要忘记把Vertex结构体变量添加到vertices里。 接着我们取出aiMesh中的所有顶点索引，这些顶点索引都保存在每一个面片中：1234567//获取aiMesh中所有面片（这里就是三角形）的顶点索引for (GLuint i = 0; i &lt; aimesh-&gt;mNumFaces; i++) &#123; aiFace aiface = aimesh-&gt;mFaces[i]; for (GLuint j = 0; j &lt; aiface.mNumIndices; j++) &#123; indices.push_back(aiface.mIndices[j]); &#125;&#125; 我们再来取出aiMesh的所有纹理，这些纹理都存储在材质中，所以需要先获取到材质：12345//获取aiMesh的材质的所有材质纹理if (aimesh-&gt;mMaterialIndex &gt;= 0) &#123; aiMaterial* aimat = scene-&gt;mMaterials[aimesh-&gt;mMaterialIndex]; ...&#125; 如果某个mesh没有材质，那么它的mMaterialIndex属性会小于0。 由于Mesh类里需要纹理加载和绑定后的ID，所以我们需要aiMesh的每一个纹理的存储路径。纹理的名称可以由aiMaterial对象的GetTexture函数得到：1234aiString str;//获取第i个漫反射纹理的名称aimat-&gt;GetTexture(aiTextureType_DIFFUSE, i, &amp;str);string texRelativePath = str.C_Str(); GetTexture函数的第一个参数是纹理类型，可以是漫反射纹理或者镜面纹理，第二个参数是第几个对应纹理，第三个参数用于存储纹理名称。注意第三个参数纹理名称是aiString类型的，需要使用C_Str函数转换为string类型。 只得到了纹理名称还不够，还应该有这个纹理所在的文件夹路径，这个我们可以用字符串自己指定。由于我们已经把纹理和模型文件nanosuit.obj放在同一个文件夹，而且在调用之前的LoadModel函数时，我们传入了模型文件的路径（LoadModel函数参数path），所以我们可以根据这个路径得到纹理所在的文件夹路径：12string directory;directory = path.substr(0, path.find_last_of('/')); substr函数的第一个参数指明截取字符串的起始位置，第二个参数指明截取字符串的终止位置。 但是GetTexture的第二个参数该怎么指定呢？我们怎么知道有多少个漫反射纹理，i应该取为多少才不会越界。可以使用aiMaterial对象的GetTextureCount函数来获取材质中相应纹理的数量，它只有一个参数，指明是漫反射纹理还是镜面纹理：12345678910111213//获取aiMesh的材质的所有材质纹理if (aimesh-&gt;mMaterialIndex &gt;= 0) &#123; aiMaterial* aimat = scene-&gt;mMaterials[aimesh-&gt;mMaterialIndex]; //获取所有的漫反射纹理 for (GLuint i = 0; i &lt; aimat-&gt;GetTextureCount(aiTextureType_DIFFUSE); i++) &#123; aiString str; //获取第i个漫反射纹理的名称 aimat-&gt;GetTexture(aiTextureType_DIFFUSE, i, &amp;str); string texName = str.C_Str(); //纹理名称 string texPath = directory + &apos;/&apos; + texName; //纹理路径 ... &#125;&#125; 纹理路径有了，接下来我们就可以用之前文章里的纹理加载类TextureLoader，来加载纹理了：123456789101112131415161718//获取aiMesh的材质的所有材质纹理if (aimesh-&gt;mMaterialIndex &gt;= 0) &#123; aiMaterial* aimat = scene-&gt;mMaterials[aimesh-&gt;mMaterialIndex]; //获取所有的漫反射纹理 for (GLuint i = 0; i &lt; aimat-&gt;GetTextureCount(aiTextureType_DIFFUSE); i++) &#123; aiString str; //获取第i个漫反射纹理的名称 aimat-&gt;GetTexture(aiTextureType_DIFFUSE, i, &amp;str); string texName = str.C_Str(); //纹理名称 string texPath = directory + '/' + texName; //纹理路径 Texture texture; TextureLoader textureLoader; texture.id = textureLoader.LoadTexture(texPath.c_str()); texture.samplerName = "diffuse_texture" + IntToString(i); textures.push_back(texture); &#125;&#125; 加载后的纹理ID赋值给Texture结构体变量的id属性，同时我们给Texture结构体变量的samplerName 属性赋值，对应像素着色器中的纹理采样器名称。当然不要忘了把Texture结构体变量添加到textures中。【注】： 由于C++没有提供把字符转换为字符串的函数，所以我们自己写了一个IntToString函数来实现这个功能：123456//把int类型转换为string类型string IntToString(int number) &#123; ostringstream outs; outs &lt;&lt; number; return outs.str();&#125; 对于镜面纹理的获取，和上面的漫反射纹理一样：1234567891011121314//获取所有的镜面纹理for (GLuint i = 0; i &lt; aimat-&gt;GetTextureCount(aiTextureType_SPECULAR); i++) &#123; aiString str; //获取第i个镜面反射纹理的存储路径 aimat-&gt;GetTexture(aiTextureType_SPECULAR, i, &amp;str); string texName = str.C_Str(); //纹理名称 string texPath = directory + '/' + texName; //纹理路径 Texture texture; TextureLoader textureLoader; texture.id = textureLoader.LoadTexture(texPath.c_str()); texture.samplerName = "specular_texture" + IntToString(i); textures.push_back(texture);&#125; 我们再指定一下mesh的镜面反射系数，用以计算镜面反射光：1float shininess = 32; 最后，我们把这些顶点、索引、纹理和镜面反射系数，传递给Mesh类，Mesh类就会用它的构造函数，生成一个用于我们绘制的Mesh对象：1return Mesh(vertices, indices, textures, shininess); 绘制每一个mesh万事俱备，只欠东风。在LoadModel类里，我们已经把所有aiMesh转换为可以绘制的Mesh对象了，最后要做的就是在LoadModel类里调用所有Mesh对象的Draw函数，我们把它写在LoadModel类的Draw函数里：12345void Draw(shader myshader) &#123; for (GLuint i = 0; i &lt; meshes.size(); i++) &#123; meshes[i].Draw(myshader); &#125;&#125; &nbsp; 绘制模型绘制模型，只需要在主程序里定义LoadModel类对象，然后在渲染循环里调用它的Draw函数就可以了：123Model mymodel("nanosuit/nanosuit.obj");...mymodel.Draw(lightObject); &nbsp; 重大优化之前对每一个mesh的所有材质纹理，我们都会使用TextureLoader类去加载绑定，这个加载纹理的过程是很费时的。由于不同的mesh，它们的纹理可能是相同的，所以很有可能会出现同一张纹理加载了好几次。这无疑是浪费，需要避免。 怎么判断要加载的纹理已经被加载过了呢？判断要加载的纹理路径是否和已加载的纹理的路径相同即可。所以，我们需要给Texture结构体添加一个属性texPath来标识纹理的路径：12345struct Texture &#123; GLuint id; string samplerName; string texPath;&#125;; 还需要设置一个Texture结构体数组，用来存储已经加载过的纹理：1vector&lt;Texture&gt; loadedTextures; //存储已经加载过的纹理 在加载纹理之前，我们先判断要加载的纹理路径是否有和已加载纹理的路径相同的：12345678bool skip = false; //纹理是否已经加载过for (int j = 0; j &lt; loadedTextures.size(); j++) &#123; if (texPath == loadedTextures[j].texPath) &#123; skip = true; textures.push_back(loadedTextures[j]); break; &#125;&#125; 用bool变量skip来标识纹理是否已经加载过，如果要加载的纹理路径和已加载的某一纹理的路径相同，那么textures直接添加已加载的纹理即可，不用再去加载一次纹理，并且设置skip为真，标识纹理已经加载过，退出循环。 如果纹理没有被加载过，for循环里的内容就一直不会被执行，skip将为假，这时就需要去加载纹理了。加载完后不要忘了把纹理路径存储到Texture结构体变量中，并且把该结构体变量添加到已加载纹理数组loadedTextures中：123456789if (!skip) &#123; Texture texture; TextureLoader textureLoader; texture.id = textureLoader.LoadTexture(texPath.c_str()); texture.samplerName = "diffuse_texture" + IntToString(i); texture.texPath = texPath; textures.push_back(texture); loadedTextures.push_back(texture);&#125; 对于镜面纹理，也是一样的优化处理，不再赘述。 所有源码到此，所有源码在这里 【注】： 主程序里去掉了对光源物体的绘制。 编译运行后的结果如下：&nbsp; 参考文献：LearnOpenGL]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>模型加载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenGL13：常见光源]]></title>
    <url>%2F2016%2F12%2F17%2FOpenGL13%E5%B8%B8%E8%A7%81%E5%85%89%E6%BA%90%2F</url>
    <content type="text"><![CDATA[几种常见的光源类型在前面的文章中，我们使用的其实都是一个点光源。现在我们将介绍几种常见的的光源类型： 定向光Directional Light：类似太阳光，每条光线平行，指向同一个方向 点光源Point Light：类似灯泡，向四周发光 聚光Spot Light：类似手电筒，只向某个方向照射 它们的图示如下：&nbsp; 定向光Directional Light定向光源类似于太阳，光源很远，每条光线接近于平行，所有光线都是同一个方向。定向光的方向和光源在哪个位置无关，因为无限远嘛。 由于定向光方向是一个固定值，所以在计算漫反射光时，就不需要用光源位置和片元位置来计算入射光线方向了，直接使用定向光方向这个固定值就可以（对所有片元来说入射光方向都是这个值）。我们先把定向光方向加入光源结构体里：12345678//定向光源struct Light&#123; vec3 direction; vec3 ambient; vec3 diffuse; vec3 specular;&#125;;uniform Light light; //光源变量 对于定向光来说，就不需要定义光源位置了，因为定向光源是无限远的，而且也用不上。 当然，需要给这个定向光方向赋值：12//设置定向光的方向glUniform3f(glGetUniformLocation(lightObject.shaderProgram, "light.direction"), 1.0f, -1.0f, -1.0f); 在计算漫反射光时，入射光方向需要变一下，现在是定向光方向的反方向（因为入射光方向需要从片元到光源，而定向光方向是从光源到片元的）：1vec3 lightDir=normalize(-light.direction); //光线入射方向的单位向量 为了清晰地看出定向光对所有物体都有相同的影响，我们还是画10个箱子出来：123456789glBindVertexArray(lightObjectVAO);for (int i = 0; i &lt; 10; i++) &#123; mat4 lightObject_model; lightObject_model = translate(lightObject_model, cubeTranlate[i]); lightObject_model = rotate(lightObject_model, radians(105.0f), vec3(0.5f, 1.0f, 1.0f)); glUniformMatrix4fv(glGetUniformLocation(lightObject.shaderProgram, "model"), 1, GL_FALSE, value_ptr(lightObject_model)); glDrawElements(GL_TRIANGLES, 36, GL_UNSIGNED_INT, 0);&#125;glBindVertexArray(0); 编译运行后的结果如下：在场景中移动摄像机，会感觉有一个太阳一样的光源照射在这些物体上。 下面是受光物体的像素着色器源码：123456789101112131415161718192021222324252627282930313233343536373839#version 330 core//材质结构体struct Material&#123; sampler2D diffuse; sampler2D specular; float shininess;&#125;;//定向光源struct Light&#123; //vec3 position; //定向光不再需要光源位置了，因为它是无限远的 vec3 direction; vec3 ambient; vec3 diffuse; vec3 specular;&#125;;in vec3 Normal;in vec3 positionInWorld;in vec2 TexCoords;out vec4 color;uniform Material material; //材质变量uniform Light light; //光源变量uniform vec3 viewPos; //观察位置void main()&#123; //计算最终的环境光 vec3 ambientColor=light.ambient * vec3(texture(material.diffuse,TexCoords)); //环境光 //计算最终的漫反射光 vec3 normal=normalize(Normal); //单位法向量 vec3 lightDir=normalize(-light.direction); //光线入射方向的单位向量 float diffuseFactor=max(dot(normal,lightDir),0.0); //漫反射系数（两个向量夹角的余弦） vec3 diffuseColor=diffuseFactor * light.diffuse * vec3(texture(material.diffuse,TexCoords)); //漫反射光 //计算最终的镜面反射光 vec3 reflectDir=normalize(reflect(-lightDir,normal)); //反射光方向 vec3 viewDir=normalize(viewPos-positionInWorld); //观察方向 float specularFactor=pow(max(dot(reflectDir,viewDir),0.0),material.shininess); //镜面反射系数 vec3 specularColor=specularFactor * light.specular * vec3(texture(material.specular,TexCoords)); //镜面反射光 color=vec4(ambientColor+diffuseColor+specularColor,1.0f);&#125; &nbsp; 点光源Point Light点光源就是我们之前一直用的那种光源，它类似于一个灯泡在向四周发光。它需要用点光源位置和片元位置去计算入射光方向。 从前的点光源下面是点光源照射的一个例子：可以看到，离点光源越近的地方越亮，离得越远越暗。点光源的亮度随着距离增大应该是有一个衰减过程的。但是我们之前一直在用的点光源并没有考虑到这一点。下面的图片是我们用从前的点光源照射情况：可以看到离点光源（白色方块）越远的箱子并没有越暗。 点光源亮度衰减随着光线穿越距离的变远，亮度也随之降低的现象，通常称之为衰减。这种衰减不是线性的，它是开始的时候衰减得非常快，之后随着距离增加，减少的速度回慢下来。 其实衰减系数和$F_{att}$和$d$之间的关系如下：$$\begin{equation}F_{att} = \frac{1.0}{K_c + K_l * d + K_q * d^2}\end{equation}$$这里d表示片元到光源的距离，$K_c$表示常系数，值通常是1.0，它的作用是保证分母不会比1小，$K_l$是线性衰减系数，$K_q$是二次衰减系数。 下面的图展示了d在100以内的衰减趋势： 一些经验值上面公式的常系数、一次项系数、二次项系数应该取多少才有较好的效果呢？经过很多实验和经验总结，下表展示的各项值会有比较好的衰减效果：【注】： 上表中的距离d是我们想要点光源照射到的距离（球半径），比如第一行，当距离到达7的时候亮度几乎为0。 实现衰减的点光源下面我们在像素着色器中来计算这个衰减系数，实现点光源的衰减效果。 由于按公式计算衰减系数，我们需要常数项、一次项、二次项这三个系数，所以我们先把它们定义到点光源结构体中：1234567891011//点光源结构体struct Light&#123; vec3 position; vec3 ambient; vec3 diffuse; vec3 specular; float constant; //常数项 float linear; //一次项 float quadric; //二次项&#125;;uniform Light light; //光源变量 这里我们希望点光源覆盖50的距离，从表中找到对应的各项系数，在主程序中把它们赋值给点光源结构体的相应变量：1234//设置点光源衰减公式的常数项、一次项、二次项glUniform1f(glGetUniformLocation(lightObject.shaderProgram, "light.constant"), 1.0f);glUniform1f(glGetUniformLocation(lightObject.shaderProgram, "light.linear"), 0.09f);glUniform1f(glGetUniformLocation(lightObject.shaderProgram, "light.quadric"), 0.032); 有了衰减公式中的这些系数，还需要片元到点光源的距离，我们就能在像素着色器中计算出衰减系数了。我们可以使用GLSL的内置函数length来计算片元到点光源的距离：1float distance=length(light.position-positionInWorld); 然后使用距离和这些系数来计算衰减系数：1float attenuation=1.0f/(light.constant+light.linear*distance+light.quadric*distance*distance); 最后，需要让点光源的每种成分光都执行这种衰减，即乘上衰减系数：1234//点光源的每种成分光都执行衰减ambientColor*=attenuation;diffuseColor*=attenuation;specularColor*=attenuation; 编译运行后的结果如下：可以看到离点光源远的物体明显越来越暗了。 全部源码实现衰减的点光源的全部源码在这里。&nbsp; 聚光Spot Light 聚光计算原理聚光类似手电筒发出的光，只在一个指定的范围内发散，如下图所示：聚光灯可以由3个参数确定： SpotDir：聚光灯的灯轴方向，即图中的红线 LightPos：聚光灯的位置 Cutoff：聚光灯的张角，即图中的$\phi$ 我们要做的就是：判断片元是不是在聚光灯照射的范围内。比如图中圈出来的那个片元，聚光灯到该片元的方向是那条黑线，和红线灯轴的夹角（称为偏轴角）为$\theta$，如果$\theta \lt \phi$，则片元在聚光范围内，应该受到光照；否则，片元落在聚光范围外，将得不到光照。 实现聚光聚光灯可以由灯轴方向、灯位置、张角来确定，需要把它们添加到像素着色器的聚光灯结构体中：123456789101112131415161718192021222324//聚光灯结构体struct Light&#123; vec3 position; //聚光灯位置 vec3 lightAxis; //灯轴方向 float cutOff; //张角 float constant; //常数项 float linear; //一次项 float quadric; //二次项 vec3 ambient; vec3 diffuse; vec3 specular;&#125;;uniform Light light; //光源变量``聚光也有随着距离衰减的效果，所以我们保留了点光源的参数和相应计算。接下来需要对新添加的这三个元素赋值：````c++ //设置聚光灯的位置、灯轴、张角 glUniform3f(glGetUniformLocation(lightObject.shaderProgram, "light.position"), mycamera.cameraPos.x, mycamera.cameraPos.y, mycamera.cameraPos.z); glUniform3f(glGetUniformLocation(lightObject.shaderProgram, "light.lightAxis"), mycamera.cameraToTarget.x, mycamera.cameraToTarget.y, mycamera.cameraToTarget.z); glUniform1f(glGetUniformLocation(lightObject.shaderProgram, "light.cutOff"), cos(radians(12.5f))); 因为在游戏中，很多时候聚光都用在主角身上，所以我们把聚光灯的位置设为了摄像机的位置，灯轴设为了摄像机照射的方向（从摄像机指向目标的向量），张角这里我们设为了12.5度的余弦值，因为后面用点乘计算出来的片元偏轴角是余弦值，所以我们这里张角也用余弦值，否则用acos转化为弧度的话计算代价是很高昂的。【注】： 在特殊需要下，聚光灯也可以在其他位置，其他朝向，可以自定义 有了聚光灯的这三个值，我们就可以在像素着色器中，计算片元的偏轴角了：12//计算聚光灯下片元的偏轴角（余弦值）float theta=dot(normalize(positionInWorld-light.position),normalize(light.lightAxis)); 然后让片元的偏轴角$\theta$余弦值和聚光灯的张角$\phi$余弦值作比较，如果大于，则说明片元在聚光范围内，执行跟点光源一样的光照计算；否则该片元就显示黑色，表示没有受到光照：12345678//计算聚光灯下片元的偏轴角（余弦值）float theta=dot(normalize(positionInWorld-light.position),normalize(light.lightAxis));if(theta &gt; light.cutOff)&#123; //执行和点光源一样的光照计算&#125;else&#123; //片元在聚光范围外呈现黑色 color=vec4(0.0f,0.0f,0.0f,1.0f);&#125; 编译运行后的结果如下：当然，片元超出聚光范围后不一定只能是黑色，也可以是其他颜色，看我们怎么设置了。如果片元超出聚光范围后，呈现环境光颜色：123else&#123; //片元在聚光范围外时使用环境光，使其不至于完全黑暗 color=vec4(light.ambient*vec3(texture(material.diffuse,TexCoords)),1.0f);&#125; 那么显示结果会是下面这样： 软化边缘上面的聚光灯看起来有点假，因为聚光边缘有个硬边。在像素着色器的逻辑中，片元一旦操作聚光范围，它就会理解黑下来，变成环境光，却没有任何平滑减弱的过度。真实的聚光在它的边界应该是慢慢向外减弱的。 为了实现聚光在边缘的平滑减弱，我们给聚光灯定义一个内张角$\phi$和外张角$\gamma$：内张角还是原来的张角，外张角比内张角稍大：12345678//聚光灯结构体struct Light&#123; vec3 position; //聚光灯位置 vec3 lightAxis; //灯轴方向 float inCutOff; //内张角 float outCutOff; //外张角 ...&#125; 12glUniform1f(glGetUniformLocation(lightObject.shaderProgram, "light.inCutOff"), cos(radians(12.5f)));glUniform1f(glGetUniformLocation(lightObject.shaderProgram, "light.outCutOff"), cos(radians(17.5f))); 在内张角里的片元还是像上面一样，执行和点光源一样的光照计算；处在内张角和外张角之间的片元，亮度$I$在内张角余弦外张角余弦之间线性插值：$$\begin{equation}I = \frac{\theta - \gamma}{\phi - \gamma}\end{equation}$$如果片元在内张角里面，这个值会大于1，我们把它截断为1；如果片元在外张角外面，这个值会小于0，我们把它截断为0：1234//计算聚光灯下片元的偏轴角（余弦值）float theta=dot(normalize(positionInWorld-light.position),normalize(light.lightAxis));//计算片元在聚光灯下的光强float intensity=clamp((theta-light.outCutOff)/(light.inCutOff-light.outCutOff),0.0,1.0); 这样一来，乘以光照计算出来的颜色值后，在内张角里面的片元会正常执行光照，在外张角外面的片元会显示黑色，在内外张角之间的片元会插值变暗（不再需要if-else了，如果想要在外张角外显示其他颜色，那还是需要的）：123456//聚光的每种成分光都执行衰减和亮度插值ambientColor*=attenuation*intensity;diffuseColor*=attenuation*intensity;specularColor*=attenuation*intensity;color=vec4(ambientColor+diffuseColor+specularColor,1.0f); 编译运行后的结果如下：使用聚光的全部源码在这里。&nbsp; 多个光源为了简介、提高代码重用率，我们把各种光源的计算分别写成一个函数：对定向光的计算写在CalcDirLight函数中，对点光源的计算写在CalcPointLight函数中，对聚光的计算写在CalcSpotLight函数中。这三个函数的代码和原来的几乎一样，只不过是拿出来放到了函数里而已。 当我们要使用多个光源时，就可以直接使用这几个光源函数了，一般都是下面这种使用结构：1234567891011121314out vec4 color;#define NUM_POINT_LIGHTS 4 void main()&#123; //添加定向光计算结果到输出颜色里 vec3 result = CalcDirLight(); //添加点光源计算结果到输出颜色里 for(int i=0; i&lt;NUM_POINT_LIGHTS; i++)&#123; result += CalcPointLight(); &#125; //添加聚光计算结果到输出颜色里 result += CalcSpotLight(); color=vec4(result,1.0f);&#125; 其中NUM_POINT_LIGHTS表示点光源的数目，是一个预编译指令，这样我们才能用它来作为数组下标。 这里，我们在场景中创建1个定向光、4个点光源和1个聚光。代码很好理解，所有源码在这里。 其余代码和上一篇文章《OpenGL12：光照贴图》一样。编译运行后的结果如下：&nbsp; 参考文献：LearnOpenGL]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>常见光源</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenGL12：光照贴图Lighting Maps]]></title>
    <url>%2F2016%2F12%2F14%2FOpenGL12%E5%85%89%E7%85%A7%E8%B4%B4%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[为何需要光照贴图在上一篇文章《OpenGL11：材质》中，我们给整个立方体定义了一个材质，但是显示世界的物体往往不是同一种材料构成的，物体上的不同部分可能需要不同的材质。例如汽车的车身喷漆了往往很光亮，而轮胎的橡胶部分则比较暗淡。为了更好地模拟现实中物体接收光照的效果，我们应该为物体的不同部分指定不同的材质属性，而不是整个物体共用一个材质属性。 要让不同的部分对应不同的材质属性，如果不同材质的部分比较多，要精确定义很多材质是很麻烦的。其实为不同部分对应不同的材质属性，有点类似于不同的像素根据纹理坐标获取不同的纹素，这里我们我们的解决方案类似，也是使用一张纹理的纹素来作为物体上对应位置的材质属性（环境属性、漫反射属性、镜面反射属性，这些属性都是vec3类型的颜色）。对应光照下的材质属性的这种纹理叫做光照贴图lighting maps。我们这里主要介绍漫反射贴图diffuse map和镜面反射贴图specular maps（当然除此之外还有其他类型的光照贴图）。【注】： 材质的环境属性和漫反射属性通常都是相等的，都是一个颜色，所以就都使用漫反射贴图了，一般不再需要环境贴图了。&nbsp; 漫反射贴图diffuse map我们使用漫反射贴图的纹素颜色来代替材质的环境属性和漫反射属性。 首先，我们加载下面一张图片，它是一个由一圈钢边的木箱：需要用到《OpenGL5：纹理》一文中的纹理加载类，所以先创建和包含相应的头文件：1#include "TextureLoader.h" 接着使用该类的LoadTexture函数加载木箱图片：12TextureLoader textureLoader;GLuint diffuseMap = textureLoader.LoadTexture("container2.png"); 为了合理使用这张纹理，我们的顶点属性里面也应该加上纹理坐标属性：12345678910111213141516171819202122232425262728293031323334//立方体各面顶点的坐标、法线、纹理坐标GLfloat vertices[] = &#123; //位置坐标 //法线 //纹理坐标 //立方体前面 0.5f, 0.5f, 0.5f, 0, 0, 1, 1.0f, 1.0f, 0.5f,-0.5f, 0.5f, 0, 0, 1, 1.0f, 0.0f, -0.5f,-0.5f, 0.5f, 0, 0, 1, 0.0f, 0.0f, -0.5f, 0.5f, 0.5f, 0, 0, 1, 0.0f, 1.0f, //立方体后 0.5f, 0.5f,-0.5f, 0, 0,-1, 1.0f, 1.0f, 0.5f,-0.5f,-0.5f, 0, 0,-1, 1.0f, 0.0f, -0.5f,-0.5f,-0.5f, 0, 0,-1, 0.0f, 0.0f, -0.5f, 0.5f,-0.5f, 0, 0,-1, 0.0f, 1.0f, //立方体上面 0.5f, 0.5f, 0.5f, 0, 1, 0, 1.0f, 1.0f, 0.5f, 0.5f,-0.5f, 0, 1, 0, 1.0f, 0.0f, -0.5f, 0.5f,-0.5f, 0, 1, 0, 0.0f, 0.0f, -0.5f, 0.5f, 0.5f, 0, 1, 0, 0.0f, 1.0f, //立方体下面 0.5f,-0.5f, 0.5f, 0,-1, 0, 1.0f, 1.0f, 0.5f,-0.5f,-0.5f, 0,-1, 0, 1.0f, 0.0f, -0.5f,-0.5f,-0.5f, 0,-1, 0, 0.0f, 0.0f, -0.5f,-0.5f, 0.5f, 0,-1, 0, 0.0f, 1.0f, //立方体右面 0.5f, 0.5f, 0.5f, 1, 0, 0, 1.0f, 1.0f, 0.5f, 0.5f,-0.5f, 1, 0, 0, 1.0f, 0.0f, 0.5f,-0.5f,-0.5f, 1, 0, 0, 0.0f, 0.0f, 0.5f,-0.5f, 0.5f, 1, 0, 0, 0.0f, 1.0f, //立方体左面 -0.5f, 0.5f, 0.5f, -1, 0, 0, 1.0f, 1.0f, -0.5f, 0.5f,-0.5f, -1, 0, 0, 1.0f, 0.0f, -0.5f,-0.5f,-0.5f, -1, 0, 0, 0.0f, 0.0f, -0.5f,-0.5f, 0.5f, -1, 0, 0, 0.0f, 1.0f&#125;; 当然，这下对顶点属性的解析也应该更新一下了：123456glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(GLfloat), (GLvoid*)0);glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(GLfloat), (GLvoid*)(3 * sizeof(GLfloat)));glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(GLfloat), (GLvoid*)(6 * sizeof(GLfloat)));glEnableVertexAttribArray(0);glEnableVertexAttribArray(1);glEnableVertexAttribArray(2); 还需要在受光物体的顶点着色器中增加输入变量，用来接收纹理坐标，还要把它输出到像素着色器：12345678layout (location=2) in vec2 texCoords; //顶点纹理坐标属性的位置值为2out vec2 TexCoords;void main()&#123; ... TexCoords=texCoords;&#125; 像素着色器要设置一个输入变量，来接收来自顶点着色器的纹理坐标：1in vec2 TexCoords; 既然是用纹素颜色来代替材质的环境属性和漫反射属性，那么：123456//材质结构体struct Material&#123; sampler2D diffuse; vec3 specular; float shininess;&#125;; 和读取纹素颜色一样，我们需要把diffuse设置为一个采样器，用于根据纹理坐标，从纹理中提取纹素颜色。材质的环境属性和漫反射属性通常是等值的，所以这里就省略环境属性的采样器了。 需要在主函数中，对这个采样器赋值：12//设置材质的环境属性和漫反射属性（都来自漫反射贴图，这里设置的是采样器/纹理单元的值）glUniform1i(glGetUniformLocation(lightObject.shaderProgram, "material.diffuse"), 0); 接下来就是使用纹素颜色来更新环境光和漫反射光的计算了：1234567//计算最终的环境光vec3 ambientColor=light.ambient * vec3(texture(material.diffuse,TexCoords)); //环境光//计算最终的漫反射光vec3 normal=normalize(Normal); //单位法向量vec3 lightDir=normalize(light.position-positionInWorld); //光线入射方向的单位向量float diffuseFactor=max(dot(normal,lightDir),0.0); //漫反射系数（两个向量夹角的余弦）vec3 diffuseColor=diffuseFactor * light.diffuse * vec3(texture(material.diffuse,TexCoords)); //漫反射光 最后，需要激活相应纹理单元和绑定纹理，再进行渲染：123456//激活纹理单元glActiveTexture(GL_TEXTURE0);glBindTexture(GL_TEXTURE_2D, diffuseMap);glBindVertexArray(lightObjectVAO);glDrawElements(GL_TRIANGLES, 36, GL_UNSIGNED_INT, 0);glBindVertexArray(0); 编译运行后的结果如下：&nbsp; 镜面贴图speculate map上面的物体是一个带钢边的木箱，木箱部分应该是没有高光的（或者高光很弱）才对。也就是说一个物体的不同部分可能有不同的镜面反射效果。和不同部分有不同漫反射效果类似，我们使用一张镜面贴图来表示对应不同部分的不同镜面反射效果，即用镜面贴图的纹素来代替材质的镜面反射属性。通常在镜面贴图中，镜面反射强度大的用接近白色的颜色表示，反射强度小的用接近黑色的颜色表示。使用ps或gimp之类的工具，通过将图片进行裁剪，将某部分调整成黑白图样，并调整亮度/对比度，可以很容易吧一个diffuse贴图处理成specular贴图。我们这里给准备上面的箱子使用的镜面贴图如下：木箱子部分不镜面反射，只有钢边部分才有镜面光。 使用这张镜面贴图的过程和上面漫反射贴图类似，简单走一下： 首先加载镜面贴图：1GLuint specularMap = textureLoader.LoadTexture("container2_specular.png"); 然后在受光物体的像素着色器中，把材质的镜面属性改为采样器类型：123456//材质结构体struct Material&#123; sampler2D diffuse; sampler2D specular; float shininess;&#125;; 需要对specular采样器赋值：12//设置材质的镜面反射属性（来自镜面贴图）glUniform1i(glGetUniformLocation(lightObject.shaderProgram, "material.specular"), 1); 在像素着色器中更新对镜面光的计算：1vec3 specularColor=specularFactor * light.specular * vec3(texture(material.specular,TexCoords)); //镜面反射光 最后，在主程序渲染前激活相应纹理单元并绑定：123456789//激活纹理单元0并绑定glActiveTexture(GL_TEXTURE0);glBindTexture(GL_TEXTURE_2D, diffuseMap);//激活纹理单元1并绑定glActiveTexture(GL_TEXTURE1);glBindTexture(GL_TEXTURE_2D, specularMap);glBindVertexArray(lightObjectVAO);glDrawElements(GL_TRIANGLES, 36, GL_UNSIGNED_INT, 0);glBindVertexArray(0); 编译运行后的结果如下：可以看到这个箱子明显真实多了！&nbsp; 使用漫反射光照贴图和镜面贴图的所有源码在这里。 其余代码不变，和《OpenGL10：光照基础Phong模型》一样。&nbsp; 参考文献：LearnOpenGL]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>光照贴图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenGL11材质]]></title>
    <url>%2F2016%2F12%2F12%2FOpenGL11%E6%9D%90%E8%B4%A8%2F</url>
    <content type="text"><![CDATA[材质概述在真实世界里，每个物体会对光产生不同的反应。钢看起来比陶瓷花瓶更闪闪发光，木头箱子肯定不会像钢箱子那样对光产生很强的反射。每个物体对镜面高光也有不同的反应。有些物体不会散射（scatter）很多光却会反射（reflect）很多光，结果看起来就有一个较小的高光点（highlight）；有些物体散射了很多，它们就会产生一个半径更大的高光（这其实就是镜面高光系数的体现）。如果我们想要模拟不同物体接受光照后的效果，就需要考虑物体的材质属性， 利用材质属性模拟出不同的效果。材质就是不同光属性组成的一个结构体。最终用材质颜色来代替《OpenGL10》中的物体本身颜色objectColor。&nbsp; 定义材质结构体在OpenGL10中，我们使用了冯氏光照模型来模拟复杂的光照，它有三种元素：环境光颜色、漫反射光颜色、镜面反射光颜色，我们这里再加上镜面高光系数，一起作为材质的属性，在像素着色器中组成材质结构体：1234567//材质结构体struct Material&#123; vec3 ambient; vec3 diffuse; vec3 specular; float shininess;&#125;; 其中ambientColor材质属性定义了在环境光照下这个物体反射的是什么颜色，通常这个值和物体本身颜色相同；diffuseColor材质属性定义了在漫反射光照下物体的颜色；specularColor材质属性定义了在镜面光照下的反射颜色；shininess材质属性定义了镜面高光系数。 这些属性指定了物体在不同光照下的颜色效果，用这些颜色来代替物体本身的颜色。让物体在环境光、漫反射光、镜面光下有不同的颜色，不同的颜色组合，就有了不同的材质。 当然，要使用这个材质结构体，我们还要定义一个结构变量：1uniform Material material; //材质变量 定义为uniform变量后，我们就可以在主程序中设置这个材质的各个属性值。&nbsp; 为材质赋值我们可以在主程序中为这个uniform变量material赋值，不过在glGetUniformLocation函数中，填写uniform变量名称时需要带上结构体变量名字作为前缀：123456789101112//设置材质的环境属性GLint matAmbientLoc = glGetUniformLocation(lightObject.shaderProgram, "material.ambient");glUniform3f(matAmbientLoc, 1.0f, 0.5f, 0.31f);//设置材质的漫反射属性GLint matDiffuseLoc = glGetUniformLocation(lightObject.shaderProgram, "material.diffuse");glUniform3f(matDiffuseLoc, 1.0f, 0.5f, 0.31f);//设置材质的镜面反射属性GLint matSpecularLoc = glGetUniformLocation(lightObject.shaderProgram, "material.specular");glUniform3f(matSpecularLoc, 0.5f, 0.5f, 0.5f);//设置材质的镜面高光系数属性GLint matShininessLoc = glGetUniformLocation(lightObject.shaderProgram, "material.shininess");glUniform1f(matShininessLoc, 32.0f); 这里我们把ambient和diffuse属性都设置为我们想要让物体所呈现的颜色（物体本身颜色是珊瑚红，这里也设置为珊瑚红）；由于我们不希望specular镜面反射属性对这个物体产生过于强烈的影响，所以设置成了（0.5f,0.5f,0.5f）；把镜面高光系数shininess依旧设置为32。&nbsp; 更新三光的计算方式我们已经使用材质颜色来代替物体本身颜色了，所以我们需要更新环境光、漫反射光、镜面光的计算方式。 对于环境光，我们使用材质的环境光属性乘上光源颜色，就是片元最终的环境光颜色了：12//计算最终的环境光vec3 ambientColor=lightColor*material.ambient; //环境光 对于漫反射光，我们依旧需要先计算出漫反射系数，漫反射系数、光源颜色和材质的漫反射属性的乘积，就是最终的漫反射光颜色：12345//计算最终的漫反射光vec3 normal=normalize(Normal); //单位法向量vec3 lightDir=normalize(lightPos-positionInWorld); //光线入射方向的单位向量float diffuseFactor=max(dot(normal,lightDir),0.0); //漫反射系数（两个向量夹角的余弦）vec3 diffuseColor=diffuseFactor*lightColor*material.diffuse; //漫反射光 对于镜面光，依旧需要先计算出镜面反射系数，镜面反射系数、光源颜色和材质的镜面反射属性的乘积，就是最终的镜面反射光颜色：12345//计算最终的镜面反射光vec3 reflectDir=normalize(reflect(-lightDir,normal)); //反射光方向vec3 viewDir=normalize(viewPos-positionInWorld); //观察方向float specularFactor=pow(max(dot(reflectDir,viewDir),0.0),material.shininess); //镜面反射系数vec3 specularColor=specularFactor*lightColor*material.diffuse; //镜面反射光 编译运行后的结果如下：有点太亮了~~~&nbsp; 分解光源颜色上面的物体太亮了。主要是因为物体的环境属性、漫反射属性、镜面反射属性都是直接乘以光源颜色，但是我们的这个光源是环境光、漫反射光和镜面光组合在一起的，应该是环境光只对材质的环境属性起作用，不应该对材质的漫反射属性起作用。光源的成分和材质的属性应该是一一对应的。 所以，直接乘以光源颜色是不对的，会造成物体太亮。我们应该把光源颜色分解为环境光颜色、漫反射光颜色和镜面反射光颜色。和材质一样，我们也使用结构体来实现：1234567//光源struct Light&#123; vec3 position; vec3 ambient; vec3 diffuse; vec3 specular;&#125;; 当然，同样需要定义一个光源结构体变量：1uniform Light light; //光源变量 接下里需要为光源结构体的这几个属性赋值了：123456789101112//设置光源的位置GLint lightPosLoc = glGetUniformLocation(lightObject.shaderProgram, "light.position");glUniform3f(lightPosLoc, lightPos.x, lightPos.y, lightPos.z);//设置光源的环境光成分GLint lightAmbientLoc = glGetUniformLocation(lightObject.shaderProgram, "light.ambient");glUniform3f(lightAmbientLoc, 0.2f, 0.2f, 0.2f);//设置光源的漫反射光成分GLint lightDiffuseLoc = glGetUniformLocation(lightObject.shaderProgram, "light.diffuse");glUniform3f(lightDiffuseLoc, 0.5f, 0.5f, 0.5f);//设置光源的镜面反射光成分GLint lightSpecularLoc = glGetUniformLocation(lightObject.shaderProgram, "light.specular");glUniform3f(lightSpecularLoc, 1.0f, 1.0f, 1.0f); 环境光ambient通常设置为一个比较低的亮度，因为我们不希望环境色太过显眼；漫反射光是我们想要的光源颜色，通常是白色，这里我们把这个光调暗一点，看起来会更自然，设置为（0.5,0.5,0.5）；镜面反射光颜色通常被设置为（1.0f,1.0f,1.0f）的全强度发光。 最后我们需要再次更新三光的计算方式，把原来的光源颜色替换成对应的光源分量：12345678910111213141516void main()&#123; //计算最终的环境光 vec3 ambientColor=light.ambient*material.ambient; //环境光 //计算最终的漫反射光 vec3 normal=normalize(Normal); //单位法向量 vec3 lightDir=normalize(light.position-positionInWorld); //光线入射方向的单位向量 float diffuseFactor=max(dot(normal,lightDir),0.0); //漫反射系数（两个向量夹角的余弦） vec3 diffuseColor=diffuseFactor*light.diffuse*material.diffuse; //漫反射光 //计算最终的镜面反射光 vec3 reflectDir=normalize(reflect(-lightDir,normal)); //反射光方向 vec3 viewDir=normalize(viewPos-positionInWorld); //观察方向 float specularFactor=pow(max(dot(reflectDir,viewDir),0.0),material.shininess); //镜面反射系数 vec3 specularColor=specularFactor*light.specular*material.specular; //镜面反射光 color=vec4(ambientColor+diffuseColor+specularColor,1.0f);&#125; 编译运行后的结果如下：&nbsp; 不同的光源颜色上面我们给光源的各个成分赋了一个固定的颜色，现在我们把颜色变一变，让它随着时间不停变换。由于镜面反射光通常都设为白色（1.0f,1.0f,1.0f），所以我们这里只改变环境光和漫反射光：123456789101112131415//随着时间变化的环境光vec3 ambientColor(0.2f, 0.2f, 0.2f);ambientColor *= vec3(sin(glfwGetTime()* 2), sin(glfwGetTime()*0.7), sin(glfwGetTime()*1.3));//随着时间变化的漫反射光vec3 diffuseColor(0.5f, 0.5f, 0.5f);diffuseColor *= ambientColor;//设置光源的环境光成分GLint lightAmbientLoc = glGetUniformLocation(lightObject.shaderProgram, "light.ambient");glUniform3f(lightAmbientLoc, ambientColor.x, ambientColor.y, ambientColor.z);//设置光源的漫反射光成分GLint lightDiffuseLoc = glGetUniformLocation(lightObject.shaderProgram, "light.diffuse");glUniform3f(lightDiffuseLoc, diffuseColor.x, diffuseColor.y, diffuseColor.z);//设置光源的镜面反射光成分GLint lightSpecularLoc = glGetUniformLocation(lightObject.shaderProgram, "light.specular");glUniform3f(lightSpecularLoc, 1.0f, 1.0f, 1.0f); 注意这里环境光和漫反射光的三个颜色分量随时间变换的快慢应该不要一致，上面是分别给glfwGetTime函数乘以了2、0.7、1.3。如果不这样做的话，三个颜色分量步调就会一直，只能看到原有的颜色变暗了，没有明显的颜色跨度。&nbsp; 到此，所有源码在这里。 编译运行后的结果类似如下： &nbsp; 参考文献：LearnOpenGL]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>材质</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenGL10：光照基础Phong模型]]></title>
    <url>%2F2016%2F12%2F12%2FOpenGL10%E5%85%89%E7%85%A7%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[要模拟现实的光照是很困难的，例如实际光照中，一束光可以经过场景中若干物体反射后，照射到目标物体上，也可以是直接照射到目标物体上。其中经过其他物体反射后再次照射到目标物体上，这是一个递归的过程，将会无比复杂。因此实际模拟光照过程中，总是采用近似模型去接近实现光照。&nbsp; Phong模型冯氏光照模型（Phong Lighting Model）就是其中很经典的一个光照模型，它由三部分光照组成：环境光+漫反射光+镜面光。如下图所示： 环境光（ambient lighting）：环境光是场景中光源给定或者全局给定的一个光照常量，它一般很小，主要是为了模拟即使场景中没有光照时，也不是全黑的效果。场景中总有一点环境光，不至于使场景全部黑暗。例如远处的月亮、来自远处的光。 漫反射光：模拟一个发光物对另一个物体的方向性影响。比如面向光源的一面会比其他面更亮。它是Phong模型最显著的组成部分。 镜面光：模拟的是物体表面光滑时反射的高亮的光，效果就是光泽物体表面上出现的两点。镜面光反应的通常是光的颜色，而不是物体的颜色。&nbsp; 环境光Ambient Lighting一个物体受到的光照可能是光源直射的，也可能是经过物体反射过来的，总之环境光来源有很多。如果我们同时考虑直射光线和非直射光线，这种情况下的算法叫做全局光照算法。可想而知，这种算法肯定是及其复杂而且昂贵的。 这里我们使用一种简化的的全局照明模型来表示环境光：将环境光颜色设定为一个恒定值，加到片元的最终颜色里。 实现起来很简单，用恒定环境光的颜色乘以一个很小的环境因子常量，再乘以受光物体本身的颜色，就是最终在环境光影响下的物体片元颜色：1234567891011#version 330 coreout vec4 color;uniform vec3 lightColor;uniform vec3 objectColor;void main()&#123; //环境因子 float ambientStrength=0.3f; //环境光 vec3 ambientColor=ambientStrength*lightColor; color=vec4(ambientColor*objectColor,1.0f);&#125; 其余程序不变，编译运行后的结果如下：可以看到冯氏光照的环境光已经应用到受光物体上了，这个物体变得暗了一下，因为环境光弱了嘛！&nbsp; 漫反射光Diffuse Lighting从文首的环境光照图可以看到，环境光本身不提供明显的光照效果，但是漫反射光会对物体产生显著的视觉影响。漫反射光使物体上与光线排布越近的片段越能从光源处获得更多的亮度。漫反射光强度与光线入射方向和物体表面的法向量之间的夹角$\theta$有关。当$\theta =0$时，光线垂直照射物体表面，这时获得的光照强度最大；当$\theta =90$时，光线与物体表面平行，此时光线照射不到物体，物体获得的光照强度最小；当$\theta &gt;90$后，物体表面转到转到光线背面了，此时物体表面接受不到光照。 所以，我们可以用光线入射方向的单位向量和单位法向量的点乘，来表示光对片元颜色的影响程度。其实也就是用两个向量之间的夹角余弦值，因为两个向量都需要标准化，取的是单位向量。 添加法向量法向量是垂直于顶点表面的（单位）向量。由于顶点自身并没有表面（它只是空间中一个独立的点），所以我们利用顶点周围的顶点来计算出这个顶点的表面。我们可以使用叉乘来为立方体所有顶点计算出发现。但是由于3D立方体不是一个复杂的形状，所以我们可以简单的把法线数据手工添加到顶点数据中：12345678910111213141516171819202122232425262728293031323334//立方体各面顶点的坐标、法线GLfloat vertices[] = &#123; //位置坐标 //法线 //立方体前面 0.5f, 0.5f, 0.5f, 0, 0, 1, 0.5f,-0.5f, 0.5f, 0, 0, 1, -0.5f,-0.5f, 0.5f, 0, 0, 1, -0.5f, 0.5f, 0.5f, 0, 0, 1, //立方体后 0.5f, 0.5f,-0.5f, 0, 0,-1, 0.5f,-0.5f,-0.5f, 0, 0,-1, -0.5f,-0.5f,-0.5f, 0, 0,-1, -0.5f, 0.5f,-0.5f, 0, 0,-1, //立方体上面 0.5f, 0.5f, 0.5f, 0, 1, 0, 0.5f, 0.5f,-0.5f, 0, 1, 0, -0.5f, 0.5f,-0.5f, 0, 1, 0, -0.5f, 0.5f, 0.5f, 0, 1, 0, //立方体下面 0.5f,-0.5f, 0.5f, 0,-1, 0, 0.5f,-0.5f,-0.5f, 0,-1, 0, -0.5f,-0.5f,-0.5f, 0,-1, 0, -0.5f,-0.5f, 0.5f, 0,-1, 0, //立方体右面 0.5f, 0.5f, 0.5f, 1, 0, 0, 0.5f, 0.5f,-0.5f, 1, 0, 0, 0.5f,-0.5f,-0.5f, 1, 0, 0, 0.5f,-0.5f, 0.5f, 1, 0, 0, //立方体左面 -0.5f, 0.5f, 0.5f, -1, 0, 0, -0.5f, 0.5f,-0.5f, -1, 0, 0, -0.5f,-0.5f,-0.5f, -1, 0, 0, -0.5f,-0.5f, 0.5f, -1, 0, 0&#125;; 我们要把法线数据传递给顶点着色器，所以顶点着色器要增加一个法线属性：12345//顶点着色器#version 330 corelayout (location=0) in vec3 position; //顶点位置属性的位置值为0layout (location=1) in vec3 normal; //顶点法线属性的位置值为1... 当然，顶点数据变了，对顶点数据的解析也应该做出调整。由于光源颜色不受影响，所以法线数据对它无用，在光源的VAO中不必解析法线数据，只是把顶点位置属性解析的步长变为6个GLfloat就行：1glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(GLfloat), (GLvoid*)0); 对于受光物体，除此之外还需要解析法线数据：12glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(GLfloat), (GLvoid*)0);glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(GLfloat), (GLvoid*)(3 * sizeof(GLfloat))); 顶点着色器接收并调整法线数据在顶点着色器中需要增加法线输入变量和法线输出变量（传递给像素着色器）：123layout (location=1) in vec3 normal; //顶点法线属性的位置值为1out vec3 Normal; 传进顶点着色器的法线数据是在主程序顶点数据中定义的，它们是局部坐标（模型坐标），但是我们的片元到光源的方向向量却是世界坐标，所以我们需要在顶点着色器中将输入的法线向量转化为世界坐标。 但是却不是简单的用模型矩阵乘以法线向量就可以，如Normal=model*normal;，因为当模型矩阵执行了不等比缩放时，法向量就不一定垂直于表面了，如下图所示：为了修复这个问题，我们需要先把模型矩阵求逆矩阵，再转置，取左上角三行三列的矩阵部分，来和法向量相乘：1Normal=mat3(transpose(inverse(model)))*normal; 顶点着色器的全部源码见后面。 在像素着色器中计算漫反射光现在每个顶点有了正确的法向量，但是我们还需要从片元指向光源的向量，所以还需要光源的位置坐标和顶点的世界坐标。 光源的位置坐标可以从主程序用uniform变量传到像素着色器：在像素着色器中定义光源位置uniform变量：1uniform vec3 lightPos; //光源位置 然后在主程序中给该uniform变量赋值：123//设置uniform变量光源位置lightPosGLint lightPosLoc = glGetUniformLocation(lightObject.shaderProgram, "lightPos");glUniform3f(lightPosLoc, lightPos.x, lightPos.y, lightPos.z); 我们还需要顶点的世界坐标，可以在顶点着色器中让输入的顶点坐标乘以模型矩阵，就变成了顶点的世界坐标了，把结果输出到像素着色器就可以了。 现在顶点着色器中定义输出变量，用于把顶点的世界坐标传递给像素着色器：1out vec3 positionInWorld; 然后在顶点着色器的main函数中，计算出顶点的世界坐标：1positionInWorld=vec3(model*vec4(position,1.0f)); 当然还需要在像素着色器中定义一个同名输入变量，来接收顶点的世界坐标：1in vec3 positionInWorld; 在像素着色器中已经有了光源世界坐标、顶点世界坐标，我们可以用它们来计算从片元到光源的单位方向向量：1vec3 lightDir=normalize(lightPos-positionInWorld); //光线入射方向的单位向量 当然，法向量也需要标准化，变成单位向量，再用法向量刚才的光线入射方向的单位向量点乘，就可以得到漫反射光的强度（就是两个向量夹角的余弦）：123//计算漫反射光vec3 normal=normalize(Normal); //单位法向量float diffuseFactor=max(dot(normal,lightDir),0.0); //漫反射光系数（两个向量夹角的余弦） 用漫反射光强度乘以光源颜色，就能得到漫反射光颜色了。再加上之前的环境光后，乘以片元本身的颜色，就能得到最终的片元颜色了：1color=vec4((ambientColor+diffuseColor)*objectColor,1.0f); 到此，Phong模型中的环境光和漫反射光都搞定了。所有源码在这里。 &nbsp; 镜面反射光Specular Lighting和环境光一样，镜面反射光也要依据光的入射向量和法向量，但是镜面光还会依据观察方向，例如玩家是从什么方向看着这个片元的： 当镜面反射光和观察方向夹角$\theta$越小时，人眼观察到的镜面光成分越明显。镜面反射系数定义为：$specFactor=\cos (\theta)^s$。其中s是镜面高光系数 ，它的值一般为2的整数幂，值越大高光部分越集中。下图是不同高光系数下的高光效果： 求反射光线的方向向量为了计算出夹角$\theta$，我们需要先求出反射光线方向。可以使用reflect函数求出：1vec3 reflectDir=normalize(reflect(-lightDir,normal)); //反射光方向 该函数的第一个参数是从光源到片元的光线入射方向，所以需要把lightDir取反，因为之前求漫反射光的时候它是从片元指向光源的；第二个参数是法向量。当然求得的反射关系方向也需要标准化。 计算观察方向然后我们需要求出观察方向，我们这里在像素着色器中设置一个uniform变量来表示观察位置：1uniform vec3 viewPos; //观察位置 然后在主程序中把摄像机的位置赋值给该uniform变量：123//设置uniform变量观察位置viewPosGLint viewPosLoc = glGetUniformLocation(lightObject.shaderProgram, "viewPos");glUniform3f(viewPosLoc, mycamera.cameraPos.x, mycamera.cameraPos.y, mycamera.cameraPos.z); 我们再用观察位置减去顶点的世界坐标，就能得到观察方向了：1vec3 viewDir=normalize(viewPos-positionInWorld); //观察方 计算镜面反射系数有了观察方向和反射光方向，我们就可以用向量点乘求出夹角$\theta$了，从而求出镜面反射系数：1float specularFactor=pow(max(dot(reflectDir,viewDir),0.0),32); //镜面反射系数 这里为了不让镜面成分过于显眼，我们把镜面高光系数设置为32。 接下来我们还需要设置一个镜面反射强度，我们给镜面高光一个中等亮度颜色，设为0.5：1float specularStrength=0.5f; //镜面反射强度 用这个镜面反射强度乘以镜面高光系数再乘以光源颜色，就能得到镜面反射光颜色了：1vec3 specularColor=specularStrength*specularFactor*lightColor; //镜面反射光 加入镜面反射光最后，我们需要加上Phong模型的最后一个成分：镜面反射光：1color=vec4((ambientColor+diffuseColor+specularColor)*objectColor,1.0f); 环境光、漫反射光和镜面反射光的和构成了最终的光照颜色，再乘上物体本身的颜色，就是受光物体最终的输出颜色了。&nbsp; 到此，我们为Phong光照模型计算了全部光照元素。全部源码在这里。 编译运行后的结果如下：&nbsp; per-vertex和per-fragment实现光照的对比我们上面的光照计算是在像素着色器中进行的，这种是基于片元计算的，称为Phong Shading（冯氏光照）。但是早期的光照着色器，开发者是在顶点着色器中实现这些光照的，这是基于顶点计算的，称为Gouraud Shading。因为顶点相比片元来说，顶点要少得多，光照的计算频率会更低，所以会更高效。然而，如果在顶点着色器中计算冯氏光照，那么除了顶点以外的其他片元，都只是根据顶点颜色插值得到自己的颜色，这种插值后的光照显得不是很真实，没有冯氏关照的那种平滑的光照效果：基于顶点这是的Gouraud Shading想要获得更平滑的效果，就得使用更多的顶点来加以完善，下面的图分别显示了少量顶点和大量顶点的基于顶点的关照计算效果：&nbsp; 参考文献：LearnOpenGL]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>冯氏光照</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenGL9：光照场景]]></title>
    <url>%2F2016%2F12%2F10%2FOpenGL9%E5%85%89%E7%85%A7%E5%9C%BA%E6%99%AF%2F</url>
    <content type="text"><![CDATA[我们先来看看物体颜色颜色是怎么形成的。&nbsp; 光照颜色和物体颜色计算机中的颜色主要是由三基色（RGB）来表示的，用有限种颜色来模拟现实世界中（无限）的颜色，因为现实世界中能被人眼区分的颜色只有有限种，差别太小的颜色人眼是看不出来的。如果想了解屏幕颜色是如何形成的，可以参考《》 OpenGL中颜色用一个vec3向量来表示：1vec3 ourColor(1.0f,0.5f,0.31f); 在光学物理中，我们知道：我们看到的物体的颜色，其实是物体自身颜色和光源颜色相互作用（或者说相乘）的结果。比如物体本身是绿色，如果用白光去照它，那么物体会反射绿光，吸收其他色光，所以我们看到的物体颜色就是绿色；但是如果物体颜色是绿色，用红光去照它，那么物体就会把红色光全部吸收，没有反射光，所以我们看到的物体颜色就是黑色。 所以，物体颜色可以定义为这个物体从一个光源反射各个颜色分量的多少。 比如光源颜色是深橄榄绿色，物体颜色是珊瑚红，那么最后被人眼看到的物体颜色是：123vec3 lightColor(0.33f, 0.42f, 0.18f); //深橄榄绿色vec3 objectColor(1.0f, 0.5f, 0.31f); //珊瑚红vec3 result = lightColor * toyColor; // = (0.33f, 0.21f, 0.06f); &nbsp; 下面我们来创建一个最基本的光照场景。 创建一个光照场景我们需要在场景中创建一个光源，设置为白色；还需要一个受光物体（被光源照射的物体）。光源和受光物体我们都用前面文章里的立方体来表示。 我们这里立方体的顶点数据只有顶点坐标，暂时不要颜色和纹理坐标属性了。顶点数据见后面的完整代码。 由于后面的文章里，我们还需要继续使用这个光照场景，后面会频繁地对物体顶点数据做一些改变，但是我们并不想因此影响到灯，所以我们光源和受光物体应该当做两个不同的立方体来绘制，不像前面文章里的10个物体都可以绑定一个VAO来绘制。我们这里给光源和受光物体分别创建一个VAO：1234567891011121314151617181920212223//光源VAOGLuint lightSourceVAO, VBO, EBO;glGenVertexArrays(1, &amp;lightSourceVAO);glGenBuffers(1, &amp;VBO);glGenBuffers(1, &amp;EBO);glBindVertexArray(lightSourceVAO);glBindBuffer(GL_ARRAY_BUFFER, VBO);glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(GLfloat), (GLvoid*)0);glEnableVertexAttribArray(0);glBindVertexArray(0);//受光物体VAOGLuint lightObjectVAO;glGenVertexArrays(1, &amp;lightObjectVAO);glBindVertexArray(lightObjectVAO);glBindBuffer(GL_ARRAY_BUFFER, VBO);glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(GLfloat), (GLvoid*)0);glEnableVertexAttribArray(0);glBindVertexArray(0); 由于受光立方体的顶点数据和此时光源立方体的顶点数据相同，所以在受光物体的VAO中可以直接使用光源立方体的VBO和EBO，直接绑定即可，不用再使用glBufferData函数把数据发送到显存。 接下里我们需要给光源和受光物体分别设置顶点着色器和像素着色器（因为这是两个渲染效果不同的物体，不能使用同一套着色器）：光源的顶点着色器和受光物体的顶点着色器都是如下：12345678910111213//顶点着色器#version 330 corelayout (location=0) in vec3 position; //顶点位置变量的属性位置值为0//模型矩阵uniform mat4 model;//观察矩阵uniform mat4 view;//投影矩阵uniform mat4 projection;void main()&#123; gl_Position=projection * view * model * vec4(position,1.0f);&#125; 光源的像素着色器代码如下（光源颜色始终是白色）：12345#version 330 coreout vec4 color;void main()&#123; color=vec4(1.0f,1.0f,1.0f,1.0f);&#125; 受光物体的像素着色器代码如下：1234567#version 330 coreout vec4 color;uniform vec3 lightColor;uniform vec3 objectColor;void main()&#123; color=vec4(lightColor*objectColor,1.0f);&#125; 受光物体的像素着色器里有两个uniform变量，用于从主程序里接收光源颜色和物体本身颜色，输出颜色是这两个颜色的乘积。 在主程序里，我们给这两个uniform变量赋值：1234GLint lightColorLoc = glGetUniformLocation(lightObject.shaderProgram, "lightColor");GLint objectColorLoc = glGetUniformLocation(lightObject.shaderProgram, "objectColor");glUniform3f(lightColorLoc, 1.0f, 1.0f, 1.0f);glUniform3f(objectColorLoc, 1.0f, 0.5f, 0.31f); 上面lightObject是受光物体的着色器类对象。 我们还需要把这两个物体放在不同位置上。对于光源我们先给它设置一个全局变量，表示光源位置：12//光源位置vec3 lightPos(1.0f, 0.0f, -3.0f); 接着在模型矩阵中设置光源所处的位置，旋转角度和缩放系数：12345//模型矩阵 mat4 lightSource_model; lightSource_model = translate(lightSource_model, lightPos); lightSource_model = rotate(lightSource_model, radians(15.0f), vec3(0.5f, 1.0f, 1.0f)); lightSource_model = scale(lightSource_model, vec3(0.5f)); 当然，受光物体的模型矩阵也需要做一些类似变换：12mat4 lightObject_model;lightObject_model = translate(lightObject_model, vec3(-1, 0, 0)); 接下来就是需要给两个物体设置观察矩阵和投影矩阵了，它俩在同一场景里，观察矩阵和投影矩阵应该是一样的：1234//观察矩阵mat4 view = mycamera.GetViewMatrix();//投影矩阵mat4 projection = perspective(radians(mycamera.cameraFov), (GLfloat)WIDTH / (GLfloat)HEIGHT, 0.1f, 100.0f); 当然，不要忘了把模型、观察、投影矩阵赋值给相应的uniform变量（两个物体的像素着色器里都有这些uniform变量，都需要赋值）。 最后就是渲染出光源物体和受光物体了，需要分别绑定各自的VAO：光源的绑定和渲染：123456//绑定VAO，完成顶点输入初始化glBindVertexArray(lightSourceVAO);//绘图glDrawElements(GL_TRIANGLES, 36, GL_UNSIGNED_INT, 0);//解绑VAOglBindVertexArray(0); 受光物体的绑定和渲染：123glBindVertexArray(lightObjectVAO);glDrawElements(GL_TRIANGLES, 36, GL_UNSIGNED_INT, 0);glBindVertexArray(0); 注意，它俩需要分别在各自的program.use激活着色器程序对象之后。&nbsp; 到此，我们就构建完这个最基本的光照场景了。全部源码在这里。 编译运行后，结果如下：&nbsp; 参考文献：LearnOpenGL]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>光照场景</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenGL8：摄像机]]></title>
    <url>%2F2016%2F12%2F08%2FOpenGL8%E6%91%84%E5%83%8F%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[OpenGL本身没有摄像机的概念，是我们虚构的，我们通过把场景往反方向移动的方式来模拟出摄像机，产生一种我们在移动的感觉。&nbsp; 摄像机坐标系（观察坐标系）摄像机默认位置是在世界空间原点，通过观察矩阵把所有的世界坐标转化为相对于摄像机位置与方向的观察坐标。但是通过观察矩阵，摄像机不一定要在原点，也是可以移动的，这就有了我们在游戏中用键盘鼠标手柄等移动视角的效果。 观察矩阵就是把世界坐标系通过矩阵变换转化为观察坐标系。那么观察坐标系是怎么构成的呢？ 观察坐标系的组成需要有4个要素构成： 摄像机的世界坐标，用来作为观察坐标系的原点，对应下面第一幅图中的摄像机位置。 12//摄像机位置vec3 cameraPos = vec3(0.0, 0.0, 3.0f); 观察坐标系的+z轴。通常用摄像机照射的目标位置到指向摄像机位置的向量来表示，对应下面第二幅图中的蓝色轴。 1234//摄像机目标位置vec3 cameraTarget = vec3(0.0f, 0.0f, 0.0f);//摄像机+z轴（从目标位置指向摄像机）vec3 targetToCamera = normalize(cameraPos - cameraTarget); 观察坐标系的+x轴。需要先有一个上向量，指明摄像机的正上方。再用上向量和+z轴做叉乘，得到+x轴，对应下面第三幅图（灰色的是上向量，红色的是+x轴）： 1234//摄像机上向量vec3 upVector = vec3(0.0f, 1.0f, 0.0f);//摄像机+x轴（上向量和+z轴的叉乘）vec3 cameraRight = normalize(cross(upVector, targetToCamera)); 观察坐标系的+y轴。由+z轴和+x轴做叉乘得到，对应下面第四幅图中的绿色轴： 12//摄像机+y轴（+z轴和+x轴的叉乘）vec3 cameraUp = normalize(cross(targetToCamera, cameraRight)); 有了原点、x、y、z轴，我们就可以构建摄像机坐标系（观察坐标系）了。&nbsp; 世界坐标系转化到观察坐标系怎么把世界坐标系转到到观察坐标系呢？先上一个线性代数中的定理（证明可参考相关线性代数教材）： 线性变换可以通过基及变换后的基唯一确定，且通过计算线性变换后基的值可以得到线性变换对应的矩阵A。 直接计算变换矩阵在上面已经得到，在世界空间中，观察坐标系的原点：$（P_x，P_y，P_z）$，x基向量（+x轴）：$（X_x，X_y，X_z）$，y基向量（+y轴）：$（Y_x，Y_y，Y_z）$，z基向量（+z轴）：$（Z_x，Z_y，Z_z）$。上诉得到的是世界坐标系下的观察坐标系，由于都是右手坐标系，所以可以由线性变换得到。由定理可知，线性变换矩阵为：$$[Camera]_{world}=\begin{pmatrix}X_x &amp; Y_x &amp; Z_x &amp; P_x\\X_y &amp; Y_y &amp; Z_y &amp; P_y \\X_z &amp; Y_z &amp; Z_z &amp; P_z \\0 &amp; 0 &amp; 0 &amp; 1\end{pmatrix}$$但是，上面得到的是世界坐标系下的观察坐标系，但我们要的是观察坐标系下的世界坐标系，所以观察矩阵应该是上述矩阵的逆矩阵：$$view=[World]_{camera}=[Camera]_{world}^{-1}$$这个矩阵代表了观察坐标系的世界坐标系，再乘以点P在世界坐标系下的位置向量，就可以得到该点在观察坐标下的位置向量。 由旋转平移得到变换矩阵由于世界坐标系和观察坐标系都是右手坐标系，所以世界坐标系可以通过直接旋转（线性变换）、平移（仿射变换）到观察坐标系。先由世界坐标系在原点旋转，再平移过去，和观察坐标系重合。旋转矩阵R为：$$R=\begin{pmatrix}X_x &amp; Y_x &amp; Z_x &amp; 0\\X_y &amp; Y_y &amp; Z_y &amp; 0 \\X_z &amp; Y_z &amp; Z_z &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 1\end{pmatrix}$$平移矩阵T为：$$T=\begin{pmatrix}0 &amp; 0 &amp; 0 &amp; P_x \\0 &amp; 0 &amp; 0 &amp; P_y \\0 &amp; 0 &amp; 0 &amp; P_z \\0 &amp; 0 &amp; 0 &amp; 1\end{pmatrix}$$T*R就是从世界坐标系旋转平移到观察坐标系，但是和前一种方法一样，得到的依旧是世界坐标系下的观察坐标系，而我们需要的是观察坐标系下的世界坐标系。所以观察矩阵$view=(T*R)^{-1}=R^{-1}*T^{-1}$，因为此时的R矩阵是正交矩阵，正交矩阵的逆矩阵就是其转置矩阵，所以$view=R^T*T^{-1}$。又因为：$$R^T=\begin{pmatrix}X_x &amp; X_y &amp; X_z &amp; 0 \\Y_x &amp; Y_y &amp; Y_z &amp; 0 \\Z_x &amp; Z_y &amp; Z_z &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 1\end{pmatrix}$$ $$T^{-1}=\begin{pmatrix}1 &amp; 0 &amp; 0 &amp; -P_x \\0 &amp; 1 &amp; 0 &amp; -P_y \\0 &amp; 0 &amp; 1 &amp; -P_z \\0 &amp; 0 &amp; 0 &amp; 1\end{pmatrix}$$所以：$$view=R^T*T^{-1}=\begin{pmatrix}X_x &amp; X_y &amp; X_z &amp; 0 \\Y_x &amp; Y_y &amp; Y_z &amp; 0 \\Z_x &amp; Z_y &amp; Z_z &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 1\end{pmatrix}*\begin{pmatrix}1 &amp; 0 &amp; 0 &amp; -P_x \\0 &amp; 1 &amp; 0 &amp; -P_y \\0 &amp; 0 &amp; 1 &amp; -P_z \\0 &amp; 0 &amp; 0 &amp; 1\end{pmatrix}$$ 通过具体例子或者证明，都可以很得到这两种方法得到的view矩阵最终是相等的。&nbsp; LookAt矩阵上面两种方法得到的view矩阵也叫作LookAt矩阵，它会创建一个看着（look at）给定目标的观察矩阵，可以很高效地把世界坐标转化为观察坐标。 当然，我们可以自己用代码定义和实现这个LookAt矩阵，把它封装成一个函数，专门用于求看着给定目标的观察矩阵。不过GLM已经给我们实现好了，它为我们提供了一个lookAt函数：12//观察矩阵mat4 view = lookAt(vec3(0.0f, 0.0f, 3.0f), vec3(0.0f, 0.0f, 0.0f), vec3(0.0f, 1.0f, 0.0f)); lookAt函数的第一个参数是摄像机的位置；第二个参数是目标的位置；第三个参数是摄像机的上向量。因为有这个三个参数就足以计算并构建出观察坐标系了（+z轴是目标指向摄像机，+x轴是上向量和+z轴的叉乘，+y轴是+z轴和+x轴的叉乘）。通过该函数就能构建出一个观察矩阵，以创建观察坐标系。 下面上个demo，通过改变lookAt函数的第一个参数摄像机的位置，让它围绕目标转圈：12345//观察矩阵GLfloat radius = 10.0f;GLfloat cameraX = radius*sin(glfwGetTime());GLfloat cameraZ = radius*cos(glfwGetTime());mat4 view = lookAt(vec3(cameraX, 0.0f, cameraZ), vec3(0.0f, 0.0f, 0.0f), vec3(0.0f, 1.0f, 0.0f)); 所有源码在这里。 编译运行后，结果类似如下： 可以看到随着时间流逝，摄像机在围绕场景（准确说是世界坐标原点）转动了。&nbsp; 上向量上面的lookAt观察矩阵中以及观察坐标系构建中，有一个很诡异的上向量，它通常赋值为（0.0f,1.0f,0.0f）。 为何不直接将这个上向量作为观察坐标系的y轴呢？这是因为上向量不一定和+z轴正交，而我们需要得到正交的坐标系。所以就需要用上向量和+z轴叉乘得到正交的+x轴，再有+z轴+x轴叉乘才能得到正交的+y轴。 上向量指定了相机的头顶方向。对于相机而言，指定了相机位置、相机目标位置后，虽然相机的位置不变、指向不变，但还是可以通过改变这个上向量而影响成像的。这类似于你眼睛的位置不变，看的方向不变，但还是可以通过转动脑袋来改变哪个方向是向上，这个上向量就好比头顶的方向。其实上向量方向不同时，叉乘后得到的x轴、y轴也会发生相应变化，观察坐标系都变了，肯定会影响成像结果。 下面三张图片分别是上向量为（0,1,0）、（1,0,0）、（0,-1,0）的成像结果：&nbsp; 用键盘移动摄像机当我们按下A、S、W、D时，摄像机会向前后左右移动，所以我们需要先给出或计算出摄像机前、右这两个方向（即-z轴和+x轴）：12345678//摄像机位置vec3 cameraPos = vec3(0.0f, 0.0f, 3.0f);//上向量vec3 upVector = vec3(0.0f, 1.0f, 0.0f);//摄像机照射方向（观察坐标系-z轴）vec3 cameraFront = normalize(vec3(0, 0, -1));//摄像机+x轴方向（观察坐标系+x轴）vec3 cameraRight = normalize(cross(upVector, -cameraFront)); 摄像机上方向就是摄像机前面的方向就是摄像机照射的方向，是观察坐标系的-z轴，也就是从摄像机指向目标位置；摄像机右方向就是观察坐标系的+x轴，是上向量和+z轴的叉乘。 接下来就是响应按键了。最初在响应键盘的ESC键时，创建了一个key_callback回调函数来关闭窗口，现在我们还是在这个函数里响应其它按键：1234567891011121314151617181920//按键回调函数void key_callback(GLFWwindow* window, int key, int scancode, int action, int mode) &#123; if (key == GLFW_KEY_ESCAPE&amp;&amp;action == GLFW_PRESS) &#123; glfwSetWindowShouldClose(window, GL_TRUE); &#125; //响应键盘按键来移动摄像机 float cameraSpeed = 0.05f; if (key == GLFW_KEY_W) &#123; cameraPos += cameraSpeed * vec3(cameraFront.x, 0, cameraFront.z); &#125; if (key == GLFW_KEY_S) &#123; cameraPos -= cameraSpeed * vec3(cameraFront.x, 0, cameraFront.z); &#125; if (key == GLFW_KEY_D) &#123; cameraPos += cameraSpeed * cameraRight; &#125; if (key == GLFW_KEY_A) &#123; cameraPos -= cameraSpeed * cameraRight; &#125;&#125; 每当有按键按下时，OpenGL就会自动调用该函数。 接下来我们在使用lookAt函数构造观察矩阵时，传入的第二个参数目标位置，应该是摄像机位置加上摄像机照射方向向量（注意摄像机其实最关心的是它的照射方向，目标位置可以是照射方向上的任意一点，所以我们这里就直接加上了照射方向向量来得到目标位置）：12//观察矩阵mat4 view = lookAt(cameraPos, cameraPos + cameraFront, upVector); 到此，我们就能通过WSAD键控制摄像机移动了。所有源码在这里。 编译运行后的结果类似如下： 但是这个摄像机不能同时朝两个方向移动（对角线移动），而且按下一个按键时，它会先顿一下才开始移动。这是因为大多数事件输入系统一次只能处理一个键盘输入。 解决方案是我们在回调函数中只存储哪个按键被按下/释放的状态信息，记录到bool数组中（true表示按下）。在渲染循环中我们读取这些值，检查哪个按键是激活的，然后做出相应反应。 由于GLFW_KRY_W等本身就是int类型的，所以我们可以用它们作为bool数组下标，对应相应的按键状态信息。为了能够存储更多的按键信息，我们定义bool数组（全局变量）如下：12//存储按键状态（按下/释放）的数组bool keys[1024]; 然后在key_callbak函数中设置被按下/释放的按键为true/false：12345678910111213//按键回调函数void key_callback(GLFWwindow* window, int key, int scancode, int action, int mode) &#123; if (key == GLFW_KEY_ESCAPE&amp;&amp;action == GLFW_PRESS) &#123; glfwSetWindowShouldClose(window, GL_TRUE); &#125; //响应键盘按键来设置相应按键状态 if (action == GLFW_PRESS) &#123; keys[key] = GL_TRUE; &#125; else if(action==GLFW_RELEASE)&#123; keys[key] = GL_FALSE; &#125;&#125; 然后在渲染循环里读取按键状态，并做出相应反应。我们把这部分功能封装到do_movement函数中：12345678910111213141516//根据按键状态移动摄像机void do_movement() &#123; GLfloat cameraSpeed = 5.0f*deltaTime; if (keys[GLFW_KEY_W]) &#123; cameraPos += cameraSpeed * vec3(cameraFront.x, 0, cameraFront.z); &#125; if (keys[GLFW_KEY_S]) &#123; cameraPos -= cameraSpeed * vec3(cameraFront.x, 0, cameraFront.z); &#125; if (keys[GLFW_KEY_D]) &#123; cameraPos += cameraSpeed*cameraRight; &#125; if (keys[GLFW_KEY_A]) &#123; cameraPos -= cameraSpeed*cameraRight; &#125;&#125; 最后就是在渲染循环中调用do_movement函数了：12345while (!glfwWindowShouldClose(window)) &#123; ... do_movement(); ...&#125; 编译运行后会发现，可以同时向多个方向移动了，并且按下按钮时也会立刻移动了，操作灵活了很多。&nbsp; 平衡不同处理器的移动速度上面的摄像机移动速度是个常量，但是实际情况下根据处理器的能力不同，有些人可能会比其他人每秒绘制更多帧，也就是以更高的频率调用do_movement函数，结果就是，由于处理器性能不同，有些人可能移动很快，而有些人会移动很慢。尤其是在网游中，这是很不公平的，我们需要确保在所有硬件上的移动速度都一样。 图形程序和游戏通常会跟踪一个时间差(deltaTime)变量，它储存了渲染上一帧所用的时间。我们把所有速度都去乘以deltaTime值。结果就是，如果我们的deltaTime很大，就意味着上一帧的渲染花费了更多时间，所以这一帧的速度需要变得更高，来平衡渲染所花去的时间。这样一来，渲染时间长的移动速度较快，渲染时间短的移动速度较慢，单位时间内的移动速度就都差不多了，这样每个用户的体验就都一样了。 首先设置两个全局变量来计算deltaTime值：1234//当前帧与上一帧的时间差GLfloat deltaTime = 0.0f;//上一帧开始的时间GLfloat lastTime = 0.0f; 在每一帧（一帧可以看做一次渲染循环）开始时计算出deltaTime：12345678//渲染循环（游戏循环）while (!glfwWindowShouldClose(window)) &#123; //计算deltaTime GLfloat currentTime = glfwGetTime(); deltaTime = currentTime - lastTime; lastTime = currentTime; ...&#125; 现在我们有了deltaTime，在计算速度的时候可以将其考虑进去了：12345//根据按键状态移动摄像机void do_movement() &#123; GLfloat cameraSpeed = 5.0f*deltaTime; ...&#125; 编译运行后的结果类似如下： &nbsp; 用鼠标移动摄像机视角 现在我们要开始用鼠标来移动摄像机了。 先来点基础数学知识。旋转共3个欧拉角：俯仰角（pitch）、偏航角（yaw）、滚转角（roll）。下面的图片展示了它们的含义：俯仰角pitch是描述我们往上或往下看的角；偏航角yaw是描述我们往左或往右看的角；滚转角roll是描述我们如何翻滚摄像机的角（通常在太空飞船的摄像机中使用）。 大多数摄像机系统都支持往上下左右看，除非特殊情况一般不考虑滚转角，我们这里只关心俯仰角和偏航角。旋转摄像机的视角其实就是旋转摄像机的照射方向（也就是摄像机指向目标的向量cameraToTarget），摄像机的照射方向正好可以用俯仰角和偏航角来表示。为了计算简单，我们以摄像机所在位置为原点（计算结果后加上摄像机位置就是实际位置了），有如下图示：其中摄像机方向就是从原点发出的那条黄色线，它的俯仰角设为pitch，偏航角设为yaw。设这条向量的长度为1，那么该向量坐标应该是（cos(pitch)*cos(yaw),sin(pitch),cos(pitch)*sin(yaw)）。由于摄像机在旋转过程中，摄像机到目标的距离应该是不变的，所以用该向量乘以这个恒定距离，就是摄像机指向目标的向量的实际坐标，再加上摄像机位置，就能得到旋转过程中目标的实际位置。把目标实际位置传参给lookAt函数，就能实现摄像机旋转了。 但是俯仰角pitch和偏航角yaw怎么得到呢？我们把俯仰角和偏航角的初始值都设为0，用前后两帧鼠标位置的x差值作为偏航角的增量，y差值作为俯仰角的增量。这样就能从一开始得到每一帧里摄像机的俯仰角和偏航角了。 下面我们来实现这个功能： 设置鼠标位置回调函数首先为了让GLFW监听鼠标移动事件，我们需要注册鼠标位置回调函数（和键盘回调函数类似）：12//注册鼠标位置回调函数glfwSetCursorPosCallback(window, cursor_callback); 鼠标位置回调函数原型如下：1void cursor_callback(GLFWwindow* window, double xpos, double ypos); xpos和ypos代表当前鼠标的位置，当我们用GLFW注册了鼠标位置回调函数后，鼠标一移动该函数就会被调用。 计算鼠标位移量接下来我们在鼠标位置回调函数cursor_callback中计算出前后两帧的位移量：需要先声明两个全局变量用以计算位移量：123//上一帧鼠标位置GLfloat lastCursorX = WIDTH / 2;GLfloat lastCursorY = HEIGHT / 2; 然后在回调函数中利用这两个全局变量进行计算：123456789GLfloat sensitivity = 0.03f;void cursor_callback(GLFWwindow* window, double xpos, double ypos) &#123; //计算前后两帧的鼠标位移量 GLfloat xOffset = (xpos - lastCursorX)*sensitivity; GLfloat yOffset = (lastCursorY - ypos)*sensitivity; lastCursorX = xpos; lastCursorY = ypos; ...&#125; 由于鼠标位移量每次太大了，不可能直接作为摄像机度数的增量，不然摄像机移动太快了。所以需要给位移量乘以sensitivity灵敏度值。要注意的是鼠标坐标原点在窗口左上角，当我们把鼠标从下往上拉时，我们应该是希望俯仰角增大。但是由于鼠标坐标原点在窗口左上角，+x轴向右，+y轴向下，所以鼠标如果从下往上，xpos - lastCursorY的值会是负数，导致俯仰角不断变小。这与我们期待的相反。应该是正数才对，改成lastCursorY - ypos才合适。 由于lastCursorX和lastCursorY的初始值设在窗口中央，当我们的鼠标第一次从窗口外进入窗口内时，xOffset和xOffset就会很大，摄像机镜头就会突然旋转很大角度。为了避免这种突变，我们改动如下：12345678910111213141516//鼠标位置回调函数bool firstCursor = true;void cursor_callback(GLFWwindow* window, double xpos, double ypos) &#123; if (firstCursor) &#123; lastCursorX = xpos; lastCursorY = ypos; firstCursor = false; &#125; //计算前后两帧的鼠标位移量 GLfloat sensitivity = 0.03f; GLfloat xOffset = (xpos - lastCursorX) * sensitivity; GLfloat yOffset = (lastCursorY - ypos) * sensitivity; lastCursorX = xpos; lastCursorY = ypos; ...&#125; 增加了一个firstCursor变量来判断鼠标是否是第一次进入窗口（隐藏鼠标开启的情况下），如果是，就让lastCursorX和lastCursorY等于当前的鼠标位置值，从而避免了镜头突变。 计算偏航角和俯仰角接下来就可以用鼠标x位移量和y位移量来作为摄像机偏航角和俯仰角的增量了。在此之前我们需要声明两个全局变量表示偏航角和俯仰角，但是它们的初始值不是随意指定的。 摄像机俯仰角和偏航角的初始值，与摄像机照射方向（即cameraDirection）的初始值有关，因为需要满足之前推导出的照射方向向量公式：（cos(pitch)*cos(yaw),sin(pitch),cos(pitch)*sin(yaw)）。根据cameraDirection的初始值和该公式，可以求出俯仰角pitch和偏航角yaw的初始值：12345//摄像机俯仰角（弧度）GLfloat Pitch = asin(cameraFront.y);//摄像机偏航角（弧度）//GLfloat Yaw = asin(sqrt((1 - cameraFront.y * cameraFront.y)));GLfloat Yaw = asin(cameraFront.z / cos(Pitch)); 如上，偏航角的求法有两种，一种是根绝三角函数公式，另一种是直接根据向量公式做除法。注意，求出来的是弧度，不是度数。 有了初始值，接下来就需要在鼠标位置回调函数求每一帧的俯仰角pitch和偏航角yaw了（就是累加鼠标位移量）：123//计算偏航角和俯仰角（弧度）Yaw += radians(xOffset);Pitch += radians(yOffset); 摄像机的俯仰角还需要有一些限制，不能让用户看到高于89度和低于-89度的地方，因为在90度和-90度时，视角会发生逆转。所以俯仰角需要在-89度到89度之间：1234567//俯仰角限制在-89度~89度之间if (Pitch &gt; radians(89.0f)) &#123; Pitch = radians(89.0f);&#125;else if (Pitch &lt; radians(-89.0f)) &#123; Pitch = radians(89.0f);&#125; 偏航角不需要限制了，因为我们希望用户能够在水平面上360转圈看。 计算摄像机到目标的向量然后就是求出，摄像机旋转之后新的摄像机照射方向（即-z轴）（该照射方向向量从一开始就一直是归一化的）：123456//摄像机到目标的向量cameraFront.x = cos(Pitch) * cos(Yaw);cameraFront.y = sin(Pitch);cameraFront.z = cos(Pitch) * sin(Yaw);cameraFront = normalize(cameraFront);cameraRight = normalize(cross(upVector, -cameraFront)); 传参给lookAt函数最后，我们需要把求出来的，旋转中的摄像机到目标的向量，传参给lookAt函数，让它和摄像机位置相加，得到旋转中的目标位置，作为lookAt函数的第二个参数：12//观察矩阵mat4 view = lookAt(cameraPos, cameraPos + cameraFront, upVector); 到此，摄像机可以旋转了，源码在缩放后面一起给出。&nbsp; 用鼠标滚轮缩放摄像机视角我们再来实现一个用鼠标滚轮缩放摄像机视角的功能。 摄像机视角是由投影矩阵perspective函数的第一个参数fov（视野，field of view）来指定的。我们通常在指定的视野大小在45度。这个视野指定了我们可以看到场景中多大的范围。当视野变小时，场景投影出来的空间就会减小，更小的投影空间变换到固定尺寸的窗口上，会产生放大了的感觉。 需要先设置一个摄像机视野的全局变量：12//摄像机视野GLfloat fov = 45.0f; 同鼠标位置和按键一样，我们先注册一个鼠标滚轮回调函数：12//注册鼠标滚轮回调函数glfwSetScrollCallback(window, scroll_callback); 接着我们需要在鼠标滚轮回调函数中，把鼠标滚轮y值的偏移量作为视野的增量，来计算视野值，并且把视野值限制在1到45度之间：123456789101112//鼠标滚轮回调函数void scroll_callback(GLFWwindow* window, double xoffset, double yoffset) &#123; if (fov &gt;= 1.0f&amp;&amp; fov &lt;= 45.0f) &#123; fov -= yoffset; &#125; if (fov &lt; 1.0f) &#123; fov = 1.0f; &#125; else if (fov &gt; 45.0f) &#123; fov = 45.0f; &#125;&#125; 当滚动鼠标滚轮时，yoffset值表示我们竖直滚动的大小。 最后，把视野值传参给投影矩阵函数：12//投影矩阵mat4 projection = perspective(radians(fov), (GLfloat)WIDTH / (GLfloat)HEIGHT, 0.1f, 100.0f); 到此，我们的摄像机就实现了按键移动、鼠标旋转、滚轮缩放的功能。所有源码在这里。 编译运行后的结果类似如下： 隐藏鼠标如果我们想要隐藏窗口上的鼠标，可以使用glfwSetInputMode函数：12//隐藏鼠标glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED); 第一个参数是窗口对象，第二个参数是要设置的输入模式，我们这里要改变的是鼠标输入这种方式，第三个参数指明不显示鼠标。 编译运行后，可以发现无论我们怎么移动鼠标，它都不会显示了，而且有一点好处：不管把鼠标移得多远，它也不会离开窗口。&nbsp; 摄像机类为了减轻主函数的负担，更为了方便程序移植和模块独立，我们把有关摄像机的代码封装成一个摄像机类。 所有源码在这里。&nbsp; 参考文献：LearnOpenGL]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>OpenGL摄像机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenGL7：坐标系统]]></title>
    <url>%2F2016%2F12%2F05%2FOpenGL7%E5%9D%90%E6%A0%87%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[OpenGL希望每次顶点着色器运行后，我们所有可见的顶点都化为标准化设备坐标（NDC，normalized device coordinate）。也就是说，每个顶点的x、y、z坐标都应该在-1.0到1.0之间，超出这个坐标范围的顶点都将不可见。我们通常会自己设定一个可见的坐标范围，之后再顶点着色器中将这些坐标变换为标准化设备坐标，然后将这些标准化设备坐标传入光栅器（Rasterizer），把它们变换为屏幕上的二维坐标/像素。&nbsp; 坐标转化过程 坐标转化过程中的坐标系统物体的顶点在最终化为屏幕坐标之前，还会被变换到多个坐标系统。这是因为，在中间的那些特定的坐标系统里，一些操作或运算更加方便和容易。其实这个过程类似现实世界的物体被我们看到的过程：最开始由物体出发，物体上可能有各种细节需要去研究，这时候是在局部空间（或称物体空间）；接着这个物体肯定是和我们身处在一个世界里，它身边可能还有其他物体，这时候是在世界空间；但是并不是世界里所有的物体都能被我们看到，只有在我们眼睛前方的物体，才能被我们看到，脑后的东西肯定看不到了，我们眼睛视角前方的世界范围都是观察空间（或称视觉空间）；但是受视力限制，在我们眼睛前方的世界（观察空间）不是都能看得到，我们只能看到目力所能及的观察空间，眼睛前方的视觉范围就是裁剪空间，即使在我们眼睛前方，但太近或者太远不在我们的视力范围内也是看不到的，处在裁剪空间里的物体会通过反射光投影到我们的视网膜上（根据是点光线/点光源还是平行光线/太阳光，可以分为透视投影和正交投影）；在视网膜上的投影最终会转换为我们脑海中的事物，在我们脑海中形成一个世界，这就是屏幕空间。 总之，一个顶点在被转换为屏幕像素之前需要经历5个坐标系统： 局部空间（Local Space，或称物体空间Object Space） 世界空间（World Space） 观察空间（View Space，或称视觉空间Eye Space） 裁剪空间（Clip Space） 屏幕空间（Screen Space） 坐标转化过程中的变换矩阵流程图如下：为了将坐标从一个坐标系转化到另一个坐标系，我们需要用到几个变换矩阵，最重要的是模型矩阵（Model）、观察矩阵（View）、投影矩阵（Projection）。我们的顶点坐标起始于局部空间，在这里它们称为局部坐标；通过模型矩阵的平移旋转缩放之后，物体被放在世界里的不同位置上，变成世界坐标；接下来会把世界坐标通过观察矩阵转化为观察坐标，使得每个坐标都是从摄像机或者说观察者的角度进行观察的；接着在观察坐标会通过投影矩阵转化为裁剪坐标，只有那些在-1.0到1.0之间的裁剪坐标，才会被裁剪出来有机会出现在屏幕上；最后，需要把裁剪坐标通过视口变换（Viewport Transform）转化为屏幕坐标，视口变换将位于-1.0到1.0范围内的坐标变换到由glViewport函数所定义的坐标范围内。最后变换出来的坐标将会送到光栅器，将其转化为像素。 我们之所以将顶点转化到各个不同的空间，是因为有些操作在特定的坐标系统中才有意义且更方便。例如，当需要对物体内部进行修改时，在局部空间中来操作会更方便；当需要对一个物体做出相对于其他物体的操作时，在世界空间中会更方便，等等。当然，也可以定义一个直接从局部坐标转化到裁剪坐标的变换矩阵，但是那样会失去很多灵活性。图中左边的过程包括模型变换、观察变换、投影变换，这些变换由用户根据需要自行指定，这些变换都在顶点着色器中完成；而图中右边的过程包括透视除法、视口变换，都是由OpenGL自动执行的，在顶点着色器处理后的阶段执行。&nbsp; 接下里我们更详细地讨论各个坐标系统和变换矩阵。 局部空间局部空间是指物体所在的坐标空间，即对象最开始所在的地方。比如在建模软件（如3Dmax）中创建了一个立方体，在建模软件里的这个立方体的所有顶点都是在局部空间里。&nbsp; 世界空间如果将我们在建模软件中创建的所有的物体，导入到我们的程序当中，它们可能会全挤在世界的原点（0,0,0）上，这可能并不是我们想要的结果。我们想要为每一个物体定义一个位置。让它们放在世界中的不同位置上。世界坐标就是顶点在（游戏）世界里的坐标。&nbsp; 模型变换物体的坐标从局部空间转化到世界空间，是由模型矩阵来实现的。模型矩阵是一种变换矩阵，其实说白了就是《OpenGL6：坐标变换》一文中的变换矩阵，它通过对物体进行平移、旋转、缩放来将物体放在世界的不同位置或朝向上。可以想象现在在建模软件里创建了一个茶壶，但是它在局部空间中太大了，我们先将它缩小，把它位移到大世界里，然后围绕着旋转一下，以搭配附近的茶壶：下图是在模型空间中定义的茶壶模型：茶壶通过模型变换，转化到世界坐标系中：&nbsp; 观察空间观察空间经常被人们称之为OpenGL的摄像机（所以也称摄像机空间Camera Space或视觉空间Eye Space）。观察空间是将世界坐标转化为用户眼睛前方空间的坐标而产生的结果，在观察空间里的物体只是留待我们去观察的，不一定能被我们看到，得在我们视觉范围内才行。 OpenGL中的相机默认位于原点，指向-Z轴，通常不移动相机（因为OpenGL中实际上没有摄像机，是虚构的），而是以相反的方式来调整场景中的物体，从而达到相同的效果。例如一个物体中心位于原点，照相机也位于初始位置原点，方向指向-Z轴。为了对物体的+Z面成像，一种方式是将照相机向+Z方向后退，仍指向-Z轴；另一种方式是照相机不动，让物体沿着-Z方向移动。OpenGL采用第二种方式。【注】： 其实无论是眼睛还是摄像机，都是假想的概念，是为了便于计算而引入的，并不真实存在。 OpenGL观察空间（或者说OpenGL的照相机）采用的是右手坐标系。想象屏幕处于三个轴的中心，则z轴穿过你的屏幕指向你。坐标系画起来如下：之所以叫做右手坐标系，看下图：可以看到大拇指指向正x轴方向，食指指向正y轴方向，中指指向正z轴方向，正好符合右手坐标系（如果用左手来做这个动作，会发现z轴的方向是相反的，这个叫做左手坐标系，它被DirectX广泛使用）。【注】： OpenGL提供给用户的是右手坐标系，即局部坐标系、世界坐标系、观察坐标系等是一个右手坐标系，但是标准化设备坐标系中OpenGL使用的实际上是左手坐标系，因为投影矩阵交换了左右手。&nbsp; 观察变换观察变换是把世界坐标变化到观察坐标。 在世界坐标系中指定相机的位置、指向的目标位置（相机朝向）以及相机的正上方向（viewUp）（第三个方向轴可以由前两个方向叉乘得到）可以构造出一个观察坐标系，在通过观察矩阵，就可以将物体坐标从世界坐标系转化到观察坐标系。 观察矩阵是一系列平移和旋转的组合，用于平移/旋转场景从而使得特定的对象被变换到摄像机的前方。 观察变化前后图示如下：&nbsp; 裁剪空间在一个顶点着色器运行的最后，OpenGL期望所有要显示的顶点的观察坐标都落在一个特定的范围内，任何在这个范围之外的点都不会显示，会被裁剪掉。这个范围就是裁剪空间，通常是一个视见体（简单说就是一个观察空间里的一个棱台）。 根据投影方式不同，裁剪空间（视见体）可分为以下两种：&nbsp; 投影变换投影变换将顶点坐标从观察空间变化到裁剪空间。为了实现投影变换，我们需要定义一个投影矩阵（Projection Matrix），它会把观察坐标变换为裁剪坐标。所有在视见体内的坐标被映射为裁剪坐标后，其x、y、z坐标分量的值都会在-w和w（第四个坐标分量）之间。而在视见体外的点的坐标分量不都会在-w到w之间，所以会被裁剪掉。比如投影矩阵指定的范围时-1000到1000，那么坐标（1250,500,700）将是不可见的，因为他的x坐标超出了范围，最后它被转化为了一个大于w的裁剪坐标分量，所以被裁剪掉了。【注】： 如果是像三角形这种基本图元，如果它的一部分超出了裁剪范围，则OpenGL会重新构建这个三角形为一个或多个三角形，让它在裁剪范围内的那部分能够显示出来。 投影方式不同，就会有不同的投影矩阵。 正交投影正交投影的投影线相互平行，且正交与投影面。它的视见体是一个立方体：需要指定这个视见体的宽、高、近平面和远平面，任何在视见体之外的坐标都会被裁减掉。在视见体内部的所有坐标都会被映射为标准化设备坐标。 使用glm命名空间里的ortho函数来创建一个正交投影矩阵：1mat4 proj = ortho(0.0f, 800.0f, 0.0f, 600.0f, 0.1f, 100.0f); 前两个参数指定了视见体的最左和最右值，第三四个参数指定了视见体的最上下和最上值，第五六个参数指定了近平面和远平面的距离。这个投影矩阵会将处于这些x、y、z值范围内的坐标变换为标准化设备坐标。【注】： 正交投影下顶点的w坐标值是1 透视投影透视投影的投影线汇于一点，会造成近大远小的透视效果：透视投影的视见体是一个四棱台：需要指定这个视见体的视野、宽高比、近平面和远平面，任何在视见体之外的坐标都会被裁减掉。在视见体内部的所有坐标都会被映射为标准化设备坐标。 使用glm命名空间里的perspective函数来创建一个透视投影矩阵：1mat4 proj = perspective(45.0f, (float)width/(float)height, 0.1f, 100.0f); 该函数的第一个参数指定了视野fov（field of view）的值，并以此设置了观察空间的大小（如果想要一个真实的观察效果，它的值通常是45.0f，如果想要一个末日风格的结果可以把它设得稍大点）；第二个参数指定了视口的宽高比，由视口的宽除以高所得；第三四个参数指定了近平面和远平面的距离。所有在近平面和远平面内且处于视见体内的顶点都会被渲染。【注】： 如果把透视矩阵的近平面值设置得太大（比如10.0f），OpenGL会将靠近摄像机的坐标（在0.0f到10.0f之间）都裁减掉，这会导致一个我们在游戏中很熟悉的视觉效果：在太过靠近一个物体的时候，视线会直接穿过去。 除此之外，透视投影矩阵还修改了每个顶点坐标的w值，离观察者越远的顶点啊坐标w分量越大，从而使得在做透视除法后，产生近大远小的效果。 透视除法注意透视除法不在投影变换的范畴内，它是在投影变换之后，由OpenGL自动进行透视除法和裁剪。投影变换后的坐标范围是在-w到w之间，做完透视除法之后坐标范围在-1.0到1.0之间，变为标准化设备坐标NDC。 一旦坐标处在裁剪空间之后，透视除法就会被应用到裁剪空间坐标上：$$out =\begin{pmatrix}x /w \\y / w \\z / w\end{pmatrix}$$顶点坐标的每个分量都会除以它的w分量，透视投影时距离观察者越远顶点坐标就会越小。这也是w分量非常重要的另一个原因，它能帮助我们进行透视投影。当使用正交投影时，虽然也要进行透视除法，但是正交投影的所有顶点w分量都是1，因此除以w分量之后不会有透视效果。 正交投影主要用于二维渲染以及一些建筑或工程的程序，因为这些场景中更希望顶点不会被透视所干扰。透视投影看起来更真实。 透视投影和正交投影效果如下：&nbsp; 总之，模型矩阵针对物体在世界里的位置角度，观察矩阵针对场景移动（或者反方向摄像机移动，因为场景移动用反方向模拟了摄像机移动效果），投影矩阵针对视见体。&nbsp; Demo来一个demo，把《OpenGL5：纹理》一文中的纹理通过模型、观察、投影矩阵，变成向后旋转45度下的透视效果，如下： 创建模型、观察、投影矩阵首先，我们创建一个模型矩阵。这个模型矩阵包含了平移、旋转、缩放操作，它们会在顶点着色器中被应用到所有物体顶点上，以变换它们到全局的世界空间。这里我们让纹理平面绕着x轴旋转55度，让它看起来就像放在地上一样：123//模型矩阵mat4 model;model = rotate(model, radians(-45.0f), vec3(1.0f, 0.0f, 0.0f)); 接着我们创建一个观察矩阵。因为纹理平面默认是处在世界原点（0,0,0）的，而摄像机也是处在世界原点的，这时候摄像机照不到纹理平面，为了让纹理平面可见，我们让场景向负z轴方向移动（因为一般要让摄像机处在原点不动）：123//观察矩阵mat4 view;view = translate(view, vec3(0.0f, 0.0f, -3.0f)); 然后在创建一个投影矩阵。我们使用透视投影：123//投影矩阵mat4 projection;projection = perspective(radians(45.0f), (GLfloat)WIDTH / (GLfloat)HEIGHT, 0.1f, 100.0f); 更改顶点着色器因为要用这三个变换矩阵去影响顶点坐标，所以我们需要先更改一下着色器，让着色器有接收这三个矩阵的变量：12345678910111213141516171819//顶点着色器#version 330 corelayout (location=0) in vec3 position; //顶点位置变量的属性位置值为0layout (location=1) in vec3 color; //顶点颜色变量的属性位置值为1layout (location=2) in vec2 texCoord; //顶点纹理坐标的属性位置值为2out vec3 ourColor;out vec2 TexCoord;//模型矩阵uniform mat4 model;//观察矩阵uniform mat4 view;//投影矩阵uniform mat4 projection;void main()&#123; gl_Position=projection * view * model * vec4(position,1.0f); ourColor=color; TexCoord=vec2(texCoord.x,1-texCoord.y);&#125; 设置了3个uniform变量，用于从主程序接收3个变换矩阵。然后在顶点着色器的main函数里，内置变量gl_Position的值是几个变换矩阵与顶点坐标向量的乘积。注意这里矩阵运算的顺序是相反的（我们需要从右往左阅读三个矩阵的乘法）。 把变换矩阵传递给顶点着色器我们使用给uniform变量赋值的方法，从主程序把变换矩阵传递给着色器：123456GLint modelLocation = glGetUniformLocation(myshader.shaderProgram, "model");glUniformMatrix4fv(modelLocation, 1, GL_FALSE, value_ptr(model));GLint viewLocation = glGetUniformLocation(myshader.shaderProgram, "view");glUniformMatrix4fv(viewLocation, 1, GL_FALSE, value_ptr(view));GLint projectionLocation = glGetUniformLocation(myshader.shaderProgram, "projection");glUniformMatrix4fv(projectionLocation, 1, GL_FALSE, value_ptr(projection)); 全部源码在这里。&nbsp; 3D箱子我们的顶点坐标都是3D的，但是到目前为止，我们还是在使用一个2D平面。因为我们只渲染了一个平面，下面我们尝试渲染一个立方体箱子。 说到立方体，很容易想到应该设置8个顶点，但是我们的立方体每个面上都会有一张纹理，一个顶点紧邻着三个面，也就是说要让一个顶点表示3个纹理的顶点纹素，这是不可能的，因为一个顶点只对应着一个纹理坐标。所以我们需要把每个面上的纹理分开来画。一个面有4个顶点，6个面就应该设置24个顶点。每个顶点都会出现3次，但只是顶点坐标相同，对应的纹理坐标是不同的：123456789101112131415161718192021222324252627282930313233GLfloat vertices[] = &#123; //位置坐标 //颜色 //纹理坐标 //立方体前面 0.5f, 0.5f, 0.5f, 1.0f,0.0f,0.0f, 1.0f,1.0f, 0.5f,-0.5f, 0.5f, 0.0f,1.0f,0.0f, 1.0f,0.0f, -0.5f,-0.5f, 0.5f, 0.0f,0.0f,1.0f, 0.0f,0.0f, -0.5f, 0.5f, 0.5f, 1.0f,1.0f,0.0f, 0.0f,1.0f, //立方体后面 0.5f, 0.5f,-0.5f, 1.0f,0.0f,0.0f, 1.0f,1.0f, 0.5f,-0.5f,-0.5f, 0.0f,1.0f,0.0f, 1.0f,0.0f, -0.5f,-0.5f,-0.5f, 0.0f,0.0f,1.0f, 0.0f,0.0f, -0.5f, 0.5f,-0.5f, 1.0f,1.0f,0.0f, 0.0f,1.0f, //立方体上面 0.5f, 0.5f, 0.5f, 1.0f,0.0f,0.0f, 1.0f,1.0f, 0.5f, 0.5f,-0.5f, 0.0f,1.0f,0.0f, 1.0f,0.0f, -0.5f, 0.5f,-0.5f, 0.0f,0.0f,1.0f, 0.0f,0.0f, -0.5f, 0.5f, 0.5f, 1.0f,1.0f,0.0f, 0.0f,1.0f, //立方体下面 0.5f,-0.5f, 0.5f, 1.0f,0.0f,0.0f, 1.0f,1.0f, 0.5f,-0.5f,-0.5f, 0.0f,1.0f,0.0f, 1.0f,0.0f, -0.5f,-0.5f,-0.5f, 0.0f,0.0f,1.0f, 0.0f,0.0f, -0.5f,-0.5f, 0.5f, 1.0f,1.0f,0.0f, 0.0f,1.0f, //立方体右面 0.5f, 0.5f, 0.5f, 1.0f,0.0f,0.0f, 1.0f,1.0f, 0.5f, 0.5f,-0.5f, 0.0f,1.0f,0.0f, 1.0f,0.0f, 0.5f,-0.5f,-0.5f, 0.0f,0.0f,1.0f, 0.0f,0.0f, 0.5f,-0.5f, 0.5f, 1.0f,1.0f,0.0f, 0.0f,1.0f, //立方体左面 -0.5f, 0.5f, 0.5f, 1.0f,0.0f,0.0f, 1.0f,1.0f, -0.5f, 0.5f,-0.5f, 0.0f,1.0f,0.0f, 1.0f,0.0f, -0.5f,-0.5f,-0.5f, 0.0f,0.0f,1.0f, 0.0f,0.0f, -0.5f,-0.5f, 0.5f, 1.0f,1.0f,0.0f, 0.0f,1.0f&#125;; 当然接下来需要对每个面指定索引了：123456789101112131415161718192021//顶点索引GLuint indices[] = &#123; //立方体前面 0,1,3, 1,2,3, //立方体后面 4,5,7, 5,6,7, //立方体上面 8,9,11, 9,10,11, //立方体下面 12,13,15, 13,14,15, //立方体右面 16,17,19, 17,18,19, //立方体左面 20,21,23, 21,22,23&#125;; 【注】： 也可以不用索引，直接画组成立方体的每个三角形，这样6个面，每个面2个三角形，每个三角形3个顶点，那就应该是36个顶点了。 为了有趣点，我们让立方体随着时间旋转：123//模型矩阵mat4 model;model = rotate(model, (GLfloat)glfwGetTime()*radians(55.0f), vec3(0.5f, 1.0f, 0.0f)); 最后使用glDrawElements函数来绘制立方体，这次需要根据36个顶点索引来绘制36个顶点：12//绘图glDrawElements(GL_TRIANGLES, 36, GL_UNSIGNED_INT, 0); 编译运行后应该得到类似下面的效果： 但是这个立方体有点怪，有些面本应该被挡住的，却绘制在了这个立方体的其他面之上。这是因为OpenGL是一个三角形一个三角形来绘制我们的立方体的，后绘制的三角形会覆盖之前绘制的，它并不会到某个三角形被遮挡了不该绘制。 幸运的是，OpenGL把每个像素的深度信息（通常是像素的z坐标值）存储在了一个叫做Z缓冲（Z-buffer）的缓冲中，它允许OpenGL决定何时覆盖一个像素而何时不覆盖。&nbsp; Z缓冲OpenGL存储窗口上所有像素的深度信息于一个Z缓冲（Z-buffer）中，也称深度缓冲（Depth Buffer）。GLFW会自动为我们生成这样一个缓冲（就像它有一个颜色缓冲来存储图像的颜色）。当一个片元（还没绘制到窗口上的像素）准备输出它的颜色时，OpenGL会将它的深度值（z值）和相应坐标上的z缓冲进行比较，如果当前的片元在窗口像素之后（片元深度值小于窗口像素深度值，它们都是负数，越大的离摄像机越近），它将会被丢弃，否则将会覆盖。这个过程称为深度测试（Depth Testing），它是由OpenGL自动完成的。 我们首先需要用glEnable函数告诉OpenGL，我们想要开启深度测试，因为它默认是关闭的：1glEnable(GL_DEPTH_TEST); glEnable和glDisable函数允许我们启用或禁用某个OpenGL功能。这个功能会一直保持启用/禁用状态，直到另一个调用来禁用/启用它。所以上面的那行代码就不用写到渲染循环里面了，因为一开启后就会一直开启，直到显式关闭。 接着还需要在每次渲染循环之前清除深度缓冲，否则前一帧的深度信息仍然保存在缓冲中。就像清除颜色缓冲一样，我们可以通过在glClear函数中指定GL_DEPTH_BUFFER_BIT位来清除深度缓冲：1glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); 添加上面的代码，编译运行后的结果类似如下： &nbsp; 到此，所有源码在这里。&nbsp; 多个立方体因为要创建的10个立方体长得一样的，只是位置方向不同而已。所以我们只需要调用glDrawElements函数10次，并且每一次调用时给顶点着色器传递不同的模型矩阵就可以：12345678910111213141516171819202122232425vec3 cubeTranlate[] = &#123; vec3(0.0f, 0.0f, 0.0f), vec3(2.0f, 5.0f, -15.0f), vec3(-1.5f, -2.2f, -2.5f), vec3(-3.8f, -2.0f, -12.3f), vec3(2.4f, -0.4f, -3.5f), vec3(-1.7f, 3.0f, -7.5f), vec3(1.3f, -2.0f, -2.5f), vec3(1.5f, 2.0f, -2.5f), vec3(1.5f, 0.2f, -1.5f), vec3(-1.3f, 1.0f, -1.5f)&#125;;//绑定VAO，完成顶点输入初始化glBindVertexArray(VAO);for (int i = 0; i &lt; 10; i++) &#123; mat4 model; model = translate(model, cubeTranlate[i]); model = rotate(model, (GLfloat)glfwGetTime()*radians(50.0f), vec3(0.5f, 1.0f, 1.0f)); glUniformMatrix4fv(modelLocation, 1, GL_FALSE, value_ptr(model)); //绘图 glDrawElements(GL_TRIANGLES, 36, GL_UNSIGNED_INT, 0);&#125;//解绑VAOglBindVertexArray(0); 这样就能在不同位置上显示10个立方体了，而且它们都在转。 所有源码在这里。 编译运行后结果如下： &nbsp; 参考文献：LearnOpenGL]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>OpenGL坐标系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenGL6坐标变换]]></title>
    <url>%2F2016%2F12%2F02%2FOpenGL6%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[在本文将会介绍利用矩阵来对图形进行坐标变化，如平移、旋转、缩放。下面先简单介绍一些数学知识，更详细的可以参考[《几何变换》]一文。&nbsp; 向量向量的乘积分为点乘和叉乘。 向量点乘两个向量的点乘等于它们的模和夹角余弦值的乘积：$$\vec x \cdot \vec y = || \vec x || \cdot ||\vec y|| \cdot \cos \theta$$当两个向量的夹角$\theta$是90度时，余弦值就为0，那么点乘结果就是0,；如果两个向量的夹角是0度，余弦值就为1，那么点乘结果就是两个向量模的乘积。所以，使用点乘可以很容易测试两个向量是否正交或平行。 上面的公式是点乘的一般数学计算，是根据向量模长和夹角来计算的。除此之外，还可以通过向量的坐标来计算，也就是向量的矩阵运算。举例如下：$$\begin{pmatrix}\color{red}{0.6} \\-\color{green}{0.8} \\\color{blue}0\end{pmatrix}\cdot\begin{pmatrix}\color{red}0 \\\color{green}1 \\\color{blue}0\end{pmatrix}= (\color{red}{0.6} * \color{red}0) + (-\color{green}{0.8} * \color{green}1) + (\color{blue}0 * \color{blue}0) = -0.8$$点乘在计算光照的时候会非常有用。 向量叉乘向量的叉乘只在3D空间中有定义，它需要两个不平行的向量作为输入，生成一个正交于两个输入向量的第三个向量。如下图所示：向量叉乘只有一种计算方法，公式如下：$$\begin{pmatrix}\color{red}{A_{x}} \\\color{green}{A_{y}} \\\color{blue}{A_{z}}\end{pmatrix}\times\begin{pmatrix}\color{red}{B_{x}} \\\color{green}{B_{y}} \\\color{blue}{B_{z}}\end{pmatrix}=\begin{pmatrix}\color{green}{A_{y}} \cdot \color{blue}{B_{z}} - \color{blue}{A_{z}} \cdot \color{green}{B_{y}} \\\color{blue}{A_{z}} \cdot \color{red}{B_{x}} - \color{red}{A_{x}} \cdot \color{blue}{B_{z}} \\\color{red}{A_{x}} \cdot \color{green}{B_{y}} - \color{green}{A_{y}} \cdot \color{red}{B_{x}}\end{pmatrix}$$ 矩阵向量其实就是矩阵列数为1的特例。但是矩阵乘法只有点乘，没有叉乘。 矩阵点乘直接看例子吧：$$\begin{bmatrix}\color{red}4 &amp; \color{red}2 &amp; \color{red}0 \\\color{green}0 &amp; \color{green}8 &amp; \color{green}1 \\\color{blue}0 &amp; \color{blue}1 &amp; \color{blue}0\end{bmatrix}\cdot\begin{bmatrix}\color{red}4 &amp; \color{green}2 &amp; \color{blue}1 \\\color{red}2 &amp; \color{green}0 &amp; \color{blue}4 \\\color{red}9 &amp; \color{green}4 &amp; \color{blue}2\end{bmatrix}=\begin{bmatrix} \color{red}4 \cdot \color{red}4 + \color{red}2 \cdot \color{red}2 + \color{red}0 \cdot \color{red}9 &amp; \color{red}4 \cdot \color{green}2 + \color{red}2 \cdot \color{green}0 + \color{red}0 \cdot \color{green}4 &amp; \color{red}4 \cdot \color{blue}1 + \color{red}2 \cdot \color{blue}4 + \color{red}0 \cdot \color{blue}2 \\\color{green}0 \cdot \color{red}4 + \color{green}8 \cdot \color{red}2 + \color{green}1 \cdot \color{red}9 &amp; \color{green}0 \cdot \color{green}2 + \color{green}8 \cdot \color{green}0 + \color{green}1 \cdot \color{green}4 &amp; \color{green}0 \cdot \color{blue}1 + \color{green}8 \cdot \color{blue}4 + \color{green}1 \cdot \color{blue}2 \\\color{blue}0 \cdot \color{red}4 + \color{blue}1 \cdot \color{red}2 + \color{blue}0 \cdot \color{red}9 &amp; \color{blue}0 \cdot \color{green}2 + \color{blue}1 \cdot \color{green}0 + \color{blue}0 \cdot \color{green}4 &amp; \color{blue}0 \cdot \color{blue}1 + \color{blue}1 \cdot \color{blue}4 + \color{blue}0 \cdot \color{blue}2\end{bmatrix}=\begin{bmatrix}20 &amp; 8 &amp; 12 \\25 &amp; 4 &amp; 34 \\2 &amp; 0 &amp; 4\end{bmatrix}$$矩阵相乘不满足交换律。 单位矩阵单位矩阵是主对角线元素为1，其他元素全为0的矩阵：$$\begin{bmatrix}\color{red}1 &amp; \color{red}0 &amp; \color{red}0 &amp; \color{red}0 \\\color{green}0 &amp; \color{green}1 &amp; \color{green}0 &amp; \color{green}0 \\\color{blue}0 &amp; \color{blue}0 &amp; \color{blue}1 &amp; \color{blue}0 \\\color{purple}0 &amp; \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}1\end{bmatrix}\cdot\begin{bmatrix}1 \\2 \\3 \\4\end{bmatrix}=\begin{bmatrix}\color{red}1 \cdot 1 \\\color{green}1 \cdot 2 \\\color{blue}1 \cdot 3 \\\color{purple}1 \cdot 4\end{bmatrix}=\begin{bmatrix}1 \\2 \\3 \\4\end{bmatrix}$$上面是一个单位矩阵和另外一个向量的点乘，可以看到结果还是那个向量，没有发生变换。一个没有变换的变换矩阵有何用？其实单位矩阵是其他变换矩阵的起点，后面会看到其他变换矩阵和单位矩阵很像。&nbsp; 平移变换平移是把一个向量从一个位置平移到另一个位置。在数学上其实就是在原始向量的基础上乘了一个位移矩阵（齐次坐标下的矩阵，关于齐次坐标也可以参考前面链接的那篇文章）：$$\begin{bmatrix}\color{red}1 &amp; \color{red}0 &amp; \color{red}0 &amp; \color{red}{T_x} \\\color{green}0 &amp; \color{green}1 &amp; \color{green}0 &amp; \color{green}{T_y} \\\color{blue}0 &amp; \color{blue}0 &amp; \color{blue}1 &amp; \color{blue}{T_z} \\\color{purple}0 &amp; \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}1\end{bmatrix}\cdot\begin{pmatrix}x \\y \\z \\1\end{pmatrix}=\begin{pmatrix}x + \color{red}{T_x} \\y + \color{green}{T_y} \\z + \color{blue}{T_z} \\1\end{pmatrix}$$那个4x4的矩阵就是我们的位移矩阵，在x、y、z方向上的位移量分别是$T_x、T_y、T_z$。&nbsp; 旋转变换在3D空间中旋转需要定义一个角和一个旋转轴。图形会沿着给定的旋转轴旋转指定角度。 对于不同的旋转轴，有不同的旋转矩阵： 沿x轴旋转：$$\begin{pmatrix}\color{red}1 &amp; \color{red}0 &amp; \color{red}0 &amp; \color{red}0 \\\color{green}0 &amp; \color{green}{\cos \theta} &amp; - \color{green}{\sin \theta} &amp; \color{green}0 \\\color{blue}0 &amp; \color{blue}{\sin \theta} &amp; \color{blue}{\cos \theta} &amp; \color{blue}0 \\\color{purple}0 &amp; \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}1\end{pmatrix}\cdot\begin{pmatrix}x \\y \\z \\1\end{pmatrix}=\begin{pmatrix}x \\\color{green}{\cos \theta} \cdot y - \color{green}{\sin \theta} \cdot z \\\color{blue}{\sin \theta} \cdot y + \color{blue}{\cos \theta} \cdot z \\1\end{pmatrix}$$ 沿y轴旋转：$$\begin{pmatrix}\color{red}{\cos \theta} &amp; \color{red}0 &amp; \color{red}{\sin \theta} &amp; \color{red}0 \\\color{green}0 &amp; \color{green}1 &amp; \color{green}0 &amp; \color{green}0 \\-\color{blue}{\sin \theta} &amp; \color{blue}0 &amp; \color{blue}{\cos \theta} &amp; \color{blue}0 \\\color{purple}0 &amp; \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}1\end{pmatrix}\cdot\begin{pmatrix}x \\y \\z \\1\end{pmatrix}=\begin{pmatrix}\color{red}{\cos \theta} \cdot x + \color{red}{\sin \theta} \cdot z \\y \\-\color{blue}{\sin \theta} \cdot x + \color{blue}{\cos \theta} \cdot z \\1\end{pmatrix}$$ 沿z轴旋转：$$\begin{bmatrix}\color{red}{\cos \theta} &amp; - \color{red}{\sin \theta} &amp; \color{red}0 &amp; \color{red}0 \\\color{green}{\sin \theta} &amp; \color{green}{\cos \theta} &amp; \color{green}0 &amp; \color{green}0 \\\color{blue}0 &amp; \color{blue}0 &amp; \color{blue}1 &amp; \color{blue}0 \\\color{purple}0 &amp; \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}1\end{bmatrix}\cdot\begin{pmatrix}x \\y \\z \\1\end{pmatrix}=\begin{pmatrix}\color{red}{\cos \theta} \cdot x - \color{red}{\sin \theta} \cdot y \\\color{green}{\sin \theta} \cdot x + \color{green}{\cos \theta} \cdot y \\z \1\end{pmatrix}$$【注】： 当把多个旋转矩阵结合起来时，比如先沿着x轴旋转再沿着y轴旋转，这可能会导致万向节死锁（Gimbal Lock，当两个旋转轴位于同一平面时，图形/物体就不能再旋转到任意位置了，有些方向怎么也旋转不过去）。关于万向节死锁可以参考下面这个视频：避免万向节死锁的真正解决方案是使用四元素，它不仅安全，而且计算更加友好（之后的文章会讲）。&nbsp; 缩放变换对一个向量进行缩放变换就是对向量的长度进行缩放，而保持它的方向不变：$$\begin{bmatrix}\color{red}{S_1} &amp; \color{red}0 &amp; \color{red}0 &amp; \color{red}0 \\ \color{green}0 &amp; \color{green}{S_2} &amp; \color{green}0 &amp; \color{green}0 \\\color{blue}0 &amp; \color{blue}0 &amp; \color{blue}{S_3} &amp; \color{blue}0 \\ \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}1\end{bmatrix}\cdot\begin{pmatrix}x \\y \\z \\1\end{pmatrix}=\begin{pmatrix}\color{red}{S_1} \cdot x \\\color{green}{S_2} \cdot y \\\color{blue}{S_3} \cdot z \\1\end{pmatrix}$$&nbsp; 下面来看看在OpenGL中怎么用代码实现这些坐标变换。 GLM由于高版本的OpenGL没有自带任何的矩阵和向量知识，低版本中的glTranslate、glRotate、glScale等等都不能再用了。所以现在我们使用GLM，它是专门为OpenGL量身定制的数学库，易于使用。 GLM（OpenGL Mathematics），是一个只有头文件的库，也就是我们只需包含对应的头文件就可以使用了（包含整个glm文件夹，方法参考《OpenGL1：OpenGL概述及环境配置》一文），不用链接和编译。 坐标变换头文件我们需要的GLM的大多数功能基本上都在下面3个头文件里：12345//GLM#include &lt;GLM/glm/glm.hpp&gt;#include &lt;GLM/glm//gtc/matrix_transform.hpp&gt;#include &lt;GLM/glm/gtc/type_ptr.hpp&gt;using namespace glm; 定义变换矩阵接下来需要定义坐标变换矩阵，使用mat4类型：12//定义变换矩阵（单位矩阵）mat4 transform; 按这种方式定义好的变换矩阵，初始值一般都是单位矩阵。 坐标变换（平移旋转缩放）我们先对上一篇文章中的纹理，进行旋转变换：12//随着时间绕z轴旋转transform = rotate(transform, (GLfloat)glfwGetTime()*1.0f, vec3(0.0f, 0.0f, 1.0f)); 使用glm命名空间里的rotate函数，第一个参数是旋转之前的变换矩阵；第二个参数是旋转角度（弧度值），这里旋转角度随着时间不断增加，图形将会一直旋转；第三个参数是旋转轴。 接下来对图形进行变换：12//平移（0.5，-0.5，0）transform = translate(transform, vec3(0.5f, -0.5f, 0.0f)); 使用glm命名空间里的translate函数，第一个参数是平移之前的变换矩阵（准备拿去平移的矩阵）；第二个参数是位移向量，指定了平移的方向和距离。 发送变换矩阵给着色器变换矩阵已经搞定了，但是怎么把矩阵传递给着色器呢？我们使用uniform变量来实现：在顶点着色器里定义一个mat4类型的uniform变量：1234567891011121314//顶点着色器#version 330 corelayout (location=0) in vec3 position; //顶点位置变量的属性位置值为0layout (location=1) in vec3 color; //顶点颜色变量的属性位置值为1layout (location=2) in vec2 texCoord; //顶点纹理坐标的属性位置值为2out vec3 ourColor;out vec2 TexCoord;//坐标变换矩阵uniform mat4 transform;void main()&#123; gl_Position=transform*vec4(position,1.0f); ourColor=color; TexCoord=vec2(texCoord.x,1-texCoord.y);&#125; 在顶点着色器的main函数里，让内置变量gl_Position的值等于变换矩阵和顶点坐标向量的乘积，这样就能把图形顶点进行坐标变换了（注意变换矩阵必须左乘顶点坐标向量）。 接下里就需要在主函数里对这个mat4类型的uniform变量赋值了：1234//获取uniform全局变量transform（变换矩阵）的位置GLint transformLoc = glGetUniformLocation(myshader.shaderProgram, "transform");//给uniform变量（变换矩阵）赋矩阵值glUniformMatrix4fv(transformLoc, 1, GL_FALSE, value_ptr(transform)); 首先获取到这个mat4类型的uniform变量的位置，再使用glUniformMatrix4fv函数对它赋值，该函数的第一个参数是获取到的uniform变量的位置；第二个参数是要传递多少个矩阵，这里是1；第三个参数指明是否要对矩阵进行转置（交换矩阵的行和列），OpenGL通常使用列主序的矩阵布局，而GLM的矩阵默认就是列朱旭，所以不需要转置矩阵，我们填GL_FALSE。最后一个参数是真正的矩阵数据，但是GLM矩阵并不是OpenGL所希望接受的数据形式，所以需要先用GLM自带的函数value_ptr来进行转换。&nbsp; 到此，关于坐标变换的所有源码在这里。 编译运行后，效果类似如下： 【注】： translate、rotate等函数，单独作用的时候它们都是以原点（窗口中心）为基准的，即相对于原点进行平移、旋转。 越靠近渲染函数glDrawElements的变换越先执行，所以上诉渲染循环中应该是先指定旋转变换，再指定平移变换。&nbsp; 参考文献：LearnOpenGL]]></content>
  </entry>
  <entry>
    <title><![CDATA[OpenGL5：纹理]]></title>
    <url>%2F2016%2F11%2F29%2FOpenGL5%E7%BA%B9%E7%90%86%2F</url>
    <content type="text"><![CDATA[在前面的文章中，我们画过矩形，画过彩色三角形。那么能不能画出现实生活中的图片呢？比如画一面砖墙，画一朵花。这样的图形无疑看起来更真实。但是这些更真实的图形也无疑很复杂，因为它们的每个像素颜色之间并没有什么明显的规律，如果要去画的话，就得一个像素一个像素的去画，要我们自己去指定大量的顶点颜色，这个开销太庞大了~~~&nbsp; 纹理概述幸运的是，还有另一种方式。我们可以先照一张砖墙的照片，让GPU自动提取这张照片上的像素，然后画到屏幕上。这张用于GPU提取像素颜色的照片，就叫做纹理。纹理通常是一个2D图片（也有1D和3D的纹理）。可以想象纹理是一张绘有砖块的纸，无缝折叠贴合到我们的3D房子上，这样我们的房子看起来就像有砖墙外表了。这样我们就不用去一个一个地去指定纹理中每个纹素（纹理中的像素）的颜色了，只需要指定怎样把纹理贴到我们的模型（比如一个三角形、矩形甚至3D房子）上。举个例子：为了把这张木箱纹理贴到图中红色三角形上，我们需要指定三角形的顶点对应纹理的那个位置。这个位置我们叫做纹理坐标，表示纹素在纹理上的位置，通常坐标值在0.0到1.0之间，原点通常在纹理左下角。我们把三角形左下角顶点对应纹理坐标（0,0），把三角形右下角顶点对应纹理坐标（1,0），把三角形上中顶点对应纹理坐标（0.5,1.0）。我们只要给顶点着色器传递这三个顶点纹理坐标就行了，接下来它们会被传到像素着色器中，GPU会根据三角形顶点纹理坐标，去为三角形内部点进行插值（根据内部点坐标和顶点坐标的关系，去纹理中找相应纹素颜色）。使用纹理坐标获取纹理颜色叫做采样。 这么说来，纹理坐标也应该是三角形顶点的一个属性，所以我们定义如下：12345678//三角形顶点的坐标、颜色、纹理坐标GLfloat vertices[] = &#123; //位置坐标 //颜色 //纹理坐标 0.5f, 0.5f, 0.0f, 1.0f,0.0f,0.0f, 1.0f,1.0f, 0.5f, -0.5f,0.0f, 0.0f,1.0f,0.0f, 1.0f,0.0f, -0.5f,-0.5f,0.0f, 0.0f,0.0f,1.0f, 0.0f,0.0f, -0.5f,0.5f, 0.0f, 1.0f,1.0f,0.0f, 0.0f,1.0f&#125;; &nbsp; 告诉OpenGL如何解析顶点数据由于顶点数据中增加了纹理坐标，我们需要重新设置OpenGL如何解析顶点数据：123456789101112//告诉OpenGL如何解析显存中的顶点位置属性数据glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(GLfloat), (GLvoid*)0);//打开顶点位置属性数组glEnableVertexAttribArray(0);//告诉OpenGL如何解析显存中的顶点颜色属性数据glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(GLfloat), (GLvoid*)(3 * sizeof(GLfloat)));//打开顶点颜色属性数组glEnableVertexAttribArray(1);//告诉OpenGL如何解析显存中的顶点纹理坐标属性数据glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(GLfloat), (GLvoid*)(6 * sizeof(GLfloat)));//打开顶点纹理坐标属性数组glEnableVertexAttribArray(2); 每个顶点属性的步长都变成了8*sizeof(GLfloat)，起始偏移量（最后一个参数）也发生了变化。顶点纹理坐标属性对应顶点着色器中的location为2。&nbsp; 创建纹理和绑定对象和创建顶点数组对象VAO等一样，使用纹理前，我们需要创建和绑定纹理对象：12345GLuint texture;//生成纹理对象textureglGenTextures(1, &amp;texture);//给纹理对象绑定目标（2D纹理）glBindTexture(GL_TEXTURE_2D, texture); 我们使用的是2D纹理，所以纹理目标是GL_TEXTURE_2D。&nbsp; 加载纹理创建和绑定完纹理对象之后，我们把纹理从文件中加载进来。 纹理图像可能被存储为各种各样的格式，每种都有自己的数据结构和排列方式，那么我们如何才能把这些图像加载到应用中呢？一个解决方案是选一个需要的文件格式，比如png，然后自己写一个图像加载器，把图像转化为字节序列。但是如果要支持更多文件格式呢？就得为每种希望支持的格式写加载器了。 另一种解决方案就是借前人之树乘凉：使用一个支持多种流行格式的图像加载库来解决这个问题。比如我们要用的SOIL库（文末还介绍了另一种加载库）。 简易OpenGL图像库SOILSOIL是简易OpenGL图像库（Simple OpenGL Image Library）的缩写，它支持大多数流行的图像格式。可以从这里下载。下载完成后用VS打开\projects\VC8目录下的SOIL.sln，生成解决方案后，从debug文件夹里取得SOIL.lib文件，将它添加到我们自己建的Libs文件夹里，再把src文件夹下的所有.h头文件添加到我们自己建的Includes文件夹里，并且在自己的VS项目中链接上SOIL.lib（具体过程和《OpenGL1：OpenGL概述及环境配置》一文中构建GLFW类似）。 当然，在我们的源文件中还需要包含SOIL.h头文件：#include &lt;SOIL.h&gt; 使用SOIL加载图片下面我们加载一张木箱图片。首先使用SOIL库的SOIL_load_image函数把木箱图片数据加载到内存：12int iamgeWidth, iamgeHeight;unsigned char* image = SOIL_load_image("container.jpg", &amp;iamgeWidth, &amp;iamgeHeight, 0, SOIL_LOAD_RGB); 函数SOIL_load_image的第一个参数是需要加载的图片路径；然后需要两个int指针作为第二个和第三个参数，函数会分别返回图片的宽度和高度到其中；第4个参数指定图片的通道数量，这里设为0即可；最后一个参数告诉SOIL如何来加载图片，由于我们只关注图片的RGB值，所以设为SOIL_LOAD_RGB。函数返回一个很大的char（或者说byte）数组。&nbsp; 生成纹理图像数据已经有了，存储在image数组中，下面我们利用这些图形数据来在GPU上生成一张纹理：1glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, iamgeWidth, iamgeHeight, 0, GL_RGB, GL_UNSIGNED_BYTE, image); 函数glTexImage2D的参数都表示什么？ 第一个参数是纹理绑定的目标GL_TEXTURE_2D 第二个参数是纹理的多级渐远纹理（后面会讲）级别，这里我们设置为0，也就是原始纹理 第三个参数告诉OpenGL我们希望把纹理存储为何种格式。我们的图形只有RGB值，所以我们也把纹理存储为RGB 第四个和第五个参数设置最终的纹理宽度和高度。我们之前加载图像的时候读取到了图像的宽度和高度，现在刚好用上 第6个参数总是设为0（历史遗留问题） 第7个参数指定源图的格式 第8个参数指定源图的数据类型 最后一个参数是真正的图形数据 当调用函数glTexImage2D时，当前绑定的纹理对象就会被附加上纹理图像。 使用完图像内存数据后，释放所占用的内存是个好习惯：1SOIL_free_image_data(image); &nbsp; 接下来还需要对纹理进行一系列的配置，先来看对纹理环绕方式的配置。 纹理环绕方式纹理坐标的范围通常是（0,0）到（1,1），那如果我们把纹理坐标设置在这个范围之外会发生什么？OpenGL默认是重复这个纹理图像（即忽略纹理坐标的整数部分，只有小数部分有效），除此之外，OpenGL还提供了几种环绕方式（Wrapping）： GL_REPEAT：重复纹理图像。这是默认的。 GL_MIRRORED_REPEAT：镜像重复纹理图像。 GL_CLAMP_TO_EDGE：纹理坐标会被约束在0到1之间，超出部分会重复纹理边缘，产生一种边缘被拉伸的效果。 GL_CLAMP_TO_BORDER：超出坐标为用户指定的边缘颜色。 当纹理坐标不在0到1之间时，每个选项都有不同的视觉输出效果：可以使用glTextParameteri函数来设置纹理的环绕方式：12glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT); 第一个参数指定了纹理对象所绑定的目标；第二个参数指定需要配置的选项和应用的纹理轴，因为我们打算配置的是纹理环绕方式wrap，并且需要配置S和T方向（纹理中的s、t、r轴等价于通常的x、y、z轴）的环绕方式。最后一个参数指定环绕方式，这里我们指定的都是重复纹理图像这种方式。 【注】： 如果我们选择GL_CLAMP_TO_BORDER这种纹理环绕方式，就还需要再指定一个边缘颜色。这时就需要再使用glTexParameterfv函数了：123glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER);GLfloat borderColor[] = &#123; 1.0f,1.0f,0.0f,1.0f &#125;;glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, borderColor); 函数glTexParameterfv的第一个参数依旧是纹理对象绑定的目标；因为要设置边缘颜色，所以第二个参数变成了GL_TEXTURE_BORDER_COLOR；第三个参数是表示颜色的一个float数组。&nbsp; 接下来我们看看对纹理过滤方式的配置 纹理过滤当使用顶点坐标映射相应纹素时，由于是根据位置关系进行插值计算的，所以得到的内部点的纹理坐标不一定是整数，比如说如果纹素位置（即纹理坐标）为（152.34,255,38）该怎么办呢？这种情况称为纹理过滤。 纹理过滤有很多种方法，这里只讨论最重要的两种：GL_NEAREST（最邻近滤波）和GL_LINEAR（线性滤波） 最邻近滤波最邻近滤波是选择中心点距离浮点数纹理坐标最近的那个纹素。图示如下：因为图中红色纹素离纹理坐标最近，所以选择该红色作为最终的输出纹素。 最邻近滤波容易导致走样误差，明显有像素块的感觉。 线性滤波线性滤波是使用纹理坐标附近的一组纹素的加权平均值（插值）来确定最终的纹素值。这个权值就是纹素中心到这个纹理坐标的距离，距离越近的纹素对最终的纹素值贡献越大。如下图所示： 最邻近滤波和线性滤波的对比效果如下：GL_NEAREST产生了颗粒状的图案，能够清晰地看到纹素，而GK_LINEAR能够产生更平滑的图案，很难看出单个的纹素。GL_LINEAR可以产生更真实的输出，不过GL_NEAREST却可以产生出8-bit风格（像素风），也有很多人喜欢。 还有一些其它的滤波方式，比如三线性滤波（Trilinear Filtering）等。 纹素放大缩小时滤波除了对纹理坐标取整时需要用到滤波以外，在纹素到像素时的放大和缩小时，也可能要用到滤波。 什么是纹素到像素的放大、缩小？ 一个纹素最终对应屏幕上的多个像素，称为放大（magnification） 一个纹素最终对应屏幕上的一个像素，这时不需要滤波 一个纹素最终对应少于一个像素，称为缩小 放大和缩小图示如下： 我们可以使用glTexParameteri函数在图像放大滤波和缩小滤波选项时设置纹理滤波：12glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); 第二个参数是放大滤波或者缩小滤波，第三个参数指定滤波方式。&nbsp; 多级渐远纹理mipmap一个物体，当它距离我们比较近时，需要很多像素去表现它；而当距离我们很远时，会看不大清楚，只有很少的像素需要被绘制，这时再从该物体对应的纹理中去找几个纹素来表现它，是很难的。因为它需要跨过纹理很大部分只拾取一个纹素，而且最终拾取出来的纹素凑在一起可能就面目全非了。更何况对于很远的物体去使用高分辨率的纹理无疑是浪费内存。 OpenGL使用多级渐远纹理Mipmap来解决这个问题。mipmap其实就是一系列纹理图像，后一个纹理图像只有前一个纹理图像的一半大小。在观察者的距离在不同的距离范围时使用不同级别的mipmap。mipmap的另一个加分点是它的性能非常好。mipmap图示如下： mipmap滤波在渲染中切换不同级别的mipmap时，会产生一些很明显的边界。对纹素的滤波也可以用到这里，来消除这些很生硬的边界。由于mipmap其实也相当于是把纹理缩小，所以它的滤滤波也是通过glTexParameteri函数在缩小滤波GL_TEXTURE_MIN_FILTER选项时来实现：1glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST_MIPMAP_LINEAR); 函数的第三个参数就是要设置的mipmap滤波方式，它有一下几种选项（“mipmap”之后是mipmap滤波方式，之前是纹素滤波方式）： GL_NEAREST_MIPMAP_NEAREST：使用最接近像素大小的mipmap，纹理内部使用最邻近滤波 GL_LINEAR_MIPMAP_NEAREST：使用最接近像素大小的mipmap，纹理内部使用线性滤波 GL_NEAREST_MIPMAP_LINEAR：在两个最接近像素大小的mipmap中做线性插值，纹理内部使用最邻近滤波 GL_LINEAR_MIPMAP_LINEAR：在两个最接近像素大小的mipmap中线性插值，纹理内部使用线性滤波 设置好mipmap的滤波之后，就可以来创建mipmap了。 创建mipmap手工为每个纹理图像创建一系列mipmap挺麻烦的，不过OpenGL有一个glGenerateMipmaps函数，在创建完一个纹理后调用它，OpenGL就会自动建立该纹理的一系列mipmap了：1glGenerateMipmap(GL_TEXTURE_2D); 【注】： 如果不需要mipmap，那关于mipmap这里的操作可以不要。&nbsp; 解绑纹理对象设置完纹理参数后，需要和别的对象一样，使用完之后解绑纹理对象：1glBindTexture(GL_TEXTURE_2D, 0); &nbsp; 更改顶点着色器123456789101112//顶点着色器#version 330 corelayout (location=0) in vec3 position; //顶点位置变量的属性位置值为0layout (location=1) in vec3 color; //顶点颜色变量的属性位置值为1layout (location=2) in vec2 texCoord; //顶点纹理坐标的属性位置值为2out vec3 ourColor;out vec2 TexCoord;void main()&#123; gl_Position=vec4(position,1.0f); ourColor=color; TexCoord=texCoord;&#125; 顶点着色器需要增加一个纹理坐标的输入变量，由于只有s、t坐标，所以是vec2类型；还需要增加一个输出变量，用于输出纹理坐标给像素着色器。在main函数内把输入纹理坐标赋值给输出纹理坐标。&nbsp; 更改像素着色器12345678910//像素着色器#version 330 corein vec3 ourColor;in vec2 TexCoord;out vec4 color;uniform sampler2D ourTexture;void main()&#123; color = vec4(ourColor,1.0f) * texture(ourTexture,TexCoord);&#125; 像素着色器需要增加一个纹理坐标的输入变量；只有纹理坐标还不足以在像素着色器中输出对应纹素的颜色，我们还需要一个采样器（设置为uniform变量），让它结合纹理坐标、顶点坐标、纹理图像，进行插值获得每一个像素颜色。使用texture函数来使用采样器，第一个参数是我们设置的采用器，第二个参数是纹理坐标。 在main函数内最终的输出颜色我们设置为顶点颜色和纹理颜色的混合。&nbsp; 渲染时绑定纹理对象设置完了纹理和相应的着色器，最后要做的就是在渲染循环里绑定纹理对象，这样才能渲染出纹理（这和绑定VAO是一个道理）。12//绑定纹理glBindTexture(GL_TEXTURE_2D, texture); &nbsp; 自此，所有源码在这里。 编译运行后，结果如下：&nbsp; 使用多个纹理 载入第二张图片载入第二张图片和第一张类似：1234567891011121314151617181920212223242526272829303132333435363738394041424344GLuint texture1;//生成纹理对象texture1glGenTextures(1, &amp;texture1);//给纹理对象绑定目标（2D纹理）glBindTexture(GL_TEXTURE_2D, texture1);int iamgeWidth, iamgeHeight;//加载纹理图像unsigned char* image = SOIL_load_image("container.jpg", &amp;iamgeWidth, &amp;iamgeHeight, 0, SOIL_LOAD_RGB);//生成2D纹理glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, iamgeWidth, iamgeHeight, 0, GL_RGB, GL_UNSIGNED_BYTE, image);//释放纹理数据内存SOIL_free_image_data(image);//设置纹理s和t方向的环绕方式glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);//设置纹理放大和缩写时的过滤方式（纹素过滤、mipmap边界过滤）glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);//生成多级渐远纹理glGenerateMipmap(GL_TEXTURE_2D);//解绑纹理对象glBindTexture(GL_TEXTURE_2D, 0);GLuint texture2;//生成纹理对象texture2glGenTextures(1, &amp;texture2);//给纹理对象绑定目标（2D纹理）glBindTexture(GL_TEXTURE_2D, texture2);//加载纹理图像image = SOIL_load_image("awesomeface.png", &amp;iamgeWidth, &amp;iamgeHeight, 0, SOIL_LOAD_RGB);//生成2D纹理glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, iamgeWidth, iamgeHeight, 0, GL_RGB, GL_UNSIGNED_BYTE, image);//释放纹理数据内存SOIL_free_image_data(image);//设置纹理s和t方向的环绕方式glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_LINEAR);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_LINEAR);//设置纹理放大和缩写时的过滤方式（纹素过滤、mipmap边界过滤）glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);//生成多级渐远纹理glGenerateMipmap(GL_TEXTURE_2D);//解绑纹理对象glBindTexture(GL_TEXTURE_2D, 0); 更改像素着色器使用多个纹理，我们就需要在像素着色器中使用多个采样器：12345678910111213//像素着色器#version 330 corein vec3 ourColor;in vec2 TexCoord;out vec4 color;//纹理采样器1uniform sampler2D ourTexture1;//纹理采样器2uniform sampler2D ourTexture2;void main()&#123; color = vec4(ourColor,1.0f) * mix(texture(ourTexture1,TexCoord),texture(ourTexture2,TexCoord),0.41);&#125; 在main函数中使用mix函数来混合两个纹理，第一个参数是纹理1的纹素颜色，第二个参数是纹理2的纹素颜色，第3个参数是纹素2在最终输出颜色中所占的权重，代码中是59%的纹素1，41%的纹素2。 渲染中激活纹理单元并设置相应采样器我们可以看到我们的采样器是被uniform声明的，但是很奇怪的是之前的源程序中，渲染时并没有对uniform全局变量ourTexture赋值，但是依旧有效并没有报错。这是因为我们的ourTexture变量是个采样器，通过多个采样器我们可以使用多个纹理。 每个纹理都有一个位置值，称为纹理单元（有点像多个纹理叠加时的图层）。而对于纹理处在哪一层，即纹理单元是多少，就是通过使用glUniform1i函数来给采样器赋值，从而确定纹理单元值。但是默认情况下，当只使用一个纹理时，纹理单元GL_TEXTURE0总是被激活的，也就是这个采样器（或者说纹理单元）总是对应0（0图层），所以不需要显式使用glUniform1i函数去为采样器赋值。 但是有多个纹理时，就没有默认了，需要显式为每个采样器指定一个整数值，对应被激活的图层（被激活的纹理单元）：12345678910111213//激活纹理单元glActiveTexture(GL_TEXTURE0);//获取uniform变量位置GLint uniformLocation1 = glGetUniformLocation(myshader.shaderProgram, "ourTexture1");//设置采样器的值（对应纹理单元值）glUniform1i(uniformLocation1, 0);//绑定纹理对象glBindTexture(GL_TEXTURE_2D, texture1);glActiveTexture(GL_TEXTURE1);GLint uniformLocation2 = glGetUniformLocation(myshader.shaderProgram, "ourTexture2");glUniform1i(uniformLocation2, 1);glBindTexture(GL_TEXTURE_2D, texture2); 在给采样器赋值之前，我们需要先激活纹理单元，活着说激活纹理图层，再给采样器赋以相应的被激活的纹理单元值，这样采样器才能读出纹素颜色。【注】： 如果采样器值对应的纹理单元没有被激活，是无法读出纹素的。因为默认纹理单元0是激活的，所以在只渲染一个纹理时，就不用去激活纹理单元并设置采样器值，默认就是用采样器0去纹理单元0（图层0）采集纹素颜色。 设置完采样器的值后，接下来就需要绑定纹理对象，好把相应纹理放在刚刚激活的纹理单元（图层）上。 OpenGL至少保证有16个纹理单元可供使用，也就是说可以激活从GL_TEXTURE0到GL_TEXTURE15。它们都是按顺序定义的，所以GL_TEXTURE8=GL_TEXTURE0+8，这在当我们需要循环一些纹理单元时会很有用。 其余代码和之前的源程序一样，编译运行的结果如下： 翻转图片可以看到第二张纹理上下颠倒了！这是因为OpenGL要求y轴0.0在图片底部，但是通常图片y轴0.0在图片顶部。有一些图片加载器比如DevIL在加载的时候有选项重载y原点，但是SOIL没有。所以，为了修复这个小问题，有两个选择： 改变顶点的纹理坐标属性，翻转y值（用1减去y坐标） 更改顶点着色器中对输出纹理坐标的赋值，也是用1减去y坐标：123456789101112//顶点着色器#version 330 corelayout (location=0) in vec3 position; //顶点位置变量的属性位置值为0layout (location=1) in vec3 color; //顶点颜色变量的属性位置值为1layout (location=2) in vec2 texCoord; //顶点纹理坐标的属性位置值为2out vec3 ourColor;out vec2 TexCoord;void main()&#123; gl_Position=vec4(position,1.0f); ourColor=color; TexCoord=vec2(texCoord.x,1-texCoord.y);&#125; 编译运行后的结果如下：&nbsp; 到此，使用两张纹理的全部源程序在这里。&nbsp; 纹理加载类我们把上面主程序中加载纹理的部分单独封装成一个类：纹理加载类的头文件：12345678910#pragma once#define GLEW_STATIC#include &lt;GL/glew.h&gt;#include &lt;GLFW/glfw3.h&gt;#include &lt;SOIL/SOIL.h&gt;class TextureLoader &#123;public: GLuint LoadTexture(GLchar* texturePath);&#125;; 纹理加载类的源文件：12345678910111213141516171819202122232425262728#include "TextureLoader.h"GLuint TextureLoader::LoadTexture(GLchar* texturePath) &#123; GLuint texture; //生成纹理对象texture glGenTextures(1, &amp;texture); //给纹理对象绑定目标（2D纹理） glBindTexture(GL_TEXTURE_2D, texture); int imageWidth, imageHeight; //加载纹理图像 unsigned char* image = SOIL_load_image(texturePath, &amp;imageWidth, &amp;imageHeight, 0, SOIL_LOAD_RGB); //生成2D纹理 glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, imageWidth, imageHeight, 0, GL_RGB, GL_UNSIGNED_BYTE, image); //释放纹理数据内存 SOIL_free_image_data(image); //设置纹理s和t方向的环绕方式 glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT); //设置纹理放大和缩写时的过滤方式（纹素过滤、mipmap边界过滤） glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); //生成多级渐远纹理 glGenerateMipmap(GL_TEXTURE_2D); //解绑纹理对象 glBindTexture(GL_TEXTURE_2D, 0); return texture;&#125; 主程序可以直接使用该类的LoadTexture函数直接加载图片了。全部源码在这里。&nbsp; 参考文献：LearnOpenGL]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>纹理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++的输入输出]]></title>
    <url>%2F2016%2F11%2F25%2FC%2B%2B%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%2F</url>
    <content type="text"><![CDATA[C++输入输出系统的优势C语言本身有自己的输入输出方式，作为升级版的C++为何还要建立一个输入输出系统呢？原因如下： C++的输入输出系统是类型安全的，也就是说它可以自动识别输出数据的类型，如cout &lt;&lt; 5;会自动识别出要输出的数据是字符串类型，但是如果用C的话就得写成printf(&quot;%d&quot;,5);。因为C++可以自动识别类型，所以可以有效防止格式控制符与输出数据的类型不一致的错误。 C++可以通过重载运算符&lt;&lt;和&gt;&gt;，让用户能够自定义输入和输出的形式，并且可以像预定义（C++已经定义好的\自带的）的一样有效方便。 C++输入输出的书写形式简单清晰，程序代码会有更好的可读性。 【注】： 在C++中也可以使用C的printf和scanf函数。&nbsp; C++的输入输出流C++的输入输出是以字节流的形式实现的。在输入操作中，字节流从输入设备（如键盘、磁盘、网络连接等）流向内存；输出操作中，字节流从内存流向输出设备（如显示器、打印机、网络连接等）。可以看到输入输出是相对于内存的，流向内存的称为输入，从内存流出的称为输出。 C++编译系统给了一个用于输入输出的库：iostream类库。这个类库中包含了很多头文件，很多用于输入输出操作的类的声明都放在这些头文件中。&nbsp; C++用于输入输出的常用头文件 iostream：主要用于基本的输入输出操作。使用cin、cout对标准设备进行IO（输入输出）时，须包含此头文件。 fstream： 用于文件的IO操作。使用文件流对象对磁盘文件进行读写，须包含此头文件。 sstream：用于字符串流的IO操作。使用字符串流对象对内存字符串空间的IO操作，须包含此头文件。 iomanip：用于输入输出时的格式控制。在使用setw、fixed等大多数操作符进行格式控制时，须包含此头文件。 【注】： 用于字符串流IO的还有strstream头文件。strstream头文件是基于C类型字符串char*类型编写的，返回的是char*类型的字符串；而sstream是基于std::string编写的，返回的是string类型的字符串。&nbsp; C++用于输入输出的流类C++的iostream类库中当然还有很多用于输入输出的类，它们的声明都包含在上诉头文件中。常用的流类有如下：其中，ios类是所有输入输出类的抽象基类，类istream和ostream单一继承ios类，而类iostream多重继承于类istream和ostream。&nbsp; C++预定义的流对象用上诉的流类定义的对象称为流对象。C++有几个已经定义好的流对象，也就是C++自带的： cin：它是istream类的派生类istream_withassign的对象，与标准输入设备（比如键盘）相联系。 cout：它是ostream类的派生类ostream_withassign的对象，与标准输出设备（比如显示器）相联系。 cerr：它也是ostream类的派生类ostream_withassign的对象，与标准错误输出设备（比如显示器）相联系。 clog：它也是ostream类的派生类ostream_withassign的对象，也是与标准错误输出设备（比如显示器）相联系。 【注】： 可以看到cerr和clog都用来输出错误信息。区别是cerr不经过缓冲区，直接向显示器输出相关信息，所以发送给它的任何内容都立即输出；而clog中的信息存放在缓冲区中，缓冲区满后或遇上endl后才向显示器输出。&nbsp; 基本输入输出流的成员函数众所周知，C++的基本输入输出可以用&lt;&lt;（输出运算符\插入运算符）和&gt;&gt;（输入运算符\提取运算符）来实现。除此之外，还可以使用类istream和类ostream对象的一些成员函数来实现字符的输入输出： put函数put函数用于输出一个字符，形如：cout.put(&#39;A&#39;);。 它的参数可以是一个字符，也可以是字符的ASCII码，如cout.put(65);也会在屏幕上显示字符A。 get函数get函数用于读入一个字符，赋给指定的字符。形如：char ch;cin.get(ch);。get函数会把从标准输入设备（键盘）上输入的字符赋值给字符类型变量ch。 cin.get函数与&gt;&gt;有一点不同，get函数可以读入空白字符，而&gt;&gt;默认情况下是不接收空白字符的。 getline函数getline函数用于读取n-1个字符，赋给指定的字符数组，然后插入一个字符串结束标志’\n’。形如：char line[20];cin.getline(line,20,&#39;t&#39;);。如果在读取n-1个字符之前遇到指定的终止字符（比如第三个参数t），则会提前结束读取。 使用cin&lt;&lt;读取数据默认以空白字符（包括空格、tab键、回车键）作为终止字符，而cin.getline是可以读取空格的。 ignore函数ignore函数用于跳过输入的n个字符，或者在遇到指定字符时停止跳过。形如:1234char* str=new char();cin.ignore(3,'z');cin.getline(str,6,'a');cout&lt;&lt;str&lt;&lt;endl; 如果输入bcdefghi，ignore函数会跳过头3个字符bcd，getline函数把后面的efghi这5个字符存储到str中，最后在屏幕上输出的就是efghi。 如果输入bzdefga，ignore函数在跳过3个字符之前遇到了指定的终止字符z，getline函数继续读取字符，在读取6-1个字符之前遇到了指定的终止字符a，最后输出defg。&nbsp; 重载&gt;&gt;和&lt;&lt;我们可以重载输入运算符&gt;&gt;和输出运算符&lt;&lt;，来达到我们想要的输出方式。 重载输出运算符&lt;&lt;重载的格式如下：123456ostream &amp;operator&lt;&lt;(ostream &amp;out, class_name&amp; obj) &#123; out &lt;&lt; obj.item1; out &lt;&lt; obj.item2; out &lt;&lt; obj.itemn; return out;&#125; 其中class_name是我们自定义的类名，函数内部可以根据需要输出我们想输出的内容。以后使用&lt;&lt;对象名就可以一次性输出你想输出的全部内容。举例如下：1234567891011121314151617181920212223#include "stdafx.h"#include&lt;iostream&gt;using namespace std;class Coord &#123;public: int x, y; Coord(int i = 0, int j = 0) &#123; x = i; y = j; &#125;&#125;;//重载输出运算符&lt;&lt;ostream &amp;operator&lt;&lt;(ostream &amp;out, Coord&amp; obj) &#123; out &lt;&lt; obj.x &lt;&lt; "," &lt;&lt; obj.y; return out;&#125;int main() &#123; Coord a(11, 22); cout &lt;&lt; a &lt;&lt; endl; return 0;&#125; 输出的结果如下：111,22 重载输入运算符&gt;&gt;重载的格式如下：123456istream &amp;operator&gt;&gt;(istream &amp;in, class_name&amp; obj) &#123; in &gt;&gt; obj.item1; in &gt;&gt; obj.item2; in &gt;&gt; obj.itemn; return in;&#125; 其中class_name是我们自定义的类名，函数内部可以根据需要输入我们需要的内容。以后使用&gt;&gt;对象名就可以一次性输入需要的全部内容。举例如下：12345678910111213141516171819202122232425#include "stdafx.h"#include&lt;iostream&gt;using namespace std;class Coord &#123;public: int x, y; Coord(int i = 0, int j = 0) &#123; x = i; y = j; &#125;&#125;;istream &amp;operator&gt;&gt;(istream &amp;in, Coord&amp; obj) &#123; in &gt;&gt; obj.x; in &gt;&gt; obj.y; return in;&#125;int main() &#123; Coord a; cin &gt;&gt; a; cout &lt;&lt; a.x &lt;&lt; "," &lt;&lt; a.y &lt;&lt; endl; return 0;&#125; 如果输入如下：111 22 那么会有如下输出结果：111,22 【注】： 上述两个重载代码虽然简单易懂，但是在工程设计上确实有点糟糕啊~-~！&nbsp; 对于文件的输入输出请参考《C++文件的输入输出》，对于字符串流的输入输出这篇文章也有简单介绍。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenGL4：着色器]]></title>
    <url>%2F2016%2F11%2F25%2FOpenGL4%E7%9D%80%E8%89%B2%E5%99%A8%2F</url>
    <content type="text"><![CDATA[在上一篇文章中，我们已经知道了简单的着色器和它们的使用方法，本文再详细地来看看着色器。着色器是运行在GPU上的小程序，是一种相当独立的程序，它们不能相互通信，只能通过输入和输出的方式进行沟通：在链接程序对象的时候，上一个阶段着色器的输出变量，和下一阶段的同名同类型输入变量，会链接到一起。&nbsp; GLSL概述在OpenGL中着色器是用GLSL语言来编写的，它是为图形计算量身定制的，尤其是向量和矩阵运算。 着色器的开头总是要声明GLSL的版本，用于匹配对应的OpenGL版本。接着是输入变量和输出变量、uniform和main函数。和大多数程序一样，着色器的入口点也是main函数，在main函数中我们处理所有的输入变量，并且用输出变量输出结果。 着色器一般都形如：123456789101112131415#version version_numberin type in_variable_name;in type in_variable_name;out type out_variable_name;uniform type uniform_name;int main() &#123; //处理输入并进行一些图形操作 ... //输出处理的结果到输出变量 out_variable_name=...&#125; 对于顶点着色器，每个输入变量也叫顶点属性（vertex attribute）。由于硬件有限，我们能够声明的顶点属性是有上限的。不同的硬件上限可能不同，想知道你的电脑最多能支持多少个顶点属性的话，可以查询一下：123GLint maxVertexAttribs;glGetIntegerv(GL_MAX_VERTEX_ATTRIBS, &amp;maxVertexAttribs);cout &lt;&lt; maxVertexAttribs &lt;&lt; endl; 通常情况下至少会返回16个，大部分情况够用了。OpenGL也确保至少16个包含4分量的顶点属性可用。&nbsp; GLSL中的向量前面提到GLSL对向量提供了特别支持，下面来看一下。GLSL中的向量是一个可以包含有1、2、3或4个分量的容器，分量的类型可以是基础类型中的任意一个。根据分量类型和支持的分量个数，有如下几种向量（n代表分量数量）： vecn：包含n个float分量的默认向量 bvecn：包含n个bool分量的向量 ivecn：包含n个int分量的向量 uven：包含n个unsigned int分量的向量 dvecn：包含n个double分量的向量 除此之外，GLSL还允许对颜色使用rgba向量，对纹理使用stpq向量。 GLSL所支持的向量有很灵活的分量组成方式，叫做重组（swizzling）。重组允许像这样的语法：1234vec2 someVec;vec4 differentVec = someVec.xyxx;vec3 anotherVec = differentVec.zyw;vec4 otherVec = someVec.xxxx + anotherVec.yxzy; 可以利用向量现有的分量重组成其它个数的向量。 当然向量（或其分量）还可以作为另一个向量的构造参数：123vec2 vect = vec2(0.5f, 0.7f);vec4 result = vec4(vect, 0.0f, 0.0f);vec4 otherResult = vec4(result.xyz, 1.0f); &nbsp; 输入与输出每个着色器都应当有输入和输出，这样才能进行数据交流和传递嘛！GLSL定义了in和out关键字来实现输入输出。 但是在顶点着色器中稍微有点不同，顶点着色器作为渲染管线上的第一个着色器，它的输入是从顶点数据中直接接收输入。为了定义顶点数据该如何管理，我们使用location这一元素指定输入变量（在用glVertexAttribPointer函数解析缓冲中的顶点数据时会用到），这样我们才可以在CPU上配置顶点属性。此外，顶点着色器还需要为它的输入提供一个额外的layout标识，这样我们才能把location链接到顶点数据，形如：layout(location=0)。【注】： 也可以不用layout(location=0)，而通过在OpenGL代码中使用glGetAttribLocation函数查询属性位置值（location），只是工作量大了些。 还有渲染管线上的最后一个着色器——像素着色器，也有点不同。它需要有一个vec4颜色输出变量，因为像素着色器需要生产一个最终输出的颜色。如果在像素着色器中没有定义输出颜色，OpenGL会把物体渲染为白色（或黑色）。 如果我们打算从一个着色器向另一个着色器发送数据，我们必须在发送方着色器中声明一个输出，在接收方着色器声明一个同名输入。当名字和类型都一样的时候，OpenGL就会把两个变量链接到一起，它们之间就可以发送数据了（这是在链接程序对象时完成的）。 接下来上个demo，让顶点着色器为像素着色器决定颜色：顶点着色器：123456789//顶点着色器const GLchar* vertexShaderSource ="#version 330 core\n""layout (location=0) in vec3 position;\n""out vec4 vertexColor;\n""void main()&#123;\n""gl_Position=vec4(position.x,position.y,position.z,1.0f);\n""vertexColor=vec4(0.5,0.0f,0.0f,1.0f);\n""&#125;\0"; 像素着色器：12345678//像素着色器const GLchar* fragmentShaderSource ="#version 330 core\n""in vec4 vertexColor;\n""out vec4 color;\n""void main()&#123;\n""color=vertexColor;\n""&#125;\0"; 可以看到我们在顶点着色器中声明了一个vertexColor变量作为输出，并且在顶点着色器的main函数中为这个输出变量赋了值；然后在像素着色器中声明了一个同名同类型的输入变量，并在其main函数中令输出变量color等于该输入变量。当链接程序对象后，像素着色器的vertexColor就和顶点着色器的vertexColor链接在一起了，因为我们在顶点着色器中设置的是深红色的，所以在像素着色器中输出的结果也是深红色的：我们完成了顶点着色器向像素着色器发送数据！&nbsp; 全局变量uniform上面我们完成了一个着色器向另一个着色器发送数据，那么能不能从应用程序向像素着色器发送一个颜色呢？我们可以使用全局变量unifrom来实现。 uniform是一种从CPU中的应用向GPU中的着色器发送数据的方式。但是uniform和顶点属性不同，uniform变量是全局的，在每个着色器程序都是独一无二的，可以在渲染管线的任意一个阶段访问。而且uniform变量会一直保存它们的数据，直到它们被重置或更新。 一般我们都是在着色器代码中声明uniform变量，形如uniform vec4 ourColor。 下面上一个demo，我们通过uniform变量来设置三角形颜色。 像素着色器：12345678//像素着色器const GLchar* fragmentShaderSource ="#version 330 core\n""out vec4 color;\n""uniform vec4 ourColor;\n""void main()&#123;\n""color=ourColor;\n""&#125;\0"; 我们在像素着色器中声明了一个uniform变量ourColor，并且把像素着色器的输出颜色设置为uniform变量的值。 下面我们到应用程序里，去给这个在像素着色器中声明的uniform变量赋值。首先需要找到这个uniform变量在着色器程序对象中的位置，我们使用glGetUniformLocation函数来完成。然后就可以使用glUniform4f函数来给uniform变量赋值了：123456//激活着色器程序对象glUseProgram(shaderProgram);//找到uniform变量在着色器程序对象中的位置GLint ourColorLocation = glGetUniformLocation(shaderProgram, "ourColor");//给uniform变量赋值glUniform4f(ourColorLocation, 0.0f, 1.0f, 0.0f, 1.0f); glGetUniformLocation函数第一个参数是链接后的着色器程序对象，第二个参数是我们要查找的uniform变量，返回GLint类型变量，代表找到的位置值。glUniform4f函数的第一参数是uniform变量的位置值，接下来几个参数就是R、G、B、A了。【注】： 查询uniform变量位置和给uniform变量赋值在glUseProgram前后都可以。 因为OpenGL的核心库是C库，所以它的函数不支持重载，在函数参数不同时就需要为其定义新的函数。glUniform函数就是一个例子。这个函数用后缀标识设定的uniform类型，可能的后缀有： f：函数需要1个float作为uniform变量的值 i：函数需要1个int作为uniform变量的值 ui：函数需要1个uint作为uniform变量的值 3f：函数需要3个float作为uniform变量的值 fv：函数需要一个float向量/数组作为uniform变量的值 上面我们找到了在着色器程序对象中uniform变量ourColor的位置，并给它赋值为绿色（0,1,0,1），在渲染后就会在窗口上出现一个绿色的三角形。 现在我们把效果做的再灵动点：让三角形的颜色随着时间不断变化。想一想其实很简单吧，只需要把上面程序中的绿色改为随时间变化的颜色就可以了：1234567// 更新颜色GLfloat timeValue = glfwGetTime();GLfloat greenValue = sin(timeValue) / 2 + 0.5;//给uniform变量赋值glUniform4f(ourColorLocation, 0.0f, greenValue, 0.0f, 1.0f);//激活着色器程序对象glUseProgram(shaderProgram); glfwGetTime函数会获取运行的秒数，然后使用sin函数让颜色值在0到1之间变化，把结果存储到greenValue变量里。再使用这个不断变化（每一次循环greenValue的值都会改变）的变量去给uniform变量赋值，这样像素着色器输出的颜色值也就是在随着时间不断变化了。 所有源码在这里。 编译运行后的结果如下： &nbsp; 多个顶点属性可以看到上面的三角形内部点都是相同的颜色，或者三角形的每个顶点都是相同的颜色，这是因为三个顶点都是使用像素着色器中的输出颜色来绘制的，那三角形的这三个顶点肯定同色了，而在使用GL_TRIANGLES方式进行绘制时，三角形内部点的颜色是由三个顶点的颜色值插值计算得到，由于三个顶点同色，插值后的结果当然还是和顶点一样的颜色，所以整个三角形中的所有点就都是一个颜色。归根结底就是因为三角形的三个顶点同色造成的，现在如果我们想要三角形中点不同色，那就需要给这三个顶点赋不同的颜色值了。也就是每个顶点现在应该要有两种顶点属性：顶点位置坐标、顶点颜色：1234567//三角形顶点的坐标和颜色GLfloat vertices[] = &#123; //位置坐标 //颜色 -0.5f,-0.5f,0.0f, 1.0f,0.0f,0.0f, 0.5f, -0.5f,0.0f, 0.0f,1.0f,0.0f, 0.0f, 0.5f, 0.0f, 0.0f,0.0f,1.0f&#125;; 输入的顶点数据变了，顶点属性也增加了，所以我们还需要使用glVertexAttribPointer函数重新解析顶点数据：12345678//告诉OpenGL如何解析显存中的顶点位置属性数据glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(GLfloat), (GLvoid*)0);//打开顶点位置属性数组glEnableVertexAttribArray(0);//告诉OpenGL如何解析显存中的顶点颜色属性数据glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(GLfloat), (GLvoid*)(3 * sizeof(GLfloat)));//打开顶点颜色属性数组glEnableVertexAttribArray(1); 对于顶点位置坐标属性，它的location为0，由三个float组成，不需要规范化，因为从位置属性开始每隔6个float数据（3个位置坐标、3个颜色），才会再次回到位置属性，所以步长是6*sizeof(GLfloat)，第一个位置属性在缓冲中的偏移量是0；对于顶点颜色属性，它的location为1，由三个float组成，不需要规范化，颜色属性也是6个float数据一个轮回，所以步长也是6*sizeof(GLfloat)，第一个颜色属性是在3个float坐标分量（x、y、z）之后才开始的，所以偏移量是(GLvoid*)(3*sizeof(GLfloat))。 然后需要在顶点着色器中增加一个颜色输入属性，然后把颜色输出（以便传递给像素着色器）：12345678910//顶点着色器const GLchar* vertexShaderSource ="#version 330 core\n""layout (location=0) in vec3 position;\n" //位置变量的属性位置值为0"layout (location=1) in vec3 color;\n" //颜色变量的属性位置值为1"out vec3 ourColor;\n""void main()&#123;\n""gl_Position=vec4(position,1.0f);\n""ourColor=color;\n""&#125;\0"; 接着在像素着色器接收颜色，并把它赋值给输出颜色变量：12345678//像素着色器const GLchar* fragmentShaderSource ="#version 330 core\n""in vec3 ourColor;\n""out vec4 color;\n""void main()&#123;\n""color=vec4(ourColor,1.0f);\n""&#125;\0"; 这样我们就能给三角形三个顶点赋不同的颜色值了，并且三角形内部的点会由三个顶点颜色插值得到。 全部源码在这里。 编译运行后的结果如下：&nbsp; 自定义着色器类从上面的程序里可以看到，主函数main太庞杂了，我们希望减轻main函数的负担，把有关着色器的内容拿出来，单独封装成一个类，用于读取、编译、管理着色器，也便于程序理解和移植。 前面是直接把着色器代码写到字符串里，很不方便，IDE也没法检查是否有语法错误。所以我们选择把着色器代码单独写在另一个文件里，要用的时候从文件里读出来。读文件的代码如下：123456789101112131415161718192021222324//从指定路径的文件中读取着色器源码const GLchar* shader::GetShaderSourceFromFile(const GLchar* shaderPath) &#123; //以二进制方式打开指定路径的文件 ifstream fin(shaderPath, ios::binary); //检测是否成功打开文件 if (!fin) &#123; cout &lt;&lt; "Cannot open input file" &lt;&lt; endl; exit(1); &#125; //将读指针设置到文件尾 fin.seekg(0, ios::end); //读出当前文件位置，以获取文件长度 int length = fin.tellg(); //定义长度为length+1的字符串来存储文件内容 char* shaderSource = new char[length + 1]; //重新将读指针设置到文件头 fin.seekg(0, ios::beg); //读出整个文件 fin.read(shaderSource, length); //给字符串末尾加上字符串结束符'\0' shaderSource[length] = '\0'; fin.close(); return shaderSource;&#125; 这里把读文件写在一个名为GetShaderSourceFromFile的函数里，函数返回的就是从文件里读出的着色器代码。注释很详细，就不再赘述了，关于C++的文件IO可以参考《C++文件的输入输出》。 其余的代码和之前差不多，只是关于着色器的都转移到了类里而已，全部源码在这里：&nbsp; 参考文献：LearnOpenGL]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>着色器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++文件的输入输出]]></title>
    <url>%2F2016%2F11%2F24%2FC%2B%2B%E6%96%87%E4%BB%B6IO%2F</url>
    <content type="text"><![CDATA[计算机领域的文件，其实是指存放在外部介质上的数据的集合。 如果想查找存放在外部介质上的数据，必须先按文件名找到所指定的文件，然后再从该文件中读取数据；而要把数据存储在外部介质上，必须先建立一个文件（以文件名标识），才能向它存入数据。&nbsp; 文本文件和二进制文件C++按照数据的组织形式，把文件分为文本文件和二进制文件。 文本文件文本文件又称ASCII文件，它的每个字节存放一个ASCII码，代表一个字符。 比如，对于一个整数10000，它如果按照文本形式输出到磁盘上，因为有5个数字，每个字符占一个字节，所以需要5个字节来保存这个整数。用文本形式输出时，一个字节对应一个字符，这便于对字符进行逐个处理，也便于输出字符，但是占用的存储空间较大。 二进制文件二进制文件是把内存中的数据，按照其在内存中的存储形式原样写到磁盘上存放。 比如，对于一个整数10000，它在内存中只需要两个字节就能存储10000的二进制形式，它如果按照二进制形式输出到磁盘上，当然还是在磁盘上占用两个字节就能表示出10000的二进制。用二进制形式输出数据，可以节省存储空间和转换时间，但是一个字节不能对应一个字符，无法直接以字符形式输出。对于需要暂时保存在外存上，以后又需要输入到内存的中间结果数据，常用二进制形式保存。&nbsp; C++进行文件输入输出的基本过程在C++中，无论对文本文件还是二进制文件，要进行文件的输入输出，必须首先创建一个流对象，然后将这个流对象与文件相关联，即打开文件，此时才能进行读写操作，读写操作完成后再关闭这个文件。 创建流对象 → 打开文件 → 读写操作 → 关闭文件。&nbsp; 创建流对象建立流的过程其实就是定义流类的对象。因为与文件IO有关的类fstream、ifstream和ofstream都包含在头文件fstream，所以首先需要在程序中包含此头文件：#include &lt;fstream&gt;。 接下来使用流类来定义流对象，例如：123ifstream in;ofstream out;fstream both; 分别定义了输入流对象in、输出流对象out、输入输出流对象both。 其实常用的cin和cout也是流对象，只是已经在头文件iostream中事先定义好了，我们不需要再去自己定义了。&nbsp; 打开文件打开文件有两种方式：使用3个文件流类的成员函数open打开文件、在定义流对象时同时打开文件。 使用成员函数open打开文件一般形式是：文件流对象.open(文件名,打开方式); 其中文件名可以是相对路径也可以是绝对路径。 打开方式有如下选项： ios::app：打开一个输出文件，用于将数据添加到文件尾部。文件位置指针自动移到文件尾部。 ios::ate：打开一个现存文件，文件位置指针自动移到文件尾部，但数据可以写入文件中任何地方。 ios::in：打开一个文件，用于输入数据，即从文件读出数据到内存。 ios::nocreate：打开一个文件，若文件不存在，则打开失败（通常用open函数打开文件时，如果不存在则创建该文件）。 ios::noreplace：打开一个文件，若文件存在，则打开失败，不存在则新建文件。 ios::out：打开一个文件，用于输出数据，即从内存写入数据到文件。 ios::trunc：打开一个文件，若文件存在，则删除其中全部数据；若文件不存在，则新建文件。 ios::binary：以二进制方式打开一个文件，默认情况下是以文本方式打开文件。 对于ifstream对象，文件打开方式默认为ios::in；对于ofstream对象，文件打开方式默认为ios::out。 当一个文件需要多种方式打开时，可以用操作符“|”把几种方式连接在一起。例如，打开一个用于输入和输出的二进制文件：12fstream mystream;mystream.open("test.dat",ios::in|ios::out|ios::binary); 定义流对象同时打开文件可以在定义文件流对象时指定文件路径，来同时打开文件。形如：1ofstream out("test.dat"); 由于这种方式没有指定打开方式，所以使用的是默认打开方式，依旧是：ifstream对象为ios::in打开方式，ofstream对象为ios::out打开方式。所以上面的打开文件代码相当于：12ofstream out;out.open("test.dat"); 检测打开文件是否成功执行打开文件操作后，还需要检测打开文件是否成功，如果打开失败，与文件相联系的流对象（比如上面的out）的值将是0。检测代码形如：12345if(!out)&#123; cout&lt;&lt;"Cannot open file!"&lt;&lt;endl; //其它处理 ...&#125; &nbsp; 文件读写文件打开以后，就可以进行文件读写了。但是由于数据组织方式不同，文本文件和二进制文件的读写是不一样的（二进制文件在打开时还需要显式指定ios::binary打开方式，默认是以文本方式打开）。 文本文件的读写其实和cin、cout一样，使用流对象&gt;&gt;把数据从文件输入到内存，使用流对象&lt;&lt;把数据从内存输出到文件。 下面上个demo，先建立一个输出文件，向它写入数据，然后关闭文件，在按输入方式打开它，并读取信息，保存到变量中，在屏幕上显示出来：12345678910111213141516171819202122232425262728293031323334#include "stdafx.h"#include &lt;iostream&gt;#include &lt;fstream&gt;using namespace std;int main() &#123; //定义输出流对象，同时打开文件 ofstream fout("test.dat"); //检测文件是否打开成功 if (!fout) &#123; cout &lt;&lt; "Cannot open output file!" &lt;&lt; endl; &#125; //把一个字符串写到磁盘文件test.dat中 fout &lt;&lt; "hello!\n"; //把一个十进制整数和一个十六进制整数写到test.dat中 fout &lt;&lt; 100 &lt;&lt; ' ' &lt;&lt; hex &lt;&lt; 100 &lt;&lt; endl; //关闭文件 fout.close(); //定义输入流对象，同时打开文件 ifstream fin("test.dat"); if (!fin) &#123; cout &lt;&lt; "Cannot open input file!" &lt;&lt; endl; &#125; char* s=new char(); int i; int j; //从磁盘文件test.dat中读取一个字符串赋给s，读取一个整数赋给i fin &gt;&gt; s &gt;&gt; i &gt;&gt; j; //在屏幕上显示 cout &lt;&lt; s &lt;&lt; endl &lt;&lt; i &lt;&lt; endl &lt;&lt; j &lt;&lt; endl; fin.close(); return 0;&#125; 编译运行后，会在该源文件同路径下，创建出一个test.dat文件，文件中内容如下：12hello!100 64 并且在屏幕上会输出如下结果：123hello!10064 64是100的二进制。 二进制文件的读写二进制文件的读写不再是使用&gt;&gt;或&lt;&lt;，而是使用类istream和类ostream的成员函数来进行读写。 根据每次读写的数据量不同，二进制文件的读写有两种方式：一种是使用成员函数get和put；另一种是使用成员函数read和write。 使用get和put函数读写二进制文件：get函数是类istream的成员函数，put函数是类ostream的成员函数，它们每次都只是读写一个字节（字符）。 上个demo体会一下，将a到z的26个英文字母写入二进制文件，而后从该文件中读出并在屏幕上显示出来： 12345678910111213141516171819202122232425262728293031 #include "stdafx.h" #include &lt;iostream&gt; #include &lt;fstream&gt; using namespace std; int main() &#123; ofstream outb("binary.dat", ios::binary); if (!outb) &#123; cout &lt;&lt; "Cannot open output file!" &lt;&lt; endl; exit(1); //退出程序，和abort()作用一样 &#125; char ch = 'a'; for (int i = 0; i &lt; 26; i++) &#123; //输出字符到磁盘文件binary.dat中 outb.put(ch); ch++; &#125; outb.close(); ifstream inb("binary.dat", ios::binary); if (!inb) &#123; cout &lt;&lt; "Cannot open input file" &lt;&lt; endl; abort(); &#125; while (inb.get(ch)) &#123; //从磁盘文件中读取字符赋给ch cout &lt;&lt; ch; &#125; inb.close(); return 0;&#125; 编译运行后，会在该源文件同路径下，创建出一个binary.dat，文件内容是26个小写英文字符对应的二进制（用记事本等工具打开后二进制会转为字符，所以用记事本打开看到的不是二进制，而是26个英文字母），并且屏幕上回输出如下结果： 1abcdefghijklmnopqrstuvwxyz 使用read和write函数读写二进制文件： read函数是类istream的成员函数，形如inb .read(char* buf,int len);。用于从与输入文件流对象inb向关联的磁盘文件中，读取len个字节（或遇到EOF提前结束），并把它们存放在字符指针buf所指的一段内存空间内。如果在len个字节（字符）前被读出前，就到达了文件尾，则read函数停止执行。 write函数是类ostream的成员函数，形如outb.write(const char* buf,int len); 。用于将字符指针buf所给出地址开始的len个字节的内容，不加转换地写到与输出文件流对象outb相关联的磁盘文件中。 再上个demo体会一下，将课程结构体以二进制形式一次性存放到磁盘文件中： 12345678910111213141516171819202122232425262728293031323334353637 #include "stdafx.h" #include &lt;iostream&gt; #include &lt;fstream&gt; using namespace std; //课程结构体struct Course &#123; char courseName[20]; int score;&#125;;int main() &#123; //课程结构体实例 Course course = &#123; "computer",100 &#125;; ofstream outb("binary2.dat", ios::binary); if (!outb) &#123; cout &lt;&lt; "Cannot open output file!" &lt;&lt; endl; exit(1); &#125; //将课程结构体实例写入磁盘文件binary2.dat中 outb.write((char*)&amp;course, sizeof(course)); outb.close(); //课程结构体实例，用于存储从文件中读取的数据 Course inCourse; ifstream inb("binary2.dat", ios::binary); if (!inb) &#123; cout &lt;&lt; "Cannot open input file!" &lt;&lt; endl; exit(1); &#125; //从磁盘文件binary2中读取数据存入inCourse结构体实例中 inb.read((char*)&amp;inCourse, sizeof(inCourse)); cout &lt;&lt; "courseName:" &lt;&lt; inCourse.courseName &lt;&lt; ' ' &lt;&lt; "score:" &lt;&lt; inCourse.score &lt;&lt; endl; inb.close(); return 0;&#125; 编译运行后，在源文件同路径下回创建出一个binary2.dat文件，用记事本打开结果如下： 1computer d 因为用记事本打开时会自动将二进制转换为字符，而数字100对应的二进制正好是字母d的ASCII码，所以数字100转变成了字母d。并且屏幕上会出现如下结果： 1courseName:computer score:100 检测读文件是否结束在文件结束的地方有一个标志位，记为EOF（end of file）。采用文件流方式读文件时，使用成员函数eof可以检测到这个结束符：12345ifstream in;...if(!in.eof())&#123; ...&#125; 函数eof如果返回值为0，未达到文件尾；如果返回值非0，表示到达文件尾。 其实前面在使用get函数读文件时：1234while (inb.get(ch)) &#123; //从磁盘文件中读取字符赋给ch cout &lt;&lt; ch; &#125; get函数在读取字符的同时，也通过返回值是否为0，判断是否到达文件尾。 二进制文件的随机读写文本文件一般是顺序读写的，但二进制文件还支持从任意位置开始读写，即随机读写。主要是靠设置读指针和写指针的位置来实现。 类istream提供了3个成员函数来设置读指针位置（下面的g是get的缩写）： tellg()：返回读指针的当前位置 seekg(long position)：将读指针设置到指定的position位置（以字节为单位） seekg(long offset,int way)：以参照位置way为基准移动offset个字节 参照位置有如下选项： ios::beg：文件开头位置 ios::cur：当前文件指针位置 ios::end：文件末尾位置 例如inf.seekg(-50,ios::cur);，表示使读指针以当前位置为基准向前（文件开头方向）移动50个字节。 类ostream也提供了3个成员函数来设置写指针位置（下面的p是put的缩写）： tellp()：返回当前写指针的位置 seekp(long position)：将写指针设置到指定的position位置（以字节为单位） seekp(long offset,int way)：以参考位置way为基准移动offset个字节 参照位置选项与上面的相同，不赘述了。 把读指针位置设置为文件尾ios::end，再使用tellg函数可以获得整个文件的长度：12fin.seekg(0, ios::end); int length = fin.tellg(); 知道了整个文件的长度，再使用read函数就可以一次性读出整个文件。上个demo，现在已经有一个binary.dat文件，文件内容如下：12abcdefghijklmnopqrstuvwxyzABC 实现代码如下：1234567891011121314151617181920212223#include "stdafx.h"#include&lt;iostream&gt;#include&lt;fstream&gt;using namespace std;int main() &#123; ifstream fin("binary.dat", ios::binary); //设置读指针到文件尾 fin.seekg(0, ios::end); //读出当前读指针的位置，从而得到文件长度 int length = fin.tellg(); //新建字符串str存储文件内容。 //需要在读出所有内容后给字符串加'\0'，所以长度设为length+1 char* str = new char[length + 1]; //把读指针重新设到文件头 fin.seekg(0, ios::beg); //一次性读出整个文件 fin.read(str, length); //给str加上字符串结束符'\0' str[length] = '\0'; cout &lt;&lt; str &lt;&lt; endl; fin.close();&#125; 编译运行后，在屏幕上的输出结果如下：12abcdefghijklmnopqrstuvwxyzABC 【注】： 成员函数get、put、read、write函数不仅可以用于二进制文件，也可以用于文本文件 当要将文件完整读入时，最好使用二进制方式打开ios::binary，因为如果以文本文件方式打开的话，文件流会把一些非字符的数据过滤掉，我们将读取不到那些内容。&nbsp; 关闭文件输入输出操作完成后，应该将文件关闭，否则可能丢失数据。所谓关闭，其实是将所打开的磁盘文件与流对象断开联系，关闭后流对象就不能再对该文件进行输入输出操作了。使用close成员函数实现，形如：1234in.close();out.close();inb.close();outb.close(); &nbsp; C++字符串流的输入输出C++字符串流的输入输出与文件IO类似。文件IO是内存和磁盘文件之间传递数据，而字符串流IO是内存和字符串流之间传递数据。 字符串流IO主要由三个类来实现： istringstream类：从字符串流向内存输入数据 ostringstream类：从内存向字符串流输出数据 stringstream类：既可以向字符串流读数据也可以写数据 【注】： string字符串其实也是内存 它们都包含在sstream.h头文件中。 也是通过字符串流对象配合&gt;&gt;和&lt;&lt;运算符来进行IO操作： 1234string line=&quot;ourStr&quot;;istringstream ins(line);string str;ins&gt;&gt;str; 1234string line;ostringstream outs;outs&lt;&lt;&quot;ourStr&quot;;cout&lt;&lt;outs.str()&lt;&lt;endl;]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>文件IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenGL3：着色器画三角形]]></title>
    <url>%2F2016%2F11%2F19%2FOpenGL3%E7%9D%80%E8%89%B2%E5%99%A8%E7%94%BB%E4%B8%89%E8%A7%92%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[在高版本的OpenGL中绘制图形，这个过程主要是由OpenGL的图形输送管道来完成的。&nbsp; 图形输送管道图形输送管段（pipeline，管线）接收一组3D坐标，然后把它们转变为屏幕上的有色2D像素。图形输送管道可以被划分为几个阶段，每个阶段的输出都是下一个阶段的输入。所有这些阶段都是高度专门化的，它们能够简单地并行执行。由于它们的可并行执行的特征，当今大多数显卡都有成千上万的小处理核心，在GPU上为管线上的每个阶段运行各自的小程序，从而在图形输送管道中快速处理这些它的以及几何运算。这些小程序就叫做着色器（如今CPU最多只有8核，而GPU却有很多很多简单的核，可以大量并行执行那些不是很复杂的计算，比如绘制图形所用的几何运算。关于GPU可以参考这下面这个视频）。 有些着色器允许开发者自己配置，用我们自己写的着色器替换默认存在的。这样我们就可以更细致地控制输送管道的特定部分了。因为它们运行在GPU上，所以会节约宝贵的CPU时间。着色器是用OpenGL着色器语言GLSL（OpenGL Shading Language）写的。 图形输送管道的每个阶段如下（蓝色部分代表的是我们可以自定义的着色器）：如你所见，图形输送管道包含很多部分，从最初的顶点数据转变为最终的有色像素。 现在我们用数组的形式传递3个3D坐标作为图形输送管道的输入，它们用来表示一个三角形，这个数组叫做这个三角形的顶点数据（Vertex Data）。除此之外，简单的顶点数据还通常包括顶点的颜色值。 【注】： 为了让OpenGL知道我们的坐标和颜色值到底构成了什么，OpenGL需要我们去给出提示，希望这些数据所表示的是什么类型，是一些列的点？一些列的三角形？还是一条线？做出的这些提示叫做基本图形（primitives）。任何一个绘制命令的调用都必须把基本图形类型传递给OpenGL。这是基本图形类型中的几个：GL_POINTS（点）、GL_TRIANGLES（三角形）、GL_LINE_STRIP（连续折线）。 下面简单介绍一下图形输送管道的每个部分： 顶点着色器（vertex shader）阶段把一个单独的顶点作为输入。主要目的是把3D坐标转换为另一种3D坐标（后续文章会与解释），同时允许我们队顶点属性进行一些基本处理。顶点着色器阶段会把表示基本图形的所有顶点输出到基本图形组装阶段，作为它的输入。 基本图形组装（primitive assembly）阶段把所有输入的点作组装为特定的基本图形的形状（本文例子是一个三角形）。基本图形组装阶段的输出会传递给几何着色器。 几何着色器（geometry shader）可以通过产生新顶点构造出新的（或是其他的）基本图形，来生成其他形状。 细分着色器（tessellation shader）可以把给定的基本图形细分成更多小基本图形。这样我们就能在物体更接近玩家的时候通过创建更多的三角形，用这种方式创建出更平滑的视觉效果。 像素化（rasterization，也叫光栅化） 阶段会把基本图形映射为屏幕上相应的像素，生成供像素着色器使用的fragment。并且在像素着色器允许之前，会执行裁剪（clipping）。裁剪会丢弃超出视图以外的那些像素，来提升执行效率。 【注】： OpenGL中的一个fragment是OpenGL渲染一个独立像素所需的所有数据。其实就是带有一些额外信息的像素，由于带有额外信息，OpenGL就没有给它取名叫像素。 像素着色器的主要目的是计算一个像素的最终颜色，这也是OpenGL高级效果最终产生的地方。通常，像素着色器包含用来计算像素最终颜色的3D场景的一些数据（比如关照、阴影、关的颜色等等）。在所有颜色值确定后，最终它会传到下一个alpha测试和混合（blending）阶段。 alpha测试和混合阶段检测像素的深度值和stencil值，来检查一个像素是否被遮挡了，从而做出取舍（即如果被遮住了就不画这个像素了）。还会查看alpha值（透明度）和物体之间的混合。所以即使在像素着色器中计算出来了一个像素将要输出的颜色，最后的像素颜色在渲染多个三角形的时候也可能会再发生变化，因为有遮挡和alpha混合存在。 应该说这个图形输送管道还是挺复杂的，包含很多要配置的部分。但是大多数场合，我们必须做的只是顶点和像素着色器。几何着色器和细分着色器是可选的，通常使用默认的着色器就行了。&nbsp; 在开始绘制之前，我们必须给OpenGL输入一些顶点数据。 顶点输入OpenGL是一个3D图形库，所以我们在OpenGL中指定的坐标都是3D的，即包括x、y、z坐标。因为我们想要渲染一个三角形，所以我们需要指定三角形的3个顶点的3D坐标。为了简单起见，这里我们直接使用标准化设备坐标（x、y、z都在-1到1之间），存储在GLfloat数组中：123456//三角形顶点坐标GLfloat vertices[] = &#123; -0.5f,-0.5f,0.0f, 0.5f,-0.5f,0.0f, 0.0f,0.5f,0.0f&#125;; 由于我们要画的是一个2D的三角形，所以就把3个顶点的z坐标都设为0了，即每个顶点的深度（depth）都是一样的，看上去就像是2D的。 【注】： 标准化设备坐标会通过glViewport函数提供的数据，进行视口变换，最后转换为屏幕空间坐标。这通常都是在顶点着色器中进行的，这些屏幕空间坐标最终会作为像素属性输入到像素着色器。 现在有了这样的顶点数据，我们需要把它输入发送给GPU，从而进入顶点着色器阶段。 在发送顶点数据之间，我们需要建立一个顶点数组对象VAO（vertex array object），用于记录顶点数据的存储和如何使用的细节信息。后面我们会告示OpenGL这些顶点数据是怎么存储的以及GPU应该怎么读出来，当我们需要用相同的顶点数据画多个三角形时，就不用每次都去指定这些顶点数据的存储方式和使用方式了，很节省效率：123//生成顶点数组对象VAO，记录数据的存储和如何使用的细节信息GLuint VAO; glGenVertexArrays(1, &amp;VAO); 由于CPU把数据发送到显卡相对较慢，但是GPU中顶点着色器却能很快获得顶点。如果从CPU一个顶点一个顶点地发送到显卡，无疑会造成GPU等待，浪费资源。所以我们希望把多个顶点数据一起从CPU发送到显存，这里我们使用顶点缓存对象VBO（vertex buffer object）来实际负责这些顶点数据的存储（包括存储空间和存储过程），它会在GPU内存上存储大批顶点：123//生顶点缓冲对象VBO，负责实际数据的存储GLuint VBO;glGenBuffers(1, &amp;VBO); 正如《OpenGL1：OpenGL概述及环境配置》一文里“OpenGL中的对象”中所诉，接下来要做的就是给顶点数组对象绑定目标（顶点数组）：12//给顶点数组对象绑定目标(顶点数组，不需要参数)glBindVertexArray(VAO); 再给顶点缓冲对象绑定目标（数组内存）：12//给顶点缓冲对象绑定目标（数组内存）glBindBuffer(GL_ARRAY_BUFFER, VBO); 已经在显卡上开辟好存储这些顶点的空间了，接下来我们需要顶点数据复制到显存缓冲中：12//把顶点数据复制到显卡的缓冲内存中glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW); glBufferData函数用来把用户定义的数据复制到当前绑定缓冲里。它的第一个参数是我们希望复制到上面的缓冲类型，这里是数组缓冲这种类型GL_ARRAY_BUFFER；第二个参数是我们希望传递给缓冲的数据大小（字节）；第三个参数是我们希望发送的真实数据；第四个参数指定了我们希望显卡如何管理给定的数据，有三种形式： GL_STATIC_DRAW：数据不会或几乎不会改变。 GL_DYNAMIC_DRAW：数据会被改变很多。 GL_STREAM_DRAW：数据每次绘制时都会改变 我们要画的三角形的位置数据不会改变，每次渲染调用时都保持原样，所以它使用的类型最好是GL_STATIC_DRAW。如果一个缓冲中的数据将频繁被改变，那么使用的类型就是GL_DYNAMIC_DRAW或GL_STREAM_DRAW，因为这样能确保图形卡把数据放在高速写入的内存部分。&nbsp; 告诉OpenGL如何读取顶点数据到现在我们只是把一堆顶点数据放到了显存的缓冲区中了，但是显卡并不知道这些顶点数据是怎么存放的，该连续多少个字节的数据才表示一个顶点坐标？不知道这些信息就无法用OpenGL函数一个一个地分开读出顶点数据。 下面我们使用 glVertexAttribPointer函数来告知OpenGL如何识别解析显存缓冲中的顶点数据：12//告诉OpenGL如何识别显存中的顶点数据glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(GLfloat), (GLvoid*)0); 它的第一个参数指定我们要配置哪一个顶点属性。因为我们在后面的顶点着色器中使用了layout (location=0)来定义顶点属性的位置值为0，所以这里要把这个参数设为0。 第二个参数指定每个属性数据由几个分量组成。因为在本例中，顶点着色器中就一个坐标属性，由3个float组成，所以这个参数设为3（这个参数的值只能是1、2、3、4中的一个）。 第三个参数指定属性分量的数据类型。由于本例中每个顶点位置由3个float组成，所以该参数设为float。 第四个参数指定是否希望数据被规格化。如果设置为GL_TRUE，所有有符号型数据会被映射到-1到1之间，无符号型数据会被映射到0到1之间。这里我们把它设为GL_FLASE。 第五个参数叫做步长，表示相同属性每隔多少字节出现一次。当顶点属性紧密排列时，可以填0，由OpenGL代替我们计算出该值。本例中每隔3*sizeof(GLfloat)字节属性就会重复出现了，即又是x、y、z了。 最后一个参数表示当前绑定到GL_ARRAY_BUFFER缓冲对象的缓冲区中，顶点对应属性的第一个分量距离缓冲起点的偏移量，以字节为单位计算。因为最后一个参数的类型是GLvoid*，而我们的顶点数据就是从数据起点开始的，所以这里设为（GLvoid*）0。 现在已经告诉OpenGL应该怎么从缓冲中解析顶点数据了，接着需要使用glEnableVertexAttribArray函数打开顶点属性数组，让这些顶点数据可以用于渲染图形。12//打开顶点属性数组glEnableVertexAttribArray(0); 当然，最后不要忘了解绑VBO和VAO。解绑了之后才能让它们脱离具体的目标，从而再去复用，绑定别的目标：1234//解绑VBOglBindBuffer(GL_ARRAY_BUFFER, 0);//解绑VAOglBindVertexArray(0); &nbsp; 顶点着色器源码顶点着色器是几个着色器中的一个，它是可编程的。现代OpenGL需要我们至少设置一个顶点着色器和一个像素着色器。 我们需要做的第一件事是用着色器语言GLSL写顶点着色器，然后编译这个着色器，这样我们就可以在接下来的程序中使用这个顶点着色器了。下面是一个非常基础的顶点着色器源码：1234567//顶点着色器const GLchar* vertexShaderSource = "#version 330 core\n" "layout (location=0) in vec3 position;\n" "void main()&#123;\n" "gl_Position=vec4(position.x,position.y,position.z,1.0);\n" "&#125;\0"; 在引号中的就是我们的顶点着色器源码，现在把它存储在一个字符串中，方便后面用着色器名字直接使用着色器。每个着色器都起始于一个版本声明，这是因为要让高版本的GLSL和OpenGL相匹配（GLSL330对应OpenGL3.3）。我们同样在后面显示地表示我们会用core profile功能。 然后就是在顶点着色器中使用in关键字声明所有的输入属性。因为现在我们只关心位置数据（position），所以我们使用in vec3 position，同时需要指定属性的索引，即layout (location = 0)，何在一起就是layout (location=0) in vec3 position;。 接下来在着色器的main函数（注意是着色器的main函数）中，我们设置顶点着色器的输出，gl_Position为内置变量（以gl前缀开头的变量一般都表示内置变量），表示顶点输出位置。我们必须把输入的位置数据赋值给预定义的gl_Position（该变量是vec4类型）：123void main()&#123; gl_Position = vec4(position.x, position.y, position.z, 1.0);&#125; gl_Position会作为顶点着色器的输出发送到图形输送管道的下一阶段。在后续文章会解释vec4的第4个参数为什么是1.0f。 【注】： 向量：在GLSL中一个向量最多可以有4个元素：x、y、z、w。但是z元素不是用作表达空间位置的，而是用在透视除法上。后续文章会介绍到。 这个顶点着色器应该是能想到的最简单的了，因为我们直接输入的就是标准化设备坐标，在顶点着色器里面什么都没有处理就把输入数据输出了。但是在真是应用里输入数据通常都没有在标准化设备坐标中，所以在顶点着色器中通常都需要把它们转化为标准化设备坐标，放进OpenGL的可视区域内。&nbsp; 编译着色器上面我们已经写了一个顶点着色器源码，但是为了让OpenGL能够使用它，我们必须在运行时动态编译它的源码。 通常的流程都是：创建着色器对象 → 把着色器源码附加到着色器对象 → 编译着色器 → 检测编译是否成功。 创建着色器对象使用glCreateShader函数创建着色器，参数是着色器类型：12//创建顶点着色器对象GLuint vertexShader = glCreateShader(GL_VERTEX_SHADER); 附加着色器源码到着色器对象使用glShaderSource函数把着色器源码添加到新创建的着色器对象上：12//把着色器源码附加到着色器对象glShaderSource(vertexShader, 1, &amp;vertexShaderSource, NULL); 第一个参数是着色器对象；第二个参数指定了源码中有多少个字符串，这里只有一个；第三个参数是顶点着色器真正的源码；第四个参数可以设置为NULL，表示每个字符串都没有终止，直到遇到’\0’。 编译着色器使用glCompileShader函数来编译着色器，参数是着色器对象：12//编译顶点着色器glCompileShader(vertexShader); 检测编译是否成功12345678//检测编译是否成功GLint success; //编译结果GLchar infoLog[512]; //错误信息glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success);if (!success) &#123; glGetShaderInfoLog(vertexShader, 512, NULL, infoLog); std::cout &lt;&lt; "ERROR::SHADER::VERTEX::COMPILATION_FAILED\n" &lt;&lt; infoLog &lt;&lt; std::endl;&#125; 首先定义一个整型success来表示是否成功编译，还需要一个存储错误消息的容器infoLog（如果有错误的话），然后用glGetShaderiv函数来检查是否编译成功了。如果编译失败，用glGetShaderInfoLog函数来获取错误信息，然后打印它。 函数glGetShaderInfoLog的第一个参数是编译失败的着色器，第二个参数是存储错误信息的数组大小，第三个参数是返回的错误信息字符串的长度，如果不需要可以为NULL，第四个参数是存储错误信息的字符数组。&nbsp; 像素着色器源码像素着色器是最终我们打算创建的用于渲染三角形的着色器。像素着色器的全部，都是用来计算像素的最后颜色输出。为了简单点，我们的像素着色器只输出橘黄色（每个颜色的强度都是在0到1之间的浮点数，三种颜色可以调配处1600万中不同颜色，颜色值的第4个参数表示alpha透明度）：1234567//像素着色器const GLchar* fragmentShaderSource = "#version 330 core\n" "out vec4 color;\n" "void main()&#123;\n" "color=vec4(1.0,0.5f,0.2f,1.0f);\n" "&#125;\0"; 像素着色器只需要一个输出变量，这个变量是一个表示最终输出颜色的vec4向量。可以用out关键字来声明输出变量，命名为color，即out vec4 color;。然后在像素着色器的main函数中给输出变量color指定橘黄色，透明度为1（不透明），即color = vec4(1.0f, 0.5f, 0.2f, 1.0f);。&nbsp; 编译像素着色器编译像素着色器的过程与顶点着色器一致，如下：123456789101112//创建像素着色器对象 GLuint fragmentShader = glCreateShader(GL_FRAGMENT_SHADER); //把像素着色器源码附加到像素着色器对象 glShaderSource(fragmentShader, 1, &amp;fragmentShaderSource, NULL); //编译像素着色器源码 glCompileShader(fragmentShader); //检测是否编译成功 glGetShaderiv(fragmentShader, GL_COMPILE_STATUS, &amp;success); if (!success) &#123; glGetShaderInfoLog(fragmentShader, 512, NULL, infoLog); std::cout &lt;&lt; "ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\n" &lt;&lt; infoLog &lt;&lt; std::endl; &#125; &nbsp; 顶点着色器和像素着色器都已经编译了，剩下的事情就是把两个着色器对象链接到一个着色器程序中，它是用来渲染的。 着色器程序着色器程序对象（shader program object）是多个着色器最后链接的版本。如果要使用刚才编译好的着色器我们必须把它们链接为一个着色器程序对象，然后当渲染物体的时候激活这个着色器程序，才能进行利用着色器进行渲染。 把着色器链接为一个程序就等于把每个着色器的输出链接到下一个着色器的输入。当然，如果你的输出和输入不匹配，那么将得到一个链接错误。 创建着色器程序对象首先需要使用glCreateShader函数创建着色器程序对象：12//创建着色器程序对象GLuint shaderProgram = glCreateProgram(); 附加链接然后需要把着色器附加到着色器程序对象上，然后链接起来：1234//把着色器附加到着色器程序对象上，然后链接起来glAttachShader(shaderProgram, vertexShader);glAttachShader(shaderProgram, fragmentShader);glLinkProgram(shaderProgram); 检测是否链接成功接下来是需要检测一下链接是否成功，和检测是否成功编译类似：123456//检查是否链接成功glGetProgramiv(shaderProgram, GL_LINK_STATUS, &amp;success);if (!success) &#123; glGetProgramInfoLog(shaderProgram, 512, NULL, infoLog); std::cout &lt;&lt; "ERROR::PROGRAM::LINKING_FAILED\n" &lt;&lt; std::endl;&#125; 删除着色器对象最后是删除着色器对象，因为它们已经被成功链接到着色器程序对象了，不再需要着色器对象了，应该释放它们：123//删除着色器对象glDeleteShader(vertexShader);glDeleteShader(fragmentShader); &nbsp; 在游戏循环中渲染三角形在顶点输入、顶点着色器、像素着色器、着色器程序对象等过程都完成后，迎来了最终的三角形渲染。 OpenGL的glDrawArrays函数为我们提供了绘制物体的能力，它使用当前激活的着色器、前面定义的顶点属性和顶点数组对象VAO来绘制基本图形。 所以我们需要先激活着色器程序对象，再绑定VAO完成顶点输入初始化，接着使用glDrawArrays函数来画三角形，最后解绑VAO：12345678//激活着色器程序对象 glUseProgram(shaderProgram); //绑定VAO，完成顶点输入初始化 glBindVertexArray(VAO); //绘图 glDrawArrays(GL_TRIANGLES, 0, 3); //解绑VAO glBindVertexArray(0); glDrawArrays函数的第一个参数是我们打算绘制的OpenGL基本图形的类型，这里是三角形GL_TRIANGLES；第二个参数是我们打算绘制的那个顶点数组的起始位置的索引；最后一个参数是我们打算绘制多少个顶点。 当然，在退出渲染后，不要忘了清除掉顶点数组对象VAO和顶点缓冲对象VBO：123//删除VAO、VBOglDeleteVertexArrays(1, &amp;VAO);glDeleteBuffers(1, &amp;VBO); &nbsp; 到此为止，我们已经完成了一个三角形的绘制，全部源码在这里。编译运行后的结果如下：&nbsp; 下面我们再来看一个，画矩形该怎么画？我们可以绘制两个三角形来组成一个矩形，事实上OpenGL主要就是绘制三角形，我们看到的很多复杂图形，包括3D图形，都是很多个小的三角形拼凑起来的。 画两个三角形的时候，如果直接用顶点去画，将需要2个三角形6个顶点：12345678910GLfloat vertices[] = &#123; // 第一个三角形 0.5f, 0.5f, 0.0f, // 右上角 0.5f, -0.5f, 0.0f, // 右下角 -0.5f, 0.5f, 0.0f, // 左上角 // 第二个三角形 0.5f, -0.5f, 0.0f, // 右下角 -0.5f, -0.5f, 0.0f, // 左下角 -0.5f, 0.5f, 0.0f // 左上角&#125;; 但是这两个三角形其实有两个顶点是重合的，指定了右下角和左上角的顶点两次！一个矩形应该只有4个顶点而不是6个，这样就产生了50%的额外开销。如果我们有一个模型是大量的三角形拼凑起来的，这将会产生更大的浪费。最好的解决方案当然是每个顶点只存储一次，而在绘制的时候只需要指定打算绘制的那个顶点的索引就可以了。&nbsp; 用索引缓冲对象绘制矩形恰巧的是，OpenGL提供了用索引缓冲进行绘制的工作方式。用索引缓冲对象EBO（elements buffer object）是一个像VBO一样的缓冲，专门存储索引，OpenGL调用这些顶点的索引来绘制。 索引数组首先我们需要定义一个浮点型数组，来存储矩形的四个顶点坐标；再定义一个整型数组，来存储组成矩形的两个三角形的顶点索引：123456789101112//三角形顶点坐标GLfloat vertices[] = &#123; 0.5f,0.5f,0.0f, 0.5f,-0.5f,0.0f, -0.5f,-0.5f,0.0f, -0.5f,0.5f,0.0f&#125;;//顶点索引GLuint indices[] = &#123; 0,1,3, //第一个三角形 1,2,3 //第二个三角形&#125;; 索引缓冲对象接下来就是在主函数中生成索引缓冲对象EBO，负责索引数据的存储：123//生成索引缓冲对象EBO，负责索引数据的存储GLuint EBO;glGenBuffers(1, &amp;EBO); 和VBO一样，接着需要给EBO绑定目标：索引数组内存：12//给索引缓冲对象绑定目标（索引数组缓冲）glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO); 然后就是把索引数据复制到显卡的索引数组缓冲中了：12//把索引数据复制到显卡的缓冲内存中glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW); 【注】： 对EBO的操作还是应该在VAO绑定和解绑之间的，因为需要让VAO记录下来EBO的存储过程和细节。这样在用索引进行绘制时，还是只需要绑定VAO即可，不用再去对EBO进行一些列的绑定、复制数据等操作。 更改绘制方式因为现在是改用索引缓冲进行渲染了，所以需要把glDrawArrays函数改为glDrawElements函数：12//绘图glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0); 第一个参数指定了绘制模式；第二个参数是我们打算绘制的顶点数；第三个参数是索引的类型；最后一个参数指定索引被存储的位置（或者说是起始索引在EBO中的偏移量；如果没有使用EBO但是还想使用索引进行绘制，这里可以传递一个索引数组）。 渲染后删除EBO当然，绘制完后不要忘了删除索引缓冲对象EBO：1glDeleteBuffers(1, &amp;EBO); &nbsp; 到此，我们已经绘制了一个由两个三角形组成的矩形，全部源码在这里。编译运行后的结果如下：&nbsp; 参考文献：LearnOpenGL]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>着色器画三角形</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenGL2：创建一个窗口]]></title>
    <url>%2F2016%2F11%2F16%2FOpenGL2%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AA%97%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[在上一篇《OpenGL1：OpenGL概述及环境配置》中，已经说过接下来的OpenGL项目，我们将使用GLFW和GLEW相结合的方式。 头文件既然要使用GLFW和GLEW中的函数，那在我们的源文件里肯定要包含它俩的头文件：12345//GLEW#define GLEW_STATIC#include&lt;GL/glew.h&gt;//GLFW#include&lt;GLFW/glfw3.h&gt; 初始化并配置GLFW加入了头文件还不够，接下来还需要在main函数中初始化并配置GLFW：12345678910int main() &#123; //初始化GLFW glfwInit(); //GLFW配置 glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); //主版本号 glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); //次版本号 glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE); // 核心开发模式 glfwWindowHint(GLFW_RESIZABLE, GL_FALSE); //窗口尺寸不可变 return 0;&#125; 在main函数中我们首先使用glfwInit来初始化GLFW，然后可以使用glfwWindowHint来配置GLFW。glfwWindowHint的第一个参数是将要配置的选项，可以从一个枚举中选择可用的选项，这些选项带有GLFW_前缀；第二个参数是一个整数，代表我们为选项所设置的值。可用的选项和对应的值可以在GLFW文档中找到。 因为我用的是OpenGL3.3版本，所以把主版本和次版本都设为3，这会保证如果一个用户没有特定的OpenGL版本，GLFW就会运行失败。开发模式我们尽量用core-proflie核心模式，而且要求用户不可以调整窗口大小。显式地告诉GLFW我们希望是用core-profile，如果我们调用了一个OpenGL的遗留函数将会产生invalid operation错误，当我们意外地使用了不该使用的旧函数时它是一个很好的提醒。&nbsp; 创建窗口对象接下来就是创建窗口对象，有了这个窗口对象后，很多GLFW函数才会有意义：1234567//创建能够使用GLFW函数的窗口对象（指针） GLFWwindow* window = glfwCreateWindow(800, 600, "LearnOpenGL", nullptr, nullptr); if (window == NULL) &#123; std::cout &lt;&lt; "Failed to create GLFW window" &lt;&lt; std::endl; glfwTerminate(); return -1; &#125; 函数glfwCreateWIndow需要窗口的宽度和高度作为它的头两个参数，第三个参数是窗口的名字，后两个参数（显示器、共享资源）可以忽略。该函数返回已创建的FLFWwindow对象的指针，在后面的其他GLFW操作会需要它。&nbsp; 设置窗口环境因为每一个窗口都必须有OpenGL或者OpenGL ES的上下文（环境），如果不给窗口指定环境，将会产生GLFW_NO_WINDIW_CONTEXT错误。这里我们使用glfwMakeContextCurrent函数指定窗口环境是当前线程的主环境：12//创建窗口环境glfwMakeContextCurrent(window); &nbsp; 初始化GLEW后面要做的就是用OpenGL函数进行渲染了。不过在之前的文章里，我们已经知道GLEW管理着OpenGL的函数指针，所以需要在调用任何OpenGL函数之前初始化GLEW：123456//初始化GLEWglewExperimental = GL_TRUE; //保证使用现代技术管理OpenGL机能if (glewInit() != GLEW_OK) &#123; std::cout &lt;&lt; "Failed to initialize GLEW" &lt;&lt; std::endl; return -1;&#125; 注意，在初始化GLEW前我们把glewExperimental变量设置为GL_TRUE。这样可以保证GLEW使用更多的现代技术来管理OpenGL机能。如果不这么设置，它就会使用默认的GL_FALSE，这样当使用core profile时有可能会出问题。&nbsp; 设置渲染窗口在开始渲染前，需要告诉OpenGL渲染窗口的大小和位置：12//设置渲染窗口位置大小glViewport(0, 0, 800, 600); 前两个参数设置了渲染窗口的左下角位置，后两个参数是渲染窗口的宽度和高度。这里指定的是和GLFW窗口是一样大的。不过我们可以吧这个渲染窗口设置得比GLFW窗口尺寸小，这样OpenGL的渲染都会在一个更小的窗口（区域）进行显示，我们可以在OpenGL的渲染窗口viewport之外显示其他的元素。 【注】： OpenGL中处理的坐标其实是在-1到1之间，原点在显示区域正中间，比如一个被加工的点位置是（-0.5,0.5）（标准化设备坐标），通过glViewport后会把这种2D坐标映射为屏幕上的坐标（200,450）。&nbsp; 渲染循环（游戏循环）因为我们不希望程序在会在一个图像之后立即退出，然后关闭窗口，这会造成渲染的结果在屏幕上一闪而过。我们想让程序持续地绘制图像，监听用户输入知道程序被明确告知停止。为了达到这个目的，我们必须建立一个while循环，每次while循环都重新绘制（渲染）一次，直到被告知结束渲染。由于程序始终处于while循环，不会自动退出（除非循环条件不满足，即被告知结束渲染），所以渲染结果也会一直于窗口上，不会一闪而过。下面的代码是一个非常简单的游戏循环（渲染循环）：12345//渲染循环（游戏循环）while (!glfwWindowShouldClose(window)) &#123; glfwPollEvents(); //检测是否有事件被触发（按键按下、鼠标移动） glfwSwapBuffers(window); //交换屏幕缓存&#125; glfwWindowShouldClose函数从开始便检验每一次循环迭代中GLFW窗口是否已经得到关闭提示。如果得到这样的提示，函数就会返回true，导致游戏循环终止。 glfwPollEvents函数检验是否有任何时间被触发（比如键盘输入、鼠标移动等事件），如果有就可以调用相应函数进行处理（可以通过回调函数进行设置）。而且经常都是在循环迭代前调用事件处理函数。 glfwSwapBuffers函数会交换颜色缓冲（颜色缓冲是一个GLFW窗口为每一个像素存储颜色数值的大缓存，它是在这次迭代中绘制的，也作为输出显示在屏幕上）。 【注】： 双缓冲（Double Buffer）：当一个应用以单缓冲方式绘制的时候，图像可能会产生闪烁的问题。这是因为最后的图像输出不是被立即绘制出来的，而是一个像素一个像素绘制出来的，通常是以从左到右从上到下这样的方式。由于这些图像不是立即呈现在用户面前，而是一步一步地生成结果，这就会产生很多不真实感。为了规避这些问题，窗口应用使用双缓冲的方式进行渲染。前缓冲包含最终的输出图像，它被显示在屏幕上，与此同时，所有的渲染命令绘制后缓冲。所有的渲染命令执行结束后，我们就把后缓冲交换到前缓冲，这样图像就会立即显示到用户面前了，前面提到的闪烁问题就被解决了。&nbsp; 渲染我们需要把所有的渲染命令都放在渲染循环里，因为我们打算每个循环迭代都执行所有的渲染命令。通常把渲染命令放在检查事件和交换缓冲之间：123456//渲染循环（游戏循环）while (!glfwWindowShouldClose(window)) &#123; glfwPollEvents(); //检测是否有事件被触发（按键按下、鼠标移动） ... //这里是渲染命令 glfwSwapBuffers(window); //交换屏幕缓存&#125; 这里我们使用一个最简单的渲染命令：用指定的颜色清空屏幕。因为每个渲染迭代开始时，我们都需要清理屏幕，否则只能一直看到前一个迭代的结果：12glClearColor(0.2f, 0.3f, 0.3f, 1.0f);glClear(GL_COLOR_BUFFER_BIT); 使用glClearColor函数来设置清空屏幕用的颜色。使用glClear函数清理屏幕的颜色缓冲，在这个函数中我们以缓冲位（BUFFER_BIT）指定我们希望清理哪个缓冲。可以用的位可以是GL_COLOR_BUFFER_BIT、GL_DEPTH_BUFFER_BIT和GL_STENCIL_BUFFER_BIT。因为我们现在关心的只是颜色值，所以我们只清空颜色缓冲。&nbsp; 响应输入之前的while循环是会一直运行下去的，因为没有被告知停止循环。现在我们希望在GLFW中有些控制输入的方式，当用户按下某个按键后结束渲染循环。我们可以使用GLFW的回调函数做到这点。其中有一个GLFW回调函数是KeyCallback函数，它在用户使用键盘交互的时候会被GLFW自动调用。该回调函数的原型是：1void (* GLFWkeyfun)(GLFWwindow* window, int key, int scancode, int action, int mode); 按键输入回调函数的参数是一个GLFWwindow对象指针，一个代表按下按键的整型数字，按键扫描码，一个表示按键是被按下、释放还是按住的整型数字，一个代表某个标识的整数告诉你shift、control、alt或super按键是否被同时按下。每当用户按下一个按钮，GLFW都会自动调用这个函数，为该函数填充合适的参数。我们给这个按键输入回调函数随便起个名字吧，叫key_callback：12345void key_callback(GLFWwindow* window,int key,int scancode,int action,int mode) &#123; if (key == GLFW_KEY_ESCAPE&amp;&amp;action == GLFW_PRESS) &#123; glfwSetWindowShouldClose(window, GL_TRUE); &#125;&#125; 在我们（新创建）的key_callback函数中，我们检查被按下的按键是否是ESC键，如果是的话，就用glfwSetWindowShouldClose设置它的WindowShouldClose属性为true来关闭GLFW窗口。下一个主while循环条件不满足，则渲染循环就结束了。 还有最后一点，在使用回调函数之前，是需要先注册的，也就是得给我们的这个按键回调函数声明一下并起个名字：12//注册回调函数glfwSetKeyCallback(window, key_callback); 【注】： 除了按键回调函数外，还有许多GLFW回调函数可供于给注册我们自己的函数。 要在创建窗口之后，渲染循环之前注册回调函数。 &nbsp; 释放资源退出渲染循环后，在程序结束之前，应该释放掉由GLFW分配的资源。使用glfwTerminate函数来完成：12//结束CLFW，释放由GLFW分配的资源glfwTerminate(); 这样会清理所有资源，并正确地退出程序。&nbsp; 到此为止的所有源码在这里。编译运行后的结果是一个黑蓝绿色的窗口：按下esc键后，窗口关闭程序结束退出。&nbsp; 参考文献：LearnOpenGL]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>OpenGL窗口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[添加数学公式mathjax]]></title>
    <url>%2F2016%2F11%2F10%2F%E6%B7%BB%E5%8A%A0%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fmathjax%2F</url>
    <content type="text"><![CDATA[配置方法 在Hexo\themes\transparent\layout_partial路径下新建文件mathjax.ejs（transparent是我的主题名）。打开文件写入如下代码： 123456789101112131415161718192021222324252627282930 &lt;!-- mathjax config similar to math.stackexchange --&gt; &lt;script type="text/x-mathjax-config"&gt; MathJax.Hub.Config(&#123; tex2jax: &#123; inlineMath: [ ['$','$'], ["\\(","\\)"] ], processEscapes: true &#125; &#125;); &lt;/script&gt; &lt;script type="text/x-mathjax-config"&gt; MathJax.Hub.Config(&#123; tex2jax: &#123; skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'] &#125; &#125;); &lt;/script&gt; &lt;script type="text/x-mathjax-config"&gt; MathJax.Hub.Queue(function() &#123; var all = MathJax.Hub.getAllJax(), i; for(i=0; i &lt; all.length; i += 1) &#123; all[i].SourceElement().parentNode.className += ' has-jax'; &#125; &#125;); &lt;/script&gt; &lt;script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"&gt;&lt;/script&gt; 打开iHexo\themes\transparent\layout_partial目录下的after_footer.ejs文件，在末尾写入如下代码： 1&lt;%- partial('mathjax') %&gt; 新建一片md文章（hexo new &quot;新文章&quot;），写入如下代码： 12## 公式$$J\_\alpha(x)=\sum _&#123;m=0&#125;^\infty \frac&#123;(-1)^ m&#125;&#123;m! \, \Gamma (m + \alpha + 1)&#125;&#123;\left(&#123;\frac&#123;x&#125;&#123;2&#125;&#125;\right)&#125;^&#123;2 m + \alpha &#125;$$ 部署完后，打开自己的网站查看公式是否成功显示。我的显示效果如下： 关于mathjax的更多介绍和语法参见《Mathjax简介及其语法》。]]></content>
  </entry>
  <entry>
    <title><![CDATA[基本光栅图形生成技术]]></title>
    <url>%2F2016%2F11%2F06%2F%E5%9F%BA%E6%9C%AC%E5%85%89%E6%A0%85%E5%9B%BE%E5%BD%A2%E7%94%9F%E4%BA%A7%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[先来回顾一下图形显示的过程。&nbsp; 图形显示的过程可以看到，视频控制器是从帧缓存中读出数据不为0的单元进行显示。但是，正如图中所示，对于三角形，我们一般存储的都只是三个顶点的坐标，那么怎么根据这三个顶点的坐标得到对应的帧缓存数据呢？其实这就是图形的生成过程，从参数形式转换为点阵形式，便于光栅扫描生成相应的图形（参数形式和点阵形式可参考《图形学概述》一文中的计算机图形表示方法）。 由参数形式到点阵形式的转换就称为扫描转换。&nbsp; 从上面可以看到，图形信息是存储在帧缓存中的，其实光栅图形显示的缓存机制并不是图示的那样简单。下面来看一下： 光栅图形生成时的缓存机制 单缓存：其实光栅图形显示时的帧缓存采用两种方式：单缓存、双缓存。采用单缓存时，是在帧缓存填满之后，再由视频控制器驱动电子枪扫描形成一幅图形，接着才能再去生成下一幅图形的帧缓存（否则会覆盖破环图形数据）。这样帧缓存数据（图形点阵形式）的生成和在屏幕上扫描显示图形就是串行的。这样会降低图形的显示速率。 双缓存：现在大多采用的是双缓存，即有两个帧缓存，一幅图形在帧缓存2生成点阵数据后，再交给帧缓存1，视频控制器就可以根据帧缓存1来驱动电子枪扫描形成图形。与此同时，下一幅图形就可以在帧缓存2中再生成点阵数据。这样一来，不会覆盖破环要显示的图形数据（因为它已经转储到帧缓存1了），达到了帧缓存图形数据生成和在屏幕上扫描显示图形并行的效果。大大提高了图形显示的速率。 如下图所示：&nbsp; 下面我们先来看个简单的：直线段是怎么通过扫描转换画出来的？ 扫描转换线画图元直线段我们知道，屏幕上其实是一个一个的像素，如下图所示：想要让像素全部恰好落在直线上是很难的，我们只能去选择距离直线最近的像素点，然后用它们来近似地画出直线段（像素点是很小的，稍微不在直线上一点，肉眼是看不出来的，所以我们看到的还是一条“很直”的直线段）。 那么我们扫描转换画直线段的方法是啥呢（假设我们要画的直线段宽度是一个像素点，斜率在[0,1]之间（即0~45度））？主要有三种方法：直线方程法、DDA、中点算法。都是为了一个一个地找出直线附近的像素点。 扫描转换直线段：直线方程法 基本思想：直接根据直线的几何方程确定直线段路径上的像素位置。x坐标的值从左端点x遍历到右端点x，对应y坐标通过直线方程算出来。描点时如果发现y坐标不是整数值，需要取为离它最近的整数（如3.4取为3，3.5取为4，程序上用了一个小技巧实现：(int)(y+0.5)）。 具体代码如下： 123456789101112131415//直线段的直线方程画法。直线方程式：y=mx+bvoid Equation(int x0,int y0,int x1,int y1,int red,int green,int blue)&#123; glBegin(GL_POINTS); glColor3ub(red,green,blue); //计算斜率m float m=float(y1-y0)/(x1-x0); //计算b float b=y0-m*x0; for(int x=x0;x&lt;=x1;x++)&#123; int y=m*x+b; glVertex2d(x,int(y+0.5)); &#125; glEnd();&#125; 用到的主要运算有：浮点运算、乘法、除法、取整、加法。 有计算机基础的朋友应该知道，乘除法、浮点运算的开销是很大的。画个线就这么惨，有没有开销小一点的方法呢？请看下面。 扫描转换直线段：数字差分分析法DDA（Digital Differential Analyzer）DDA算法不再直接按照直线方程求像素点，而是打上了直线斜率的主意。在直线方程法中，是根据每个点的横坐标，按直线方程求出对应的纵坐标。这是把直线上的每个点作离散处理的，忽略了直线上点的纵坐标其实是有联系的：相邻点的纵坐标正好差一个斜率。所以纵坐标不用根据方程求解了，直接从上一个点的纵坐标加一个斜率值即可。具体描述如下： 基本思想：纵坐标每次加一个斜率值。x坐标的值从左端点x遍历到右端点x，对应y坐标每次加一个斜率。描点时如果发现y坐标不是整数值，需要取为离它最近的整数（如3.4取为3，3.5取为4，程序上用了一个小技巧实现：(int)(y+0.5)）【注】：只是在描点的时候描在最近的整数点上，即(int)(y+0.5)，而不能把y值变为最近的整数值，即y=int(y+0.5)是不对的。因为每次描点都应该是在其纵坐标的真实值上，进行取整描点；如果是y=int(y+0.5)这样把纵坐标作了近似处理，那么下一个点加斜率值之后，算出来的纵坐标就不是它的真实纵坐标了。 具体代码如下： 12345678910111213//直线段的DDA画法。直线方程式：y=mx+bvoid LineDDA(int x0,int y0,int x1,int y1,int red,int green,int blue)&#123; glBegin(GL_POINTS); glColor3ub(red,green,blue); //计算斜率m float m=float(y1-y0)/(x1-x0); for(int x=x0,y=y0; x&lt;=x1; x++)&#123; glVertex2d(x,int(y+0.5)); //四舍五入取整 y+=m; &#125; glEnd();&#125; 用到的主要运算有：浮点运算、除法、加法、取整。 看出来了吧，DDA比直线方程法少了乘法运算，加快了画线速度，但是还不够好，因为还存在浮点运算和取整运算。想要更好的算法，请看下面。 扫描转换直线段：中点算法在DDA中还是存在对浮点数的取整运算，因为要描出在y方向上离直线最近的像素点。能不能不通过取整运算，直接知道哪个像素点在y方向上离直线最近呢？画个图找点灵感（直线段斜率0~45度）：图1和图2最左下角的黑点是当前已经确定的离直线最近的像素点。如果是图1这种情况，邻近的右上方（因为直线斜率0~45度）中点（图1的绿色点）在直线上方，则此时离直线最近的点应该是中点正下方的蓝色点；如果是图2这种情况，邻近的右上方中点（图2的绿色点）在直线下方，则此时离直线最近的点应该是中点正上方的蓝色点。 采用这种分类的方法（邻近的中点在直线上方还是下方），确实可以不再需要取整运算了，因为每种分类下应该取哪个整数点是确定的，通过简单的加法就能算出来（如果是图1的情况，则下一个应该描的像素点是x+1，y不变；如果是图2的情况，则下一个应该描的像素点是x+1，y+1）。问题又来了，怎么知道邻近的中点在直线上方还是下方呢？很简单，学过中学数学的朋友都知道，把中点坐标代入直线方程，如果算出来的结果0，则在直线上方。 but，把中点坐标代入直线方程？这不又要算浮点数乘法了嘛~~~。回顾在直线方程法中，之所以会出现乘法，是因为把直线上的点作离散处理的，忽略了各个点之间的联系。这里也是这个原因，因为这些中点坐标也是有联系的。如果是图1的情况，则下一个中点应该是图1中的黄色点（即相比上一个中点x+1，y不变）；如果是图2的情况，则下一个中点应该是图2中的黄色点（即相比上一个中点x+1，y+1）。直线方程是ax+by+c=0，设把中点坐标代入直线方程得到的表达式是：$d=F(M)=ax+by+c$。如果是图1的情况，因为下一个中点相比上一个中点x+1，y不变，代入直线方程很容易得到，下一个中点$d_{i+1}$和上一个中点$d_i$的联系是：$d_{i+1}=d_i+a$；如果是图2的情况，因为下一个中点相比上一个中点x+1、y+1，代入直线方程很容易得到，下一个中点$d_{i+1}$和上一个中点$d_i$的联系是：$d_{i+1}=d_i+a+b$。而图1的情况其实就是$d_{i+1} \le 0$，图2的情况其实就是$d_{i+1}\gt 0$，所以得到如下方程组：$$d_{i+1}=\begin{cases}d_i+a,&amp; d_i \gt 0 \\d_i+a+b,&amp; d_i \le 0 \\\end{cases}$$那么最初的$d_0$是多少呢？看看$d_0$的表达式$d_0=F(M)=F(x_0+1,y_0+0.5)=F(x_0,y_0)+a+0.5b$，因为点$(x_0,y_0)$在直线上，所以$d_0=a+0.5b$。但是这里又出现了浮点数0.5，能不能把它转化成整数？其实我们一直关注的都是d是大于0还是小于0，2d和d的正负性是一样的，所以我们可以给上诉方程组等号两边同时乘以2，把所有的系数都变成整数：$$\begin{array}{l}2d_0=2a+b \\2d_{i+1}=\begin{cases}2d_i+2a,&amp; 2d_i \gt 0 \\2d_i+2a+2b,&amp; 2d_i \le 0 \\\end{cases}\end{array}$$再把$2d_i$换成$x_i$，即$x_i=2d_i$。于是方程组变成如下：$$\begin{array}{l}x_0=2a+b \\x_{i+1}=\begin{cases}x_i+2a,&amp; x_i \gt 0 \\x_i+2a+2b,&amp; x_i \le 0 \\\end{cases}\end{array}$$既然可以换成$x_i$，那么当然也可以换成$d_i$啊！所以方程组还可以是下面这样：$$\begin{array}{l}d_0=2a+b \\d_{i+1}=\begin{cases}d_i+2a,&amp; d_i \gt 0 \\d_i+2a+2b,&amp; d_i \le 0 \\\end{cases}\end{array}$$而描点坐标的方程组也可以表示如下：$$\begin{array}{l}x_{i+1}=x_i+1 \\y_{i+1}=\begin{cases}y_i,&amp; d_i \gt 0 \\y_i+1,&amp; d_i \le 0 \\\end{cases}\end{array}$$【注】：参数表示下直线段两端点坐标为($x_0,y_0$)，($x_1,y_1$)。则ax+by+c=0中的$a=y_0-y_1$、$b=x_1-x_0$。且方程组中诸如2a是可以写成a+a的。 从上述方程组中可以看出中点算法下的直线段扫描转换就只剩下整数加法运算了，效率得到了很大的提升。 总结一下： 基本思想：中点算法中只存在整数加法运算。在分类情况下（下一格中点在直线上方还是下方），下一个像素点坐标可以直接通过上一个点坐标做加法得到；同时下一个中点代入方程值也可以在分类情况下，直接通过上一个中点代入方程值做加法得到。【注】：上面只是研究了直线斜率0~45度的情况，其实其它斜率也是同样的研究方法。不再赘述，结论如下： 具体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596//直线段的中点算法。直线方程ax+by+c=0void MidPointLine(int x0,int y0,int x1,int y1,int red,int green,int blue)&#123; glBegin(GL_POINTS); glColor3ub(red,green,blue); //初始化线段方程中的a、b int a=y0-y1; int b=x1-x0; //中点公式当中的d=d+dPlusPart1 int dPlusPart1; int dPlusPart2; int d; int y=y0; int x=x0; //计算斜率 float k=float(y1-y0)/(x1-x0); int type=0; if(k&gt;=0&amp;&amp;k&lt;=1) type=1; else if(k&gt;1) type=2; else if(k&gt;=-1&amp;&amp;k&lt;0) type=3; else type=4; switch(type)&#123; //斜率大于0小于1 case 1: dPlusPart1=a+a; dPlusPart2=a+a+b+b; d=a+a+b; for(;x&lt;x1;x++)&#123; glVertex2d(x,y); if(d&lt;0)&#123; y++; d+=dPlusPart2; &#125; else&#123; d+=dPlusPart1; &#125; &#125; break; //斜率大于1 case 2: d=a+b+b; dPlusPart1=a+a+b+b; dPlusPart2=b+b; for(;y&lt;y1;y++)&#123; glVertex2d(x,y); if(d&gt;0)&#123; x++; d+=dPlusPart1; &#125; else&#123; d+=dPlusPart2; &#125; &#125; break; //斜率大于-1小于0 case 3: d=a+a-b; dPlusPart1=a+a-b-b; dPlusPart2=a+a; for(;x&lt;x1;x++)&#123; glVertex2d(x,y); if(d&gt;0)&#123; y--; d+=dPlusPart1; &#125; else&#123; d+=dPlusPart2; &#125; &#125; break; //斜率小于-1 case 4: d=a-b-b; dPlusPart1=a+a-b-b; dPlusPart2=-b-b; for(;x&lt;x1;x++)&#123; glVertex2d(x,y); if(d&gt;0)&#123; y--; d+=dPlusPart1; &#125; else&#123; d+=dPlusPart2; &#125; &#125; break; default: break; &#125; glEnd();&#125; 用到的主要运算有：整数加法。 为了方便理解，举例如下： 再来看个稍微复杂点的：圆弧是怎么通过扫描转换画出来的？ 扫描转换线画图元圆弧扫描转换圆弧也是把圆弧的参数方程转换为一个一个的像素点。不过对于圆这种东西，已经对称得不能再对称了，不利用它的对称性不浪费嘛~-~。利用圆的对称性，我们只需要画出1/8圆弧（一般研究逆时针45~90度的圆弧）就可以了，剩下的7/8都可以通过x对称或y对称得到。既然说到了对称，那肯定是要把圆心放在原点才好对称啊！那如果要画的圆心不再原点怎么办？平移到原点呗（平移会在《图形几何变换》一文中讲到）。那如何扫描转换这段圆弧呢？主要有三种方法：方程法、中点算法、多边形逼近法。 扫描转换圆弧：方程法和直线扫描转换方程法原理一致，把(x,y)一个一个算出来。根据圆方程不同，大致分为以下两种方式： 这方法不说了，效率很着急！ 扫描转换圆弧：中点算法和直线段扫描转换的中点算法原理一致。先画个图找点思路：哪个点离圆弧最近呢？如果是图中黑色圆弧的情况，即中点M在圆弧外面，则M的竖直方向上，离圆弧最近的点是正下方的SE点；如果是图中红色圆弧的情况，即中点M在圆弧里面，则离圆弧最近的点是正上方的E点。而中点在圆弧外面其实就是中点代入圆方程值d大于0，中点在里面就是中点代入方程值d小于0。那么圆弧是不是和直线段一样，中点代入方程值d也可以由上一个值加一个常量得到呢？ 答案是当然的。看上图（圆方程：$x^2+y^2-R^2=0$）如果是红色圆弧的情况，那么下一个中点坐标x+1，y不变，即d增量是$2x_M+1$，但是这里$x_M$是中点的坐标，应该把它换算成圆弧上点的坐标（因为中点算法的目的就是避开中点坐标，并没有求出中点坐标具体是多少，而只是关注中点代入方程的结果值。也就是说在整个过程里中点坐标$(x_M,y_M)$是多少不得而知，所以就得把它换算成$x_i$，即上一个圆弧上点的坐标，这个我们是知道的。具体可以参考程序进行理解），如果点P的坐标是(x,y)，那么$x_M=x+1$，所以d的增量是2x+3；如果是黑色圆弧的情况，那么下一个中点坐标x+1，y-1，即d增量是$2x_M-2y_M+2$，同样的道理，$x_M=x+1，y_M=y-0.5$，所以d的增量是2x-2y+5。那么d的初始值$d_0$是多少呢？因为$d_0=(x_0+1)^2+(y_0-0.5)^2-R^2$且点($x_0,y_0$)=(0,R)，所以$d_0=1.25-R$。整理一下，有如下方程式：$$\begin{array}{l}x_{i+1}=x_i+1 \\y_{i+1}=\begin{cases}y_i,&amp; d \le 0 \\y_i-1,&amp; d \gt 0 \\\end{cases} \\d_{i+1}=\begin{cases}d_i+2x_i+3,&amp; d_i \le 0 \\d_i+2x_i-2y_i+5,&amp; d_i \gt 0 \\\end{cases} \\d_0=1.25-R \\\end{array}$$但是很可恨啊，上面存在1.25这个浮点数，所以仿照前文直线段的中点算法中对浮点数的处理，可以把上诉有关d的方程都在等号两端乘以4，转换为整数。再令$a_i=4d_i$，再令$d_i=a_i$，得到如下方程组：$$\begin{array}{l}x_{i+1}=x_i+1 \\y_{i+1}=\begin{cases}y_i,&amp; d \le 0 \\y_i-1,&amp; d \gt 0 \\\end{cases} \\d_{i+1}=\begin{cases}d_i+8x_i+12,&amp; d_i \le 0 \\d_i+8x_i-8y_i+20,&amp; d_i \gt 0 \\\end{cases} \\d_0=5-4R \\\end{array}$$but，上面又出现了$8x_i$这些乘法，不过由于这是像素点的坐标，相邻点之间具有很明显的常量联系，所以可以仿照上面的原理，把它们转化为加法。令$E_i=8x_i+12，SE_i=8x_i-8y_i+20$，与$d_i$同样的推理过程（不再赘述），会得到如下方程组：$$\begin{array}{l}x_{i+1}=x_i+1 \\y_{i+1}=\begin{cases}y_i,&amp; d \le 0 \\y_i-1,&amp; d \gt 0 \\\end{cases} \\d_{i+1}=\begin{cases}d_i+E_i,&amp; d_i \le 0 \\d_i+SE_i,&amp; d_i \gt 0 \\\end{cases} \\E_i=8x_i+12 \\SE_i=8x_i-8y_i+20 \\E_{i+1}=E_i+8 \\SE_{i+1}=\begin{cases}SE_i+8,&amp; d_i \le 0 \\SE_i+16,&amp; d_i \gt 0 \\\end{cases} \\d_0=5-4R \\E_0=8x_0+12=12 \\SE_0=8x_0-8y_0+20=20-8R \\\end{array}$$ 总结一下： 基本思想：圆弧扫描转换的中点算法也只存在整数加法运算。在分类情况下（下一格中点在圆弧里面还是外面），下一个像素点坐标可以直接通过上一个点坐标做加法得到；同时下一个中点代入方程值也可以在分类情况下，直接通过上一个中点代入方程值做加法得到。【注】：上面只是研究了逆时针45度到90度的圆弧，其他圆弧可以通过坐标对称得到。 具体代码如下：123456789101112131415161718192021222324252627282930313233343536//圆弧的中点算法void MidPointCircle(int R,int red,int green,int blue,int centre_x=0,int centre_y=0)&#123; glBegin(GL_POINTS); glColor3f(red,green,blue); //初始化中点算法的d,即d int d=5-4*R; int x=0; int y=R; //初始化E和SE int E=12; int SE=20-8*R; //定义八分之一圆弧x的最大值 float xMax=R*1.414/2; for(;x&lt;=xMax;x++)&#123; glVertex2d(x+centre_x,y+centre_x); glVertex2d(-x+centre_x,y+centre_x); glVertex2d(x+centre_x,-y+centre_x); glVertex2d(-x+centre_x,-y+centre_x); glVertex2d(y+centre_x,x+centre_x); glVertex2d(-y+centre_x,x+centre_x); glVertex2d(y+centre_x,-x+centre_x); glVertex2d(-y+centre_x,-x+centre_x); if(d&lt;=0)&#123; d+=E; E+=8; SE+=8; &#125; else&#123; y--; d+=SE; E+=8; SE+=16; &#125; &#125; glEnd();&#125; 扫描转换圆弧：多边形逼近法平时生活学习中，我们都知道正多边形边数越多，就会越像一个圆。多边形逼近法就是源自于此：根据已知的圆半径（圆心在原点），求出多边形的各个顶点，再依次连起来就像一个圆了。 那么根据什么规则来求多边形顶点呢？主要有两种，一种是把多边形作为圆的内接正多边形，另一种是把多边形作为与圆等面积且圆心重合的正多边形。如下图所示： 内接正多边形逼近法：点$P_i$的坐标如下：$$\begin{array}{l}x_i=R \cos \theta_i \\y_i=R \sin \theta_i \\\end{array}$$点$P_{i+1}$的坐标如下：$$\begin{array}{l}x_{i+1}=R \cos (\theta_i+\alpha) \\y_{i+1}=R \sin (\theta_i+\alpha) \\\end{array}$$用三角变化可以得到如下矩阵方程式：$$\begin{array}{c c c c}\begin{pmatrix}x_{i+1} \\y_{i+1} \\\end{pmatrix}&amp;=&amp;\begin{pmatrix}\cos \alpha &amp; -\sin \alpha \\\sin \alpha &amp; \cos \alpha \\\end{pmatrix}&amp;\begin{pmatrix}x_i \\y_i \\\end{pmatrix}\end{array}$$其中，$\alpha$是正多边形对应的圆心角，是一个常数（为什么是常数后文会讲到）。所以$\sin \alpha，\cos \alpha$只需要在开始时计算一次，之后的每一个顶点坐标都只需要4次乘法即可。 那么圆心角到底是多少呢？也就是正多边形多少条边合适？当然是边数越多越好，越像圆。但是计算机计算能力有限，不可能边数搞得特别特别大，而且在实际问题中经常也不需要那么圆，有时候可能稍微像圆一点就可以，有时候可能需要再圆一点。到底要多圆就根据实际问题能够接受的多大的误差而定了。我们经常用最大逼近误差d来表示这个能接受的最大误差。 最大逼近误差d是什么玩意？词穷了，我也不知道咋描述能简单通俗易懂，所以直接看图吧！d就是边中点到另一点（其半径与圆弧交点）的距离。也就是说这个d通常是已知的，那么圆心角就能算出来了（计算过程不再赘述了~），即$\alpha=2\arccos(R-d)/R$。总结一下： 基本思想：根据最大逼近误差d求出圆心角，再由圆心角和半径求出多边形各顶点的坐标，把各顶点依次连接起来（使用OpenGl画多边形的方法），就成了一个近似圆。 具体代码如下： 123456789101112131415161718192021222324//圆弧的正内接多边形逼近法void CircleIn(float MaxError,float R,int red,int green,int blue,int centre_x=0,int centre_y=0)&#123; glBegin(GL_LINE_LOOP); glColor3f(red,green,blue); //初始化正内接多边形对应圆心角 float alpha=2*acos((R-MaxError)/R); //初始化边数，即顶点个数 int n=2*3.14/alpha; float cosAlpha=cos(alpha); float sinAlpha=sin(alpha); float x=0; float y=R; float xTemp; float yTemp; for(int i=0;i&lt;n;i++)&#123; glVertex2d(x+centre_x,y+centre_y); xTemp=x; yTemp=y; x=cosAlpha*xTemp-sinAlpha*yTemp; y=sinAlpha*xTemp+cosAlpha*yTemp; &#125; glEnd();&#125; 等面积正多边形逼近法：在圆内接正多边形逼近法中，正多边形是内接于圆的，总感觉上面画出来的正多边形比圆要小，毕竟是内接嘛~那么有没有和圆差不多大的？减少一点这种差距。那干脆找一个面积和圆一样大，且圆心重合的正多边形把，这就是等面积正多边形逼近法（参见前面的“等面积多边形”一图）。 由于圆面积和正多边形面积相等，所以相同圆心角对应的扇形（圆的一部分）和三角形（正多边形的一部分）面积应该相等，如下图所示：图中的扇形ODCE和三角形$OP_iP_{i+1}$面积应该相等，再结合给定（在圆的参数方程中给定的）的圆半径R和最大逼近误差d，可以算出圆心角$\alpha$和正多边形半径$OP_i$的长度。知道了正多边形的圆心角和半径长度，自然就能算出正多边形个顶点的坐标了（求法和内接正多边形一致）。 基本原理和具体代码和内接正多边形逼近法类似，不再赘述了。 【注】：可以看出，中点算法是基本线画图元的高效扫面转换算法，因为算法中只用到了整数加法运算，但中点算法是有条件的：所要画的图元必须具有正负划分性，像在直线上方就是正，下方就是负；在圆外面就是正，里面就是负。像Bezier曲线这种可以自交没有正负划分性的曲线，是无法用中点算法画出来的。&nbsp; 上面研究的都是直线、圆弧这些线画图元，那么那些填充图元（包括边界和其内部的图形）又是怎么画出来的呢？主要有两种方法：扫描转换（参数→点阵）、填充（点阵→点阵）。先来看个最简单的：扫描转换矩形。&nbsp; 扫描转换填充图元矩形既然是扫描转换，那填充图元——矩形的参数形式提供了哪些参数呢？有两个：左下角坐标、右上角坐标。这足以定义一个填充的矩形了。 扫描转换时，只需要从左下角开始向右（x增大）、向上（y增大）一个一个描像素点，知道右上脚为止。代码就是x和y增大的两重循环，这里不再赘述了。&nbsp; 矩形可以这么画，但是其它多边形呢？当然要另寻他法了~~~那矩形也是多边形，为何不归为多边形画法，而要单独分出来呢？这是因为矩形的画法相当简单，没有必要去用其他多边形的那些复杂画法，而且矩形在计算机中相当常见，所以需要把这简单的单独分出来，不能把简单的搞复杂了~-~。下面来看看除了矩形以外的其他多边形是怎么画出来的。 扫描转换填充图元多边形扫描转换多边形其实就是把多边形的顶点表示形式转换成点阵表示形式。在介绍画法之前，先来看看几个问题： 共享边界如何处理？如下图：那个共享边界应该属于哪个矩形？介于此，对共享边界有个处理原则：左闭右开、下闭上开。所以上图那个共享边界应该是属于黑色矩形。 在扫描转换中，经常会提到多边形的凹凸性。所以做个解释（只考虑简单多边形，即不会自交）： 凸多边形：所有内角小于180度。 凹多边形：存在内角大于180度。 那么如何区分多边形的凹凸性呢？主要有两种方法： 顶点同侧异侧法：对于多边形的每条边，所有顶点都在这条边所在直线的同侧，则是凸多边形；如果存在异侧的，就是凹多边形。 向量叉积法：沿顺时针或逆时针，把每条边看作一个向量，如果所有相邻边向量叉积同号，则是凸多边形，否则是凹多边形。 说了这么多，到底怎么扫描转换多边形呢？主要有三种方法： 逐点判断法、扫描线算法、种子填充法。 扫描转换填充多边形：逐点判断法逐点判断法就是在绘图窗口内，一个一个地去判断像素是否位于多边形内，若是，则用指定颜色绘制该像素。 那么如何判断一个像素是否位于多边形内呢？第一感觉可能是用数学计算来判断，好吧，那先来一个粗暴的。这里主要介绍射线法。来画个图找点灵感：从上图会发现一个规律：从像素点作一条水平向右的射线，如果与多边形的交点个数是偶数，则该像素点位于多边形外边，如果交点个数是奇数，则该像素点位于多边形里面。 是吗？反例来了~如下图：~居然有出格的~那给个规定： 如果射线与边重合，则视为无数个交点，这时直接判断像素点是否在边上。 如果交点为顶点，以此顶点为端点的两条边在射线同侧，则视为两个交点；如果在射线异侧，则视为1个交点。 这样应该是没有反例了~根据上诉规律，即可判断一个像素点是否在多边形内。However，交点怎么求？用射线去和多边形的所有边通过方程求交点~不言而喻，射线法的效率低、花费大。 射线法为何效率低？主要是它忽略了多边形内部点的连续性，把它们离散处理了。当一个点在多边形内部时，通常它周围的点也会在多边形内部，这就是这里点的连续性。 扫描转换填充多边形：扫描线算法同样，画个图找点灵感：图中的水平虚线就是一条一条的扫描线（一般扫描线都是平行于x轴的，图中每条扫面线之间画的比较远，而实际扫描时扫描线都是以像素为单位，也就是y方向上每个像素都会有一条水平扫描线穿过），我们需要画出图中的多边形。 一条一条来看吧~。y=1的扫描线与多边形交于两点（水平线不参与交点计算）：P1(5，1)、P2(7，1)；y=2的扫描线也与多边形交于两点：(4，2)、(8.25，2)；……而且多边形在这些扫描线上要填充的像素点，也恰好是在扫面与多边形的两个交点之间。比如在y=1时，就把交点P1、P2之间的所有像素点描出来；在y=2时，就把交点(4，2)、(8.25，2)之间的所有像素点描出来…….直到y=7的扫描线时，我们应该已经画出了如下填充图形（不要纠结扫描线宽度，当做扫描线宽度为一个像素来理解就可以了）：但是当y=7时，扫描线与多边形有3个交点，当y=7.5时，扫描线又与多边形有4个交点（扫描线当然不会是小数，不过整数扫描线与多边形有4个交点的情况确实存在，只是这幅图找不出来，所以用7.5冒充了~-~），而且应该填充的像素点在头两个交点之间和后两个交点之间。结合之前只有两个交点的情况，好像有一个规律：把交点两两配对后，要填充的像素就在每一对交点之间。但是y=7却只有3个交点，无法两两配对，回想前面射线法是把顶点P5当做两个交点来看的，正好抄过来用一下，规定：两条边都在扫描线同一侧的顶点看作两个交点。这样y=7也可以两两配对了，扫描线一直上升到y=8甚至y=11时都可以实现交点两两配对。 扫描线从y=1上升到y=11，把配对的交点之间的像素点描上颜色，就画出了这个不规则的填充多边形。这就是扫描线转换多边形。 but同样的，我们要来看看它的效率怎么样。在两个交点之间填充像素点好说，因为扫描线是水平的，两交点的y值肯定相等，只需要让x坐标从左交点一直增大到右交点即可。但是交点怎么办？扫描线虽然是水平的，都是x=？的水平直线，那把它代入多边形边的直线方程求交？显然这又增加了一堆乘除法运算，效率很低。那有没有效率好点的求交点算法？恩~用方程求点，前面我们是不是看到过，扫描转换直线的第一个方法就是方程法，因为每个点都有一堆计算，所以放弃了方程法，效率太低，改为研究DDA算法了。那么这里能不能借用DDA的思想？其实原理是一致的，之前求扫描线与多边形的交点，忽略了扫描线上升时，多条扫描线与同一条边的交点之间其实是有联系的（因为在同一条直线上嘛）：同一条边上相邻交点的y值差1，x值正好差一个斜率的倒数。比如y=1时与边e0的交点P1（5,1）和y=2时与边e0的交点（4,2），第二个交点比第一个交点y+1（因为扫描线上升了一个像素），而第二个交点比第一个交点x-1（因为边e0的斜率为-1）；再比如y=1时与边e2的交点P2（7,1）和y=2时与边e2的交点（8.25,2），第二个交点比第一个交点y+1（因为扫描线上升了一个像素），而第二个交点比第一个交点x+1.25（因为边e2的斜率倒数是1.25）。 这样一来，我们只需要知道多边形中每条边的斜率倒数和其下端点x坐标就行，因为在同一条边上的其他交点都可以通过该边的下端点x坐标和斜率倒数做加法求出来。比如知道了边e0的和边e2的斜率倒数和其下端点坐标P1、P2，那后面边e0在y=2、3、4时的交点都可以求出来了，边e2在y=2、3、4、5时的交点也可以求出来了。但是到了y=4时，边e0变成了边e6；到y=5时，边e2也变成了边e3；到y=7时，又增加了边e5和边e4；到y=8时，边e5、e6都没了；到y=11时，仅剩的边e4和e3也没了，一条边也没了。在这过程中，有些边会加进来，有些边会删除，那什么时候加边？什么时候删除边？在回顾一下上面的过程，我们就会发现当扫描线上升到边的下端点时（扫描线y值达到了边下端点的y值），该边就会加进来配对；当扫描线上升到边的上端点时（扫描线y值达到了边上端点的y值），该边就会被删除，退出配对。所以除了边的斜率和其下端点x坐标，还需要下端点的y坐标、上端点的y坐标。 有这么多边，自然在数据结构中应该设置一个容器来存储这些边（包括边的下端点x坐标、上端点y坐标和斜率倒数，这些是已知的参数，由用户输入），那用什么容器来存储呢？第一反应当然是用数组去存储所有边，当扫描线y=1时，去遍历这个边数组，看哪条边下端点y=1就把该边加入配对队伍里，看哪条边上端点y=1就把该边从配对队伍里剔除。这个配对队伍和存储所有边的数组是同一个容器吗？当然不是~否则剔除之后到哪去遍历所有边，所以还需要另一个容器来存储那些需要去配对的边（给需要去配对的起个名字吧，叫：活性边）。那应该用什么容器来存储这些活性边呢？由于需要频繁插入、删除，而且扫描过程中，活性边容器中有多少边是不确定的，可能一会多一会少，用固定大小的数组无疑很浪费空间，而且不易于插入删除，鉴于此，存储活性边的容器选链表比较合适（可参考《数据结构与算法之链表》）一文。 那链表中的活性边如何配对呢？看看上图，比如在y=7.5的扫描线，此时的活性边是e6、e5、e4、e3，应该是e6和e5配对、e4和e3配对，放到图中刚好是从左至右两两配对。从左至右？这不就是x从小到大嘛！e6在e5左边，可见应该是下端点x小的在左边，即活性边按照下端点x坐标从小到大排序；but边e5和e4下端点x相等，e5在e4左边，可见当下端点x相等时，按照上端点x从小到大排序。 故活性边链表中的边，应该是按照下端点x值由小到大排序的，如果下端点x值相等再按照上端点x值由小到大排序（边表中每条链表里的边都是按上端点x值由小到大排序的，所以从边表里依次插入到活性边表后，下端点x值相等的边肯定是按照上端点x值由小到大排序的，所以边结构体中也就不需要上端点x坐标这个数据成员了，可参考代码进行理解）。不管怎么说，这些活性边需要按x值排序，那么采用哪种排序算法呢？因为多边形的活性边数据量不是很大，没有必要采用那些改进排序，用简单排序就好；而这些活性边应该是随着扫描线上升，动态地从链表中加入或删除，并不是一开始就全部在链表中的，所以采用冒泡排序和选择排序都不大适合，而且在简单排序中插入排序效率是最高的，所以这里对活性边的排序应该选择插入排序（关于排序可参考《数据结构与算法之简单排序》和《数据结构与算法之改进排序》）。活性边表AEL（Active Edge List）中的结点存储着边的相关信息，即边的斜率（用于求同一条边上下一个交点坐标）、当前扫描线与边的交点的x坐标（初始值为其下端点x坐标，由边表复制而来，用于求同一条边上下一个交点坐标）、上端点y坐标（用于从活性边表中删除不再参与配对的边）。活性边表结构如下图：结点中的4个数据成员依次是：上端点y坐标、当前交点的x坐标、斜率倒数、指向下一个结点的指针 存储活性边的容器选定为采用插入排序的链表了，再回过头来看看最初存储所有边的容器数组，难道扫描线每上升一次都要去遍历整个数组，找出哪些边该插入哪些边该删除~~~看图中，y=7时，应该把哪些边加入活性边表中？很显然是e5和e4，这是我们根据规律肉眼看出来的。那有没有办法当y=7时，计算机也能直接知道应该加入哪些边？把y=7时应该加入的边事先列出来存储在某一个地方不就好了么~-~就好像今天是星期天，我们应该上哪些课？通常我们是直接去查课表（课表中只有星期几和这天该上的课，不包括诸如8点到10点这些具体时间），因为课表里存储着星期几和该上哪些课。我们这里的y=？（y=几）也就相当于星期几，我们需要另一个类似课表的容器去存储y=？时应该加入活性边表的边。想想如果你要存储上面的课表，你会选用哪种容器。第一反应肯定还是最简单的数组，用数组的下标表示星期几，数组的内容表示当天应该上哪些课。但是每天上的课都不是一样多的啊，数组的内容应该取为多大才好？下标为0的数组元素可以存储2个课程结构体（因为可能想要知道课名、上课老师…等等相关内容，课程就对于多边形的边，需要知道边的斜率、下端点x坐标、上端点y坐标等），还是5个课程结构体，还是其他个数的课程结构体？这显然是不确定的，如果把数组元素内容大小设为最大长度（如一天最多上10节课），这无疑会浪费很多存储空间（可能某一天要上10节课，但另一天一节课也不上，不就浪费了10个存储空间~），所以定容的数组是不适合的，每个数组元素应该采用不定长的链表。注意是每个数组元素，就是说一周有7天是固定的，可以用大小为7的数组来表示这7天，但是每一个数组元素（每一天）能装下的课程数量是不定的，需要用链表来表示。也就是说每一个数组元素应该装一个不定长的链表，但是数组元素的容量是固定的，比如int a[7]，每个数组元素只能存放4个字节，总不能把一整条链表都装到数组元素里去吧！但是既然是链表，我们可以在数组元素里装一个指向链表第一个结点的指针啊，指针的大小是固定的（常见的是4个字节）。 这样，就解决了存储所有边应该用哪种容器：用一个大小等于扫描线条数（其实大小这里可以改进，毕竟不是每一条扫描线都有边会加入到活性边表中去，只存储那些需要加边的扫描线也是可以的）的数组表示扫描线的y=几，每个数组元素里存储着一个指向链表的指针；这个链表中存储着y=？时应该加入活性边表中的边。如下图所示（ET表示边表（Edge Table），即我们这个容器的名字）：如此，当扫描线上升到某个y值时，就可以直接从边表ET中读出需要加入活性边表AET的边。 边表中链表结点是什么样呢？链表中存储着应该加入活性边表的边，也就是这些链表中的每一个结点就表示了多边形的一个边，所以这些结点应该存储着边的相关信息，即边的斜率（用于求同一条边上下一个交点坐标）、其下端点x坐标（用于求同一条边上下一个交点坐标）、上端点y坐标（用于从），而且每条链表中存储的边（即结点）对应到图中都应该是从左到右排序的，即每条链表中的结点是按照边上端点x值由小到大排序的（这种顺序是在建立边表时人为就排好的，一般不需要再使用排序算法让计算机去排序）。因为边表中每一条链表中存储的边，都是按上端点x有序排列的，所以依次复制插入到活性边表后，下端点相同的边也就按照上端点x值由小到大排序好了。省去了到活性边表中按照上端点x再排一次，节省了很多花费。 弄清了边表中结点的数据成员和链接次序后，对图中多边形建立的完整边表如下： 回顾多边形扫描过程结合需要建立的数据结构，扫描线算法总结如下： 建立边表ET 将扫描线纵坐标y的初始值置为ET中非空元素的最小序号，如图中，y=1 置活性边表AEL为空（初始化活性边表头结点） 执行下列步骤直到ET和AET都为空4.1. 如果ET中的第y类非空，则将其中的所有边取出并复制插入到AEL中4.2. 如果有新边要插入AEL，则对AEL各边进行插入排序4.3. 对AEL中的边两两配对（第1个和第2个为一对，第3个和第4个为一对……），将每队边中x坐标按规则取整，获得有效的填充区段，再填充4.4. 将当前扫描线纵坐标y值加14.5. 将AEL中满足y=ymax（扫描线达到了某边上端点）的边删去（每条边是被看作下闭上开的，即下端点属于该边，但上端点不属于该边）4.6. 对AEL中剩下的每条边的x加斜率倒数delta，即x=x+delta 【注】：由于边的斜率倒数可能是小数，如e2的斜率倒数是1.25，所以每次算出来的交点是一个小数，但是描点的时候只能是整数值，所以4.3中，描点时需要对配对的交点的x坐标取整（这样也能在填充时减少浮点数的出现），取整规则是：让取整后的交点坐标都落在多边形内。即配对的交点中，左边的交点向右取整（通常采用int(…)+1），右边的交点向左取整（通常采用int(…)）。 用扫描线算法来扫描转换多边形的具体代码如下（代码里的多边形坐标比前面多边形图中扩大了10倍）：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163#include&lt;iostream&gt;#include&lt;math.h&gt;#include&lt;gl/glut.h&gt;using namespace std;const int infinity=65535; //表示一个不可能的数//建立边表ET中的链表结点（边结点）数据结构class ETListNode&#123;public: float xBottom; //边的下端点x坐标 float delta; //边的斜率倒数 int yTop; //边的上端点y坐标 ETListNode* nextEdge; //指向下一个链表结点的指针 ETListNode()&#123; xBottom=infinity; delta=infinity; yTop=infinity; nextEdge=NULL; &#125;&#125;;//建立边表ET中的数组元素的结构class ETArray&#123;public: ETListNode* ToETList; //指向链表的指针 ETArray()&#123; ToETList=NULL; &#125;&#125;;//边表class ET&#123;public: ETArray etArray[110]; ETListNode edges[6]; ET()&#123; edges[0].yTop=40; edges[0].xBottom=50; edges[0].delta=-1; edges[1].yTop=50; edges[1].xBottom=70; edges[1].delta=5.0/4; edges[2].yTop=80; edges[2].xBottom=20; edges[2].delta=0; edges[3].yTop=110; edges[3].xBottom=120; edges[3].delta=0; edges[4].yTop=80; edges[4].xBottom=70; edges[4].delta=-5; edges[5].yTop=110; edges[5].xBottom=70; edges[5].delta=5.0/4; edges[0].nextEdge=&amp;edges[1]; edges[4].nextEdge=&amp;edges[5]; etArray[10].ToETList=&amp;edges[0]; etArray[40].ToETList=&amp;edges[2]; etArray[50].ToETList=&amp;edges[3]; etArray[70].ToETList=&amp;edges[4]; &#125;&#125;;//建立活性边表AET的结点结构class AETListNode&#123;public: float xIntersection; //当前扫描线与活性边的交点的x坐标 float delta; //边的斜率倒数 int yTop; //边的上端点y坐标 AETListNode* nextEdge; //指向下一个链表结点的指针 AETListNode()&#123; xIntersection=infinity; delta=infinity; yTop=infinity; nextEdge=NULL; &#125;&#125;;//活性边表class AET&#123;public: AETListNode* first; //活性边表头结点 AET()&#123; first=new AETListNode(); //初始化头结点 &#125;&#125;;//扫描线算法画多边形void Scan()&#123; ET et; AET aet; bool etEmpty=false; bool aetEmpty=false; int y=0; //扫描线y值 while(et.etArray[y].ToETList==NULL)&#123; y++; &#125; while(y&lt;110)&#123; ETListNode* currentETNode=et.etArray[y].ToETList; while(currentETNode!=NULL)&#123; AETListNode* tempAETNode=new AETListNode(); tempAETNode-&gt;yTop=currentETNode-&gt;yTop; tempAETNode-&gt;xIntersection=currentETNode-&gt;xBottom; tempAETNode-&gt;delta=currentETNode-&gt;delta; AETListNode* currentAETNode=aet.first; while(currentAETNode-&gt;nextEdge!=NULL &amp;&amp; tempAETNode-&gt;xIntersection&gt;=currentAETNode-&gt;nextEdge-&gt;xIntersection)&#123; currentAETNode=currentAETNode-&gt;nextEdge; &#125; //插入新边（新结点） tempAETNode-&gt;nextEdge=currentAETNode-&gt;nextEdge; currentAETNode-&gt;nextEdge=tempAETNode; currentETNode=currentETNode-&gt;nextEdge; &#125; AETListNode* currentAETNode=aet.first; for(int i=1;currentAETNode-&gt;nextEdge!=NULL;i++)&#123; currentAETNode=currentAETNode-&gt;nextEdge; if(i%2==1 )&#123; int xStart=int(currentAETNode-&gt;xIntersection)+1; int xEnd=int(currentAETNode-&gt;nextEdge-&gt;xIntersection); for(int x=xStart;x&lt;=xEnd;x++)&#123; glVertex2d(x,y); &#125; &#125; &#125; y++; currentAETNode=aet.first; while(currentAETNode-&gt;nextEdge!=NULL)&#123; if(currentAETNode-&gt;nextEdge-&gt;yTop==y)&#123; currentAETNode-&gt;nextEdge=currentAETNode-&gt;nextEdge-&gt;nextEdge; &#125; else&#123; currentAETNode=currentAETNode-&gt;nextEdge; currentAETNode-&gt;xIntersection+=currentAETNode-&gt;delta; &#125; &#125; &#125;&#125;void Draw()&#123; gluOrtho2D(0,700,0,600); glClearColor(1,1,0,0); glClear(GL_COLOR_BUFFER_BIT); glBegin(GL_POINTS); glColor3ub(255,0,0); Scan(); glEnd(); glFlush();&#125;void mydisplay()&#123; Draw();&#125;int main()&#123; glutInitWindowSize(400,600); glutCreateWindow("扫描转换多边形"); glutDisplayFunc(mydisplay); glutMainLoop(); return 0;&#125; &nbsp; 在扫描线算法中用到了交点（相邻扫描线与多边形某一条边的交点）之间的连续性，即同一条边上相邻交点是有固定代数联系的。也就是说扫描线算法是从多边形的轮廓下手的，先找出多边形轮廓上的点，再去填充这些轮廓点之间的像素点。那么能不能直接从多边形内部的点下手呢？毕竟多边形内部的点连续性更明显啊：多边形内部的点通常它周围的点都会在多边形里。下面的这个算法就是利用了这点。 扫描转换填充多边形：种子填充法种子填充法是利用了多边形内部点的连续性。有两种填充方式： 边界填充：首先用一种颜色（取名边界色）画出多边形轮廓，再从多边形内部任意一点开始，查看它的周围像素点（一般是上下左右）是否是边界色或者已填充色，如果都不是，则说明该点是多边形内部且暂时没有被描色的点，接下来给该点描色即可。一般采用递归的方式，让每个已描色的点都去重复上诉过程。 内点填充：依然是首先用一种不同于背景色的颜色，画出多边形轮廓，再从多边形内部任意一点开始，查看它的周围像素点（一般是上下左右）是否是背景色，如果是则说明该点是多边形内部且暂时没有被描色的点，接下来用一种不同于背景色的颜色给该点描色即可。同样采用递归的方式，让每个以描色的点都去重复上诉过程。 使用内点填充画五角星的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109 #include&lt;math.h&gt; #include&lt;gl/glut.h&gt; #include&lt;iostream&gt; using namespace std; #define PI 3.14 //读像素颜色 unsigned char* GetPixel(float x,float y)&#123;unsigned char* color=new unsigned char[3];glReadPixels(x,y,1,1,GL_RGB,GL_BYTE,color); //调用opengl函数读取像素颜色return color; &#125; //写像素颜色 void SetPixel(float x,float y,int* BoundaryColor)&#123;glBegin(GL_POINTS); glColor3ub(BoundaryColor[0],BoundaryColor[1],BoundaryColor[2]);glVertex2f(x,y);glEnd();glFlush(); &#125; //内点填充（递归） //参数BoundaryColor为边界色或者填充色，二者等色 void FloodFill(float x,float y,int* BoundaryColor)&#123;unsigned char* color=GetPixel(x,y);//像素颜色是否等于原背景色:绿色，如果是则填为边界色if(color[0]==0&amp;&amp;color[1]==127&amp;&amp;color[2]==0)&#123; SetPixel(x,y,BoundaryColor); FloodFill(x,y+1,BoundaryColor); FloodFill(x,y-1,BoundaryColor); FloodFill(x+1,y,BoundaryColor); FloodFill(x-1,y,BoundaryColor);&#125; &#125; //填充五角星 void FillPentagram()&#123;int* BoundaryColor=new int[3]; //设置边界色/已填充色BoundaryColor[0]=255;BoundaryColor[1]=0;BoundaryColor[2]=0;glColor3ub(BoundaryColor[0],BoundaryColor[1],BoundaryColor[2]);//指定一个种子坐标float x0=0;float y0=10;float theta;for(int i=0;i&lt;10;i++)&#123; //旋转种子点，每次36度 theta=0.2*PI*i; float x=cos(theta)*x0-sin(theta)*y0+300; float y=sin(theta)*x0+cos(theta)*y0+300; if(i%2==0)&#123; BoundaryColor[0]=255; &#125; else&#123; BoundaryColor[0]=127; &#125; FloodFill(x,y,BoundaryColor);&#125; &#125; //画五角星轮廓 void DrawPentagramOutline()&#123;float R=100; //五角星外圆半径float r=R*0.415f; //五角星内圆半径float point[10][2];float point_original[1][2];point_original[0][0]=300;point_original[0][1]=300;glBegin(GL_LINE_LOOP); glColor3ub(255,0,0); for(int i=0;i&lt;10;i++)&#123; if(i%2==0)&#123; point[i][0]=r*cos(0.2*i*PI); point[i][1]=r*sin(0.2*i*PI); &#125; else&#123; point[i][0]=R*cos(0.2*i*PI); point[i][1]=R*sin(0.2*i*PI); &#125; &#125; for(i=0;i&lt;10;i++)&#123; glVertex2d(point_original[0][0]+point[i][0],point_original[0][1]+point[i][1]); &#125;glEnd();glBegin(GL_LINES); glColor3ub(255,0,0); for(i=0;i&lt;10;i++)&#123; glVertex2d(point_original[0][0]+point[i][0],point_original[0][1]+point[i][1]); glVertex2d(point_original[0][0],point_original[0][1]); &#125;glEnd();glFlush(); &#125; void mydisplay()&#123;glClearColor(0,1,0,0);glClear(GL_COLOR_BUFFER_BIT);glMatrixMode(GL_PROJECTION);glLoadIdentity();gluOrtho2D(0,500,0,600);DrawPentagramOutline();FillPentagram(); &#125; void main()&#123;glutInitWindowSize(500,600);glutCreateWindow("种子填充");glutDisplayFunc(mydisplay);glutMainLoop(); &#125; 效果如下： 可以看出，无论哪种方法，其实都需要先画出多边形轮廓的点阵信息，再根据屏幕上像素点的颜色来进行填充，所以其实是点阵到点阵的转换，已经不是严格意义上的扫描转换了。但是那些事先的轮廓点阵信息一般都是由参数形式转换而来，所以才把种子填充勉强地归为扫描转换。&nbsp; 到此，已经介绍完了画基本填充图元的扫描转换法。下面是另一个画法：填充法。 画填充图形：填充法扫描转换法是把图形的参数形式转换为点阵形式，再进行显示。但是并不是每一幅图形都能用参数表示出来啊~~比如相机照出来的照片，要用参数这种数学形式表示出照片这种复杂图形估计有点难度！那就没有参数形式，只有点阵形式了，比如要在计算机上显示一幅照片，就得需要这幅照片的点阵形式，这幅照片的点阵形式是什么？当然是每一个像素点的颜色啊，所以如果知道图形每一个像素点的颜色值，则交给计算机按颜色值逐像素点描色，即可在电脑上画出这张照片。 所以填充法就是：按照事先知道的图形像素点颜色值，在计算机上逐点描色，从而画出图形。 至于怎么事先知道一幅图形的所有像素点颜色值，就得靠其它方法了，比如数码摄像机会通过电子传感器把光学影像转换成电子数据，再传输给计算机。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Mathjax简介及其语法]]></title>
    <url>%2F2016%2F10%2F27%2FMathjax%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Mathjax简介Mathjax是一款运行在浏览器中的开源数学符号渲染引擎，使用Mathjax可以方便地在浏览器中显示数学公式，不需要使用图片。目前，Mathjax可以解析LateX、MathML和ASCIIMathML的标记语言。几乎支持所有的主流浏览器。&nbsp; Mathjax语法 Mathjax公式排版方式Mathjax公式排版有两种方式：inline和displayed。inline方式是把公式内嵌（使用$...$），例如$f(x)=3 \times x$，$f(x)=3 \times x$这是一个inline公式；而displayed是公式独立成段（使用$$...$$），例如$$f(x)=3 \times x$$，$$f(x)=3 \times x$$是一个displayed公式。【注】： 右键点击公式，可查看公式代码、设置显示效果和渲染模式（点击打开的公式代码没有包含$，自己在写公式时加上即可）。 两个独立成段的displayed公式之间必须以空行分开，否则显示不出来。即应该是下面这样：123$$...$$$$...$$ 公式中的希腊字母 公式中的上标下标上标使用^，下标使用_。例如x_i^2是：$x_i^2$。【注】： 10^10得到的是$10^10$，而10^{10}才是$10^{10}$。 x^5^6会报错，因为有二义性，必须使用大括号来加以界定，如：{x^5}^6：${x^5}^6$ 或者x^{5^6}：$x^{5^6}$。 公式中的括号 小括号与方括号：小括号还是原始的()，方括号也是原始的[]。如(2+3)[4+4]：$(2+3)[4+4]$ 大括号：{}由于被用来界定分组（如上文中的10^{10}），所以大括号需要用{和}来表示，也可以使用\lbrace和\rbrace来表示。如{a*b}：${a*b}$，\lbrace a*b \rbrace：$\lbrace a*b \rbrace$。 尖括号：使用\langle和\rangle表示。如\langle x \rangle：$\langle x \rangle$。 向上取整：使用\lceil和\rceil表示。如\lceil x \rceil：$\lceil x \rceil$。 向下取整：使用\lfloor和\rfloor表示。如\lfloor x \rfloor：$\lfloor x \rfloor$。 不可见括号：使用.表示。 【注】：这些括号都是不会随着公式大小进行缩放的。如果需要括号大小自适应公式大小，可以在相应的左括号前面加上/left，右括号前面加上/right。如下所示：$$\lbrace \sum_{i=0}^n i^2 \rbrace \tag{1}$$ $$\left\lbrace \sum_{i=0}^n i^2 \right\rbrace \tag{2}$$ 公式2的括号就是经过缩放的（右键点击公式能看到公式源码）。 公式中的求和与积分求和符号使用\sum来表示，用下标_来表示求和下限，用上标^来表示求和上限。如\sum_1^n：$\sum_1^n$。 积分符号使用\int来表示，同样用上下标表示积分的上下限。如\int_1^\infty：$\int_1^\infty$。 与此类似的符号还有：二重积分\iint：$\iint$，连乘\prod：$\prod$，并\bigcup：$\bigcup$，交\bigcap：$\bigcap$。 公式中的分数分数有两种表示方式： 使用\frac ab来表示，\frac作用于其后的两个组a、b，结果为$\frac ab$。如果分子或分母不是单个字符，使用{}进行分组即可（也就是用大括号括起来）。 使用a \over b来分隔分子分母。如a+1 \over b+1：$a+1 \over b+1$。 公式中的根号根号使用\sqrt[]{}来表示。如\sqrt[4]{\frac xy}：$\sqrt[4]{\frac xy}$。 公式中的三角函数使用\sin来表示正弦函数，如$\sin x$。其他三角函数类似。 公式中的特殊符号 求极限符号：使用\lim_{x \to y}表示。如$\lim_{1 \to \infty}$。 比较运算符： 小于$\lt$：\lt。 大于$gt$：\gt 小于等于$\le$：\le。 大于等于$\ge$：\ge。 可以在这些运算符前面加上\not，如\not \gt：$\not \gt$。 常见计算运算符： 加$+$：直接在公式中使用+即可。 减$-$：直接在公式中使用-即可。 乘$\times$：\times。 除$\div$：\div。 加减$\pm$：\pm。 减加$\mp$：\mp。 点乘$\cdot$：\cdot。如x \cdot y：$x \cdot y$。 集合运算符： 并$\cup$：\cup 交$\cap$：\cap 舍$\setminus$：\setminus 包含于$\subset$：\subset 真包含于$\subseteq$：\subseteq 非真包含于$\subsetneq$：\subsetneq 包含$\supset$：\supset 属于$\in$：\in 不属于$\notin$：\notin 空集$\varnothing$：\varnothing 排列使用$n+1 \choose 2k$：使用a \choose y或者\binom ab来表示。 箭头：\to：$\to$，\rightarrow：$\rightarrow$，\leftarrow：$\leftarrow$，\Rightarrow：$\Rightarrow$，\Leftarrow：$\Leftarrow$，\mapsto：$\mapsto$。 逻辑运算符：\land：$\land$， \lor：$\lor$， \lnot：$\lnot$， \forall：$\forall$，\exists：$\exists$，\top：$\top$，\bot：$\bot$，\vdash：$\vdash$， \vDash：$\vDash$。 模运算符：\pmod。如b \pmod n：$b\ pmod n$。 省略号：\cdots位置居中：$\cdots$；\ldots位置稍低：$\ldots$。 \star：$\star$，\ast：$\ast$，\oplus：$\oplus$，\circ：$\circ$，\bullet：$\bullet$，\approx：$\approx$，\sim：$\sim$，\cong：$\cong$，\equiv：$\equiv$，\prec：$\prec$，\infty：$\infty$，\nabla：$\nabla$，\partial：$\partial$。 【注】：使用Detexify，可以在它的网页上画出你想要的符号，Detexify会给出相似的符号及其公式代码。但是不能保证它给出的符号可以在Mathjax中使用，可以参考supported-latex-commands确定MathJax是否支持此符号。 公式中的空格因为Mathjax通过内部策略自己管理公式内部的空间，因此a b的显示结果依然是：$a b$。想要在ab之间加入间隙，可以使用\,、\;、\quad、\qquad等，间隙依次增加，如$a\,b$、$a\;b$、$a \quad b$、$a \qquad b$。 公式中的顶部符号对于单字符\hat：$\hat x$，多字符\widehat：$\widehat {xy}$。类似的还有：\overline：$\overline {xyz}$、\vec：$\vec x$、\overrightarrow：$\overrightarrow x$、\dot：$\dot x$、\ddot：$\ddot x$。 公式中的表格使用$$\begin{array}{列样式}...\end{array}$$这样的样式来创建表格。 列样式可以是c（居中）、l（左对齐）、r（右对齐）。 每行之间使用\\来分隔（本来是\，但是在markdown中第一个\被解释为转义字符，所以需要\\），每列之间使用&amp;来分隔。 在列样式中写入|可表示一条竖线，在每行前面加上\hline可在本行前加入一条直线。 例如：12345678910111213$$\begin&#123;array&#125;&#123;|c|l|c|r|&#125;\hlinen &amp; Left &amp; Center &amp; Right \\\\\hline1 &amp; 0.24 &amp; 1 &amp; 125 \\\\\hline2 &amp; -1 &amp; 189 &amp; -8 \\\\\hline3 &amp; -20 &amp; 2000 &amp; 1+10i \\\\\hline\end&#123;array&#125;$$ 效果：$$\begin{array}{|c|l|c|r|}\hlinen &amp; Left &amp; Center &amp; Right \\\hline1 &amp; 0.24 &amp; 1 &amp; 125 \\\hline2 &amp; -1 &amp; 189 &amp; -8 \\\hline3 &amp; -20 &amp; 2000 &amp; 1+10i \\\hline\end{array}$$ 公式中的矩阵使用$$\begin{matrix}...\end{matrix}$$这样的形式来表示矩阵。矩阵的每行之间依然使用\\来分隔，列之间依然使用&amp;来分隔。例如：1234567$$\begin&#123;matrix&#125;1 &amp; x &amp; x^2 \\\\1 &amp; y &amp; y^2 \\\\1 &amp; z &amp; z^2 \\\\\end&#123;matrix&#125;$$ 效果：$$\begin{matrix}1 &amp; x &amp; x^2 \\1 &amp; y &amp; y^2 \\1 &amp; z &amp; z^2 \\\end{matrix}$$ 给矩阵加括号： 可以用前文中提到的括号再配以\left和\right。 也可以使用特殊的matrix，即替换\begin{matrix}...\end{matrix}中的matrix为pmatrix、bmatrix、Bmatrix、vmatrix、Vmatrix。如pmatrix：$\begin{pmatrix} 1 &amp; 2 \\ 3 &amp; 4\\ \end{pmatrix}$、bmatrix：&amp;\begin{bmatrix} 1 &amp; 2 \\ 3 &amp; 4\\ \end{bmatrix}$、Bmatrix：$\begin{Bmatrix} 1 &amp; 2 \\ 3 &amp; 4\\ \end{Bmatrix}$、vmatrix：$\begin{vmatrix} 1 &amp; 2 \\ 3 &amp; 4\\ \end{vmatrix}$、Vmatrix：$\begin{Vmatrix} 1 &amp; 2 \\ 3 &amp; 4\\ \end{Vmatrix}$。 矩阵中的省略元素：可以使用\cdots：$\cdots$、\ddots：$\ddots$、\vdots：$\vdots$来表示矩阵中的省略元素。例如：$$\begin{pmatrix}1 &amp; a_1 &amp; a_1^2 &amp; \cdots &amp; a_1^n \\1 &amp; a_2 &amp; a_2^2 &amp; \cdots &amp; a_2^n \\\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\1 &amp; a_m &amp; a_m^2 &amp; \cdots &amp; a_m^n \\\end{pmatrix}$$ 增广矩阵的表示：增广矩阵需要使用前面的array来实现，而matrix办不到了。例如：12345678$$ \left [ \begin&#123;array&#125;&#123;cc|c&#125; 1 &amp; 2 &amp; 3 \\\\ 4 &amp; 5 &amp; 6 \\\\ \end&#123;array&#125;\right ]$$ 效果：$$\left [ \begin{array}{cc|c} 1 &amp; 2 &amp; 3 \\ 4 &amp; 5 &amp; 6 \\ \end{array}\right ]$$ 公式对齐有时候可能需要一系列的公式中等号对齐，例如：$$\begin{align}\sqrt{37} &amp; = \sqrt{\frac{73^2-1}{12^2}} \\ &amp; = \sqrt{\frac{73^2}{12^2}\cdot\frac{73^2-1}{73^2}} \\ &amp; = \sqrt{\frac{73^2}{12^2}}\sqrt{\frac{73^2-1}{73^2}} \\ &amp; = \frac{73}{12}\sqrt{1 - \frac{1}{73^2}} \\ &amp; \approx \frac{73}{12}\left(1 - \frac{1}{2\cdot73^2}\right)\end{align}$$这需要使用形如\begin{align}...\end{align}的格式，其中需要使用&amp;来指明需要对齐的位置（右键可查看上诉公式的代码）。 分类表达式可使用形如\begin{cases}...\end{cases}的格式。其中使用\来分类，可使用&amp;指明需要对齐的位置。例如：$$f(n) =\begin{cases}n/2, &amp; \text{if $n$ is even} \\3n+1, &amp; \text{if $n$ is odd} \\\end{cases}$$ 方程组 可以使用\begin{array}...\end{array}与\left{ ... \right.，配合表示方程组。例如：$$\left\{\begin{array}{c}a_1x+b_1y+c_1z=d_1 \\a_2x+b_2y+c_2z=d_2 \\a_3x+b_3y+c_3z=d_3 \\\end{array}\right.$$ 也可以使用\begin{cases}...\end{cases}。例如：$$\begin{cases}a_1x+b_1y+c_1z=d_1 \\a_2x+b_2y+c_2z=d_2 \\a_3x+b_3y+c_3z=d_3 \\\end{cases}$$ &nbsp; 【注】：本文主要参考《Mathjax与LaTex公式简介》一文，更多详细内容请参考此文。]]></content>
      <categories>
        <category>博客配置</category>
      </categories>
      <tags>
        <tag>Mathjax语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机图形显示系统]]></title>
    <url>%2F2016%2F10%2F19%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E6%98%BE%E7%A4%BA%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[在揭开计算机图形显示系统的面纱之前，我们先来看看我们再熟悉不过的显示器吧。 显示器如今的显示器大致分为两类（按器件的发光性质）： 阴极射线管CRT（Cathode Ray Cube）：优点：亮度高、对比度好、色彩鲜艳缺点：体积大、笨重 平板型显示器：液晶、等离子优点：器件薄，适合携带缺点：亮度和对比度相对较低、色彩不够鲜艳，价格偏高 两种显示器如下图所示： 接下来分别看看这两种显示器。 CRT（Cathode Ray Cube）显示器 CRT是怎么显示图形的呢？CRT是一种真空器件，利用内部电磁场产生高速的、经过聚集的电子束，偏转到屏幕的不同位置，轰击屏幕表面的荧光材料，从而产生可见的图形。 CRT由哪些东西组成？CRT主要由电子枪、聚焦系统、加速电极、偏转系统、荧光屏组成。如下图所示：（其实其中的电极、磁场、电场、偏转系统在高中物理就学过~在此就不赘述了） 但是我们现在经常见到的都是彩色电视，也就是彩色CRT（指的是大头电视，不是液晶电视~），那么CRT是怎么显示彩色的呢？ CRT是怎么显示彩色像素点的？常用的有两种方法：射线穿透法、影孔板法。 射线穿透法：原理：屏幕表面的荧光材料有两层：红色荧光涂层（发红光）和绿色荧光涂层（发绿光），电子束轰击穿透荧光层的深浅，决定了最后所产生的颜色。如下图所示：使用射线穿透法的CRT成本低，但是只能产生有限几种颜色。主要用于画线显示器。 影孔板法： 原理：屏幕表面其实有三层，最内层是影孔板，中间层才是荧光涂层，最外层是屏幕玻璃。其中影孔板上有很多个小孔，每个小孔对应后面荧光涂层上的三个荧光点（呈三角形排列），所以每个小孔其实也是对应一个像素点（即三个荧光点）。如下图所示：在影孔板的内侧有三支电子枪，对应红、绿、蓝三种基色，电子枪、影孔板中的一个小孔和荧光点在一条直线上（如下图所示）。通过调节各电子枪发生的电子数目，就可以控制三个荧光点产生的三种色光强度。我们知道，三种基色的不同比例混合可以产生多种颜色，如此便达到了彩色的效果。（如果每支电子枪发出的电子束的强度有256个等级，则显示器能同时显示256*256*256=16M种颜色，称为真彩系统。） 【注】：三基色通常是RGB（红绿蓝），多用于硬件设备，如摄像机、扫描仪、投影仪等。还有一种三基色是CMY（蓝绿cyan、品红magenta、黄yellow），常用于彩色打印。CMY与RGB具有互补关系，即R=1-C、G=1-M、B=1-Y。 平板型显示器这里主要介绍液晶显示器。 液晶显示器LCD（Liquid Crystal Display）我们先来看看什么是液晶。 什么是液晶？液晶是一种液体和固体之间的特殊物质，它具有液体的流态性质和固体的光学性质。当液晶分子的某种排列状态，在电场作用下变为另一种排列状态时，液晶的光学性质会随之改变。 液晶分子受到电压影响时，会改变其分子排列状态，于是可以让摄入的光线产生偏转现象，从而改变光的强弱。如下图所示：液晶亮度的控制原理如下：那么到底是怎么显示彩色的呢？ 液晶LCD是怎么显示彩色像素点的从上面可以看到，液晶可以改变光的强度，这就类似影孔板法中电子束的强度，在LCD中其实也和影孔板法一样，存在三基色，通过不同的光强产生不同强度的三种色光，再组合就能得到各种各样的颜色。只是荧光涂层和三基色的实现方式不同于影孔板法罢了，原理都是一样的。影孔板法通过在阴极上调节电压来控制电子束的强度，从而控制三基色的强度，达到彩色效果，而LCD是通过液晶分子在电压下的不同排列方式来控制光强，从而控制三基色的强度，达到彩色效果。想要了解的更详细，可以看这篇文章哦！ LCD显示器和CRT显示器的比较 相同点：都是通过单个发光元素（像素）来显示图形或文字。 不同点： LCD体积小，厚度薄，重量轻，耗能少，无辐射 CRT显示亮度高，色彩鲜艳，分辨率高，但是体积较大 【注】：分辨率是CRT在水平或竖直方向单位长度上能识别的最大像素个数，单位通常为dpi（dots per inch）。在假定屏幕尺寸一定的情况下，也可用整个屏幕所能容纳的像素个数描述，如640480，1024768，1280*1024等等。分辨率越高显示的图形就越精细。 到此，我们搞清了显示器的原理。是时候来看看我们的主题了：计算机图形显示系统。 计算机图形显示系统先来看看显示系统由哪些东西组成。 显示系统由哪些东西组成？主要组成部分是：显示器、视频控制器、显示缓冲器。 视频控制器：控制显示设备（有的含图形加速处理器GPU），通过访问帧缓存来刷新屏幕 显示缓冲器：可以在内存或显示控制器中，帧缓存存放在显示缓冲器中 如下图所示：视频控制器就是从系统存储器（显示缓冲器）的帧缓存中取出一帧要显示的内容（一些绘图命令），然后由视频控制器来显示数据对应的图形。 视频控制器以不同的方式显示计算机图形，可把显示系统分为两类：随机扫描显示系统、光栅扫描显示系统。 随机扫描显示系统 什么是随机扫描？电子束可以随意移动，只扫描荧屏上要显示的部分像素。对应的显示器为画线设备。 随机扫描显示系统主要靠哪些东西来实现（逻辑部件）？ 刷新存储器（Refreshing Buffer）：帧缓存所在的地方 显示处理器（DPU：Display Processing Unit）：解释执行绘图命令，驱动电子枪绘图 CRT 随机扫描显示是怎么实现的（显示原理）？应用程序发出绘图命令，这些绘图命令被解析成为显示处理器可以接受的命令格式，存储在刷新储存器中。刷新存储器中的所有绘图命令组成一个显示文件，交由显示处理器DPU解释执行，驱动电子枪在屏幕上绘图。如下图所示： 光栅扫描显示系统 什么是光栅扫描？电子束按固定的扫面线和扫描顺序从左到右、自上而下进行扫描。【注】： 扫描线：一条水平线 帧：一次扫描生成的图像 水平回扫期：水平线间的回扫期 垂直回扫期：帧间的回扫期（从上到下的扫描期） 分辨率：电子束按固定的扫描顺序扫描N条扫描线，每条扫描线有M个像素，则M*N为显示器的分辨率。 光栅扫描过程图示 光栅扫描显示系统主要靠哪些东西来实现（逻辑部件）光栅扫描显示系统的主要逻辑部件是：帧缓冲存储器、视频控制器、显示处理器、显示器（CRT、液晶）。如下图所示：下面分别来了解一下这些部件： 帧缓冲存储器：简称帧缓存，是显存中的部分存储单元。用于存储屏幕上的颜色值，所以帧缓存中的存储单元与屏幕上的像素一一对应（总数也是相同的），帧缓存中存储单元的数值决定了对应屏幕像素的颜色，存储单元的位数自然也就决定了屏幕像素颜色有多少种。如黑白显示系统的帧缓存存储单元位数就应该是1位。对于真彩色系统应该是每种基色有8位，所以真彩色的帧缓存存储单元位数应该是24位，显示系统最多可显示2^24种颜色若分辨率为M*N、颜色个数为K，则帧缓存大小V&gt;=M*N*[log2K]（向上取整）【注：】 目前PC机的显存容量一般都在256M以上，但是对于1024*1024的真彩色系统需要的缓存大小只有：1024*1024*log2(2^24)/8=3M字节，为何显存容量远大于真彩色需要的存储容量呢？这是因为显存不止包括像素的颜色信息，还包括深度缓存、纹理内存等等。 视频控制器：负责解释执行帧缓存中的绘图命令，驱动电子枪在荧光屏上绘图，实现刷新。具体工作过程如下：刷新周期开始，依扫描次序依次取出帧缓存单元的数值，放入像素值寄存器，列对应的地址寄存器的地址加1，如此重复，直到该扫描线上的最后一个元素，转下一行，列地址置0，行地址加1。其逻辑结构如下图所示： 显示处理器（GPU）：用于代替CPU完成部分图形处理功能，如扫描转换、几何变换、裁剪、光栅操作、纹理映射等等。 光栅扫描显示系统的优缺点 优点：成本低、容易绘制填充图形、色彩丰富、刷新频率一定（与图形的复杂程度无关）、易于修改图形（其实就是修改绘图命令） 缺点：需要扫描转换，这样复杂图形计算量会比较大；会产生混淆（走样）。]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>图形显示系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图形学概述]]></title>
    <url>%2F2016%2F10%2F18%2F%E5%9B%BE%E5%BD%A2%E5%AD%A6%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[什么是计算机图形学？ ISO定义：通过计算机将数据转换为图形，并在专门的显示设备上进行显示，而计算机图形学就是研究其中的原理、方法和技术的学科。 IEEE定义：Computer graphics is the art or science of producing graphical images with the aid of computer。 说白了，计算机图形学就是应用计算机技术进行图形的生成、处理和输出。 那么什么是图形呢？图形有哪些特征吗？ 什么是图形？凡是能在人的视觉系统中产生视觉映像的客观对象都是图形，在计算机中是指可以用计算机生成、显示、存储、处理并输出的对象。【注】：图形也可以是完全虚构的物体（如假想中的天堂）。 图形的基本要素 几何要素：如点、线、多边形、多面体等。主要用于刻画对象的轮廓、形状。 非几何要素：如颜色、纹理等。主要用于刻画物体的颜色、材质等等。 那么在计算机中图形是以何种方式显示的呢？ 计算机图形的表示方法？首先要明白，计算机肯定都是通过一个一个的像素点的颜色来显示图形的。但是对于要显示的图形，根据记录其像素点的方式不同，计算机图形的表示方法分为点阵法和参数法。 点阵法记录图形中的所有像素点（包括轮廓和其内部、外部的所有点，也就是带背景的图形），显示时按行按列依次快速显示出每个像素点，就能看到完整的一幅图形。其实以这种方式表示的图形通常称为图像（image）。 参数法只记录图形的的形状参数（方程或表达式的系数、线段的端点坐标等）、属性参数（颜色、线型等），显示时通过计算来确定哪些像素点应该位于图形上，再根据属性参数绘制出相应的点，最后便能形成完整的图形（如圆可以通过圆心坐标、半径和颜色来表示）。以这种方式表示的通常才称为图形（graphics）。 不难看出，点阵法表示的计算机图形数据量很大，不需要复杂的计算；而参数法表示的计算机图形数据量很小，显示时需要复杂的计算。更多比较，请看下图： 搞清了什么是图形和计算机图形学，那么计算机图形学究竟是研究哪些东西呢？ 计算机图形的研究内容 图形系统（硬件、软件、标准化）。 基本图形生成。比如如何显示点、线段、多边形、圆等几何图形。 图形处理。比如几何变换（图形动起来）、投影变化（如何显示三维图形）、真实感图形（关照、阴影等）。 物体造型（建模）。比如实体表示、曲线曲面、真实感等等。 下面来看一看图形学的发展历史吧！ 计算机图形学的发展史分三个方向来回顾这段历史：学科发展历程、硬件发展历程、软件以软件标准的发展历程（该部分略，可问度娘）。 学科发展历程 20世纪50年代，计算机图形学诞生。1950年，第一台图形显示器诞生，当时是作为麻省理工旋风1号计算机的附件。CRT的出现为计算机生成并显示图形提供了可能。而后MIT（麻省理工）林肯实验室，在Whirlwind上开发SAGE空中防御系统，通过光笔在屏幕上指点实现与系统交互。标志着交互式图形技术诞生。 20世纪60年代，计算机图形学这一门学科被确立。1962年，MIT林肯实验室，Ivan E.Sutherland在他的博士论文中首次提出”Computer Graphics”一词。从此，Sutherland被称为计算机图形学之父。 1962年，雷洛汽车公司的工程师Pierre Bezier提出Bezier曲线、曲面的理论。 1964年，MIT的Steven A.Coons教授提出了超限插值的新思想，通过插值四条任意的边界曲线来构造曲面。 19实际70年代，光栅图形学迅速发展。区域填充、裁剪、消隐等基本图形概念及其相应算法纷纷诞生。 在真实感图形学上，1970年，Bouknight提出了第一个光反射模型；1971年，Gourand提出”漫反射+插值”的思想，被称为Gourand明暗处理。1975年，Phong提出了著名的简单关照模型-Phong模型。 19世纪80年代，计算机图形学开始实用化。大量图形应用软件出现，但是图形硬件设备却是十分昂贵。8 .19世纪90年代，计算机图形学被广泛应用。多用于多媒体技术、人工智能、科学计算可视化、虚拟现实、三维造型技术等领域。而且硬件集成化也大幅度提高：GPU出现。 硬件发展历程 图形显示设备的发展 20世纪60年代中期，主要是画线显示器，需要刷新。具有较高的分辨率和对比度，良好的动态性能。但设备昂贵。 20世纪60年代后期，主要是存储管式显示器，许需要刷新。价格较低，但是不具有动态修改图形的功能，不适合交互式。 20世纪70年代初，主要是刷新式光栅扫描器。以点阵形式表示图形，使用专用的缓冲区存放点阵，由视频控制器负责刷新扫描。大大推动了交互式图形技术的发展。 20世纪90年代至今，主要是液晶和等离子显示器，和一些新的显示设备（如立体显示器）。 图形输入设备的发展 控制开关、穿孔纸等。 键盘。 二维定位设备。如鼠标、光笔、触摸屏、语音、操纵杆等。 三维输入设备。如空间球、数据手套、用户手势和表情等（将来）。 用户思维（将来）。]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>图形学概述</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenGL1：OpenGL概述及环境配置]]></title>
    <url>%2F2016%2F10%2F18%2FOpenGL1%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[OpenGL简介OpenGL是一个功能强大的图形库，提供了很多操作图形和图片的API（Application Programming Interface），用户可以用它很方便地开发所需要的有多种特殊视觉（如光照、透明、纹理、阴影）的三维图形。OpenGL库的实际开发者通常是各大显卡厂商。Khronos Group公开提供了所有OpenGL的规范文档，可以从这里看到OpenGL3.3规范文档。OpenGL具有很好的跨平台性，2012年8月已经更新到4.3版本。 OpenGL组成OpenGL主要由OpenGL基本函数库、OpenGL实用函数工具包、WGL库（OpenGL的Windows扩展库） OpenGL的基本函数库：主要包括三个：OpenGL核心库、OpenGL实用库、OpenGL辅助库。 OpenGL核心库（GL）这部分函数常用于常规的、核心的图形处理，是OpenGL的核心部分；包含300多个函数，函数名前缀都是”gl”。 OpenGL实用库（GLU）（Utility）这部分函数通过调用核心库的函数，为开发者提供相对简单的用法，实现一些较为复杂的操作。如绘制茶壶等简单形体。包含大约50个函数，函数名前缀都是”glu”。 OpenGL辅助库（GLAUX）（Auxiliary）这部分函数提供窗口管理、输入输出处理以及绘制一些简单的三维物体，包含约30个函数，函数名前缀都是”aux”。 OpenGL实用函数工具包（GLUT：OpenGL Utility Toolkit）：由Mark Kilgard开发。主要提供窗口系统操作功能，如创建窗口、鼠标和键盘输入、菜单、事件驱动等等。包含大约30个函数，函数名前缀都是glut。【注】：glut中的窗口管理函数不依赖于操作系统，可以在所有的OpenGL平台上运行。 WGL库：OpenGL对窗口系统的扩展 用于连接OpenGL和Windows，在Windows平台上设置OpenGL环境 并不是所有函数前缀都是”wgl” 只能在Windows上运行 OpenGL主要功能 基本几何形状绘制点、线段、多边形、Bezier曲线、简单形体等。 属性设置颜色、线型（实、虚等）… 变换几何变换：平移、旋转、缩放；投影变换：正投影、透视投影 交互键盘和鼠标 &nbsp; OpenGL的两种开发模式OpenGL的两种开发模式是：快速模式和core-profile（核心模式）。 在OpenGL3.2版本以前，都是使用快速模式，也叫fixed function pipeline，固定函数输送管道，顾名思义，快速模式是一种简单易用的绘图方式，容易使用容易理解，但是效率低下，而且大多数功能都被封装了，开发者难以获得更多的图形控制权。所以从3.2版本开始，快速模式不建议被使用了，出现了core-profile（核心模式），它是OpenGL规范的一部分，移除了所有过时的不建议使用的功能。当使用core-profile模式时，OpenGL会强制让我们使用现代函数；如果使用了过时的或不建议的函数，是会报错的。 使用core-profile，需要开发者真正懂得OpenGL，而且还要掌握图形编程，难度是提高了，但是却提供了更高的灵活性和效率，还能让我们更好的理解图形编程。由于之后版本的OpenGL都是以3.3为基础的，核心机理并没有变化，而且大多数开发情况下都需要支持较低的显卡，低显卡可能不支持最新版的OpenGL，所以我们也使用OpenGL3.3版本了。&nbsp; OpenGL特性：支持扩展OpenGL是支持扩展的。如果显卡厂商在某个时候推出了一个新技术或渲染优化， 那么图形开发者就可以通过扩展来直接使用该新技术，而不需要等待新版本的OpenGL发布。事实上，当一个扩展被证明很流行或很有用时，它就会变成未来OpenGL的一部分。 一般使用扩展的代码如下：12345678if(GL_ARB_extension_name) //GL_ARB_扩展名&#123; //执行硬件支持的新特性&#125;else&#123; //不支持该扩展，使用老办法&#125; &nbsp; OpenGL的本质OpenGL本身其实是个大状态机，也就是说它定义了一大堆OpenGL该做何操作的变量。 OpenGL的状态通常称为OpenGL环境（context）。我们通常都是设置一些选项，操作一些缓冲，来改变它们的状态（即环境），然后使用当前环境做渲染。 使用OpenGL时，会遇到多种状态改变函数，这些函数会改变环境；还会遇到多种状态使用函数，这些函数是基于当前状态来执行一些操作。&nbsp; OpenGL的库是用C写的，所以OpenGL无法表示诸如对象这些在更高级语言中才有东西。于是OpenGL开发了几种自己特有的抽象概念，对象就是其中一个。 OpenGL中的对象OpenGL的对象是一些可选项（即变量）的集合，是OpenGL状态的一部分。那么OpenGL中的对象怎么定义和使用呢？ OpenGL中定义对象的流程大致如下：123456789101112131415161718192021//OpenGL的状态struct OpenGL_Context&#123; ... object* object_Window_Target; ...&#125;;//创建对象GLuint objectId = 0;glGenObject(1, &amp;objectId);//把对象绑定到目标上glBindObject(GL_WINDOW_TARGET, objectId);//为当前绑定到GL_WINDOW_TARGET的对象设置选项glSetObjectOption(GL_WINDOW_TARGET, GL_OPTION_WINDOW_WIDTH, 800);glSetObjectOption(GL_WINDOW_TARGET, GL_OPTION_WINDOW_HEIGHT, 600);//把目标绑定的对象恢复为默认（解绑）glBindObject(GL_WINDOW_TARGET, 0); 上面的代码是在OpenGL中会经常遇到的工作流。通过glGenObject函数创建一个对象，保存到后台内存中，并且用一个无符号整数来表示这个对象，相当于是给这个对象起了个名字（对象id，就像人的身份证号），然后把这个名字（整数）存入变量objectId中。接着用glBindObject方法把对象绑定到一个目标上（代码中是把目标定为了GL_WINDOW_TARGET）。再下一步就是设置目标的选项（这些设置会被保存到对象中），最后把目标绑定的对象id设置为0，即解绑对象。至此，便完成了对一个对象的属性设置。 【注】： 上面的代码只是在描述OpenGL的操作原理，并不是OpenGL中的实际函数，只是伪码。 当使用OpenGL时，建议使用OpenGL定义的自由类型。在写float时在前面加GL；int、char、bool等等同样处理。应为不同的操作系统可能对于各自的类型有不同的内存布局，而OpenGL的GL自有类型的内存布局是跨平台的。所以使用OpenGL的自有类型可以保证我们的应用可以跨平台。 好像还有点懵，这个对象有何意义？打个比方，上面对对象的定义流程就好像是：拿出来一张纸，先给它编个号（对应创建对象），说这是第一张纸，然后拿这张纸去找到一个橡皮泥（对应绑定目标），说我要把这个橡皮泥变成什么什么样，然后在纸上画出梦想中的橡皮泥（设置选项），橡皮泥捏好了以后，就用不上这张纸了（解绑），但是还可以根据这张纸（对象）再去捏出很多一模一样的橡皮泥（目标）啊！不用再去找张纸画画了，这就是对象的好处。&nbsp; 下面来看看，OpenGL环境应该咋配置。先看VC++6.0下的： VC6.0下的OpenGL环境配置 使用OpenGL辅助库GLAUX时的环境配置： 打开工程，工程 → 设置 → 连接 → 分类选输入 → 在对象/库模块文本框中加上opengl32.lib glu32.lib glaux.lib（注意用空格分开） → 确定。如下图所示： Windows平台下的源文件需要加上以下头文件： 1234#include &lt;window.h&gt;#include &lt;GL/gl.h&gt;#include &lt;GL/glu.h&gt;#include &lt;GL/glaux.h&gt; 一般还需要：#include &lt;stdio.h&gt;、#include &lt;stdlib.h&gt;、#include &lt;math.h&gt; 使用OpenGL实用函数工具包GLUT时的环境配置： 文件拷贝（这三个文件百度很容易找到）：头文件glut.h拷贝到：\VC6.0安装目录\VC98\Include\GL目录下连接库glut32.lib拷贝到：\VC6.0安装目录\VC98\Lib目录下运行库glut32.dll拷贝到：C:\Windows\SysWOW64目录下（这时64位系统下的，如果是32位系统应该拷贝到：C:\Windows\System32） 打开工程，工程 → 设置 → 连接 → 分类选输入 → 在对象/库模块文本框中加上opengl32.lib glu32.lib glut32.lib（注意用空格分开） → 确定。如下图所示： 在源文件里加上头文件：#include &lt;GL/glut.h&gt; 【注】：OpenGL不需要单独下载安装，因为OpenGL是跟着驱动走的，只要装了显卡驱动，一般都会有OpenGL的。&nbsp; 但是原生的OpenGL不支持窗口管理、跨平台等功能，所以就有了很多热心人写了工具来支持这些功能，比如glut、glfw等等。 它们都是一些函数库，这些库免去了所有跨平台的问题，同时也提供了窗口、OpenGL环境等渲染所需的功能。比较流行的库主要有GLUT、SDL、SFML、GLFW。但是glut太老了，最后一个版本都是90年代的。这里我们主要用GLFW。 GLFWGLFW（OpenGL For Window）是一个轻量级的、开源的、跨平台的library，是一个跨平台的OpenGL应用框架，支持OpenGL和 OpenGL ES，用于管理窗口、读取输入、处理事件等，并且可以给我们创建一个OpenGL环境。 下面将介绍GLFW的构建过程。 构建GLFW 下载GLFW源文件GLFW可以从官网下载。当然是可以直接上面已经编译好的二进制文件，但是反正它有源码了，我们自己来编译一把，体验多多。而且使用源码编译出来的glwf库，可以完美适应自己的CPU/OS，编译好的二进制库就不一定了，所以先下载源码把（如果是下载编译好的二进制文件，尽量下32位的，64位可能会有很诡异的错误）。 但是从源码编译也有一个问题：不是所有人的IDE（ Integrated Development Environment）都是相同的，这就意味着用自己的IDE编译出来的库或其他文件可能别人并不能用，项目整合时会出现不兼容。比如有的用VS，有的用XCode，在VS上面写的项目要与和在XCode上面写的项目进行整合，但是IDE不同，很多项目文件会不兼容，比较原始的办法就是把VS上的源文件一个一个复制到XCode上，再在XCode上编译（或者相反），如果工程很大源文件很多，这样做是很要命的。而CMake可以根据源文件和一些简单的配置信息，生成对应OS下的IDE的项目文件，比如可以在用CMake把VS下的源文件直接整体编译为XCode项目，然后就可以直接和别人的XCode项目进行整合，还是很节省效率的。 CMakeCMake是一个可以根据源文件生成多个IDE下的项目/解决方案的工具（CMake可以从这里下载），我用的是Win32-x86 Installer。 安装完成后进入\bin文件夹选择cmake-gui.exe，再分别选择源码文件夹和用于生成项目的目标文件夹（需要自己新建一个文件夹），如下图：点击Configure按钮，CMake会要求选择目标IDE环境（即想要生成哪种IDE下的项目/解决方案），由于我用的是VS2015，所以选择了VS 14 2015，如下图：点击finish， 当出现configuring done后，点击generate，出现generating done以后，在新建的build文件夹内就可以看到生成的项目文件了。我的文件夹如下图所示： 编译但是这些项目文件中还没有Debug文件夹，无法拿到我们进行OpenGL编程所需要的库文件，那么打开GLFW.sln编译一下把，在VS编辑器菜单上点击生成/生成解决方案（Build/Build Solution），然后编译好的库glfw3.lib就会出现在build/src/Debug文件夹内了。接下来把这个库链接到项目上，就可以进行OpenGL编程了。 链接在链接到项目之前，得让IDE能够找到该库文件在哪里。新建一个将要写入OpenGL代码的VS项目，建好后在‘解决方案资源管理器’中右键项目名称，点击属性，在VC++目录（VC++ Directories）中点击包含目录（Include Directories），添加glfw源码的include文件夹。再点击库目录（Library Directories），添加glfw3.lib。现在VS能找到所需要的文件了。我添加的如下图（我是把包括后面glew要用到的文件一起放在文件夹内的，然后直接添加的文件夹。当然也可以向上面说的一个文件一个文件地添加）： 接下来是链接。还是在属性里点击链接器（Linker）/输入（Input），在附加依赖项（Additional Dependencies）中添加上glfw3.lib，当然还需要把OpenGL也链接上，添加opengl32.lib（只要有显卡驱动一般都会有opengl，opengl32.lib是安装VS时自带的）。如下图：&nbsp; 下面就可以在项目中使用OpenGL的函数了。其实OpenGL只是一种标准/规范，具体怎么实现要看驱动怎么来实现这种显卡支持规范（通俗点说就是提供接口函数），由于存在着很多不同版本的OpenGL驱动，不能够在编译的时候（compile-time）就确定静态链接哪个OpenGL函数，需要在运行时（run-time）指定所需要的函数地址，然后把地址存储在函数指针中以备后用（有点像先声明后定义）。在Windows中类似如下代码段：1234567//定义函数原型typedef void(*GL_GENBUFFERS)(GLsizei, GLuint*);//寻找函数并分配给它一个函数指针GL_GENBUFFERS glGenBuffers = (GL_GENBUFFERS)wglGetProcAddress("glGenBuffers");//现在可以正常使用OpenGL函数了GLuint buffer;glGenBuffers(1, &amp;buffer); 如你所见，想使用一个OpenGL函数太麻烦了，每个函数都得先被声明。不过为了解决这个问题，一个工具GLEW应运而生。&nbsp; GLEWGLEW（OpenGL Extension Wrangler Library）是一个跨平台的C++扩展库，基于OpenGL图形接口。由于目前Windows只支持OpenGL1.1的函数，但是现在OpenGL都已反正到4了，要使用这些OpenGL的高级特性，就必须下载最新的扩展，除此之外，不同的显卡公司，也会发布一些只有自家显卡才能支持的扩展函数。如果我们想要使用这些函数，就不得不去寻找最新的glext.h（glext.h使我们可以调用常见的更高版本的OpenGL函数，但是必须在源文件中包含此头文件，并将显卡驱动更新到最新版，glext.h可以在这里找到，不保证最新，也有可能会有些函数接口找不到）。但是有了GLEW扩展库，就再也不用担心找不到这些函数的接口了，因为GLEW能自动识别你的平台所能支持的全部OpenGL高级扩展函数。也就是说，只要包含一个glew.h头文件，就能使用gl、glu、glext、wgl、glx的全部函数。并且GLEW支持目前流行的各种操作系统。当然了，我们之前得问题也迎刃而解了，可以直接使用函数，不用先声明了。下面来看看GLWF环境的搭建。&nbsp; 构建GLEW由于GLEW是一个库，所以我们还是需要把它的库文件和头文件链接到我们的项目中。GLEW可以从中这里下载。当然还是可以和前面GLFW一样从源码编译出lib库文件。这里我直接下载编译好的二进制文件Binaries了。下载好后找到\glew-2.0.0-win32\glew-2.0.0\lib\Release\Win32路径下的glew32s.lib文件，把这个文件添加到项目属性的库目录里，再把\glew-2.0.0-win32\glew-2.0.0路径下的include文件夹添加到项目属性的包含目录里（我是把这里glew和之前glfw的库文件和头文件放在了两个新建文件夹下：一个Libs文件夹、一个Includes文件夹，再把这两个文件夹添加到项目属性的相应目录里。人懒省事~。可以参考前面GLFW标题后链接标题下的第一张图。） 这里使用的是GLEW的静态库，即glew32s.lib。而且GLWF3默认也是被编译为静态库的。 如果使用GLEW的静态库，必须在包含GLEW之前定义一个预处理变量GLEW_STATIC。如下：12#DEFINE GLEW_STATIC#include &lt;GL/glew.h&gt; 如果想要使用GLEW的动态库，需要移除对GLEW_STATIC的定义，而且需要把.dll复制到二进制代码所在的文件夹里。&nbsp; 测试环境是否构建成功在自己新建的并且构建好环境的项目中，写入如下代码：1234567891011121314151617// GLEW#define GLEW_STATIC#include &lt;GL/glew.h&gt; // GLFW#include &lt;GLFW/glfw3.h&gt;int main()&#123; glfwInit(); glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE); glfwWindowHint(GLFW_RESIZABLE, GL_FALSE); return 0;&#125;如果出现了很多未定义引用错误，就是还没有构建成功了~。 【注】： 静态链接库是会在编译的时候整合到我们的二进制文件中，这样做的好处是不必保持跟踪这额外的文件，只需要发布单独的二进制文件。缺点是最后的可执行文件会变得更大，而且当一个库有一个更新的版本时需要重新编译整个应用程序。 动态链接库就是.dll或.so文件，库的代码是与我们的二进制代码分开存在的，它可以使最终的可执行文件更小，更新的时候也更容易，不足之处是必须在最终的应用程序中发布dll文件。&nbsp; 参考文献：LearnOpenGL]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>OpenGL配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程的描述与控制]]></title>
    <url>%2F2016%2F10%2F14%2F%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8F%8F%E8%BF%B0%E4%B8%8E%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[程序的并发执行程序的并发执行：宏观上，用户看到多个程序同时执行，向前不间断地推进；微观上，任意时刻一个CPU上只能有一个程序在执行。程序不加控制地并发执行的结果可能不是唯一的，举个例子： ex：counter是全局变量，初值为0，现进程p1和进程p2都对counter加1：12进程p1：...;counter=counter+1;...进程p2：...;counter=counter+1;... 但是我们知道这只是高级语言的程序语句，计算机却是逐指令进行执行的，所以还需要把上诉高级语言转换成编译后的基本指令序列：（其中r1和r2是两个通用寄存器）1234进程p1：r1=counter; //将counter对应内存的数据送寄存器r1r1=r1+1; //累加1counter:=r1; //将r1中的累加结果送往counter对应的内存中 1234进程p2：r2=counter; //将counter对应内存的数据送寄存器r1r2=r2+1; //累加1counter:=r2; //将r1中的累加结果送往counter对应的内存中 当进程p1和进程p2逐指令并发执行时，若指令执行顺序如下：123456r1=counter;r1=r1+1; r2=counter; r2=r2+1; counter:=r2;counter:=r1; 则执行后的结果是counter等于1，显然这不是我们想要的结果，原因就在于程序的并发执行上。若指令顺序如下：123456r1=counter;r1=r1+1; counter:=r1;r2=counter; r2=r2+1; counter:=r2; 则执行后的结果是counter等于2。而程序并发执行时，两个程序的指令谁先执行谁后执行是不确定的，也就造成了程序并发执行时结果的不唯一性。 进程的描述因为并发执行的程序可能是同一个程序在不同数据集合上的执行，也可能是不同的程序在不同的数据集合上的执行，它们共享系统资源，所以在并发执行中，仅仅用程序来作为描述单位是不够的，还应该加上程序的数据集合。所以，进程破壳出生了。 什么是进程 简单的定义：进程是程序在一个数据集合上的运行过程。 详细的定义：进程是由正文段、用户数据段、系统数据段共同组成的一个执行环境（正文段存放被执行的机器指令；用户数据段存放进程在执行时直接进行操作的所有数据；系统数据段存放程序的运行环境，是进程实体最重要的一部分）。 进程和程序的比较 程序是静态的，进程是动态的 。程序是一组二进制代码，而进程对应着程序执行的过程，程序执行过程中运行环境是不断变化的。 几个进程能并发地执行相同的程序代码，同一个进程也能顺序地执行几个程序（进程和程序是多对多的关系）。 进程控制块PCB操作系统中那么多进程，用什么来唯一标识呢？答案是进程控制块（PCB，Process Control Block），一种操作系统管理进程所使用的数据结构。进程控制块用于描述进程及控制进程运行所需的全部信息。每个进程都有PCB，它是操作系统感知进程存在的唯一标志。 那么进程控制块PCB中包含哪些内容呢？ 进程标识符信息PID（Process Identifier）PCB之所以能够唯一标识某个进程，就是依赖于PCB中的进程标识符，它用于唯一标识一个进程。当然出于其它一些方面的性能考虑，PCB中同时存有本进程的标识符、其父进程的标识符、子进程的标识符。 处理机状态信息所有进程共享处理机CPU，当一个进程需要被暂停执行，交出CPU使用权时，需要把当前进程CPU寄存器的值保存到内存中（即PCB中）（保存现场），以防止被覆盖，以便该进程再次获得CPU时，能从内存（PCB）中加载寄存器的值，恢复进程上次被暂停时的CPU环境，使进程能够从上次被中断处继续执行。那么需要保存的CPU状态信息有哪些呢？ 通用寄存器。用户程序可以访问的寄存器，用于暂存信息。 指令计数器。里面存放了CPU要访问的下一条指令的地址。 程序状态字PSW。里面含有状态信息，如条件码、执行方式、中断屏蔽标志灯。 用户栈指针。每个用户进程都有一个或多个与之相关的系统栈，用于存放过程和系统调用参数及调用地址。栈指针指向该栈的栈顶。 进程调度信息 进程状态信息 进程优先级 进程调度所需的其他信息 事件 进程控制信息 程序和数据的地址 进程同步和通信机制 资源清单 链接指针 进程的组织方式系统中那么多进程，它们是如何联系在一起的呢？也就是说操作系统是通过怎样的方式把它们聚在一块的？我们先来想想，需要把所有进程拿出来连在一起吗？这当然是很不划算的，因为有的进程是很大的，而且在地址空间上不一定连续，这样做会有很大的时间空间上的开销。上面讲了进程控制块PCB可以唯一标识一个进程，所以把PCB组织在一起就够了。 链接方式把系统中具有相同状态的进程的PCB用其中的链接字链接成一个队列，如下图所示： 索引方式系统根据所有进程的状态，建立几张索引表，索引表的每一个表项指向一个PCB的物理块，如下图所示： 进程的三种基本状态 就绪状态就绪状态是进程一旦获得CPU就可以投入运行的状态。把多个处于就绪状态的进程组织在一起，形成一个或多个就绪队列。 执行状态执行状态是进程获得CPU正在运行的状态。（单CPU系统中，任意时刻只会有一个进程处于执行状态） 阻塞状态阻塞状态是进程由于等待资源或由于某个事件的发生而暂停执行的状态。把多个处于阻塞状态的进程组织在一起，形成一个或多个阻塞队列。 【注】：新创建进程的状态一般被设置为就绪状态 三种基本状态之间的转换关系如下图所示： 进程的控制 进程的创建创建新进程包括在主存中为进程分配地址空间、建立操作系统用于管理进程的数据结构（如进程控制块）等操作。在Linux系统中，除了0号进程（swapper进程）外的其他进程都是由其父进程创建的。调用创建新进程的系统调用来创建进程的一般步骤为： 申请空白PCB 为新进程分配资源 初始化进程控制块 将新进程插入就绪队列 Linux2.6.11中创建进程的常用系统调用有fork()。 进程的阻塞进程阻塞的简化过程大致如下： 暂停进程的执行，将进程的状态改为阻塞状态 将进程插入相应的阻塞队列 转进程调度程序。重新进程进程调度 进程的唤醒进程唤醒的简化过程大致如下： 将进程从阻塞队列中移除 将进程状态由阻塞状态改为就绪状态 将进程插入就绪队列 进程的终止进程终止的简化工程大致如下： 从进程PCB中读进程状态 若进程正在执行状态，则终止进程的执行 若进程有子孙进程，则在大多数情况下需要终止其子孙进程 释放资源 将终止进程的PCB移出（从相应的PCB组织方式中移除） 【注】：如果一个进程终止，它的所有子进程也被终止，这称为级联终止，通常是由操作系统进行的。在Unix系统中，如果父进程终止，那么其他所有子进程会把init进程作为它们新的父进程。 线程（Thread） 要线程何用？由于进程所占的空间太大，并且独享它占有的所有资源，在进程创建、撤销、切换时，都有较大的时空开销，会降低并发程度。所以，引入了线程。让线程作为独立调度和分配的单位，线程不独立占有资源（少量基本资源还是要独占的，如程序计数器、寄存器组、栈等），而是与其他线程共享同一进程的资源，减小了系统时空开销，提高了操作系统的并发程度。 什么是线程线程只是比进程更小的执行单位，是被系统独立调度和分派的基本单位。线程和进程及其相似，包括状态、分类、调度切换等等都和进程是一样的。所以不再赘述。【注】： CPU只能感知到内核级线程的存在，而感知不到用户级线程的存在。所以： 对于用户级线程，CPU的调度单位还是进程；而对于内核级线程，CPU的调度单位是线程 当用户级线程被阻塞时，对应的整个用户级进程也会被阻塞；而内核级线程被阻塞时，对应的内核级进程不会被阻塞，OS内核可以去调度同一个内核级进程内的其他内核级线程 内核级线程进行系统调用只阻塞该线程，而用户级线程进行系统调用要阻塞线程所属的进程 内核级线程的CPU时间以线程为单位进行分配，每个线程独享一个CPU时间片；而用户级线程的CPU时间以进程为单位进行分配，同一进程里的多个线程共享一个CPU时间片 由于用户级线程的调度与切换不需要OS内核的参与，所以用户级线程切换比较快；而内核级线程在调度和切换时需要进行用户态/内核态的切换，所以内核级线程切换比较慢 线程控制块TCB采用链接方式来组织，没有PCB的索引方式 进程之间的通信必须采用OS提供的进程间通信机制，而同一进程中的各线程间可以通过直接读写全局变量来进行通信，无需操作系统的参与 由于一个进程内的多个线程共享资源，所以一个线程对资源的任何修改，都会影响到同一个进程中的其他线程的执行环境。所以，需要对各种线程的活动进行同步，保证多个线程以互斥的方式访问临界资源，使它们互不干扰。如本文开头的加法例子，如果不对共享的临界资源counter加以访问控制，任由线程随意并发执行，则可能会导致错误结果。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>进程的描述与控制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统内核（中断、时钟管理、系统调用）]]></title>
    <url>%2F2016%2F10%2F14%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8%2F</url>
    <content type="text"><![CDATA[操作系统内核是指大多数操作系统的核心部分，是把一些执行频率高的模块常驻内存，它是计算机硬件的第一次扩充。操作系统内核一般包括下述功能： 支撑功能。包括中断处理、时钟管理、原语操作（也叫原子操作，是一组在执行过程中不能被中断的操作）等。 资源管理功能。包括进程管理、存储器管理、设备管理等。 中断 中断是什么？中断时改变处理器指令执行顺序的一种事件。该事件与CPU芯片内外部硬件电路产生的电信号相对应。计算机在执行程序的过程中，若出现中断，计算机将停止现行程序的运行，转向对这些中断事件的处理，处理结束后返回被中断处，继续向下执行。 为何需要中断？引入中断机制前，当在CPU上执行的程序遇到I/O时，CPU采取反复轮询的方式检测本次I/O是否结束，在轮询的过程中CPU不能完成任何更有效的工作，这是对CPU相当大的浪费。引入中断机制后，一个正在执行的进程p1请求I/O后，CPU启动这次的I/O，然后CPU可以先去执行其他进程（而不用去轮询I/O是否结束），当I/O完成后，通过中断机制使CPU获得进程I/O结束的信息，转中断处理，处理完毕后返回到原来进程p1断点处，继续向后执行。可以看到，在p1进程的I/O过程中，CPU不用去轮询I/O是否结束，而可以转去并行执行其他的进程，这无疑很大程度上减少了CPU的浪费。 中断类型中断分为同步中断（也叫内部中断或异常）和异步中断（也叫外部中断）。 同步中断（（程序）内部中断或异常）同步中断是当指令执行时由CPU控制单元产生的。之所以称为同步中断，是因为只有在一条指令终止执行后CPU才会发出中断，如除法错误、调试、溢出、浮点出错等。 异步中断（外部中断）异步中断是由其他硬件设备依照CPU时钟信号随机产生的。外部中断又可以分为外部可屏蔽中断和外部不可屏蔽中断。 外部可屏蔽中断。这种中断是由I/O设备产生的。有两种方式可以屏蔽中断：一时在Intel80X86的CPU上，把EFLAGS寄存器的IF标志置0，表示关中断，此时CPU忽略所有可屏蔽中断；二是通过对PIC编程来禁止IRQ，即可以告诉PIC停止对给定的IRQ线发布中断。 外部不可屏蔽中断。这种中断是由紧急事件引起的，如硬件故障。 引起中断的原因有哪些呢？ 人为设置中断。在程序中认为设置中断。 程序性事故。如计算中出现除数为0等情况。 硬件故障。 I/O设备。I/O设备启动后，一旦其准备就绪或完成一次输入/输出，便向CPU发出中断请求。 外部中断。如用户通过键盘来中断现行程序。 中断响应有哪些条件吗？对于可屏蔽中断，开中断是响应中断的前提。例如，在Intel80X86 CPU上，EFLAGS寄存器的IF标志置1时表示开中断。 什么时候响应中断呢？前面我们知道，内部中断是发生在指令执行完毕之后，外部中断是发生在CPU时钟信号之后，而对于外部中断，CPU每执行完一条指令都会检测是否有外部中断信号到来。若有则转中断处理。 单重外部中断的处理过程CPU在反复执行指令的过程中，每执行完一条指令，都会去检测是否有外部中断信号到来。如果检测到有中断信号，则转中断处理过程。 保护断点。把当前要执行的下一条指令的地址保存到内存中，以便中断返回时能把这个地址恢复到程序计数器PC中，使被中断的程序从断点处开始继续执行。 关中断，转中断处理程序，在中断处理程序中保护现场。也就是把相关的硬件上下文信息（中断返回恢复被中断程序的执行时，需要写回CPU寄存器的值）保存到内存中。 根据中断向量到中断向量表中找到中断例程的入口地址。 执行中断例程，完成本次中断处理工作。 恢复现场，开中断，CPU返回断点处继续执行被中断的程序。 怎么找到中断服务子例程？ 中断向量（中断类型号）中断向量是对不同的中断源到来的信号编号，是一个无符号整数（0~255）。不可屏蔽中断和异常的中断向量是固定的，而可屏蔽中断的向量可以通过对中断控制器编程来改变。可屏蔽中断控制器的IRQ线是从0开始按顺序编号的，因此，第一条IRQ线通常表示成IRQ0。与IRQn关联的Intel缺省向量是n+32。通过向中断控制器端口发布合适的指令可以修改IRQ和向量之间的映射。 中断描述符表（Interrupt Descriptor Table,IDT，又叫中断向量表）它是一个系统表，每一个中断或异常都在表中有唯一对应的表项，其中存有与中断或异常处理子例程入口地址相关的信息。在Linux里，IDT的每个表项占8个字节（64位）。IDT表的起始地址由操作系统执行lidt汇编指令并存放在idtr CPU寄存器中。 中断子例程的入口地址相关信息在内存中的地址=idtr中的起始地址 + 8 x 中断向量的值。 时钟管理 时钟有何用时钟是计算机系统的脉搏，很多计算机的活动都是由定时器测量来驱动的。计算机中当前时间显示功能、即时通讯等与时间相关的软件都需要时钟机制的支持。比如要编译一个很大的工程文件，不可能每次编译都去重新编译所有源文件，而是只编译修改过的那些源程序。判断方法是看a.c最后生成时间是否晚于a.obj的生成时间。 计算机系统中的时钟机制计算机系统中其实有两种时钟：RTC（Real-Time Clock）时钟和OS时钟。RTC时钟也叫CMOS时钟，是一块时钟芯片，靠电池供电，为计算机提供计时标准，是最原始、最底层的时间数据。OS时钟是产生于PC机主板上的定时/计数芯片，在开机时有效，由操作系统控制。计算机开机加电后，操作系统通过BIOS获取当前RTC时钟的值，来作为系统的初始时间。操作系统初始化后启用自己的时钟硬件（可编程间隔定时器PIT，Programmable Interval Timer）。PIT按照一定的频率产生时钟中断，来告诉内核又一个时间间隔过去了。RCT时钟和OS时钟关系如下图所示： OS时钟机制OS系统时钟主要有两个作用： 保存当前日期和时间，便于用户程序可以通过系统调用获取当前时间，同时也可以由内核把当前时间作为文件和网络包的时间戳 维持定时器，用来告诉内核或用户程序某一时间间隔已经过去了 OS时钟依靠时钟硬件（可编程间隔定时器）和时钟软件（时钟中断处理程序）来实现。下面简单介绍一下它俩： 可编程间隔定时器PIT（OS时钟硬件）主要有晶振、计数器、保持寄存器三部分构成。如下图所示：晶振按固定频率产生脉冲，每产生一次脉冲计数器值减1，当计数器值减到0时，产生一次时钟中断信号，再把保持寄存器的值送往计数器，使其恢复初始值。这样，PIT就每隔一定时间产生一次时钟信号了。 时钟中断处理程序（OS时钟软件）也叫时钟驱动程序。PIT每产生一次时钟中断信号，OS内核都要执行时钟中断处理程序，来完成如下功能 维护日期、时间 递减时间片并检查是否为0，防止进程运行超时 对CPU的使用情况记账 递减报警计数器 【注】：Linux OS时钟的时间基准是1970.1.1的凌晨0点 系统调用 什么是系统调用？操作系统内核中有一些预先定义好的模块，系统调用就是让用户程序去调用这些内核模块的接口。如C语言的getpid()函数实际上是调用了在内核态运行的系统调用sysgetpid()，来获得进程标识符。可以看出，系统调用和一般函数调用还是挺像的。 系统调用和一般函数调用的区别？先来看看用户态和核心态的概念：当一个进程在用户空间执行时，该进程便处在用户态；当一个进程在具有执行系统核心代码的权利时，该进程便处于核心态。那么系统调用和一般函数调用的区别是什么呢？ 系统调用运行在核心态，一般函数运行在用户态 用户态进程执行系统调用时（调用前进程处于用户态，调用时进程处于核心态，调用后进程处于用户态），当前进程会被中断，由系统去找到相应的系统调用子程序，并且在核心态下执行，而一般函数调用是不需要中断处理的。 Linux中的一些系统调用 fork：创建一个新进程 clone：按指定条件创建子进程 execve：运行可执行文件 exit：中止进程 getpgid：获取进程组标识号 open：打开文件 creat：创建新文件 close：关键文件描述字 read：读文件 write：写文件]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>OS内核</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BIOS和微机操作系统的启动过程]]></title>
    <url>%2F2016%2F10%2F09%2FBIOS%2F</url>
    <content type="text"><![CDATA[什么是BIOS？BIOS，Basic Input Output System基本输入输出系统，是最接近硬件的软件之一，是固化在计算机主板上的ROM芯片中的一组程序，直接对计算机系统中的输入输出设备进行硬件级的控制，为其他软件程序与硬件设备之间建立连接提供了基础，包含基本的中断服务程序、系统设置程序、加电自检程序和系统启动自举程序。BIOS程序是计算机开机加电后第一个开始执行的程序，完成硬件检测及基本的设置功能，故BIOS为操作系统及其他自启动程序的开发和加载提供了接口，是计算机系统中最基础的系统软件。 BIOS的住处：BIOS芯片上面已经介绍过，BIOS程序被固化在ROM芯片中，所以保存BIOS程序的ROM加上其配套的电路就构成了BIOS芯片。BIOS芯片通常是一块32针的双列直插式长方形或正方形集成电路，表面贴有“BIOS”字样的标签，如下图所示：BIOS芯片根据其ROM存储器特点的不同，分为EPROM和EEPROM两种类型。 EPROM（Erasure Program Read Only Memory）可擦除可编程只读存储器，其芯片中央有一个透明的小窗口，通过这个小窗口可以使用紫外线光将芯片上保存的信息擦除掉（所以当不需要擦除时，就需要一块不透明的标签将已保存了信息的EPROM芯片的紫外线窗口封住）。在向EPROM写入内容时，必须先用紫外线擦除器将EPROM中的信息清除掉，即将EPROM中的每个信息存储比特单元都变成“1”状态。 EEPROM（Electricity Erasure Program Read Only Memory）电可擦除可编程只读存储器，在通常情况下，EEPROM也是只读的，当需要写入内容时，只要在指定的引脚上加一个高电压即可快速写入和擦除。 另外还有一种EEPROM就是现在主板上常见的FLASHROM（闪速存储器，闪存），其读写速度更快更可靠，而且使用单电压进行读写和编程，为便携式设备的在线操作提供了极大的便利，所以广泛应用在计算机主板上。 通常，在Intel486以及486以下档次计算机中使用的BIOS芯片基本上采用的是EPROM芯片，而586及以上档次计算机中使用的基本上都是EEPROM。 BIOS程序的组成前面已经介绍过，BIOS程序包括中断服务程序、系统设置程序、加电自检程序、系统启动自举程序。下面来看看这几种程序的详细介绍。 BIOS中断服务程序 什么是中断？中断是改变处理器执行指令顺序的一种事件，这样的事件与CPU芯片内外部硬件电路产生的电信号相对应。中断发生时，计算机停止现行程序的运行，转向对这些中断事件的处理，处理结束后再返回到现行程序的中断处，继续往下执行。 在哪里对中断事件进行处理的？CPU对中断的处理是转到中断服务程序来进行的 什么是中断服务程序？中断服务程序是系统开发者针对某种中断事件事先编写好的处理程序，并且把他们保存在内存的某个地址空间里。 那么怎么根据中断源找到相对应的中断服务程序呢？中断源在向CPU进行中断请求时，会告诉CPU一个中断类型号（在x86系统中是0~255之间的整数），每个中断类型号都会对应一个中断服务程序。那么怎么根据中断类型好去找它命中注定的中断服务程序呢？其实所有中断服务程序的入口地址（起始地址）都被保存在中断向量表（一维连续的一段内存空间）中，中断向量表的每一个表项的长度都是固定一样的。所以让中断类型号和中断向量表的表项依次一一对应不就行了嘛？根据中断类型 x 中断向量表项长度 + 中断向量表起始地址，就可以找到对应的表项了，然后再从里面取出中断服务程序的起始地址，跳转到该地址，就可以执行中断服务程序进行中断处理了。 BIOS包含哪些中断服务程序呢？显示服务程序（INT 10h）、直接磁盘服务程序（INT 13h）、键盘服务（INT 16h）等等。 这些BIOS中断服务程序可以为微型计算机软件和硬件之间提供可编程接口，是软件和硬件的中间桥梁。DOS、Windows等操作系统对软盘、硬盘、光驱与键盘、显示器等外围设备的管理就是建立在系统BIOS的基础上的。当然，程序员还可以直接调用BIOS中断服务程序。 BIOS系统设置程序如果你给自己的电脑装过操作系统，会知道当开机后狂按某个（F2、F12等等）按键时，会进入一些设置界面，这里其实就是一些BIOS系统设置。微型计算机中各部分组建的配置参数是放在一块可读写的COMSRAM芯片（简称CMON）中的，它保存着系统CPU、软/硬盘驱动器、显示器、键盘等部件的配置信息。微机关闭电源后，系统通过一块后备电池向CMOS供电以保持其中的信息。如果CMOS中关于微机部件的配置信息不正确，会导致系统性能降低和零部件不能识别，从而导致一系列的软硬件故障。在BIOS芯片中装有一个系统设置程序，用来设置CMOS中的各种参数。增加了新的部件或者要进行系统安装或升级时，一般都需要进行BIOS设置。【注】： BIOS设置和CMOS设置的区别CMOS是微机主板上一块特殊的CMOSRAM芯片，是存放系统参数的地方；而BIOS是一组程序，存储在主板上的EPROM或EEPROM芯片中。也就是说，通过BIOS中的系统设置程序其实是对CMOS参数进行设置。 POST加电自检程序为了保证计算机正常启动，微机在接通电源后，系统有一个对内部各个设备进行检查的过程，该过程是由一个通常称之为POST（Power On Self Test，加电自检）的程序来完成的。完整的POST自检过程包括了CPU、640K基本内存、1M以上的扩展内存、ROM、主板、CMOS存储器、串口、并口、显示卡、硬盘及键盘的测试。自检过程中如果发现有问题，系统将会给出提示信息或鸣笛警告。 BIOS系统启动自举程序在自己装操作系统的过程里，想想是不是有一步是让设置磁盘的优先级，如果优先级最高的是U盘，则接下来系统就会进入U盘里的操作系统映像，用U盘来装操作系统了。而这个查找优先级最高的硬盘驱动器并装载操作系统的过程，就是BIOS系统启动自举程序来完成的。BIOS系统启动自举程序的作用是在完成POST自检后，按照系统CMOS设置中的启动顺序搜寻硬盘驱动器及CDROM、网络服务器等有效的启动驱动器，读入操作系统引导程序，开始逐步完成操作系统内核的加载和初始化，完成系统的启动。 BIOS的基本功能从上诉对BIOS程序组成部分介绍，可以看出BIOS的基本功能有如下： 在微机启动过程中的自检及初始化。 提供程序服务处理。如磁盘读写、键盘读取、将文件输出到答应及等等。 提供硬件中断处理。 微机启动的过程 当按下电源开关后，电源开始向主板和其他设备供电。但是此时电压并不稳定，主板会认为电压并没有达到CMOS中所要求的电压，就会向CPU发出RESET信号（复位信号），当电压到大符合要求的稳定值时撤销复位信号，然后CPU立刻从基本内存的BIOS段读取一条跳转指令，跳转到BIOS的启动代码处，开始执行BIOS程序。 执行BIOS启动程序会进行加电自检POST。这个过程进行得很快，主要是检测关键设备（如电源、CPU芯片、BIOS芯片、基本内存等电路是否存在，供电情况是否良好等），如果发现了问题，系统喇叭会发出警报声音（更具警报声的长短和次数可以知道出现了什么问题）。 如果自检通过，系统BIOS会查找显卡BIOS，找到后会调用显卡BIOS的初始化代码，此时屏幕上会显示显卡的相关信息。 显卡检测成功后会进行其他设备的测试，通过测试后系统BIOS重新执行代码，并显示启动画面，将相关信息显示在屏幕上，然后进行内存测试，最后是短暂出现系统BIOS设置的提示信息，此时按下相应按键，可以对系统BIOS进行需要的设置，完成后系统会重新启动。 然后系统会检测系统的标准硬件（如硬盘、光驱、串行和并行接口等），检测完成后会接着检测即插即用设备，如果有的话就为该设备分配中断、DMA通道、I/O端口等资源，至此所有的设备都已经检测完了。 上面的检测都顺利完成后，BIOS会按照用户指定的设备顺序，依次从设备中找启动程序，以完成系统启动（如果首先是硬盘启动，则BIOS会检查硬盘的0面0磁道1扇区，若发现该扇区以0xAA55结束，则BIOS认为它是引导扇区。一旦发现引导扇区，BIOS会执行程序将其装入到内存地址0000：7c00处，然后跳转到该地址处执行这段引导程序代码，开始加载操作系统，BIOS将系统的控制权交给操作系统）。 简化的微机启动过程如下（结合我们平时的开机过程来理解）：按下电源开关，电源供电 → CPU通过基本内存的BIOS段，找到BIOS程序起始地址，执行BIOS程序 → BIOS进行POST加电自检 → 检测和初始化显卡，在屏幕上显示相关信息 → 内存测试 → 出现BIOS设置的提示信息 → 检测硬盘、串并行接口等标准硬件 → 检测U盘等即插即用设备并为其分配资源 → 按照设备启动顺序加载操作系统 → 将系统控制权交给操作系统。 【注】：当硬盘的多个分区中同时存在多个操作系统时，每个分区都会有自己的引导扇区，那么操作系统怎么知道应该加载哪个扇区呢？操作系统会先去执行0面0磁道0扇区的主引导扇区的代码，判断当前被激活的分区，然后加载激活分区的引导扇区，从而加载该激活分区的操作系统。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>BIOS和微机启动过程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统概述]]></title>
    <url>%2F2016%2F10%2F08%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[什么是操作系统操作系统（Operating System，OS）是一种复杂的系统软件，它提供计算机用户与计算机硬件之间的接口，并管理计算机软件和硬件资源。操作系统本身并不向用户提供功能，但是它为应用程序的运行提供平台，并使应用程序的编程变得简单、容易。 接口：两个不同组成部分的交界面。在计算机领域，接口分为硬件接口（如USB接口、串口、并口）和软件接口（如C语言中的函数调用printf()）。 操作系统必须要实现的两个功能： 与硬件部分相互作用，为包含在硬件平台上所有的低层可编程部件提供服务 为运行在计算机系统上的应用程序提供执行环境 操作系统的发展 无操作系统第一代计算机（1945-1955年）使用电子管作为主要的电子器件，用插件板上的硬连线或穿孔卡片表示程序，没有存储程序的内存，也就自然没有操作系统（因为操作系统是需要常驻内存的）。比如1946年诞生于宾夕法尼亚大学的第一台电子计算机ENIAC，它的每一个用户程序进入计算机和退出计算机系统都需要人工干预，计算机无法自动完成程序的加载和卸载，所以整个计算机系统处于“运行—因等待人工操作而暂停—运行”这样一种不能自动连续工作的状态。由于CPU长时间等待人工操作，造成CPU资源的严重浪费。 单道批处理系统第二代计算机（1955-1965年）使用的主要电子器件是晶体管，开始使用磁性存储设备，内、外存容量增加，出现了早期的单道批处理系统。单道批处理系统中有早期的操作系统（也叫监视程序）常驻内存，能够连续自动地读取磁带中的用户程序，但是内存中只能驻留一道用户作业，CPU和内存资源被用户作业独占。但是当程序执行到输入输出操作时，由于不需要CPU干预，并且内存中又只有一个程序在运行，所以CPU便空闲下来了，造成CPU的浪费。 多道程序系统为了解决上述问题，多道程序系统的最初想法是将内存分成几个部分，每一部分存放不同的作业，当一个作业等待输入输出操作时，另一个作业可以使用CPU；任何时刻，当一个作业运行完毕，操作系统会自动从外存读出另一个作业，装入空闲的内存区域运行。早期的多道程序系统不具有交互功能，称为多道批处理系统。 微机操作系统随着个人电脑的出现，微机操作系统应运而生。第一个微机操作系统是Intel的CP/M（Control Program for Microcomputer）（后由Digital Research重写，使之适用于多种微机），在微机操作系统市场风行了5年，称为最著名的8位机操作系统。20世纪80年代初，IBM进军个人电脑市场时，想要Digital Research为IBM的个人电脑编写16位操作系统，但是遭到了拒绝。可怜，这对Digital Research真的是一场肠子都悔青的商业决策。与此同时，另一位著名的商业天才风生水起，Gates从计算机制造商Seattle Computer Products手里购买了DOS（Disk Operating System），然后向IBM提供整套的DOS和BASIC。后来升级成MS-DOS（Microsoft Disk Operating System）。商业天才盖茨采取将MS-DOS与硬件捆绑销售的策略，站在蓝色巨人IBM的肩上，使MS-DOS成为微机操作系统的主流。后来受苹果Macintosh（麦金塔）的影响（很可能是抄袭~），1985年微软开始构建Windows操作系统，使之成为微机操作系统的主流（如今的微机操作系统还有Linux、Chrome OS、OS X等）。 实时操作系统随着计算机在机器人、航空航天、自动化控制等领域的应用，出现了各种实时系统。实时操作系统是支持实时计算的系统。实时计算是指计算的正确性不仅依赖于系统计算的逻辑结果，还依赖于产生这个结果的时间。应用于实时系统中的操作系统称为实时操作系统（实时系统也可以不使用操作系统）。 【注】： 单道批处理系统具有自动性、顺序性（将外存中的作业顺序装入内存运行）、单道性的特点，而多道批处理系统具有多道性、无序性（同时驻留在内存中的作业，其被调度的顺序和执行的进度无法预知）、调度性（多道程序系统必须具有作业调度和进程调度功能）。 分时系统运行多个用户通过终端同时使用计算机（通过类似时间片轮转的方法来实现），并且具有交互性，用户可以通过终端与系统进行广泛的人机对话。 操作系统的特征 并发并发是指两个或多个事件在同一时间间隔内发生。而并行是指多个事件在同一时刻发生。 共享系统中的资源可供内存中多个并发执行的进程共同使用。分为互斥共享和同时共享。 互斥共享：任意时刻一种资源只能被一个进程访问，当一个进程访问该互斥资源时，其他进程必须等待，直到资源被进程访问完毕，释放访问权。 同时共享：从宏观上看，资源可以被多个进程同时访问。例如对磁盘的访问，虽然在任意时刻只能有一个程序访问某个磁盘，但是多个程序可以在短时间内轮流访问该磁盘，就造成了在宏观上同时共享某资源的假象。 虚拟虚拟是指通过某种技术把一个物理实体变成若干逻辑上的对应物。例如虚拟CPU、虚拟内存、虚拟打印机，都是操作系统通过某种技术把少量的物理资源变成比物理资源多的逻辑资源。 异步异步是指进程以不可预知的速度向前推进。 操作系统的功能 存储器管理存储器管理的主要任务是为多道程序的运行提供良好的环境，方便用户使用存储器，提高存储器的利用率，以及能从逻辑上扩充内存。存储器管理主要有内存分配、内存保护、地址映射、内存扩充等。 内存分配：为每道程序分配内存空间，使它们“各得其所”，提高存储器的利用率，以减小不可用的内存空间，允许正在运行的程序申请附加的内存空间，以适应程序和数据动态增长的需要。主要有静态内存分配方式（实现分配好并且不再变化）和动态内存分配方式 （运行过程中根据进程的请求分配内存，内存中分区的大小和数量都是动态变化的）。 内存保护确保每道用户程序都在自己的内存空间中运行，互不干扰。可以采用界限存储器存放允许程序访问的地址区间的上限和下限值来实现内存保护。 地址映射在CPU之心改程序过程中访问内存时，把程序中的逻辑地址转换为物理地址（内存地址）。 内存扩充借助虚拟存储技术，从逻辑上扩充内存容量，使系统能够提供比物理内存大的容量。需要有请求调入功能（指令或数据不在内存时请求调入内存）和置换功能（请求调入时若内存空间不够，则要将内存中的一部分换出到外存，再调入当前需要的内若）。 进程管理主要包括进程控制、进程同步、进程通信、进程调度等。进程控制功能完成对进程的创建、撤销、唤醒、阻塞等；进程同步功能完成多个进程（以及线程）运行的互斥与协调；进程通信功能用来实现进程之间的信息交换；进程调度功能是从进程的就绪队列中选出一个进程，把处理机分配给它，并为它设置运行现场，使其投入运行。 设备管理主要完成用户的I/O请求，为用户分配I/O设备。 文件管理主要是对文件存储空间的管理、目录管理、文件读写管理和存取控制。 提供用户接口为了方便用户使用操作系统，操作系统向用户提供了用户与操作系统之间的接口。向最终用户提供命令行和图形接口，向程序员提供高级语言和操作系统之间的接口—“系统调用”。系统调用是操作系统实现的具有某种功能的程序模块。应用程序可以通过系统调用的接口，来使用操作系统实现的功能，获得操作系统内核的服务。 操作系统的体系结构简单的监控程序模型、单体结构模型、层次结构模型、客户/服务器模型与微内核结构、动态可扩展结构模型]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统概述</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网游流畅基础：帧同步游戏开发]]></title>
    <url>%2F2016%2F09%2F18%2F%E5%B8%A7%E5%90%8C%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[在现代多人游戏中，多个客户端之间的通讯，主要是同步多方状态。为了同步多方状态，主要有两个技术： 状态同步客户端发送游戏动作到服务器，服务器收到后，计算游戏行为的结果，然后以广播的方式下发游戏中各种状态，客户端收到状态后再根据状态显示内容。在回合制游戏中，大多都是这种方式 帧同步也是客户端发送游戏动作到服务器，服务器收到后并不计算游戏行为结果，只是转发所有客户端的动作（或者不需要服务器，客户端之间直接通过P2P技术发送游戏动作）。然后客户端根据收到的所有游戏动作来做游戏运算和显示。早期的IPX（Internetwork Parket Exchange Protocol，互联网数据包交换协议）网络游戏就是这种帧同步的方式，比如红色警戒、星际争霸和大量的支持网络连线双打的游戏机模拟器。 什么时候用状态同步，什么时候用帧同步？状态同步主要是依靠服务器来计算游戏状态，然后下发到客户端，而帧同步主要是依靠客户端自己来做游戏运算，服务器仅仅是做一个转发，甚至不需要服务器，客户端之间可以通过P2P方式来转发数据。 由于帧同步只是转发游戏行为，而不是游戏状态，所以要广播的数据量比状态同步要小很多，比较适合游戏行为非常频繁的动作类游戏，比如飞行射击、FPS（First Person Shooting Game，第一人称射击类游戏）、RTS（Real Time Strategy Game，即时战略游戏）这些游戏。因为这些游戏中的对象特别多，比如满屏的子弹，如果使用状态同步，那么服务器要广播的数据就很大了，但是如果用帧同步，则仅仅需要广播与玩家角色有关的动作即可，像在射击游戏中其余的满屏的子弹（这些都是有机器控制的，不是玩家控制的）都不需要广播数据了。这个时候帧同步的优势很明显。 反过来，如果游戏里有大量的玩家，那么帧同步和状态同步的差异就不明显了，因为与每一个玩家相关的动作都需要做广播。而且状态同步由于是在服务器上进行游戏运算，安全性会更高，比较容易防止外挂。 帧同步机制帧同步最重要的基础概念：相同的输入+相同的时机=相同的显示意思是每个客户端在同一时间收到的，来自网络中多个客户端的操作是一样的，就能够达到同步效果。 由于在同步中每个客户端的运算要绝对一致，所以不能依赖本地时间、本地随机数等等类似的操作，而应该是以来自网络的操作数据为主。所以，在游戏客户端引擎中的本地Update就不能再在每帧画面渲染前被调用了，因为它是依赖本地时间的。Update总不能省掉吧？因为它是游戏逻辑更新的主循环，没有它游戏就没法动了。既然Update是必须的，那么什么时候调用它才能保证同步呢？ 在一般的帧同步系统中，会有一个Relay Server负责广播所有客户端的数据，并且由于每个客户端不能依靠本地时间来驱动Update，只能依靠来自网络的数据。所以，Relay Server会每隔一定时间向所有客户端下发“网络帧”，当有玩家有输入的时候，把玩家的游戏操作数据填入到网络帧数据包中，再进行广播，如果没有玩家输入，则发送空（大部分是空的）的网络帧。当每个客户端收到网络帧的时候，就会调用一个UpdateByNet()函数来进行游戏更新。（UpdateByNet其实干的是和Update差不多的事，只是受驱动的对象变了，Update受本地CPU驱动，UpdateByNet受网络驱动。而且帧同步中Update函数依然存在，也会受CPU驱动执行，不过其中的大部分内容都挪到了UpdateByNet中，所以Update的更新不再会产生游戏逻辑的更新，UpdateByNet才会）。 显然网络帧的速度要比本地CPU帧速度慢很多，帧率会很低。那么怎么保证游戏流畅度呢？ 帧同步中如何保证游戏流畅 Delay Server每一个网络帧广播的数据应该要足够小，最好在一个 MTU（Max Transmission Unit ）以下，这样才能有效降低网络延迟。 为了让Delay Server每次广播的数据量小，一般要求每次客户端发送的数据应该小于128字节 一个减少客户端发送数据长度的方法就是：自己写序列化函数。一般的面向对象语言都带有把对象序列化和反序列化的功能，但是编程语言的默认序列化功能，为了实现一些高级功能（比如反射），会把很多游戏逻辑所不必要的数据也序列化了（比如对象类名、属性名）。所以我们可以自己针对特定的对象来编写序列化函数，来减少多余的数据，甚至能合并和裁剪一些数据项，以最小化数据长度。 另一个减少客户端发送数据长度的方法是：用整数代替浮点数。比如在游戏中所使用的位置数据，大多是浮点数，占了8个字节，其实往往我们并不需要这么高的精确度，所以可以考虑把浮点数变成整数，整数只占了4个字节，少了一倍的数据量。最简单的方法是把浮点数乘以1000或100然后取整（客户端接收到以后可以除以1000或100来还原，这样在保证整数的同时还能有一定的精确度）。 还有一个减少客户端发送数据长度的必要方法是：只有当客户端收到网络下行帧以后才发送一次上行的玩家操作，而不是每一个渲染帧（本地Update）都去发送。 玩家的网络可能会出现临时拥堵（网络抖动），也有可能中途会有玩家加进来，甚至游戏录像等等都会导致客户端收到一堆“过去时间”里的网络帧，无法即时处理。这时就要求玩家恢复正常状态后，要有处理这一堆网络数据的能力。最简单的办法就是加速播放（快进或者叫拉帧）：客户端收到网络帧处理完游戏逻辑后，在同一个渲染帧（本地Update）内，马上重复接收下一个网络帧（而不再是直到下一次Delay Server广播时才再次接收网络帧），然后又立即处理。这样往往能在一个渲染帧的时间内，加速赶上服务器广播的最新游戏进度（赶上其他正常玩家的当前游戏状态）。但是也有副作用，如果客户端积累的包太多（比如游戏已经开始10分钟，新玩家中途加入），客户端会因为在一个渲染帧内疯狂下载积累的帧同步包和快进运算，导致本地客户端长时间卡住。所以有时候会限制一个渲染帧内快进的次数，保证用户还是能看到活动的画面（虽然动的比较快但也总比一直静止好啊！）。如果帧同步包实在是太多，要快进的进度很多，那么就要采用“快照”技术了。 客户端在快进时，每个渲染帧会接收很多网络帧，因为每收到一个网络帧都会发送一次玩家操作数据，这回导致Delay Server广播的数据量很大，造成网络延迟。所以当某个客户端在快进时，应该禁止输入玩家输入，那么每次收到网络帧后由于没有玩家输入就不会再进行数据发送了。 为了提高实时性，一般使用UDP，而不是TCP，但是使用UDP又会带来丢包、乱序。所以，一般会采用冗余的方式，每个网络帧数据包其实还包含了过去2帧的数据，也就是说每次发3帧数据来对抗丢包，3个包里只要有一个包没丢就不会影响游戏。 Delay Server上还会保存大量的客户端上传的数据，如果客户端发现丢包或者乱序，就会发起一次“下载”请求，从 Delay Server上重新下载丢失或乱序的帧数据包（这可能会使用TCP）。 通过牺牲某些不重要的特性来提高游戏流畅度 牺牲一致性来交换流畅度。虽然帧同步的目标就是所有客户端都看到一致的显示，但是游戏内容很多，有一部分内容是可以容忍不一致的，飞机大战中，满屏的子弹是由机器控制的，加上子弹本身存在的时间也很短，所以这些子弹在不同的客户端上是可以不一致的；又比如几个玩家一起打电脑控制的怪物，玩家关心的是怪物被打死，而不会太在意其他玩家的出招是不是在自己电脑上滞后了几秒。这种情况下，就可以把可以容忍不一致的那部分游戏逻辑，从网络帧的UpdateByNet拿出到本地渲染帧的Update里。这样就算网络有些卡，但还是有很多东西是不会卡住的（与玩家有关的逻辑更新还是应该受网络帧驱动，不然就失去了同步的效果）。 牺牲实时性来交换流畅度。一般我们是希望玩家有输入后，从客户端把操作数据发出去，然后在收到下一个网络帧时就能立即得到响应。但是网络是不稳定的，什么时候能收到下一个网络帧是不确定的，如果网络快点，客户端响应得就快，网络慢点，客户端响应得就慢，这会造成同样的操作出现一会快一会慢的效果，像在跑酷游戏中，如果主角一会向前跑得蜗牛似的，一会又向前跑得很快，这是很诡异的。解决办法就是：收到网络帧数据包后，并不立即响应和处理，而是放入客户端的网络帧缓冲区内，客户端每隔一定时间从缓冲区中取出一个网络帧进行运算。当网络速度快时，会有比较多的网络帧被存放到缓冲区中，网络速度慢时，可能一段时间内都没有网络帧进入缓冲区，但是客户端依旧可以从缓冲区中取出网络帧（这些网络帧是在网络快时被缓存下来的），因为客户端从缓冲区取网络帧的频率是固定的，所以对数据的运算是匀速的，对游戏逻辑的更新也就匀速了。虽然在网络快时没有得到立即响应，牺牲了实时性，但是同时却换来了游戏的流畅性，平滑了对那些一会快一会慢的网络帧数据包的响应（其实原理类似于传输语音业务，可参考这篇文章）。 这种做法会让玩家感觉到一个固定的延迟：输入操作后，隔一定时间才会有反应。但起码这种延迟是可以固定的，是玩家可以预测的，方便玩家操作。（这个操作的感觉就好像玩家有了一定的”惯性”一样，按下跑并不会立刻跑，松开跑不会立刻停，但这个惯性的时间是固定的） 牺牲公平性来交换流畅度。这个特性和一致性的根源一致，玩家不希望对方因为网络好，电脑运行速度快就比自己先看到游戏的运行结果，比如在格斗对打游戏和RTS游戏里这是很不公平的。为了让网络、硬件不同的玩家能够公平游戏，经常会使用一种叫”锁步”的策略：每个客户端都定时（每N个渲染帧）发送一个网络帧到服务器，即使玩家没有任何操作也像心跳一样发送空数据帧，每个客户端要收到其他所有客户端的心跳帧才能开始一次逻辑运算和更新。这就是让所有客户端相互等待，如果有玩家卡了，其它客户端都能知道，然后让玩家停止输入来等待对方玩家恢复网络。 这种做法其实是牺牲流畅度的，一旦有玩家掉线了，其他所有玩家都会受到影响。为了减少这种对流畅度的影响，锁步的时候可以少锁一点，对方的”心跳帧”缺了若干帧（比如几秒）自己这里都还是能正常更新，能不公平地玩一会，如果这段时间内还是没有补齐所缺的”心跳帧”，才宣布锁住游戏等待对方玩家恢复网络。这就是通过牺牲公平性来叫交换流畅度。甚至在一些非PVP（玩家对战）的帧同步游戏中都不太需要这个公平性，因为不是和对方玩家实时对战的，并不关注对方是不是比自己先看到结果。 移动网络帧同步中自定义的UDP 为何要使用UDP而不是TCP呢？ TCP的慢启动算法不适合移动网络，移动网络信号时好时坏，使用慢启动会使数据包的发送速率经常在很低的段位，导致数据不能及时快速地到达对端 拥塞避免算法不适合移动网络主要原因是其考虑到网络的公平性及收敛性，并且AIMD 算法会使实时性大受影响，延迟明显提升 还有TCP协议用于重传的RTO的指数变化及拥塞算法的实现Nagle的缓存等，都是TCP并不太适合高实时性要求的游戏玩法的原因 实验表明，在弱网络环境下，UDP的RTT几乎不受影响，而TCP的RTT波动比较大，特别是受丢包率影响比较明显 基于UDP的FSP协议栈由于UDP是不可靠的，所以需要DIY自己的UDP。于是基于UDP实现一个自定义的协议栈，称为FSP（FrameSyncProtocol）。FSP的基本原理其实就是仿照TCP的ACK/SEQ重传机制，并且使用冗余重传，来实现传输的可靠性。使用冗余重传的好处是简化了麻烦的时序问题，并且收到的每个包都是顺序的。在网络拥塞时带宽利用率优于TCP，但流量会略微增加一些（好像也无法调节网络拥塞，因为它去除了TCP的拥塞控制机制，可能对于时好时坏的移动网络是比较适合的，因为网络不大会一直很差）。FSP图示如下： 客户端发Action1，服务器未收到 客户端新增Action2，发送给服务器的包同时包含Action1和Action2，并且seq=2 服务器确认并发送给客户端ACK=2的包 客户端由于某些原因（可能是网络延迟）未收到服务器ACK=2的确认包，新增Action3后，客户端则把Action1、Action2、Action3一起发送给服务器，并且seq=3 客户端收到了ACK=2的确认包，则把队列中的Action1、Action2删除，新增Action4后，把队列中的Action3、Action4一起发送给服务器，并且seq=4 实际上线测试中，FSP在弱网络环境下表现也是不错的 更多详细介绍，请看这篇文章]]></content>
      <categories>
        <category>游戏开发</category>
      </categories>
      <tags>
        <tag>帧同步</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法之查找]]></title>
    <url>%2F2016%2F09%2F17%2F%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[先来看几个概念 查找分为静态查找和动态查找。静态查找是只做查找操作，而动态查找是在查找过程中同时进行插入或删除。 查找算法主要分为： 顺序表查找顺序表查找就是按序从头找到尾，找到为止。时间复杂度为O(n) 有序表查找 折半查找核心思想：每次查找线性有序表(假定从小到大有序)的中间位置的记录，如果给定值小于中间记录，则在左半区查找；如果给定值大于中间记录，则在右半区查找。要求查找表是有序的顺序存储的线性表。代码如下： 插值查找核心思想：插值查找是折半查找的改良版，每次不再是查找正中间位置的元素，而是根据元素内容在最小值到最大值之间的比例，来查找区间里同比例的那个位置上的元素。插值计算公式如下：mid=low+(key-a[low])/(a[high]-a[low])*(high-low)。同折半查找一样，要求查找表示有序的顺序存储的线性表，而且需要表内元素值分布比较均匀，这样查找效率才会比较高。代码如下： 斐波那契查找(黄金分割法查找)斐波那契数列有如下定义：F(n)=F(n-1)+F(n-2)，该数列越往后相邻的两个数值的比例越接近于黄金比例0.618。核心思想：斐波那契查找也是折半查找的改良版，每次不再是查找正中间的位置，而是先把查找序列补全成为刚好比自身长度大的斐波那契数的长度(在序列后面补序列的最后一个元素值)，再去查找序列中位置等于前一个斐波那契数上的元素。如下图：代码如下： 斐波那契查找最大的优点就是它只有加减法，没有除法，这在海量数据中运算时，还是有不小的性能提升。 线性索引查找就像房间里面的n多东西，一样一样去找是非费劲的，也很难对他们去排序，即使排了序还要花大把时间去维护这个序列。如果我们一个小本子，里面记录着每一样东西它在房间里的位置，那找起来就相当方便了。这就是索引。每个索引项至少要包含记录的关键字和记录存储的位置。上面的例子里，每件物品相当于一个记录，它有各种属性，名字就相当于它的关键字，能唯一确定它，在房间里的位置就相当于记录的存储位置。线性索引表就是索引项组成的线性结构，基于线性索引表的查找就是线性索引查找。有三种重要的线性索引：稠密索引、分块索引、倒排索引。 稠密索引稠密索引是指每一条记录都对应一个索引项。为了让索引表也可以排序，我们可以用数字来替换关键字，比如用数字去替换名字。在下图中表现为关键码：但是稠密索引有个很致命的缺点，当记录量很大时，比如上亿，就需要和记录量一样多的索引项，这需要反复地去访问磁盘，查找性能反而会下降。 分块索引将大量的记录分成若干块，快内无序，块间有序，再让每块对应一个索引项，这就是分块索引(快内再有序的话代价太大)。在块数和快内记录数相等时，分块索引的平均查找长度最短，即性能达到最好。 倒排索引在前面的例子中，如果我想知道哪些东西是红色的，是需要一个物体一个物体地去查看它的所有属性，看看有没有红色这一项吗？或者说我想知道在n多篇文章里，哪几篇出现了hello这个单词，哪几篇出现了world这个单词，是需要一篇文章一篇文章去找吗？这样太费时了！如果我们有一张表，左侧是红色，右侧红色对应的物体，或者左侧是单词，右侧是单词出现的文章，根据这张表是不是能快很多？由于这是根据记录的属性去查找记录，所以称为倒排索引。 二叉排序树想要查找效率高，就应当让数据有序，但是如果采用线性顺序存储，又降低了插入和删除记录的效率。有没有什么办法能让查找、插入、删除的效率都高呢？二叉排序树可以做到。二叉排序树也叫做二叉搜索树。 二叉排序树：左子树上所有结点值小于根结点，右子树上所有结点值大于根结点。 二叉排序树的插入和创建现在有一堆记录{62，88，58，47，35，73，51，99，37，93}，把第一个数据作为根节点，后面每插入一个数据，先从根节点开始，小于则向左走，一直到某个结点的左儿子为空时插入，大于则向右走，一直到某个结点的右儿子为空时插入（在每个结点处都要判断是向左还是向右走）。最终构造出如下图的树：先把62作为根结点，接下来是88，比62大往右走，发现62结点的右儿子为空，则插入到这个位置；接下来是58，比62小往左走，发现62结点的左儿子为空，则插入；再接下来是47，比62小往左走，发现62结点的左儿子不为空，继续向左走，比58小往左走，发现58的左儿子为空，则插入；……对这棵排序二叉树作中序遍历后，就能得到有序序列：{35，37，47，51，58，62，73，88，93，99}。代码见后面。 二叉排序树的查找从根结点开始，小于则向左找，大于则向右找。一样的用递归实现，很简单。代码见后面。 二叉排序树的删除二叉排序树的删除分为4种情况： 要删除结点为叶子结点，直接删除即可。 要删除结点的右子树为空，则只需要把左子树接上来即可，得到的依然是一棵排序二叉树。如下图： 要删除结点的左子树为空，与上一个类似，只需要把右子树接上来即可。 要删除结点的左右子树都不为空，如下图：这就不能简单地把左子树或右子树接上就可以了，这样做可能就不再是一棵排序二叉树了。仔细观察，其实有37结点和48结点可以代替47结点，而它俩又恰好是47结点中序排列的前驱和后继，其中前驱肯定没有右子树，后继肯定没有左子树（由中序决定的）。比如把37结点的数据移到47结点的位置，再由35结点的右子树去接管37结点的左子树。注意，如果上图中35结点(待删除结点的左儿子)没有右子树，则待删除结点47的直接前驱就应该是35结点，这时候就需要47的左子树去接管35的左子树了。所以这里应该分两种情况讨论，一种是待删除结点的前驱结点不是它的左儿子，另一种是待删除结点的前驱结点就是它的左儿子。代码如下：可以看出，查找某个元素的次数，等于该元素在二叉排序树中的层数。也就是说，二叉排序树的查找性能取决于二叉排序树的形状，深度太大，性能会很低。所以我们希望二叉排序树是平衡的，即它的深度与完全二叉树相同，均为[logn]+1（以2为底，向下取整）。那么查找的时间复杂度将变为O(logn)。 平衡二叉树 平衡二叉树：一种每个结点的左右子树高度差不会超过1的二叉排序树。 平衡因子BF：结点的左子树深度减右子树深度的值。对于平衡二叉树的BF。 最小不平衡子树：其根节点距离插入结点最近，且平衡因子绝对值大于1应该只有三种取值：1，0，-1。非平衡二叉树的BF就多了去了。 平衡二叉树的创建：平衡二叉树只是在创建排序二叉树的基础上，每添加一个结点都去递归检查插入结点后树是不是长高了，然后去改变自己的平衡因子，如果打破了平衡（平衡因子绝对值大于1）则作相应的旋转处理（BF为2则把对应的最小不平衡子树右旋，BF为-2则把对应的最小不平衡子树左旋），重新达到平衡状态，并修改平衡因子。插入节点时由于非平衡所带来的旋转处理分为以下4种： 左左（给结点的左子树插入一个左孩子）：分为以下两种：这俩其实是一样的，都是把BF为2的分支旋转成BF为1的结点的右子树，再把BF为1的结点的原先的右子树改为BF为2的结点的左子树。 右右分为以下两种：这俩其实也是一样的，都是把BF为-2的分支旋转成BF为-1的结点的左子树，再把BF为-1的结点的原先的左子树改为BF为-2的结点的右子树。 左右分为以下三种：这三其实也是一样的，先把不平衡分支下BF符号相反的结点（下图中BF为-1的结点2）进行左旋，结果旋转成了左左类型，后续处理和左左一致。 右左 多路查找树我们前面讲的树结构都只能一个结点存储一个元素，在元素非常多的时候，就会使得树的度非常大或者树的深度非常大，这样会造成频繁地访问外存（因为所访问的树结点很可能并不是顺序存储的），导致性能很低。所以，我们需要打破一个结点只存储一个元素的限制，于是就有了多路查找树。 多路查找树：每个结点可以存储多个元素，且孩子不止于两个 2-3树2-3树同时具有以下特点： 每个结点具有两个孩子（称为2结点）或者三个孩子（称为3结点） 每个2结点包含一个元素和两个孩子（或没有孩子），其左子树的元素小于该2结点的元素，其右子树的元素大于该2结点的元素 每个3结点包含两个元素和三个孩子（或没有孩子），其左子树的元素小于3结点中的较小元素，其中子树的元素介于3结点的两个元素之间，其右子树的元素大于3结点中的较大元素 2-3树的所有叶子都在同一层上 2-3-4树2-3-4树是2-3树的扩展，增加了一个四结点，所以相比2-3树增加了以下特点： 每个结点可以是2结点或者3结点或者4结点 每个4结点包含三个元素和4个孩子（或没有孩子），其左子树的元素小于4结点中的最小元素；第二子树的元素大于4结点的最小元素，小于4结点的第二元素；第三子树的元素大于4结点的第二元素，小于4结点的最大元素；右子树的元素大于4结点的最大元素 B树B树是一种平衡的多路查找树，2-3树和2-3-4树都是B树的特例。结点最大的孩子数目称为B树的阶。B树具有如下特点（其阶数为m）： 如果根结点不是叶结点，则至少有两棵子树 每个非根的分支结点都有超过(m/2-1)（向下取整）个元素和m/2个孩子（孩子比元素个数多1） 每个叶子结点都有超过(m/2-1)个元素 所有叶子结点位于同一层 每个结点的各个子树所包含的元素的值都介于结点中孩子对应的相邻元素值之间（结点中孩子和元素相间存放，最左孩子的左边元素看作无穷小，最右孩子的右边看作无穷大） B+树虽然使用B树访问多个关键字（元素）时，由于一个结点可以存储多个关键字，会减少访问外存的次数，但是如果是访问多个结点，则需要从根结点开始去遍历树，遍历过程中的很多结点可能并不在一个内存页面上，也就是说访问B树的多个结点时，还是要频繁地访问外存。而B+树则是应文件系统所需而产生的一种B树的变形树，严格来说，B+树已经不能算作树了。m阶B+树和m阶B树的区别： 有n棵子树的结点中包含n个关键字 所有分支结点可以看成是索引，分子结点中仅含有其子树中的最大（或最小）关键字 所有叶子结点按关键字大小从小到大链接在一起 所有的叶子结点加在一起一定包含了树中的全部关键字，以及指向这些关键字记录的指针 即使在分支结点中已经找到了要查找的关键字，但它也只是用来索引的，不能提供实际记录的访问，因为只有叶子结点中才存储着关键字对应记录的实际指针，还是需要到达包含此关键字的叶子结点才行。 那么使用B+树为什么能减少外存访问次数呢？因为B+树中的所有叶子结点是按大小链接在一起的，当需要访问多个结点时，可以从B+树最左端的叶子结点出发，不经过分支结点，而是沿着指向向下一个叶子结点的指针就可以遍历所有的关键字，这样就省去了从根结点开始遍历所需要访问的诸多分支结点，访问的结点少了，访问外存的次数当然就少了。 由于所有叶子结点包含了所有关键字，且是按关键字从小到大链接在一起的，所以B+树特别适合带有范围的查找。 散列表查找之前的查找都是先有关键字，然后去表中挨个查找，再根据顺序存储位置的计算方法找到关键字记录对应的内存地址。那么能不能直接根据关键字，不用去表中一个一个地比较就能知道对应记录的内存地址呢？？？可以发现，关键字和内存地址是一对映射关系，如果知道它们之间是怎么映射的，不就可以直接通过关键字找到内存地址吗？也就是如下形式： 存储位置=f(关键字)所以在存储的时候，我们就可以按照关系f来存储，查找的时候也按照关系f来查找。 这就是散列技术：在记录的存储位置和它的关键字之间确定一个对应关系f，使得每一个关键字key对应一个存储位置f(key)。对应关系f称为散列函数或哈希函数。使用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间称为散列表或哈希表。（散列技术既是存储方法，也是对应的查找方法）。 但是散列技术也有很多缺点： 同样的关键字对应很多记录时，不适合用散列技术。因为函数本身可以多个x对应一个y，但不能一个x对应多个y。 散列表不适合范围查找，比如查找一个公司18~50岁的员工，在散列技术中是没法进行这种范围查找的。 散列查找也不能获得记录的排序，而且像最大值、最小值等都无法通过散列查找知道。 散列技术还可能出现冲突，因为在散列函数中有可能会有多个x对应一个y的情况，即多个关键字通过散列函数算出来的是同一个存储地址（这多个关键字称为同义词），但是多个关键字对应的记录明显是多个不同的记录，总不能把这多个记录都存储到一个地址中把，这会产生数据覆盖的，造成后续查找错误，找不到关键字对应的正确记录。 散列技术的冲突其实是由散列函数造成的，如果构造出来的散列函数只能一个x对应一个y，那当然是不会产生冲突了。同时散列函数还不能太复杂，不然计算散列函数就得花费大量时间，反而查找性能不好。所以在散列技术中如何构造散列函数f是一个关键点。 散列函数的构造方法 直接定址法：取关键字的某个线性函数值作为散列地址，即：f(key)=a x key+b（a、b为常数）。直接定址法的优点是简单、均匀，也不会产生冲突，但是需要事先知道关键字的分布情况，因为关键字如果分布比较稀疏，就会造成散列地址很分散，可能在不同的内存页面上，导致频繁换页，性能降低。所以直接定址法只适合查找表小且连续的情况，实际中并不常用。 数字分析法：数字分析法是抽取关键字的一部分来计算散列地址，这在散列函数中常常用到。数字分析法适合处理关键字位数比较大的情况，而且如果事先知道关键字的分布且关键字中的若干位分布较均匀，就可以考虑使用数字分析法。 平方取中法比如关键字是1234，它的平方是1522756，再抽取中间三位227来作为散列地址。这就是平方取中法。平方取中法比较适合不知道关键字分布，而且关键字位数又不是很大的情况。 折叠法折叠法是将关键字从左到右分割成位数相等的几部分（最后一部分位数不够就不够了，不管它），然后将这几部分叠加求和，并且根据散列表表长，取后几位作为散列地址。比如关键字是9876543210，散列表表长为3位，将关键字分为4组：987|654|321|0，然后将它们叠加求和987+654+321+0=1962，再拿出后3位962作为散列地址。折叠法适合不知道关键字分布，而且关键字位数比较多的情况。 除留余数法此方法为最常用的散列函数构造方法。除留余数法就是把关键字除以某个数，取余数作为散列地址，即：f(key)=key % p很显然，除留余数法是会产生冲突的，它的关键就在于选择合适的p。 经验表明，p应该选为小于或等于散列表长度（最好接近表长）的最小质数或不包含20以下的质因子的合数。 随机数法随机数法就是取关键字的随机函数值作为它的散列地址，即f(key)=random(key)。随机数法适合关键字长度不等的情况。 处理散列冲突的方法虽然可以通过构造好的散列函数来减少冲突的发生，但是冲突总还是有的，几乎不可避免。那么应该有一些处理散列冲突的方法。 开放地址法就像你要去买一套房子，发现它已经被人买走了，怎么办？找别的房子呗！这就是开放地址法：发生冲突后，去寻找下一个空的地址。只要散列表足够大，空的散列地址总是能找到的。那么以何种方式去找下一个空的地址呢？ 开放定址法之线性探测法发生冲突后，一个一个往后顺序查找空的地址，即： fi(key)=(f(key)+di) % p （di=1，2，3…..p-1）但是使用线性探测法，很可能会出现本来不是同义词却要争夺一个地址的情况，这种现象称为堆积。 开放定址法之二次探测法发生冲突后，以平方跳跃的方式往前或者往后查找空的地址，即使用平方是为了不让关键字算出来的散列地址都聚集在某一块区域，减少堆积现象。 开放地址法之随机探测法发生冲突后，随机地去查找空的地址，即：fi(key)=(f(key)+di) % p （di是一个随机数列） 再散列函数法当发生冲突时，换个散列函数来计算散列地址。这种方法不会产生堆积，但是也相应地增加了计算时间。 链地址法发生冲突后，把同义词的记录链接到上一个同义词的后面，构成一个单链表，称之为同义词子表，而散列表中只存储所有同义词子表的头指针（有些类似于之前介绍过的树中的孩子表示法）链地址法适合处理可能会造成很多冲突的散列函数，因为它提供了绝对不会出现找不到地址的保障。但是同时，也带来了查找时需要遍历单链表的性能消耗。 公共溢出区法发生冲突后，把冲突的关键字放到一个公共的溢出区（顺序存储表）里去。查找时，先根据关键字和散列函数计算出来的地址去查找，如果关键字不匹配，则到再溢出区里去顺序查找关键字。公共溢出区法适合冲突数据很少的情况，因为在溢出区里顺序查找关键字也是比较费时的。冲突数据很少时，公共溢出区法对查找性能来说是非常高的。 影响散列查找性能的因素 散列函数是否均匀，即散列函数下发生冲突的可能性是否小 处理冲突的方法。比如线性探测法处理冲突有可能会产生堆积现象，显然性能就没有二次探测法好。 散列表的装填因子。装填因子=填入表中的记录个数/散列表长度。显然，装填因子越大，散列表中的空闲地址就越少，产生冲突的可能性就越大。所以通常把散列表的空间设置得记录集合大。无论记录集合有多大，都总可以选择一个合适的装填因子以便将平均查找长度限定在一个范围之内，这个时候查找的时间复杂度就是O(1)了。不过这是以牺牲空间为代价的，典型的用空间换时间。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[递归与尾递归]]></title>
    <url>%2F2016%2F09%2F16%2F%E5%B0%BE%E9%80%92%E5%BD%92%2F</url>
    <content type="text"><![CDATA[递归：在函数或者方法里调用自身，且有明确的递归结束条件。 下面来看一个基本递归（一般意义下的递归）问题：计算n!计算公式为：n!=nx(n-1)x(n-2)……2x1递归公式为：代码如下：12345678static int Recursion(int n) &#123; if (n &lt; 0) return 0; else if (n == 0 || n == 1) //0的阶乘也等于1 return 1; else return n * Recursion(n - 1);&#125; 在上面的每一次递归中，都需要在栈中开辟一块新的空间，用来保存当前方法的参数、局部变量、返回地址等等，便于后面递归返回时能够回溯到正确的位置和状态。如果递归深度太大，栈中就会保存大量的递归之前的数据，可能会造成栈溢出。 下面再来看一下尾递归问题还是：计算n!代码如下：123456789//调用时currentValue传入1static int Recursion(int n, int currentValue) &#123; if (n &lt; 0) return 0; else if (n == 0 || n == 1) return currentValue; else return Recursion(n - 1, n * currentValue);&#125; 比较上诉两份代码，可以看到第一份代码的递归调用是在倒数第二步进行的（先递归调用再做乘法），而第二份代码的递归调用是在最后一步进行的。所以，顾名思义，尾递归：对函数自身的递归调用在函数体的最后一步 还有更有意思的，由于尾递归是在最后一步调用的自身，所以在调用返回后应该就直接退出调用函数了（因为它已经是函数体最后一步了），也就是说返回到函数体的哪个位置（返回地址）不需要了，递归到最后一层时直接退出，不再需要回溯了。而且调用函数的参数、局部变量等等也不会再用到，那么就没有必要在尾递归调用的时候在栈中开辟新的空间去存储调用之前的状态信息了。很多编译器会自动识别并这样优化尾递归（部分高级语言不支持）。这样，尾递归就带来了性能上的很大提升。 在第一份基本递归的代码中，由于递归调用是在倒数第二步进行的，再递归返回后还需要与方法的参数n相乘，这样就不得不在栈中开辟一块新的空间，来存储调用之前的参数n、返回地址等等。如果不开辟新的空间，下次进入递归的函数内部时，由于递归函数本身就有参数、局部变量等等，就有可能把递归调用之前的n给覆写了，导致递归返回时，跟它相乘的n不是正确的n，导致结果错误。 可以看到在尾递归中，不仅需要把递归调用放在最后一步，还需要设置一个参数用来保存或计算调用之前的计算结果，如第二份尾递归代码中的currentValue。其实由于尾递归没了回溯，所以它的过程还是很类似迭代的。 【注】：可以看出，这种优化其实不止于尾递归，对于所有尾调用（在函数体最后一步调用别的函数）其实都是有这种优化的。尾递归是尾调用的一种。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>尾递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法之图之拓扑排序]]></title>
    <url>%2F2016%2F09%2F09%2F%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[先来看几个概念： AOV网：在表示一个工程的有向图中，用顶点表示活动，用弧表示活动之间的优先关系，这样的用有向图顶点表示活动的网，称为AOV(Activity On Vertex)网 AOV网中不能存在回路。因为某个活动要以自己完工作为先决条件，是不可能的，也就是某个活动不可能优先于自己 拓扑序列：在有向图的所有顶点组成的序列中，任意弧尾顶点都排在弧头顶点之前的序列 拓扑排序：对一个有向图构造拓扑序列的过程。一个AOV网的拓扑序列不是唯一的。 拓扑排序算法 由于是要找一个任意弧尾顶点都在弧头顶点之前的序列，所以我们可以从入度为0的顶点出发，那么怎么找到下一个顶点呢？看定义，任意弧尾顶点在弧头顶点之前，也就是说需要保证我们找到的下一个顶点不会称为之前顶点的弧头(经过1段或n段有向弧称为弧头)。怎么保证？我们切断所有从之前顶点出去的弧(以之前顶点作为弧尾的有向弧)不就ok了。所以：核心思想：从AOV网中选择一个入度为0的顶点，输出并删去它以及从它出去的弧(该顶点时弧尾)，重复上述步骤，直到输出全部顶点或AOV网中不存在入度为0的顶点为止。 由于需要删除顶点，所以用邻接表要比邻接矩阵方便。因为对数组的删除操作效率并不高，有很多元素需要移位。还有我们需要查找入度为0的点，所以需要给邻接表中顶点结点增加一个数据成员InDegree，标识顶点的入度数。为了避免每次都去遍历所有顶点查找入度为0的顶点，我们需要一个栈，用来存储一开始入度就为0的顶点和删除有向弧过程中入度变为0的顶点。综上，需要用到的数据结构：邻接表+栈。其中邻接表的顶点类结构如下： 代码如下： 未完待续]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法之改进排序]]></title>
    <url>%2F2016%2F09%2F03%2F%E6%94%B9%E8%BF%9B%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[排序算法主要分为7类：冒泡排序、简单选择排序、直接插入排序(这三种属于简单算法)、希尔排序、堆排序、归并排序、快速排序(这四种属于改进算法) 希尔排序希尔排序是直接插入排序的升级版。对于直接插入排序，原序列中待排序的元素还是比较多。每次插入时需要很多次后移操作(因为序列较长时一般后移距离也长)，有没有什么办法能够减少后移的距离呢？很容易想到的是，把原序列分组，在每一组内进行直接插入排序，由于每一组序列长度较小，再插入时移动的次数也就自然少了。但是有一个问题，对{9，1，2，5，7，4，8，6，3，5}分成五组：{9，1}，{2，5}，{7，4}，{8，6}，{3，5}，即使每一分组都排好序后再合并：{1，9，2，5，4，7，6，8，3，5}，得到的这个序列依旧是杂乱无章的，如下图：并没有大体上让小的元素往前走，让大的元素往后走，对下一次的直接排序几乎没有多大帮助。原因在于分组时，元素间隔太小，交换位置时，只能和附近的元素交换，如果把元素间隔设大一点，就能够和较远的元素交换位置，这就增大了小元素大幅度往前走，大元素大幅度往后走的几率。但是通常仅有一次排序是不够的，需要缩小间隔再直接插入排序多次（第一次间隔gap=n/2，后面几次的间隔减半gap=gap/2，直到gap==1。直接插入排序相当于gap=1时的希尔排序）。如下图所示：希尔排序的核心：按间隔分组直接插入排序，再缩小间隔分组直接插入排序，直到间隔等于1代码如下：12345678910111213141516static void ShellSort(int[] array) &#123; int gap = array.Length / 2; //多次分组直接插入排序，直到gap=1 for (; gap &gt;= 1; gap /= 2) &#123; for (int i = 0; i &lt; array.Length - gap; i++) &#123; if (array[i + gap] &lt; array[i]) &#123; int temp = array[i + gap]; int j; for (j = i; j &gt;= 0 &amp;&amp; array[j] &gt; temp; j -= gap) &#123; array[j + gap] = array[j]; &#125; array[j + gap] = temp; &#125; &#125; &#125;&#125; 【注】： 由于希尔排序比直接插入排序减少了移动距离(移动次序)，所以希尔排序的效率比直接插入排序高，也就自然比简单选择排序和冒泡排序性能好了。进过分析希尔排序的平均时间复杂度是O(nlogn)。 由于希尔排序是将元素跳跃式分组，插入元素时也是跳跃式插入，如上图中第一轮排序里两个5在排序前后的次序发生了变化，所以希尔排序是不稳定排序。 大量研究表明，当间隔序列为时，可以获得不错的效果。但是最后一个增量值必须等于1。 堆排序堆排序是对简单选择排序的一种改进。来看几个定义： 堆是一棵完全二叉树，满足一下特性：所有结点比它的子结点大（大顶堆）或者所有结点比它的子结点小（小顶堆）。 堆可以用层序遍历的次序存入到数组中 把待排序的序列建成一个大顶堆的方法：先把待排序的序列按照层序构建成一棵完全二叉树，再从下往上、从右到左，将每个非叶结点与其左右子结点的较大值互换，直到比它的左右儿子都大为止。 比如有一个待排序序列：{50，10，90，30，70，40，80，60，20}，先按层序构建成完全二叉树，如下图：接下来从下往上，从右到左的第一个非叶结点是30，将它与左右儿子的较大者60互换，结果如下图：接着从下往上，从右到左的第二个非叶结点是10，将它与左右儿子的较大者70互换，结果如下图：再接下来从下往上，从右到左的第三个非叶结点是90，因为它本身就比它的左右儿子都大，所以不用互换了。再接下来从下往上，从右到左的第四个非叶结点是50，将它与左右儿子的较大者90互换，因为要一直换到比左右儿子都大为止，所以把50、90互换之后，50还要和它的左右儿子的较大者80互换，结果如下图：到此，整个大顶堆就构建完成了。那么如何利用这个大顶堆来排序呢？ 利用大顶堆来排序的方法：把根结点元素与还未排序的最后一个元素交换位置（层序下的最后一个未排序元素），再把交换后的根结点与其左右孩子的较大者交换，直到比它的左右孩子都大。重复，直到所有结点都排序完成。 对上面的大顶堆排序的过程如下：先把根结点90和待排序的最后一个元素20交换位置，结果如下图：再把20和它的左右儿子的较大者交换位置，直到比它的左右儿子都大，结果如下图：这样最大的元素90就被放到了数组的最后一个位置，是不是有点像选出了最大的元素然后把它放到最后的位置？？？所以从这里可以看出堆排序是简单选择排序的改进版。接下来把根结点80和待排序的最后一个元素30交换位置，结果如下图：再把30和它的左右儿子的较大者交换位置，直到比它的左右儿子都大，结果如下图：后面的变化完全类似，不再赘述，如下图：至此，便完成了堆排序的过程。经过分析，堆排序的时间复杂度为O(nlogn)（堆排序对原始序列的排序状态并不敏感，所以堆排序的最好、最坏和平均时间复杂度都为O(nlogn)），空间复杂度为O(1)。但是由于它的交换是跳跃式的（不是和相邻的元素交换），所以堆排序也是一种不稳定排序。【注】： 由于构建堆的时候需要很多次比较，所以它并不适合待排序序列个数较少的情况，因为得不偿失嘛！ 代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;iostream&gt;using namespace std;void HeapSort(int array[], int length);int main()&#123; int array[] = &#123; 65535,1,6,9,7,2,5,0,3,1 &#125;; int length = sizeof(array) / sizeof(int); HeapSort(array, length-1); for (int i = 1; i &lt; length; i++) &#123; cout &lt;&lt; array[i] &lt;&lt; ' '; &#125; int key; cin &gt;&gt; key; return 0;&#125;int GreaterRoot(int array[], int i, int length);void HeapSort(int array[], int length) &#123; //数组从1开始存数 //构建大顶堆 for (int i = length / 2; i &gt;= 1; i--) &#123; int j = GreaterRoot(array, i, length); while (j != 0) &#123; //一直向下调整到比它的子结点都大 j = GreaterRoot(array, j, length); &#125; &#125; //对大顶堆排序 for (int i = length; i &gt;= 2; i--) &#123; //第一个位置和右下角最后一个未排序位置互换 int temp; temp = array[1]; array[1] = array[i]; array[i] = temp; //将调到第一个位置的元素和它的子结点一直向下比较，直到重新调整为大顶堆 int j = GreaterRoot(array, 1, i - 1); while (j != 0) &#123; j = GreaterRoot(array, j, i - 1); &#125; &#125;&#125;//如果该结点已经比子结点都大，则返回0，否则返回跟它交换的那个子结点的编号int GreaterRoot(int array[], int i, int length) &#123; if (i * 2 &gt; length) //叶节点 return 0; if (array[i] &gt; array[2 * i] &amp;&amp; (2 * i + 1 &gt; length || array[i] &gt; array[2 * i + 1])) &#123; //只有左儿子，但是比左二子大，或者有右儿子但是比左右儿子都大 return 0; &#125; if (2 * i + 1 &gt; length || array[2 * i] &gt; array[2 * i + 1]) &#123; //和子结点的较大者交换 int temp; temp = array[i]; array[i] = array[2 * i]; array[2 * i] = temp; return 2 * i; &#125; else &#123; int temp; temp = array[i]; array[i] = array[2 * i + 1]; array[2 * i + 1] = temp; return 2 * i + 1; &#125;&#125; 归并排序归并排序很简单，归并在数据结构中定义是将两个或者两个以上的有序表组合成一个新的有序表。2路归并排序就是每两个一组进行排序，再归并（合起来并同时排序），再每两个一组进行排序，再归并，直到不能再归并为止（或者得到的有序序列长度等于原始待排序序列长度为止）。如下图所示：迭代图示：递归图示：归并排序可以用递归来实现，也可以用迭代（非递归）来实现。归并排序的递归代码如下：归并排序的迭代代码如下： 快速排序希尔排序是直接插入排序的升级版，属于插入排序类，堆排序是简单选择排序的升级版，属于选择排序类，而快速排序是冒泡排序的升级版，属于交换排序类。 快速排序的核心思想：随机选择一个基准数，把小于基准数的元素移到基准数左边，把大于等于基准数的元素移到基准数右边。再分别对左右两边的元素重新选择基准数，重复上诉过程，直到排序结束（从小到大排序）。 快速排序的具体方法（这里介绍两种：哨兵换岗法、挖坑填数法） 哨兵换岗法：随机选择一个基准数（一般选择待排序序列最左边的数），开始时左哨兵指向序列头，右哨兵指向序列尾。右哨兵先向左移动，直到找一个小于基准数的数，然后左哨兵向右移动，直到找到一个大于基准数的数，然后两哨兵换岗（两哨兵所在的元素交换位置，这样小的就到左边了，大的就到右边了）。重复上诉过程直到右哨兵和左哨兵相遇，再把相遇的数和基准数交换位置。这样一次排序后，比基准数小的全在它的左边，比基准数大的全在它的右边，再分别对左右两边进行上诉排序，直到排序完成（一看就是递归）。 例如要对{6，1，2，7，9，3，4，5，10，8}这个序列进行排序： 假定选择6作为基准数，设置左哨兵i和右哨兵j，如下图： 然后右哨兵j向左走找到比6小的数5，左哨兵i向右走找到比6大的数7，交换5和7，如下图所示： 接着右哨兵继续向左走找到比6小的数4，左哨兵向右走找到比6大的数9，交换4和9，如下图所示： 然后右哨兵继续向左走找到比6小的数3，左哨兵向右走去找比6大的数，结果遇到右哨兵了，把左右哨兵所在的数3和基准数交换。到此第一轮排序结束了。如下图所示： 再对6左边的序列{3，1，2，5，4}进行上诉排序，以3为新的基准数得到的序列应该是：{2，1，3，5，4}，这样比3小的都在3左边，比3大的都在3右边。再对序列{2，1}和{5，4}进行排序，最后得到的序列应该是：{1，2，3，4，5，6，9，7，10，8}，对6右边的序列{9，7，10，8}也是同样的排序方式，最终得到的序列是：{1，2，3，4，5，6，7，8，9，10} 代码如下： 挖坑填数法：随机选择一个基准数（一般选择待排序序列最左边的数），将基准数所在的位置看作第一个坑，从右往左找第一个小于基准数的数，把它挪到坑里去（这个数原先所在的位置就形成了一个新的坑），再从左往右找第一个大于基准数的数，把它挪到新坑里去。重复上诉过程直到左右相遇，再把基准数挪到最后一个坑里去。样一次排序后，比基准数小的全在它的左边，比基准数大的全在它的右边，再分别对左右两边进行上诉排序，直到排序完成（从小到大排序。而且其实也是有哨兵的，不过为了突出挖坑，下面的图示没有画出哨兵）。 例如要对{6，1，2，7，9，3，4，5，10，8}这个序列进行排序： 假定选择6作为基准数，则6所在的位置就是第一个坑，如下图： 从右往左找到小于基准数6的数5，把它挪到坑里，结果如下： 再从左往右找到大于基准数6的数7，把它挪到坑里，结果如下： 接下来继续从右往左找到小于基准数6的数4，把它坑里，如下图所示： 再从左往右找到大于基准数6的数9，把它挪到坑里，结果如下图： 接着继续从右向左找到小于基准数6的数3，把它挪到坑里，如下图所示： 再从左往右去找大于基准数6的数，结果发现左右相遇了，这时到第一轮排序的最后一步了，把基准数挪到坑里，结果如下图： 到此，快速排序的挖坑填数法的第一轮排序就结束了，接下来再对基准数左右两边的序列重复上诉排序过程就ok了。代码如下： 从排序过程和代码都可以看出，挖坑填数法其实是哨兵换岗法的改进版，挖坑填数法一样存在左右哨兵，但是明显交换次数少了（交换时的赋值语句少了）。 快速排序的时间性能取决于快速排序递归的深度，当选择的基准数恰好接近待排序序列的中间值时，例如在哨兵换岗法中选择的基准数6恰好就接近序列中间值，此时快速排序的性能较好，时间复杂度为O(nlogn)，空间复杂度为O(logn)；但是如果待排序的序列恰好是已经有序或基本有序的，如序列{1，2，3，4，5，6，7，8，9，10}或者{10，9，8，7，6，5，4，3，2，1}，此时快速排序的深度就为n-1，性能较差，时间复杂度为O(n^2)，空间复杂度为O(n)。平均情况，快速排序的时间复杂度为O(nlogn)，空间复杂度为O(logn)。 对快速排序的优化： 优化选取基准数每次选择待排序序列的第一个元素作为基准数，就很有可能选中的数值太大或者太小，造成快速排序性能太低，对怎么选择基准数有以下几种方法： 不再是每次选待排序序列的第一个元素作为基准数，而是随机选取一个。其实对于无序的序列来说，这种随机选取和选择第一个元素是一个意思，并不能起到优化作用，还会增加随机数生成器本身带来的开销 三数取中。随机取三个数，选择大小在中间的那个数，来作为快速排序的基准数。为了避免随机数带来的消耗，实际上取序列左端、右端、中间位置的三个数即可。因为这和随机是一个效果嘛。从概率上来说，取到的三个数均为序列中最小或者最大数的可能性是很小的，所以三个数中的中间数接近序列的中间数的可能性就提高了。 九数取中。和三数取中是一个意思，在数组中分三次取样，每次选出各组的中间数，再在这三个中数种选出一个中数作为基准数。九数取中一般用于序列长度比较大的情况下，以保证取出的基准数比较接近序列的中值。 减少交换次数。在哨兵换岗法中，右哨兵和左哨兵找出的数要互相交换位置，这种swap交换需要三个赋值语句，其实可以减少。而挖坑填数法正好是哨兵换岗法的这种优化，把要调到前面或者后面的数填到坑里就行，不一定要正好调换两个哨兵的位置，只要保证把小的大致往前放，把大的大致往后放就行。比如右哨兵找到了一个比基准数小的数，左哨兵找到了一个比基准数大的数，这时候其实不需要交换左右哨兵，只需要把右哨兵填到前面的坑里（基准数那个位置），再把左哨兵填到后面的坑里（原右哨兵空出来的位置），这样就大致保证了“把小的往前挪，把大的往后挪”的原则，同时减少了交换次数（在下图中可以看到只有两次赋值，而不是三次），如下图所示： 小数组时使用直接插入排序（直接插入排序是简单排序中性能最好的）。对于序列元素较少时，使用快速排序反而不如直接插入排序，因为快速排序用到了递归操作，在数据量大时，相比于快排的优势递归带来的开销可以忽略，但数据量小时就无法忽略了。所以对快排的优化，可以在待排序序列长度递归到很小时，就不再继续用快排进行排序了，而换成直接插入排序。一般递归到待排序序列长度小于7（有时是50）时，改为使用直接插入排序。伪码如下： 1234567891011121314const int Length_InsertSort = 7;void QuickSort(int[] array,int low,int high)&#123; int pivot; //基准数在序列中的位置 if ((high - low) &gt; Length_InsertSort)&#123; //递归待排序序列长度大于7时用快速排序 pivot = Partition(array, low, high);//把array[low..high]一分为二，小的在左边，大的在右边，返回基准数所在的位置 QuickSort(array, low, pivot - 1); //对基准数左边的序列递归排序 QuickSort(array, pivot + 1, high); //对基准数右边的序列递归排序 &#125; else &#123; //递归待排序序列长度小于等于7时用直接插入排序 InsertSort(array); &#125;&#125; 减少递归调用的次数。在上述代码中，第一个递归调用和第二个递归调用做的都是相同的Partition操作，其实可以把它俩合成一个。伪码如下： 123456789101112131415161718const int Length_InsertSort = 7;void QuickSort(int[] array,int low,int high)&#123; int pivot; //基准数在序列中的位置 if ((high - low) &gt; Length_InsertSort)&#123; while (low &lt; high) &#123; //递归待排序序列长度大于7时用快速排序 pivot = Partition(array, low, high);//把array[low..high]一分为二，小的在左边，大的在右边，返回基准数所在的位置 QuickSort(array, low, pivot - 1); low = pivot + 1; &#125; &#125; else &#123; //递归待排序序列长度小于等于7时用快速排序 InsertSort(array); &#125;&#125; 将low=pivot+1后，再循环来一次pivot = Partition(array, low, high);，其实就是pivot = Partition(array, pivot+1, high);，与QuickSort(array, pivot + 1, high);是同样的效果，因为QuickSort本来做的就是Partition操作。但是使用循环减少了一个递归调用，从而减少了堆栈带来的开销，提高了性能。 7种排序算法的时间复杂度和空间复杂度的比较]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>改进排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法之简单排序]]></title>
    <url>%2F2016%2F09%2F03%2F%E7%AE%80%E5%8D%95%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[排序：将一组记录序列变成，在一组关键字的非递减(或非递增)排列下的映射记录序列。比如下面这4个人的总分成绩为：令狐冲 753，郭靖 573，杨过 682，张无忌 753按照总分成绩这组关键字的非递减排列{573，682，753，753}，那么排序后的记录应该是：郭靖 573，杨过 682，令狐冲 753，张无忌 753所以排序的依据是关键字之间的大小关系。 排序的稳定性：当关键字相等时，如果排序前后对应记录的先后次序没有发生变化，则是稳定排序，如果变化了则是不稳定排序。如上面的例子有两个相等的关键字753，排序前令狐冲记录在张无忌记录前面，若排序后令狐冲记录还是在张无忌记录前面，则是稳定排序；若排序后令狐冲记录跑到了张无忌记录后面，则是不稳定排序。如下图所示： 排序算法主要分为7类：冒泡排序、简单选择排序、直接插入排序(这三种属于简单算法)、希尔排序、堆排序、归并排序、快速排序(这四种属于改进算法) 冒泡排序冒泡排序是一种交换排序，核心思想是：两两比较，符合大小关系则交换，将最小的元素浮到最上面(非递减排序) 冒泡排序初级版如下图所示：先让数组中第一个元素依次和后面的元素作比较，如果小于则交换位置，交换位置后依然是让第一个元素继续和后面的元素作比较，直到比到数组中最后一个元素为止。这样第一轮完了以后最小的元素(数字1)就浮到了最上面。然后让数组中的第二个元素依次和后面的元素作比较，如果小于则交换位置。这样第二轮完了以后最小的元素(数字2)就浮到了次上面。以此类推，9个元素8轮比较后，就完成了整个排序。代码如下： 12345678910111213static void BubbleSort(int[] array)&#123; //i既表示比较多少轮，也表示数组下标，所以得从0开始 for (int i = 0; i &lt; array.Length - 1; i++)&#123; //j表示数组下标 for (int j = i + 1; j &lt; array.Length; j++)&#123; if (array[i] &gt; array[j])&#123; int temp = array[i]; array[i] = array[j]; array[j] = temp; &#125; &#125; &#125;&#125; 正宗的冒泡排序上面的初级版其实效率是很低的，一个数字浮上去了却对其它数字没有任何帮助，比如在第二轮里2虽然浮上去了，却把3沉下来了。我们希望能够找到一种算法能够让2浮上去的同时，不会把3沉那么多下来。仔细观察会发现，初级版冒泡是把当前元素和与之比较的元素作交换，这两个元素有可能位置相差很远，就很有可能会让数值较小的元素一下大幅度沉底，比如上面第二轮的最后一次交换，让仅仅比2小的3一下子就沉底了。那么能不能缩短每次交换的元素的距离呢？也就是缩短相比较的两个元素的距离。这就是正宗的冒泡排序：每次只比较相邻的两个元素的大小。不过它是从数组后面往前面比的，因为要冒泡把最小(或最大)的元素浮上去嘛。如下图所示：先让数组最后一个元素和倒数第二个元素比较，如果小于则交换位置，再让倒数第二个元素和倒数第三个元素作比较，以此类推。因为每次比较的结果都是较小的元素在上面，所以一轮完成后就能把最小的元素浮到最上面去。以此类推，9个元素8轮比较后，就完成了排序。可以看到在把1浮到最上面的同时，也把2浮上去了很多，这相比初级版的冒泡会减少很多交换次数。代码如下： 123456789101112static void BubbleSort(int[] array)&#123; //i既表示比较多少轮，也表示数组下标，所以得从0开始 for (int i = 0; i &lt; array.Length - 1; i++)&#123; for (int j = array.Length - 1; j &gt; i; j--)&#123; if (array[j] &lt; array[j - 1])&#123; //注意这里和冒泡初级版的差别 int temp = array[j]; array[j] = array[j - 1]; array[j - 1] = temp; &#125; &#125; &#125;&#125; 冒泡排序升级版正宗的冒泡排序也只是比初级版的冒泡减少了交换次数而已，那么有没有可能减少比较次数呢？如下面的情况：第一轮交换完，最小元素浮到最上面以后，下面的序列就已经有序了，那么其实后面的比较都不用了。但是在正宗的冒泡算法里，后面的比较还是要继续的。为了减少这种无用的比较，我们可以设置一个bool变量，标识这一轮比较有没有数据交换，如果没有，则说明后面的元素已经有序了，不用再比较了。代码如下： 12345678910111213141516static void BubbleSort(int[] array)&#123; //标识后面的元素是否已经有序 bool ordered = false; //i既表示比较多少轮，也表示数组下标，所以得从0开始 for (int i = 0; !ordered &amp;&amp; i &lt; array.Length - 1; i++) &#123; ordered = true; for (int j = array.Length - 1; j &gt; i; j--) &#123; if (array[j] &lt; array[j - 1]) &#123; int temp = array[j]; array[j] = array[j - 1]; array[j - 1] = temp; ordered = false; &#125; &#125; &#125;&#125; 简单选择排序冒泡排序还是存在着很多次的位置交换，有没有可能直接找到某个元素应该所处的位置，然后只交换一次就可以了呢？选择排序就是这样的。简单选择排序的核心思想：在每一轮排序中找出最小的元素，把它放到该轮次对应的位置上去。如下图所示：在第一轮排序中，找到最小的元素是1，将它与数组中第一个元素交换位置在第二轮排序中，在剩下的元素中找到的最小元素是2，将它与数组中第二个元素交换位置以此类推…代码如下：12345678910111213141516static void SimpleSelectSort(int[] array)&#123; //i既表示比较多少轮，也表示数组下标，所以得从0开始 for (int i = 0; i &lt; array.Length - 1; i++) &#123; int minIndex = i; for (int j = i + 1; j &lt; array.Length; j++) &#123; if (array[j] &lt; array[minIndex]) &#123; minIndex = j; &#125; &#125; if (minIndex != i) &#123; int temp = array[minIndex]; array[minIndex] = array[i]; array[i] = temp; &#125; &#125;&#125; 由于简单选择排序每一轮最多只有一次交换数据，不像冒泡排序那样频繁地交换位置，所以简单选择排序的性能要略优于冒泡排序。 直接插入排序直接插入排序的核心：一开始把数组的第一个元素看作是一个有序序列，接着在每一轮排序中把轮次对应的元素插入到该有序序列(数组的前i个元素就是该有序序列)中去。如下图所示(箭头表示接下来这一轮排序中将要后移的元素)：有一组待排序的序列如下：把第一个元素9看作是一个有序序列：{9}在第一轮排序中，要将元素1插入到有序序列{9}(数组前1个元素)中，先将有序序列中大于1的所有元素右移一位，左边会多出一个空位(如下图中的残缺方块)，再把1插入到空位中去。结果如下图：在第二轮排序中，要将元素5插入到有序序列{1，9}(数组前两个元素)中，先将有序序列中大于5的所有元素右移一位，会出现一个空位(如下图中的残缺方块)，再把5插入到空位中去。结果如下图：在第三轮排序中，要将元素8插入到有序序列{1，5，9}(数组前三个元素)中，先将有序序列中大于8的所有元素右移一位，出现空位，再把8插入到空位中去。结果如下图：在第四轮排序中，要将元素3插入到有序序列{1，5，8，9}中，需要先将有序序列中所有大于3的元素右移一位，出现空位，再把3插入到空位中去。结果如下图：一次类推，9个元素8轮插入后，将完成整个排序。【如果要插入元素的左边没有比它大的元素，则让这个要插入的元素什么也不做，保留在原地】代码如下：1234567891011121314static void StraightInsertSort(int[] array) &#123; for (int i = 0; i &lt; array.Length - 1; i++) &#123; //如果要插入元素小于左边有序序列最大值，则让有序序列中所有比它大的元素右移一位 if (array[i + 1] &lt; array[i]) &#123; int temp = array[i + 1];//保存要插入元素的值，因为在右移过程中会覆盖这个元素 int j; for (j = i; j &gt;= 0 &amp;&amp; array[j] &gt; temp; j--) &#123; array[j + 1] = array[j]; &#125; //把要插入元素插入到移出来的空位中去 array[j + 1] = temp; &#125; &#125;&#125; 因为插入排序是向有序序列中插入新元素的，所以比较次数会比简单选择排序少，且每一轮排序都只是把大于的元素往后移再插入一个元素而已，所以直接插入排序要比简单选择排序和冒泡排序的性能好一些。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>简单排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法之关键路径]]></title>
    <url>%2F2016%2F09%2F01%2F%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[先来看几个概念和式子：关键路径：从源点到汇点具有最大长度的路径关键活动：关键路径上的活动事件：带权图中的顶点活动：带权图中的边事件(顶点)Vi的最早发生时间VE：源点到顶点的最长距离事件(顶点)Vi的最晚发生时间VL：工期-结点到汇点的最长距离活动的最早开始时间AE：对应有向边的起点的最早发生时间活动的最晚开始时间AL：对应有向边的终点的最晚发生时间-该有向边的权值关键活动：AE=AL的活动(边) 求关键路径的步骤： 从源点开始，向后求出每一个结点的最长路径（也就是AE），直到汇点为止（到某个顶点有多个路径值时取最大值）。 从汇点开始反推，向前求出每一个结点的【工期-汇点到结点的最长路径】，即AL，直到源点为止（到某个结点有多个路径值是取最小值）。 取出上面两步中AE=AL的点，由它们构成的路径就是关键路径。 【注】： 求源点到结点的最长路径或者汇点到结点的最长路径，都可以根据已经求出的点作为跳板来计算，这一点和《最短路径》有点像 图的关键路径不唯一，有多条关键路径时，需要同时提高这些关键路径上的活动的速度，才能缩短工期。 举例如下，求下面这幅图的关键路径：先从源点开始，算出每个结点的最长路径AE；再从汇点开始，算出每个路径的AL。结果如下图所示：取出AE和AL相等的结点V0、V2、V3、V4、V7、V8、V9。所以关键路径如下图： 未完待续]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>关键路径</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法之图之最短路径]]></title>
    <url>%2F2016%2F09%2F01%2F%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[最短路径：两顶点之间权值之和最小的路径寻找带权图(网图)中两点之间最短路径的算法主要有两种：迪杰斯特拉(Dijkstra)算法、弗洛伊德(Floyd)算法 迪杰斯特拉(Dijkstra)算法迪杰斯特拉算法的核心思想：在每个顶点处，都会去存储它到周围点的路径长度。每次找出未知结点中到源点路径最短的结点，看其周围的结点是否会通过它得到比以前更短的路径长度，若是，则更新对应结点的最短路径长度和其前驱结点。如下图所示：要求源点V0到终点V8的最短路径，根据迪杰斯特拉算法需要先求得到中间所有顶点的最短路径：1. 先将V0加入已知顶点序列，V0到V0的最短距离自然是0，前驱结点就设为它自己吧：0，它周围点V1的当前最短路径就变为1，前驱结点为0；V2的当前最短路径变为5，前驱结点为0.如下图所示（空的地方路径都是无穷大，不可达）：2. 然后找出未知结点中当前路径长度最短的，为V1，把它加入已知结点序列，以V1为跳板的话，V2的路径长度就变为了4（V1的最短路径加上V1到V2的长度），比之前存储的5要短，所以把V2的当前最短路径变为4，前驱结点变为1；V3的当前最短路径变为8，前驱结点变为1；V4的当前最短路径变为6，前驱结点为1.如下图所示：3. 然后找出未知结点中当前路径长度最短的，为V2，把它加入已知顶点序列，以V2为跳板的话，V4的路径长度变为5，比之前的6要短，所以把V4的当前最短路径变为5，前驱结点变为2；V5的当前最短路径变为11，前驱结点变为2.如下图所示：4. 然后继续找出未知结点中当前路径长度最短的，为V4，把它加入已知顶点序列，以V4为跳板的话，V3的路径长度变为7，比之前的8要短，所以把V4的当前最短路径变为7，前驱结点变为4；同样V5比之前也短了，当前最短路径变为8，前驱结点变为4；V6、V7的当前最短路径分别变为11和14，前驱结点变为4。如下图所示：5. 然后继续找出未知结点中当前路径长度最短的，为V3，把它加入已知顶点序列，以V3为跳板的话，V6的路径长度变为9，比之前的11要短，所以把V6的当前最短路径变为9，前驱结点变为3。如下图所示：6. 然后继续找出未知结点中当前路径长度最短的，为V5，把它加入已知顶点序列，以V5位跳板的话，V7的路径长度变为13，比之前的14要短，所以把V7的当前路径长度变为13，前驱结点变为5。如下图所示：7. 然后找出最短的V6，把它加入已知顶点序列，以V6为跳板，V7的路径长度变为11，比之前的13要短，所以把V7的当前最短路径变为11，前驱结点变为6；V8的当前最短路径变为16，前驱结点变为6。如下图所示：8. 然后找出最短的V7，把它加入已知顶点序列，以V7位跳板，V8的路径长度变为15，比之前的16要短，所以把V8的当前最短路径变为15，前驱结点变为7。如下图所示：9. 然后找出最短的V8，把它加入已知顶点序列，现在图中的所有顶点都在已知顶点序列中了，终止循环。V8的最短路径就是一个一个地回溯前驱结点：V8的前驱结点是6，V6的前驱结点是3，V3的前驱结点是4，V4的前驱结点是1，V1的前驱结点是0。所以最短路径是：V0 → V1 → V4 → V3 → V6 → V8。迪杰斯特拉算法求最短路径的代码如下：迪杰斯特拉算法求某两点之间的最短路径的时间复杂度为O(n^2)，求所有顶点到所有顶点之间最短路径的时间复杂度为O(n^3)。*弗洛伊德(Floyd)算法 未完待续]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>最短路径</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法之图之最小生成树]]></title>
    <url>%2F2016%2F09%2F01%2F%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%2F</url>
    <content type="text"><![CDATA[看下面这个实际问题：假设你是电信的工程师，需要为下面的9个村庄架设网线，村庄位置如下图所示。边上的数字表示村庄之间的距离。要求以最小的成本使这9个村庄的网线互通，应该怎么办？最小成本，自然是需要连线的公里数最小。因为只需要9个村庄网线互通，不要求直接可达，所以设计路线至少应该是一颗生成树，9个结点，只铺设8条线路即可。但是图的生成树有很多个，我们需要代价最小的那棵生成树，即最小生成树。要根据图找出这棵最小生成树，有两种算法：普里姆(Prim)算法、克鲁斯卡尔(Kruskal)算法。 普里姆(Prim)算法算法规则： 设置一个已知顶点序列和一个生成树边序列。 先随机找一个顶点，把这个顶点加入已知顶点序列中 找出已知顶点和图中剩余顶点(未知顶点)之间权值最小的边，把这个边加入到生成树边序列中，并且把这条边上的那个未知顶点加入到已知顶点序列中 重复步骤3，直到已知顶点序列已经包含了图中所有的顶点为止 Prim算法核心：从已知顶点到未知顶点中找出最小边（权值最小）按Prim算法找出的最小生成树如下图所示：代码如下： 普里姆(Prim)算法的时间复杂度为O(n^2)。 克鲁斯卡尔(Kruskal)算法算法规则： 设置最小生成树的一个顶点序列和一个边序列。先确定图中的所有顶点，全部存放到最小生成树的顶点序列中，边序列还是空的 找出原图中除去最小生成树边序列以外的权值最小的边，如果这条边的两个顶点在现有最小生成树的不同连通子图上(也就是加入这条边后不会在现有生成树中形成回路)，则加入到最小生成树的边序列中 重复第2步，直到现有最小生成树的所有边都在同一连通子图上(只有一个连通分量) Kruskal算法核心：从剩下的边中找出不会构成回路的最小边（权值最小）按Kruskal算法找出的最小生成树如下图所示：代码如下： 克鲁斯卡尔(Kruskal)算法的时间复杂度为O(eloge)。其中e是图的边数 普里姆(Prim)算法和克鲁斯卡尔(Kruskal)算法的比较： 普里姆算法是从结点入手的，找出已知结点和未知结点之间权值最小的边；克鲁斯卡尔算法是从边入手的，其最小生成树中的所有结点已经事先确定好，再去找不会构成回路的权值最小的边 普里姆算法在边数非常多的情况下，比如稠密图，效率会比克鲁斯卡尔算法高；而在边数比较少时，例如稀疏图，克鲁斯卡尔算法的效率比普里姆算法高 未完待续]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法之图]]></title>
    <url>%2F2016%2F09%2F01%2F%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[先来看几个图的概念和特性 图：由顶点的有穷非空集合和顶点之间边的集合组成 完全图：图中任意两个顶点之间都存在可直接到达对方的边。分为无向完全图和有向完全图，其中无向完全图有n(n-1)/2条边，有向完全图有n(n-1)条边 稀疏图：边数很少的图，反之为稠密图 简单路径：路径的顶点序列中不存在重复的顶点 连通图：任意两点之间都有路径可达(不需要直接可达)的无向图 强连通图：任意两点之间都有路径可达的有向图 连通分量：非连通无向图中的极大连通子图(顶点数最大)叫做连通分量 强连通分量：非强连通有向图的极大强连通子图叫做强连通分量 连通图的生成树：连通图的极小连通子图。有n个顶点时，只有n-1条边，随便加哪两个顶点之间的边都将构成环，而生成树里是没有环的。 网：带权图称为网 图的存储结构由于图的结构比较复杂，任意两点之间都可能存在联系，难以用元素在内存中的物理位置来表示元素之间的关系，也就是图不可能用简单的顺序存储结构来表示。前辈们给我们提供了图的5种存储结构： 图的邻接矩阵存储方式：将图的点和边分开存储，用一个一维数组加一个二维数组来表示图。一维数组存储图中的顶点信息，二维数组(邻接矩阵)存储图中边或弧的信息。当然，边数组不仅可以存储0,1这两个数字，如果是带权图(网)，边数组中还能存储对应边的权值。不过这时需要指定一个比较大的数来标识图中不存在的边，如代码中的Infinity。如下图所示：我们可以通过给顶点数组和边数组输入数据，来创建邻接矩阵图。当然，由于是数组，需要先输入要创建的图的顶点数numVertexs和边数numEdges。代码如下： 1234567891011121314151617181920212223242526272829303132333435class AdjacencyMatrixGrpah&#123; int numVertexs; int numEdges; object[] Vertexs; int[,] EdgesMatrix; //Infinity标识图中不存在的边 const int Infinity = 66535; //建立邻接矩阵图 public void CreateGraph() &#123; numVertexs = Convert.ToInt32(Console.ReadLine()); numEdges = Convert.ToInt32(Console.ReadLine()); Vertexs = new object[numVertexs]; EdgesMatrix = new int[numVertexs,numVertexs]; //建立顶点数组 for (int i = 0; i &lt; numVertexs; i++) &#123; Vertexs[i] = Console.ReadLine(); &#125; //初始化边数组(邻接矩阵) for (int i = 0; i &lt; numVertexs; i++) &#123; for (int j = 0; j &lt; numVertexs; j++) &#123; EdgesMatrix[i,j] = Infinity; &#125; &#125; //将图中的带权边存储到邻接矩阵中 for (int k = 0; k &lt; numEdges; k++) &#123; int i = Convert.ToInt32(Console.ReadLine()); int j = Convert.ToInt32(Console.ReadLine()); int weight = Convert.ToInt32(Console.ReadLine()); EdgesMatrix[i, j] = weight; &#125; &#125;&#125; 【注】： 上面代码是针对有向图的，如果是无向图，只需要把EdgesMatrix[i, j] = weight;改为EdgesMatrix[i, j] = EdgesMatrix[j, i] = weight;，因为无向图的邻接矩阵是一个对称矩阵。 在邻接矩阵主对角线上的元素，即顶点到自身的边，我也是设置为Infinity的，并非像上图中那样主对角线上的元素都为0 图的邻接表存储方式：可以看到在图的邻接矩阵存储方式中，还有很多没有用到的空间，尤其是在稀疏图中，将会浪费很多存储空间。所以我们考虑用链表替换邻接矩阵中的每一行，减少空间浪费。但是图中每个结点的出度不一样，不方便把每个结点的邻接结点引用都存储的自身结点中，其实可以用类似树中的孩子表示法，把结点的所有邻接结点都用链表连起来。这就是图的邻接表存储方式，如下图所示：需要的数据结构有：顶点类+邻接结点类+图(类)顶点类由两个数据成员组成：顶点数据、第一个邻接结点的引用邻接结点类由三个数据成员：邻接结点在数组中的下标、权值、下一个邻接结点的引用图(类)的数据成员主要是：顶点类数组代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class VertexNode &#123; public object Data; public AdjacencyNode FirstAdjacencyNode; public VertexNode() &#123; Data = null; FirstAdjacencyNode = null; &#125; public VertexNode(object data) &#123; Data = data; FirstAdjacencyNode = null; &#125;&#125;//邻接结点类public class AdjacencyNode &#123; public int NodeIndex; public int Weight; public AdjacencyNode NextAdjacencyNode; const int Infinity = 65535; public AdjacencyNode() &#123; NodeIndex = -1; Weight = Infinity; NextAdjacencyNode = null; &#125; public AdjacencyNode(int index,int weight) &#123; NodeIndex = index; Weight = weight; NextAdjacencyNode = null; &#125;&#125;//邻接表图类class AdjacencyListGraph&#123; private VertexNode[] Vertexs; int numVertexs; int numEdges; //建立邻接表图 public void CreateGraph() &#123; numVertexs = Convert.ToInt32(Console.ReadLine()); numEdges = Convert.ToInt32(Console.ReadLine()); Vertexs = new VertexNode[numVertexs]; //建立顶点数组 for (int i = 0; i &lt; numVertexs; i++) &#123; object data = Console.ReadLine(); Vertexs[i] = new VertexNode(data); &#125; //建立顶点的邻接结点链表(边表) for (int k = 0; k &lt; numEdges; k++) &#123; int i = Convert.ToInt32(Console.ReadLine()); int j = Convert.ToInt32(Console.ReadLine()); int weight = Convert.ToInt32(Console.ReadLine()); AdjacencyNode newNode = new AdjacencyNode(j, weight); //头插法 newNode.NextAdjacencyNode = Vertexs[i].FirstAdjacencyNode; Vertexs[i].FirstAdjacencyNode = newNode; //无向图还要同时对另一个顶点对称操作，有向图就不需要下面的代码了 AdjacencyNode newNode1 = new AdjacencyNode(i, weight); //头插法 newNode1.NextAdjacencyNode = Vertexs[j].FirstAdjacencyNode; Vertexs[j].FirstAdjacencyNode = newNode1; &#125; &#125; &#125; 图的十字链表存储方式 图的邻接多重表存储方式 图的边集数组存储方式 图的遍历图的遍历：从图中某一顶点出发访遍图中其余顶点，且要求每个顶点仅被访问一次。分为深度优先遍历DFS(depth first search)和广度优先遍历BFS(breadth first search)。 深度优先遍历DFS先来看下面这个图任意选择一个顶点，比如A点，现在开始想象在走这个迷宫，给自己定一个原则：没有碰到重复顶点时，就始终向右手边走，碰到了重复顶点则回退到上一个顶点处，再选择除开重复顶点外的最右手边的路(最右边没被访问过的邻接结点)，如果在某个顶点处所有的路都走过了(所有的邻接结点都被访问过了)，则回退到上一个顶点处。重复上述操作，一直到回退到起点A，这时就能保证连通图中的所有结点都被访问到了，且只被访问了一次(发现是重复结点的那一步不算)。上图的访问过程如下：在A出一直沿着右手边走到F处，再向右走发现A被访问过了，回退到F，再访问F处除了A的最右手边结点G，在G点去访问B，发现B已经访问过了，回退到G，再去访问D，发现D已经访问过了，又回退到G，再访问H，在H点去访问D、E，发现D、E都已经访问过了，按原路回退到上一个访问过的结点G，也没有未被访问过的邻接点，再回退到F，同样没有未被访问过的结点，再回退到E，再回退到D，发现I是没有被访问过的，则去访问I，在I处没有未被访问过的邻接点，回退到D，再回退到C，回退到B，回退到A。此时回到了起点，则访问结束。不难发现，这个访问过程其实就是一棵二叉树的前序遍历过程，如下图：所以，对图的深度优先遍历DFS，其实就是类似对树的前序遍历。注意，上述过程是针对一个连通图来说的，如果不是连通图，则需要把图中每一个顶点作为起点，都来一次深度优先遍历DFS，这样就能保证非连通图也能访问到所有结点了。对邻接矩阵图的深度优先遍历DFS的代码如下(还未上机验证过)： 12345678910111213141516171819//标识每一个节点是否被访问过bool[] Visited;public void DFSTraverse() &#123; Visited = new bool[numVertexs]; for (int i = 0; i &lt; numVertexs; i++) &#123; Visited[i] = false; &#125; DFS(0);&#125;//深度优先遍历DFSpublic void DFS(int i) &#123; Visited[i] = true; Console.WriteLine(Vertexs[i]); for (int j = 0; j &lt; numVertexs; j++) &#123; if (EdgesMatrix[i, j] == 1 &amp;&amp; Visited[j] == false) &#123; DFS(j); &#125; &#125;&#125; 对邻接表图的深度优先遍历DFS的代码如下(还未上机验证过)： 1234567891011121314151617181920212223242526//标识每一个节点是否被访问过bool[] Visited;public void DFSTraverse()&#123; Visited = new bool[numVertexs]; for (int i = 0; i &lt; numVertexs; i++) &#123; Visited[i] = false; &#125; DFS(0);&#125;//深度优先遍历DFSpublic void DFS(int i)&#123; Visited[i] = true; Console.WriteLine(Vertexs[i].Data); AdjacencyNode current = Vertexs[i].FirstAdjacencyNode; while (current != null) &#123; if (Visited[current.NodeIndex] == false) &#123; DFS(current.NodeIndex); &#125; current = current.NextAdjacencyNode; &#125;&#125; 广度优先遍历BFS深度优先遍历类似于树的前序遍历，其实广度优先遍历BFS类似于树的层序遍历。需要先把图调整称为层次分明一点的图。如下图所示：由于是层序遍历，所以是需要借助队列的，如下图所示： 先让图中的任意一个结点入队列 让队头的结点出队列，同时让与此结点相连的其他结点入队列 重复第2步，直到队列为空。广度优先遍历BFS的代码如下： 未完待续]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法之二叉树]]></title>
    <url>%2F2016%2F09%2F01%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[先来看几个二叉树的特点和概念： 二叉树： 二叉树的左子树和右子树是有顺序的，是有序树。 任意一颗二叉树的：叶子数=2度结点数+1 满二叉树：每个分支结点都有左儿子和右儿子，且所有叶子结点位于同一层。如下图： 完全二叉树：按层序编号后，对应结点编号和满二叉树完全相同(完全二叉树的结点数&lt;=满二叉树的结点数)。如下图： 所以，判断某二叉树是否是完全二叉树的方法：看着树的示意图，按照完全二叉树的结构逐层按顺序编号，如果编号出现空挡，则不是完全二叉树。 同样结点的二叉树，完全二叉树的深度最小 具有n个结点的完全二叉树的深度为： 对具有n个结点的完全二叉树【前提条件是2i和2i+1均小于n】：左孩子跟双亲满足关系：2i&lt;=&gt;i右孩子跟双亲满足关系：2i+1&lt;=&gt;i 顺序二叉树任何一颗二叉树的顺序存储都是按其对应的完全二叉树的编号来的，当出现大量空挡(比如右倾斜树)时，会浪费很多存储空间，所以顺序存储一般只用于完全二叉树。 链表二叉树 链表二叉树的数据结构：结点类+树(类)结点类由三个数据成员组成：结点数据、左儿子、右儿子树(类)主要由一个数据成员组成：根结点 建立二叉树要建立一颗二叉树，这棵二叉树应该是已经确定好的，而且需要事先知道该二叉树的前序序列(或中序序列、后序序列)。并且为了确认每一个结点是否有左右孩子，需要将原二叉树进行扩展，也就是将每个二叉树结点内的空指针用一个虚结点代替(假定虚结点数据为#)，得到一颗扩展二叉树。由扩展二叉树得到的前序序列称为完全前序序列。如下图所示：上图的完全前序序列为：AB#D##C##，输入已知的完全前序序列，便能通过CreateBinaryTree()函数来建立该二叉树。代码见后面。 遍历二叉树二叉树的遍历是从根节点开始的。按照根结点访问次序的不同，分为三种遍历方式：前序遍历、中序遍历、后序遍历，另外还有一种层序遍历。 前序遍历：先根再左再右遍历规则：若结点为空，则返回，否则先访问根结点，再访问左子树，再访问右子树。如下图所示：遍历的顺序(前序序列)为：ABDGHCEIF 中序遍历：先左再根再右遍历规则：若结点为空，则返回，否则先访问左子树，再访问根结点，再访问右子树。如下图所示：遍历的顺序(中序序列)为：GDHBAEICF 后序遍历：先左再右再根遍历规则：若结点为空，则返回，否则先访问根结点，再访问左子树，再访问右子树。如下图所示：遍历的顺序(后序序列)为：GHDBIEFCA 层序遍历：按层从左到右访问结点如下图所示：遍历的顺序(层序序列)为：ABCDEFGHI 上面得到的各种遍历序列可以用来创建二叉树，当然也可以根据各种遍历方法来遍历已经创建好的二叉树，前序、中序、后序遍历的代码见后面。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class BinaryTreeNode &#123; public object Data; public BinaryTreeNode LeftChild; public BinaryTreeNode RightChild; public BinaryTreeNode() &#123; Data = null; LeftChild = null; RightChild = null; &#125; public BinaryTreeNode(object data) &#123; Data = data; LeftChild = null; RightChild = null; &#125;&#125;class BinaryTree&#123; public BinaryTreeNode root; //按前序序列建立二叉树(中序、后序建立的代码类似) public void CreateBinaryTree(ref BinaryTreeNode root) &#123; object data; data=Console.ReadLine(); if (data.Equals("#")) &#123; root = null; return; &#125; root = new BinaryTreeNode(data); CreateBinaryTree(ref root.LeftChild); CreateBinaryTree(ref root.RightChild); &#125; //前序遍历二叉树(中序、后序遍历的代码类似） public void PreOrderTraverse(BinaryTreeNode root) &#123; if (root == null) return; Console.Write(root.Data+" "); PreOrderTraverse(root.LeftChild); PreOrderTraverse(root.RightChild); &#125; //中序遍历二叉树 public void InOrderTraverse(BinaryTreeNode root) &#123; if (root == null) return; InOrderTraverse(root.LeftChild); Console.Write(root.Data + " "); InOrderTraverse(root.RightChild); &#125; //后序遍历二叉树 public void PostOrderTraverse(BinaryTreeNode root) &#123; if (root == null) return; PostOrderTraverse(root.LeftChild); PostOrderTraverse(root.RightChild); Console.Write(root.Data + " "); &#125;&#125; 二叉树前序、中序、后序序列的推导 小技巧：推导一棵树的前序、中序、后序序列时，可以想着对应的递归代码来推导，不容易出错。 已知前序序列和中序序列，推导后序序列：把握两个关键点：前序、后序序列用于确定树或子树的根结点是谁，而中序序列用于确定哪些结点位于根节点左边，哪些结点位于根节点右边。如：已知一颗二叉树前序序列为ABCDEF，中序序列为CBAEDF，求后序序列： 根据前序序列ABCDEF可知，结点A为树的根结点(最前面的是根结点)，再由中序序列CBAEDF可知结点CB位于A的左边，结点EDF位于A的右边。如下图所示： 由前序序列中的BC可知，在BC子树中，B是根结点(最前面的是根节点)。又由中序序列的CB可知C应该位于B的左边。如下图所示： 由前序序列的DEF可知，在DEF子树中，D是根结点(最前面的是根结点)。又由中序序列的EDF可知E位于D的左边，F位于D的右边。如下图： 已知后序序列和中序序列，推导前序序列：唯一的不同之处在于：如上面的第1、2、3步，在前序序列(先根再左再右)中，最前面的是根节点，而在后序序列(先左再右再根)中最后的才是根结点。 已知前序序列和后序序列，是无法唯一确定一颗二叉树的。原因很简单，因为没有中序序列，无法确定哪些结点位于根结点左边，哪些结点位于根结点右边。 【注】：不画出二叉树也可以很快推导对应序列。关键点在于：由前序或后序来确定根结点，由中序来确定哪些结点位于根结点左边，哪些结点位于根结点右边。如下图所示： 线索二叉树 在扩展二叉树里面，我们就已经看到一颗二叉树里其实还留有很多空引用(指针)，主要来源于叶子结点和单分支结点(1度结点)。 在链表二叉树里面，我们只能直接知道结点的左右儿子是谁，而如果要知道某个结点在对应序列中的前驱和后继是谁，就必须得重新遍历一次。 其实可以考虑把那些空引用用来存储结点的前驱和后继。更巧的是，一颗二叉树中的空引用数目和所有结点的前驱后继总数刚好相等。 我们把这种指向前驱和后继的引用称为线索，加上线索的二叉树便成了线索二叉树。所以线索化的实质就是将链表二叉树中的空引用利用起来，去指向结点的前驱和后继。如下图所示：将该二叉树线索化后：仔细观察会发现线索化后的二叉树其实就是一个双向链表，如下图：既然是双向链表，那么可以给它加上一个头结点，方便我们既可以从第一个结点沿着后继进行遍历，也可以从最后一个结点沿着前驱进行遍历。 还有一个问题，原来的空引用变成了前驱和后继，那么怎么和原来那些指向左右儿子的非空引用区别开来呢？这时我们需要两个标志位，来分别标识两个引用到底是指向左右儿子还是作为前驱后继：ltag为0时表示指向结点的左儿子，为1时表示指向结点的前驱；rtag为0时表示指向结点的右儿子，为1时表示指向结点的后继。如下图所示：线索二叉树的数据结构：和二叉树的数据结构类似，只是结点类增加了两个数据成员：ltag、rtag。 可以在前序遍历的过程中就实现线索化。由于线索二叉树其实是一个双向链表，所以可以按照链表的遍历方式来遍历线索二叉树了，省去了递归的大量开销。代码中的CluePreOrderTraverse()函数其实是模拟了二叉树的前序遍历，先一直向左，再向右，利用RightChild访问到下一个序列结点。可参考线索二叉树标题下的第一幅图（有后继的那幅图）。部分代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class ClueBinaryTreeNode&#123; public object Data; public ClueBinaryTreeNode LeftChild; public ClueBinaryTreeNode RightChild; public int LeftTag; public int RightTag; ...&#125;class ClueBinaryTree&#123; public ClueBinaryTreeNode first; //全局变量，指向刚刚访问过的结点 ClueBinaryTreeNode pre; public ClueBinaryTree() &#123; first = new ClueBinaryTreeNode(); &#125; //前序遍历过程中实现线索化 void PreOrderTraverse(ClueBinaryTreeNode root) &#123; if (root == null) return; //设置当前结点的前驱 if (root.LeftChild == null) &#123; root.LeftTag = 1; root.LeftChild = pre; &#125; //设置前驱结点的后继为当前结点 if (pre.RightChild == null) &#123; pre.RightTag = 1; pre.RightChild = root; &#125; pre = root; PreOrderTraverse(root.LeftChild); PreOrderTraverse(root.RightChild); &#125; //用双向链表的方式来遍历线索二叉树 void CluePreOrderTraverse() &#123; ClueBinaryTreeNode current; current = first.LeftChild; while (current != first) &#123; while (current.LeftTag == 0) &#123; current = current.LeftChild; &#125; Console.WriteLine(current.Data); while (current.RightTag == 1 &amp;&amp; current.RightChild != first) &#123; current = current.RightChild; Console.WriteLine(current.Data); &#125; current = current.RightChild; &#125; &#125; ...&#125; 树、森林与二叉树的转换 树转换为二叉树 兄弟加线：在所有兄弟之间加一条连线 非长子去线：对树中每个结点，只保留它与第一个孩子结点的连线，删除它与其他孩子结点之间的连线 层次调整：以树和子树的根结点为轴心，将整棵树顺时针旋转一定的角度，使之结构层次分明。【注意第一个孩子是二叉树结点的左孩子，兄弟转换过来的孩子是结点的右孩子】如下图所示： 森林转换为二叉树：每棵树的根结点依次作为右兄弟 把每个树转换为二叉树 把后一棵二叉树的根结点作为右孩子连到前一棵二叉树的根结点上。再调整层成层次分明的二叉树 如下图所示： 二叉树转换为树 加线：二叉树及其所有子树的根结点与它的长子的右孩子加线 去线：删除原二叉树中所有结点与其右孩子结点的连线 层次调整，使其结构层次分明 如下图所示： 二叉树转换为森林(森林到二叉树的逆转换) 首先要判断一棵二叉树能否转换成森林，需要看二叉树的根结点是否有右孩子，如果有则删掉与右孩子的连线。一直进行下去，直到分离的所有二叉树根结点与右孩子的连线都删除为止 将每棵分离的二叉树转换为树 如下图所示： 二叉树的应用之哈夫曼树树的带权路径长度WPL：树中所有叶子结点的权值乘以路径长度的和。带权路径长度WPL最小的二叉树称为哈夫曼树。哈夫曼树又称带权最优二叉树。 求解哈夫曼树的方法： 把所有带权值得叶子节点排成一个序列 取出权值最小的两个加起来，作为新结点，加入到序列中(取出的两个结点报废)，并在对应哈夫曼树的结构图作为取出的两个结点的双亲结点 重复第二步，直到序列中不再有结点为止 假设六个字母的频率为A 27，B 8，C 15，D 15，E 30，F 5，则由它们构成的哈夫曼树如下图所示：规定哈夫曼树的左分支代表0，右分支代表1，则从叶子结点到根结点的01序列就是对应字符的哈夫曼编码。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#常用容器]]></title>
    <url>%2F2016%2F08%2F30%2FC%23%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[C#常用容器如下： T[]：静态数组，连续内存，可快速地随机访问和遍历 List：可变大小，固定类型，连续内存，可快速地随机访问和遍历 ArrayList：可变大小，泛型容器，但是性能开销大 LinkedList/LinkedListNode：双向链表，可快速地随机插入删除 Dictionary：散列字典，快速查找，但是性能开销大 HashSet：单项散列表，快速查找，但是性能开销大(优于Dictionary) Queue：队列，快速入队出队 Stack：栈]]></content>
      <categories>
        <category>C#语法</category>
      </categories>
      <tags>
        <tag>C#容器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法之树]]></title>
    <url>%2F2016%2F08%2F30%2F%E6%A0%91%2F</url>
    <content type="text"><![CDATA[树：任意一颗树或其子树都只有一个根节点，且子树之间互不相交。节点的度：结点拥有的子树数目，或者说结点的直接子节点的数目。树的度：树中所有结点的度的最大值。 树的存储结构 双亲表示法为了让每一个结点都能很快地找到它的双亲结点，我们可以给每一个结点附加一个双亲结点引用，指向该结点的双亲结点。伪码如下： public class ParentNode { public object Data; public ParentNode Parent; public ParentNode() { } } class ParentTree { private ParentNode root; public ParentTree() { } ... } 但是如果某结点想要找到它的子节点是谁，用上面的存储结构就得把整个树重新遍历一次。可以考虑给每个结点再增加一个长子(最左孩子)结点引用。如果结点还想要知道自己的兄弟是谁，可以考虑再给每个结点增加一个右兄弟结点引用。当然，如何设计要看具体情况，适度够用就好，要避免过度设计。【注】：树的双亲表示法用数组也很好实现，只需要把Parent引用改为双亲节点在数组中的位置(数组下标)即可。 孩子表示法孩子表示法是从结点的n个孩子来看问题的。首先想到的表示方法应该是：把每个结点的所有孩子引用都在结点中存储起来，如下图：但是树的每个结点的孩子个数可能不一样，那结点到底该准备多少个孩子引用呢？一种方法是：让孩子引用个数等于树的度，但是这样会浪费很多引用的存储空间，因为很可能某些结点并没有那么多孩子。第二种方法是：让每个结点孩子引用的个数等于该结点的度，可是仔细考虑，虽然这种方法节省了存储空间，但是由于每个结点的引用个数不同，也就是每个结点的存储结构不一样，这会给遍历、查找、删除等等操作带来很大的运算开销，时间复杂度会很高。其实问题的根源出在：为何一定要把所有孩子引用都存储到双亲结点中呢？上面的方法相当于在结点中开辟了一个数组，用来存储孩子引用，但是每个结点的这个数组大小是不一样的，相当于是需要一个动态变化的数组。而这恰巧是数组的弊端，一般数组的大小初始化后都是固定不变的，而解决数组这个弊端的方法就是用链表：把数组中的元素(结点的所有孩子)用链表连起来，这样就不用考虑结点到底该用多少个存储单元来放置孩子引用了。图示如下：不过总不能让这些结点及其链表都独立存在吧，需要用一个数组把这些节点存储起来就ok，每个节点跟着一个孩子链表，如下图：上图就是孩子表示法。 树的孩子表示法的数据结构：表头结点类+孩子结点类+树(类)。 表头结点类由两个数据成员组成：结点数据+孩子结点引用(长子) 孩子结点类也由两个数据成员组成：结点的数组下标+孩子结点引用(指向该孩子结点的右兄弟) 树(类)主要由一个数据成员组成：表头结点数组 伪码如下： public class ArrayNode { public object Data; public ChildNode FirstChild; public ArrayNode() { } } public class ChildNode { public int index; public ChildNode RightBrother; public ChildNode() { } } class ChildTree { ArrayNode[] Headers; public ChildTree() { } ... } 如果结点还想知道它的双亲是谁，可以在表头结点中再加一个数据成员：双亲结点的数组下标，标识该结点的双亲结点是谁。这种表示结构叫孩子双亲表示法 孩子兄弟表示法：孩子兄弟表示法是从结点的孩子和兄弟来看问题的。在孩子表示法中，是把一个结点的所有孩子都存储在一个链表中，也就是一个孩子和这个孩子的兄弟都在一个链表中。因为每一个孩子其实也是一个结点，而且它的右兄弟是唯一的，所以其实也可以把右兄弟引用搬到结点中去，作为结点的数据成员。这样就省去了给每个结点建立一个子链表的操作。图示如下：这棵树用孩子兄弟表示法如下：其实仔细看，上面的表示结构其实是一颗二叉树。所以，孩子兄弟表示法的最大好处在于它能够把一个复杂的树变成一颗二叉树。 树的孩子兄弟表示法的数据结构：结点类+树(类) 结点类由三个数据成员组成：结点数据+孩子结点引用(指向结点的第一个孩子)+右兄弟结点引用 树(类)主要由一个数据成员组成：树根结点 伪码如下： public class ChildBrotherNode { public object Data; ChildBrotherNode FirstChild; ChildBrotherNode RightBrother; public ChildBrotherNode() { } } class ChildBrotherTree { ChildBrotherNode root; public ChildBrotherTree() { } ... } 二叉树请看另一篇博文《数据结构与算法之二叉树》]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法之队列]]></title>
    <url>%2F2016%2F08%2F28%2F%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[队列：只允许在一端进行插入操作，在另一端进行删除操作的线性表。允许插入的一端称为队尾，允许删除的一端称为队头。 顺序队列 最简单的顺序队列：由数组构成，入队时在数组元素尾部插入新元素，出队时移去数组下标为0的元素，同时其他数组元素向前移动一个位置。就像一群人在买票，前面的人离开，后面的人就会全部向前一步，补上空位。图示如下：入队列：出队列：C#的容器已经实现了这个在尾部插入数据、在头部删除数据并且自动补位的功能，用C#容器实现的队列代码如下(由于C#自带实现队头队尾的插入删除，所以不需要队头队尾节点的引用)： class SequenceQueue { private ArrayList Data; public SequenceQueue() { Data = new ArrayList(); } //入队列 public void EnQueue(object data) { Data.Add(data); } //出队列 public void DeQueue(ref object data) { data = Data[0]; Data.RemoveAt(0); } //查找队列第i个元素 public object Find(int i) { return Data[i]; } //清除队列 public void Clear() { Data.Clear(); } //队列元素个数 public int Count() { return Data.Count; } } 循环队列 但是上面的队列实现方式有个性能缺陷：出队列时所有元素都要移位。所以我们可以设置一个队头和队尾的引用(指针)，出队列时直接把队头引用处的结点移除，入队列时直接把元素添加到队尾引用所在的节点，而其他元素不用动，只是在入队列和出队列时修改队头引用或者队尾引用即可。所以，队头引用front指向队头元素，队尾引用rear指向队尾元素的下一个位置(方便下次入队时直接添加到该位置)。但是，这种方式存在下图的尴尬(针对固定容量的队列，非ArrayList这种大小可变的容器)：若再在rear位置入队插入新元素，则会溢出，但是明显数组前面还有空位，是可以插入新元素的。就像坐公交，前面有空位置肯定是要去座的。为了让新元素能够按次序插入到前面的空位里去，应该把队列的首尾连起来，形成循环队列，这样新元素插入到前面的空位就水到渠成了。还有一个问题，如下：如上图所示，队列空和队列满的条件都是front==rear，为了区分他俩，我们人为设定：数组中只剩下一个空闲单元时，就认为队列已经满了。即敲定队列空的条件为：front==rear，队列满的条件为(rear+1)%QueueSize==front。如下图所示：综上，循环队列数据结构：数据成员：数组、队头引用front、队尾引用rear，方法成员：入队、出队等。代码如下： class RoundQueue { private Object[] Data; private int front; private int rear; private int QueueSize; public RoundQueue() { QueueSize = 3; front = 0; rear = 0; Data = new object[QueueSize]; } //入队列 public void EnQueue(object data) { //如果队列满，则不能再入队列 if ((rear + 1) % QueueSize == front) return; Data[rear] = data; rear = (rear + 1) % QueueSize; } //出队列 public void DeQueue(ref object data) { //如果队列空，则不能再出队列 if (rear == front) return; data = Data[front]; front = (front + 1) % QueueSize; } //队列中元素个数 public int Count() { return (rear - front + QueueSize) % QueueSize; } } 优先队列 优先队列不再是每次移除队头的结点元素，而是每次出队优先级最高的结点。严格来说，它已经不算是一个队列。对于优先队列，需要给每一个结点都加上一个表示优先级的数据成员，可以把结点单独写成一个类，如下： class PriorQueueNode{ public object Data; public int Priority; } 优先队列可以继承普通的顺序队列或者循环队列，但是需要重载出队列函数，伪码如下： public override object DeQueue(){ //找出优先队列里优先级最大的结点 for(;;){ } //移除优先级最大的结点 Remove(); } 链队列 因为顺序队列的存储空间有限且大小是固定的，插入时会有溢出，所以我们需要链队列。由于链队列需要在表头(队头)删除结点，删除结点需要知道该结点的前一个结点是谁，为了统一第一个结点和中间结点，需要给链队列加上一个头结点。链队列的队头引用front其实就是指向头结点，是固定不动的，队尾引用rear是一直指向表中的最后一个结点(最后一个结点有Next成员，所以rear不需要指向最后一个结点的下一个位置)。代码如下： public class Node{ public object Data; public Node Next; public Node() { Data = null; Next = null; } public Node(Object data) { Data = data; Next = null; } } class LinkQueue { protected Node header; protected Node front; protected Node rear; public LinkQueue() { header = new Node(); front = header; rear = header; } //入队列 public void EnQueue(object data) { Node newNode = new Node(data); rear.Next = newNode; rear = newNode; } //出队列，队头引用front是不动的，一直指向头结点 public void DeQueue(ref object data) { //队列空，则不再出队列 if (front == rear) return; //队头结点(头结点)的下一个结点就是队尾结点(表中只有一个元素了),则出队列后让队尾引用重新指向头结点 if (front.Next == rear) rear = header; data = front.Next.Data; front.Next = front.Next.Next; } } 【注】： 可以确定队列容量的情况下，建议使用循环队列，如果队列长度不能确定或者需要动态变化时，则需要用链队列]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表中什么时候需要用到头结点]]></title>
    <url>%2F2016%2F08%2F28%2F%E5%A4%B4%E7%BB%93%E7%82%B9%2F</url>
    <content type="text"><![CDATA[链表中什么时候需要用到头结点： 需要统一对第一个结点和中间结点的操作 ，这时需要加上头结点 链接的方向(引用/指针指向的方向)是从表头指向表尾时，这时需要加上头结点，因为需要对开始节点初始化内存以后，才能使用Node.Next。不可能在插入结点的函数里去指定第一个插入的结点是表头结点，因为这样会增加复杂度，每次都要判断插入的结点会不会是表里的第一个节点 存在对链表的第一个结点的删除操作时，这时需要加上头结点。就像队列，出队列时需要删除表中第一个结点，如果链接方向是从表头指向表尾，虽然node=node.next就可以从容器中删除第一个结点，但是从第二条看，初始化时还是需要头结点的。 因为在栈里只存在对表尾结点的插入删除，不涉及中间结点，也不涉及对第一个结点的删除(栈中只有一个结点时，该结点也可以被看作是表尾结点来处理)，所以从原理上栈是可以不要头结点的，所有栈采用了从表尾指向表头的链接方式。而队列中存在对第一个结点的删除操作，所以是需要头结点作为辅助的。 链接方向从表头指向表尾(比如队列)：链接方向从表尾指向表头(比如栈)【头结点：链表头部不存放数据的一个结点，是有真实内存的，不同于结点引用、头指针等等，头结点存在的意义在于降低程序/时间复杂度】]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>头结点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法之栈]]></title>
    <url>%2F2016%2F08%2F26%2F%E6%A0%88%2F</url>
    <content type="text"><![CDATA[栈：只允许在表尾(栈顶)进行插入和删除操作的的线性表。 顺序栈 顺序栈是由数组+栈顶引用(指针)构成的。由于是数组，所以下标较小的那一端作为固定的栈底。程序员习惯数字从0开始，所以当栈中存在一个元素时，栈顶引用top等于0，所以栈空时top=-1。 class SequenceStack { private ArrayList Data; private int Top; public SequenceStack() { Data = new ArrayList(); Top = -1; } //进栈 public void Push(object data) { Top++; Data.Add(data); } //出栈 public void Pop(ref object data) { if (Top == -1) { return; } data = Data[Top]; Top--; } //栈中元素数量 public int Count() { return Data.Count; } //清空栈 public void Clear() { Data.Clear(); Top = -1; } } 【注】： 上述代码用的是C#语言，如果用C++就不能再用ArrayList了，应该指定数组容量：Data[MaxSize]，且push操作还要在函数内加上数组是否越界的判断 实际问题中尽量使用List代替ArrayList，因为ArrayList性能开销大，可参考博客《C#常用容器》 两顺序栈共享空间 因为实际情况中，有可能出现一个栈已经满了，而另一个栈还有很多存储空间的情形。这时可以把两个栈合并成一个栈：它有两个栈底，一个栈底为数组的始端(下标最小处)，一个栈底为数组的末端(下标最大处)。这样由于两个栈底在数组的两端，所以对这两个栈进栈时，就会向数组的中间靠拢。 栈满就是两个栈见面之时，即Top1+1==Top2为栈满 Push和Pop操作时都要传入一个stackNumber参数，表示是对栈1还是栈2操作 适用情况：两个栈数据类型相同，且一个栈增长时另一个栈在缩短。 class ShareStack { Object[] Data; int Top1; int Top2; int MaxSize = 50; public ShareStack() { Data = new object[MaxSize]; Top1 = -1; Top2 = MaxSize; } public void Push(Object data,int stackNumber) { //栈满就不能再push新元素了 if (Top1 + 1 == Top2) { return; } if (stackNumber == 1){ Top1++; Data[Top1] = data; } else if (stackNumber == 2) { Top2--; Data[Top2] = data; } } public void Pop(ref object data,int stackNumber) { if (stackNumber == 1){ //栈1空则栈1不能再pop if (Top1 == -1) return; data = Data[Top1]; Top1--; } else if (stackNumber == 2) { //栈2空则栈2不能再pop if (Top2 == MaxSize) return; data = Data[Top2]; Top2++; } } } 链栈 链栈其实就是对单链表的改造，由于链栈只在栈顶(表尾)插入删除，不会对链表中间结点有插入删除操作，所以链栈不再需要头结点。但是需要一个栈顶节点的引用(指针) public class Node { public Object Data; public Node Next; public Node() { Data = null; Next = null; } public Node(Object data) { Data = data; Next = null; } } class LinkStack { protected Node Top; public LinkStack(){ Top = null; } //进栈 public void Push(object data) { Node newNode = new Node(data); newNode.Next = Top; Top = newNode; } //出栈 public void Pop(ref object data) { //栈空则不再出栈 if (Top == null) return; data = Top.Data; Top = Top.Next; } } 栈的应用——递归之斐波那契数列 形如：0，1，1，2，3，5，8，13……，它除了第一项是0和第二项是1以外，其余每项都是其前两项的和，这个数列被称为斐波那契数列。用数学函数定义如下：不用递归输出斐波那契数列前40项，代码如下： static void Main(string[] args) { int[] a = new int[40]; a[0] = 0; a[1] = 1; Console.WriteLine(a[0]); Console.WriteLine(a[1]); for (int i = 2; i &lt; 40; i++) { a[i] = a[i - 1] + a[i - 2]; Console.WriteLine(a[i]); } Console.ReadKey(); } 用递归输出斐波那契数列前40项，代码如下： static void Main(string[] args) { for (int i = 0; i &lt; 40; i++) { Console.WriteLine(FBNQ(i)); } Console.ReadKey(); } static int FBNQ(int i) { if (i == 0) return 0; if (i == 1) return 1; return FBNQ(i - 1) + FBNQ(i - 2); } 而编译器是用栈来实现递归的。在向下递归阶段，对于每一层递归，函数的局部变量、参数值以及返回地址都被压入栈中，在向上回溯阶段，位于栈顶的局部变量、参数值和返回地址被弹出，用于返回调用层次中执行代码的其余部分，也就是恢复了被调用时的状态。【注】： 每个递归定义必须至少有一个递归终止的条件，即不再是调用自身而是返回一个具体的值退出 大量的递归调用会建立函数的副本，会消耗大量的时间和内存。而像第一种代码这种迭代是不需要反复调用函数和占用额外内存的 栈的应用——四则运算表达式求值 为了方便计算机运算，需要把人们习惯的中缀表达式利用栈转化为计算机更容易处理的后缀表达式，计算机在后缀表达式的基础上再利用栈计算出最后的结果。所以分为两步：中缀转后缀表达式(逆波兰式)、后缀表达式计算结果 中缀转后缀表达式“9+(3-1)x3+10/2”，这是中缀表达式，而”9 3 1-3*+10 2/+”，这是它的后缀表达式。中缀转后缀表达式的方法：从左到右遍历中缀表达式的每个数字和符号，遇到数字则输出，作为后缀表达式的一部分，遇到符号，则判读当前符号与栈顶符号的优先级，若大于则进栈，否则使栈顶符号出栈，直到当前符号优先级大于栈顶符号优先级，再把当前符号进栈。重复上述操作一直到遍历完且栈空为止(即输出了最终的后缀表达式)核心思想：遍历的当前符号的优先级大于栈顶符号优先级则进栈，否则出栈图示如下： 后缀表达式计算结果从左到右遍历后缀表达式的每个数字和符号，遇到数字则进栈，遇到符号则让栈顶的两个数字出栈并进行运算，再将运算结果进栈。重复上述操作一直到栈空核心思想：数字进栈，遇到符号则让数字出栈运算，运算结果再进栈图示如下： 【注】： 中缀转后缀表达式是符号进栈，而后缀表达式计算结果是数字进栈]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法之链表]]></title>
    <url>%2F2016%2F08%2F24%2F%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[由于数组的删除、插入是很费时的，所以我们需要链表。 链表的数据结构：节点类+链表类 节点类：表示链表中的节点，由两个数据成员组成：节点数据Data，指向表内下一节点的引用Link public class Node { public Object Data; public Node Next; public Node() { Data = null; Next = null; } public Node(Object theData) { Data = theData; Next = null; } } 链表类：表示链表中节点之间的链接。数据成员只有一个头节点(如果要用到尾插法，则还需要一个尾节点)，类方法包括：构造函数、链表创建(分为头插法和尾插法)、查找、插入、删除、遍历 class LinkedList { protected Node header; protected Node tailer; public LinkedList() { header = new Node(); tailer = header; } //头插法创建单链表(非整表创建) public void InsertHead(Object theData) { Node newNode = new Node(theData); newNode.Next = header.Next; header.Next = newNode; } //尾插法创建单链表(非整表创建) public void InsertTail(Object theData) { Node newNode = new Node(theData); tailer.Next = newNode; tailer = newNode; } //查找 public Node Find(Object theData) { Node current = header.Next; while (current != null &amp;&amp; !current.Data.Equals(theData)) { current = current.Next; } return current; } //插入(在指定内容(theData)的节点后插入新节点) public void Insert(Object theData,Object newData) { Node current = header.Next; while (current != null &amp;&amp; !current.Data.Equals(theData)) { current = current.Next; } //以上的代码和Find方法一致 if (current != null) { Node newNode = new Node(newData); newNode.Next = current.Next; current.Next = newNode; } } //删除(删除指定内容的节点) public void Remove(Object theData) { Node current = header.Next; Node previous = header.Next; while (current != null &amp;&amp; !current.Data.Equals(theData)) { previous = current; current = current.Next; } //以上代码和Find方法类似 if (current != null) { previous.Next = current.Next; } } //遍历 public void ShowList() { Node current = header.Next; while (current != null) { Console.WriteLine(current.Data); current = current.Next; } } } 注： 其中的头插法和尾插法都只是向链表中插入了一个节点，如果需要插入多个节点，多次调用即可。这是非整表创建的一种方式，如果需要整表创建，可在LinkedList类中加入如下代码：//头插法整表创建 public void CreateListHead(int n) { for (int i = 0; i &lt; n; i++) { Object data; data=Console.ReadLine(); InsertHead(data); } } //尾插法整表创建 public void CreateListTail(int n) { for (int i = 0; i &lt; n; i++) { object data; data = Console.ReadLine(); InsertTail(data); } } 在代码中节点的数据类型是Object，而在实际问题中最好换成相应的数据类型，否则像list.InsertTail(1);等等传入数值时，将会发生多次装箱拆箱过程，浪费资源 循环链表循环链表只是把单链表作些许改动： 尾节点不再是指向null，而是指向头节点header 判断循环结束的条件不再是current是否为null，而是current不等于头节点header 为了让查找头节点和尾节点的时间复杂度都为O(1)，需要保留一个尾节点的引用(如上述代码中的tailer)，如下图： 使用尾节点引用还可以方便地将两个链表链接成一个表：将上面两个循环链表合并成一个链表，如下：合并的代码如下：headerA = rearA-&gt;next; //保存A表的头节点,即图中1 rearA-&gt;next = rearB-&gt;next-&gt;next; //将A表的尾节点的Link指向B表的第一个节点(非B表头节点),即图中2 rearB-&gt;next = headerA; //将B表的尾节点的Link指向A表的头节点,即图中3 双向链表双向链表在单链表上做出的改动： 节点类增加一个数据成员prior，指向该结点的前驱结点。代码如下： public class Node { public Object Data; public Node next; public Node prior; //双向链表新增的数据成员 public Node() { Data = null; next = null; prior = null; } public Node(Object theData) { Data = theData; next = null; prior = null; } } 插入结点时要不仅要考虑next，还要考虑prior对应代码如下：(顺序很重要) s-&gt;prior = p; s-&gt;next = p-&gt;next; p-&gt;next-&gt;prior = s; p-&gt;next = s; 删除结点时也要考虑到prior对应代码如下： p-&gt;prior-&gt;next = p-&gt;next; p-&gt;next-&gt;prior = p-&gt;prior; 链表中头结点存在的意义： 如果没有头结点，那么对链表的第一个节点和中间节点的插入删除操作就是不一样的，需要把第一个结点分开来处理，而有了头结点以后，原来的第一个结点和中间结点都变成了中间结点，不用再分开处理。加入头结点后对链表中的所有结点操作就变得一致了。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#语法之测试程序时间花费]]></title>
    <url>%2F2016%2F08%2F24%2F%E6%B5%8B%E8%AF%95%E7%A8%8B%E5%BA%8F%E6%97%B6%E9%97%B4%2F</url>
    <content type="text"><![CDATA[不多说，直接上代码 using System; using System.Diagnostics; namespace timeTest { class Program { static void Main(string[] args){ int[] nums = new int[100000]; TimeSpan duration; BuildArray(nums); duration = Process.GetCurrentProcess().TotalProcessorTime; Console.WriteLine(&quot;Time: &quot;+duration.TotalSeconds); Console.ReadKey(); } static void BuildArray(int[] arr){ for (int i = 0; i &lt;= 99999; i++) { arr[i] = i; } } } } 测试的是程序当前进程的处理器时间，不会包括控制台输出等进程所花费的时间 使用Process类需要using System.Diagnostics; TimeSpan类：表示一个时间间隔]]></content>
      <categories>
        <category>C#语法</category>
      </categories>
      <tags>
        <tag>timeTest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[给博客添加多说评论]]></title>
    <url>%2F2016%2F08%2F23%2F%E8%AE%BE%E7%BD%AE%E5%A4%9A%E8%AF%B4%E8%AF%84%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[Hexo+Github博客添加多说评论 在多说官网 点击我要安装，创建自己的多说域名，其中http://xxx.duoshuo.com 中的xxx就是自己的duoshuo_shortname 打开 主题路径\_config.yml，修改(\增加)duoshuo_shortname为duoshuo_shortname: xxx(xxx参考第一步，注意:后面有一个空格) 打开主题路径\layout\_partial\comment.ejs(不同主题路径可能不一样)，将之间的代码替换为如下：&lt;h2 class=&quot;title&quot;&gt;&lt;%= __(&apos;comment&apos;) %&gt;&lt;/h2&gt; &lt;% if(theme.duoshuo_shortname) { %&gt; &lt;!-- 多说评论框 start --&gt; &lt;div class=&quot;ds-thread&quot; data-thread-key=&quot;&lt;%- page.path %&gt;&quot; data-title=&quot;&lt;%- page.title %&gt;&quot; data-url=&quot;&lt;%- page.permalink %&gt;&quot;&gt;&lt;/div&gt; &lt;!-- 多说评论框 end --&gt; &lt;!-- 多说公共JS代码 start (一个网页只需插入一次) --&gt; &lt;script type=&quot;text/javascript&quot;&gt; var duoshuoQuery = {short_name:&quot;duoshuo_shortname&quot;}; &lt;!-- 替换这里的duoshuo_shortname为第一步的xxx --&gt; (function() { var ds = document.createElement(&apos;script&apos;); ds.type = &apos;text/javascript&apos;;ds.async = true; ds.src = (document.location.protocol == &apos;https:&apos; ? &apos;https:&apos; : &apos;http:&apos;) + &apos;//static.duoshuo.com/embed.unstable.js&apos;; ds.charset = &apos;UTF-8&apos;; (document.getElementsByTagName(&apos;head&apos;)[0] || document.getElementsByTagName(&apos;body&apos;)[0]).appendChild(ds); })(); &lt;/script&gt; &lt;!-- 多说公共JS代码 end --&gt; &lt;% } else if(config.disqus_shortname) { %&gt; &lt;div id=&quot;disqus_thread&quot;&gt; &lt;noscript&gt;Please enable JavaScript to view the &lt;a href=&quot;//disqus.com/?ref_noscript&quot;&gt;comments powered by Disqus.&lt;/a&gt;&lt;/noscript&gt; &lt;/div&gt; &lt;% } %&gt; 重新部署到github即可。打开博客文章便能看到多说评论框了。 【注：博主用的主题是transparent，在github主题官网就能找到，其它主题可能配置方法不太一样，但大多数都大同小异】]]></content>
      <categories>
        <category>博客配置</category>
      </categories>
      <tags>
        <tag>多说</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown的简单语法规则]]></title>
    <url>%2F2016%2F08%2F22%2FMarkDown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[&lt;font size=&quot;5&quot; color=&quot;orange&quot;&gt;标题&lt;/font&gt;### 标题2###### 标题3有序列表(嵌套时需要在序号前加空格)：1. a2. 阿斯顿 &nbsp;a. 阿斯顿 &nbsp;b. 阿达3. 阿达4. 阿斯顿 无序列表：- 撒旦- 阿斯顿- 阿达 链接[百度](http://baidu.com)图片![](http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721517339.jpg)引用> 黄河远上白云间> 一片孤城万仞山 分割线****斜体***粗体** 表格(表格前要空一行，多一个|就会多一个单元格) ad &#124; asd&#124; ad—&#124;:–:&#124; –:h &nbsp;&nbsp;&#124;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&#124; &nbsp; ka &nbsp;&nbsp;&#124;&nbsp;&nbsp;&nbsp; b &#124; &nbsp;b代码框(行)`void fun(){ destroy();}` 代码框(段落),如下格式(或每一行代码前面加4个空格，且代码段前有空行)```csharpvoid fun(){ destroy();}``` ## 公式$$J\_\alpha(x)=\sum _{m=0}^\infty \frac{(-1)^ m}{m! \, \Gamma (m + \alpha + 1)}{\left({\frac{x}{2}}\right)}^{2 m + \alpha }$$ ***&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=&quot;YellowGreen&quot;&gt;文本框背景色&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; ##所展示的效果如下 标题 标题2标题3有序列表： a 阿斯顿a. 阿斯顿b. 阿达 阿达 阿斯顿 无序列表： 撒旦 阿斯顿 阿达 链接百度图片引用 黄河远上白云间一片孤城万仞山 分割线 斜体粗体 表格(表格前要空一行，多一个|就会多一个单元格) ad asd ad h j k 1 2 3 代码框(行)void fun(){ destroy(); }代码框(段落),如下格式(或每一行代码前面加4个空格，且代码段前有空行)123void fun()&#123; estroy();&#125; 公式$$J_\alpha(x)=\sum _{m=0}^\infty \frac{(-1)^ m}{m! \, \Gamma (m + \alpha + 1)}{\left({\frac{x}{2}}\right)}^{2 m + \alpha }$$ 文本框背景色]]></content>
      <categories>
        <category>博客配置</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
      </tags>
  </entry>
</search>
