<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[C++Primer 第十二章动态内存]]></title>
      <url>/2018/03/11/C++Primer%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/</url>
      <content type="html"><![CDATA[<p><font size="5" color="orange">概述</font></p>
<hr>
<ol>
<li>静态内存用来保存局部static对象、类static数据成员以及定义在任何函数之外的变量。栈内存用来保存定义在函数内的非static对象。分配在静态或栈内存中的对象由编译器自动创建和销毁。对于栈对象，仅在其定义的程序块运行时才存在；static对象在使用之前分配，在程序结束时销毁。</li>
<li>除了静态内存和栈内存，每个程序还拥有一个内存池。这部分内存被称作自由空间或堆。程序用堆来存储动态分配的对象，即那些在程序运行时分配的对象。动态对象的生存期由程序来控制，也就是说，当动态对象不再使用时，我们的代码必须显式地销毁它们。</li>
</ol>
<p><font size="5" color="orange">动态内存与智能指针</font></p>
<hr>
<ol>
<li>为了更容易、更安全地使用动态内存，新标准库提供了三种智能指针类型来管理动态对象：shared_ptr和unique_ptr。它们和普通指针的重要区别是它们负责自动释放所指向的对象。shared_ptr允许多个指针指向同一个对象；unique_ptr则独占所指向的对象。</li>
<li>标准库还定义了一个名为weak_ptr的伴随类，它是一种弱引用，指向shared_ptr所管理的对象。</li>
<li>shared_ptr、unique_ptr和weak_ptr都定义在头文件memory中。</li>
<li>智能指针其实是在普通指针上作了一些包装，包括自动释放内存、指向同一对象的指针指针数量（用智能指针类中的计数器保存）等等。</li>
<li>智能指针也是模板类，默认初始化的智能指针中保存着一个空指针：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> p1<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//shared_ptr，可以指向string对象，现在还是空指针</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li>使用智能指针的get成员函数可以获得对应的普通指针：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> p1<span class="token punctuation">;</span>
 <span class="token keyword">auto</span> p <span class="token operator">=</span> p1<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//p是string*类型</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li>shared_ptr独有的操作如下表：</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">make_shared<t>(args)</t></td>
<td>返回一个shared_ptr，指向一个动态分配的类型为T的对象，使用args初始化该对象</td>
</tr>
<tr>
<td style="text-align:center">shared_ptr<t>p(q)</t></td>
<td>p是shared_ptr q的拷贝，此操作会递增q中的计算器。q中的指针必须能转换为T*</td>
</tr>
<tr>
<td style="text-align:center">p=q</td>
<td>p和q都是shared_ptr，所保存的指针必须能相互转换。此操作会递减p的引用计数，递增q的引用计数；若p的引用计数变为0，则将其管理的原内存释放</td>
</tr>
<tr>
<td style="text-align:center">p.unique()</td>
<td>若p.use_count()为1，返回true，否则返回false</td>
</tr>
<tr>
<td style="text-align:center">p,use_count()</td>
<td>返回一个与p共享对象的智能指针数量；可能很慢，主要用于测试</td>
</tr>
</tbody>
</table>
<ol>
<li>我们可以用make_shared函数代替new来生成一个指针，这样更安全，同时不需要匹配的delete操作，因为智能指针在计算器变为0时会自动调用delete：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> p1 <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
 当然用auto来保存make_shared的结果更简单：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">auto</span> p1 <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li>每个shared_ptr都有一个关联的计数器，通常称其为引用计数。无论何时我们拷贝一个shared_ptr，计数器都会增加，当我们给shared_ptr赋予一个新值或是shared_ptr被销毁（例如局部shared_ptr离开其作用域）时，计数器就会递减。一旦一个shared_ptr的计数器变为0，它就会自动释放自己所管理的对象。</li>
<li>当指向一个对象的最后一个shared_ptr被销毁时，shared_ptr类会自动销毁此对象。它是通过析构函数来完成销毁工作的。shared_ptr的析构函数会递减它所指向的对象的引用计数。如果引用计数变为0，shared_ptr的析构函数就会销毁对象，并释放它占用的内存。</li>
<li>如果将shared_ptr存放于一个容器中，而后不再需要全部元素，而只使用其中一部分，要记得用erase删除不再使用的那些元素，否则它们占用的内存将无法释放。</li>
<li>使用动态内存的一个常见原因是允许多个对象共享相同的状态。</li>
<li>使用new进行动态内存分配时，不带()的执行默认初始化，值是未定义的，带()的执行值初始化：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//*p的值是未定义的</span>
<span class="token keyword">int</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//*p2 = 0</span>
std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//本机输出-842150451</span>
std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p2 <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//输出0</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>默认情况下，如果new不能分配所要求的内存空间，它会抛出一个类型为bad_alloc的异常。我们可以改变使用new的方式来阻止它抛出异常：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">//如果分配失败，new抛出std::bad_alloc异常</span>
<span class="token keyword">int</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>nothrow<span class="token punctuation">)</span> <span class="token keyword">int</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//如果分配失败，new返回一个空指针，不抛出异常</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
我们称这种形式的new为定位new。定位new表达式允许我们向new传递额外的参数。这里我们传递的是标准库的一个名为nothrow的对象，告诉它不能抛出异常。bad_alloc和nothrow都定义在头文件new中。</li>
<li>通常情况下，编译器不能分辨一个指针指向的是静态还是动态分配的对象。类似的，编译器也不能分辨一个指针所指向的内存是否已经被释放了。</li>
<li>使用new和delete管理动态内存存在三个问题：<ul>
<li>忘记delete内存。忘记释放动态内存会导致人们常说的“内存泄漏”问题，因为这种内存永远不可能被归还给自由空间了。</li>
<li>使用已经释放掉的对象。通过在释放内存后将指针置位空，有时可以检测出这种错误（delete p; p = nullptr）。</li>
<li>同一块内存释放两次。</li>
</ul>
</li>
<li>坚持使用智能指针，就可以避免所有这些问题。对于一块内存，只有在没有任何智能指针指向它的情况下，智能指针才会自动释放它。</li>
<li><p>接受指针参数的智能指针构造函数时explicit的，我们不能进行内置指针到智能指针之间的隐式转换：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//正确：使用了直接初始化形式</span>
std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//错误：不能将普通指针隐式转换为智能指针</span>

std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//错误：不能将普通指针隐式转换为智能指针</span>
<span class="token punctuation">}</span>
std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">clone1</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//正确，显式创建智能指针</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>定义智能指针时还可以增加一个参数来代替delete，这个参数必须是一个可调用对象：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p1</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>vp<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">delete</span> vp<span class="token punctuation">;</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"delete"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
当智能指针p1离开其作用域时，如果其计数器变为0，将会执行这个可调用的lambda表达式，输出字符串delete。</li>
<li>智能指针还有一个名叫reset的成员函数：<ul>
<li><code>p.reset();</code> ：若p是唯一指向其对象的shared_ptr，reset会释放此对象</li>
<li><code>p.reset(q);</code>：令p指向指针q</li>
<li><code>p.reset(q, d);</code>：令p指向q，并且调用对象d而不是delete来释放q</li>
</ul>
</li>
<li><p>不要混合使用普通指针和智能指针：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> vp<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">process</span><span class="token punctuation">(</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//合法，但函数退出后p指向的内存会被释放，p称为悬空指针</span>
<span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当将一个shared_ptr绑定到一个普通指针时，我们就将内存的管理责任交给了这个shared_ptr。一旦这样做了，我们就不应该再使用内置指针来问shared_ptr所指向的内存了。</p>
</li>
<li>不要用智能指针的get成员函数返回的普通指针，去初始化另一个智能指针：<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> q <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">{</span>
    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">TempP</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//逻辑错误：两个独立的shared_ptr指向相同的内存</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> foo <span class="token operator">=</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//未定义：p指向的内存已经被释放了</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>发生异常后，智能指针指向的内存会被正常释放，但是普通指针指向的内存就永远不会被释放了（在delete之前发生异常）：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">sp</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//这段代码发生异常</span>
<span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//函数结束时，shared_ptr自动释放内存</span>

<span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//这段代码发生异常</span>
    <span class="token keyword">delete</span> p<span class="token punctuation">;</span>
<span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//发生异常后，p指向的内存永远不会被释放</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>无论是否发生异常，局部对象都会被销毁，所以发生异常后sp会被销毁，但是delete p永远执行不到。这个特性对建立局部网络连接的代码很有用，如果代码是这样的：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> SDestination<span class="token punctuation">;</span>
<span class="token keyword">struct</span> SConnection<span class="token punctuation">;</span>
SConnection <span class="token function">connect</span><span class="token punctuation">(</span>SDestination<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//打开连接</span>
<span class="token keyword">void</span> <span class="token function">disconnect</span><span class="token punctuation">(</span>SConnection<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//关闭连接</span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>SDestination <span class="token operator">&amp;</span>d<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    SConnection Conn <span class="token operator">=</span> <span class="token function">connect</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//使用连接</span>
    <span class="token comment" spellcheck="true">//如果我们在f退出前忘记调用disconnect，或者在调用它之前发生了异常，就无法关闭连接Conn了</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>为了保证函数退出时关闭连接，我们可以使用智能指针：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> SDestination<span class="token punctuation">;</span>
<span class="token keyword">struct</span> SConnection<span class="token punctuation">;</span>
SConnection <span class="token function">connect</span><span class="token punctuation">(</span>SDestination<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//打开连接</span>
<span class="token keyword">void</span> <span class="token function">disconnect</span><span class="token punctuation">(</span>SConnection<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//关闭连接</span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>SDestination <span class="token operator">&amp;</span>d<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    SConnection Conn <span class="token operator">=</span> <span class="token function">connect</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>SConnection<span class="token operator">></span> <span class="token function">p</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Conn<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>SConnection <span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">disconnect</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//使用连接</span>
    <span class="token comment" spellcheck="true">//即使我们在f退出前忘记调用disconnect，或者在调用它之前发生了异常，Conn也会被正确关闭</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>即使发生了异常或者忘记调用disconnect，连接也会被正常关闭，因为函数退出时会释放局部对象p，p在被销毁时会调用lambda表达式来关闭连接。</p>
</li>
<li>为了正确使用智能指针，我们必须坚持一些规范：<ul>
<li>不使用相同的内置指针初始化（或reset）多个智能指针</li>
<li>不delete get()返回的指针</li>
<li>不使用get()返回的指针去初始化或reset另一个智能指针</li>
<li>如果使用get返回的普通指针，记住当最后一个对应的智能指针被销毁后，这个普通指针就失效了</li>
<li>如果使用智能指针管理的资源不是new分配的内存，记住传递给它一个删除器（代替delete的可调用对象）</li>
</ul>
</li>
<li>与shared_ptr不同，某个时刻只能有一个unique_ptr指向一个给定对象。当unique_ptr被销毁时，它所指向的对象也被销毁。而且没有类似make_shader的标准库函数来返回一个unique_ptr。当我们定义一个unique_ptr时，需要将其绑定到一个new返回的指针上或默认初始化，因为它不支持拷贝和赋值操作（独占内存所致）：<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> p1<span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">//p1是一个指向int类型的空指针</span>
std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p2</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//p2指向一个值为42的int</span>
std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p3</span><span class="token punctuation">(</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//错误：unique_ptr不支持拷贝</span>
p1 <span class="token operator">=</span> p2<span class="token punctuation">;</span>                               <span class="token comment" spellcheck="true">//错误：unique_ptr不支持赋值</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>虽然不能拷贝或赋值unique_ptr，但可以通过release算法unique_ptr对指针的控制权，然后将其转移给另一个unique_ptr：<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//p2指向一个值为42的int</span>
std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p2</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//将p1的控制权转移给p2</span>
p1<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span>p2<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">//将p2的控制权转移给p1</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
如果我们不用另一个智能指针来保存release返回的普通指针，我们的程序就要负责delete掉该指针。</li>
<li>不能拷贝unique_ptr的规则有一个例外：我们可以拷贝或赋值一个将要被销毁的unique_ptr（因为通常会对它们指向移动拷贝或移动赋值，见13章）：<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">sp</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> sp<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//正确：可以对一个将要被销毁的unique_ptr赋值或拷贝</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>和shared_ptr类似，我们也可以像unique_ptr传递一个自定义的删除器，不同的是，定义时必须显式制定出删除器的模板类型：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">deleteFunc</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">delete</span> p<span class="token punctuation">;</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"delete"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>deleteFunc<span class="token punctuation">)</span><span class="token operator">*</span><span class="token operator">></span> <span class="token function">p1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">,</span> deleteFunc<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>weak_ptr是一种不控制所指向对象生存期的智能指针，它指向由一个shared_ptr管理的对象。将一个weak_ptr绑定到一个shared_ptr不会改变shared_ptr的引用计数。一旦最后一个指向对象的shared_ptr被销毁，对象就会被释放，即使有weak_ptr指向对象，对象也还是会被释放。</p>
<p>当我们创建一个weak_ptr时，要用一个shared_ptr来初始化它：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> sp <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token operator">::</span>weak_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">wp</span><span class="token punctuation">(</span>sp<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//wp弱共享sp，sp的引用计数未改变</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>weak_ptr特有的成员操作如下：</p>
<ul>
<li>w.use_count()：与w共享对象的shared_ptr的数量</li>
<li>w.expired()：若w.use_count()为0，返回true，否则返回false</li>
<li>w.lock()：如果expired为true，返回一个空的shared_ptr；否则返回一个指向w的对象的shared_ptr</li>
</ul>
<p>从上面可以看出weak_ptr所指向的对象可能不存在，所以我们不能使用weak_ptr直接访问对象，而必须调用lock：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> vSp <span class="token operator">=</span> wp<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//在if中使用vSp访问共享对象是安全的</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<p><font size="5" color="orange">动态数组</font></p>
<hr>
<ol>
<li>标准库包含一个名为allocator的类，允许我们将分配和初始化分离。使用allocator通常会提供更好的性能和更灵活的内存管理能力。</li>
<li>大多数应用应该使用标准库容器而不是动态分配的数组。使用容器更为简单、更不容易出现内存管理错误并且可能有更好的性能。</li>
<li>我们用new分配的动态数组并不是数组类型，所以不能对动态数组调用begin或end：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
 <span class="token keyword">auto</span> it <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">begin</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//正确：可以对数组类型调用begin函数</span>
 <span class="token keyword">int</span> <span class="token operator">*</span>b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
 <span class="token function">memset</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">auto</span> it2 <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">begin</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//错误：不能对动态数组调用begin函数</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>释放动态数组时，需要在delete之后、指针名之前加上一个[ ]：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> <span class="token operator">*</span>b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
 <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
 动态数组中的元素按逆序销毁，即最后一个元素先被销毁，然后是倒数第二个…。</li>
<li>标准库提供了一个可以管理new分配的数组的unique_ptr版本，需要在模板参数的对象类型后面跟一个方括号：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> <span class="token function">up</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 up<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//自动调用delete[]销毁其指针</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
 但是如果要使用shared_ptr来管理一个动态数组，必须提供自定义的删除器：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">sp</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> p<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 sp<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//使用我们提供的lambda释放数组，它使用delete[]</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p>unique_ptr管理的动态数组可以通过下标来访问元素，但是shared_ptr不可以，它没有定义下标运算符。而且智能指针类型不支持指针算术运算。因此shared_ptr为了访问数组中的元素，必须先用get获取一个内置指针，然后用它来访问素组元素：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> <span class="token function">up</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
     up<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>

 std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">sp</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> p<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
     <span class="token operator">*</span><span class="token punctuation">(</span>sp<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> i<span class="token punctuation">)</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>当分配一大块内存时，我们通常计划在这块内存还是那个按需构造对象。在此情况下，我们希望将内存分配和对象构造分离。这意味着我们可以分配大块内存，但只在真正需要时才真正执行对象创建操作。</li>
<li>标准库allocator类定义在头文件memory中，它帮助我们将内存分配和对象构造分离开来。allocator也是一个模板，它会根据给定的对象类型来确定恰当的内存大小和对齐位置：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>allocator<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> Alloc<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//可以分配string的allocator对象</span>
 <span class="token keyword">auto</span> <span class="token keyword">const</span> p <span class="token operator">=</span> Alloc<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//分配n个未初始化的string</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
 allocator类的成员操作如下表：</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">allocator<t> a</t></td>
<td>定义一个allocator对象，它可以为类型为T的对象分配内存</td>
</tr>
<tr>
<td style="text-align:center">a.allocate(n)</td>
<td>分配一段原始的、未构造的内存，保存n个类型为T的对象</td>
</tr>
<tr>
<td style="text-align:center">a.deallocate(p, n)</td>
<td>释放从T*指针p中地址开始的内存，这块内存保存了n个类型为T的对象；p必须是一个先前由allocate返回的指针，且n必须是p创建时所要求的大小。在调用deallocate之前，用户必须对每个在这块内存中创建的对象调用destroy</td>
</tr>
<tr>
<td style="text-align:center">a.construct(p, args)</td>
<td>p必须是一个类型为T*的指针，指向一块原始内存；args被传递给类型为T的构造函数，用来在p指向的内存中构造一个对象</td>
</tr>
<tr>
<td style="text-align:center">a.destroy(p)</td>
<td>p为T*类型的指针，此算法对p指向的对象执行析构函数</td>
</tr>
</tbody>
</table>
<ol>
<li>allocator分配的内存是未构造的，我们需要在此内存中构造对象，而construct成员函数接受一个指针和零个或多个额外参数，在指针所指的位置构造一个元素：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">auto</span> q <span class="token operator">=</span> p<span class="token punctuation">;</span>
 Alloc<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>q<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//*q为空字符串</span>
 Alloc<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>q<span class="token operator">++</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//*q为10个字符c组成的字符串</span>
 Alloc<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>q<span class="token operator">++</span><span class="token punctuation">,</span> <span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//*q为字符串hello</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
 还未构造对象的情况下就使用原始内存是错误的：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>allocator<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> Alloc<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//可以分配string的allocator对象</span>
 <span class="token keyword">auto</span> <span class="token keyword">const</span> p <span class="token operator">=</span> Alloc<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//分配n个未初始化的string</span>
 std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//错误：程序崩溃，因为p指向未构造的内存</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li>当我们用完对象后，必须对每个构造的元素调用destroy来销毁它们。函数destroy接受一个指针，对指向的对象执行析构函数：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">while</span> <span class="token punctuation">(</span>q <span class="token operator">!=</span> p<span class="token punctuation">)</span>
    Alloc<span class="token punctuation">.</span><span class="token function">destroy</span><span class="token punctuation">(</span><span class="token operator">--</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li>销毁这些被构造出来的元素以后，我们就可以使用deallocate成员函数把内存归还给系统了（当然也可以拿这些内存再去构造新的对象）。所以allocator使用四部曲就是：allocate、construct、destroy、deallocate：<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>allocator<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> Alloc<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//可以分配string的allocator对象</span>
<span class="token keyword">auto</span> <span class="token keyword">const</span> p <span class="token operator">=</span> Alloc<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//分配n个未初始化的string</span>
<span class="token keyword">auto</span> q <span class="token operator">=</span> p<span class="token punctuation">;</span>
Alloc<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>q<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//*q为空字符串</span>
Alloc<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>q<span class="token operator">++</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//*q为10个字符c组成的字符串</span>
Alloc<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>q<span class="token operator">++</span><span class="token punctuation">,</span> <span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//*q为字符串hello</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>q <span class="token operator">!=</span> p<span class="token punctuation">)</span>
    Alloc<span class="token punctuation">.</span><span class="token function">destroy</span><span class="token punctuation">(</span><span class="token operator">--</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment" spellcheck="true">//销毁每个构造出来的对象</span>
Alloc<span class="token punctuation">.</span><span class="token function">deallocate</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">//第二个参数必须与allocate分配内存时指定的参数相同</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>标准库还为allocator类定义了两个伴随算法：copy和fill，用于在未初始化内存（原始内存）中创建对象，定义在头文件memory中：<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> SVec<span class="token punctuation">{</span> <span class="token string">"Hello"</span><span class="token punctuation">,</span><span class="token string">"World"</span><span class="token punctuation">,</span><span class="token string">"Nice"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
std<span class="token operator">::</span>allocator<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> Alloc<span class="token punctuation">;</span>
<span class="token keyword">auto</span> p <span class="token operator">=</span> Alloc<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span>SVec<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//通过拷贝SVec中的元素来构造原始内存从p开始的元素</span>
<span class="token keyword">auto</span> q <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">uninitialized_copy</span><span class="token punctuation">(</span>SVec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> SVec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//将原始内存中剩余的未构造元素初始化为字符串Same</span>
std<span class="token operator">::</span><span class="token function">uninitialized_fill_n</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> SVec<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"Same"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">uninitialized_copy(b, e, b2)</td>
<td>将迭代器b到e范围内的元素拷贝到迭代器b2指向的未构造的原始内存中</td>
</tr>
<tr>
<td style="text-align:center">uninitialized_copy_n(b, n, b2)</td>
<td>从迭代器b指向的元素开始，拷贝n个元素到b2指向的原始内存中</td>
</tr>
<tr>
<td style="text-align:center">uninitialized_fill(b, e, t)</td>
<td>在迭代器b到e的元素内存范围内构造对象，对象的值均为t的拷贝</td>
</tr>
<tr>
<td style="text-align:center">uninitialized_fill_n(b, n, t)</td>
<td>从迭代器b指向的元素内存开始创建n个对象，对象的值均为t的拷贝</td>
</tr>
</tbody>
</table>
<p><font size="5" color="orange">使用标准库：文本查询程序</font></p>
<hr>
<ol>
<li>-_-||，最近比较忙，比较忙。。。有时间再来补上了(*￣︶￣)</li>
</ol>
<p><font size="5" color="orange">概述</font></p>
<hr>
<ol>
<li>静态内存用来保存局部static对象、类static数据成员以及定义在任何函数之外的变量。栈内存用来保存定义在函数内的非static对象。分配在静态或栈内存中的对象由编译器自动创建和销毁。对于栈对象，仅在其定义的程序块运行时才存在；static对象在使用之前分配，在程序结束时销毁。</li>
<li>除了静态内存和栈内存，每个程序还拥有一个内存池。这部分内存被称作自由空间或堆。程序用堆来存储动态分配的对象，即那些在程序运行时分配的对象。动态对象的生存期由程序来控制，也就是说，当动态对象不再使用时，我们的代码必须显式地销毁它们。</li>
</ol>
<p><font size="5" color="orange">动态内存与智能指针</font></p>
<hr>
<ol>
<li>为了更容易、更安全地使用动态内存，新标准库提供了三种智能指针类型来管理动态对象：shared_ptr和unique_ptr。它们和普通指针的重要区别是它们负责自动释放所指向的对象。shared_ptr允许多个指针指向同一个对象；unique_ptr则独占所指向的对象。</li>
<li>标准库还定义了一个名为weak_ptr的伴随类，它是一种弱引用，指向shared_ptr所管理的对象。</li>
<li>shared_ptr、unique_ptr和weak_ptr都定义在头文件memory中。</li>
<li>智能指针其实是在普通指针上作了一些包装，包括自动释放内存、指向同一对象的指针指针数量（用智能指针类中的计数器保存）等等。</li>
<li>智能指针也是模板类，默认初始化的智能指针中保存着一个空指针：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> p1<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//shared_ptr，可以指向string对象，现在还是空指针</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li>使用智能指针的get成员函数可以获得对应的普通指针：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> p1<span class="token punctuation">;</span>
 <span class="token keyword">auto</span> p <span class="token operator">=</span> p1<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//p是string*类型</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li>shared_ptr独有的操作如下表：</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">make_shared<t>(args)</t></td>
<td>返回一个shared_ptr，指向一个动态分配的类型为T的对象，使用args初始化该对象</td>
</tr>
<tr>
<td style="text-align:center">shared_ptr<t>p(q)</t></td>
<td>p是shared_ptr q的拷贝，此操作会递增q中的计算器。q中的指针必须能转换为T*</td>
</tr>
<tr>
<td style="text-align:center">p=q</td>
<td>p和q都是shared_ptr，所保存的指针必须能相互转换。此操作会递减p的引用计数，递增q的引用计数；若p的引用计数变为0，则将其管理的原内存释放</td>
</tr>
<tr>
<td style="text-align:center">p.unique()</td>
<td>若p.use_count()为1，返回true，否则返回false</td>
</tr>
<tr>
<td style="text-align:center">p,use_count()</td>
<td>返回一个与p共享对象的智能指针数量；可能很慢，主要用于测试</td>
</tr>
</tbody>
</table>
<ol>
<li>我们可以用make_shared函数代替new来生成一个指针，这样更安全，同时不需要匹配的delete操作，因为智能指针在计算器变为0时会自动调用delete：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> p1 <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
 当然用auto来保存make_shared的结果更简单：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">auto</span> p1 <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li>每个shared_ptr都有一个关联的计数器，通常称其为引用计数。无论何时我们拷贝一个shared_ptr，计数器都会增加，当我们给shared_ptr赋予一个新值或是shared_ptr被销毁（例如局部shared_ptr离开其作用域）时，计数器就会递减。一旦一个shared_ptr的计数器变为0，它就会自动释放自己所管理的对象。</li>
<li>当指向一个对象的最后一个shared_ptr被销毁时，shared_ptr类会自动销毁此对象。它是通过析构函数来完成销毁工作的。shared_ptr的析构函数会递减它所指向的对象的引用计数。如果引用计数变为0，shared_ptr的析构函数就会销毁对象，并释放它占用的内存。</li>
<li>如果将shared_ptr存放于一个容器中，而后不再需要全部元素，而只使用其中一部分，要记得用erase删除不再使用的那些元素，否则它们占用的内存将无法释放。</li>
<li>使用动态内存的一个常见原因是允许多个对象共享相同的状态。</li>
<li>使用new进行动态内存分配时，不带()的执行默认初始化，值是未定义的，带()的执行值初始化：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//*p的值是未定义的</span>
<span class="token keyword">int</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//*p2 = 0</span>
std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//本机输出-842150451</span>
std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p2 <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//输出0</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>默认情况下，如果new不能分配所要求的内存空间，它会抛出一个类型为bad_alloc的异常。我们可以改变使用new的方式来阻止它抛出异常：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">//如果分配失败，new抛出std::bad_alloc异常</span>
<span class="token keyword">int</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>nothrow<span class="token punctuation">)</span> <span class="token keyword">int</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//如果分配失败，new返回一个空指针，不抛出异常</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
我们称这种形式的new为定位new。定位new表达式允许我们向new传递额外的参数。这里我们传递的是标准库的一个名为nothrow的对象，告诉它不能抛出异常。bad_alloc和nothrow都定义在头文件new中。</li>
<li>通常情况下，编译器不能分辨一个指针指向的是静态还是动态分配的对象。类似的，编译器也不能分辨一个指针所指向的内存是否已经被释放了。</li>
<li>使用new和delete管理动态内存存在三个问题：<ul>
<li>忘记delete内存。忘记释放动态内存会导致人们常说的“内存泄漏”问题，因为这种内存永远不可能被归还给自由空间了。</li>
<li>使用已经释放掉的对象。通过在释放内存后将指针置位空，有时可以检测出这种错误（delete p; p = nullptr）。</li>
<li>同一块内存释放两次。</li>
</ul>
</li>
<li>坚持使用智能指针，就可以避免所有这些问题。对于一块内存，只有在没有任何智能指针指向它的情况下，智能指针才会自动释放它。</li>
<li><p>接受指针参数的智能指针构造函数时explicit的，我们不能进行内置指针到智能指针之间的隐式转换：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//正确：使用了直接初始化形式</span>
std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//错误：不能将普通指针隐式转换为智能指针</span>

std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//错误：不能将普通指针隐式转换为智能指针</span>
<span class="token punctuation">}</span>
std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">clone1</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//正确，显式创建智能指针</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>定义智能指针时还可以增加一个参数来代替delete，这个参数必须是一个可调用对象：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p1</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>vp<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">delete</span> vp<span class="token punctuation">;</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"delete"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
当智能指针p1离开其作用域时，如果其计数器变为0，将会执行这个可调用的lambda表达式，输出字符串delete。</li>
<li>智能指针还有一个名叫reset的成员函数：<ul>
<li><code>p.reset();</code> ：若p是唯一指向其对象的shared_ptr，reset会释放此对象</li>
<li><code>p.reset(q);</code>：令p指向指针q</li>
<li><code>p.reset(q, d);</code>：令p指向q，并且调用对象d而不是delete来释放q</li>
</ul>
</li>
<li><p>不要混合使用普通指针和智能指针：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> vp<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">process</span><span class="token punctuation">(</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//合法，但函数退出后p指向的内存会被释放，p称为悬空指针</span>
<span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当将一个shared_ptr绑定到一个普通指针时，我们就将内存的管理责任交给了这个shared_ptr。一旦这样做了，我们就不应该再使用内置指针来问shared_ptr所指向的内存了。</p>
</li>
<li>不要用智能指针的get成员函数返回的普通指针，去初始化另一个智能指针：<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> q <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">{</span>
    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">TempP</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//逻辑错误：两个独立的shared_ptr指向相同的内存</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> foo <span class="token operator">=</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//未定义：p指向的内存已经被释放了</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>发生异常后，智能指针指向的内存会被正常释放，但是普通指针指向的内存就永远不会被释放了（在delete之前发生异常）：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">sp</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//这段代码发生异常</span>
<span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//函数结束时，shared_ptr自动释放内存</span>

<span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//这段代码发生异常</span>
    <span class="token keyword">delete</span> p<span class="token punctuation">;</span>
<span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//发生异常后，p指向的内存永远不会被释放</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>无论是否发生异常，局部对象都会被销毁，所以发生异常后sp会被销毁，但是delete p永远执行不到。这个特性对建立局部网络连接的代码很有用，如果代码是这样的：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> SDestination<span class="token punctuation">;</span>
<span class="token keyword">struct</span> SConnection<span class="token punctuation">;</span>
SConnection <span class="token function">connect</span><span class="token punctuation">(</span>SDestination<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//打开连接</span>
<span class="token keyword">void</span> <span class="token function">disconnect</span><span class="token punctuation">(</span>SConnection<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//关闭连接</span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>SDestination <span class="token operator">&amp;</span>d<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    SConnection Conn <span class="token operator">=</span> <span class="token function">connect</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//使用连接</span>
    <span class="token comment" spellcheck="true">//如果我们在f退出前忘记调用disconnect，或者在调用它之前发生了异常，就无法关闭连接Conn了</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>为了保证函数退出时关闭连接，我们可以使用智能指针：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> SDestination<span class="token punctuation">;</span>
<span class="token keyword">struct</span> SConnection<span class="token punctuation">;</span>
SConnection <span class="token function">connect</span><span class="token punctuation">(</span>SDestination<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//打开连接</span>
<span class="token keyword">void</span> <span class="token function">disconnect</span><span class="token punctuation">(</span>SConnection<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//关闭连接</span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>SDestination <span class="token operator">&amp;</span>d<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    SConnection Conn <span class="token operator">=</span> <span class="token function">connect</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>SConnection<span class="token operator">></span> <span class="token function">p</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Conn<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>SConnection <span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">disconnect</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//使用连接</span>
    <span class="token comment" spellcheck="true">//即使我们在f退出前忘记调用disconnect，或者在调用它之前发生了异常，Conn也会被正确关闭</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>即使发生了异常或者忘记调用disconnect，连接也会被正常关闭，因为函数退出时会释放局部对象p，p在被销毁时会调用lambda表达式来关闭连接。</p>
</li>
<li>为了正确使用智能指针，我们必须坚持一些规范：<ul>
<li>不使用相同的内置指针初始化（或reset）多个智能指针</li>
<li>不delete get()返回的指针</li>
<li>不使用get()返回的指针去初始化或reset另一个智能指针</li>
<li>如果使用get返回的普通指针，记住当最后一个对应的智能指针被销毁后，这个普通指针就失效了</li>
<li>如果使用智能指针管理的资源不是new分配的内存，记住传递给它一个删除器（代替delete的可调用对象）</li>
</ul>
</li>
<li>与shared_ptr不同，某个时刻只能有一个unique_ptr指向一个给定对象。当unique_ptr被销毁时，它所指向的对象也被销毁。而且没有类似make_shader的标准库函数来返回一个unique_ptr。当我们定义一个unique_ptr时，需要将其绑定到一个new返回的指针上或默认初始化，因为它不支持拷贝和赋值操作（独占内存所致）：<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> p1<span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">//p1是一个指向int类型的空指针</span>
std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p2</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//p2指向一个值为42的int</span>
std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p3</span><span class="token punctuation">(</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//错误：unique_ptr不支持拷贝</span>
p1 <span class="token operator">=</span> p2<span class="token punctuation">;</span>                               <span class="token comment" spellcheck="true">//错误：unique_ptr不支持赋值</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>虽然不能拷贝或赋值unique_ptr，但可以通过release算法unique_ptr对指针的控制权，然后将其转移给另一个unique_ptr：<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//p2指向一个值为42的int</span>
std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p2</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//将p1的控制权转移给p2</span>
p1<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span>p2<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">//将p2的控制权转移给p1</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
如果我们不用另一个智能指针来保存release返回的普通指针，我们的程序就要负责delete掉该指针。</li>
<li>不能拷贝unique_ptr的规则有一个例外：我们可以拷贝或赋值一个将要被销毁的unique_ptr（因为通常会对它们指向移动拷贝或移动赋值，见13章）：<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">sp</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> sp<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//正确：可以对一个将要被销毁的unique_ptr赋值或拷贝</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>和shared_ptr类似，我们也可以像unique_ptr传递一个自定义的删除器，不同的是，定义时必须显式制定出删除器的模板类型：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">deleteFunc</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">delete</span> p<span class="token punctuation">;</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"delete"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>deleteFunc<span class="token punctuation">)</span><span class="token operator">*</span><span class="token operator">></span> <span class="token function">p1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">,</span> deleteFunc<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>weak_ptr是一种不控制所指向对象生存期的智能指针，它指向由一个shared_ptr管理的对象。将一个weak_ptr绑定到一个shared_ptr不会改变shared_ptr的引用计数。一旦最后一个指向对象的shared_ptr被销毁，对象就会被释放，即使有weak_ptr指向对象，对象也还是会被释放。</p>
<p>当我们创建一个weak_ptr时，要用一个shared_ptr来初始化它：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> sp <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token operator">::</span>weak_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">wp</span><span class="token punctuation">(</span>sp<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//wp弱共享sp，sp的引用计数未改变</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>weak_ptr特有的成员操作如下：</p>
<ul>
<li>w.use_count()：与w共享对象的shared_ptr的数量</li>
<li>w.expired()：若w.use_count()为0，返回true，否则返回false</li>
<li>w.lock()：如果expired为true，返回一个空的shared_ptr；否则返回一个指向w的对象的shared_ptr</li>
</ul>
<p>从上面可以看出weak_ptr所指向的对象可能不存在，所以我们不能使用weak_ptr直接访问对象，而必须调用lock：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> vSp <span class="token operator">=</span> wp<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//在if中使用vSp访问共享对象是安全的</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<p><font size="5" color="orange">动态数组</font></p>
<hr>
<ol>
<li>标准库包含一个名为allocator的类，允许我们将分配和初始化分离。使用allocator通常会提供更好的性能和更灵活的内存管理能力。</li>
<li>大多数应用应该使用标准库容器而不是动态分配的数组。使用容器更为简单、更不容易出现内存管理错误并且可能有更好的性能。</li>
<li>我们用new分配的动态数组并不是数组类型，所以不能对动态数组调用begin或end：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
 <span class="token keyword">auto</span> it <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">begin</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//正确：可以对数组类型调用begin函数</span>
 <span class="token keyword">int</span> <span class="token operator">*</span>b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
 <span class="token function">memset</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">auto</span> it2 <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">begin</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//错误：不能对动态数组调用begin函数</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>释放动态数组时，需要在delete之后、指针名之前加上一个[ ]：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> <span class="token operator">*</span>b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
 <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
 动态数组中的元素按逆序销毁，即最后一个元素先被销毁，然后是倒数第二个…。</li>
<li>标准库提供了一个可以管理new分配的数组的unique_ptr版本，需要在模板参数的对象类型后面跟一个方括号：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> <span class="token function">up</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 up<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//自动调用delete[]销毁其指针</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
 但是如果要使用shared_ptr来管理一个动态数组，必须提供自定义的删除器：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">sp</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> p<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 sp<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//使用我们提供的lambda释放数组，它使用delete[]</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p>unique_ptr管理的动态数组可以通过下标来访问元素，但是shared_ptr不可以，它没有定义下标运算符。而且智能指针类型不支持指针算术运算。因此shared_ptr为了访问数组中的元素，必须先用get获取一个内置指针，然后用它来访问素组元素：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> <span class="token function">up</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
     up<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>

 std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">sp</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> p<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
     <span class="token operator">*</span><span class="token punctuation">(</span>sp<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> i<span class="token punctuation">)</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>当分配一大块内存时，我们通常计划在这块内存还是那个按需构造对象。在此情况下，我们希望将内存分配和对象构造分离。这意味着我们可以分配大块内存，但只在真正需要时才真正执行对象创建操作。</li>
<li>标准库allocator类定义在头文件memory中，它帮助我们将内存分配和对象构造分离开来。allocator也是一个模板，它会根据给定的对象类型来确定恰当的内存大小和对齐位置：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>allocator<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> Alloc<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//可以分配string的allocator对象</span>
 <span class="token keyword">auto</span> <span class="token keyword">const</span> p <span class="token operator">=</span> Alloc<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//分配n个未初始化的string</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
 allocator类的成员操作如下表：</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">allocator<t> a</t></td>
<td>定义一个allocator对象，它可以为类型为T的对象分配内存</td>
</tr>
<tr>
<td style="text-align:center">a.allocate(n)</td>
<td>分配一段原始的、未构造的内存，保存n个类型为T的对象</td>
</tr>
<tr>
<td style="text-align:center">a.deallocate(p, n)</td>
<td>释放从T*指针p中地址开始的内存，这块内存保存了n个类型为T的对象；p必须是一个先前由allocate返回的指针，且n必须是p创建时所要求的大小。在调用deallocate之前，用户必须对每个在这块内存中创建的对象调用destroy</td>
</tr>
<tr>
<td style="text-align:center">a.construct(p, args)</td>
<td>p必须是一个类型为T*的指针，指向一块原始内存；args被传递给类型为T的构造函数，用来在p指向的内存中构造一个对象</td>
</tr>
<tr>
<td style="text-align:center">a.destroy(p)</td>
<td>p为T*类型的指针，此算法对p指向的对象执行析构函数</td>
</tr>
</tbody>
</table>
<ol>
<li>allocator分配的内存是未构造的，我们需要在此内存中构造对象，而construct成员函数接受一个指针和零个或多个额外参数，在指针所指的位置构造一个元素：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">auto</span> q <span class="token operator">=</span> p<span class="token punctuation">;</span>
 Alloc<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>q<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//*q为空字符串</span>
 Alloc<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>q<span class="token operator">++</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//*q为10个字符c组成的字符串</span>
 Alloc<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>q<span class="token operator">++</span><span class="token punctuation">,</span> <span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//*q为字符串hello</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
 还未构造对象的情况下就使用原始内存是错误的：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>allocator<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> Alloc<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//可以分配string的allocator对象</span>
 <span class="token keyword">auto</span> <span class="token keyword">const</span> p <span class="token operator">=</span> Alloc<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//分配n个未初始化的string</span>
 std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//错误：程序崩溃，因为p指向未构造的内存</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li>当我们用完对象后，必须对每个构造的元素调用destroy来销毁它们。函数destroy接受一个指针，对指向的对象执行析构函数：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">while</span> <span class="token punctuation">(</span>q <span class="token operator">!=</span> p<span class="token punctuation">)</span>
    Alloc<span class="token punctuation">.</span><span class="token function">destroy</span><span class="token punctuation">(</span><span class="token operator">--</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li>销毁这些被构造出来的元素以后，我们就可以使用deallocate成员函数把内存归还给系统了（当然也可以拿这些内存再去构造新的对象）。所以allocator使用四部曲就是：allocate、construct、destroy、deallocate：<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>allocator<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> Alloc<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//可以分配string的allocator对象</span>
<span class="token keyword">auto</span> <span class="token keyword">const</span> p <span class="token operator">=</span> Alloc<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//分配n个未初始化的string</span>
<span class="token keyword">auto</span> q <span class="token operator">=</span> p<span class="token punctuation">;</span>
Alloc<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>q<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//*q为空字符串</span>
Alloc<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>q<span class="token operator">++</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//*q为10个字符c组成的字符串</span>
Alloc<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>q<span class="token operator">++</span><span class="token punctuation">,</span> <span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//*q为字符串hello</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>q <span class="token operator">!=</span> p<span class="token punctuation">)</span>
    Alloc<span class="token punctuation">.</span><span class="token function">destroy</span><span class="token punctuation">(</span><span class="token operator">--</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment" spellcheck="true">//销毁每个构造出来的对象</span>
Alloc<span class="token punctuation">.</span><span class="token function">deallocate</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">//第二个参数必须与allocate分配内存时指定的参数相同</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>标准库还为allocator类定义了两个伴随算法：copy和fill，用于在未初始化内存（原始内存）中创建对象，定义在头文件memory中：<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> SVec<span class="token punctuation">{</span> <span class="token string">"Hello"</span><span class="token punctuation">,</span><span class="token string">"World"</span><span class="token punctuation">,</span><span class="token string">"Nice"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
std<span class="token operator">::</span>allocator<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> Alloc<span class="token punctuation">;</span>
<span class="token keyword">auto</span> p <span class="token operator">=</span> Alloc<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span>SVec<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//通过拷贝SVec中的元素来构造原始内存从p开始的元素</span>
<span class="token keyword">auto</span> q <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">uninitialized_copy</span><span class="token punctuation">(</span>SVec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> SVec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//将原始内存中剩余的未构造元素初始化为字符串Same</span>
std<span class="token operator">::</span><span class="token function">uninitialized_fill_n</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> SVec<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"Same"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">uninitialized_copy(b, e, b2)</td>
<td>将迭代器b到e范围内的元素拷贝到迭代器b2指向的未构造的原始内存中</td>
</tr>
<tr>
<td style="text-align:center">uninitialized_copy_n(b, n, b2)</td>
<td>从迭代器b指向的元素开始，拷贝n个元素到b2指向的原始内存中</td>
</tr>
<tr>
<td style="text-align:center">uninitialized_fill(b, e, t)</td>
<td>在迭代器b到e的元素内存范围内构造对象，对象的值均为t的拷贝</td>
</tr>
<tr>
<td style="text-align:center">uninitialized_fill_n(b, n, t)</td>
<td>从迭代器b指向的元素内存开始创建n个对象，对象的值均为t的拷贝</td>
</tr>
</tbody>
</table>
<p><font size="5" color="orange">使用标准库：文本查询程序</font></p>
<hr>
<ol>
<li>-_-||，最近比较忙，比较忙。。。有时间再来补上了(*￣︶￣)</li>
</ol>
<p><font size="5" color="orange">概述</font></p>
<hr>
<ol>
<li>静态内存用来保存局部static对象、类static数据成员以及定义在任何函数之外的变量。栈内存用来保存定义在函数内的非static对象。分配在静态或栈内存中的对象由编译器自动创建和销毁。对于栈对象，仅在其定义的程序块运行时才存在；static对象在使用之前分配，在程序结束时销毁。</li>
<li>除了静态内存和栈内存，每个程序还拥有一个内存池。这部分内存被称作自由空间或堆。程序用堆来存储动态分配的对象，即那些在程序运行时分配的对象。动态对象的生存期由程序来控制，也就是说，当动态对象不再使用时，我们的代码必须显式地销毁它们。</li>
</ol>
<p><font size="5" color="orange">动态内存与智能指针</font></p>
<hr>
<ol>
<li>为了更容易、更安全地使用动态内存，新标准库提供了三种智能指针类型来管理动态对象：shared_ptr和unique_ptr。它们和普通指针的重要区别是它们负责自动释放所指向的对象。shared_ptr允许多个指针指向同一个对象；unique_ptr则独占所指向的对象。</li>
<li>标准库还定义了一个名为weak_ptr的伴随类，它是一种弱引用，指向shared_ptr所管理的对象。</li>
<li>shared_ptr、unique_ptr和weak_ptr都定义在头文件memory中。</li>
<li>智能指针其实是在普通指针上作了一些包装，包括自动释放内存、指向同一对象的指针指针数量（用智能指针类中的计数器保存）等等。</li>
<li>智能指针也是模板类，默认初始化的智能指针中保存着一个空指针：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> p1<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//shared_ptr，可以指向string对象，现在还是空指针</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li>使用智能指针的get成员函数可以获得对应的普通指针：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> p1<span class="token punctuation">;</span>
 <span class="token keyword">auto</span> p <span class="token operator">=</span> p1<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//p是string*类型</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li>shared_ptr独有的操作如下表：</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">make_shared<t>(args)</t></td>
<td>返回一个shared_ptr，指向一个动态分配的类型为T的对象，使用args初始化该对象</td>
</tr>
<tr>
<td style="text-align:center">shared_ptr<t>p(q)</t></td>
<td>p是shared_ptr q的拷贝，此操作会递增q中的计算器。q中的指针必须能转换为T*</td>
</tr>
<tr>
<td style="text-align:center">p=q</td>
<td>p和q都是shared_ptr，所保存的指针必须能相互转换。此操作会递减p的引用计数，递增q的引用计数；若p的引用计数变为0，则将其管理的原内存释放</td>
</tr>
<tr>
<td style="text-align:center">p.unique()</td>
<td>若p.use_count()为1，返回true，否则返回false</td>
</tr>
<tr>
<td style="text-align:center">p,use_count()</td>
<td>返回一个与p共享对象的智能指针数量；可能很慢，主要用于测试</td>
</tr>
</tbody>
</table>
<ol>
<li>我们可以用make_shared函数代替new来生成一个指针，这样更安全，同时不需要匹配的delete操作，因为智能指针在计算器变为0时会自动调用delete：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> p1 <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
 当然用auto来保存make_shared的结果更简单：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">auto</span> p1 <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li>每个shared_ptr都有一个关联的计数器，通常称其为引用计数。无论何时我们拷贝一个shared_ptr，计数器都会增加，当我们给shared_ptr赋予一个新值或是shared_ptr被销毁（例如局部shared_ptr离开其作用域）时，计数器就会递减。一旦一个shared_ptr的计数器变为0，它就会自动释放自己所管理的对象。</li>
<li>当指向一个对象的最后一个shared_ptr被销毁时，shared_ptr类会自动销毁此对象。它是通过析构函数来完成销毁工作的。shared_ptr的析构函数会递减它所指向的对象的引用计数。如果引用计数变为0，shared_ptr的析构函数就会销毁对象，并释放它占用的内存。</li>
<li>如果将shared_ptr存放于一个容器中，而后不再需要全部元素，而只使用其中一部分，要记得用erase删除不再使用的那些元素，否则它们占用的内存将无法释放。</li>
<li>使用动态内存的一个常见原因是允许多个对象共享相同的状态。</li>
<li>使用new进行动态内存分配时，不带()的执行默认初始化，值是未定义的，带()的执行值初始化：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//*p的值是未定义的</span>
<span class="token keyword">int</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//*p2 = 0</span>
std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//本机输出-842150451</span>
std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p2 <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//输出0</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>默认情况下，如果new不能分配所要求的内存空间，它会抛出一个类型为bad_alloc的异常。我们可以改变使用new的方式来阻止它抛出异常：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">//如果分配失败，new抛出std::bad_alloc异常</span>
<span class="token keyword">int</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>nothrow<span class="token punctuation">)</span> <span class="token keyword">int</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//如果分配失败，new返回一个空指针，不抛出异常</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
我们称这种形式的new为定位new。定位new表达式允许我们向new传递额外的参数。这里我们传递的是标准库的一个名为nothrow的对象，告诉它不能抛出异常。bad_alloc和nothrow都定义在头文件new中。</li>
<li>通常情况下，编译器不能分辨一个指针指向的是静态还是动态分配的对象。类似的，编译器也不能分辨一个指针所指向的内存是否已经被释放了。</li>
<li>使用new和delete管理动态内存存在三个问题：<ul>
<li>忘记delete内存。忘记释放动态内存会导致人们常说的“内存泄漏”问题，因为这种内存永远不可能被归还给自由空间了。</li>
<li>使用已经释放掉的对象。通过在释放内存后将指针置位空，有时可以检测出这种错误（delete p; p = nullptr）。</li>
<li>同一块内存释放两次。</li>
</ul>
</li>
<li>坚持使用智能指针，就可以避免所有这些问题。对于一块内存，只有在没有任何智能指针指向它的情况下，智能指针才会自动释放它。</li>
<li><p>接受指针参数的智能指针构造函数时explicit的，我们不能进行内置指针到智能指针之间的隐式转换：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//正确：使用了直接初始化形式</span>
std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//错误：不能将普通指针隐式转换为智能指针</span>

std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//错误：不能将普通指针隐式转换为智能指针</span>
<span class="token punctuation">}</span>
std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">clone1</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//正确，显式创建智能指针</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>定义智能指针时还可以增加一个参数来代替delete，这个参数必须是一个可调用对象：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p1</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>vp<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">delete</span> vp<span class="token punctuation">;</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"delete"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
当智能指针p1离开其作用域时，如果其计数器变为0，将会执行这个可调用的lambda表达式，输出字符串delete。</li>
<li>智能指针还有一个名叫reset的成员函数：<ul>
<li><code>p.reset();</code> ：若p是唯一指向其对象的shared_ptr，reset会释放此对象</li>
<li><code>p.reset(q);</code>：令p指向指针q</li>
<li><code>p.reset(q, d);</code>：令p指向q，并且调用对象d而不是delete来释放q</li>
</ul>
</li>
<li><p>不要混合使用普通指针和智能指针：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> vp<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">process</span><span class="token punctuation">(</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//合法，但函数退出后p指向的内存会被释放，p称为悬空指针</span>
<span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当将一个shared_ptr绑定到一个普通指针时，我们就将内存的管理责任交给了这个shared_ptr。一旦这样做了，我们就不应该再使用内置指针来问shared_ptr所指向的内存了。</p>
</li>
<li>不要用智能指针的get成员函数返回的普通指针，去初始化另一个智能指针：<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> q <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">{</span>
    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">TempP</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//逻辑错误：两个独立的shared_ptr指向相同的内存</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> foo <span class="token operator">=</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//未定义：p指向的内存已经被释放了</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>发生异常后，智能指针指向的内存会被正常释放，但是普通指针指向的内存就永远不会被释放了（在delete之前发生异常）：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">sp</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//这段代码发生异常</span>
<span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//函数结束时，shared_ptr自动释放内存</span>

<span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//这段代码发生异常</span>
    <span class="token keyword">delete</span> p<span class="token punctuation">;</span>
<span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//发生异常后，p指向的内存永远不会被释放</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>无论是否发生异常，局部对象都会被销毁，所以发生异常后sp会被销毁，但是delete p永远执行不到。这个特性对建立局部网络连接的代码很有用，如果代码是这样的：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> SDestination<span class="token punctuation">;</span>
<span class="token keyword">struct</span> SConnection<span class="token punctuation">;</span>
SConnection <span class="token function">connect</span><span class="token punctuation">(</span>SDestination<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//打开连接</span>
<span class="token keyword">void</span> <span class="token function">disconnect</span><span class="token punctuation">(</span>SConnection<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//关闭连接</span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>SDestination <span class="token operator">&amp;</span>d<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    SConnection Conn <span class="token operator">=</span> <span class="token function">connect</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//使用连接</span>
    <span class="token comment" spellcheck="true">//如果我们在f退出前忘记调用disconnect，或者在调用它之前发生了异常，就无法关闭连接Conn了</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>为了保证函数退出时关闭连接，我们可以使用智能指针：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> SDestination<span class="token punctuation">;</span>
<span class="token keyword">struct</span> SConnection<span class="token punctuation">;</span>
SConnection <span class="token function">connect</span><span class="token punctuation">(</span>SDestination<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//打开连接</span>
<span class="token keyword">void</span> <span class="token function">disconnect</span><span class="token punctuation">(</span>SConnection<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//关闭连接</span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>SDestination <span class="token operator">&amp;</span>d<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    SConnection Conn <span class="token operator">=</span> <span class="token function">connect</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>SConnection<span class="token operator">></span> <span class="token function">p</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Conn<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>SConnection <span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">disconnect</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//使用连接</span>
    <span class="token comment" spellcheck="true">//即使我们在f退出前忘记调用disconnect，或者在调用它之前发生了异常，Conn也会被正确关闭</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>即使发生了异常或者忘记调用disconnect，连接也会被正常关闭，因为函数退出时会释放局部对象p，p在被销毁时会调用lambda表达式来关闭连接。</p>
</li>
<li>为了正确使用智能指针，我们必须坚持一些规范：<ul>
<li>不使用相同的内置指针初始化（或reset）多个智能指针</li>
<li>不delete get()返回的指针</li>
<li>不使用get()返回的指针去初始化或reset另一个智能指针</li>
<li>如果使用get返回的普通指针，记住当最后一个对应的智能指针被销毁后，这个普通指针就失效了</li>
<li>如果使用智能指针管理的资源不是new分配的内存，记住传递给它一个删除器（代替delete的可调用对象）</li>
</ul>
</li>
<li>与shared_ptr不同，某个时刻只能有一个unique_ptr指向一个给定对象。当unique_ptr被销毁时，它所指向的对象也被销毁。而且没有类似make_shader的标准库函数来返回一个unique_ptr。当我们定义一个unique_ptr时，需要将其绑定到一个new返回的指针上或默认初始化，因为它不支持拷贝和赋值操作（独占内存所致）：<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> p1<span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">//p1是一个指向int类型的空指针</span>
std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p2</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//p2指向一个值为42的int</span>
std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p3</span><span class="token punctuation">(</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//错误：unique_ptr不支持拷贝</span>
p1 <span class="token operator">=</span> p2<span class="token punctuation">;</span>                               <span class="token comment" spellcheck="true">//错误：unique_ptr不支持赋值</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>虽然不能拷贝或赋值unique_ptr，但可以通过release算法unique_ptr对指针的控制权，然后将其转移给另一个unique_ptr：<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//p2指向一个值为42的int</span>
std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p2</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//将p1的控制权转移给p2</span>
p1<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span>p2<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">//将p2的控制权转移给p1</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
如果我们不用另一个智能指针来保存release返回的普通指针，我们的程序就要负责delete掉该指针。</li>
<li>不能拷贝unique_ptr的规则有一个例外：我们可以拷贝或赋值一个将要被销毁的unique_ptr（因为通常会对它们指向移动拷贝或移动赋值，见13章）：<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">sp</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> sp<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//正确：可以对一个将要被销毁的unique_ptr赋值或拷贝</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>和shared_ptr类似，我们也可以像unique_ptr传递一个自定义的删除器，不同的是，定义时必须显式制定出删除器的模板类型：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">deleteFunc</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">delete</span> p<span class="token punctuation">;</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"delete"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>deleteFunc<span class="token punctuation">)</span><span class="token operator">*</span><span class="token operator">></span> <span class="token function">p1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">,</span> deleteFunc<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>weak_ptr是一种不控制所指向对象生存期的智能指针，它指向由一个shared_ptr管理的对象。将一个weak_ptr绑定到一个shared_ptr不会改变shared_ptr的引用计数。一旦最后一个指向对象的shared_ptr被销毁，对象就会被释放，即使有weak_ptr指向对象，对象也还是会被释放。</p>
<p>当我们创建一个weak_ptr时，要用一个shared_ptr来初始化它：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> sp <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token operator">::</span>weak_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">wp</span><span class="token punctuation">(</span>sp<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//wp弱共享sp，sp的引用计数未改变</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>weak_ptr特有的成员操作如下：</p>
<ul>
<li>w.use_count()：与w共享对象的shared_ptr的数量</li>
<li>w.expired()：若w.use_count()为0，返回true，否则返回false</li>
<li>w.lock()：如果expired为true，返回一个空的shared_ptr；否则返回一个指向w的对象的shared_ptr</li>
</ul>
<p>从上面可以看出weak_ptr所指向的对象可能不存在，所以我们不能使用weak_ptr直接访问对象，而必须调用lock：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> vSp <span class="token operator">=</span> wp<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//在if中使用vSp访问共享对象是安全的</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<p><font size="5" color="orange">动态数组</font></p>
<hr>
<ol>
<li>标准库包含一个名为allocator的类，允许我们将分配和初始化分离。使用allocator通常会提供更好的性能和更灵活的内存管理能力。</li>
<li>大多数应用应该使用标准库容器而不是动态分配的数组。使用容器更为简单、更不容易出现内存管理错误并且可能有更好的性能。</li>
<li>我们用new分配的动态数组并不是数组类型，所以不能对动态数组调用begin或end：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
 <span class="token keyword">auto</span> it <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">begin</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//正确：可以对数组类型调用begin函数</span>
 <span class="token keyword">int</span> <span class="token operator">*</span>b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
 <span class="token function">memset</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">auto</span> it2 <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">begin</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//错误：不能对动态数组调用begin函数</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>释放动态数组时，需要在delete之后、指针名之前加上一个[ ]：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> <span class="token operator">*</span>b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
 <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
 动态数组中的元素按逆序销毁，即最后一个元素先被销毁，然后是倒数第二个…。</li>
<li>标准库提供了一个可以管理new分配的数组的unique_ptr版本，需要在模板参数的对象类型后面跟一个方括号：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> <span class="token function">up</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 up<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//自动调用delete[]销毁其指针</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
 但是如果要使用shared_ptr来管理一个动态数组，必须提供自定义的删除器：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">sp</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> p<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 sp<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//使用我们提供的lambda释放数组，它使用delete[]</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p>unique_ptr管理的动态数组可以通过下标来访问元素，但是shared_ptr不可以，它没有定义下标运算符。而且智能指针类型不支持指针算术运算。因此shared_ptr为了访问数组中的元素，必须先用get获取一个内置指针，然后用它来访问素组元素：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> <span class="token function">up</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
     up<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>

 std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">sp</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> p<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
     <span class="token operator">*</span><span class="token punctuation">(</span>sp<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> i<span class="token punctuation">)</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>当分配一大块内存时，我们通常计划在这块内存还是那个按需构造对象。在此情况下，我们希望将内存分配和对象构造分离。这意味着我们可以分配大块内存，但只在真正需要时才真正执行对象创建操作。</li>
<li>标准库allocator类定义在头文件memory中，它帮助我们将内存分配和对象构造分离开来。allocator也是一个模板，它会根据给定的对象类型来确定恰当的内存大小和对齐位置：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>allocator<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> Alloc<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//可以分配string的allocator对象</span>
 <span class="token keyword">auto</span> <span class="token keyword">const</span> p <span class="token operator">=</span> Alloc<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//分配n个未初始化的string</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
 allocator类的成员操作如下表：</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">allocator<t> a</t></td>
<td>定义一个allocator对象，它可以为类型为T的对象分配内存</td>
</tr>
<tr>
<td style="text-align:center">a.allocate(n)</td>
<td>分配一段原始的、未构造的内存，保存n个类型为T的对象</td>
</tr>
<tr>
<td style="text-align:center">a.deallocate(p, n)</td>
<td>释放从T*指针p中地址开始的内存，这块内存保存了n个类型为T的对象；p必须是一个先前由allocate返回的指针，且n必须是p创建时所要求的大小。在调用deallocate之前，用户必须对每个在这块内存中创建的对象调用destroy</td>
</tr>
<tr>
<td style="text-align:center">a.construct(p, args)</td>
<td>p必须是一个类型为T*的指针，指向一块原始内存；args被传递给类型为T的构造函数，用来在p指向的内存中构造一个对象</td>
</tr>
<tr>
<td style="text-align:center">a.destroy(p)</td>
<td>p为T*类型的指针，此算法对p指向的对象执行析构函数</td>
</tr>
</tbody>
</table>
<ol>
<li>allocator分配的内存是未构造的，我们需要在此内存中构造对象，而construct成员函数接受一个指针和零个或多个额外参数，在指针所指的位置构造一个元素：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">auto</span> q <span class="token operator">=</span> p<span class="token punctuation">;</span>
 Alloc<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>q<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//*q为空字符串</span>
 Alloc<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>q<span class="token operator">++</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//*q为10个字符c组成的字符串</span>
 Alloc<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>q<span class="token operator">++</span><span class="token punctuation">,</span> <span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//*q为字符串hello</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
 还未构造对象的情况下就使用原始内存是错误的：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>allocator<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> Alloc<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//可以分配string的allocator对象</span>
 <span class="token keyword">auto</span> <span class="token keyword">const</span> p <span class="token operator">=</span> Alloc<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//分配n个未初始化的string</span>
 std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//错误：程序崩溃，因为p指向未构造的内存</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li>当我们用完对象后，必须对每个构造的元素调用destroy来销毁它们。函数destroy接受一个指针，对指向的对象执行析构函数：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">while</span> <span class="token punctuation">(</span>q <span class="token operator">!=</span> p<span class="token punctuation">)</span>
    Alloc<span class="token punctuation">.</span><span class="token function">destroy</span><span class="token punctuation">(</span><span class="token operator">--</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li>销毁这些被构造出来的元素以后，我们就可以使用deallocate成员函数把内存归还给系统了（当然也可以拿这些内存再去构造新的对象）。所以allocator使用四部曲就是：allocate、construct、destroy、deallocate：<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>allocator<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> Alloc<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//可以分配string的allocator对象</span>
<span class="token keyword">auto</span> <span class="token keyword">const</span> p <span class="token operator">=</span> Alloc<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//分配n个未初始化的string</span>
<span class="token keyword">auto</span> q <span class="token operator">=</span> p<span class="token punctuation">;</span>
Alloc<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>q<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//*q为空字符串</span>
Alloc<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>q<span class="token operator">++</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//*q为10个字符c组成的字符串</span>
Alloc<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>q<span class="token operator">++</span><span class="token punctuation">,</span> <span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//*q为字符串hello</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>q <span class="token operator">!=</span> p<span class="token punctuation">)</span>
    Alloc<span class="token punctuation">.</span><span class="token function">destroy</span><span class="token punctuation">(</span><span class="token operator">--</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment" spellcheck="true">//销毁每个构造出来的对象</span>
Alloc<span class="token punctuation">.</span><span class="token function">deallocate</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">//第二个参数必须与allocate分配内存时指定的参数相同</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>标准库还为allocator类定义了两个伴随算法：copy和fill，用于在未初始化内存（原始内存）中创建对象，定义在头文件memory中：<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> SVec<span class="token punctuation">{</span> <span class="token string">"Hello"</span><span class="token punctuation">,</span><span class="token string">"World"</span><span class="token punctuation">,</span><span class="token string">"Nice"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
std<span class="token operator">::</span>allocator<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> Alloc<span class="token punctuation">;</span>
<span class="token keyword">auto</span> p <span class="token operator">=</span> Alloc<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span>SVec<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//通过拷贝SVec中的元素来构造原始内存从p开始的元素</span>
<span class="token keyword">auto</span> q <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">uninitialized_copy</span><span class="token punctuation">(</span>SVec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> SVec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//将原始内存中剩余的未构造元素初始化为字符串Same</span>
std<span class="token operator">::</span><span class="token function">uninitialized_fill_n</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> SVec<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"Same"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">uninitialized_copy(b, e, b2)</td>
<td>将迭代器b到e范围内的元素拷贝到迭代器b2指向的未构造的原始内存中</td>
</tr>
<tr>
<td style="text-align:center">uninitialized_copy_n(b, n, b2)</td>
<td>从迭代器b指向的元素开始，拷贝n个元素到b2指向的原始内存中</td>
</tr>
<tr>
<td style="text-align:center">uninitialized_fill(b, e, t)</td>
<td>在迭代器b到e的元素内存范围内构造对象，对象的值均为t的拷贝</td>
</tr>
<tr>
<td style="text-align:center">uninitialized_fill_n(b, n, t)</td>
<td>从迭代器b指向的元素内存开始创建n个对象，对象的值均为t的拷贝</td>
</tr>
</tbody>
</table>
<p><font size="5" color="orange">使用标准库：文本查询程序</font></p>
<hr>
<ol>
<li>-_-||，最近比较忙，比较忙。。。有时间再来补上了(*￣︶￣)</li>
</ol>
<p><font size="5" color="orange">概述</font></p>
<hr>
<ol>
<li>静态内存用来保存局部static对象、类static数据成员以及定义在任何函数之外的变量。栈内存用来保存定义在函数内的非static对象。分配在静态或栈内存中的对象由编译器自动创建和销毁。对于栈对象，仅在其定义的程序块运行时才存在；static对象在使用之前分配，在程序结束时销毁。</li>
<li>除了静态内存和栈内存，每个程序还拥有一个内存池。这部分内存被称作自由空间或堆。程序用堆来存储动态分配的对象，即那些在程序运行时分配的对象。动态对象的生存期由程序来控制，也就是说，当动态对象不再使用时，我们的代码必须显式地销毁它们。</li>
</ol>
<p><font size="5" color="orange">动态内存与智能指针</font></p>
<hr>
<ol>
<li>为了更容易、更安全地使用动态内存，新标准库提供了三种智能指针类型来管理动态对象：shared_ptr和unique_ptr。它们和普通指针的重要区别是它们负责自动释放所指向的对象。shared_ptr允许多个指针指向同一个对象；unique_ptr则独占所指向的对象。</li>
<li>标准库还定义了一个名为weak_ptr的伴随类，它是一种弱引用，指向shared_ptr所管理的对象。</li>
<li>shared_ptr、unique_ptr和weak_ptr都定义在头文件memory中。</li>
<li>智能指针其实是在普通指针上作了一些包装，包括自动释放内存、指向同一对象的指针指针数量（用智能指针类中的计数器保存）等等。</li>
<li>智能指针也是模板类，默认初始化的智能指针中保存着一个空指针：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> p1<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//shared_ptr，可以指向string对象，现在还是空指针</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li>使用智能指针的get成员函数可以获得对应的普通指针：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> p1<span class="token punctuation">;</span>
 <span class="token keyword">auto</span> p <span class="token operator">=</span> p1<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//p是string*类型</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li>shared_ptr独有的操作如下表：</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">make_shared<t>(args)</t></td>
<td>返回一个shared_ptr，指向一个动态分配的类型为T的对象，使用args初始化该对象</td>
</tr>
<tr>
<td style="text-align:center">shared_ptr<t>p(q)</t></td>
<td>p是shared_ptr q的拷贝，此操作会递增q中的计算器。q中的指针必须能转换为T*</td>
</tr>
<tr>
<td style="text-align:center">p=q</td>
<td>p和q都是shared_ptr，所保存的指针必须能相互转换。此操作会递减p的引用计数，递增q的引用计数；若p的引用计数变为0，则将其管理的原内存释放</td>
</tr>
<tr>
<td style="text-align:center">p.unique()</td>
<td>若p.use_count()为1，返回true，否则返回false</td>
</tr>
<tr>
<td style="text-align:center">p,use_count()</td>
<td>返回一个与p共享对象的智能指针数量；可能很慢，主要用于测试</td>
</tr>
</tbody>
</table>
<ol>
<li>我们可以用make_shared函数代替new来生成一个指针，这样更安全，同时不需要匹配的delete操作，因为智能指针在计算器变为0时会自动调用delete：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> p1 <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
 当然用auto来保存make_shared的结果更简单：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">auto</span> p1 <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li>每个shared_ptr都有一个关联的计数器，通常称其为引用计数。无论何时我们拷贝一个shared_ptr，计数器都会增加，当我们给shared_ptr赋予一个新值或是shared_ptr被销毁（例如局部shared_ptr离开其作用域）时，计数器就会递减。一旦一个shared_ptr的计数器变为0，它就会自动释放自己所管理的对象。</li>
<li>当指向一个对象的最后一个shared_ptr被销毁时，shared_ptr类会自动销毁此对象。它是通过析构函数来完成销毁工作的。shared_ptr的析构函数会递减它所指向的对象的引用计数。如果引用计数变为0，shared_ptr的析构函数就会销毁对象，并释放它占用的内存。</li>
<li>如果将shared_ptr存放于一个容器中，而后不再需要全部元素，而只使用其中一部分，要记得用erase删除不再使用的那些元素，否则它们占用的内存将无法释放。</li>
<li>使用动态内存的一个常见原因是允许多个对象共享相同的状态。</li>
<li>使用new进行动态内存分配时，不带()的执行默认初始化，值是未定义的，带()的执行值初始化：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//*p的值是未定义的</span>
<span class="token keyword">int</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//*p2 = 0</span>
std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//本机输出-842150451</span>
std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p2 <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//输出0</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>默认情况下，如果new不能分配所要求的内存空间，它会抛出一个类型为bad_alloc的异常。我们可以改变使用new的方式来阻止它抛出异常：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">//如果分配失败，new抛出std::bad_alloc异常</span>
<span class="token keyword">int</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>nothrow<span class="token punctuation">)</span> <span class="token keyword">int</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//如果分配失败，new返回一个空指针，不抛出异常</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
我们称这种形式的new为定位new。定位new表达式允许我们向new传递额外的参数。这里我们传递的是标准库的一个名为nothrow的对象，告诉它不能抛出异常。bad_alloc和nothrow都定义在头文件new中。</li>
<li>通常情况下，编译器不能分辨一个指针指向的是静态还是动态分配的对象。类似的，编译器也不能分辨一个指针所指向的内存是否已经被释放了。</li>
<li>使用new和delete管理动态内存存在三个问题：<ul>
<li>忘记delete内存。忘记释放动态内存会导致人们常说的“内存泄漏”问题，因为这种内存永远不可能被归还给自由空间了。</li>
<li>使用已经释放掉的对象。通过在释放内存后将指针置位空，有时可以检测出这种错误（delete p; p = nullptr）。</li>
<li>同一块内存释放两次。</li>
</ul>
</li>
<li>坚持使用智能指针，就可以避免所有这些问题。对于一块内存，只有在没有任何智能指针指向它的情况下，智能指针才会自动释放它。</li>
<li><p>接受指针参数的智能指针构造函数时explicit的，我们不能进行内置指针到智能指针之间的隐式转换：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//正确：使用了直接初始化形式</span>
std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//错误：不能将普通指针隐式转换为智能指针</span>

std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//错误：不能将普通指针隐式转换为智能指针</span>
<span class="token punctuation">}</span>
std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">clone1</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//正确，显式创建智能指针</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>定义智能指针时还可以增加一个参数来代替delete，这个参数必须是一个可调用对象：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p1</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>vp<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">delete</span> vp<span class="token punctuation">;</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"delete"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
当智能指针p1离开其作用域时，如果其计数器变为0，将会执行这个可调用的lambda表达式，输出字符串delete。</li>
<li>智能指针还有一个名叫reset的成员函数：<ul>
<li><code>p.reset();</code> ：若p是唯一指向其对象的shared_ptr，reset会释放此对象</li>
<li><code>p.reset(q);</code>：令p指向指针q</li>
<li><code>p.reset(q, d);</code>：令p指向q，并且调用对象d而不是delete来释放q</li>
</ul>
</li>
<li><p>不要混合使用普通指针和智能指针：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> vp<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">process</span><span class="token punctuation">(</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//合法，但函数退出后p指向的内存会被释放，p称为悬空指针</span>
<span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当将一个shared_ptr绑定到一个普通指针时，我们就将内存的管理责任交给了这个shared_ptr。一旦这样做了，我们就不应该再使用内置指针来问shared_ptr所指向的内存了。</p>
</li>
<li>不要用智能指针的get成员函数返回的普通指针，去初始化另一个智能指针：<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> q <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">{</span>
    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">TempP</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//逻辑错误：两个独立的shared_ptr指向相同的内存</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> foo <span class="token operator">=</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//未定义：p指向的内存已经被释放了</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>发生异常后，智能指针指向的内存会被正常释放，但是普通指针指向的内存就永远不会被释放了（在delete之前发生异常）：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">sp</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//这段代码发生异常</span>
<span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//函数结束时，shared_ptr自动释放内存</span>

<span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//这段代码发生异常</span>
    <span class="token keyword">delete</span> p<span class="token punctuation">;</span>
<span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//发生异常后，p指向的内存永远不会被释放</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>无论是否发生异常，局部对象都会被销毁，所以发生异常后sp会被销毁，但是delete p永远执行不到。这个特性对建立局部网络连接的代码很有用，如果代码是这样的：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> SDestination<span class="token punctuation">;</span>
<span class="token keyword">struct</span> SConnection<span class="token punctuation">;</span>
SConnection <span class="token function">connect</span><span class="token punctuation">(</span>SDestination<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//打开连接</span>
<span class="token keyword">void</span> <span class="token function">disconnect</span><span class="token punctuation">(</span>SConnection<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//关闭连接</span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>SDestination <span class="token operator">&amp;</span>d<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    SConnection Conn <span class="token operator">=</span> <span class="token function">connect</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//使用连接</span>
    <span class="token comment" spellcheck="true">//如果我们在f退出前忘记调用disconnect，或者在调用它之前发生了异常，就无法关闭连接Conn了</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>为了保证函数退出时关闭连接，我们可以使用智能指针：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> SDestination<span class="token punctuation">;</span>
<span class="token keyword">struct</span> SConnection<span class="token punctuation">;</span>
SConnection <span class="token function">connect</span><span class="token punctuation">(</span>SDestination<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//打开连接</span>
<span class="token keyword">void</span> <span class="token function">disconnect</span><span class="token punctuation">(</span>SConnection<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//关闭连接</span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>SDestination <span class="token operator">&amp;</span>d<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    SConnection Conn <span class="token operator">=</span> <span class="token function">connect</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>SConnection<span class="token operator">></span> <span class="token function">p</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Conn<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>SConnection <span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">disconnect</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//使用连接</span>
    <span class="token comment" spellcheck="true">//即使我们在f退出前忘记调用disconnect，或者在调用它之前发生了异常，Conn也会被正确关闭</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>即使发生了异常或者忘记调用disconnect，连接也会被正常关闭，因为函数退出时会释放局部对象p，p在被销毁时会调用lambda表达式来关闭连接。</p>
</li>
<li>为了正确使用智能指针，我们必须坚持一些规范：<ul>
<li>不使用相同的内置指针初始化（或reset）多个智能指针</li>
<li>不delete get()返回的指针</li>
<li>不使用get()返回的指针去初始化或reset另一个智能指针</li>
<li>如果使用get返回的普通指针，记住当最后一个对应的智能指针被销毁后，这个普通指针就失效了</li>
<li>如果使用智能指针管理的资源不是new分配的内存，记住传递给它一个删除器（代替delete的可调用对象）</li>
</ul>
</li>
<li>与shared_ptr不同，某个时刻只能有一个unique_ptr指向一个给定对象。当unique_ptr被销毁时，它所指向的对象也被销毁。而且没有类似make_shader的标准库函数来返回一个unique_ptr。当我们定义一个unique_ptr时，需要将其绑定到一个new返回的指针上或默认初始化，因为它不支持拷贝和赋值操作（独占内存所致）：<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> p1<span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">//p1是一个指向int类型的空指针</span>
std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p2</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//p2指向一个值为42的int</span>
std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p3</span><span class="token punctuation">(</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//错误：unique_ptr不支持拷贝</span>
p1 <span class="token operator">=</span> p2<span class="token punctuation">;</span>                               <span class="token comment" spellcheck="true">//错误：unique_ptr不支持赋值</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>虽然不能拷贝或赋值unique_ptr，但可以通过release算法unique_ptr对指针的控制权，然后将其转移给另一个unique_ptr：<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//p2指向一个值为42的int</span>
std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p2</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//将p1的控制权转移给p2</span>
p1<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span>p2<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">//将p2的控制权转移给p1</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
如果我们不用另一个智能指针来保存release返回的普通指针，我们的程序就要负责delete掉该指针。</li>
<li>不能拷贝unique_ptr的规则有一个例外：我们可以拷贝或赋值一个将要被销毁的unique_ptr（因为通常会对它们指向移动拷贝或移动赋值，见13章）：<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">sp</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> sp<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//正确：可以对一个将要被销毁的unique_ptr赋值或拷贝</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>和shared_ptr类似，我们也可以像unique_ptr传递一个自定义的删除器，不同的是，定义时必须显式制定出删除器的模板类型：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">deleteFunc</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">delete</span> p<span class="token punctuation">;</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"delete"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>deleteFunc<span class="token punctuation">)</span><span class="token operator">*</span><span class="token operator">></span> <span class="token function">p1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">,</span> deleteFunc<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>weak_ptr是一种不控制所指向对象生存期的智能指针，它指向由一个shared_ptr管理的对象。将一个weak_ptr绑定到一个shared_ptr不会改变shared_ptr的引用计数。一旦最后一个指向对象的shared_ptr被销毁，对象就会被释放，即使有weak_ptr指向对象，对象也还是会被释放。</p>
<p>当我们创建一个weak_ptr时，要用一个shared_ptr来初始化它：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> sp <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token operator">::</span>weak_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">wp</span><span class="token punctuation">(</span>sp<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//wp弱共享sp，sp的引用计数未改变</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>weak_ptr特有的成员操作如下：</p>
<ul>
<li>w.use_count()：与w共享对象的shared_ptr的数量</li>
<li>w.expired()：若w.use_count()为0，返回true，否则返回false</li>
<li>w.lock()：如果expired为true，返回一个空的shared_ptr；否则返回一个指向w的对象的shared_ptr</li>
</ul>
<p>从上面可以看出weak_ptr所指向的对象可能不存在，所以我们不能使用weak_ptr直接访问对象，而必须调用lock：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> vSp <span class="token operator">=</span> wp<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//在if中使用vSp访问共享对象是安全的</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<p><font size="5" color="orange">动态数组</font></p>
<hr>
<ol>
<li>标准库包含一个名为allocator的类，允许我们将分配和初始化分离。使用allocator通常会提供更好的性能和更灵活的内存管理能力。</li>
<li>大多数应用应该使用标准库容器而不是动态分配的数组。使用容器更为简单、更不容易出现内存管理错误并且可能有更好的性能。</li>
<li>我们用new分配的动态数组并不是数组类型，所以不能对动态数组调用begin或end：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
 <span class="token keyword">auto</span> it <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">begin</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//正确：可以对数组类型调用begin函数</span>
 <span class="token keyword">int</span> <span class="token operator">*</span>b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
 <span class="token function">memset</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">auto</span> it2 <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">begin</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//错误：不能对动态数组调用begin函数</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>释放动态数组时，需要在delete之后、指针名之前加上一个[ ]：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> <span class="token operator">*</span>b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
 <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
 动态数组中的元素按逆序销毁，即最后一个元素先被销毁，然后是倒数第二个…。</li>
<li>标准库提供了一个可以管理new分配的数组的unique_ptr版本，需要在模板参数的对象类型后面跟一个方括号：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> <span class="token function">up</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 up<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//自动调用delete[]销毁其指针</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
 但是如果要使用shared_ptr来管理一个动态数组，必须提供自定义的删除器：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">sp</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> p<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 sp<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//使用我们提供的lambda释放数组，它使用delete[]</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p>unique_ptr管理的动态数组可以通过下标来访问元素，但是shared_ptr不可以，它没有定义下标运算符。而且智能指针类型不支持指针算术运算。因此shared_ptr为了访问数组中的元素，必须先用get获取一个内置指针，然后用它来访问素组元素：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> <span class="token function">up</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
     up<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>

 std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">sp</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> p<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
     <span class="token operator">*</span><span class="token punctuation">(</span>sp<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> i<span class="token punctuation">)</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>当分配一大块内存时，我们通常计划在这块内存还是那个按需构造对象。在此情况下，我们希望将内存分配和对象构造分离。这意味着我们可以分配大块内存，但只在真正需要时才真正执行对象创建操作。</li>
<li>标准库allocator类定义在头文件memory中，它帮助我们将内存分配和对象构造分离开来。allocator也是一个模板，它会根据给定的对象类型来确定恰当的内存大小和对齐位置：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>allocator<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> Alloc<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//可以分配string的allocator对象</span>
 <span class="token keyword">auto</span> <span class="token keyword">const</span> p <span class="token operator">=</span> Alloc<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//分配n个未初始化的string</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
 allocator类的成员操作如下表：</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">allocator<t> a</t></td>
<td>定义一个allocator对象，它可以为类型为T的对象分配内存</td>
</tr>
<tr>
<td style="text-align:center">a.allocate(n)</td>
<td>分配一段原始的、未构造的内存，保存n个类型为T的对象</td>
</tr>
<tr>
<td style="text-align:center">a.deallocate(p, n)</td>
<td>释放从T*指针p中地址开始的内存，这块内存保存了n个类型为T的对象；p必须是一个先前由allocate返回的指针，且n必须是p创建时所要求的大小。在调用deallocate之前，用户必须对每个在这块内存中创建的对象调用destroy</td>
</tr>
<tr>
<td style="text-align:center">a.construct(p, args)</td>
<td>p必须是一个类型为T*的指针，指向一块原始内存；args被传递给类型为T的构造函数，用来在p指向的内存中构造一个对象</td>
</tr>
<tr>
<td style="text-align:center">a.destroy(p)</td>
<td>p为T*类型的指针，此算法对p指向的对象执行析构函数</td>
</tr>
</tbody>
</table>
<ol>
<li>allocator分配的内存是未构造的，我们需要在此内存中构造对象，而construct成员函数接受一个指针和零个或多个额外参数，在指针所指的位置构造一个元素：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">auto</span> q <span class="token operator">=</span> p<span class="token punctuation">;</span>
 Alloc<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>q<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//*q为空字符串</span>
 Alloc<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>q<span class="token operator">++</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//*q为10个字符c组成的字符串</span>
 Alloc<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>q<span class="token operator">++</span><span class="token punctuation">,</span> <span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//*q为字符串hello</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
 还未构造对象的情况下就使用原始内存是错误的：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>allocator<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> Alloc<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//可以分配string的allocator对象</span>
 <span class="token keyword">auto</span> <span class="token keyword">const</span> p <span class="token operator">=</span> Alloc<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//分配n个未初始化的string</span>
 std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//错误：程序崩溃，因为p指向未构造的内存</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li>当我们用完对象后，必须对每个构造的元素调用destroy来销毁它们。函数destroy接受一个指针，对指向的对象执行析构函数：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">while</span> <span class="token punctuation">(</span>q <span class="token operator">!=</span> p<span class="token punctuation">)</span>
    Alloc<span class="token punctuation">.</span><span class="token function">destroy</span><span class="token punctuation">(</span><span class="token operator">--</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li>销毁这些被构造出来的元素以后，我们就可以使用deallocate成员函数把内存归还给系统了（当然也可以拿这些内存再去构造新的对象）。所以allocator使用四部曲就是：allocate、construct、destroy、deallocate：<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>allocator<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> Alloc<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//可以分配string的allocator对象</span>
<span class="token keyword">auto</span> <span class="token keyword">const</span> p <span class="token operator">=</span> Alloc<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//分配n个未初始化的string</span>
<span class="token keyword">auto</span> q <span class="token operator">=</span> p<span class="token punctuation">;</span>
Alloc<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>q<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//*q为空字符串</span>
Alloc<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>q<span class="token operator">++</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//*q为10个字符c组成的字符串</span>
Alloc<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>q<span class="token operator">++</span><span class="token punctuation">,</span> <span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//*q为字符串hello</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>q <span class="token operator">!=</span> p<span class="token punctuation">)</span>
    Alloc<span class="token punctuation">.</span><span class="token function">destroy</span><span class="token punctuation">(</span><span class="token operator">--</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment" spellcheck="true">//销毁每个构造出来的对象</span>
Alloc<span class="token punctuation">.</span><span class="token function">deallocate</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">//第二个参数必须与allocate分配内存时指定的参数相同</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>标准库还为allocator类定义了两个伴随算法：copy和fill，用于在未初始化内存（原始内存）中创建对象，定义在头文件memory中：<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> SVec<span class="token punctuation">{</span> <span class="token string">"Hello"</span><span class="token punctuation">,</span><span class="token string">"World"</span><span class="token punctuation">,</span><span class="token string">"Nice"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
std<span class="token operator">::</span>allocator<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> Alloc<span class="token punctuation">;</span>
<span class="token keyword">auto</span> p <span class="token operator">=</span> Alloc<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span>SVec<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//通过拷贝SVec中的元素来构造原始内存从p开始的元素</span>
<span class="token keyword">auto</span> q <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">uninitialized_copy</span><span class="token punctuation">(</span>SVec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> SVec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//将原始内存中剩余的未构造元素初始化为字符串Same</span>
std<span class="token operator">::</span><span class="token function">uninitialized_fill_n</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> SVec<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"Same"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">uninitialized_copy(b, e, b2)</td>
<td>将迭代器b到e范围内的元素拷贝到迭代器b2指向的未构造的原始内存中</td>
</tr>
<tr>
<td style="text-align:center">uninitialized_copy_n(b, n, b2)</td>
<td>从迭代器b指向的元素开始，拷贝n个元素到b2指向的原始内存中</td>
</tr>
<tr>
<td style="text-align:center">uninitialized_fill(b, e, t)</td>
<td>在迭代器b到e的元素内存范围内构造对象，对象的值均为t的拷贝</td>
</tr>
<tr>
<td style="text-align:center">uninitialized_fill_n(b, n, t)</td>
<td>从迭代器b指向的元素内存开始创建n个对象，对象的值均为t的拷贝</td>
</tr>
</tbody>
</table>
<p><font size="5" color="orange">使用标准库：文本查询程序</font></p>
<hr>
<ol>
<li>-_-||，最近比较忙，比较忙。。。有时间再来补上了(*￣︶￣)</li>
</ol>
<p>&nbsp; </p>
<hr>
<p>参考文献：《C++Primer第五版》</p>
]]></content>
      
        <categories>
            
            <category> C++ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C++Primer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++Primer第十一章 关联容器]]></title>
      <url>/2018/03/05/C++Primer%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/</url>
      <content type="html"><![CDATA[<p><font size="5" color="orange">概述</font></p>
<hr>
<ol>
<li>关联容器支持高效的关键字查找和访问。两个主要的关联容器是map和set。map是键值对集合，而set只是关键字集合，set支持高效的关键字查询工作：检查一个给定关键字是否存在set中。</li>
<li>允许重复关键字的关联容器的名字中都包含单词multi；不保持关键字按顺序存储的容器的名字都以单词unordered开头。</li>
<li>类型map和multimap定义在头文件map中，set和multiset定义在头文件set中，无序容器定义在头文件unordered_map和unordered_set中。</li>
</ol>
<p><font size="5" color="orange">使用关联容器</font></p>
<hr>
<ol>
<li>当只想知道一个值是否存在时，set是最有用的。</li>
<li>可以使用map来统计字符串中每个字符出现的次数：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>string Str <span class="token operator">=</span> <span class="token string">"The farthest distance in the world is not between death and life."</span><span class="token punctuation">;</span>
 std<span class="token operator">::</span>map<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token punctuation">,</span> size_t<span class="token operator">></span> CharCount<span class="token punctuation">;</span>
 <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> e <span class="token operator">:</span> Str<span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
     <span class="token operator">++</span>CharCount<span class="token punctuation">[</span>e<span class="token punctuation">]</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
 <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span> <span class="token operator">&amp;</span>e <span class="token operator">:</span> CharCount<span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
     std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> e<span class="token punctuation">.</span>first <span class="token operator">&lt;&lt;</span> <span class="token string">":"</span> <span class="token operator">&lt;&lt;</span> e<span class="token punctuation">.</span>second <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
 当从一个map中提取一个元素时，会得到一个pair类型的对象，所以访问map中的元素时使用了first成员和second成员。</li>
<li>对于上述例子，如果我们不想统计空格、标点符号等等字符，可以先用set来保存想要忽略的字符，只对不在set中的字符统计出现次数：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>string Str <span class="token operator">=</span> <span class="token string">"The farthest distance in the world is not between death and life."</span><span class="token punctuation">;</span>
 std<span class="token operator">::</span>map<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token punctuation">,</span> size_t<span class="token operator">></span> CharCount<span class="token punctuation">;</span>
 std<span class="token operator">::</span>set<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span> IgnoreSet<span class="token punctuation">{</span> <span class="token string">' '</span><span class="token punctuation">,</span><span class="token string">','</span><span class="token punctuation">,</span><span class="token string">'.'</span><span class="token punctuation">,</span><span class="token string">'!'</span><span class="token punctuation">,</span><span class="token string">':'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
 <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> e <span class="token operator">:</span> Str<span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
     <span class="token keyword">if</span><span class="token punctuation">(</span>IgnoreSet<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token operator">==</span>IgnoreSet<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//查找当前字符是否在忽略字符的集合中</span>
         <span class="token operator">++</span>CharCount<span class="token punctuation">[</span>e<span class="token punctuation">]</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
 <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span> <span class="token operator">&amp;</span>e <span class="token operator">:</span> CharCount<span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
     std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> e<span class="token punctuation">.</span>first <span class="token operator">&lt;&lt;</span> <span class="token string">":"</span> <span class="token operator">&lt;&lt;</span> e<span class="token punctuation">.</span>second <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<p><font size="5" color="orange">关联容器概述</font></p>
<hr>
<ol>
<li>关联容器的迭代器都是双向的。</li>
<li>map和set的关键字必须是唯一的，而multimap和multiset没有此限制：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> Array<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
 std<span class="token operator">::</span>set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">ISet</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">begin</span><span class="token punctuation">(</span>Array<span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span><span class="token function">end</span><span class="token punctuation">(</span>Array<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 std<span class="token operator">::</span>multiset<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">IMultiSet</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">begin</span><span class="token punctuation">(</span>Array<span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span><span class="token function">end</span><span class="token punctuation">(</span>Array<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> ISet<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//输出4</span>
 std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> IMultiSet<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//输出8</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>默认情况下，标准库使用关键字类型的&lt;运算符来比较两个关键字。如果一个类型定义了“行为正常”的&lt;运算符，则它可以用作关键字类型。</li>
<li>我们也可以使用关联容器的第二个模板参数来自定义比较操作（通常是一个函数指针类型）：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">bool</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token keyword">int</span> v1<span class="token punctuation">,</span> <span class="token keyword">int</span> v2<span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
     <span class="token keyword">return</span> v1 <span class="token operator">></span> v2<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
 std<span class="token operator">::</span>set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>compare<span class="token punctuation">)</span><span class="token operator">*</span><span class="token operator">></span> <span class="token function">ISet</span><span class="token punctuation">(</span>compare<span class="token punctuation">)</span><span class="token punctuation">;</span>
 ISet<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//ISet中元素为：2 1</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
 我们使用decltype来指出自定义比较操作的类型，由于用decltype获得的是函数类型而非函数指针，所以还需要在后面加上一个*。在定义容器时，需要将比较函数的地址作为实参传入。当我们向set容器中添加元素时，通过调用compare函数来为这些元素排序。</li>
<li>pair这个标准库类型定义在头文件utility中。pair的默认构造函数会对数据成员进行值初始化：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>pair<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> Pair1<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//默认值初始化，Pair1保存一个空string和整型值0</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
 pair的数据成员是public的，两个成员分别命名为first和second。我们还可以使用make_pair(v1, v2)函数来生成一个pair，pair的类型根据参数的类型出来：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">auto</span> Pair1 <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">make_pair</span><span class="token punctuation">(</span><span class="token string">"good"</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//Pair1的类型是pair&lt;string, int></span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
</ol>
<p><font size="5" color="orange">关联容器操作</font></p>
<hr>
<ol>
<li>关联容器还定义了key_type等等类型别名：<ul>
<li>key_type：关联容器的关键字类型</li>
<li>mapped_type：值的类型，只适用于map</li>
<li>value_type：关联容器中元素的类型。对于set就是关键字类型，和key_type相同；对于map，为pair<const key_type,="" mapped_type=""><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>set<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span><span class="token operator">::</span>value_type v1<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//v1是一个string</span>
std<span class="token operator">::</span>map<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>value_type v2<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//v2是一个pair&lt;const string, int></span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
对于map，value_type是一个pair类型，其fisrt成员保存const的关键字，second成员保存值。</const></li>
</ul>
</li>
<li>一个set中的关键字也是const的。可以用一个set迭代器来读取元素的值，但不能修改，因为set迭代器是只读的。</li>
<li>我们通常不对关联容器使用泛型算法。关键字是const这一特性意味着不能将关联容器传递给修改或重排容器元素的算法，因为这类算法需要向元素写入值，而set类型中的元素是const的，map的关键字也是const的。关联容器可用于只读取元素的算法。但是，很多这类算法都要搜索序列。由于关联容器中的元素不能通过它们的关键字进行快速查找，因此对其使用泛型算法几乎总是个坏主意。比如使用关联容器自己定义的find成员会比调用泛型find快得多。</li>
<li><p>向关联容器中添加元素可以使用insert成员函数。对于set有两个版本：一个是接受范围迭代器，一个是接受初始值列表：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> IVec<span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
 std<span class="token operator">::</span>set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ISet<span class="token punctuation">;</span><span class="token punctuation">;</span>
 ISet<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>IVec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> IVec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//ISet现在有4个元素</span>
 ISet<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//ISet现在有6个元素</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p> 向map中添加元素时，insert的参数是必须是pair：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>map<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token punctuation">,</span> size_t<span class="token operator">></span> Map1<span class="token punctuation">;</span>
 Map1<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token string">"First"</span><span class="token punctuation">,</span><span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 Map1<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>std<span class="token operator">::</span>pair<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token punctuation">,</span> size_t<span class="token operator">></span><span class="token punctuation">(</span><span class="token string">"Second"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 Map1<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">make_pair</span><span class="token punctuation">(</span><span class="token string">"Third"</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 Map1<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>std<span class="token operator">::</span>map<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token punctuation">,</span> size_t<span class="token operator">></span><span class="token operator">::</span><span class="token function">value_type</span><span class="token punctuation">(</span><span class="token string">"Forth"</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 Map1<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span><span class="token string">"Fifth"</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 除了用insert插入外，还可以使用emplace成员函数来插入元素，和insert不同的是，emplace可以直接从参数构造一个元素，所以上面代码插入Fifth，5时并没有加花括号，但是insert不行。</p>
<p> 对于set和map这种不包含重复关键字的容器，添加单一元素的insert和emplace版本返回一个pair，告诉我们插入操作是否成功，pair的first成员是一个迭代器，指向具有给定关键字的元素；second成员是一个bool值，指出元素是插入成功，还是因为已经存在于容器中而插入失败。</p>
<p> 对于multiset和multimap这种允许重复关键字的容器接受单个元素的insert和emplace操作返回一个指向新元素的迭代器，无须再返回一个bool值，因为插入总是成功的。</p>
</li>
<li>关联容器使用成员函数erase来进行删除操作，它的参数是一个要删除元素的关键字、或要删除元素的迭代器或者迭代器范围：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ISet<span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
 ISet<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//删除ISet中关键字为1的元素</span>
 ISet<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>ISet<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//删除ISet中第一个元素</span>
 ISet<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>ISet<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">++</span>ISet<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//删除ISet中第一个迭代器到第二个迭代器之间的范围（不包括第二个迭代器指向的元素）</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
 对于保存不重复关键字的容器，erase的返回值总是0或1，若返回值为0，则表明想要删除的元素并不在容器中。对于允许重复关键字的容器，删除元素的数量可能大于1。</li>
<li><p>我们不能对一个multimap或unordered_multimap进行下标操作，因为这些容器中可能有多个值与一个关键字相关联。map和unordered_map的下标操作如下：</p>
<ul>
<li>c[k]：返回关键字为k的元素的引用；如果k不在c中，添加一个关键字为k的元素，对其进行值初始化</li>
<li><p>c.at[k]：访问关键字为k的元素，带参数检查：若k不在c中，抛出一个out_of_range异常</p>
<p>关联容器的下标运算符在查找关键字时，如果关键字不在容器中，可能会向容器中插入一个新元素，所以我们只可以对非const的map使用下标操作。</p>
</li>
</ul>
</li>
<li>如果只是想知道一个元素是否在map中，但不存在是并不想添加元素，在这种情况下就不能使用下标运算符，而应该使用at或者find成员函数。<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> Map1<span class="token punctuation">;</span>
 <span class="token keyword">if</span> <span class="token punctuation">(</span>Map1<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                    <span class="token comment" spellcheck="true">//Map1中会加入一个{1, 0}键值对</span>
 <span class="token punctuation">{</span>
 <span class="token punctuation">}</span>
 <span class="token keyword">if</span> <span class="token punctuation">(</span>Map1<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">!=</span>Map1<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">//不会向Map1中插入新元素</span>
 <span class="token punctuation">{</span>
 <span class="token punctuation">}</span>
 <span class="token keyword">if</span> <span class="token punctuation">(</span>Map1<span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                 <span class="token comment" spellcheck="true">//抛出异常，不会向Map1中插入新元素</span>
 <span class="token punctuation">{</span>
 <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>对一个map进行下标操作时，会获得一个mapped_type对象，但当解引用一个map迭代器时，会得到一个value_type对象。</li>
<li>在一个关联容器中查找元素的操作如下，其中lower_bound和upper_bound不适用于无序容器，下标和at操作只适用于非const的map和unordered_map：</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">c.find(k)</td>
<td>返回一个迭代器，指向第一个关键字为k的元素，若k不在容器中，则返回尾后迭代器</td>
</tr>
<tr>
<td style="text-align:center">c.count(k)</td>
<td>返回关键字等于k的元素数量</td>
</tr>
<tr>
<td style="text-align:center">c.lower_bound(k)</td>
<td>返回一个迭代器，指向第一个关键字不小于k的元素</td>
</tr>
<tr>
<td style="text-align:center">c.upper_bound(k)</td>
<td>返回一个迭代器，指向第一个关键字大于k的元素</td>
</tr>
<tr>
<td style="text-align:center">c.equal_range(k)</td>
<td>返回一个迭代器pair，表示关键字等于k的元素的范围，若k不存在，则pair的两个成员均等于c.end()</td>
</tr>
</tbody>
</table>
<ol>
<li>如果一个multimap或multiset中有多个元素具有相同的关键字，则这些元素在容器中会相邻存储。</li>
<li>如果想要输出一个map中具有给定关键字的所有元素，可以使用以下三种方案：<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>multimap<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token punctuation">,</span> size_t<span class="token operator">></span> Map1<span class="token punctuation">{</span> <span class="token punctuation">{</span><span class="token string">"Bob"</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"Lucy"</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"Bob"</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"Smith"</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"Bob"</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> BobCount <span class="token operator">=</span> Map1<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token string">"Bob"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> Iter <span class="token operator">=</span> Map1<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">"Bob"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> BobCount<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>Iter<span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>first <span class="token operator">&lt;&lt;</span> <span class="token string">":"</span> <span class="token operator">&lt;&lt;</span> Iter<span class="token operator">-</span><span class="token operator">></span>second <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>multimap<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token punctuation">,</span> size_t<span class="token operator">></span> Map1<span class="token punctuation">{</span> <span class="token punctuation">{</span><span class="token string">"Bob"</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"Lucy"</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"Bob"</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"Smith"</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"Bob"</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> Iter1 <span class="token operator">=</span> Map1<span class="token punctuation">.</span><span class="token function">lower_bound</span><span class="token punctuation">(</span><span class="token string">"Bob"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> Iter2 <span class="token operator">=</span> Map1<span class="token punctuation">.</span><span class="token function">upper_bound</span><span class="token punctuation">(</span><span class="token string">"Bob"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> CurIter <span class="token operator">=</span> Iter1<span class="token punctuation">;</span> CurIter <span class="token operator">!=</span> Iter2<span class="token punctuation">;</span> <span class="token operator">++</span>CurIter<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> CurIter<span class="token operator">-</span><span class="token operator">></span>first <span class="token operator">&lt;&lt;</span> <span class="token string">":"</span> <span class="token operator">&lt;&lt;</span> CurIter<span class="token operator">-</span><span class="token operator">></span>second <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>multimap<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token punctuation">,</span> size_t<span class="token operator">></span> Map1<span class="token punctuation">{</span> <span class="token punctuation">{</span><span class="token string">"Bob"</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"Lucy"</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"Bob"</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"Smith"</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"Bob"</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> IterRange <span class="token operator">=</span> Map1<span class="token punctuation">.</span><span class="token function">equal_range</span><span class="token punctuation">(</span><span class="token string">"Bob"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> CurIter <span class="token operator">=</span> IterRange<span class="token punctuation">.</span>first<span class="token punctuation">;</span> CurIter <span class="token operator">!=</span> IterRange<span class="token punctuation">.</span>second<span class="token punctuation">;</span> <span class="token operator">++</span>CurIter<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> CurIter<span class="token operator">-</span><span class="token operator">></span>first <span class="token operator">&lt;&lt;</span> <span class="token string">":"</span> <span class="token operator">&lt;&lt;</span> CurIter<span class="token operator">-</span><span class="token operator">></span>second <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>C++Primer P391页中所述的单词转换程序如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>map<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token punctuation">,</span>std<span class="token operator">::</span>string<span class="token operator">></span> <span class="token function">buildMap</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> vFileName<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token operator">::</span>map<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token punctuation">,</span> std<span class="token operator">::</span>string<span class="token operator">></span> TransformMap<span class="token punctuation">;</span>
    std<span class="token operator">::</span>ifstream <span class="token function">Fin</span><span class="token punctuation">(</span>vFileName<span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token operator">::</span>string Value<span class="token punctuation">;</span>
    std<span class="token operator">::</span>string Key<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>Fin <span class="token operator">>></span> Key <span class="token operator">&amp;&amp;</span> <span class="token function">getline</span><span class="token punctuation">(</span>Fin<span class="token punctuation">,</span> Value<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        TransformMap<span class="token punctuation">[</span>Key<span class="token punctuation">]</span> <span class="token operator">=</span> Value<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//跳过第一个空格</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> TransformMap<span class="token punctuation">;</span>
    Fin<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

std<span class="token operator">::</span>string <span class="token function">transform</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> vFileName<span class="token punctuation">,</span> std<span class="token operator">::</span>map<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token punctuation">,</span> std<span class="token operator">::</span>string<span class="token operator">></span><span class="token operator">&amp;</span> vTransformMap<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token operator">::</span>string Result<span class="token punctuation">;</span>
    std<span class="token operator">::</span>ifstream <span class="token function">Fin</span><span class="token punctuation">(</span>vFileName<span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token operator">::</span>string Value<span class="token punctuation">;</span>
    std<span class="token operator">::</span>string Line<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">getline</span><span class="token punctuation">(</span>Fin<span class="token punctuation">,</span>Line<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        std<span class="token operator">::</span>istringstream <span class="token function">Stream</span><span class="token punctuation">(</span>Line<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">bool</span> FirstWord <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>Stream <span class="token operator">>></span> Value<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>FirstWord<span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                FirstWord <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">else</span>
            <span class="token punctuation">{</span>
                Result<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>

            <span class="token keyword">if</span> <span class="token punctuation">(</span>vTransformMap<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>Value<span class="token punctuation">)</span> <span class="token operator">!=</span> vTransformMap<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                Result<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>vTransformMap<span class="token punctuation">[</span>Value<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">else</span>
            <span class="token punctuation">{</span>
                Result<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>Value<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        Result<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    Fin<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> Result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token operator">::</span>map<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token punctuation">,</span> std<span class="token operator">::</span>string<span class="token operator">></span> TransformMap <span class="token operator">=</span> <span class="token function">buildMap</span><span class="token punctuation">(</span><span class="token string">"TransformRules.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">transform</span><span class="token punctuation">(</span><span class="token string">"InputText.txt"</span><span class="token punctuation">,</span> TransformMap<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>文件TransformRules.txt的内容如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">brb be right back
k okay <span class="token operator">?</span>
y why
r are
u you
pic picture
thk thanks
18r later
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>文件InputText.txt的内容如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">where r u
y dont u send me a pic
k thk 18r
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<p><font size="5" color="orange">无序容器</font></p>
<hr>
<ol>
<li>新标准定义了4个无序关联容器，这些容器不是使用比较运算符来组织元素，而是使用一个哈希函数和关键字类型的==运算符。在关键字类型的元素没有明显的序关系的情况下，无序容器是非常有用的。在某些应用中，维护元素的序代价非常高昂，此时无序容器也很有用。</li>
<li>如果关键字类型固有就是无序的，或者性能测试发现问题可以用哈希技术解决，就可以使用无序容器。</li>
<li><p>除了哈希管理操作之外，无序容器还提供了与有序容器相同的操作（find、insert等）。这意味着我们曾用于map和set的操作也能用于unordered_map和unordered_set。类似的，无序容器也有允许重复关键字的版本。</p>
<p> 用无序容器重写之前统计字符串中字符出现次数的程序如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>string Str <span class="token operator">=</span> <span class="token string">"The farthest distance in the world is not between death and life."</span><span class="token punctuation">;</span>
 std<span class="token operator">::</span>unordered_map<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token punctuation">,</span> size_t<span class="token operator">></span> CharCount<span class="token punctuation">;</span>
 std<span class="token operator">::</span>unordered_set<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span> IgnoreSet<span class="token punctuation">{</span> <span class="token string">' '</span><span class="token punctuation">,</span><span class="token string">','</span><span class="token punctuation">,</span><span class="token string">'.'</span><span class="token punctuation">,</span><span class="token string">'!'</span><span class="token punctuation">,</span><span class="token string">':'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
 <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> e <span class="token operator">:</span> Str<span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>IgnoreSet<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token operator">==</span> IgnoreSet<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//查找当前字符是否在忽略字符的集合中</span>
         <span class="token operator">++</span>CharCount<span class="token punctuation">[</span>e<span class="token punctuation">]</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
 <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span> <span class="token operator">&amp;</span>e <span class="token operator">:</span> CharCount<span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
     std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> e<span class="token punctuation">.</span>first <span class="token operator">&lt;&lt;</span> <span class="token string">":"</span> <span class="token operator">&lt;&lt;</span> e<span class="token punctuation">.</span>second <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>无序容器在存储上组织为一组桶，每个桶保存零个或多个元素。无序容器使用一个哈希函数将元素映射到桶。为了访问一个元素，容器首先计算元素的哈希值，它指出应该搜索哪个桶。容器将具有一个特定哈希值的所有元素保存在相同的桶中。如果容器允许重复关键字，所有具有相同关键字的元素都会在同一个桶中。因此，无序容器的性能依赖于哈希函数的质量和桶的数量和大小。</li>
<li>计算一个元素的哈希值和在桶中搜索都是很快的操作。但是，如果一个桶中保存了很多元素，那么查找一个特定元素就需要大量比较操作（哈希表特性）。</li>
<li>无序容器的管理操作如下：</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">c.bucket_count()</td>
<td>正在使用的桶的数目</td>
</tr>
<tr>
<td style="text-align:center">c.max_bucket_count()</td>
<td>容器能容纳的最多的桶的数量</td>
</tr>
<tr>
<td style="text-align:center">c.bucket_size(n)</td>
<td>第n个桶中有多少个元素</td>
</tr>
<tr>
<td style="text-align:center">c.bucket(k)</td>
<td>关键字为k的元素在哪个桶中</td>
</tr>
<tr>
<td style="text-align:center">local_iterator</td>
<td>可以用来访问桶中元素的迭代器类型</td>
</tr>
<tr>
<td style="text-align:center">const_local_iterator</td>
<td>桶迭代器的const版本</td>
</tr>
<tr>
<td style="text-align:center">c.begin(n), c.end(n)</td>
<td>桶n的首元素迭代器和尾后迭代器</td>
</tr>
<tr>
<td style="text-align:center">c.cbegin(n), c.cend(n)</td>
<td>与前两个函数类似，但是返回const_local_iterator</td>
</tr>
<tr>
<td style="text-align:center">c.load_factor()</td>
<td>每个桶的平均元素数量，返回float值</td>
</tr>
<tr>
<td style="text-align:center">c.max_load_factor()</td>
<td>c试图维护的平均桶大小，返回float值。c会在需要时添加新的桶，以使得load_factor &lt;= max_load_factor</td>
</tr>
<tr>
<td style="text-align:center">c.rehash(n)</td>
<td>重组存储，使得bucket_count &gt;= n且bucket_count &gt; size/max_load_factor</td>
</tr>
<tr>
<td style="text-align:center">c.reserve(n)</td>
<td>重组存储，使得c可以保存n个元素且不必rehash</td>
</tr>
</tbody>
</table>
<ol>
<li><p>无序容器使用一个hash<key_type>类型的对象来生成每个元素的哈希值。标准库为内置类型（包括指针）提供了hash模板。还未一些标准库类型，包括string和智能指针类型定义了hash。因此，我们可以直接定义关键字是内置类型（包括指针类型）、string或是智能指针类型的无序容器。但是，我们不能直接定义关键字类型为自定义类型的无序容器，必须先提供我们自己的hash模板版本（见16章），也可以在定义无序容器时增加生成hash值得函数模板参数和相等函数模板参数，来为自定义的类建立无序容器：</key_type></p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">class</span> <span class="token class-name">CData</span>
 <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
     <span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> <span class="token function">getDataName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> m_DataName<span class="token punctuation">;</span> <span class="token punctuation">}</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
     std<span class="token operator">::</span>string m_DataName<span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>

 size_t <span class="token function">hasher</span><span class="token punctuation">(</span><span class="token keyword">const</span> CData <span class="token operator">&amp;</span>vData<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//生成自定义类的hash值</span>
 <span class="token punctuation">{</span>
     <span class="token keyword">return</span> std<span class="token operator">::</span>hash<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>vData<span class="token punctuation">.</span><span class="token function">getDataName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>

 <span class="token keyword">bool</span> <span class="token function">equal</span><span class="token punctuation">(</span><span class="token keyword">const</span> CData <span class="token operator">&amp;</span>vData1<span class="token punctuation">,</span> <span class="token keyword">const</span> CData <span class="token operator">&amp;</span>vData2<span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
     <span class="token keyword">return</span> vData1<span class="token punctuation">.</span><span class="token function">getDataName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> vData2<span class="token punctuation">.</span><span class="token function">getDataName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>

 <span class="token comment" spellcheck="true">//定义元素类型为自定义类类型的无序容器，参数是桶大小、哈希函数指针和相等函数指针</span>
 std<span class="token operator">::</span>unordered_set<span class="token operator">&lt;</span>CData<span class="token punctuation">,</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>hasher<span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>equal<span class="token punctuation">)</span><span class="token operator">*</span><span class="token operator">></span> <span class="token function">DataSet</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">,</span> hasher<span class="token punctuation">,</span> equal<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>&nbsp; </p>
</li>
</ol>
<hr>
<p>参考文献：《C++Primer第五版》</p>
]]></content>
      
        <categories>
            
            <category> C++ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C++Primer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++Primer第十章 泛型算法]]></title>
      <url>/2018/03/04/C++Primer%E7%AC%AC%E5%8D%81%E7%AB%A0%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<p><font size="5" color="orange">概述</font></p>
<hr>
<ol>
<li>大多数泛型算法都定义在头文件algorithm中。标准库还在头文件numeric中定义了一组数值泛型算法。</li>
<li>一般情况下，这些算法并不直接操作容器，而是遍历由两个迭代器指定的一个元素范围来进行操作。</li>
<li>由于内置数组的指针就像数组上的迭代器一样，所以我们可以使用find在数组中查找值：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> IntArray<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
 <span class="token keyword">int</span> Value <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
 <span class="token keyword">int</span> <span class="token operator">*</span>pResult <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">find</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">begin</span><span class="token punctuation">(</span>IntArray<span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span><span class="token function">end</span><span class="token punctuation">(</span>IntArray<span class="token punctuation">)</span><span class="token punctuation">,</span> Value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
 find的工作是在一个未排序的元素序列中查找一个特定元素。</li>
<li>泛型算法永远不会改变底层容器的大小，可能改变容器中保存的元素的值，也可能在容器内移动元素，但永远不会直接添加或删除元素。</li>
</ol>
<p><font size="5" color="orange">初识泛型算法</font></p>
<hr>
<ol>
<li>求和算法accumulate如下：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> IntVec <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
 <span class="token keyword">int</span> Sum <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">accumulate</span><span class="token punctuation">(</span>IntVec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> IntVec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
 accumulate函数的前两个参数指出了需要求和的元素的范围，第三个参数是和的初值。第三个参数的类型决定了函数中使用哪个加法运算符以及返回值类型。accumulate函数定义在头文件numeric中。</li>
<li>由于string也定义了+运算符，所以可以使用accumulate函数将字符串连接起来：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> StrVec <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token string">"This "</span><span class="token punctuation">,</span><span class="token string">"is "</span><span class="token punctuation">,</span><span class="token string">"an "</span><span class="token punctuation">,</span><span class="token string">"apple"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
 std<span class="token operator">::</span>string SumStr <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">accumulate</span><span class="token punctuation">(</span>StrVec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> StrVec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// SumStr = "This is an apple"</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
 但是如果是下面这样就会发生错误：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>string SumStr <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">accumulate</span><span class="token punctuation">(</span>StrVec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> StrVec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//错误，const char*上没有定义+运算符</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
 如果我们把第三个参数指定的是一个字符串字面值，则用于保存和的对象的类型将是const char*，如前所述，此类型决定了使用哪个+运算符，由于const char*并没有+运算符，所以此调用将产生编译错误。</li>
<li>确定两个序列值是否相同的算法equal如下：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> IntVec <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
 std<span class="token operator">::</span>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> IntList <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
 <span class="token keyword">bool</span> IsEqual <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">equal</span><span class="token punctuation">(</span>IntVec<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> IntVec<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> IntList<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//IsEqual = true</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
 equal函数的前两个参数是第一个序列的元素范围，第三个参数是第二个序列范围的首元素。</li>
<li>使用操作两个序列但只有3个参数（前两个表示第一个序列的元素范围，第三个表示第二个序列范围的首元素）的算法时，一定要保证后一个序列至少与第一个序列一样长。</li>
<li>使用特定值填充容器某个范围的fill算法如下：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">IntVec</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 std<span class="token operator">::</span><span class="token function">fill</span><span class="token punctuation">(</span>IntVec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> IntVec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> IntVec<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//将容器的一个子序列用3填充</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
 还有个fill_n算法，它填充的是从某个迭代器到该迭代器加n的范围：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span><span class="token function">fill_n</span><span class="token punctuation">(</span>IntVec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> IntVec<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//与上面那句等价</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li>插入迭代器是一种向容器中添加元素的迭代器，当我们给容器的一个插入迭代器赋值时，它会把一个与赋值号右侧相等的元素新增到容器中（拷贝值、新增）。</li>
<li>使用back_inserter函数可以获得一个容器的插入迭代器。当我们通过此迭代器赋值时，赋值运算符会调用push_back将一个具有给定值的元素添加到容器中：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> IntVec<span class="token punctuation">;</span>
 <span class="token keyword">auto</span> Iter <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">back_inserter</span><span class="token punctuation">(</span>IntVec<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token operator">*</span>Iter <span class="token operator">=</span> <span class="token number">41</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//IntVec中现在有一个元素，值为41</span>
 std<span class="token operator">::</span><span class="token function">fill_n</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">back_inserter</span><span class="token punctuation">(</span>IntVec<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//IntVec中新增了10个值为22的元素</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
 值得注意的是，fill_n中第一个参数不能是Iter，因为在插入元素之后，Iter这个迭代器就失效了，需要重新更新。</li>
<li>可以使用copy函数来对数组这种自身没有拷贝构造函数的容器来进行拷贝操作：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> Array1<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
 <span class="token keyword">int</span> Array2<span class="token punctuation">[</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Array1<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>Array1<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
 <span class="token keyword">auto</span> Ret <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">copy</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">begin</span><span class="token punctuation">(</span>Array1<span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span><span class="token function">end</span><span class="token punctuation">(</span>Array1<span class="token punctuation">)</span><span class="token punctuation">,</span> Array2<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//Ret指向拷贝到Array2的尾元素之后的位置</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
 不过如果把第三个参数改成<code>std::begin(Array2)</code>，会发生错误，因为该模板函数的第三个参数类型不能和前两个相同。</li>
<li>替换范围内某个指定值的函数replace如下：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> IntVec <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
 std<span class="token operator">::</span><span class="token function">replace</span><span class="token punctuation">(</span>IntVec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> IntVec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//把所有值为2的元素替换为20</span>
 std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> IntVec2<span class="token punctuation">;</span>
 <span class="token comment" spellcheck="true">//把所有值为4的元素替换为40，并且把替换后的序列拷贝到新序列里，原序列不受影响</span>
 std<span class="token operator">::</span><span class="token function">replace_copy</span><span class="token punctuation">(</span>IntVec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> IntVec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">back_inserter</span><span class="token punctuation">(</span>IntVec2<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
 其中replace_copy函数相当于replace和copy函数的结合，该算法接受额外第三个迭代器参数，表示新序列的起始位置。</li>
<li><p>可以用如下的程序把容器中的元素进行排序并消除重复元素：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> IntVec <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
std<span class="token operator">::</span><span class="token function">sort</span><span class="token punctuation">(</span>IntVec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> IntVec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//排序后的元素为：1 2 2 2 3 4 4</span>
<span class="token keyword">auto</span> EndIterator <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">unique</span><span class="token punctuation">(</span>IntVec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> IntVec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//消除重复元素后可能为：1 2 3 4 3 4 4</span>
IntVec<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>EndIterator<span class="token punctuation">,</span> IntVec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//删除重复元素后为：1 2 3 4</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中，sort使用了内置类型的小于操作来排序， unique会消除<strong>相邻的</strong>重复项。不过unique毕竟只是泛型算法，它无法真正删除容器内的元素，只是把那些相邻的重复元素覆盖了，使得不重复元素出现在序列开始部分，并返回指向最后一个不相邻重复元素的迭代器，此迭代器之后的元素依然存在，只是值不确定罢了，并没有被删除。</p>
<p>想要真正删除那些重复的元素，只能调用容器的erase成员函数。</p>
</li>
</ol>
<p><font size="5" color="orange">定制操作</font></p>
<hr>
<ol>
<li><p>现在有一堆字符串，如果把我们想把它们先按长度排序，长度相同的再按字典序排序，则可以设计如下程序：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">bool</span> <span class="token function">isShorter</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span>vS1<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span>vS2<span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
     <span class="token keyword">return</span> vS1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> vS2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>

 std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> StrVec <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token string">"the"</span><span class="token punctuation">,</span><span class="token string">"my"</span><span class="token punctuation">,</span><span class="token string">"that"</span><span class="token punctuation">,</span><span class="token string">"god"</span><span class="token punctuation">,</span><span class="token string">"good"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
 std<span class="token operator">::</span><span class="token function">sort</span><span class="token punctuation">(</span>StrVec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> StrVec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//排序后：god good my that the</span>
 std<span class="token operator">::</span><span class="token function">stable_sort</span><span class="token punctuation">(</span>StrVec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> StrVec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> isShorter<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//排序后：my god the good that</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 需要先按字典序排序，再按长度进行稳定排序。其中stable_sort函数就是稳定排序，它会维持相等元素原有的顺序。</p>
</li>
<li>上面stable_sort函数还包含有第三个参数，它是一个谓词。谓词是一个可调用的表达式，其返回结果是一个能用作条件的值。stable_sort使用第三个参数指定的谓词来进行排序，而不再是使用string类的&lt;运算符。</li>
<li>上面的程序可以得到按长度排序再按字典序排序后的一堆字符串，现在我们想要输出一个长度大于给定值3的所有字符串。当然首先需要在这个已经排好序的一堆字符串里，找到第一个长度大于3的字符串。除了手动循环遍历以外，我们还可以直接调用标准库算法find_if，它前两个参数是查找的范围，第三个参数是一个谓词：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">auto</span> It <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">find_if</span><span class="token punctuation">(</span>StrVec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> StrVec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> isLonger3<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
 但是如果是大于1、大于2、大于4…呢？不可能再去重载多个函数吧？把给定值写入函数isLonger中？<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">bool</span> <span class="token function">isLonger</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span>vS<span class="token punctuation">,</span> std<span class="token operator">::</span>string<span class="token operator">::</span>size_type vN<span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
     <span class="token keyword">return</span> vS<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> vN<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
 但是find_if的第三个参数是一个谓词，只能传可调用对象的地址进去，那么那个参数vN怎么传进去？find_if只支持3个参数。<br> 其中一个解决方案就是使用lambda表达式。</li>
<li>一个lambda表达式表示一个可调用的代码单元。我们可以将其理解为一个未命名的内联函数。但与函数不同，lambda可能定义在函数内部。lambda表达式形式如下：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token punctuation">[</span>capture list<span class="token punctuation">]</span><span class="token punctuation">(</span>parameter list<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token keyword">return</span> type <span class="token punctuation">{</span>function body<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
 其中，capture list（捕获列表）是一个lambda所在函数中定义的局部变量的列表（通常为空），与普通函数不同的是，lambda的返回类型是尾置返回。而且其中的参数列表和返回类型是可选的（可以省略）。<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">auto</span> f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token number">41</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//省略参数列表和返回类型的lambda</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
 lambda的调用方式与普通函数的调用方式相同，都是使用调用运算符：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li>一个lambda通过将局部变量包含在其捕获列表中来指出将会使用这些变量。这样我们就可以通过lambda的捕获列表来获取那个给定长度值，从而解决之前3中提到的问题：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> SpecifiedLength <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
 <span class="token keyword">auto</span> It <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">find_if</span><span class="token punctuation">(</span>StrVec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> StrVec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>SpecifiedLength<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> vS<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> vS<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> SpecifiedLength<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
 在lambda的捕获列表中捕获局部变量SpecifiedLength ，这样一来当给定长度发生变化时，只需要更改该局部变量的值即可，无需去重载多个谓词函数。</li>
<li>现在我们只是找到了第一个长度大于给定值的字符串，剩下的就是在这堆有序字符串里打印所有长度大于给定值的字符串了。我们可以使用for_each函数来遍历，它的前两个参数是遍历范围，第三个参数可调用对象，它会对遍历的每个元素调用此可调用对象：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span><span class="token function">for_each</span><span class="token punctuation">(</span>It<span class="token punctuation">,</span> StrVec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> vS<span class="token punctuation">)</span> <span class="token punctuation">{</span>std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> vS <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//可调用对象是一个lambda</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li>当定义一个lambda时，编译器生成一个与lambda对应的新的未命名的类类型。默认情况下，从lambda生成的类都包含对应该lambda所捕获变量的数据成员。类似任何普通类的数据成员，lambda的数据成员也在lambda对象创建时被初始化。不过值得注意的是，与参数不同，被捕获的变量的值是在lambda被创建时拷贝，而不是调用时拷贝：<pre class="line-numbers language-cpp"><code class="language-cpp"> size_t Value <span class="token operator">=</span> <span class="token number">41</span><span class="token punctuation">;</span>
 <span class="token keyword">auto</span> f <span class="token operator">=</span> <span class="token punctuation">[</span>Value<span class="token punctuation">]</span> <span class="token punctuation">{</span><span class="token keyword">return</span> Value<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//创建lambda时，局部变量Value被拷贝到捕获列表中</span>
 Value <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
 <span class="token keyword">auto</span> Value1 <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//Value1的值为41而不是0，因为f保存了我们创建它时Value的拷贝</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>上面的捕获列表是值捕获，如果想要引用捕获，需要在Value前加上引用符号&amp;：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">auto</span> f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span>Value<span class="token punctuation">]</span> <span class="token punctuation">{</span><span class="token keyword">return</span> Value<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li>采用引用方式捕获一个变量，必须确保被引用的对象在lambda执行的时候是存在的。lambda捕获的都是局部变量，这些变量在函数结束后就不复存在了。如果lambda可能在函数结束后执行，捕获的引用所指向的局部变量已经消失。</li>
<li>隐式捕获：除了在捕获列表中显式列出我们希望使用的局部变量之外，还可以让编译器根据lambda体中的代码来推断我们要使用哪些变量。为了指示编译器推断捕获列表，应在捕获列表中写一个&amp;或=。&amp;告诉编译器采用引用捕获方式，=是值捕获方式：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> It <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">find_if</span><span class="token punctuation">(</span>StrVec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> StrVec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> vS<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> vS<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> SpecifiedLength<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//隐式值捕获</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li>如果我们希望对一部分变量采用值捕获，对其他变量采用引用捕获，可以混合使用隐式捕获和显式捕获：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">char</span> C <span class="token operator">=</span> <span class="token string">' '</span><span class="token punctuation">;</span>
std<span class="token operator">::</span>ostream <span class="token operator">&amp;</span>OS <span class="token operator">=</span> std<span class="token operator">::</span>cout<span class="token punctuation">;</span>
std<span class="token operator">::</span><span class="token function">for_each</span><span class="token punctuation">(</span>It<span class="token punctuation">,</span> StrVec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>OS<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> vS<span class="token punctuation">)</span> <span class="token punctuation">{</span>OS <span class="token operator">&lt;&lt;</span> vS <span class="token operator">&lt;&lt;</span> C<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
当我们混合使用隐式捕获和显式捕获时，捕获列表中的第一个元素必须是&amp;或=，它指明默认隐式捕获方式是引用捕获还是值捕获。而且如果隐式捕获是引用方式，则显式捕获命名必须是值捕获，不能在捕获变量名字前面用&amp;，反之亦然（道理很简单，显式捕获和隐式捕获如果采用相同的引用或值捕获，会发生冲突）。</li>
<li>在lambda函数体内部不能修改值捕获变量的值：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">41</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> f <span class="token operator">=</span> <span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">++</span>i<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//错误：i必须是可修改的左值</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
如果确实想要修改值捕获变量的值，可以在参数列表后使用关键字mutable：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">41</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> f <span class="token operator">=</span> <span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">mutable</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">++</span>i<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//需要加上参数列表</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
注意需要加上参数列表，至少也要有个空的()。</li>
<li>对于那种只在一两个地方使用的简单操作，lambda表达式是最有用的。如果我们需要在很多地方使用相同的操作，通常应该定义一个函数，而不是多次编写相同的lambda表达式。类似的，如果一个操作需要很多语句才能完成，通常使用函数更好。</li>
<li>如果lambda的捕获列表为空，通常可以用函数来代替它。</li>
<li><p>除了使用lambda来解决上面无法传递给定值的问题以外，还可以使用标准库的bind函数来解决。可以把bind函数看作一个通用的函数适配器，它接受一个可调用对象，生成一个新的可调用对象来“适应”原对象的参数列表。说得更通俗点，bind其实就是把一个函数包装成另一个可能参数更少、可能参数顺序发生变化的另一个函数。bind函数定义在functional头文件中。</p>
<p>调用bind函数的形式为：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> newCallable <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span>callable<span class="token punctuation">,</span> arg_list<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>其中callable是一个可调用对象，arg_list是一个逗号分隔的参数列表，对应给定的callable的参数，返回一个新的可调用对象newCallable。也就是当我们调用newCallable 时，newCallable 会调用callable，并依次传递给它arg_list中的参数。</p>
<p>arg_list中的参数可能包含形如_n的名字，其中n是一个整数。这些参数是占位符，表示newCallable的参数，它们占据了传递给newCallable的参数的“位置”，_1为newCallable的第一个参数，_2为newCallable的第二个参数…。这些占位符都定义在命名空间std::placeholders中。</p>
<p>例如下面的函数：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">minus</span><span class="token punctuation">(</span><span class="token keyword">int</span> v1<span class="token punctuation">,</span> <span class="token keyword">int</span> v2<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> v1 <span class="token operator">-</span> v2<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果我们想要调用减数和被减数的位置，则可以用bind来生成一个新的可调用对象：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">minus</span><span class="token punctuation">(</span><span class="token keyword">int</span> v1<span class="token punctuation">,</span> <span class="token keyword">int</span> v2<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> v1 <span class="token operator">-</span> v2<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword">auto</span> minusReverse <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span>minus<span class="token punctuation">,</span> std<span class="token operator">::</span>placeholders<span class="token operator">::</span>_2<span class="token punctuation">,</span> std<span class="token operator">::</span>placeholders<span class="token operator">::</span>_1<span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">minusReverse</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//输出1而非-1</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li>既然isLonger函数因为需要两个参数而无法作为find_if函数的第三个参数，那么我们现在可以用bind函数把isLonger函数包装成只需要一个参数的新函数：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> SpecifiedLength <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> f <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span>isLonger<span class="token punctuation">,</span> std<span class="token operator">::</span>placeholders<span class="token operator">::</span>_1<span class="token punctuation">,</span> SpecifiedLength<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> It <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">find_if</span><span class="token punctuation">(</span>StrVec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> StrVec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
find_if函数为范围内的每个元素调用f，并且把该元素传递当做参数传递给f，f是只有一个参数的新函数，在调用f时，f会去调用isLonger函数，并且把这个元素（这里其实就是字符串）传递给isLonger函数的第一个参数，把变量SpecifiedLength传递给isLonger函数的第二个参数。</li>
<li><p>一般情况下，我们传递给bind的实参都是值传递，如果想要引用传递而避免拷贝 ，可以使用标准库ref函数：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>ostream<span class="token operator">&amp;</span> <span class="token function">print</span><span class="token punctuation">(</span>std<span class="token operator">::</span>ostream<span class="token operator">&amp;</span> vOS<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> vS<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> vOS <span class="token operator">&lt;&lt;</span> vS<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">auto</span> f1 <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span>print<span class="token punctuation">,</span> std<span class="token operator">::</span><span class="token function">ref</span><span class="token punctuation">(</span>std<span class="token operator">::</span>cout<span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span>placeholders<span class="token operator">::</span>_1<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//ostream无法拷贝，所以要用ref</span>
std<span class="token operator">::</span><span class="token function">for_each</span><span class="token punctuation">(</span>It<span class="token punctuation">,</span> StrVec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> f1<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>函数ref返回一个对象，包含给定的引用，此对象是可以拷贝的，相当于生成了一个给定对象的引用形式。标准库中还有一个cref函数，生成一个保存const引用的类。与bind一样，函数ref和cref也定义在头文件functional中。</p>
</li>
</ol>
<p><font size="5" color="orange">再探迭代器</font></p>
<hr>
<ol>
<li>上一章接触过插入迭代器。插入迭代器有三种类型，差异在于元素插入的位置：<ul>
<li>back_inserter：创建一个使用push_back的迭代器。</li>
<li>front_inserter：创建一个使用push_front的迭代器。</li>
<li>inserter：创建一个使用insert的迭代器。此函数接受第二个参数，是一个迭代器，表示元素被插入到这个迭代器之前的位置。<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> List <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">20</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token operator">*</span>std<span class="token operator">::</span><span class="token function">back_inserter</span><span class="token punctuation">(</span>List<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//容器中含有元素：20 30</span>
<span class="token operator">*</span>std<span class="token operator">::</span><span class="token function">front_inserter</span><span class="token punctuation">(</span>List<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//容器中含有元素：10 20 30</span>
<span class="token operator">*</span>std<span class="token operator">::</span><span class="token function">inserter</span><span class="token punctuation">(</span>List<span class="token punctuation">,</span> List<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//容器中含有元素0 10 20 30</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> List <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
std<span class="token operator">::</span>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> List2<span class="token punctuation">,</span> List3<span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//拷贝完成后，List2中含有元素：4 3 2 1</span>
std<span class="token operator">::</span><span class="token function">copy</span><span class="token punctuation">(</span>List<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> List<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span><span class="token function">front_inserter</span><span class="token punctuation">(</span>List2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//拷贝完成后，List3中含有元素：1 2 3 4</span>
std<span class="token operator">::</span><span class="token function">copy</span><span class="token punctuation">(</span>List<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> List<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span><span class="token function">inserter</span><span class="token punctuation">(</span>List3<span class="token punctuation">,</span> List3<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
</li>
<li>虽然iostream不是类型，但是标准库定义了可以用于这些IO类型对象的迭代器。istream iterator读取输入流，ostream_iterator向一个输出流写入数据。通过使用迭代器，我们可以用泛型算法从流对象读取数据以及向其写入数据。</li>
<li>创建一个istream_iterator时，我们可以把它绑定到一个流。如果不绑定任何流（即默认初始化），则创建的是istream_iterator类型的尾后迭代器。<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>istream_iterator<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">IIterator</span><span class="token punctuation">(</span>std<span class="token operator">::</span>cin<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//迭代器可以从cin读取int</span>
 std<span class="token operator">::</span>istream_iterator<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> EndIterator<span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">//尾后迭代器</span>
 std<span class="token operator">::</span>ifstream <span class="token function">Fin</span><span class="token punctuation">(</span><span class="token string">"test.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 std<span class="token operator">::</span>istream_iterator<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> <span class="token function">SIterator</span><span class="token punctuation">(</span>Fin<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//迭代器可以从文件test.txt读取string</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
 我们可以用流迭代器来从IO流读取数据：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> IVec<span class="token punctuation">;</span>
 std<span class="token operator">::</span>istream_iterator<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">IIter</span><span class="token punctuation">(</span>std<span class="token operator">::</span>cin<span class="token punctuation">)</span><span class="token punctuation">;</span> 
 std<span class="token operator">::</span>istream_iterator<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> EndIter<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//尾后迭代器</span>
 <span class="token keyword">while</span> <span class="token punctuation">(</span>IIter <span class="token operator">!=</span> EndIter<span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
     IVec<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token operator">*</span>IIter<span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token operator">++</span>IIter<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
 对于一个流迭代器，一旦其关联的流遇到文件尾或遇到IO错误，迭代器的值就与尾后迭代器EndIter相等。<br> 其实可以直接把程序重写为如下形式，这体现了流迭代器更有用的地方：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>istream_iterator<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">IIter</span><span class="token punctuation">(</span>std<span class="token operator">::</span>cin<span class="token punctuation">)</span><span class="token punctuation">,</span> EndIter<span class="token punctuation">;</span> 
 std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">IVec</span><span class="token punctuation">(</span>IIter<span class="token punctuation">,</span> EndIter<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//从迭代器范围构造IVec</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li>当创建ostream_iterator时，我们可以提供可选的第二参数，它是一个字符串，在输出每个元素后都会打印此字符串。此字符串必须是一个C风格字符串。而且和istream_itertor不同的是，必须将ostream_iterator绑定到一个IO流，不存在表示尾后迭代器的空ostream_iterator。<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> Vec<span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
 std<span class="token operator">::</span>ostream_iterator<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">OIter</span><span class="token punctuation">(</span>std<span class="token operator">::</span>cout<span class="token punctuation">,</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> e <span class="token operator">:</span> Vec<span class="token punctuation">)</span>
     <span class="token operator">*</span>OIter<span class="token operator">++</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//赋值语句实际上将元素写到cout，每输出一个元素都输出字符串“,”</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
 其实向ostream_iterator赋值时，可以忽略解引用和递增运算符，所以上面的循环可以写成下面这样：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> e <span class="token operator">:</span> Vec<span class="token punctuation">)</span>
     OIter <span class="token operator">=</span> e<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
 但是为了方便阅读代码还是第一种形式比较好，不过正因为这种特性，我们可以用copy函数来简化该循环：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> Vec<span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
 std<span class="token operator">::</span>ostream_iterator<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">OIter</span><span class="token punctuation">(</span>std<span class="token operator">::</span>cout<span class="token punctuation">,</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 std<span class="token operator">::</span><span class="token function">copy</span><span class="token punctuation">(</span>Vec<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Vec<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> OIter<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li>当然流迭代器也可以处理那些定义了输入运算符（&gt;&gt;）和输出运算符（&lt;&lt;）的类。</li>
<li>除了forward_list之外，其他容器都支持反向迭代器。获取反向迭代器的函数只是比正向迭代器在名字上多了一个r，比如c.begin()和c.rbegin()。其中c.rbegin()指向容器中的最后一个元素，而c.rend()是首前迭代器，指向容器中第一个元素之前的位置（原理类似c.end()尾后迭代器）。<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> IVec<span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
 std<span class="token operator">::</span><span class="token function">sort</span><span class="token punctuation">(</span>IVec<span class="token punctuation">.</span><span class="token function">rbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> IVec<span class="token punctuation">.</span><span class="token function">rend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//按逆序排序，将最小的元素放在IVec的末尾</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li>因为不可能在一个流中反向移动，所以流迭代器不支持递减运算，所以流迭代器也不存在方向迭代器。</li>
<li>如果我们有一个字符串“Tomorrow will be nice”，希望打印出它的最后一个单词，我们可以先用反向迭代器逆序找到最后一个空格出现的地方，然后打印它到字符串末尾的部分：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>string Str <span class="token operator">=</span> <span class="token string">"Tomorrow will be nice"</span><span class="token punctuation">;</span>
 <span class="token keyword">auto</span> Start <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">find</span><span class="token punctuation">(</span>Str<span class="token punctuation">.</span><span class="token function">crbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Str<span class="token punctuation">.</span><span class="token function">crend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span><span class="token function">string</span><span class="token punctuation">(</span>Str<span class="token punctuation">.</span><span class="token function">crbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Start<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//输出ecin</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
 注意由于是反向迭代器，进行的是递减运算而不是递增运算，所以构造字符串时需要从迭代器Str.crbegin()到迭代器Start的方向来构造字符串。但是最后得到的是最后一个单词nice的逆序结果。原因在于我们构造字符串时用的是反向迭代器，我们可以用反向迭代器的base成员函数来将其转换为正向迭代器：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span><span class="token function">string</span><span class="token punctuation">(</span>Start<span class="token punctuation">.</span><span class="token function">base</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>Str<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//输出nice</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
</ol>
<p><font size="5" color="orange">泛型算法结构</font></p>
<hr>
<ol>
<li>接受谓词参数的泛型算法都有附加的_if前缀：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span><span class="token function">find</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//在输入范围中查找val第一次出现的位置</span>
 std<span class="token operator">::</span><span class="token function">find_if</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> pred<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//在输入范围中查找第一个令pred为真的元素</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li>写到额外目的空间的泛型算法都会在名字后面附加一个_copy：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span><span class="token function">reverse</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//反转输入范围中元素的顺序</span>
 std<span class="token operator">::</span><span class="token function">reverse_copy</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> dest<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//将输入范围中的元素按逆序拷贝到dest</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li>还有一些算法同时提供_copy和_if。它们接受一个目的位置迭代器和一个谓词：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> IVec<span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> IVec2<span class="token punctuation">,</span> IVec3<span class="token punctuation">;</span>
 <span class="token comment" spellcheck="true">//将IVec中的奇数元素拷贝到IVec2</span>
 std<span class="token operator">::</span><span class="token function">copy_if</span><span class="token punctuation">(</span>IVec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> IVec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span><span class="token function">back_inserter</span><span class="token punctuation">(</span>IVec2<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> i <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token comment" spellcheck="true">//从IVec2中删除奇数元素，返回的迭代器指向删除范围的后一个位置（泛型算法并不真正删除容器里的元素）</span>
 <span class="token keyword">auto</span> Iter <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">remove_if</span><span class="token punctuation">(</span>IVec2<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> IVec2<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> i <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token comment" spellcheck="true">//将IVec中的偶数元素拷贝到IVec3(先删除奇数，再把剩余的偶数拷贝到IVec3)，IVec不变</span>
 std<span class="token operator">::</span><span class="token function">remove_copy_if</span><span class="token punctuation">(</span>IVec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> IVec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span><span class="token function">back_inserter</span><span class="token punctuation">(</span>IVec3<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> i <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
 在调用remove_if这个泛型算法时，并不真正删除容器中的元素，需要真正删除元素，还需要调用容器的erase成员函数。</li>
</ol>
<p><font size="5" color="orange">特定容器算法</font></p>
<hr>
<ol>
<li>对于list和forward_list这些链表容器，应该优先使用成员函数版本的算法而不是对应的泛型算法，因为泛型版本的算法需要交换输入序列中的元素，而成员函数版本的算法只需要改变元素之间的链接即可，性能要好得多。</li>
<li>链表的成员函数包括remove、remove_if、reverse、sort、merge、unique、splice等等。其中merge表示把一个链表合并进另一个链表中：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> List1<span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">7</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
 std<span class="token operator">::</span>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> List2<span class="token punctuation">{</span> <span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">8</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
 List1<span class="token punctuation">.</span><span class="token function">merge</span><span class="token punctuation">(</span>List2<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//合并后List1为：1 2 3 4 5 6 7 8，List2为空</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
 合并前List1和List2都必须是有序的。合并后List2变为空，List1中元素合并排序时默认使用的是&lt;运算符。它还有第二个版本，可以接受自定义的比较操作：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> List1<span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">7</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
 std<span class="token operator">::</span>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> List2<span class="token punctuation">{</span> <span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">8</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
 List1<span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 List2<span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 List1<span class="token punctuation">.</span><span class="token function">merge</span><span class="token punctuation">(</span>List2<span class="token punctuation">,</span> compare<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//合并后List1为：8 7 6 5 4 3 2 1，List2为空</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>splice可以把一个链表中的元素移动另一个链表中的指定位置之前：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> List1<span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">7</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
 std<span class="token operator">::</span>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> List2<span class="token punctuation">{</span> <span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">8</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
 <span class="token comment" spellcheck="true">//将List2中的所有元素移动到List1第一个元素之前</span>
 List1<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>List1<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> List2<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//List1为：2 4 6 8 1 3 5 7，List2为空</span>
 <span class="token comment" spellcheck="true">//将List1中的第一个元素移动到List2中</span>
 List2<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>List2<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> List1<span class="token punctuation">,</span> List1<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">++</span>List1<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//List1为：4 6 8 1 3 5 7，List2为：2</span>
 <span class="token comment" spellcheck="true">//将List1中第二个元素移动到List2中</span>
 List2<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>List2<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> List1<span class="token punctuation">,</span> <span class="token operator">++</span>List1<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//List1为：4 8 1 3 5 7，List2为：6 2</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
 forward_list的对应版本是splice_after。</li>
<li>链表的迭代器不支持加减算术运算（++和–可以）：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">auto</span> it <span class="token operator">=</span> List1<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//错误</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
 根本原因在于链表的存储空间不是连续的，不支持随机访问。<br>&nbsp; </li>
</ol>
<hr>
<p>参考文献：《C++Primer第五版》</p>
]]></content>
      
        <categories>
            
            <category> C++ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C++Primer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++Primer第九章 顺序容器]]></title>
      <url>/2018/03/01/C++Primer%E7%AC%AC%E4%B9%9D%E7%AB%A0%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/</url>
      <content type="html"><![CDATA[<p><font size="5" color="orange">顺序容器概述</font></p>
<hr>
<ol>
<li>标准库中的顺序容器类型如下：</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">vector</td>
<td>可变大小数组。支持随机访问。在尾部之外的位置插入或删除元素可能很慢</td>
</tr>
<tr>
<td style="text-align:center">deque</td>
<td>双端队列。支持快速随机访问。在头尾位置插入/删除速度很快</td>
</tr>
<tr>
<td style="text-align:center">list</td>
<td>双向链表。支持双向顺序访问。在list中任何位置插入/删除都很快</td>
</tr>
<tr>
<td style="text-align:center">forward_list</td>
<td>单向链表。只支持单向顺序访问。在链表中任何位置插入/删除都很快</td>
</tr>
<tr>
<td style="text-align:center">array</td>
<td>固定大小数组。支持快速随机访问。不能添加或删除元素</td>
</tr>
<tr>
<td style="text-align:center">string</td>
<td>与vector相似的容器，但专门用于保存字符。随机访问块，在尾部插入/删除速度很快</td>
</tr>
</tbody>
</table>
<ol>
<li>链表容器（list和forward_list）相比于vector、deque、array这些容器，其额外内存开销会很大。</li>
<li>与内置数组相比，array是一种更安全、更容易使用的数组类型。</li>
<li>forward_list的设计目标是达到与最好的手写的单向链表数据结构相当的性能。因此，forward_list没有size操作，因为保存和计算其大小就会比手写链表多出额外的开销。</li>
<li>新标准的容器比旧版本快得多。新标准容器的性能几乎肯定与最精心优化过的同类数据结构一样好（通常会更好）。现代C++程序应该使用标准库容器，而不是更原始的数据结构，如内置数组。</li>
<li>如果程序只有在读取输入时才需要在容器中间位置插入元素，随后需要随机访问元素，则：<ul>
<li>首先确定是否真的需要在容器中间位置添加元素。当处理输入数据时，通常可以很容易地向vector追加数据，然后再调用标准库的sort函数来重排容器中的元素，从而避免在中间位置添加元素（这条准则需要容器是有序的）。</li>
<li>如果必须在中间位置插入元素，考虑在输入阶段使用list，一旦输入完成，将list中的内容拷贝到一个vector中。</li>
</ul>
</li>
</ol>
<p><font size="5" color="orange">容器库概述</font></p>
<hr>
<ol>
<li>标准库容器均为模板类。</li>
<li>容器的公共操作中（Container是某种容器），<code>Container::size_type</code>表示容器可能的最大容量大小，是无符号整数类型，<code>Container::difference_type</code>用于保存两个迭代器之间的距离，是有符号整数类型，<code>Container::value_type</code>是容器里的元素类型，<code>Container::reference</code>是容器里元素的左值类型，相当于<code>Container::value_type&amp;</code>。</li>
<li>forward_list迭代器不支持递减运算符，毕竟是单向链表嘛。</li>
<li>容器的begin和end成员函数其实是有重载版本的。非常量对象调用这两个函数时，会返回iterator；而常量对象调用这两个函数时，会返回const_iterator。</li>
<li>当不需要写访问时，迭代器应使用cbegin和cend函数（这两函数无论调用它们的是不是常量对象，都总是会返回const_iterator）。</li>
<li>用一个容器拷贝给另一个容器时，容器类型必须相同。而用迭代器范围来拷贝时要求低一点，不需要容器类型完全相同，只要容器里的元素可以进行隐式转换即可。<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">></span> CVec <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token string">"This"</span><span class="token punctuation">,</span><span class="token string">"There"</span><span class="token punctuation">,</span><span class="token string">"Here"</span> <span class="token punctuation">,</span><span class="token string">"Good"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
 std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> <span class="token function">SVec2</span><span class="token punctuation">(</span>Vec1<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//错误：直接拷贝时，容器类型必须匹配</span>
 <span class="token comment" spellcheck="true">//使用范围迭代器拷贝时，元素能隐式转换即可，不需要容器类型完全相同</span>
 std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> <span class="token function">SVec3</span><span class="token punctuation">(</span>CVec<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> CVec<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//正确</span>
 std<span class="token operator">::</span>forward_list<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> <span class="token function">SList</span><span class="token punctuation">(</span>CVec<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> CVec<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>当定义一个array时，除了指定元素类型，还要指定容器大小，使用时也是一样。毕竟array是一个固定大小的数组嘛：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>array<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token operator">></span> Datas<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//类型为：保存10个int的数组</span>
 std<span class="token operator">::</span>array<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token operator">></span><span class="token operator">::</span>size_type i<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li>虽然我们不能对内置数组类型进行拷贝操作，但是array是可以的：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> Data1<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
 <span class="token keyword">decltype</span><span class="token punctuation">(</span>Data1<span class="token punctuation">)</span> Data2 <span class="token operator">=</span> Data1<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//错误：内置数组不支持拷贝或赋值</span>
 std<span class="token operator">::</span>array<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token operator">></span> Data3 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
 std<span class="token operator">::</span>array<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token operator">></span> Data4 <span class="token operator">=</span> Data3<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//正确，只要数组类型匹配即合法</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>顺序容器（array除外）还定义了一个名为assign的成员函数，它用其参数所指定的元素的拷贝去替换左边容器中的所有元素（不要求容器相同，只要元素类型可以隐式转换即可）。assign操作不适用于array和关联容器。因为旧元素会被替换，所以传递给assign的迭代器不能指向调用assign的容器。</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">seq.assign(b, e)</td>
<td>将seq中的元素替换为迭代器b和e所表示的范围内的元素。迭代器b和e不能指向seq中的元素</td>
</tr>
<tr>
<td style="text-align:center">seq.assign(il)</td>
<td>将seq中的元素替换为初始化列表il中的元素</td>
</tr>
<tr>
<td style="text-align:center">seq.assign(n, t)</td>
<td>将seq中的元素替换为n个值为t的元素</td>
</tr>
</tbody>
</table>
<pre><code>```cpp
std::vector&lt;const char*&gt; Vec = { &quot;This&quot;,&quot;There&quot;,&quot;Here&quot; ,&quot;Good&quot; };
std::list&lt;std::string&gt; List;
List.assign(Vec.cbegin(), Vec.cend());
```
</code></pre><ol>
<li>赋值相关运算符会导致指向左边容器内部的迭代器、引用和指针失效。不过<code>swap(Container1, Container2)</code>或者<code>Container1.swap(Container2)</code>操作不会。而且在容器之间swap操作通常比拷贝元素要快。</li>
<li>除array外，交换两个容器内容的swap操作保证会很快，因为元素本身并未交换，只是交换了两个容器的内部数据结构，它不对任何元素进行拷贝、删除或插入操作，因此可以保证在常数时间内完成。与其他容器不同，swap两个array会真正交换它们的元素，因此其所需的时间与array中元素的数目成正比。</li>
<li>除string外，指向容器的迭代器、引用和指针在swap操作之后都不会失效，它们仍指向swap操作之前所指向的那些元素。但是在swap操作之后，这些元素已经属于不同的容器了。例如，假定iter在swap之前指向svec[3]的元素，那么在swap操作之后它指向svec2[3]的元素。与其他容器不同，对一个string调用swap操作会导致迭代器、引用和指针失效。</li>
<li>在新标准中，容器提供成员函数版本的swap，也提供非成员版本的swap。统一使用非成员版本的swap是一个好习惯。</li>
<li>只有当内部的元素类型也定义了相应的比较运算符时，我们才可以使用关系运算符来比较两个容器。</li>
</ol>
<p><font size="5" color="orange">顺序容器操作</font></p>
<hr>
<ol>
<li>向容器中添加元素的insert函数的几个版本：</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">c.insert(p, t)</td>
<td>在迭代器p指向的元素<strong>之前</strong>插入一个值为t的元素。返回指向新添加元素的迭代器</td>
</tr>
<tr>
<td style="text-align:center">c.insert(p, n, t)</td>
<td>在迭代器p指向的元素之前插入n个值为t的元素</td>
</tr>
<tr>
<td style="text-align:center">c.insert(p, b, e)</td>
<td>将迭代器b和e指定的范围内的元素插入到迭代器p所指向的元素之前。b和e不能指向c中的元素</td>
</tr>
<tr>
<td style="text-align:center">c.insert(p, il)</td>
<td>将花括号包围的元素值列表il插入到迭代器p指向的元素之前</td>
</tr>
</tbody>
</table>
<ol>
<li>向一个vector、string或deque插入元素会使所有指向容器的迭代器、引用和指针失效。</li>
<li>向一个vector或string添加元素可能引起整个对象存储空间的重新分配。重新分配一个对象的存储空间需要分配新的内存，并将元素从旧的空间移动到新的空间中。</li>
<li>vector、deque、list和string都支持insert成员，但是forward_list有点不同，它提供了自己特殊版本的insert成员（后文详述）。</li>
<li>由于迭代器有可能指向尾后迭代器（容器中不存在的元素的位置），所以是在迭代器之前的位置插入元素。</li>
<li>将元素插入到连续容器vector、deque、string中的任何位置都是合法的，但这样做可能很耗时。</li>
<li>新标准引入了三个新成员：emplace_front、emplace和emplace_back，这些操作构造而不是拷贝元素。这些操作分别对应push_front、insert和push_back，允许我们将元素放在容器头部、一个指定位置之前或容器尾部。调用一个emplace成员函数时，是将参数传递给元素类型的构造函数。emplace成员使用这些参数在容器管理的内存空间中直接构造元素。<strong>其实emplace相当于比push或insert多了一个隐式转换</strong>。</li>
<li>顺序容器的front和back成员函数返回的是元素的引用，begin和end成员函数返回的是迭代器。</li>
<li>使用容器的at成员函数来代替下标运算符[]，可以安全地随机访问容器中的元素。因为下标运算符在下标越界时函数行为未定义，但是at成员函数在索引越界时会抛出out_of_range异常。</li>
<li><code>c.erase(p)</code>和<code>c.erase(b, e)</code>操作是顺序容器的删除操作，前者删除迭代器p指向的元素，后者删除迭代器b和e所指定范围内的元素。都返回删除元素的下一个位置的迭代器。</li>
<li>删除deque中除首位之外的任何元素都会使所有迭代器、引用和指针失效。vector或string中删除点之后的迭代器、引用和指针都会失效。</li>
<li><p>由于forward_list是单向链表，无法获取链表中某个结点的前驱结点，导致无法在某个元素之前进行插入、删除等等操作，所以forward_list并未定义insert、emplace和earse等操作，而是定义了名为insert_after、emplace_after和erase_after的操作。在执行插入、删除等操作时，需要首先获取到前驱结点，再调用这些函数来完成相应工作。除此之外，forward_list还定义了名为before_begin的成员函数来获取首前迭代器（即链表首元素之前的位置，用于在链表首元素之前添加删除元素）。</p>
<p>如下程序可以删除存储在forward_list中的所有奇数，其中PrevIter用于存储用于遍历的当前迭代器的前驱迭代器。通过这个前驱迭代器来删除forward_list中的元素。</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>forward_list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> IList<span class="token punctuation">{</span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> PrevIter <span class="token operator">=</span> IList<span class="token punctuation">.</span><span class="token function">cbefore_begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> CurrIter <span class="token operator">=</span> <span class="token operator">++</span>PrevIter<span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>CurrIter <span class="token operator">!=</span> IList<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>CurrIter <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">)</span>
        CurrIter <span class="token operator">=</span> IList<span class="token punctuation">.</span><span class="token function">erase_after</span><span class="token punctuation">(</span>PrevIter<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">{</span>
        PrevIter <span class="token operator">=</span> CurrIter<span class="token punctuation">;</span>
        <span class="token operator">++</span>CurrIter<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>可以用顺序容器的<code>c.resize(n)</code>或<code>c.resize(n, t)</code>成员函数来改变容器大小。前者更改容器大小后，多出的元素被丢弃，新添加的元素进行值初始化；而后者新添加的元素被初始化为t。当然，resize操作不适用于array。</li>
<li>值得注意的是，resize操作只改变容器里的元素数目，并不改变容器的容量。而且使用resize后，指针、迭代器或引用都有可能失效。</li>
<li><p>总结一下，哪些情况下，会使容器的迭代器、指针和引用等失效：</p>
<ul>
<li>向容器添加元素后：<ul>
<li>对于vector和string。且存储空间被重新分配，则指向容器的迭代器、指针和引用都会失效。如果存储空间未重新分配，指向插入位置之后的元素的迭代器等会失效，之前的依然有效。</li>
<li>对于deque，插入到除首尾位置之外的任何位置都会导致迭代器等失效。如果在首尾位置添加元素，只会使迭代器失效，指针和引用依然有效。</li>
<li>对于list和forward_list，添加元素后迭代器、指针和引用等总是有效的。</li>
</ul>
</li>
<li>从容器删除一个元素后：<ul>
<li>对于vector和string，指向被删元素之后元素的迭代器、引用和指针失效，之前的依然有效。</li>
<li>对于deque，在除首尾位置之外的任何位置删除元素都会导致迭代器等失效。如果删除的是尾元素，则尾后迭代器会失效，但是其他迭代器、指针、引用等依然有效；如果删除的是首元素，迭代器等也依然有效。</li>
<li>对于list和forward_list，删除元素之后，除了指向被删除元素的其他迭代器等依然有效。</li>
</ul>
</li>
</ul>
<p>可以看出，其实添加和删除情况都差不多，主要是看添加删除元素后，迭代器所指向的地址是否还是原来的地址。在涉及到向容器添加或删除元素时，一定要注意之前的迭代器是否还指向正确的元素，尤其是在循环中。</p>
</li>
<li>不要保存end返回的迭代器。当我们添加/删除vector或string的元素后，或在deque中首元素之外的任何位置添加/删除元素后，原来end返回的迭代器总是会失效。所以，在循环中必须返回调用end成员函数，而不能在循环之前保存end返回的迭代器，当做容器的尾后迭代器来使用。比如如下程序就是错误的：<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> Vec<span class="token punctuation">{</span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> Iter <span class="token operator">=</span> Vec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> EndIter <span class="token operator">=</span> Vec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>Iter <span class="token operator">!=</span> EndIter<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//错误，插入或删除元素后EndIter就失效了</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>Iter <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        Iter <span class="token operator">=</span> Vec<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>Iter<span class="token punctuation">,</span> <span class="token operator">*</span>Iter<span class="token punctuation">)</span><span class="token punctuation">;</span>
        Iter <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">{</span>
        Iter <span class="token operator">=</span> Vec<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>Iter<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
不应该在循环之前把尾后迭代器保存下来，循环条件应该写成下面这样：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">while</span> <span class="token punctuation">(</span>Iter <span class="token operator">!=</span> Vec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//每次调用返回当前最新的尾后迭代器</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
</ol>
<p><font size="5" color="orange">vector对象是如何增长的</font></p>
<hr>
<ol>
<li>诸如vector和string，如果容器没有足够的空间容纳新的元素，而不得不获取新的内存空间时，vector和string的实现通常会分配比新的空间需求更大的内存空间。容器预留这些空间作为备用，可用来保存更多的新元素。这样，就不需要每次添加新元素都重新分配容器的内存空间了。虽然vector在每次重新分配内存空间时都需要移动所有元素，但使用此策略后，其扩张操作通常比list和deque还要快。</li>
<li>容器大小的管理操作函数如下表：</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">c.shrink_to_fit()</td>
<td>将capacity()减少为与size()相同大小</td>
</tr>
<tr>
<td style="text-align:center">c.capacity()</td>
<td>不重新分配内存空间的话，容器c可以保存多少元素</td>
</tr>
<tr>
<td style="text-align:center">c.reserve(n)</td>
<td>分配至少能容纳n个元素的内存空间</td>
</tr>
</tbody>
</table>
<ol>
<li>reserve并不改变容器中元素的数量，它仅影响vector预先分配多大的内存空间。如果需求的n小于或等于当前容量，reserve什么也不做，而且容器不会退回多余的内存空间。这样，调用reserve永远也不会减少容器占用的内存空间。</li>
<li>如果确实需要容器退回不需要的内存空间，可以调用shrink_to_fit成员函数。但是，它只是一个请求，标准库并不保证一定会退还内存空间，需要更具具体的实现而定。</li>
</ol>
<p><font size="5" color="orange">额外的string操作</font></p>
<hr>
<ol>
<li>用字符串字面值赋给char类型的指针时，末尾会有一个空字符’\0’作为结尾标志，但以字符数组（非字符串变量值）赋给char型指针时，末尾没有这样一个空字符：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">char</span> <span class="token operator">*</span>cp <span class="token operator">=</span> <span class="token string">"This"</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//cp里保存的是：T、h、i、s、\0</span>
 <span class="token keyword">char</span> ca<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token string">'T'</span><span class="token punctuation">,</span><span class="token string">'h'</span><span class="token punctuation">,</span><span class="token string">'i'</span><span class="token punctuation">,</span><span class="token string">'s'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//ca里在s后面没有\0</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
 所以，可以使用cp去构造一个string对象，但是不能使用ca：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>string <span class="token function">s1</span><span class="token punctuation">(</span>cp<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//s1是：This</span>
 std<span class="token operator">::</span>string <span class="token function">s2</span><span class="token punctuation">(</span>ca<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//s2可能是："This烫烫烫烫坃\xe\x1烫烫飧f\xev"</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li>string的substr成员函数返回一个string，它是原始string的一部分的<strong>拷贝</strong>：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>string s <span class="token operator">=</span> <span class="token string">"This is ..."</span><span class="token punctuation">;</span>
 std<span class="token operator">::</span>string s1 <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// s1 = is...</span>
 std<span class="token operator">::</span>string s2 <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// s2 = is is ..</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li>除了如前面所述的顺序容器接受迭代器的insert和erase版本以外，string还额外提供了接受下标的版本：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>string s <span class="token operator">=</span> <span class="token string">"This is"</span><span class="token punctuation">;</span>
 s<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token string">"dog "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// s = This dog is</span>
 s<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// s = This dog is...</span>
 s<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//从序号为4的位置开始删除4个元素, s = This is... </span>
 s<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//从倒数第3个位置开始删除后面的所有元素，s = This is</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>string类还定义了两个额外的操作：append和replace。append用于在string末尾进行追加（插入）操作。而replace是把字符串中的某一段字符替换成另外的字符，相当于连续调用了erase和insert：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>string s <span class="token operator">=</span> <span class="token string">"This is"</span><span class="token punctuation">;</span>
 s<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">" a dog"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// s = This is a dog</span>
 s<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">"There"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//把从0号位置开始的4个元素替换为There，s = There is a dog</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li>string提供了6个不同的搜索函数（其中args时包含要查找的字符串，还可能包含要查找的起始位置，它默认为0）：</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">s.find(args)</td>
<td>查找s中args第一次出现的位置</td>
</tr>
<tr>
<td style="text-align:center">s.rfind(args)</td>
<td>查找s中args最后一次出现的位置</td>
</tr>
<tr>
<td style="text-align:center">s.find_first_of(args)</td>
<td>在s中查找args中任何一个字符第一次出现的位置</td>
</tr>
<tr>
<td style="text-align:center">s.find_last_of(args)</td>
<td>在s中查找args中任何一个字符最后一次出现的位置</td>
</tr>
<tr>
<td style="text-align:center">s.find_first_not_of(args)</td>
<td>在s中查找第一个不在args中的字符</td>
</tr>
<tr>
<td style="text-align:center">s.find_last_not_of(args)</td>
<td>在s中查找最后一个不在args中的字符</td>
</tr>
</tbody>
</table>
<ol>
<li>上面的6个搜索操作都返回string::size_type类型的值，该类型其实是一个unsigned类型，表示匹配发生位置的下标。如果搜索失败，会返回一个名为string::npos的static成员，它也是string::size_type类型。例如在一个字符串中搜索子串出现的所有位置：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>string s <span class="token operator">=</span> <span class="token string">"aaabbaa"</span><span class="token punctuation">;</span>
 std<span class="token operator">::</span>string<span class="token operator">::</span>size_type pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
 <span class="token comment" spellcheck="true">//输出为0 1 5 </span>
 <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pos <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">"aa"</span><span class="token punctuation">,</span> pos<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> std<span class="token operator">::</span>string<span class="token operator">::</span>npos<span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
     std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> pos <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
     <span class="token operator">++</span>pos<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//移动到下一个字符，在剩余的子串中查找</span>
 <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>由于string的搜索操作返回的是一个无符号类型，所以通常不要用一个带符号类型来保存这些函数的返回值。</li>
<li>string的compare成员函数还可以比较string对象和C风格字符串，通常返回正数、负数或0，分别表示大于、小于或等于：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>string s <span class="token operator">=</span> <span class="token string">"aab"</span><span class="token punctuation">;</span>
 std<span class="token operator">::</span>string s2 <span class="token operator">=</span> <span class="token string">"ab"</span><span class="token punctuation">;</span>
 std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> s<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//本机输出-1</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li>把数值类型转换成string可以用to_string(val)函数，任何数值类型都可以。而把string转换成数值类型需要用stoi(s)、stod(s)、stof(s)、stol(s)…等等函数，它们还有额外的参数可以指定转换的进制（具体参考C++Premier中文版P328）:<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">float</span> Value <span class="token operator">=</span> <span class="token number">123.4</span><span class="token punctuation">;</span>
 std<span class="token operator">::</span>string Str <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">to_string</span><span class="token punctuation">(</span>Value<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">float</span> Value1 <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">stof</span><span class="token punctuation">(</span>Str<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<p><font size="5" color="orange">容器适配器</font></p>
<hr>
<ol>
<li>本质上，一个适配器是一种机制，能使某种事物的行为看起来像另外一种事物一样。一个容器适配器接受一种已有的容器类型，使其行为看起来像另外一种不同的类型。例如stack、queue和priority_queue：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>deque<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> Deque<span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
 std<span class="token operator">::</span>stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> Stk<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//空栈</span>
 std<span class="token operator">::</span>stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">Stk1</span><span class="token punctuation">(</span>Deque<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//基于Deque创建的适配器：栈，会把Deque中的元素拷贝到Stk1</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> IntStack<span class="token punctuation">;</span>
 <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
     IntStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>IntStack<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
     <span class="token keyword">int</span> Value <span class="token operator">=</span> IntStack<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     IntStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//pop返回的是void类型</span>
 <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>默认情况下，stack和queue是基于双端队列deque实现的，而priority_queue是在vector上实现的。不过我们也可以自己指定在哪种容器上来实现这些适配器，只需要在定义时添加第二个模板参数即可：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> Stk2<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//基于vector创建的栈</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li>对于一个给定的适配器，可以使用哪些容器是有限制的。stack只要求push_back、pop_back和back操作，因此可以使用除array和forward_list之外的任何容器类型来构造stack。queue适配器要求back、push_back、front和push_front，因此它可以构造于list或deque之上，但不能基于vector构造。priority_queue除了front、push_back和pop_back操作之外还要求随机访问能力，因此它可以构造于vector或deque之上，但不能基于list构造。</li>
<li>priority_queue允许我们为队列中的元素建立优先级。新加入的元素会排在所有优先级比它低的已有元素之前。默认情况下，标准库在元素类型上使用&lt;运算符来确定相对优先级。<br>&nbsp; </li>
</ol>
<hr>
<p>参考文献：《C++Primer第五版》</p>
]]></content>
      
        <categories>
            
            <category> C++ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C++Primer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++Primer第八章 IO库]]></title>
      <url>/2018/01/22/C++Primer%E7%AC%AC%E5%85%AB%E7%AB%A0IO%E5%BA%93/</url>
      <content type="html"><![CDATA[<p><font size="5" color="orange">IO类</font><br><a id="more"></a></p>
<hr>
<ol>
<li>可以将IO理解为读写，而非输入输出。</li>
<li>我们不能拷贝或对IO对象赋值。因此，我们也不能将形参或返回类型设置为流类型。进行IO操作的函数通常以引用方式传递和返回流。读写一个IO对象会改变其状态，因此传递和返回的引用都不能是const的。即不能用const修饰IO流对象。</li>
<li><p>IO库定义了4个iostate类型（与机器无关的一种类型）的位模式：badbit、failbit、eofbit、goodbit。<br>其中badbit表示系统级错误，如不可恢复的读写错误。通常情况下，一旦badbit被置位，流就无法再使用了。<br>在发生可恢复错误后，failbit被置位，如期望读取数值却读出一个字符等错误。这种问题通常是可以修正的，流还可以继续使用。<br>如果达到文件结束位置，eofbit和failbit都会被置位。<br>goodbit的值为0，表示流未发生错误。<br>如果badbit、failbit、eofbit任意一个被置位，则检测流状态的条件会失败。</p>
<p> IO库条件状态（位模式）及相关查询函数如下表所示（其中strm是某一种IO类型，如istream）：</p>
</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">位模式及相关函数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">strm::iostate</td>
<td>iostate是一种机器相关的类型，提供了表达条件状态的完整功能。</td>
</tr>
<tr>
<td style="text-align:center">strm::badbit</td>
<td>表示流已奔溃</td>
</tr>
<tr>
<td style="text-align:center">strm::failbit</td>
<td>表示一个IO操作失败了</td>
</tr>
<tr>
<td style="text-align:center">strm::eofbit</td>
<td>表示流到达了文件结束位置</td>
</tr>
<tr>
<td style="text-align:center">strm::goodbit</td>
<td>表示流未处于错误状态</td>
</tr>
<tr>
<td style="text-align:center">s.eof()</td>
<td>若流s的eofbit置位，则返回true</td>
</tr>
<tr>
<td style="text-align:center">s.fail()</td>
<td>若流s的failbit或badbit置位，则返回true</td>
</tr>
<tr>
<td style="text-align:center">s.bad()</td>
<td>若流s的badbit置位，则返回true</td>
</tr>
<tr>
<td style="text-align:center">s.good()</td>
<td>若流s处于有效状态，则返回true</td>
</tr>
<tr>
<td style="text-align:center">s.clear()</td>
<td>将流s的所有条件状态位复位，将流的状态设置为有效。返回void。</td>
</tr>
<tr>
<td style="text-align:center">s.clear(flags)</td>
<td>根据给定的flags标志位，将流s中对应条件状态位复位。flags的类型为strm::iostate。返回void。</td>
</tr>
<tr>
<td style="text-align:center">s.setstate(flags)</td>
<td>将流s中的flags条件状态位置位。flags类型同上，返回void。</td>
</tr>
<tr>
<td style="text-align:center">s.rdstate()</td>
<td>返回流s的当前条件状态，返回值类型为strm::iostate。</td>
</tr>
</tbody>
</table>
<ol>
<li>每个输出流都管理一个缓冲区，用来保存程序读写的数据。例如，如果程序执行如下语句：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Please enter a value:"</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
 文本串可能立即打印出来，但也可能被操作系统保存在缓冲区中，随后再打印。而导致缓冲刷新的原因有很多：<ul>
<li>程序正常结束，即main函数的return被执行时，会刷新缓冲。</li>
<li>缓冲区满时，会刷新缓冲。</li>
<li>使用endl等操纵符，会显式刷新缓冲区。</li>
<li>用操纵符unitbuf设置流的内部状态，从而清空缓冲区。</li>
<li>因为cerr是默认设置unitbuf的，所以写到cerr的内容会立即刷新，会被立即打印出来</li>
<li>当读写被关联的流时，关联到的流的缓冲区会被刷新。例如，默认情况下，cin和cerr都关联到cout，所以读写cin或cerr都会导致cout的缓冲区被刷新。</li>
</ul>
</li>
<li>除了使用操纵符endl刷新缓冲区外，还可以使用flush和ends：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"hi!"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//换行后刷新缓冲区</span>
 std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"hi!"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>ends<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//输出空字符后刷新缓冲区</span>
 std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"hi!"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>flush<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//直接刷新缓冲区，不附加任何额外字符</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li>如果想在每次输出操作后都立即刷新缓冲区，可以使用unitbuf操纵符。它告诉流在接下来的每次写操作后都执行一次flush操作，直到使用nounitbuf重置流为止，才会恢复使用正常的系统管理的缓冲区刷新机制。<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>unitbuf<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//之后的所有输出操作都会立即刷新缓冲区</span>
 <span class="token comment" spellcheck="true">//任何输出操作都立即刷新，无缓冲</span>
 std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>nounitbuf<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//回到正常的缓冲方式</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li>如果程序异常终止，输出缓冲区是不会被刷新的。就有可能会导致程序崩溃后，输出的数据依然留在缓冲区中等待被打印。这对一些输出的调试代码可能会有影响，导致调试困难。应该尽量让调试输出的错误或者警告信息立即刷新缓冲区。</li>
<li>交互式系统通常应该关联输入流和输出流。这意味着在读操作之前，缓冲区都会被刷新一次，留在缓冲区中的内容都会被打印出来。</li>
</ol>
<p><font size="5" color="orange">文件输入输出</font></p>
<hr>
<ol>
<li>当一个fstream对象被销毁时，其成员函数close会自动被调用。</li>
<li>每个流都有一个关联的文件模式，用来支出如何使用文件。</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">文件模式</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">in</td>
<td>以读方式打开</td>
</tr>
<tr>
<td style="text-align:center">out</td>
<td>以写方式打开</td>
</tr>
<tr>
<td style="text-align:center">app</td>
<td>每次写操作前都定位到文件末尾</td>
</tr>
<tr>
<td style="text-align:center">ate</td>
<td>打开文件后立即定位到文件末尾</td>
</tr>
<tr>
<td style="text-align:center">trunc</td>
<td>截断文件，及文件内容会被清除</td>
</tr>
<tr>
<td style="text-align:center">binary</td>
<td>以二进制方式进行IO</td>
</tr>
</tbody>
</table>
<ol>
<li><p>与ifstream关联的文件默认以in模式打开；与ofstream关联的文件默认以out模式打开；与fstream关联的文件默认以in和out模式打开。</p>
<p>默认情况下，即使没有指定trunc，以out模式打开的文件也会被截断。为了保留以out模式打开的文件的内容，必须同时指定app模式（将数据追加写到文件末尾）或in模式（同时读写文件）。</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token comment" spellcheck="true">//下面三条语句中，文件的原有内容都会被丢弃</span>
 std<span class="token operator">::</span>ofstream <span class="token function">out</span><span class="token punctuation">(</span><span class="token string">"file1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//隐含以out模式打开文件并截断文件</span>
 std<span class="token operator">::</span>ofstream <span class="token function">out2</span><span class="token punctuation">(</span><span class="token string">"file1"</span><span class="token punctuation">,</span>std<span class="token operator">::</span>ofstream<span class="token operator">::</span>out<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//隐含地截断文件</span>
 std<span class="token operator">::</span>ofstream <span class="token function">out3</span><span class="token punctuation">(</span><span class="token string">"file1"</span><span class="token punctuation">,</span> std<span class="token operator">::</span>ofstream<span class="token operator">::</span>out <span class="token operator">|</span> std<span class="token operator">::</span>ofstream<span class="token operator">::</span>trunc<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token comment" spellcheck="true">//下面两条语句，打开文件后会保留文件原有内容</span>
 std<span class="token operator">::</span>ofstream <span class="token function">out4</span><span class="token punctuation">(</span><span class="token string">"file1"</span><span class="token punctuation">,</span> std<span class="token operator">::</span>ofstream<span class="token operator">::</span>app<span class="token punctuation">)</span><span class="token punctuation">;</span>
 std<span class="token operator">::</span>ofstream <span class="token function">out5</span><span class="token punctuation">(</span><span class="token string">"file1"</span><span class="token punctuation">,</span> std<span class="token operator">::</span>ofstream<span class="token operator">::</span>out <span class="token operator">|</span> std<span class="token operator">::</span>ofstream<span class="token operator">::</span>app<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<p><font size="5" color="orange">string流</font></p>
<hr>
<ol>
<li>stringstream特有的相关函数如下（其中sstream是istringstream、ostringstream、stringstream中的一种）：</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">sstream strm</td>
<td>strm是一个未绑定的stringstream对象</td>
</tr>
<tr>
<td style="text-align:center">sstream strm(s)</td>
<td>strm是一个sstream对象，保存string s的一个拷贝。其构造函数是explicit的。即不支持隐式类型转换。</td>
</tr>
<tr>
<td style="text-align:center">strm.str()</td>
<td>返回strm所保存的string的拷贝</td>
</tr>
<tr>
<td style="text-align:center">strm.str(s)</td>
<td>将string s拷贝到strm中，返回void</td>
</tr>
</tbody>
</table>
<ol>
<li><p>在Info.txt中有如下信息（姓名和电话号码）：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> lee <span class="token number">13281171818</span> <span class="token number">13381171810</span>
 liu <span class="token number">13531471012</span>
 ma  <span class="token number">15542171568</span> <span class="token number">13081151819</span> <span class="token number">13232273848</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p> 现在设计如下程序，可读出并保存文件中的人物的电话信息：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">struct</span> CPersonInfo
 <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
     std<span class="token operator">::</span>string m_Name<span class="token punctuation">;</span>
     std<span class="token operator">::</span>vector <span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> m_PhonesNumber<span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>

 <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
     std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>CPersonInfo<span class="token operator">></span> PersonsInfo<span class="token punctuation">;</span>
     std<span class="token operator">::</span>ifstream <span class="token function">Fin</span><span class="token punctuation">(</span><span class="token string">"Info.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     std<span class="token operator">::</span>string Line<span class="token punctuation">;</span>
     <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">getline</span><span class="token punctuation">(</span>Fin<span class="token punctuation">,</span> Line<span class="token punctuation">)</span><span class="token punctuation">)</span>
     <span class="token punctuation">{</span>
         CPersonInfo Info<span class="token punctuation">;</span>
         std<span class="token operator">::</span>istringstream <span class="token function">Sin</span><span class="token punctuation">(</span>Line<span class="token punctuation">)</span><span class="token punctuation">;</span>
         Sin <span class="token operator">>></span> Info<span class="token punctuation">.</span>m_Name<span class="token punctuation">;</span>
         std<span class="token operator">::</span>string Number<span class="token punctuation">;</span>
         <span class="token keyword">while</span> <span class="token punctuation">(</span>Sin <span class="token operator">>></span> Number<span class="token punctuation">)</span>
             Info<span class="token punctuation">.</span>m_PhonesNumber<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>Number<span class="token punctuation">)</span><span class="token punctuation">;</span>
         PersonsInfo<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>Info<span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
     Fin<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

     <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 其中，字符串Line中的数据被全部读出后，同样会触发“文件结束”信号，在Sin上的下一个读取操作会失败。</p>
</li>
<li>istringstream通常被用来作字符串的拆分、解析等等操作。</li>
<li><p><strong>当我们逐步构造输出，希望最后一起打印时，ostringstream是很有用的</strong>。例如，我们希望把上面代码PersonsInfo中存储的电话号码转换一下格式（把13281171818转换成132-8117-1818），然后把所有人的信息输出到窗口上：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">struct</span> CPersonInfo
 <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
     std<span class="token operator">::</span>string m_Name<span class="token punctuation">;</span>
     std<span class="token operator">::</span>vector <span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> m_PhonesNumber<span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>

 <span class="token keyword">void</span> <span class="token function">formatPhoneNumber</span><span class="token punctuation">(</span>std<span class="token operator">::</span>string <span class="token operator">&amp;</span>vioPhoneNumber<span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>vioPhoneNumber<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">11</span><span class="token punctuation">)</span>
     <span class="token punctuation">{</span>
         std<span class="token operator">::</span>cerr <span class="token operator">&lt;&lt;</span> <span class="token string">"Phone number is not valid!"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
         <span class="token keyword">return</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
     vioPhoneNumber<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>vioPhoneNumber<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'-'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     vioPhoneNumber<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>vioPhoneNumber<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token string">'-'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>

 <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
     std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>CPersonInfo<span class="token operator">></span> PersonsInfo<span class="token punctuation">;</span>
     std<span class="token operator">::</span>ifstream <span class="token function">Fin</span><span class="token punctuation">(</span><span class="token string">"Info.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     std<span class="token operator">::</span>string Line<span class="token punctuation">;</span>
     <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">getline</span><span class="token punctuation">(</span>Fin<span class="token punctuation">,</span> Line<span class="token punctuation">)</span><span class="token punctuation">)</span>
     <span class="token punctuation">{</span>
         CPersonInfo Info<span class="token punctuation">;</span>
         std<span class="token operator">::</span>istringstream <span class="token function">Sin</span><span class="token punctuation">(</span>Line<span class="token punctuation">)</span><span class="token punctuation">;</span>
         Sin <span class="token operator">>></span> Info<span class="token punctuation">.</span>m_Name<span class="token punctuation">;</span>
         std<span class="token operator">::</span>string Number<span class="token punctuation">;</span>
         <span class="token keyword">while</span> <span class="token punctuation">(</span>Sin <span class="token operator">>></span> Number<span class="token punctuation">)</span>
             Info<span class="token punctuation">.</span>m_PhonesNumber<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>Number<span class="token punctuation">)</span><span class="token punctuation">;</span>
         PersonsInfo<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>Info<span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
     Fin<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

     std<span class="token operator">::</span>ostringstream Sout<span class="token punctuation">;</span>
     <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>Info <span class="token operator">:</span> PersonsInfo<span class="token punctuation">)</span>
     <span class="token punctuation">{</span>
         Sout <span class="token operator">&lt;&lt;</span> Info<span class="token punctuation">.</span>m_Name<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token punctuation">;</span>
         <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>PhoneNumber <span class="token operator">:</span> Info<span class="token punctuation">.</span>m_PhonesNumber<span class="token punctuation">)</span>
         <span class="token punctuation">{</span>
             <span class="token function">formatPhoneNumber</span><span class="token punctuation">(</span>PhoneNumber<span class="token punctuation">)</span><span class="token punctuation">;</span>
             Sout <span class="token operator">&lt;&lt;</span> PhoneNumber <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
         <span class="token punctuation">}</span>
         Sout <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
     <span class="token punctuation">}</span>

     std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> Sout<span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

     <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>&nbsp; </p>
</li>
</ol>
<hr>
<p>参考文献：《C++Primer第五版》</p>
]]></content>
      
        <categories>
            
            <category> C++ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C++Primer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++Primer第七章 类]]></title>
      <url>/2018/01/21/C++Primer%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%B1%BB/</url>
      <content type="html"><![CDATA[<p><font size="5" color="orange">定义抽象数据类型</font><br><a id="more"></a></p>
<hr>
<ol>
<li>定义在类内部的函数是隐式的内联(inline)函数。调用内联函数是没有运行时开销的。</li>
<li>用对象obj调用其成员函数getName时：<pre class="line-numbers language-cpp"><code class="language-cpp"> CObj obj<span class="token punctuation">;</span>
 std<span class="token operator">::</span>string Name <span class="token operator">=</span> obj<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
 编译器会把obj对象的地址传递给getName函数的<strong>隐式形参this</strong>，可以等价地认为编译器将该调用重写成了如下形式：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token comment" spellcheck="true">//伪代码，用于说明成员函数调用的实际执行过程</span>
 std<span class="token operator">::</span>string Name <span class="token operator">=</span> CObj<span class="token operator">::</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li>this是一个常量指针，不允许改变this中保存的地址。</li>
<li>C++允许把const放在成员函数的形参列表之后，此时该const表示this是一个指向常量的指针，声明的函数也是常量成员函数。由于常量成员函数里的this是指向常量的指针，所以常量成员函数不能改变其对象的数据成员。</li>
<li>常量对象，以及常量对象的引用或指针都只能调用常量成员函数。</li>
<li>编译器分两步处理类：首先编译成员的声明，然后才轮到成员函数体（如果有的话）。因此，成员函数体可以随意使用类中的其他成员而无须在意这些成员出现的次序。</li>
<li>一般来说，如果非成员函数是类接口的组成部分，则这些函数的声明应该与类在同一个头文件内。</li>
<li>对如下函数：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span>std<span class="token operator">::</span>ostream <span class="token operator">&amp;</span>os<span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
     os <span class="token operator">&lt;&lt;</span> <span class="token string">"There is an ostream parameter."</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
 因为IO类属于不能被拷贝的类型，因此我们只能通过引用来传递它们。而且因为读写操作都会改变流的内容，所以都只是普通引用类型的参数，而非常量引用。</li>
<li>不同于其他成员函数，构造函数不能被声明成const的。当我们创建一个const对象时，直到构造函数完成初始化过程，对象才能真正取得其“常量”属性。因此，构造函数在const对象的构造过程中可以向其写值。</li>
<li>含有内置类型或符合类型成员的类应该在类的内部初始化这些成员，或者定义一个自己的默认构造函数。否则用户在创建类的对象时就可能得到未定义的值。<br>11.有的时候编译器不能为某些类合成默认的构造函数。例如，如果类中包含一个其他类类型的成员且这个成员的类型没有默认构造函数，那么编译器将无法初始化该成员。</li>
<li>我们可以使用类内初始值来初始化数据成员：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">CData</span>
<span class="token punctuation">{</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span> m_Data <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
如果类的内置变量没有类内初始值，且没有构造函数来初始化它，那么它的值有可能就会是未定义的（有的编译器可能不支持类内初始值）。</li>
<li>在C++11新标准中，如果我们需要默认的行为，可以通过在参数列表后面写上=default来要求编译器生成默认构造函数。和其他函数一样，如果=default在类的内部，则默认构造函数是内联的；如果它在类的外部，则默认情况下不是内联的。<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">CData</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">CData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span> m_Data <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>构造函数不应该轻易覆盖掉类内的初始值，除非新赋的值与原值不同。如果编译器不能使用类内初始值，则所有构造函数都应该显式地初始化每个内置类型的成员。</li>
<li>使用vector或者string的类能避免分配和释放内存带来的复杂性，比直接使用动态数组要好。</li>
</ol>
<p><font size="5" color="orange">访问控制与封装</font></p>
<hr>
<ol>
<li>类可以允许其他类或者函数访问它的非公有成员，方法是令其他类或者函数称成为它的友元。</li>
<li>友元不是类的成员也不受所在区域访问控制级别的约束。</li>
<li><p>一般来说，最好在类定义或结束前的位置中声明友元。</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">class</span> <span class="token class-name">CData</span>
 <span class="token punctuation">{</span>
     <span class="token keyword">friend</span> <span class="token keyword">void</span> <span class="token function">printData</span><span class="token punctuation">(</span><span class="token keyword">const</span> CData<span class="token operator">&amp;</span> vData<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
     <span class="token function">CData</span><span class="token punctuation">(</span><span class="token keyword">int</span> vData<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">m_Data</span><span class="token punctuation">(</span>vData<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">printData</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
 <span class="token keyword">private</span><span class="token operator">:</span>
     <span class="token keyword">int</span> m_Data <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>

 <span class="token keyword">void</span> <span class="token function">printData</span><span class="token punctuation">(</span><span class="token keyword">const</span> CData<span class="token operator">&amp;</span> vData<span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
     std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> vData<span class="token punctuation">.</span>m_Data <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<p><font size="5" color="orange">类的其他特性</font></p>
<hr>
<ol>
<li>如果我们已经定义了一个构造函数，则编译器不会自动生成默认构造函数。如果此时需要默认构造函数需要显式地把它声明出来（可以使用=default）。</li>
<li><p>一个可变数据成员（mutable）永远不会是const，即使它是const对象的成员。因此，一个const成员函数可以改变一个可变成员的值：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">class</span> <span class="token class-name">CData</span>
 <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
     <span class="token function">CData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
     <span class="token keyword">int</span> <span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
 <span class="token keyword">private</span><span class="token operator">:</span>
     <span class="token keyword">mutable</span> <span class="token keyword">int</span> m_Data <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>

 <span class="token keyword">int</span> CData<span class="token operator">::</span><span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
 <span class="token punctuation">{</span>
     <span class="token keyword">return</span> <span class="token operator">++</span>m_Data<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>当我们提供一个类内初始值时，必须以=或者花括号表示。</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">class</span> <span class="token class-name">CData</span>
 <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
     <span class="token function">CData</span><span class="token punctuation">(</span><span class="token keyword">int</span> vData<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">m_Data</span><span class="token punctuation">(</span>vData<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
 <span class="token keyword">private</span><span class="token operator">:</span>
     <span class="token keyword">int</span> m_Data <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>

 <span class="token keyword">class</span> <span class="token class-name">CDataSet</span>
 <span class="token punctuation">{</span>
 <span class="token keyword">private</span><span class="token operator">:</span>
     std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>CData<span class="token operator">></span> m_DataSet<span class="token punctuation">{</span> <span class="token function">CData</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>一个const成员函数如果以引用的形式返回*this，那么它的返回类型将是常量引用。</li>
<li>我们可以仅声明类而暂时不定义它：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">class</span> <span class="token class-name">CData</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
 这种声明有时被称作前向声明，它向程序中引入了名字CData并且指明CData是一种类类型。对于类型CData来说，在它声明之后定义之前，它都一直是一个不完全类型，也就是说，此时我们只知道CData是一个类类型，但是不清楚它到底包含哪些成员。</li>
<li>友元函数能定义在类的内部，这样的函数是隐式内联的。需要注意的是，友元关系不存在传递性，即朋友的朋友不一定是我的朋友，它不一定可以访问我。</li>
</ol>
<p><font size="5" color="orange">类的作用域</font></p>
<hr>
<ol>
<li><p>在类的外部定义成员函数时，一旦遇到类名，剩余的部分（包括参数列表、函数体等等）就都在类的作用域之类了。所以在参数列表以及函数体中可以直接使用类内的成员而无须通过作用域符显示声明其作用域，但是由于函数返回类型位于类名之前，所以函数返回类型中一旦用到类内的成员，需要显示声明其属于哪一个类：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">class</span> <span class="token class-name">CData</span>
 <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
     <span class="token function">CData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
     <span class="token function">CData</span><span class="token punctuation">(</span><span class="token keyword">int</span> vData<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">m_Data</span><span class="token punctuation">(</span>vData<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
 <span class="token keyword">private</span><span class="token operator">:</span>
     <span class="token keyword">int</span> m_Data <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>

 <span class="token keyword">class</span> <span class="token class-name">CDataSet</span>
 <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
     <span class="token keyword">using</span> DataSet <span class="token operator">=</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>CData<span class="token operator">></span><span class="token punctuation">;</span>
     <span class="token keyword">const</span> DataSet<span class="token operator">&amp;</span> <span class="token function">getDataSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
 <span class="token keyword">private</span><span class="token operator">:</span>
     DataSet m_DataSet<span class="token punctuation">{</span> <span class="token function">CData</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>

 <span class="token keyword">const</span> CDataSet<span class="token operator">::</span>DataSet<span class="token operator">&amp;</span> CDataSet<span class="token operator">::</span><span class="token function">getDataSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
 <span class="token punctuation">{</span>
     <span class="token keyword">return</span> m_DataSet<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 如果在类外定义getDataSet函数时，去掉DataSet&amp;前面的CDataSet::将无法通过编译，因为函数返回值类型在类名之前，处于类作用域之外。</p>
</li>
<li>编译器处理完类中的全部声明后才会处理成员函数的定义。</li>
</ol>
<p><font size="5" color="orange">构造函数再探</font></p>
<hr>
<ol>
<li>如果成员是const、引用或者属于某种未提供默认构造函数的类类型时，我们必须通过内类初始值或者构造函数初始化列表的方式来初始化这些成员，而不能再构造函数体内部通过赋值语句来初始化：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">class</span> <span class="token class-name">CData</span>
 <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
     <span class="token function">CData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
     <span class="token function">CData</span><span class="token punctuation">(</span><span class="token keyword">int</span> vData<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">m_Data</span><span class="token punctuation">(</span>vData<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">m_DataID2</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> 
     <span class="token punctuation">{</span> 
         m_DataID3 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//错误，不能在构造函数体内部为const成员赋值</span>
     <span class="token punctuation">}</span>
 <span class="token keyword">private</span><span class="token operator">:</span>
     <span class="token keyword">int</span> m_Data <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
     <span class="token keyword">const</span> <span class="token keyword">int</span> m_DataID <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
     <span class="token keyword">const</span> <span class="token keyword">int</span> m_DataID2<span class="token punctuation">;</span>
     <span class="token keyword">const</span> <span class="token keyword">int</span> m_DataID3<span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
 上面程序中，对成员m_DataID和m_DataID2的初始化都是合法的，但是对m_DataID3的赋值是不合法的 。</li>
<li>在很多类中，初始化和赋值的区别事关底层效率：前者直接初始化数据成员，后者先初始化再赋值。</li>
<li><p>成员的初始化顺序与它们在类定义中的出现顺序一致：第一个成员先被初始化，然后第二个…。而构造函数初始值列表中初始值的前后位置关系不会影响实际的初始化顺序。</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">class</span> <span class="token class-name">CData</span>
 <span class="token punctuation">{</span>
     <span class="token keyword">friend</span> <span class="token keyword">void</span> <span class="token function">printData</span><span class="token punctuation">(</span><span class="token keyword">const</span> CData<span class="token operator">&amp;</span> vData<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
     <span class="token function">CData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
     <span class="token comment" spellcheck="true">//m_DataID是未定义的，因为m_Data先定义，m_DataID2后定义</span>
     <span class="token function">CData</span><span class="token punctuation">(</span><span class="token keyword">int</span> vData<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">m_Data</span><span class="token punctuation">(</span>vData<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">m_DataID2</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">m_DataID</span><span class="token punctuation">(</span>m_DataID2<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">printData</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
 <span class="token keyword">private</span><span class="token operator">:</span>
     <span class="token keyword">int</span> m_Data <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
     <span class="token keyword">int</span> m_DataID <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
     <span class="token keyword">int</span> m_DataID2 <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>

 <span class="token keyword">void</span> <span class="token function">printData</span><span class="token punctuation">(</span><span class="token keyword">const</span> CData<span class="token operator">&amp;</span> vData<span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
     std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> vData<span class="token punctuation">.</span>m_DataID <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> vData<span class="token punctuation">.</span>m_DataID2 <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 所以，最好令构造函数初始值列表里的顺序与成员成名的顺序一致。而且如果可能的话，尽量避免使用一个成员去初始化另一个成员。</p>
</li>
<li>C++11允许定义所谓的委托构造函数。一个委托构造函数使用它所属类的其他构造函数执行它自己的初始化过程，或者说把它自己的一些（或者全部）职责委托给了其他构造函数。<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">class</span> <span class="token class-name">CData</span>
 <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
     <span class="token function">CData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
     <span class="token function">CData</span><span class="token punctuation">(</span><span class="token keyword">int</span> vData<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">CData</span><span class="token punctuation">(</span>vData<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//委托构造函数</span>
     <span class="token function">CData</span><span class="token punctuation">(</span><span class="token keyword">int</span> vData<span class="token punctuation">,</span> <span class="token keyword">int</span> vDataID<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">m_Data</span><span class="token punctuation">(</span>vData<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">m_DataID</span><span class="token punctuation">(</span>vDataID<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> 
 <span class="token keyword">private</span><span class="token operator">:</span>
     <span class="token keyword">int</span> m_Data <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
     <span class="token keyword">int</span> m_DataID <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
 值得注意的是，委托构造函数不能具有其他成员初始值设定项。如下面的委托构造函数是非法的：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token function">CData</span><span class="token punctuation">(</span><span class="token keyword">int</span> vData<span class="token punctuation">,</span> <span class="token keyword">int</span> vDataID<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">m_DataID</span><span class="token punctuation">(</span>vDataID<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">CData</span><span class="token punctuation">(</span>vData<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//非法，委托构造函数不能具有其他成员初始值设定项</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li>在实际中，如果定义了其他构造函数，那么最好也提供一个默认构造函数。</li>
<li><p>如下程序：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">class</span> <span class="token class-name">CData</span>
 <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
     <span class="token function">CData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
     <span class="token function">CData</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> vDataName<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">m_DataName</span><span class="token punctuation">(</span>vDataName<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
     <span class="token keyword">void</span> <span class="token function">printOtherName</span><span class="token punctuation">(</span><span class="token keyword">const</span> CData<span class="token operator">&amp;</span> vData<span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> vData<span class="token punctuation">.</span>m_DataName <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
     <span class="token keyword">int</span> m_Data <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
     std<span class="token operator">::</span>string m_DataName<span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>
 <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
     CData <span class="token function">Data</span><span class="token punctuation">(</span><span class="token string">"FirstData"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     std<span class="token operator">::</span>string str <span class="token operator">=</span> <span class="token string">"SecondData"</span><span class="token punctuation">;</span> 
     Data<span class="token punctuation">.</span><span class="token function">printOtherName</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//合法</span>
     Data<span class="token punctuation">.</span><span class="token function">printOtherName</span><span class="token punctuation">(</span><span class="token string">"ThirdData"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//非法</span>
     <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 在执行<code>Data.printOtherName(str);</code>函数时，编译器会把str隐式地转换为CData对象，但是编译器只会自动地执行一步类型转换，所以无法将C字符串ThirdData先转换为string对象，再转换为CData对象。</p>
<p> 值得注意的是，这种隐式转换仅在调用时只有一个实参的时候才有效。如下程序是非法的：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">class</span> <span class="token class-name">CData</span>
 <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
     <span class="token function">CData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
     <span class="token function">CData</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> vDataName<span class="token punctuation">,</span> <span class="token keyword">int</span> vData<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">m_DataName</span><span class="token punctuation">(</span>vDataName<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">m_Data</span><span class="token punctuation">(</span>vData<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
     <span class="token keyword">void</span> <span class="token function">printOtherName</span><span class="token punctuation">(</span><span class="token keyword">const</span> CData<span class="token operator">&amp;</span> vData<span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> vData<span class="token punctuation">.</span>m_DataName <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
     <span class="token keyword">int</span> m_Data <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
     std<span class="token operator">::</span>string m_DataName<span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>
 <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
     CData <span class="token function">Data</span><span class="token punctuation">(</span><span class="token string">"FirstData"</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     std<span class="token operator">::</span>string str <span class="token operator">=</span> <span class="token string">"SecondData"</span><span class="token punctuation">;</span> 
     Data<span class="token punctuation">.</span><span class="token function">printOtherName</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//非法，实参不止一个时，无法执行隐式转换   </span>
     <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 如果不想要构造函数执行这种隐式转换，可以为构造函数添加explicit关键字：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">class</span> <span class="token class-name">CData</span>
 <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
     <span class="token function">CData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
     <span class="token keyword">explicit</span> <span class="token function">CData</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> vDataName<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">m_DataName</span><span class="token punctuation">(</span>vDataName<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
     <span class="token keyword">void</span> <span class="token function">printOtherName</span><span class="token punctuation">(</span><span class="token keyword">const</span> CData<span class="token operator">&amp;</span> vData<span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> vData<span class="token punctuation">.</span>m_DataName <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
     <span class="token keyword">int</span> m_Data <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
     std<span class="token operator">::</span>string m_DataName<span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>
 <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
     CData <span class="token function">Data</span><span class="token punctuation">(</span><span class="token string">"FirstData"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     std<span class="token operator">::</span>string str <span class="token operator">=</span> <span class="token string">"SecondData"</span><span class="token punctuation">;</span> 
     Data<span class="token punctuation">.</span><span class="token function">printOtherName</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//非法，explicit构造函数不允许执行隐式转换</span>
     CData Data3 <span class="token operator">=</span> <span class="token string">"ThirdData"</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//非法，explicit构造函数不允许执行隐式转换</span>
     <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 甚至<code>CData Data3 = &quot;ThirdData&quot;;</code>这样的初始化都不可以，因为它需要先把字符串隐式转换为CData对象，再拷贝给Data3。</p>
<p> 还要注意的是，只能在内类声明构造函数时使用explicit关键字，不能在类外部定义构造函数时也加上explicit关键字。</p>
</li>
<li><p>尽管构造函数不能是const的，但是字面值常量类的构造函数可以是constexpr函数。事实上，一个字面值常量类必须至少提供一个constexpr构造函数。</p>
<p> constexpr构造函数通常都应该是空的。</p>
</li>
</ol>
<p><font size="5" color="orange">类的静态成员</font></p>
<hr>
<ol>
<li>类的静态成员存在于任何对象之外，对象中不包含任何与静态数据成员有关的数据。类似的，静态成员函数也不与任何对象绑定在一起，它们不包含this指针。所以，静态成员函数不能声明成const的，而且我们也不能在static函数体内使用this指针，这一限制既适用于this的显式使用，也对调用非静态成员的隐式使用有效（因为调用非静态成员函数需要隐式用到this）。</li>
<li>当在类的外部定义静态成员时，不能重复static关键字，它只能出现在类内部的声明语句中。</li>
<li>即使一个常量静态数据成员在类内部被初始化了，通常情况下也应该在类的外部定义一下该成员。</li>
<li>静态成员可以是不完全类型，而非静态数据成员必须是完全类型。如下程序<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">class</span> <span class="token class-name">CData</span>
 <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
     <span class="token comment" spellcheck="true">//...</span>
 <span class="token keyword">private</span><span class="token operator">:</span>
     <span class="token keyword">static</span> CData m_DataObj<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//正确，静态成员可以是不完全类型</span>
     CData <span class="token operator">*</span>m_pDataObj2<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//正确，指针成员可以是不完全类型</span>
     CData m_DataObj3<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//错误，非静态数据成员不可以是不完整类型</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>静态成员可以作为函数的默认实参，但是非静态成员不可以：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">class</span> <span class="token class-name">CData</span>
 <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
     <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> CData<span class="token operator">&amp;</span> vData <span class="token operator">=</span> m_DataObj<span class="token punctuation">)</span><span class="token punctuation">;</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
     <span class="token keyword">static</span> CData m_DataObj<span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>&nbsp; </p>
</li>
</ol>
<hr>
<p>参考文献：《C++Primer第五版》</p>
]]></content>
      
        <categories>
            
            <category> C++ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C++Primer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Blog迁移]]></title>
      <url>/2018/01/03/Blog%E8%BF%81%E7%A7%BB/</url>
      <content type="html"><![CDATA[<ol>
<li>安装git和nodejs。</li>
<li>在任意路径下安装hexo：<pre class="line-numbers language-c++"><code class="language-c++">npm install -g hexo
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li>在博客文件夹下，初始化hexo和安装依赖包：<pre class="line-numbers language-c++"><code class="language-c++">hexo init
npm install
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li>在新机器上生成SSH密钥：<pre class="line-numbers language-c++"><code class="language-c++">ssh-keygen -t rsa -C “你的邮箱地址”
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
会提示输入用户名密码等，连续按3个回车就行（即设置密码为空）</li>
<li>在C:\Users\Administrator.ssh路径下，打开id_rsa.pub文件，复制全文，在GitHub里Add SSH key，粘贴进去。</li>
<li>检查密钥是否设置成功：<pre class="line-numbers language-c++"><code class="language-c++">$ ssh -T git@github.com
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
如果是类似下面的反馈：<pre class="line-numbers language-c++"><code class="language-c++">The authenticity of host 'github.com (207.97.227.239)' can't be established.
RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.
Are you sure you want to continue connecting (yes/no)?
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
输入yes就好，然后类似得到反馈：<pre class="line-numbers language-c++"><code class="language-c++">Hi cnfeat! You've successfully authenticated, but GitHub does not provide shell access.
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
表明以及可以通过SSH链接到GitHub了。</li>
<li>接下来需要设置用户名和邮箱信息：<pre class="line-numbers language-c++"><code class="language-c++">$ git config --global user.name "cnfeat"//用户名
$ git config --global user.email  "cnfeat@gmail.com"//填写自己的邮箱
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li>将原来博客根目录下的.deploy_git、public、source、themes、_config.yml等文件夹或文件拷贝到新机器的博客根目录下。</li>
</ol>
<p>到此，博客就迁移成功了，可以在新机器上正常使用。</p>
]]></content>
      
        <categories>
            
            <category> 博客配置 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Blog </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++Primer第六章 函数]]></title>
      <url>/2017/12/20/C++Primer%E7%AC%AC%E5%85%AD%E7%AB%A0%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<p><font size="5" color="orange">函数基础</font><br><a id="more"></a></p>
<hr>
<ol>
<li>用void作形参是C语言风格。</li>
<li>局部静态变量会被默认初始化。</li>
<li>如果我们修改了项目中的一个源文件，那么只需要重新编译那个改动了的文件。大多数编译器提供了分离式编译每个文件的机制，这一过程通常会产生一个后缀名是.obj（Windows）或.o（UNIX）的文件，后缀名的含义是该文件包含对象代码（object code）。</li>
</ol>
<p><font size="5" color="orange">参数传递</font></p>
<hr>
<ol>
<li>在C++语言中，建议使用引用类型的形参替代指针。</li>
<li>和其他初始化过程一样，当用实参初始化形参时会忽略掉形参的顶层const。即对于函数<code>void fcn(const int i){}</code>，传入的形参既能是const int，也能是int。</li>
<li><p>因为不能拷贝数组，所以我们无法以值传递的方式使用数组参数。因为数组会被转换成指针，所以当我们为函数传递一个数组时，实际上传递的是指向数组首元素的指针。</p>
<p> 如果确实像传递数组作为参数怎么办呢？有以下几种方案：</p>
<ul>
<li>在数组末尾指定一个特殊标记表示数组结束。如C风格字符串在末尾会有一个空字符’\0’，则可以按照如下方式处理C风格字符数组：<pre class="line-numbers language-cpp"><code class="language-cpp">  <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>vCP<span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>vCP<span class="token punctuation">)</span>
          <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">*</span>vCP<span class="token punctuation">)</span>
              std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>vCP<span class="token operator">++</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>传递数组的首元素指针和尾后指针：<pre class="line-numbers language-cpp"><code class="language-cpp">  <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>vBeg<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>vEnd<span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
      <span class="token keyword">while</span> <span class="token punctuation">(</span>vBeg <span class="token operator">!=</span> vEnd<span class="token punctuation">)</span>
          std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>vBeg<span class="token operator">++</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>额外传递一个表示数组大小的参数：<pre class="line-numbers language-cpp"><code class="language-cpp">  <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>vCP<span class="token punctuation">,</span> <span class="token keyword">int</span> vSize<span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">!=</span> vSize<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
          std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> vCP<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>用数组的引用作为形参：<pre class="line-numbers language-cpp"><code class="language-cpp">  <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>vArr<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> Elem <span class="token operator">:</span> vArr<span class="token punctuation">)</span>
          std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> Elem<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
这种方式虽然可以直接传递数组，但是缺点也很明显：数组大小是固定的。在后面第十六章会介绍怎样让它可以作用与任意大小数组的方式。</li>
</ul>
</li>
<li><p>数组实际上是数组的数组，所以传递多维数组作为参数的形式如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span>vMatrix<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> vRowSize<span class="token punctuation">,</span> <span class="token keyword">int</span> vColSize<span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
     <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> vRowSize<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
     <span class="token punctuation">{</span>
         <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> vColSize<span class="token punctuation">;</span> <span class="token operator">++</span>k<span class="token punctuation">)</span>
             std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> vMatrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
         std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>

 <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
     <span class="token keyword">int</span> Arr<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span>
     <span class="token punctuation">{</span>
         <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span>
         <span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span>
         <span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span>
         <span class="token number">10</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token number">12</span>
     <span class="token punctuation">}</span><span class="token punctuation">;</span>
     <span class="token function">print</span><span class="token punctuation">(</span>Arr<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

     <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>有形参的main函数形式如下：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
 第二个形参argv是一个数组，它的元素是指向C风格字符串的指针；第一个形参argv表示数组中字符串的数量。<br> 因为第二个形参是数组，所以main函数也可以是如下形式：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
 其中argv指向char*。<br> 当实参传给main函数之后，argv的第一个元素指向程序的名字或者一个空字符串，接下来的元素依次传递命令行提供的实参。最后一个指针之后的元素值保证为0。以下面的命令行为例：<pre class="line-numbers language-cpp"><code class="language-cpp"> prog <span class="token operator">-</span>d <span class="token operator">-</span>o ofile data0
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
 命令行提供的实参传入main函数之后，形参argc应该等于5，argv应该包含如下C风格字符串：<pre class="line-numbers language-cpp"><code class="language-cpp"> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"prog"</span><span class="token punctuation">;</span>
 argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"-d"</span><span class="token punctuation">;</span>
 argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"-o"</span><span class="token punctuation">;</span>
 argv<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"ofile"</span><span class="token punctuation">;</span>
 argv<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"data0"</span><span class="token punctuation">;</span>
 argv<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
 当使用argv中的实参时，一定要记得可选的实参从argv[1]开始，argv[0]保存程序的名字，而非用户输入。</li>
<li><p>为了编写能处理不同数量实参的函数，C++11新标准提供了两种主要的方法：如果所有的实参类型相同，可以传递一个名为initializer_list的标准库类型；如果实参的类型不同，我们可以编写一种特殊的函数，也就是所谓的可变参数模板，这在第16章会有详细介绍。</p>
<p> initializer_list用于表示某种特定类型的值的数组，定义在同名的头文件中。和vector类似，它也是一种模板类型；和vector不一样的是，initializer_list对象中的元素永远是常量值，所以我们无法修改initializer_list对象中元素的值。实例代码如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">void</span> <span class="token function">Msg</span><span class="token punctuation">(</span>std<span class="token operator">::</span>initializer_list<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> vIL<span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
     <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span> <span class="token operator">&amp;</span>Elem <span class="token operator">:</span> vIL<span class="token punctuation">)</span>
         std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> Elem <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
     std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>

 <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
     <span class="token function">Msg</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token string">"function"</span><span class="token punctuation">,</span><span class="token string">"okay"</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 可以看到，如果想向initializer_list形参中传递一个值的序列，则必须把序列放在一对花括号内。而且因为initializer_list由begin和end成员，所以可以使用范围for循环访问其中的元素。</p>
</li>
</ol>
<p><font size="5" color="orange">返回类型和return语句</font></p>
<hr>
<ol>
<li>不要返回局部对象的引用或指针。因为函数终止意味着局部变量的引用或指针将指向不再有效的区域，值将是未定义的（不可预知的任意值）。</li>
<li>C++11新标准规定，函数可以返回花括号包围的值的列表：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> <span class="token function">getInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
     <span class="token keyword">return</span><span class="token punctuation">{</span> <span class="token string">"function"</span><span class="token punctuation">,</span><span class="token string">"okay"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>如果程序达到了main函数的结尾处而且没有return语句，编译器将隐式地插入一条返回0的return语句。</li>
<li><p>main函数返回0表示执行成功，返回其他值表示执行失败。其中非0值得具体含义视机器而定。</p>
<p> 为了让返回值与机器无关，cstdlib头文件定义了两个预处理变量：EXIT_FAILURE、EXIT_SUCCESS，分别表示失败和成功。</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">if</span> <span class="token punctuation">(</span>Success<span class="token punctuation">)</span>
     <span class="token keyword">return</span> EXIT_SUCCESS<span class="token punctuation">;</span>
 <span class="token keyword">else</span>
     <span class="token keyword">return</span> EXIT_FAILURE<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>如果我们想定义一个返回数组指针的函数，则数组的维度必须跟在函数名字之后。形式如下：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
 我们先从内向外理解：func(int i)说明func是一个函数，参数是整型，右边的*表示函数func的返回值是一个指针，然后从右至左理解：(*func(int i))的右边是[10]，表示(*func(int i))是一个大小为10的数组的名字，左边是int，说明数组中的元素是整型。所以func函数返回的是一个指向大小为10的数组的指针。</li>
<li>可以看出，上面的定义比较繁琐，可以使用类型别名来简化：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">using</span> ArrI <span class="token operator">=</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
 ArrI <span class="token operator">*</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
 注意ArrI只代表一个大小为10的数组，想要函数返回指向数组的指针，别忘了函数名前面的*。</li>
<li>C++11还提供了另一种简化定义返回数组指针的函数的方法：使用尾置返回类型。如下：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">auto</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
 表示函数接受一个int类型的实参，返回一个指针，该指针指向含有10个整数的数组。</li>
<li>当然，如果我们明确知道函数返回的是指向哪个数组的指针，那么我们可以直接使用decltype来指定函数返回类型：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> g_Odd<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">7</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
 <span class="token keyword">int</span> g_Even<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
 <span class="token keyword">decltype</span><span class="token punctuation">(</span>g_Odd<span class="token punctuation">)</span> <span class="token operator">*</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">(</span>i <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token operator">&amp;</span>g_Odd <span class="token operator">:</span> <span class="token operator">&amp;</span>g_Even<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
 由于decltype不会把数组名转换为对应的指针，所以decltype的结果仍然是个数组，所以必须在函数名前面加上一个*符号才能表示返回的是指针。</li>
</ol>
<p><font size="5" color="orange">函数重载</font></p>
<hr>
<ol>
<li>如果形参是某种类型的指针或引用，则通过区分其指向的是常量对象还是非常量对象可以实现函数重载，此时的const是底层的：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>CData <span class="token operator">&amp;</span>vData<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">const</span> CData <span class="token operator">&amp;</span>vData<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p>const_cast和重载：<br> 如下代码：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span><span class="token function">getShorterString</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span>vS1<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span>vS2<span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
     <span class="token keyword">return</span> vS1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> vS2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> vS1 <span class="token operator">:</span> vS2<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p> 可以对这个函数传入两个非常量的string对象，但是如果我们想得到的也是非常量的返回结果呢？这时我们可以重载一个函数：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>string <span class="token operator">&amp;</span><span class="token function">getShorterString</span><span class="token punctuation">(</span>std<span class="token operator">::</span>string <span class="token operator">&amp;</span>vS1<span class="token punctuation">,</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span>vS2<span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
     <span class="token keyword">auto</span> <span class="token operator">&amp;</span>r <span class="token operator">=</span> <span class="token function">getShorterString</span><span class="token punctuation">(</span><span class="token keyword">const_cast</span><span class="token operator">&lt;</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span><span class="token operator">></span><span class="token punctuation">(</span>vS1<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">const_cast</span><span class="token operator">&lt;</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span><span class="token operator">></span><span class="token punctuation">(</span>vS2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token keyword">return</span> <span class="token keyword">const_cast</span><span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">&amp;</span><span class="token operator">></span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 这个重载的函数首先将它的实参强制转换为对const的引用，然后调用了原先的const版本的getShortString函数，最后将返回值又强制转换回非常量的string&amp;。由于返回的字符串实际上是初始时是非常量的，所以这种转换是安全的。</p>
<p> 值得注意的是，auto后面一定要有引用符&amp;，否则就是新生成了一个局部变量，然后返回了这个局部变量的引用。</p>
</li>
<li>有多余一个函数可以匹配，但是每一个都不是明显的最佳选择，此时也将发生错误，称为二义性调用。</li>
</ol>
<p><font size="5" color="orange">特殊用途语言特性</font></p>
<hr>
<ol>
<li>调用函数一般比直接求等价表达式的值要慢一些，因为调用函数时会存在保存寄存器、拷贝实参等等操作。</li>
<li>内联函数可以避免函数调用的开销。因为将函数指定为内联函数，通常就是将它在每个调用点上“内联地”展开。形式如下：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">inline</span> <span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span><span class="token function">getShorterString</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span>vS1<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span>vS2<span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
     <span class="token keyword">return</span> vS1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> vS2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> vS1 <span class="token operator">:</span> vS2<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
 一般来说，内联机制用于优化规模较小、流程直接、频繁调用的函数。</li>
<li><p>constexpr函数是指能够用于常量表达式的函数。即下面这样的函数：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">new_sz</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token number">42</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
 <span class="token keyword">constexpr</span> <span class="token keyword">int</span> foo <span class="token operator">=</span> <span class="token function">new_sz</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p> 需要注意的是，要能作用于常量表达式才能算作真正的constexpr函数。编译器在执行上述初始化过程的时候，会把对constexpr函数的调用替换成其结果值。为了能在编译过程中随时展开，constexpr函数被隐式地指定为内联函数。</p>
<p> 定义它时需要遵循几项约定：函数的返回类型及所有形参的类型都得是字面值类型（即内置的基础类型），而且函数体中必须有且只有一条return语句：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">class</span> <span class="token class-name">CData</span>
 <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
     <span class="token keyword">int</span> m_Data <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>

 <span class="token keyword">constexpr</span> CData<span class="token operator">&amp;</span> <span class="token function">getData</span><span class="token punctuation">(</span><span class="token keyword">const</span> CData <span class="token operator">&amp;</span>vData<span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>vData<span class="token punctuation">.</span>m_Data<span class="token punctuation">)</span>      <span class="token comment" spellcheck="true">//流程控制语句不允许出现在constexpr函数中，因为可能出现多个return</span>
         <span class="token keyword">return</span> vData<span class="token punctuation">;</span>
     <span class="token keyword">else</span>
         <span class="token keyword">return</span> <span class="token keyword">new</span> CData<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//只能有一个return语句</span>
 <span class="token punctuation">}</span>

 <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
     <span class="token keyword">const</span> CData Data<span class="token punctuation">;</span>
     <span class="token keyword">constexpr</span> CData Data1 <span class="token operator">=</span> <span class="token function">getData</span><span class="token punctuation">(</span>Data<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//constexpr函数的参数和返回值都必须是字面值类型</span>

     <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 虽然下面的程序可以通过，但由于它并没有把constexpr函数用于常量表达式，所以不能说明getData函数就是一个真正的constexpr函数：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">class</span> <span class="token class-name">CData</span>
 <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
     <span class="token keyword">int</span> m_Data <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>

 <span class="token keyword">constexpr</span> CData<span class="token operator">&amp;</span> <span class="token function">getData</span><span class="token punctuation">(</span><span class="token keyword">const</span> CData <span class="token operator">&amp;</span>vData<span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
     <span class="token keyword">return</span> vData<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>

 <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
     <span class="token keyword">const</span> CData Data<span class="token punctuation">;</span>
     std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">getData</span><span class="token punctuation">(</span>Data<span class="token punctuation">)</span><span class="token punctuation">.</span>m_Data <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>

     <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 还有一点需要注意的是，constexpr函数不一定返回常量表达式。</p>
</li>
<li>通常将内联函数和constexpr函数定义在头文件中。</li>
<li><p>assert是一种预处理宏，它定义在cassert头文件中。因为宏处理名字由预处理器而非编译器管理，所以使用预处理名字时可以直接使用而无须提供using声明。</p>
<p> assert的行为依赖于一个名为NDEBUG的预处理变量的状态。如果定义了NDEBUG，则assert什么也不做。默认状态下没有定义NDEBUG，此时assert将执行运行时检查。我们可以使用#define语句定义NDEBUG，从而关闭调试状态。也可以通过编译器的命令行选项来做这件事。</p>
<p> 我们可以把assert当成调试程序的一种辅助手段，但是不能用它替代真正的运行时逻辑检查，<strong>也不能替代程序本身应该包含的错误检查</strong>。</p>
</li>
<li><p>除了用于assert外，我们也可以使用NDEBUG编写自己的条件调试代码。如下程序：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
 <span class="token macro property">#<span class="token directive keyword">ifndef</span> NDEBUG</span>
     std<span class="token operator">::</span>cerr <span class="token operator">&lt;&lt;</span> __FUNCTION__ <span class="token operator">&lt;&lt;</span> <span class="token string">" To do..."</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
 <span class="token macro property">#<span class="token directive keyword">endif</span></span>
 <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 如果NDEBUG未定义，将执行#ifndef和#endif之间的代码；如果定义了NDEBUG，这些代码将被忽略掉。<br> 在VS环境下，__FUNCTION__表示当前调试的函数的名字。编译器为每个函数都定义了<strong>FUNCTION</strong>，它是const char的一个静态数组，用于存放函数的名字。</p>
<p> 除此之外，C++编译器还定义了另外4个对程序调试很有用的名字：</p>
<ul>
<li>__FILE__：存放当前文件名的字符串字面值</li>
<li>__LINE__：存放当前行号的整型字面值</li>
<li>__TIME__：存放文件编译时间的字符串字面值</li>
<li>__DATE__：存放文件编译器日期的字符串字面值</li>
</ul>
</li>
</ol>
<p><font size="5" color="orange">函数匹配</font></p>
<hr>
<ol>
<li><p>函数匹配的基本思想是：实参类型与形参类型越接近，它们匹配得越好。具体匹配标准是：如果有且只有一个函数满足最佳匹配（类型最接近），则匹配成功。</p>
<p> 如下面两个重载函数：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p> 如果调用<code>f(41,3.14);</code>，对一个实参来说，f(int,int)是其最佳匹配函数，对第二个参数来说f(double,double)是其最佳匹配函数。因为杜宇不同的实参会有不同的最佳匹配函数，编译器无法从整体上判断孰优孰劣，所以会发出二义性调用的错误。</p>
</li>
<li>调用重载函数时，实参应尽量避免强制类型转换（const_cast除外）。否则，说明我们设计的形参集合不合理。</li>
<li>对于下列重载函数调用也是有二义性的：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">3.14</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//错误，二义性调用</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
 字面值3.14的类型是double，它既能转换成long也能转换成float，所以具有二义性调用。</li>
</ol>
<p><font size="5" color="orange">函数指针</font></p>
<hr>
<ol>
<li><p>函数的类型由它的返回类型和形参共同决定，与函数名无关。对于下面的函数：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">bool</span> <span class="token function">compareLength</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p> 想要声明指向该函数的指针，只需要用指针替换函数名即可：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">bool</span> <span class="token punctuation">(</span><span class="token operator">*</span>pf<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p> pf指向一个函数，该函数具有两个const string引用类型的参数，返回值是bool。</p>
<p> 注意，*pf两端一定要加上括号，否则pf是一个返回值为bool指针的函数，而不是函数指针。</p>
<p> 对于pf的赋值，下面两种方式都可以：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> pf <span class="token operator">=</span> compareLength<span class="token punctuation">;</span>
 pf <span class="token operator">=</span> <span class="token operator">&amp;</span>compareLength<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//取地址符是可选的</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p> 对于pf的调用，下面两种方式都可以：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token punctuation">(</span><span class="token operator">*</span>pf<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">,</span> <span class="token string">"goodbye"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token function">pf</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">,</span> <span class="token string">"goodbye"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//解引用符是可选的</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li>把函数作为参数时，会自动把函数转换成指向函数的指针：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span>vS1<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span>vS2<span class="token punctuation">,</span> <span class="token keyword">bool</span> <span class="token function">compareLength</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
 其中第三个参数是函数类型，会被自动转换为函数指针。等价于下面的形式：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span>vS1<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span>vS2<span class="token punctuation">,</span> <span class="token keyword">bool</span><span class="token punctuation">(</span><span class="token operator">*</span>pf<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>可以使用别名来简化函数指针类型：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">typedef</span> <span class="token keyword">bool</span><span class="token punctuation">(</span><span class="token operator">*</span>FuncP<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">typedef</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>compareLength<span class="token punctuation">)</span> <span class="token operator">*</span>FuncP2<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//等价的类型</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p> 需要注意的是，decltype返回函数类型，它不会将函数类型自动转换成指针类型。所以需要在前面加上*才能得到指针。</p>
<p> 此时，print函数可以是如下形式：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span>vS1<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span>vS2<span class="token punctuation">,</span> FuncP<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span>vS1<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span>vS2<span class="token punctuation">,</span> FuncP2<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//等价的声明</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p>将函数类型作为形参时，会自动转换为函数指针，但将函数类型最为返回值类型时，这种转换不会发生。如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">using</span> F <span class="token operator">=</span> <span class="token keyword">bool</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//F是函数类型，不是指针</span>
 <span class="token keyword">using</span> PF <span class="token operator">=</span> <span class="token keyword">bool</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//PF是函数指针</span>

 F <span class="token function">f1</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//错误：F是函数类型，f1不能返回一个函数</span>
 F <span class="token operator">*</span><span class="token function">f2</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//正确：显式指定返回类型是指向函数的指针</span>
 PF <span class="token function">f3</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//正确：PF是函数指针，f3返回指向函数的指针</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>当然，我们也可以使用尾置返回类型的方式来声明返回函数指针的函数：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">auto</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li>而且，如果我们明确知道返回的函数是哪一个，就可以使用decltype来简化函数指针的形式：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">bool</span> <span class="token function">smallerString</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">bool</span> <span class="token function">largerString</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">decltype</span><span class="token punctuation">(</span>smallerString<span class="token punctuation">)</span> <span class="token operator">*</span><span class="token function">getFunc</span><span class="token punctuation">(</span><span class="token keyword">int</span> vFuncType<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
 牢记decltype不会把函数类型转换为函数指针，想要表示指针必须得加上*。<br>&nbsp; </li>
</ol>
<hr>
<p>参考文献：《C++Primer第五版》</p>
]]></content>
      
        <categories>
            
            <category> C++ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C++Primer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++Primer第五章 语句]]></title>
      <url>/2017/12/16/C++Primer%E7%AC%AC%E4%BA%94%E7%AB%A0%E8%AF%AD%E5%8F%A5/</url>
      <content type="html"><![CDATA[<p><font size="5" color="orange">简单语句</font></p>
<hr>
<ol>
<li>使用空语句时应该加上注释，从而令读这段代码的人知道该语句是有意省略的。</li>
</ol>
<p><font size="5" color="orange">条件语句</font></p>
<hr>
<ol>
<li>对于switch-case语句，case后的值必须是整型常量表达式。如下：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">char</span> ch<span class="token punctuation">;</span>
 std<span class="token operator">::</span>cin <span class="token operator">>></span> ch<span class="token punctuation">;</span>
 <span class="token keyword">int</span> ival <span class="token operator">=</span> <span class="token number">41</span><span class="token punctuation">;</span>
 <span class="token keyword">switch</span> <span class="token punctuation">(</span>ch<span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
 <span class="token keyword">case</span> <span class="token number">3.14</span><span class="token operator">:</span>         <span class="token comment" spellcheck="true">//错误，3.14不是整数</span>
 <span class="token keyword">case</span> ival<span class="token operator">:</span>         <span class="token comment" spellcheck="true">//错误，ival不是常量</span>
 <span class="token comment" spellcheck="true">//...</span>
 <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>即使不在default标签下做任何工作，定义一个default标签也是有用的。其目的在于告诉程序的读者，我们已经考虑到了默认的情况，只是目前什么也没做。</li>
<li><p>尽量不要在switch-case中定义新的局部变量。如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">bool</span> b <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
 <span class="token keyword">switch</span> <span class="token punctuation">(</span>b<span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
 <span class="token keyword">case</span> <span class="token boolean">true</span><span class="token operator">:</span>
     <span class="token keyword">int</span> jval <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//错误，不能绕过一个显示初始化的变量</span>
     std<span class="token operator">::</span>string str<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//错误，不能绕过一个隐式初始化的变量</span>
     <span class="token keyword">break</span><span class="token punctuation">;</span>
 <span class="token keyword">case</span> <span class="token boolean">false</span><span class="token operator">:</span>
     jval <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>  
     <span class="token keyword">break</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 上面的代码编译会报错，但是下面的代码能够正常运行：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">bool</span> b <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
 <span class="token keyword">switch</span> <span class="token punctuation">(</span>b<span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
 <span class="token keyword">case</span> <span class="token boolean">true</span><span class="token operator">:</span>
     <span class="token keyword">int</span> jval<span class="token punctuation">;</span>
     <span class="token keyword">break</span><span class="token punctuation">;</span>
 <span class="token keyword">case</span> <span class="token boolean">false</span><span class="token operator">:</span>
     jval <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>  
     <span class="token keyword">break</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 这是因为case会跳过一些<strong>语句</strong>的执行，在第一份代码中<code>int jval = 0;</code>这个初始化语句有其对应的汇编代码<code>mov dword ptr [jval],0</code>，在b为false时会被跳过，导致在case b下不能使用jval这个变量（为什么不能使用还是个迷，是没有分配内存还是怎么的？），所以程序报错；对于<code>std::string str;</code>也是一样的，因为string类有其构造函数，会隐式的初始化string类对象。还有一个原因，switch结束后会调用str的析构函数，但是由于定义str的语句可能被跳过，导致其没有执行配对的构造函数，析构的时候就很容易出错。而第二份代码中，<code>int jval;</code>只是对变量的定义，不是初始化，没有对应的汇编代码，所以并不会被跳过，而且case只是一个标签（类似goto语句的标签），在任何一个case下定义的变量，其作用域会从定义处一直到switch结束（不加大括号时case下的语句虽然形式上有缩进，但并不是一个作用域块，可以看作是一段顺序排列的语句）。所以在case true下定义的jval变量，在case false下依然是可见的，所以第二份代码能够正常运行。</p>
<p> 不过，在switch-case中定义变量很容易出错，还是尽量不要在里面定义变量，即使要定义变量，也要在case后加上大括号，如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">bool</span> b <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
 <span class="token keyword">switch</span> <span class="token punctuation">(</span>b<span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
 <span class="token keyword">case</span> <span class="token boolean">true</span><span class="token operator">:</span>
 <span class="token punctuation">{</span>
     <span class="token keyword">int</span> jval <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
     <span class="token keyword">break</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
 <span class="token keyword">case</span> <span class="token boolean">false</span><span class="token operator">:</span>
 <span class="token punctuation">{</span>
     <span class="token keyword">break</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<p><font size="5" color="orange">迭代语句</font></p>
<hr>
<ol>
<li>定义在while条件部分或者while循环体内的变量每次迭代都经历从创建到销毁的过程。即while循环中定义的变量会被反复创建和销毁。</li>
<li>for小括号里定义的所有变量都必须是同一个类型。如下：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">double</span> <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//错误，只能定义同种类型的变量</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li>范围for语句(<code>for(auto a : array){}</code>)执行时，每次迭代都会重新定义循环控制变量a，并将其初始化为序列中的下一个值。</li>
<li>不能通过范围for语句增加或删除vector对象（或其他容器）中的元素。因为在范围for语句中预存了end的值，一旦序列中添加（删除）元素，end函数的值就可能变得无效了。</li>
<li>和while、for不同的是，do-while语句应该在循环最后用一个分号表示语句结束：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
 <span class="token keyword">do</span> 
 <span class="token punctuation">{</span>
     <span class="token operator">++</span>i<span class="token punctuation">;</span>
 <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
 而且不允许在do-while的while条件部分定义变量。</li>
</ol>
<p><font size="5" color="orange">跳转语句</font></p>
<hr>
<ol>
<li>对于for循环：<code>for(; ; ++i){}</code>，在内部continue之后++i还是要执行的，因为不执行的话循环变量i就不会有变化，循环下去就会一直continue；但是循环内部break之后是不会执行++i的，如下：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
 <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">5</span><span class="token punctuation">)</span>
         <span class="token keyword">break</span><span class="token punctuation">;</span>
 std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//输出5</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<p><font size="5" color="orange">try语句块和异常处理</font></p>
<hr>
<ol>
<li><p>try用于检测原本程序的部分代码，在其中可能用throw抛出一些异常，try外面会有一些catch块来捕获抛出的这些异常。如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> ival <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> jval <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
 std<span class="token operator">::</span>cin <span class="token operator">>></span> ival <span class="token operator">>></span> jval<span class="token punctuation">;</span>
 <span class="token keyword">if</span> <span class="token punctuation">(</span>ival <span class="token operator">==</span> jval<span class="token punctuation">)</span>
     std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> ival <span class="token operator">+</span> jval <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
 <span class="token keyword">else</span>
     std<span class="token operator">::</span>cerr <span class="token operator">&lt;&lt;</span> <span class="token string">"ival and jval must be same"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 在真实项目中，我们应该尽量让逻辑代码（相加部分的代码）和用户交互的代码（输出错误信息的代码）分离开来。这里我们选择抛出一个异常：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">try</span> 
 <span class="token punctuation">{</span>
     <span class="token keyword">int</span> ival <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> jval <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
     std<span class="token operator">::</span>cin <span class="token operator">>></span> ival <span class="token operator">>></span> jval<span class="token punctuation">;</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>ival <span class="token operator">!=</span> jval<span class="token punctuation">)</span>
         <span class="token keyword">throw</span> std<span class="token operator">::</span><span class="token function">runtime_error</span><span class="token punctuation">(</span><span class="token string">"ival and jval must be same"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> ival <span class="token operator">+</span> jval <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
 <span class="token keyword">catch</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>runtime_error err<span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
     std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> err<span class="token punctuation">.</span><span class="token function">what</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 抛出异常将终止当前try语句块的执行（也有可能终止当前函数，见后面所述），并把控制权移交给能处理该异常的代码。</p>
<p> 类型runtime-error是标准库异常类型的一种，定义在stdexcept头文件中。每个标准库异常类都定义了一个名为what的成员函数，这些函数吧没有参数，返回值是C风格字符串（即const char*）。其中runtime-error的what成员函数返回的是初始化一个具体对象时所用的string类型参数的副本。</p>
</li>
<li><p>try-catch寻找处理代码（即catch）的过程与函数调用链刚好相反，会从当前函数开始向上查找对应的处理代码。当异常被抛出时们首先搜索抛出该异常的函数。如果没找到匹配的catch子句，终止该函数，并在调用该函数的函数中继续寻找。以此类推，沿着程序的执行路径逐层回退，直到找到适当类型的catch子句为止。如果最终还是没能找到任何匹配的catch子句，程序转到名为terminate的标准函数库。该函数的行为与系统有关，一般情况下，执行该函数将导致程序非正常退出。对于那些没有任何try语句块的异常，也按照类似的方式处理。</p>
<p> 可以看到，try-catch其实还是有一些性能消耗的。</p>
</li>
<li><p>通常情况下，略过部分程序意味着对象处理到一半就戛然而止，从而导致对象处于无效或未完成的状态，或者资源没有正常释放，等等。那些在异常发生期间正确执行了“清理”工作的程序被称作异常安全的代码。然而经验表明，编写异常安全的代码非常困难。</p>
<p> 所以对于那些确实要处理异常并继续执行的程序，就要加倍注意了。我们必须清楚异常何时发生，异常发生后程序应如何确保对象有效、资源无泄漏、程序处于合理状态，等等。</p>
<p> 当然，对于那些异常发生后终止即可的程序，不需要太关心这些问题。</p>
</li>
<li>标准异常：<br> C++定义的标准异常分别定义在4个头文件中：<ul>
<li>exception头文件定义了最通用的异常类exception。它只报告异常的发生。不提供任何额外信息。</li>
<li>stdexcept头文件定义了几种常用的异常类，详细信息如下：</li>
</ul>
</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center"><stdexcept>定义的异常类</stdexcept></th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">exception</td>
<td style="text-align:center">最常见的问题</td>
</tr>
<tr>
<td style="text-align:center">runtime_error</td>
<td style="text-align:center">只有在运行时才能检测出的问题</td>
</tr>
<tr>
<td style="text-align:center">range_error</td>
<td style="text-align:center">运行时错误：生成的结果超出了有意义的值域范围</td>
</tr>
<tr>
<td style="text-align:center">overflow_error</td>
<td style="text-align:center">运行时错误：计算上溢</td>
</tr>
<tr>
<td style="text-align:center">underflow_error</td>
<td style="text-align:center">运行时错误：计算下溢</td>
</tr>
<tr>
<td style="text-align:center">logic_error</td>
<td style="text-align:center">程序逻辑错误</td>
</tr>
<tr>
<td style="text-align:center">domain_error</td>
<td style="text-align:center">逻辑错误：参数对应的结果值不存在</td>
</tr>
<tr>
<td style="text-align:center">invalid_argument</td>
<td style="text-align:center">逻辑错误：无效参数</td>
</tr>
<tr>
<td style="text-align:center">length_error</td>
<td style="text-align:center">逻辑错误：试图创建一个超出类型最大长度的对象</td>
</tr>
<tr>
<td style="text-align:center">out_of_range</td>
<td style="text-align:center">逻辑错误：使用一个超出有效范围的值</td>
</tr>
</tbody>
</table>
<ol>
<li><p>我们只能以默认初始化的方式初始化exception、bad_alloc和bad_cast对象，不允许为这些对象提供初始值。</p>
<p> 其他异常类型的行为恰好相反：应该使用string对象或者C风格字符串初始化这些类型的对象，但是不允许使用默认初始化的方式。当创建此类对象时，必须提供初始值，该初始值含有错误相关的信息。</p>
<p> 异常类型只定义了一个名为what的成员函数，该函数没有任何参数，返回值是一个指向C风格字符串的const char*。该字符串的目的是提供关于异常的一些文本信息。如果异常类型有一个字符串初始值，则what返回该字符串，对于其他无初始值的异常类型来说，what返回的内容由编译器决定。<br>&nbsp; </p>
</li>
</ol>
<hr>
<p>参考文献：《C++Primer第五版》</p>
]]></content>
      
        <categories>
            
            <category> C++ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C++Primer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++Primer第四章 表达式]]></title>
      <url>/2017/12/14/C++Primer%E7%AC%AC%E5%9B%9B%E7%AB%A0%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p><font size="5" color="orange">基础</font><br><a id="more"></a></p>
<hr>
<ol>
<li>小整数类型（如bool、char、short等）通常会被提升成较大的整数类型（主要是int）。</li>
<li>当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中地址）。总之，左值是用址，右值是用值。左值右值并不是等号=左侧右侧的意思。</li>
<li><p>对于如下表达式：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p> 我们无法知道到底是f1先执行还是f2先执行，这个调用顺序是不固定的。</p>
<p> 对于这种没有指定执行顺序的运算符来说，如果表达式指向并修改了同一个对象，将会引发错误并产生未定义的行为,，程序结果将是不可预知的。如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
 std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span><span class="token operator">++</span>i <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//未定义的</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p> 编译器可能先求++i的值再求i的值，此时输出结果是1 1；也可能先求i的值再求++i的值，输出结果是0 1；甚至编译器还可能做完全不同的操作。</p>
<p> 建议：</p>
<pre><code>- 拿不准的时候最好用括号来强制让表达式的组合关系符合程序逻辑的要求。
- 如果改变了某个运算对象的值，在表达式的其他地方不要再使用这个运算对象。
</code></pre></li>
</ol>
<p><font size="5" color="orange">算术运算符</font></p>
<hr>
<ol>
<li><p>对大对数运算符来说，布尔类型的运算对象将被提升为int类型。如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">bool</span> b <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
 <span class="token keyword">bool</span> b2 <span class="token operator">=</span> <span class="token operator">-</span>b<span class="token punctuation">;</span>
 std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> b2 <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//输出1，b2是ture！</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p> 参与运算时b将被提升成整数值1，对它求负后的结果是-1，将-1再转换会布尔值将其作为b2的初始值，显然这个初始值不等于0，转换成布尔值后应该为1，所以b2的值是true。</p>
<p> 再一次证明，布尔值不应该参与运算。</p>
</li>
<li>参与取余运算的运算对象必须是整数类型。余数的符号总是和余数表达式中的被除数一致。m%(-n)等于m%n，(-m)%n等于-(m%n)。</li>
</ol>
<p><font size="5" color="orange">赋值运算符</font></p>
<hr>
<ol>
<li>C++11新标准允许使用花括号括起来的初始值列表作为赋值语句的右侧运算对象：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span>
 <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">3.14</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//运行错误</span>
 std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> vi<span class="token punctuation">;</span>
 vi <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
 第一条语句运行时正常，a的值将是3，而第二条语句运行时报错：懂double转换到int需要收缩转换。这是因为使用初始值列表来进行赋值的时候，初始值列表里值所占的空间不应该大于目标类型的空间。</li>
<li>赋值运算符满足右结合律，这一点与其他二元运算符不太一样：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> ival<span class="token punctuation">,</span> jval<span class="token punctuation">,</span> <span class="token operator">*</span>pval<span class="token punctuation">;</span>
 ival <span class="token operator">=</span> jval <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//正确，相当于ival = (jval = 0);</span>
 ival <span class="token operator">=</span> pval <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//错误，相当于ival = (pval = 0);，不能把指针的值赋给int</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<p><font size="5" color="orange">递增和递减运算符</font></p>
<hr>
<ol>
<li><p>对于递增和递减运算符，其前置版本（++i）将对象本身作为左值返回，后置版本则将对象原始值的副本作为右值返回。</p>
<p> 前置版本的递增递减运算符避免了不必要的工作，它把值加1后直接返回改变了的运算对象。与之相比，后置版本需要将原始值存储下来以便于返回这个未修改的内容。如果我们不需要修改前的值，那么后置版本的操作就是一种浪费。</p>
</li>
<li>后置递增运算符的优先级高于解引用运算符，因此*pbeg++等价于*(pbeg++)。pbeg++把pbeg的值加1，然后返回pbeg的初始值的副本作为其求值结果。</li>
</ol>
<p><font size="5" color="orange">成员访问运算符</font></p>
<hr>
<ol>
<li>解引用运算符的优先级低于点运算符，所以ptr-&gt;mem等价于(*ptr).mem，而非*ptr.mem。后者会报错，因为指针没有名为mem的成员。</li>
<li>对于<code>*pval++</code>，解引用运算符的优先级低于++，所以等价于<code>*(pval++)</code>。</li>
</ol>
<p><font size="5" color="orange">条件运算符</font></p>
<hr>
<ol>
<li>&lt;&lt;运算符比一般的关系运算符、条件运算符的优先级要高（即比逻辑运算符优先级高）。所以：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> grade <span class="token operator">&lt;</span> <span class="token number">60</span> <span class="token operator">?</span> <span class="token string">"fail"</span> <span class="token operator">:</span> <span class="token string">"pass"</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//错误，试图比较cout和60</span>
 std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>grade <span class="token operator">&lt;</span> <span class="token number">60</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token string">"fail"</span> <span class="token operator">:</span> <span class="token string">"pass"</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//输出1或者0</span>
 std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>grade <span class="token operator">&lt;</span> <span class="token number">60</span> <span class="token operator">?</span> <span class="token string">"fail"</span> <span class="token operator">:</span> <span class="token string">"pass"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//输出pass或者fail</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<p><font size="5" color="orange">位运算符</font></p>
<hr>
<ol>
<li>位运算符作用于整数类型的运算对象。如果作用于类似char这种类型，会先把char类型的运算对象提升成int型。</li>
<li>由于关于符号位如何处理没有明确的规定，所以强烈建议仅将位运算符用于处理无符号类型。</li>
<li><p>左移运算符（&lt;&lt;）在右侧插入值为0的二进制位；右移运算符（&gt;&gt;）的行为则依赖于其左侧运算对象的类型，如果该运算对象是无符号类型，则在左侧插入值为0的二进制位；如果该运算符对象是带符号类型，则在左侧插入符号位的副本或值为0的二进制位，如何选择具体视环境而定。</p>
<p> 不过对于移出边界之外，两者都是直接舍弃掉。</p>
</li>
<li>移位运算符满足左结合律，所以<code>std::cout &lt;&lt; &quot;hi&quot; &lt;&lt; &quot;here&quot; &lt;&lt; std::endl</code>等价于<code>((std::cout &lt;&lt; &quot;hi&quot;) &lt;&lt; &quot;here&quot;) &lt;&lt; std::endl</code>。</li>
<li>移位运算符的优先级不高不低，介于中间：比算术运算符的优先级低，但比关系运算符、赋值运算符和条件运算符的优先级高。</li>
</ol>
<p><font size="5" color="orange">sizeof运算符</font></p>
<hr>
<ol>
<li>sizeof运算符满足右结合律，其所得的值是一个size_t类型的常量表达式，它有两种形式，都是合法的：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">sizeof</span> expr<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li>sizeof并不实际计算其运算对象的值，如：<pre class="line-numbers language-cpp"><code class="language-cpp"> CData Data<span class="token punctuation">;</span>
 <span class="token keyword">sizeof</span> Data<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//Data的类型的大小，即sizeof(CData)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li>对引用类型执行sizeof运算得到被引用对象所占空间的大小，但是对指针执行sizeof运算得到指针本身所占空间的大小。</li>
<li>对数组执行sizeof运算得到整个数组所占空间的大小，等价于对数组中所有的元素各执行一次sizeof运算并将所得结果求和。注意，sizeof运算不会把数组转换成指针来处理。</li>
<li>对string对象或vector对象执行sizeof运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间。即只计算静态数据的大小，而非对象里动态分配的数据。</li>
<li>sizeof运算的优先级低于算术运算符，但大于关系运算符等。所以<code>sizeof x + y</code>等价于<code>sizeof (x + y)</code>，<code>sizeof a &lt; b</code>等价于<code>sizeof (a) &lt; b</code>。</li>
</ol>
<p><font size="5" color="orange">逗号运算符</font></p>
<hr>
<ol>
<li>逗号运算符含有两个运算对象，按照从左向右的顺序依次求值，真正的运算结果是右侧表达式的值：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// a = 2</span>
 <span class="token keyword">int</span> b<span class="token punctuation">;</span>
 b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// b = 1</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
 逗号运算符的优先级是所有运算符中最低的，比赋值运算符还低。</li>
</ol>
<p><font size="5" color="orange">类型转换</font></p>
<ol>
<li>在大多数表达式中，比int类型小的整型值首先提升为较大的整数类型。</li>
<li>当数组被用作decltype关键字的参数，或者作为取地址符（&amp;）、sizeof及typeid等运算符的运算对象时，数组名不会被转换为指针。</li>
<li>虽然有时不得不使用强制类型转换，但这种方法本质上是非常危险的。</li>
<li>一个命名的强制类型转换具有如下形式：<pre class="line-numbers language-cpp"><code class="language-cpp"> cast<span class="token operator">-</span>name<span class="token operator">&lt;</span>type<span class="token operator">></span><span class="token punctuation">(</span>expression<span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
 type是转换的目标类型。如果type是引用类型，则结果是左值。cast-name是static_cast、dynamic_cast、const_cast和reinterpret_cast中的一种。</li>
<li>dynamic_cast支持运行时类型识别，第十九章再做详细说明。</li>
<li><p>static_cast：<br> 任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast。如：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
 <span class="token keyword">double</span> slope <span class="token operator">=</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">/</span> j<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p> 当需要把一个较大的算术类型赋值给较小的类型时，static非常有用（比如上面把double赋给int类型的i）。此时，强制类型转换告诉程序的读者和编译器，我们知道并且不在乎潜在的精度损失。一般来说，如果编译器发现一个较大的算术类型试图赋值给一个较小的类型，就会给出警告信息；但是当我们执行了显示的类型转换后，警告信息就会被关闭了。</p>
<p> static_cast对于编译器无法自动执行的类型转换也非常有用。例如，我们可以使用static_cast找回存在于void*指针中的值：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
 <span class="token keyword">void</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span>
 <span class="token keyword">int</span> <span class="token operator">*</span>ip <span class="token operator">=</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">double</span> <span class="token operator">*</span>dp <span class="token operator">=</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//dp的值不是10.0，是未定义的（本机输出是-9.25596e+61）</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p> 不过我们必须保证static_cast强制转换回原来的类型，否则将产生未定义的后果。因为由于类型不同，可能转换后的地址与原始地址不相等了，再加上由于类型大小不一样，也很可能得不到和原来相等的值。</p>
</li>
<li>const_cast：<br> const_cast只能改变运算对象的底层const。如：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
 <span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span>
 <span class="token keyword">int</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> <span class="token keyword">const_cast</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token operator">*</span>p2 <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
 std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//输出20</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
 如果对象本身不是一个常量，使用强制类型转换获得写权限是合法的行为；但是如果对象是一个常量，再使用const_cast后执行写操作将会产生未定义的后果。如下：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">const</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
 <span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span>
 <span class="token keyword">int</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> <span class="token keyword">const_cast</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token operator">*</span>p2 <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
 std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//输出10</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
 const_cast常常用于有函数重载的上下文中（第六章会有介绍），但是用于其他地方就说明有设计缺陷。</li>
<li><p>reinterpret_cast：<br> reinterpret_cast通常为运算对象的位模式提供较低层次上的重新解释。如下程序：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
 <span class="token keyword">int</span> <span class="token operator">*</span>ip <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span>
 <span class="token keyword">char</span> <span class="token operator">*</span>cp <span class="token operator">=</span> <span class="token keyword">reinterpret_cast</span><span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>ip<span class="token punctuation">)</span><span class="token punctuation">;</span>
 std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span><span class="token function">string</span><span class="token punctuation">(</span>cp<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//可能导致异常的运行时行为</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p> 我们必须牢记cp所指的真实对象是一个int而非字符，如果把cp当做普通的字符指针使用时就可能在运行时发生错误。可以看出，使用reinterpret_cast是非常危险的。</p>
<p> reinterpret_cast本质上依赖于机器，想要安全地使用reinterpret_cast必须对涉及的类型和编译器实现转换的过程都非常了解。</p>
</li>
<li>强制类型转换干扰了正常的类型检查，因此强烈建议避免使用强制类型转换，尤其是reinterpret_cast。即使是static_cast和dynamic_cast都不应该频繁使用。</li>
<li>旧式的强制类型转换形式为：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token function">type</span> <span class="token punctuation">(</span>expr<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//函数形式的强制类型转换</span>
<span class="token punctuation">(</span>type<span class="token punctuation">)</span> expr<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//C语言风格的强制类型转换</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
与命名的强制类型转换相比，旧式的强制类型转换从表现形式上来说不那么清晰明了，容易被看漏，所以一旦转换过程出现问题，追踪起来也更加困难。<br>&nbsp; </li>
</ol>
<hr>
<p>参考文献：《C++Primer第五版》</p>
]]></content>
      
        <categories>
            
            <category> C++ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C++Primer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++Primer第三章 字符串、向量和数组]]></title>
      <url>/2017/12/12/C++Primer%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/</url>
      <content type="html"><![CDATA[<p><font size="5" color="orange">命名空间的using声明</font><br><a id="more"></a></p>
<hr>
<ol>
<li><p>比如我们需要在程序中用cin时，可以用using声明可以从命名空间std中获取它：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>

 <span class="token keyword">using</span> std<span class="token operator">::</span>cin<span class="token punctuation">;</span>

 <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
     <span class="token keyword">int</span> i<span class="token punctuation">;</span>
     cin <span class="token operator">>></span> i<span class="token punctuation">;</span>
     std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> i<span class="token punctuation">;</span>

     <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>头文件里不应该包含using声明。因为头文件的内容会被拷贝到所有引用它的文件中去，如果头文件里有某个using声明，那么每个使用了该头文件的文件就都会有这个声明，对于某些程序来说，由于不经意间包含了一些名字，反而可能会产生始料未及的名字冲突。</li>
</ol>
<p><font size="5" color="orange">标准库类型string</font></p>
<hr>
<ol>
<li>C++标准库在实现时已经考虑到了性能需求，所以标准库类型对于一般应用场合来说有足够的效率。</li>
<li>编译器虽然会给字符串字面值自动添加空字符，但是把这个字符串字面值赋给string对象时，却不会把空字符也赋值过去：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>string <span class="token function">str</span><span class="token punctuation">(</span><span class="token string">"Lova"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> str<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//输出4，其中str[4]是未定义的，并不是空字符</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li>虽然如下两种对string对象赋值的结果是一样的：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>string <span class="token function">s1</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//直接初始化</span>
 std<span class="token operator">::</span>string s2 <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//拷贝初始化</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
 但是，使用等号初始化一个变量，实际上执行的是拷贝初始化，编译器把等号右侧的初始值拷贝到新创建的对象中去。与之相反，如果不使用等号，则执行的是直接初始化。</li>
<li>用cin执行读取操作时，string对象会自动忽略开头的空白（即空格符、换行符、制表符等）并从第一个真正的字符开始读起，直到遇见下一处空白为止。如下程序：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>string s1<span class="token punctuation">,</span> s2<span class="token punctuation">;</span>
 std<span class="token operator">::</span>cin <span class="token operator">>></span> s1 <span class="token operator">>></span> s2<span class="token punctuation">;</span>
 std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> s1 <span class="token operator">&lt;&lt;</span> s2 <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
 如果输入“&nbsp;&nbsp;&nbsp; &nbsp;      Hello World  &nbsp;&nbsp; &nbsp;&nbsp;   ”，则输出是“HelloWorld”。</li>
<li><p>有时我们希望能在最终得到的字符串中保留输入时的空白符，这时应该用getline函数代替原来的&gt;&gt;运算符。如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>string line<span class="token punctuation">;</span>
 <span class="token function">getline</span><span class="token punctuation">(</span>std<span class="token operator">::</span>cin<span class="token punctuation">,</span> line<span class="token punctuation">)</span><span class="token punctuation">;</span>
 std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> line <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>  如果输入“&nbsp;&nbsp;&nbsp; &nbsp;      Hello World  &nbsp;&nbsp; &nbsp;&nbsp;   ”，则输出也是“&nbsp;&nbsp;&nbsp; &nbsp;      Hello World  &nbsp;&nbsp; &nbsp;&nbsp;   ”。</p>
<p> getline函数会从给定的输入流中读入内容，直到遇到换行符为止（注意换行符也被读进来了），然后把所读的内容存入到那个string对象中去（注意不存换行符）。</p>
<blockquote>
<p>触发getline函数返回的那个换行符实际上被丢弃了，得到的string对象中并不包含该换行符。</p>
</blockquote>
</li>
<li><p>如下程序：</p>
<pre class="line-numbers language-c++"><code class="language-c++"> std::string str("Hello");
 auto len = str.size();
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p> 其中size函数返回的是一个string::size_type类型的值。</p>
<p> string类及其他大多数标准库类型都定义了几种配套的类型，这些配套类型体现了标准库类型与机器无关的特性，类型size_type即是其中的一种。它是一种无符号整型值，而且能够存放下任何string对象的大小。</p>
<p> 由于size函数返回的是无符号整型，所以需要注意表达式中不要再使用int这种有符号整型了，否则可能会因为混用有符号和无符号数而产生意想不到的bug。</p>
</li>
<li>因为某些历史原因，也为了与C兼容，所以C++语言中的字符串字面值并不是标准库类型string的对象。切记，字符串字面值与string是不同的类型。</li>
<li>可以把string对象和字符串字面值相加，但不能直接把两个字符串字面值相加（因为这两个字符串字面值都不是string对象，无法使用string类中才重载的字符串相加运算符）。</li>
<li>在cctype头文件中定义了一组标准库函数可以用来处理字符：</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">isalnum(c)</td>
<td>当c是字母或数字时为真</td>
</tr>
<tr>
<td style="text-align:center">isalpha(c)</td>
<td>当c是字母时为真</td>
</tr>
<tr>
<td style="text-align:center">iscntrl(c)</td>
<td>当c是控制字符时为真</td>
</tr>
<tr>
<td style="text-align:center">isdigit(c)</td>
<td>当c是数字时为真</td>
</tr>
<tr>
<td style="text-align:center">isgraph(c)</td>
<td>当c不是空格但可以打印时为真</td>
</tr>
<tr>
<td style="text-align:center">islower(c)</td>
<td>当c是小写字母时为真</td>
</tr>
<tr>
<td style="text-align:center">isprint(c)</td>
<td>当c是可打印字符时为真（即c是空格或c具有可视形式）</td>
</tr>
<tr>
<td style="text-align:center">ispunct(c)</td>
<td>当c是标点符号时为真（即c不是控制字符、数字、字母、可打印空白中的一种）</td>
</tr>
<tr>
<td style="text-align:center">isspace(c)</td>
<td>当c是空白时为真（即c是空格、制表符、回车符、换行符、进纸符的一种）</td>
</tr>
<tr>
<td style="text-align:center">issupper(c)</td>
<td>当c是大写字母时为真</td>
</tr>
<tr>
<td style="text-align:center">isxdigit(c)</td>
<td>当c是十六进制数字时为真</td>
</tr>
<tr>
<td style="text-align:center">tolower(c)</td>
<td>如果c是大写字母，输出对应的小写字母；否则原样输出</td>
</tr>
<tr>
<td style="text-align:center">tosupper(c)</td>
<td>如果c是小写字母，输出对应的大写字母；否则原样输出</td>
</tr>
</tbody>
</table>
<ol>
<li><p>范围for语句：<br>  范围for语句遍历给定序列中的每个元素并对序列中的每个值执行某种操作，其语法形式是：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">for</span><span class="token punctuation">(</span>declaration <span class="token operator">:</span> expression<span class="token punctuation">)</span>
    statement
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>每次迭代，declaration部分的变量会被初始化为expression部分的下一个元素值。如下代码是统计给定字符串中标点符号的个数：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>string <span class="token function">s</span><span class="token punctuation">(</span><span class="token string">"this elay's blog!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> NumPunct <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> c <span class="token operator">:</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">ispunct</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">//记得添加cctype头文件</span>
        NumPunct<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> NumPunct <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果想要改变string对象中字符的值，必须把循环变量（上面的代码里是c）定义成引用类型。</p>
</li>
<li>string对象的下标运算符[ ]接收的输入参数是string::size_type类型的值，这个参数表示要访问的字符的位置；返回值是该位置上字符的引用。如果某个下标索引是带符号类型的值，讲自动转换成由string::size_type表达的无符号类型。使用下标时必须确定其大于等于0，而且小于字符串的size()的值。一种简便的方法是：总是设下标的类型为string::size_type类型，因为它是无符号类型，可以确保下标不会小于0，然后只需要再保证下标小于size()的值就可以了。</li>
</ol>
<p><font size="5" color="orange">标准库类型vector</font></p>
<hr>
<ol>
<li>标准库类型vector表示对象的集合，其中所有对象的类型都相同。</li>
<li>vector是模板而非类型，由vector生成的类型必须带尖括号声明元素的具体类型，如vector<int>。</int></li>
<li>vector能容纳绝大多数类型的对象作为其元素，但是因为引用不是对象。所以不存在包含引用的vector。</li>
<li>在早期的C++标准中，声明双重vector，需要在外层vector对象的右尖括号和其元素类型之间添加一个空格，即：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">></span> Array<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
 不过在C++11标准中，这个空格不是必须的了。</li>
<li>类似数组，C++11还提供了使用列表初始化vector的方式：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> V1 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//列表初始化</span>
 std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> V2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//错误，应该使用花括号</span>
 std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">V3</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//V3里有10个int类型的元素，每个都被初始化为0</span>
 std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> V4<span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//V4里有2个int类型的元素，值分别是10和0</span>
 std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">V5</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//V5里有10个int类型的元素，初始值都是0</span>
 std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> V6<span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">}</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//V6里有1个int类型的元素，初始值是10</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
 在初始化时，如果用的是圆括号，可以说提供的值是用来构造vector对象的；如果用的是花括号，就是用列表初始化该vector对象的。</li>
<li>其实vector对象能够高效增长，不需要在初始化时指定其大小，初始化时设定其大小可能性能反而不好，更有效的办法是先定义一个空的vector对象，再在运行时向其中添加具体值。</li>
<li>和string类似，vector也支持&lt;，&gt;等关系运算符，也是按字典顺序进行比较的，而且V1[n]也是返回V1中第n个元素的引用。</li>
<li>对于vector，要使用size_type（vector的下标的类型是size_type），需要先指定具体的vector类型：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>vector<span class="token operator">::</span>size_type        <span class="token comment" spellcheck="true">//错误</span>
 std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>size_type <span class="token comment" spellcheck="true">//正确</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
</ol>
<p><font size="5" color="orange">迭代器介绍</font></p>
<hr>
<ol>
<li>所有标准库容器都可以使用迭代器，但是其中只有少数几种才同时支持下标运算符。</li>
<li><p>像string、vector这种有迭代器的类型都拥有begin和end成员函数：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> v<span class="token punctuation">;</span>
 <span class="token keyword">auto</span> b <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> e <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p> 其中，begin函数返回指向第一个元素的迭代器；end函数返回指向容器“尾元素的下一位置”的迭代器，也就是说该迭代器指向的是容器的一个本不存在的“尾后”元素，没有什么实际含义，仅是个标记而已，表示我们已经处理完了容器中的所有元素，所以通常被称为尾后迭代器，或简称尾迭代器。</p>
<p> 如果容器为空，则begin和end返回的是同一个迭代器，都是尾后迭代器。</p>
<p>由于end返回的迭代器并不指示某个元素，所以不能对其进行递增或解引用的操作。如下代码：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>string <span class="token function">s</span><span class="token punctuation">(</span><span class="token string">"some string"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>s<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
 std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>s<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//非法，不能对尾后迭代器解引用</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li>通常我们不需要care迭代器的具体类型到底是什么，一个auto就足够了。</li>
<li>迭代器的访问方法类似指针，如<code>*iter</code>表示迭代器iter指向的元素的引用，<code>iter-&gt;mem</code>表示迭代器iter指向的对象中名为mem的成员。</li>
<li>我们通常不知道，也无须知道迭代器的精准类型，用auto就可以了。其实，迭代器的类型是iterator和const_iterator，如下：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>iterator it<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//it能读写vector&lt;int>中的元素</span>
 std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>const_iterator it2<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//it2只能读vector&lt;int>中的元素，不能写</span>
 std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> v<span class="token punctuation">;</span>
 <span class="token keyword">const</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> cv<span class="token punctuation">;</span>
 <span class="token keyword">auto</span> it3 <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">//it3的类型是vector&lt;int>::iterator</span>
 <span class="token keyword">auto</span> it4 <span class="token operator">=</span> cv<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment" spellcheck="true">//it4的类型是vector&lt;int>::const_iterator</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
 为了便于专门得到const_iterator类型的返回值，C++11引入了两个新函数，分别是cbegin和cend：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">auto</span> it5 <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment" spellcheck="true">//it5的类型是vector&lt;int>::const_iterator</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
 其中即使vector对象（或string对象）不是常量，这两个函数返回值也都是const_iterator。</li>
<li>C++语言的箭头运算符（<code>-&gt;</code>）实际上是把解引用和成员访问两个操作结合在一起，也就是说，<code>it-&gt;mem</code>和<code>(*it).mem</code>表达的意思相同。</li>
<li>谨记，但凡是使用的迭代器的循环体，都不要向迭代器所属的容器添加元素，因为这样会使迭代器失效的。</li>
<li>两个迭代器的距离，在C++中用类型difference_type来表示，它是带符号整型数（因为两个迭代器之间的距离是可正可负的）。</li>
</ol>
<p><font size="5" color="orange">数组</font></p>
<hr>
<ol>
<li>如果不清楚元素的个数，请使用vector，而非数组。</li>
<li>定义数组的时候必须指定数组的类型，不允许使用auto关键字由初始值的列表推断类型，这一点与vector不同。如下：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> v <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//合法</span>
 <span class="token keyword">auto</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">//非法</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li>使用列表初始化数组时，不够的元素一定会被默认初始化，无论是不是函数的局部变量。如下：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
 <span class="token keyword">int</span> b<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
 std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//a中的元素是未定义的</span>
 std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//b中的元素被默认初始化为0</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>想要理解数组声明的含义，最好的办法是从数组的名字开始，从内向外、从右向左的顺序阅读。如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> <span class="token operator">*</span>ptrs<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//ptrs是含有10个整型指针的数组，是指针数组</span>
 <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>pArray<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//pArray指向含有10个整型的数组，是数组指针</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p> 从右向左，ptrs右边是[10]，所以定义的是一个大小为10的数组，数组名称是ptrs；ptrs左边是int*，即数组中的所有元素都是int型指针，所以ptrs是含有10个整型指针的数组的名称，是10个指针构成的数组。</p>
<p>先从内向外，在括号内部，pArray右边没有东西，左边是*，所以知道pArray是一个指针，然后从右向左，（*pArray）右边是[10]，所以（*pArray）是一个大小为10的数组的名称，（*pArray）右边是int，说明数组中的所有元素都是int型，所以pArray是一个指向整型数组的指针。</p>
<p> 所以，对于如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arry<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> ptrs<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//arry是数组的引用，该数组含有10个整型指针</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p> 从内向外，可以知道arry是一个引用，然后从右至左，在(&amp;arry)右边是[10]，所以(&amp;arry)是一个大小为10的数组的名称，在(&amp;arry)左边是int*，即数组中的每个元素是int型指针，所以arry是在引用一个大小为10的整型指针数组。</p>
</li>
<li>在使用数组下标时，通常将其定义为<strong>size_t</strong>类型，它是一种机器相关的无符号类型，它被设计得足够大以便能表示内存中任意对象的大小。在cstddef头文件中定义了size_t类型，这个文件是C标准库stddef.h头文件的C++版本。</li>
<li><p>使用auto时，用数组名作初始值推断出来的变量类型是指针；而使用decltype时，用数组名作初始值推断出来的变量类型依然是数组：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> Array<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
 <span class="token keyword">auto</span> pArray2 <span class="token operator">=</span> Array<span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">//pArray2是一个整型指针，指向Array的第一个元素</span>

 <span class="token keyword">decltype</span><span class="token punctuation">(</span>Array<span class="token punctuation">)</span> Array3 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//Array3含有4个整数的数组</span>
 Array3<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
 <span class="token keyword">decltype</span><span class="token punctuation">(</span>Array<span class="token punctuation">)</span> Array4 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//错误，Array4必须是含有4个整数的数组</span>
 <span class="token keyword">decltype</span><span class="token punctuation">(</span>Array<span class="token punctuation">)</span> Array4 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//正确</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用auto时，编译器实际上作了类似如下的转化：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">auto</span> pArray2 <span class="token operator">=</span> <span class="token operator">&amp;</span>Array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>而在使用decltype时并没有发生这种转化，所以推断出来的依然是数组类型。值得注意的是推断出来的4个整型的数组类型，就不能给把数量比它多的初始化列表赋给它，但是可以把数量比它少的初始化列表赋给它，因为不够的元素默认被初始化为0了。</p>
</li>
<li>为了得到数组的首指针和尾后指针，C++11也为数组定义了begin和end函数，与vector这种容器不同的是，作用与数组的begin和end函数并非是其成员函数，而且返回值也是指针类型，而非迭代器类型。<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> Array<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
 <span class="token keyword">int</span> <span class="token operator">*</span>beg <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">begin</span><span class="token punctuation">(</span>Array<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li>再次特别注意，尾后指针不能执行解引用和递增操作，不过可以获取其地址（即指针存储的值）。</li>
<li>两个指针相减的结果的类型是一种名为ptrdiff_t的标准库类型。和size_t一样，ptrdiff_t也是一种定义在cstddef头文件中的机器相关的带符号类型。</li>
<li>标准库类型（如string、vector等等）限定使用的下标必须是无符号类型，而内置的下标运算无此要求。如下：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> Array<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>Array<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> j <span class="token operator">=</span> p<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//p[-2]是Array[0]表示的那个元素</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li>用char*定义的字符数组就是C风格的字符串，如下：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">char</span> cs<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"This is a C string."</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
尽管C++支持C风格字符串，但在C++程序中最好还是不要使用它们。这是因为C风格字符串不仅使用起来不太方便，而且还极易引发程序漏洞，是诸多安全问题的根本原因。<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">char</span> cs1<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token string">'C'</span><span class="token punctuation">,</span><span class="token string">'+'</span><span class="token punctuation">,</span><span class="token string">'+'</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//末尾没有空字符</span>
<span class="token keyword">const</span> <span class="token keyword">char</span> cs2<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"This is a C string."</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//末尾有空字符</span>
std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">strlen</span><span class="token punctuation">(</span>cs1<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//错误，cs1没有以空字符结束，输出的可能不是3</span>
std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">strlen</span><span class="token punctuation">(</span>cs2<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//正确</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
对大多数应用来说，使用标准库string要比使用C风格字符串更安全、高效。</li>
<li>允许使用以空字符结束的字符数组来初始化string对象或为string对象赋值，但是不能用string对象直接初始化指向字符的指针：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">char</span> cs1<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token string">'C'</span><span class="token punctuation">,</span><span class="token string">'+'</span><span class="token punctuation">,</span><span class="token string">'+'</span><span class="token punctuation">,</span><span class="token string">'\0'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
std<span class="token operator">::</span>string s1 <span class="token operator">=</span> cs1<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//正确                  </span>
<span class="token keyword">char</span> <span class="token operator">*</span>cs2 <span class="token operator">=</span> s1<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//错误，不能用string对象初始化char*指针</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
为了完成该功能，string专门提供了一个名为c_str的成员函数：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>cs2 <span class="token operator">=</span> s1<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//正确</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
顾名思义，c_str函数的返回值是一个C风格的字符串指针，结果指针的类型是const char*。由于返回的实际上是指向字符串s1的指针，所以当s1的内容改变时，cs2的内容也会随之改变。</li>
<li>不允许使用vector对象初始化数组，但是允许使用数组来初始化vector对象，只需要在初始化时指明待拷贝区域的首地址和尾后地址就可以了：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> Array<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">ivec</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">begin</span><span class="token punctuation">(</span>Array<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> std<span class="token operator">::</span><span class="token function">end</span><span class="token punctuation">(</span>Array<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//ivec的内容是2,3,4</span>
std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">ivec2</span><span class="token punctuation">(</span>Array <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> Array <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                       <span class="token comment" spellcheck="true">//ivec2的内容是2,3</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
注意第二个参数是待拷贝区域的尾后地址，所以ivec的内容是2、3、4，而不是2、3、4、5。</li>
<li>现代C++程序应当尽量使用vector和迭代器，避免使用内置数组和指针；应该尽量使用string，避免使用C风格的基于数组的字符串。</li>
</ol>
<p><font size="5" color="orange">多维数组</font></p>
<hr>
<ol>
<li>严格来说，C++没有多维数组，通常所说的多维数组其实是数组的数组。谨记！如下：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> Array<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//大小为3的数组，每个元素是含有4个整数的数组</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
 按照由内而外、由左至右的顺序阅读多维数组的定义有助于更好地理解其真实含义。</li>
<li>多维数组初始化：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> Array<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token operator">=</span>
 <span class="token punctuation">{</span>
     <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
     <span class="token punctuation">{</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
     <span class="token punctuation">{</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">}</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
 其中内层嵌套的花括号并非必需的，但是如果内层花括号中元素个数不够时，会执行默认初始化，这时有没有花括号还是有很大区别的：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> Array<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token number">8</span><span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
 <span class="token keyword">int</span> Array2<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">0</span> <span class="token punctuation">,</span> <span class="token number">4</span> <span class="token punctuation">,</span> <span class="token number">8</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
 此时的Array和Array2内容是不一样的，Array是每一行不足的用0进行默认初始化，而Array2是前三个元素分别是0、4、8，但是后面的元素都是默认初始化为0。</li>
<li><p>要使用范围for语句处理多维数组时，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型。这时最内层获取到的变量是只读的，如果要可写的话，还需要给最内层循环的控制变量加上引用。如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> Array<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
 size_t cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
 <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>row <span class="token operator">:</span> Array<span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
     <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>col <span class="token operator">:</span> row<span class="token punctuation">)</span>
     <span class="token punctuation">{</span>
         col <span class="token operator">=</span> cnt<span class="token punctuation">;</span>
         <span class="token operator">++</span>cnt<span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 上面的代码是正确的，但是下面这样就不合法了：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> Array<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
 size_t cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
 <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> row <span class="token operator">:</span> Array<span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
     <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>col <span class="token operator">:</span> row<span class="token punctuation">)</span>
     <span class="token punctuation">{</span>
         col <span class="token operator">=</span> cnt<span class="token punctuation">;</span>
         <span class="token operator">++</span>cnt<span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 因为row不是引用类型，所以编译器初始化row时会自动将这些数组形式的元素（谨记多维数组实际上是数组的数组）转换成指向该数组内首元素的指针。这样得到的row的类型就是int*，显然内层的循环就不合法了，因为编译器将试图在一个int*内进行遍历，显然和程序的初衷相去甚远。</p>
<p> 所以，谨记没有使用引用的数组名都是会被自动转换为指针的。</p>
</li>
<li>因为多维数组实际上是数组的数组，所以由多维数组名转换得来的指针实际上是指向第一个内层数组的指针。如下代码：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> Array<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
 <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> Array<span class="token punctuation">;</span>
 p <span class="token operator">=</span> <span class="token operator">&amp;</span>Array<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
 通过p的声明形式可以知道，p是一个指针，指向含有4整数的数组，而数组名Array也是指向第一个内层数组的指针，所以第二句代码是合法的。由于Array[2]表示Array的第三个元素，这个元素是一个含有4个整数的数组，所以对Array[2]取地址，再赋给p也是合法的。<br> &nbsp; </li>
</ol>
<hr>
<p>参考文献：《C++Primer第五版》</p>
]]></content>
      
        <categories>
            
            <category> C++ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C++Primer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[在OpenGL中踩过的坑]]></title>
      <url>/2017/12/02/OpenGL%E4%B8%AD%E7%9A%84%E5%9D%91/</url>
      <content type="html"><![CDATA[<p><font size="5" color="orange">重新链接着色器程序后uniform失效</font><br><a id="more"></a></p>
<hr>
<p>如果链接着色器程序后，为着色器程序设置好了uniform变量，然后再链接一次。着色器程序将会回到初始状态，所有设置好的uniform变量也会还原（可能变成0）。</p>
<p>这个情况在Transform Feedback中很容易发生。因为通常会有如下程序：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">m_pFLCPassShader  <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">CShader</span><span class="token punctuation">(</span><span class="token string">"FLC_VS.glsl"</span><span class="token punctuation">,</span> <span class="token string">"FLC_FS.glsl"</span><span class="token punctuation">,</span> <span class="token string">"FLC_GS.glsl"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
m_pFLCPassShader<span class="token operator">-</span><span class="token operator">></span><span class="token function">activeShader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">glUniform1i</span><span class="token punctuation">(</span><span class="token function">glGetUniformLocation</span><span class="token punctuation">(</span>m_pFLCPassShader<span class="token operator">-</span><span class="token operator">></span><span class="token function">getProgram</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"u_Test"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">300</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">const</span> GLchar <span class="token operator">*</span> <span class="token keyword">const</span> Varyings<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span>             <span class="token comment" spellcheck="true">//为Transform Feedback设置要读回哪些变量</span>
<span class="token punctuation">{</span>
    <span class="token string">"VERTEX_WORLD_POSITION"</span><span class="token punctuation">,</span>
    <span class="token string">"VERTEX_NORMAL"</span><span class="token punctuation">,</span>
    <span class="token string">"VERTEX_TEXCOORD"</span><span class="token punctuation">,</span>
    <span class="token string">"VERTEX_COLOR"</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token function">glTransformFeedbackVaryings</span><span class="token punctuation">(</span>vShader<span class="token punctuation">.</span><span class="token function">getProgram</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> Varyings<span class="token punctuation">,</span> GL_INTERLEAVED_ATTRIBS<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">glLinkProgram</span><span class="token punctuation">(</span>vShader<span class="token punctuation">.</span><span class="token function">getProgram</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在第一句CShader类里会第一次链接好着色器程序，然后我为该着色器设置了u_Test这个uniform变量的值，后面我们针对着色器程序里要用到的Transform Feedback，为它设置要读回哪些变量，这个时候不得不再链接一次程序（不链接的话Transform Feedback将无效）。因为又链接了一次程序，我们发现之前为u_Test设置的值300失效了，被重新还原为初始状态：0。</p>
<p>解决方案当然就是确保先链接着色器程序，再设置uniform值了。</p>
<p><font size="5" color="orange">深度测试无效</font><br>在自定义帧缓冲中应用深度测试时，一定要记得给自定义的帧缓冲添加深度附件，否则开启的深度测试是无效的。</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">GLuint fbo<span class="token punctuation">;</span>
<span class="token function">glGenFramebuffers</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>fbo<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">glBindFramebuffer</span><span class="token punctuation">(</span>GL_FRAMEBUFFER<span class="token punctuation">,</span> fbo<span class="token punctuation">)</span><span class="token punctuation">;</span>
GLuint texColorBuffer<span class="token punctuation">;</span>
<span class="token function">glGenTextures</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>texColorBuffer<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">glBindTexture</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> texColorBuffer<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">glTexImage2D</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> GL_RGB<span class="token punctuation">,</span> width<span class="token punctuation">,</span> height<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> GL_RGB<span class="token punctuation">,</span> GL_UNSIGNED_BYTE<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">glTexParameteri</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> GL_TEXTURE_MIN_FILTER<span class="token punctuation">,</span> GL_LINEAR<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">glTexParameteri</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> GL_TEXTURE_MAG_FILTER<span class="token punctuation">,</span> GL_LINEAR<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">glBindTexture</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">glFramebufferTexture2D</span><span class="token punctuation">(</span>GL_FRAMEBUFFER<span class="token punctuation">,</span> GL_COLOR_ATTACHMENT0<span class="token punctuation">,</span> GL_TEXTURE_2D<span class="token punctuation">,</span> texColorBuffer<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
GLuint rbo<span class="token punctuation">;</span>
<span class="token function">glGenRenderbuffers</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>rbo<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">glBindRenderbuffer</span><span class="token punctuation">(</span>GL_RENDERBUFFER<span class="token punctuation">,</span> rbo<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">glRenderbufferStorage</span><span class="token punctuation">(</span>GL_RENDERBUFFER<span class="token punctuation">,</span> GL_DEPTH24_STENCIL8<span class="token punctuation">,</span> width<span class="token punctuation">,</span> height<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">glBindRenderbuffer</span><span class="token punctuation">(</span>GL_RENDERBUFFER<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">glFramebufferRenderbuffer</span><span class="token punctuation">(</span>GL_FRAMEBUFFER<span class="token punctuation">,</span> GL_DEPTH_STENCIL_ATTACHMENT<span class="token punctuation">,</span> GL_RENDERBUFFER<span class="token punctuation">,</span> rbo<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">glCheckFramebufferStatus</span><span class="token punctuation">(</span>GL_FRAMEBUFFER<span class="token punctuation">)</span> <span class="token operator">!=</span> GL_FRAMEBUFFER_COMPLETE<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Framebuffer is not complete!"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">glBindFramebuffer</span><span class="token punctuation">(</span>GL_FRAMEBUFFER<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><font size="5" color="orange">绑定TFB后不能再激活着色器</font></p>
<hr>
<ol>
<li><p>在使用glBeginTransformFeedback激活Transform Feedback Buffer之后，就不能再使用glUseProgram去激活任何着色器了，直到glEndTransformFeedback之后才可以。如下程序：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token function">glBindBufferBase</span><span class="token punctuation">(</span>GL_TRANSFORM_FEEDBACK_BUFFER<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">*</span>CForwardLightCuts<span class="token operator">::</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">fetchTF_VBO</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token function">glBeginTransformFeedback</span><span class="token punctuation">(</span>GL_TRIANGLES<span class="token punctuation">)</span><span class="token punctuation">;</span>
 vModel<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span>vShader<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token function">glEndTransformFeedback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token function">glBindBufferBase</span><span class="token punctuation">(</span>GL_TRANSFORM_FEEDBACK_BUFFER<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 如果在render函数中使用了glUseProgram函数将会报错，正确的做法应该是在激活TFB的前面激活一次着    色器程序就可以了：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token function">glUseProgram</span><span class="token punctuation">(</span>vShader<span class="token punctuation">.</span><span class="token function">getProgram</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token function">glBindBufferBase</span><span class="token punctuation">(</span>GL_TRANSFORM_FEEDBACK_BUFFER<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">*</span>CForwardLightCuts<span class="token operator">::</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">fetchTF_VBO</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token function">glBeginTransformFeedback</span><span class="token punctuation">(</span>GL_TRIANGLES<span class="token punctuation">)</span><span class="token punctuation">;</span>
 vModel<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span>vShader<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token function">glEndTransformFeedback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token function">glBindBufferBase</span><span class="token punctuation">(</span>GL_TRANSFORM_FEEDBACK_BUFFER<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 注意同时需要移除render及其子函数中的所有glUseProgram调用。</p>
</li>
<li><p>Transform Feedback Buffer（TFB）虽然也是个Buffer，但是它和Uniform Buffer（UBO）、Shader Storage Buffer（SSBO）这些不同，UBO、SSBO这些通常意义上的Buffer都是可以在不同着色器程序（即不同Pass）之间共享的，在不同的着色器程序中都能访问同一个这样的Buffer。但是TFB却只是专属于某一个shader program，因为TFB会针对某个shader里的varying重新link其着色器程序，也就是说TFB只针对有varying的那个着色器有效，而对其他着色器程序是无效的，所以TFB是不能在不同着色器程序之间共享的，其他的着色器并不能通过绑定GL_TRANSFORM_FEEDBACK来访问TFB里的内容（需要将Buffer重新绑定到其他绑定点上，比如VBO）。</p>
</li>
</ol>
<p><font size="5" color="orange">纹理格式</font></p>
<hr>
<ol>
<li>在为帧缓冲添加纹理附件时，使用浮点型格式（GL_FLOAT），其帧率可能比使用无符号整型（GL_UNSIGNED_BYTE）低上一倍，所以在不需要用到-1到1之外的浮点型数据时，纹理格式还是最好使用（内部格式GL_RGBA等、外部格式GL_RGBA等，数据类型GL_UNSIGNED_BYTE）。因为OpenGL默认情况下会以无符号归一化格式存储纹理，纹素值在内存中以整数存储，整数在读进着色器时会转换到[0.0, 1.0]之间（如果指定是有符号归一化格式，如GL_R8_SNORM，则转换到[-1.0, 1.0]之间）。</li>
<li>GL_RGBA、GL_RGB这些不带数字大小的纹理内部格式，就是以无符号归一化格式存储的。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> OpenGL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OpenGL天坑 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Forward Light Cuts]]></title>
      <url>/2017/11/16/ForwardLightCuts/</url>
      <content type="html"><![CDATA[<p><font size="5" color="orange">Introduction</font></p>
<hr>
<ol>
<li><p>很多已有的辐射度缓存（Radiance Caching）方法会给场景中已经生成好的VPLs（即很多个虚拟点光源）建立树形结构，来计算给定点的入射辐射度（Incoming Radiance）。它们会把VPL作为树的叶子结点，然后把相似度相近的两个光源合成一个父结点。父结点中包含两个光源的总亮度值和轴对称包围盒（AABB）信息。重复该步骤，一直到只剩下一个结点为止，即根结点。这个过程有点像哈夫曼树的构建过程，只是这里是以光源的相识度作为标准而已。</p>
<p> 其中相似度通过如下公式来计算：<br> $$<br> W = I_c(\alpha_c^2 + c^2(1 - \cos\beta_c)^2)<br> $$<br> 其中$I_c$为两个光源的亮度之和，$\alpha_c$表示两个光源轴对齐包围盒（AABB）的对角线长度。对于聚光灯，常量c控制着空间大小与聚光灯方向相似性的相对缩放比例，常量c的大小与场景包围盒的对角线长度有关，$\beta_c$则是两个光源包围锥体的半角。对于点光源和平行光，常量c恒为0。W的值越小，则两个光源的相似度越高。</p>
<p> 但是这类方法至少有两个缺点：</p>
<ul>
<li>对于动态场景，每帧都要重新建树。</li>
<li>VPL太多。</li>
</ul>
</li>
<li>《Forward Light Cuts》这篇文章解决了这两个问题：<ul>
<li>用场景的三角形自己来触发创建VPL（使用几何着色器和细分着色器），其中会把太大的三角形（Divergent Triangle）进一步细分，把太过密集的三角形（Small Triangle）简化，即抛弃小三角形，不在上面创建VPL。</li>
<li>提出了一种随机聚类方法，把VPLs的子集和其影响到的有界区域关联起来，以此来计算其中某个点的辐射度。</li>
</ul>
</li>
<li>FLC方法的优点是可以适应完全动态的场景，无需任何像树这样的层次数据结构。</li>
</ol>
<p><font size="5" color="orange"> Previous Work</font></p>
<hr>
<ol>
<li>基于屏幕空间的方法用深度缓冲来替代实际的场景，虽然能够降低光照计算的复杂度，而且拥有很好的实时性和适应完全的动态场景，但是这类方法都依赖于深度剔除和多视角渲染，这样就需要考虑到离摄像机最近深度，以及视锥之外的场景了，这样一来，还是会导致渲染速率急剧下降，而且还存在一些视角依赖的问题，比如拖影（Ghosting Artifacts）。值得注意的是，在基于屏幕空间的方法中，VPL是在几何、细分着色器里基于每个三角形，借助GPU硬件的优势来生成的。</li>
<li><p>基于模型空间的方法能够避免这些视角依赖问题，比如立即辐射度（Indirect Radiance）方法，而RSM（Reflective Shadow Maps）方法更进一步，它提出了从光源视角（也叫光源空间）下生成VPLs的方法，在后来的发展中，又在RSM的基础上加上了针对RSM Pixels的聚类策略，只保留相关的光源，从而减少VPL的数量。但是在大场景下还是需要大量的VPL。</p>
<p> 这个问题可以用分层的方案来解决，典型的比如Light Cuts、Point-Based Global Illumination，它们可以用LOD点采样广场的形式来管理VPL，后来又用clustring shading（分开着色的改进版）来进一步达到大规模光源+复杂场景的实时性能。</p>
<p> 但是，这些基于模型空间的方法都是需要树形结构的，需要把建树的过程分摊到多帧来完成才能降低对帧率的影响，但是这却阻碍了完全动态场景的实现。</p>
</li>
<li>使用立即辐射度方法模拟间接光照有个难题：VPL和像素之间的可见性怎么确定。有很多方法来解决这个问题，比如用可以快速生成的不完全阴影贴图（Imperfect Shadow Maps，ISM），来近似计算可见性；再比如可以用虚拟面光源（Virtual Area Lights，VALs）方法能够减少可见性查询的次数，再从软阴影贴图计算软阴影时就能近似计算出可见性。后来又有人提出了记录VPL帧到帧的位置，直到VPL影响不到帧缓存里的像素才剔除它们，然后通过光线跟踪去采样VPLs来计算可见性。不过《Forward Light Cuts》这篇文章并没有解决可见性问题。</li>
<li>DDS（Deep Screen Space）方法剔除同时利用屏幕空间和模型空间的辐射度缓存。和模型空间策略一样，它同样是在几何表面上生成VPLs；和屏幕空间策略一样，它也同样地利用几何着色器和细分着色器来生成VPLs。虽然DDS在小中型场景中表现很好，但是却无法适用于大型场景，因为该方法为了达到实时性，会自动去掉大场景里的一些几何形状（比如Divergent Triangle），而不是进一步去细化它。</li>
<li>FLC方法比DDS更进一步，提出了一个Diffuse Global Illumination管线，用两个pass去细化和简化由几何驱动生成的VPL。优点是能够适应完全动态的大场景，而且无需任何层次数据结构。</li>
</ol>
<hr>
<p>参考文献：Laurent G, Delalandre C, Grégoire D L R, et al. Forward Light Cuts: A Scalable Approach to Real‐Time Global Illumination[J]. Computer Graphics Forum, 2016, 35(4):79-88.</p>
]]></content>
      
        <categories>
            
            <category> 全局光照 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 实时全局光照 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++Primer第二章变量和基本类型]]></title>
      <url>/2017/11/10/C++Primer%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/</url>
      <content type="html"><![CDATA[<p><font size="5" color="orange">基本内置类型</font><br><a id="more"></a></p>
<hr>
<ol>
<li>可寻址的最小内存块称为字节，存储的基本单元称为字。</li>
<li><p>字符型有3种：char、signed char和unsigned char。所以类型char和signed char并不一样，char既可能是有符号，有可能是无符号的，具体哪一种是由编译器决定的。</p>
<p>所以，在算术表达式中不要使用char和bool，只有在存放字符或布尔值时才使用它们。因为类型char在一些机器上是有符号的，而在另一些机器上又是无符号的，所以如果使用char进行运算特别容易出问题。如果需要使用一个不大的整数，那么明确指定它的类型是signed char或者unsigned char。int、short、long和long long都是有符号的。</p>
</li>
<li>执行浮点数运算时选用double，这是因为float通常精度不够而且双精度浮点数和单精度浮点数的计算代价相差无几。事实上，对于某些机器来说，双精度运算甚至比单精度还快。</li>
<li>可以给无符号char赋以可表示范围之外的值，但是有符号char却不能，否则它的值将是未定义的：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> c <span class="token operator">=</span> <span class="token number">256</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//c的值等于0</span>
 <span class="token keyword">signed</span> <span class="token keyword">char</span> c2 <span class="token operator">=</span> <span class="token number">256</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//c2的值未定义</span>
 std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>c <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>c2 <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
 虽然上面的程序可能正常运行，但是c2的值确实是未定义的。当给有符号类型赋以一个超出它可表示范围之外的值时，结果是未定义的。此时，程序可能继续工作、可能崩溃、也可能产生垃圾数据。</li>
<li>不要在表达式中混用带符号和无符号类型。<br>比如对于无符号数的自减操作：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> u <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> u <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>u<span class="token punctuation">)</span>
     std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> u <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
这个程序会陷入死循环。因为u是无符号数，减到0时，再减1会变成unsigned int类型可表示的最大整数，永远不会小于0。<br>再比如在混用带符号数和无符号数的表达式中，带符号数会自动转换为无符号数：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">unsigned</span> u <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
 <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">42</span><span class="token punctuation">;</span>
 std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> u <span class="token operator">+</span> i <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//，如果int占32位，输出4294967264</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li>如下面一组整型数字：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token number">20</span> <span class="token comment" spellcheck="true">/*十进制*/</span>    <span class="token number">024</span> <span class="token comment" spellcheck="true">/*八进制*/</span>    <span class="token number">0x14</span> <span class="token comment" spellcheck="true">/*十六进制*/</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
 虽然这些数字都表示数字20，但是实际上它们不都是一样的。因为默认情况下，十进制字面值是带符号数，而八进制和十六进制既可能是带符号的也可能是无符号的。十进制字面值的类型是能够容纳其数值的int、long和long long中尺寸最小的那个，而八进制和十六进制字面值的类型是能够容纳其数字的int、unsigned int、long、unsigned long、long long和unsigned long long中的尺寸最小者。</li>
<li>默认的浮点型字面值是一个double，可以加f后缀让其变成float型，加L变成long double型。还有一些不太常见的字面值前缀或者后缀：<pre class="line-numbers language-cpp"><code class="language-cpp"> L<span class="token string">'a'</span>      <span class="token comment" spellcheck="true">//宽字符型字面值，类型是wchar_t</span>
 u8<span class="token string">"hi!"</span>   <span class="token comment" spellcheck="true">//utf-8字符串字面值（utf-8用8位编码一个Unicode字符）</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li>编译器会在每一个字符串字面值的结尾处添加一个空字符’\0’。</li>
<li>C++除了’\n’等等转义字符外，还可以使用泛化的转义序列，其形式是\x后紧跟1个或多个十六进制数字，或者\后紧跟1个、2个或3个八进制数字。<br>如下：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"\x4d"</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\115"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//输出M M</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
 要注意的是，反斜线\后面跟着的八进制数字超过3个时，只有前3个数字与\构成转义序列，如下：<pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"\1234"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//输出S4</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
 “\1234”只表示2个字符，八进制数123对应的字符S以及字符4。</li>
</ol>
<p><font size="5" color="orange">变量</font></p>
<hr>
<ol>
<li>初始化不是赋值，初始化的含义是创建变量时赋予其一个某一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代。</li>
<li>在C++11中，可以用花括号来初始化变量（也叫列表初始化）：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> n<span class="token punctuation">{</span> <span class="token number">10</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
 当用于内置类型的变量时，这种初始化形式有一个重要特点：如果我们使用列表初始化且初始值存在丢失信息的风险，编译器会报错。这在C++11之前通过等号或者括号来初始化变量是做不到的，如下：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> a<span class="token punctuation">{</span> <span class="token number">3.14</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//编译失败，因为存在信息丢失的危险</span>
 <span class="token keyword">int</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token number">3.14</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//编译通过，但是因为类型转换丢失了部分值</span>
 <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//编译通过，但是因为类型转换丢失了部分值</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>定义在函数体外的变量会被默认初始化，但定义在函数内部的局部变量是不会被默认初始化的，它的值将是未定义的，如果试图拷贝或以其他形式访问此类值将引发错误：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> m<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//初始化为0</span>
 <span class="token keyword">char</span> c<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//初始化为空字符'\0'</span>

 <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
 <span class="token punctuation">{</span>
     std<span class="token operator">::</span>string str<span class="token punctuation">;</span>
     std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> str <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//编译通过，因为str是对象，std::string规定该对象默认初始化为空串""</span>
     <span class="token keyword">int</span> n<span class="token punctuation">;</span>
     std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> n <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//编译报错，n没有被默认初始化</span>
     <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 不过类对象如果没有显示地初始化，则其值由类确定，如上面的str对象。</p>
<p> 所以，建议初始化每一个内置类型的变量。为初始化的变量含有一个不确定的值，使用未初始化变量的值是一种错误的编程行为并且很难调试，因为严格来说，编译器并未被要求检查此类错误（虽然大多数编译器都会对一部分使用未初始化变量的行为提出警告），使用未初始化的变量将带来无法预计的后果。</p>
</li>
<li><p>如果想要声明一个变量而非定义它，可以在变量名前面加关键字extern，而不要显式地初始化变量：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> i<span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//声明并定义i</span>
 <span class="token keyword">extern</span> <span class="token keyword">int</span> j<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//声明j而非定义j</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p> 但是如果给extern声明的变量赋初值，那么就变成定义了：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">extern</span> <span class="token keyword">double</span> PI <span class="token operator">=</span> <span class="token number">3.1415926</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//声明并定义PI（不能在函数内部对extern声明的变量赋初值）</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p> 变量只能被定义一次，但是可以被多次声明，即可以多次extern同一变量。</p>
</li>
</ol>
<p><font size="5" color="orange">复合类型</font></p>
<hr>
<ol>
<li>引用本身不是一个对象，只是某一个对象的别名。</li>
<li>因为无法令引用重新绑定到另外一个对象上，所以引用必须被初始化（重新绑定的话会重复定义标识符）。</li>
<li>因为引用本身不是一个对象，所以不能定义引用的引用，即不能给别名再起一个别名。</li>
<li>允许在一条语句中定义多个引用，其中每个引用标识符都必须以符号&amp;开头（指针也是类似）：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
 <span class="token keyword">int</span> <span class="token operator">&amp;</span>i <span class="token operator">=</span> n<span class="token punctuation">,</span> j <span class="token operator">=</span> n<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//i是n的引用，但j是int</span>
 <span class="token keyword">int</span> <span class="token operator">&amp;</span>i2 <span class="token operator">=</span> n<span class="token punctuation">,</span> <span class="token operator">&amp;</span>j2 <span class="token operator">=</span> n<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//i2和j2都是n的引用</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>引用和指针的类型都要和与之绑定的对象严格匹配：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">double</span> d <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span>
 <span class="token keyword">int</span> <span class="token operator">&amp;</span>i <span class="token operator">=</span> d<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//编译报错，引用类型和绑定的对象类型不符</span>
 <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
 <span class="token keyword">double</span> <span class="token operator">&amp;</span>m <span class="token operator">=</span> n<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//编译报错，引用类型和绑定的对象类型不符</span>

 <span class="token keyword">double</span> dd <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span>
 <span class="token keyword">int</span> <span class="token operator">*</span>pi <span class="token operator">=</span> <span class="token operator">&amp;</span>d<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//编译报错，指针类型和指向的对象类型不符</span>
 <span class="token keyword">int</span> nn <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
 <span class="token keyword">double</span> <span class="token operator">*</span>pm <span class="token operator">=</span> <span class="token operator">&amp;</span>nn<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//编译报错，指针类型和指向的对象类型不符</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>引用和指针有很多不同点：<ul>
<li>指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象，但是引用本身不是对象，一旦初始化后就不能被重新绑定到其他对象上。</li>
<li>指针无须在定义时赋初值，但是引用必须在定义时初始化。</li>
</ul>
</li>
<li>和其他内置类型一样，在函数内部的指针也不会被默认初始化，也将拥有一个不确定的值。</li>
<li>因为引用不是对象，没有实际地址，所以不能定义指向引用的指针。</li>
<li>因为指针类型代表了其所指向对象的类型，通过类型才知道其指向对象的存储大小等等信息，才可以对它进行操作，所以指针类型和其指向对象的类型必须匹配（引用也是同理）。</li>
<li>编译器可能不会检查无效指针和未初始化的变量，所以一定要记得初始化。</li>
<li>“*“不仅是指针声明符，也是解引用符，所以通过*p能够访问到指针p所指向的对象。</li>
<li>给指针赋空值有以下3种方法：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//等价于int *p1 = 0;</span>
<span class="token keyword">int</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">*</span>p3  <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//等价于int *p3 = 0;不过需要先#include cstdlib</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
得到空指针最好的方法就是使用字面值nullptr来初始化指针，因为它可以被转换成任意其他的指针类型。nullptr也是在C++11新标准中引入的。尽量避免使用NULL。</li>
<li>使用未经初始化的指针是引发运行时错误的一大原因。尽量先有对象，再有指向对象的指针，如果实在不清楚指针应该指向何处，也应该把它初始化为nullptr。</li>
<li>void*是一种特殊的指针类型，可用于存放任意类型对象的地址。不能直接操作void*指针所指的对象，因为我们并不知道这个对象到底是什么类型，也就无法确定能在这个对象上做哪些操作。</li>
<li>在声明或者定义指针（或引用）时，最好把*（或&amp;）与变量名连在一起。</li>
<li><p>对于如下类型语句：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">&amp;</span>r <span class="token operator">=</span> p<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>想弄清楚r的类型到底是什么，最简单的方法是从右向左阅读r的定义，离变量名最近的符号对变量的类型有最直接的影响。上面离变量名r最近的符号是&amp;，说明r是一个引用。那么声明符的其余部分说明了它引用的对象是什么类型，上面声明符中剩余的是int *，说明r是对一个int型指针的引用。</p>
<p>所以，面对一条比较复杂的指针或引用的声明语句时，从右向左阅读有助于弄清楚它的真实含义。</p>
</li>
</ol>
<p><font size="5" color="orange">const限定符</font></p>
<hr>
<ol>
<li>因为const对象一旦创建后其值就不能再改变，所以const对象必须初始化。</li>
<li>既可以用非const对象去初始化const对象，也可以用const对象去初始化非const对象。在拷贝时，无需在意双方是否是const，因为拷贝只是值传递，不会影响到原来的对象。</li>
<li><p>默认情况下，const对象被设定为仅在文件内有效。什么意思呢？我们先来看看下面的程序：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> A<span class="token punctuation">.</span>h<span class="token operator">:</span>
 <span class="token macro property">#<span class="token directive keyword">pragma</span> once</span>
 <span class="token keyword">class</span> <span class="token class-name">A</span>
 <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
     <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-cpp"><code class="language-cpp"> A<span class="token punctuation">.</span>cpp<span class="token operator">:</span>
 <span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"A.h"</span></span>
 <span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>

 <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>

 A<span class="token operator">::</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
     std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"A: "</span> <span class="token operator">&lt;&lt;</span> N <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-cpp"><code class="language-cpp"> main<span class="token punctuation">.</span>cpp<span class="token operator">:</span>
 <span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
 <span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"A.h"</span></span>

 <span class="token keyword">extern</span> <span class="token keyword">int</span> N<span class="token punctuation">;</span>

 <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
 <span class="token punctuation">{</span>
     A a<span class="token punctuation">;</span>
     std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"main: "</span> <span class="token operator">&lt;&lt;</span> N <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
     <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 由于在main.cpp文件里，并没有包含A.cpp，所以它不知道变量N的存在，想要使用变量N，需要在main.cpp里用extern关键字声明变量N，表示该变量是一个外部链接，在别的编译单元里有它的定义，所以在链接时，程序会因为它是外部链接而去找它的定义，所以main函数里也就可以识别到变量N了。那么我们再看下面的程序：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> A<span class="token punctuation">.</span>h<span class="token operator">:</span>
 <span class="token macro property">#<span class="token directive keyword">pragma</span> once</span>

 <span class="token keyword">class</span> <span class="token class-name">A</span>
 <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
     <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-cpp"><code class="language-cpp"> A<span class="token punctuation">.</span>cpp<span class="token operator">:</span>
 <span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"A.h"</span></span>
 <span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>

 <span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>

 A<span class="token operator">::</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
     std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"A: "</span> <span class="token operator">&lt;&lt;</span> N <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-cpp"><code class="language-cpp"> main<span class="token punctuation">.</span>cpp<span class="token operator">:</span>
 <span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
 <span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"A.h"</span></span>

 <span class="token keyword">extern</span> <span class="token keyword">const</span> <span class="token keyword">int</span> N<span class="token punctuation">;</span>

 <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
 <span class="token punctuation">{</span>
     A a<span class="token punctuation">;</span>
     std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"main: "</span> <span class="token operator">&lt;&lt;</span> N <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
     <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 程序变动很小，只是给变量N加上了const属性，但是此时编译却无法通过，main.cpp中识别不到变量N。这是因为默认情况下，const对象被设定为仅在文件内有效。所以在A.cpp中声明的常量N只能在该文件内被访问了。如果想要在不同的相互独立的文件之间共享这个常量怎么办呢？可以在A.cpp中定义该常量的时候加上extern关键字，即：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> A<span class="token punctuation">.</span>cpp<span class="token operator">:</span>
 <span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"A.h"</span></span>
 <span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>

 <span class="token keyword">extern</span> <span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>

 A<span class="token operator">::</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
     std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"A: "</span> <span class="token operator">&lt;&lt;</span> N <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 所以，如果想在多个独立的文件之间共享const对象，必须在变量的定义之前添加extern关键字。<br> 【注】：注意是在相互独立的文件之间，比如上面main.cpp和A.cpp文件并不存在#include这种包含关系。如果把定义常量A的语句写到A.h中，main.cpp当然可以访问到了，因为它包含了A.h，这时A.h和main.cpp不是相互独立的文件。不过在头文件中定义全局变量通常不是好的做法。</p>
</li>
<li>如下语句：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">const</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
 <span class="token keyword">int</span> <span class="token operator">&amp;</span>j <span class="token operator">=</span> i<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//错误：试图让一个非常量引用绑定到常量引用上</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
 这时非法的，因为如果合法的话，则可以通过j来改变它引用对象i的值，这显然是不正确的。</li>
<li><p>看如下程序：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">double</span> d <span class="token operator">=</span> <span class="token number">10.0</span><span class="token punctuation">;</span>
 <span class="token keyword">int</span> <span class="token operator">&amp;</span>i <span class="token operator">=</span> d<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//错误：不能用double类型的值去初始化int &amp;类型的引用</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p> 错误还是很明显的，如果正确的话，那我们就可以用用操作整型变量的方式来改变d的值了，这显然是和double类型的d冲突。<br> 再看如下程序：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">double</span> d <span class="token operator">=</span> <span class="token number">10.0</span><span class="token punctuation">;</span>
 <span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>i <span class="token operator">=</span> d<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//正确</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p> 为什么加上const之后就正确了？这是因为加上const之后，我们就不能再改变i的值了，也就不能通过整型变量i来改变double型变量d了，所以合法。</p>
<p> 我们再从编译的角度来看一下这个程序：<br> 在初始化引用或者指针时，编译器会自动进行类型检查，如果类型不符，会先生成临时量。比如上面的<code>const int &amp;i = d;</code>，由于d是double型而非int型，所以编译器会把上述代码变成如下形式：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">const</span> <span class="token keyword">int</span> temp <span class="token operator">=</span> d<span class="token punctuation">;</span>
 <span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>i <span class="token operator">=</span> temp<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p> 虽然此时i实际上是临时量的别名，但是由于i是常量对象的引用，i的值不可能再变，所以它到底是临时量还是原对象的引用都无关紧要了。如果输出i和d的地址，会得到不同的结果：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">double</span> d <span class="token operator">=</span> <span class="token number">10.0</span><span class="token punctuation">;</span>
 <span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>i <span class="token operator">=</span> d<span class="token punctuation">;</span>
 std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>d <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>i <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//输出00E7FD84 00E7FD6C</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p> 但是对于之前的<code>int &amp;i = d;</code>，如果合法的话，编译器也会有类似上面的变换：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> temp <span class="token operator">=</span> d<span class="token punctuation">;</span>
 <span class="token keyword">int</span> <span class="token operator">&amp;</span>i <span class="token operator">=</span> temp<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p> 同样的，i还是临时量的引用，改变i的值其实改变的是临时量的值，而不是d的，但是<code>int &amp;i = d;</code>的语义就包括了可以通过改变i来改变d的潜在意图，所以矛盾了，所以该语句是非法的。</p>
<p> 类似的，下面的语句也是非法的：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>i <span class="token operator">=</span> <span class="token operator">&amp;</span>d<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//错误</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p> 如果合法的话，编译器会把它转换成如下形式：</p>
<pre><code> const int temp = d;
 const int *i = &amp;temp;
</code></pre><p> 虽然*i是常量，不会被改变，但是指针i本身是可以被改变的。比如对于i++，对于前者应该得到的是d的地址加4个字节，但是对于后者得到的却是临时量temp的地址加4个字节，所以该语句也是非法的。</p>
</li>
<li>注意区分常量指针和指向常量的指针：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
 <span class="token keyword">int</span> <span class="token operator">*</span><span class="token keyword">const</span> pi <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//常量指针</span>
 <span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>pI <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//指向常量的指针</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li>常量指针必须被初始化，而且一旦初始化完成，则它的值（也就是存放在指针中的那个地址）就不能再改变了：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
 <span class="token keyword">int</span> <span class="token operator">*</span><span class="token keyword">const</span> pi <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li>顶层const表示指针本身是个常量，而底层const表示指针所指的对象是一个常量。其实不止指针，普通变量也可以有底层/顶层const属性。</li>
<li>常量和常量表达式是不一样的，常量是变量在被初始化后就不能再被修改，而常量表达式更严格，还需要在编译时就能确定其初始值。如下代码：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">const</span> <span class="token keyword">int</span> sz <span class="token operator">=</span> <span class="token function">getSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
 sz是一个常量，但不是常量表达式。因为它的初始值，需要getSize函数运行后才能知道，不是在编译时就确定的。</li>
<li><p>C++11规定，用constexpr声明的变量是常量表达式，如果它的初始值不是常量表达式，那么语句会报错：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">constexpr</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//正确，因为初始值20是常量表达式</span>
<span class="token keyword">constexpr</span> <span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//正确，因为初始值i+1是常量表达式</span>
<span class="token keyword">constexpr</span> <span class="token keyword">int</span> sz <span class="token operator">=</span> <span class="token function">getSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//只有getSize是一个constexpr函数时才正确</span>
<span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">constexpr</span> <span class="token keyword">int</span> m <span class="token operator">=</span> n<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//错误，因为初始值n需要在运行时才能确定具体值</span>
<span class="token keyword">constexpr</span> std<span class="token operator">::</span>string str <span class="token operator">=</span> <span class="token string">"asd"</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//错误，因为string类型不属于字面值类型</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>为了在编译时就确定值，所以常量表达式的初始值都是字面值类型，包括算术类型、引用和指针，但是不包括string等复杂类型。所以string类型变量不能被声明为常量表达式，即不能用constrexpr声明。</p>
<p>如果我们认为某个变量是一个常量表达式，那么就应该把它声明为constexpr类型。</p>
</li>
<li>用constexpr声明的指针是常量指针，初始值必须为空，或者存在在固定地址的某个对象的地址。限定符constexpr仅仅对指针有效，对指针所指向的对象无关。</li>
<li>如下语句：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">&amp;</span>i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//非法，因为10是一个常量</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>j <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//合法，因为10是一个常量</span>
<span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>k <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//非法，因为10的内存地址不是编译时确定的</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<p><font size="5" color="orange">处理类型</font></p>
<hr>
<ol>
<li>using和typedef基本等价，都可以为内置类型和自定义类型设置别名。<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">typedef</span> <span class="token keyword">double</span> _Double<span class="token punctuation">;</span>
 _Double d <span class="token operator">=</span> <span class="token number">10.0</span><span class="token punctuation">;</span>
 <span class="token keyword">using</span> _Int <span class="token operator">=</span> <span class="token keyword">int</span><span class="token punctuation">;</span>
 _Int i <span class="token operator">=</span> <span class="token number">14</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>如下语句：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">typedef</span> <span class="token keyword">char</span> <span class="token operator">*</span>pstr<span class="token punctuation">;</span>
 <span class="token keyword">const</span> pstr str <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//str是指向char型对象的常量指针</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
 对于声明中的别名不要把它替换回原来的内容来理解，比如上面的语句把pstr替换后成为如下形式：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>str <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//str是指向char型常量的指针</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
 这种理解是错误的。pstr实际上是指向char的指针，所以const pstr就是指向char的常量指针，而非指向常量字符的指针。</li>
<li>auto这个类型说明符可以让编译器通过初始值来推算变量的类型，所以，Auto定义的变量必须有初始值。</li>
<li>如果使用auto一次声明多个变量，那么这些变量的初始值类型都应该一样：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">auto</span> i <span class="token operator">=</span> <span class="token number">14</span><span class="token punctuation">,</span> d <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//错误，i和d的类型不一致</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li>auto一般会忽略掉顶层const，保留底层const。即auto会去掉变量自己的const性质，但不会影响变量指向const对象的这个事实：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
 <span class="token keyword">const</span> <span class="token keyword">int</span> ci <span class="token operator">=</span> i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>cr <span class="token operator">=</span> ci<span class="token punctuation">;</span>
 <span class="token keyword">auto</span> b <span class="token operator">=</span> ci<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//b是int型（ci的顶层const特性被忽略掉了）</span>
 <span class="token keyword">auto</span> c <span class="token operator">=</span> cr<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//c是int型（cr是ci的别名，ci本身是一个顶层const）</span>
 <span class="token keyword">auto</span> d <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//d是int*类型（整型变量i的地址）</span>
 <span class="token keyword">auto</span> e <span class="token operator">=</span> <span class="token operator">&amp;</span>ci<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//d是指向常量的int*类型（整型常量ci的地址，对常量取地址是一种底层const）</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
 如果需要推断出的auto类型是一个顶层const，需要明确指出：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">const</span> <span class="token keyword">auto</span> f <span class="token operator">=</span> ci<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//auto去掉了ci的const特性，但是显式指定const让f变成了const int类型</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li>auto是通过初始值来推断声明的变量的类型，比如<code>auto i = 3.14;</code>，i的变量会被推断为double型，但是如果我们想要i的变量被推断为int型怎么办呢？可以用decltype这个类型指示符：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
 <span class="token keyword">decltype</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> i <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
 decltype可以根据表达式的值来推断变量的声明类型。括号里的表达式不止是变量，还可以是任何复杂表达式，甚至函数调用。</li>
<li>decltype和auto不一样，它会保留变量的顶层const和底层const以及引用符号&amp;。如下：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">const</span> <span class="token keyword">int</span> ci <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>cj <span class="token operator">=</span> ci<span class="token punctuation">;</span>
 <span class="token keyword">decltype</span><span class="token punctuation">(</span>ci<span class="token punctuation">)</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//x是const int类型</span>
 <span class="token keyword">decltype</span><span class="token punctuation">(</span>cj<span class="token punctuation">)</span> y <span class="token operator">=</span> x<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//y是const int&amp;类型，y绑定到x</span>
 <span class="token keyword">decltype</span><span class="token punctuation">(</span>cj<span class="token punctuation">)</span> z<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//错误，z是一个引用，必须初始化</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>decltype中如果表达式的内容是解引用操作，则decltype将得到引用类型。如下：<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">41</span><span class="token punctuation">,</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span>
 <span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span> j<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//错误，j是int&amp;类型，必须被初始化</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li>decltype((variable))（注意是双层括号）的结果永远是引用，而decltype（variable）结果只有当variable本身就是一个引用时才是引用。</li>
</ol>
<p><font size="5" color="orange">自定义数据结构</font></p>
<hr>
<ol>
<li>C++11规定，可以为类的成员数据提供类内初始值。创建对象时，类内初始值将用于初始化成员数据。没有初始值的成员将默认被初始化。<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">class</span> <span class="token class-name">A</span>
 <span class="token punctuation">{</span>
 <span class="token keyword">private</span><span class="token operator">:</span>
     <span class="token keyword">int</span> m_Data <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
     <span class="token keyword">double</span> m_Vlaue <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>头文件一旦改变，相关的源文件必须重新编译以获取更新过得声明。</li>
<li><p>确保头文件多次包含仍能安全工作的常用技术是预处理器，它由C++语言从C语言继承而来。预处理器是在编译之前执行的一段程序，可以部分地改变我们所写的程序。比如当预处理器看到#include标记时就会用指定的头文件的内容代替#include。</p>
<p> 预处理变量有两种状态：已定义和未定义。#define指定把一个名字设定为预处理变量，#ifdef当且仅当变量已定义时为真，#ifndef当且仅当变量未定义时为真。一旦检查结果为真，则执行后续操作直至遇到#endif为止。如下程序：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token macro property">#<span class="token directive keyword">ifndef</span> A_H</span>
 <span class="token macro property">#<span class="token directive keyword">define</span> A_H</span>
 <span class="token keyword">class</span> <span class="token class-name">A</span>
 <span class="token punctuation">{</span>
 <span class="token keyword">private</span><span class="token operator">:</span>
     <span class="token keyword">int</span> m_Data <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
     <span class="token keyword">double</span> m_Vlaue <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>
 <span class="token macro property">#<span class="token directive keyword">endif</span></span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>第一次包含A.h时，#ifndef的检查结果为真，预处理器将顺序执行后面的操作直至遇到#endif为止。此时，预处理变量A_H的将变为已定义，而且A.h也会被包含到主程序中来。后面如果再一次包含A.h，则#ifndef将为假，编译器将会忽略#ifndef到#endif之间的部分。</p>
</li>
<li>预处理变量无视C++语言中关于作用域的规则。</li>
<li>一般预处理变量的名字全部大写。<br>&nbsp; </li>
</ol>
<hr>
<p>参考文献：《C++Primer第五版》</p>
]]></content>
      
        <categories>
            
            <category> C++ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C++Primer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++Primer第一章开始]]></title>
      <url>/2017/11/04/C++Primer%E7%AC%AC%E4%B8%80%E7%AB%A0%E5%BC%80%E5%A7%8B/</url>
      <content type="html"><![CDATA[<p><font size="5" color="orange">编写一个简单的C++程序</font><br><a id="more"></a></p>
<hr>
<ol>
<li>在一些系统中，即使文件就在当前目录或文件夹中，也必须显式指出文件的位置。在此情况下，我们可以输入：<pre class="line-numbers language-cpp"><code class="language-cpp">$ <span class="token punctuation">.</span>\prog1
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
“.”后面跟一个反斜线可以指出该文件在当前目录中。</li>
<li>运行GNU编译器的命令是g++：<pre class="line-numbers language-cpp"><code class="language-cpp">$ g<span class="token operator">++</span> <span class="token operator">-</span>o prog1 prog1<span class="token punctuation">.</span>cc
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
其中，$是系统提示符；-o prog1是编译器参数，指定可执行文件的文件名；prog1.cc是代码源文件名。</li>
<li>运行微软VS编译器的命令为cl：<pre class="line-numbers language-cpp"><code class="language-cpp">C<span class="token operator">:</span>\User\me\Programs<span class="token operator">></span> cl <span class="token operator">/</span>EHsc prog1<span class="token punctuation">.</span>cpp
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
其中，C:\User\me\Programs&gt;是系统提示符，表示当前处于哪个路径下；命令cl可以调用编译器；/EHsc是编译器选项，用来打开标准异常处理。</li>
</ol>
<p><font size="5" color="orange">初识输入输出</font></p>
<hr>
<ol>
<li>术语“流”想要表达的是：随之时间的推移，字符是顺序生成或消耗的。</li>
<li>cerr通常用来输出警告和错误消息，clog用来输出程序运行时的一般性信息。如果是控制台程序的话，它俩和cout一样都是输出到控制台的。</li>
<li><p>如下语句：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Enter two numbers:"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>我们在输出语句中用了两次&lt;&lt;运算符。因为此运算符返回其左侧的运算对象，因此第一个运算符的结果成为了第二个运算符的左侧运算对象，即等价于：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token punctuation">(</span>std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Enter two numbers:"</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>其中std::endl被称为操纵符，写入endl的效果是结束当前行，并将于设备关联的缓冲区(buffer)中的内容刷到设备中。缓冲刷新操作可以保证到目前为止程序所产生的所有输出都真正写入输出流中，而不是仅停留在内存中等待写入流。所以：</p>
<p>程序员常常在调试时添加打印语句。这类语句应该保证“一直”刷新流。否则，如果程序崩溃，输出可能还留在缓冲区中，从而导致关于程序崩溃位置的错误推断。</p>
</li>
<li>标准库定义的所有名字都在命名空间std中。 </li>
</ol>
<p><font size="5" color="orange">注释简介</font></p>
<hr>
<ol>
<li>编译器会忽略注释，因此注释对程序的行为或性能不会有任何影响。</li>
<li>当我们修改代码时，不要忘记同时更新注释。</li>
</ol>
<p><font size="5" color="orange">控制流</font></p>
<hr>
<ol>
<li>如下程序：<br>```cpp<br>#include <iostream></iostream></li>
</ol>
<p>int main() {<br>    int sum = 0, value = 0;<br>    while (std::cin &gt;&gt; value)<br>        sum += value;<br>    std::cout &lt;&lt; “Sum is: “ &lt;&lt; sum &lt;&lt; std::endl;</p>
<pre><code>return 0;
</code></pre><p>}</p>
<pre><code>   当遇到文件结束符（end-of-file），或遇到一个无效输入时（例如读入的值不是一个整数），istream对象的状态才会变为无效，才会退出上面的while循环。所以仅仅输入空格或者回车，是无法让上述循环终止的。可以输入一个字符来终止循环：
```cpp
1 2 3  4 5
6   7
a
Sum is: 28
</code></pre><p>   除此之外，还可以输入文件结束符。在Windows系统中，输入文件结束符的方法是Ctrl+Z，然后按回车（Enter键），Unix系统中（包括Mac OS X系统），文件结束符输入是用Ctrl+D。</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span><span class="token operator">^</span>Z
Sum is<span class="token operator">:</span> <span class="token number">6</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><font size="5" color="orange">类简介</font></p>
<hr>
<ol>
<li>标准库头文件通常不带后缀（string.h不属于标准库头文件，string头文件才是）。</li>
<li><string.h>是旧的C头文件，对应的是基于char*的字符串处理函数（C++为了兼容C的标准库）；<string>是位于std中的C++头文件，对应的是基于string类的字符串处理函数；<cstring>是旧C头文件对应的std版本，所以也是基于char*的。</cstring></string></string.h></li>
<li>文件重定向：<pre class="line-numbers language-cpp"><code class="language-cpp">$ addIems <span class="token operator">&lt;</span>infile<span class="token operator">></span> outfile
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
$是操作系统提示符，addItems代表程序的可执行文件addItems.exe，则上述命令会从一个名为infile的文件读取输入，并将输出结果写入到一个名为outfile的文件中。用这种方法，我们就不必每次运行程序都往控制台手动输入一堆数据了。<br>&nbsp; </li>
</ol>
<hr>
<p>参考文献：《C++Primer第五版》</p>
]]></content>
      
        <categories>
            
            <category> C++ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C++Primer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OpenGL28：阴影映射]]></title>
      <url>/2017/11/03/OpenGL28%E9%98%B4%E5%BD%B1%E6%98%A0%E5%B0%84/</url>
      <content type="html"><![CDATA[<p><font size="5" color="orange">阴影的重要意义</font><br><a id="more"></a></p>
<hr>
<p>阴影是光线被阻挡的结果，它能够使场景看起来真实很多，可以让观察者获得物体之间的空间位置关系。如下图所示：</p>
<p><div align="center"><br><img src="http://oqcvzqam1.bkt.clouddn.com/OpenGL28%E9%98%B4%E5%BD%B1%E6%98%A0%E5%B0%841.png" alt=""><br>图1</div></p>
<p><div><br>可以看到，有阴影的时候能够更容易的看出立方体是悬浮在地板上的。</div></p>
<p>当前实时渲染领域还没找到一种完美的阴影算法，目前有几种近似阴影技术，但他它们都有自己的弱点和不足。游戏中常用的技术是阴影贴图（shadow mapping），效果不错，而且相对容易实现，性能也挺高，比较容易扩展为更高级的算法，如 <a href="http://learnopengl.com/#!Advanced-Lighting/Shadows/Point-Shadows" target="_blank" rel="external">Omnidirectional Shadow Maps</a>和 <a href="http://learnopengl.com/#!Advanced-Lighting/Shadows/CSM" target="_blank" rel="external">Cascaded Shadow Maps</a>。</p>
<p><font size="5" color="orange">阴影映射原理</font></p>
<hr>
<p>在绘制物体的某个片元时，要确定它是否在阴影中，就是要判断它是否被别的片元挡住了。而这个挡住其实是光线被挡住了，所以应该从光源位置看过去，看这个片元是否被其他片元挡住。如下图所示：</p>
<p><div align="center"><br><img src="http://oqcvzqam1.bkt.clouddn.com/OpenGL28%E9%98%B4%E5%BD%B1%E6%98%A0%E5%B0%842.png" alt=""><br>图2<br></div><br>判断是否被遮挡可以用深度贴图来实现：从光源处看过去（相当于把摄像机调整到光源的位置，即更改观察矩阵和投影矩阵，只是不渲染场景颜色而已），渲染一次场景（开启深度测试），将场景的深度值渲染到<a href="http://popperelay.cn/2017/01/21/OpenGL19%E5%B8%A7%E7%BC%93%E5%86%B2/" target="_blank" rel="external">自定义帧缓冲的深度纹理附件</a>中，此时深度纹理中存储的深度值就是离光源（或者说摄像机）最近的深度值，然后再渲染一次场景，这次渲染过程中判断当前片元的深度是否比对应位置上深度纹理中的深度更靠近光源（在屏幕空间里就是深度值更小），如果不是则说明该片元被挡住了，在阴影里。如下图所示：</p>
<p><div align="center"><br><img src="http://oqcvzqam1.bkt.clouddn.com/OpenGL28%E9%98%B4%E5%BD%B1%E6%98%A0%E5%B0%843.png" alt=""><br>图3<br></div><br>右图中，在光源看来C点和P点处在同一xy位置（以光源为原点的坐标系）上，但是深度z不同，P点的深度是0.9，C点的深度是0.4，存储在深度纹理中的应该是最靠近光源的0.4，在绘制点P时由于其深度值0.9比从深度纹理中取出的0.4大，所以判定点P被挡住了，应该位于阴影里。</p>
<p>综上，深度映射通过两个步骤完成：</p>
<ol>
<li>渲染深度纹理。</li>
<li>正常渲染场景，同时采样深度纹理来判断片元是否在阴影中。</li>
</ol>
<p>用代码表示如下：</p>
<pre class="line-numbers language-c++"><code class="language-c++">// 1. 首先渲染深度贴图
glViewport(0, 0, SHADOW_WIDTH, SHADOW_HEIGHT);
glBindFramebuffer(GL_FRAMEBUFFER, depthMapFBO);
    glClear(GL_DEPTH_BUFFER_BIT);
    ConfigureShaderAndMatrices();
    RenderScene();
glBindFramebuffer(GL_FRAMEBUFFER, 0);
// 2. 像往常一样渲染场景，但这次使用深度贴图
glViewport(0, 0, SCR_WIDTH, SCR_HEIGHT);
glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
ConfigureShaderAndMatrices();
glBindTexture(GL_TEXTURE_2D, depthMap);
RenderScene();
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><font size="5" color="orange">渲染深度纹理</font><br>我们需要从光源的视角去渲染得到一张场景的深度纹理，最后需要用它来计算阴影。为了将场景的深度保存到纹理中，我们需要用到帧缓冲，并且为它添加深度纹理附件：</p>
<pre class="line-numbers language-c++"><code class="language-c++">GLuint DepthMap;
    glGenTextures(1, &DepthMap);
    glBindTexture(GL_TEXTURE_2D, DepthMap);
    glTexImage2D(GL_TEXTURE_2D, 0, GL_DEPTH_COMPONENT, WIDTH, HEIGHT, 0, GL_DEPTH_COMPONENT, GL_FLOAT, NULL);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
    glBindTexture(GL_TEXTURE_2D, 0);

    GLuint DepthMapFBO;
    glGenFramebuffers(1, &DepthMapFBO);
    glBindFramebuffer(GL_FRAMEBUFFER, DepthMapFBO);
    glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_TEXTURE_2D, DepthMap, 0);
    glDrawBuffer(GL_NONE);
    glReadBuffer(GL_NONE);
    if (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE)
        std::cout << "Framebuffer is not complete!" << std::endl;
    glBindFramebuffer(GL_FRAMEBUFFER, 0);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面的代码首先创建了一张<code>GL_DEPTH_COMPONENT</code>格式的纹理，然后将它绑定到帧缓冲的深度附件上。</p>
<p>接下来我们需要从光源视角去渲染场景。先来看看着色器怎么写吧：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#version 330 core

layout (location = 0) in vec3 position;

uniform mat4 LightSpaceMVP;  //projection * view * model

void main()
{
    gl_Position = LightSpaceMVP * vec4(position,1.0f);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">#version 330 core

void main()
{
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到渲染深度纹理的着色器相当简单，在顶点着色器里只是需要一个在光源视角下的MVP矩阵（投影矩阵、观察矩阵和物体模型矩阵的乘积），来计算在光源视角下的顶点坐标。片元着色器可以是空的，因为我们只想得到深度，所以没有必要在片元着色器里输出颜色。<br>【注】：</p>
<ul>
<li>直接使用MVP矩阵，是为了避免每一个顶点着色器都去执行模型矩阵、观察矩阵、投影矩阵的乘法运算，减少GPU的运算量，只需要每帧在应用程序里计算一次MVP矩阵，然后传给顶点着色器即可。这样还减少了传输带宽，毕竟只需要给GPU传一个MVP矩阵，而不是三个矩阵。</li>
</ul>
<p>加下来需要我们在应用程序里算好这个LightSpaceMVP矩阵了：</p>
<pre class="line-numbers language-c++"><code class="language-c++">mat4 View = lookAt(lightPos, lightPos + lightDirection, vec3(0, 1, 0));
mat4 Projection = ortho(-6.0, 6.0, -6.0, 6.0, 0.1, 20.0);
mat4 LightSpaceVP = Projection * View;
mat4 CubeModel;
CubeModel = translate(CubeModel, glm::vec3(-1.0f, 0.0f, -1.0f));
mat4 LightSpaceMVPCube = LightSpaceVP * CubeModel;
mat4 PlaneModel;
PlaneModel = mat4();
mat4 LightSpaceMVPPlane = LightSpaceVP * PlaneModel;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>场景里面有两个物体：地面和箱子，它们都需要在上面的着色器下绘制一次，由于它们的模型矩阵不同，所以它们的MVP矩阵需要分开算。观察矩阵通过平行光源的位置和方向来计算，投影矩阵是一个正交投影矩阵（因为场景里用的是平行光源）。</p>
<p>然后我们绑定自定义帧缓冲，激活着色器渲染场景，就可以渲染出深度纹理了：</p>
<pre class="line-numbers language-c++"><code class="language-c++">glBindFramebuffer(GL_FRAMEBUFFER, DepthMapFBO);
glClear(GL_DEPTH_BUFFER_BIT);

GenerateDepthMap_Shader.Use();
glUniformMatrix4fv(glGetUniformLocation(GenerateDepthMap_Shader.shaderProgram, "LightSpaceMVP"), 1, GL_FALSE, value_ptr(LightSpaceMVPCube));
glBindVertexArray(cubeVAO);
glDrawElements(GL_TRIANGLES, 36, GL_UNSIGNED_INT, 0);

glUniformMatrix4fv(glGetUniformLocation(GenerateDepthMap_Shader.shaderProgram, "LightSpaceMVP"), 1, GL_FALSE, value_ptr(LightSpaceMVPPlane));
glBindVertexArray(planeVAO);
glDrawArrays(GL_TRIANGLES, 0, 6);
glBindVertexArray(0);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们可以用一张窗口四边形来渲染这张深度贴图：</p>
<pre class="line-numbers language-c++"><code class="language-c++">glBindFramebuffer(GL_FRAMEBUFFER, 0);
glClearColor(0.3f, 0.4f, 0.5f, 1.0f);
glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

RenderDepthMap_Shader.Use();
glBindVertexArray(windowQuadVAO);
glBindTexture(GL_TEXTURE_2D, DepthMap);
glDrawArrays(GL_TRIANGLES, 0, 6);
glBindVertexArray(0);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>渲染结果如下：<br><img src="http://oqcvzqam1.bkt.clouddn.com/OpenGL28%E9%98%B4%E5%BD%B1%E6%98%A0%E5%B0%844.png" alt=""><br>所有源码在<a href="https://github.com/Popperelay/BlogCode/tree/master/LearnOpenGL28_ShadowMap/LearnOpenGL28_ShadowMap_1" target="_blank" rel="external">这里</a>。</p>
<p><font size="5" color="orange">渲染阴影</font></p>
<hr>
<p>我们先来看看着色器怎么写。</p>
<p>顶点着色器和正常渲染场景时一样，只是多了计算顶点在光源视角下的裁剪坐标这一步：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#version 330 core

layout (location = 0) in vec3 position;
layout (location = 1) in vec2 texCoords;
layout (location = 2) in vec3 normal;

out vec2 VS_TexCoords;
out vec3 VS_Normal;
out vec3 VS_WorldPos;
out vec4 VS_LightSpacePos;

uniform mat4 u_LightSpaceMVP;  //projection * view * model
uniform mat4 u_Model;
uniform mat4 u_View;
uniform mat4 u_Projection;

void main()
{
    VS_TexCoords = texCoords;
    VS_Normal = transpose(inverse(mat3(u_Model))) * normal;
    VS_WorldPos = vec3(u_Model * vec4(position, 1.0f));
    gl_Position = u_Projection * u_View * vec4(VS_WorldPos, 1.0f);
    VS_LightSpacePos = u_LightSpaceMVP * vec4(position, 1.0f);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中u_LightSpaceMVP是光源视角下的模型矩阵、观察矩阵和投影矩阵的乘积。</p>
<p>将计算得到的顶点在光源视角下的裁剪坐标VS_LightSpacePos，传递给片元着色器，来计算阴影：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#version 330 core

in vec2 VS_TexCoords;
in vec3 VS_Normal;
in vec3 VS_WorldPos;
in vec4 VS_LightSpacePos;

out vec4 Color;

uniform sampler2D u_DiffuseMapSampler1;
uniform sampler2D u_DepthMapSampler2;
uniform vec3 u_LightPos;
uniform vec3 u_LightDirection;
uniform vec3 u_ViewPos;
uniform vec3 u_LightColor;

vec3 getDepthInLightSpace(vec4 vLightSpacePos)
{
    vec3 Temp = (vLightSpacePos / vLightSpacePos.w).xyz;
    Temp = Temp * 0.5 + 0.5;
    return Temp;
}

void main()
{
    vec3 ObjectColor = texture(u_DiffuseMapSampler1, VS_TexCoords).rgb;

    float AmbientStrength = 0.3f;
    vec3  AmbientColor = AmbientStrength * ObjectColor;

    vec3 LightClipSpacePos = getDepthInLightSpace(VS_LightSpacePos);
    if(LightClipSpacePos.z >= texture(u_DepthMapSampler2, LightClipSpacePos.xy).r + 0.01)
    {
        Color = vec4(AmbientColor * ObjectColor, 1.0);
        return;
    }

    vec3 Normal = normalize(VS_Normal);
    vec3 LightDir = normalize(-u_LightDirection);
    float DiffuseFactor = max(dot(Normal, LightDir), 0.0);
    vec3 DiffuseColor = DiffuseFactor * u_LightColor;

    vec3 ViewDir = normalize(u_ViewPos - VS_WorldPos);
    vec3 HalfDir = normalize(LightDir + ViewDir);
    float SpecularFactor = pow(max(dot(HalfDir, Normal), 0.0f), 32);
    vec3 SpecularColor = SpecularFactor * u_LightColor;

    Color = vec4((AmbientColor + DiffuseColor + SpecularColor) * ObjectColor, 1.0);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中在片元着色器里，我们需要计算插值后的片元在光源视角下的深度：</p>
<pre class="line-numbers language-c++"><code class="language-c++">vec3 getDepthInLightSpace(vec4 vLightSpacePos)
{
    vec3 Temp = (vLightSpacePos / vLightSpacePos.w).xyz;
    Temp = Temp * 0.5 + 0.5;
    return Temp;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>原理跟简单，就是模拟了一下透视除法，让xyz分量分别除以w分量（其实不除也可以，因为在我们的demo里用的是平行光，光源视角下的投影矩阵是正交投影，所以w分量其实是1，但是如果不是平行光，这一步还是必须要做的）。但是透视除法之后的坐标范围还是-1到1，而之后我们需要用这个坐标去查找之前的深度纹理，而且其z分量应该代表片元在光源视角下的深度，所以不应该有负数，我们需要把-1到1的范围映射到0到1，所以才有了：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    Temp = Temp * 0.5 + 0.5;
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>然后我们就可以根据这个坐标（片元在光源视角下的裁剪坐标并且映射到了0到1的范围）的xy值，去之前保存下来的深度纹理里查找场景在这个xy位置上距离光源最近的深度值，如果当前片元在光源视角下的深度值大于从纹理中查找到的深度值，则说明这个片元被挡住了，应该在阴影里：</p>
<pre class="line-numbers language-c++"><code class="language-c++">if(LightClipSpacePos.z >= texture(u_DepthMapSampler2, LightClipSpacePos.xy).r + 0.01)
{
    Color = vec4(AmbientColor * ObjectColor, 1.0);
    return;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里对阴影的处理方式是让片元的颜色等于环境光颜色，不再对它做漫反射和镜面反射光照了。</p>
<p>对于不满足这个条件，即不在阴影里的片元，照常执行blinn-phong光照即可。</p>
<p>剩下的就是在应用程序里把着色器需要的顶点数据和uniform变量传进来就可以了，由于这些内容和之前的文章里几乎是一样的，所以不再赘述了，所有源码都在<a href="">这里</a>。</p>
<p>运行结果如下图所示：<br><img src="http://oqcvzqam1.bkt.clouddn.com/OpenGL28%E9%98%B4%E5%BD%B1%E6%98%A0%E5%B0%845.png" alt=""></p>
<p><font size="5" color="orange">改进阴影贴图</font></p>
<hr>
<p><font size="4" color="red">阴影fighting</font><br>可以看到上面的阴影并不好，有很多条纹，这是由于深度贴图所能保存的精度有限，相邻的很多片元可能用的是同一个深度，如下图所示：<br><img src="http://oqcvzqam1.bkt.clouddn.com/OpenGL28%E9%98%B4%E5%BD%B1%E6%98%A0%E5%B0%846.png" alt=""><br>可能表示的最大深度只有6位，那么图中0.9276355到0.9276364的部分都只能用0.927636来表示了，但是getDepthInLightSpace函数计算出来的片元深度精度通常更大，导致在比较时，0.9276355到0.927636的部分，比深度纹理中存储的0.927636小，不处于阴影中，而0.927636到0.9276364的部分比深度纹理中存储的0.927636更大，处于阴影中，所以会出现一半不在阴影中，而另一半在阴影中，而这种精度情况在每一个类似的精度范围内都会出现，所以造成了上图里的条纹状。<br>【注：】</p>
<ul>
<li>这里只是举了个例子，最大精度不一定是6位小数，也不一定是四舍五入，要视具体运行环境和硬件决定。</li>
</ul>
<p>那么我们怎么避免这种深度精度问题呢？</p>
<p>我们可以在判断条件上加一个很小的偏移量：</p>
<pre class="line-numbers language-c++"><code class="language-c++">if(LightClipSpacePos.z >= texture(u_DepthMapSampler2, LightClipSpacePos.xy).r + 0.0009)
{
    Color = vec4(AmbientColor * ObjectColor, 1.0);
    return; 
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>运行结果如下图所示：<br><img src="http://oqcvzqam1.bkt.clouddn.com/OpenGL28%E9%98%B4%E5%BD%B1%E6%98%A0%E5%B0%847.png" alt=""><br>可以看到虽然很大程度上解决了条纹状问题，但是由于偏移量加得太小，在箱子的垂直表面上，坡度很大，导致上面还是有一些黑点，有两种方法可以解决：一种是加大偏移量，但是有可能会产生彼得潘效应（后文会介绍），另一种就是利用表面法线和光线的夹角来计算出一个偏移值，这样对于坡度大的地方偏移就大、对坡度小的地方偏移就很小：</p>
<pre class="line-numbers language-c++"><code class="language-c++">float Offset = max(0.0009, 0.0025 * (1.0 - dot(Normal, LightDir)));
if(LightClipSpacePos.z >= texture(u_DepthMapSampler2, LightClipSpacePos.xy).r + Offset)
{
    Color = vec4(AmbientColor * ObjectColor, 1.0);
    return; 
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>运行结果如下：<br><img src="http://oqcvzqam1.bkt.clouddn.com/OpenGL28%E9%98%B4%E5%BD%B1%E6%98%A0%E5%B0%848.png" alt=""></p>
<p>但是，偏移量加多少合适需要多次微调，加少了会有黑点，加多了会有彼得潘效应，其实即使是上面的代码，运行程序后拉近看依然有彼得潘效应。想要调出合适的偏移量很难，很容易出现彼得潘效应。下面来看看什么是彼得潘效应。</p>
<p><font size="4" color="red">彼得潘效应</font><br>当偏移加的偏大时，可以看到阴影相对实际物体的偏移，如下图所示（这个偏移值加得很大0.01）：<br><img src="http://oqcvzqam1.bkt.clouddn.com/OpenGL28%E9%98%B4%E5%BD%B1%E6%98%A0%E5%B0%849.png" alt=""><br>看起来像箱子漂浮在地面之上，但是实际上从顶点数据来看箱子是紧贴着地面的，这种错觉就是彼得潘效应（童话里彼得潘是个会飞的男孩……）。</p>
<p>经过代码实现，渲染阴影贴图时开启正面剔除依然不能消除彼得潘效应，只能用更精确的偏移值来让彼得潘效应更小，直到看不出来。</p>
<p><font size="4" color="red">光视锥外的阴影</font><br>在之前的片元着色器里，对于不在光源视角下的正交投影视锥里的片元，经过getDepthInLightSpace函数算出来的裁剪坐标绝对值将大于1，用这个坐标去索引深度纹理，当然得不到正确的深度值。因为默认深度纹理的环绕方式是repeat，所以导致在视锥之外的片元都处于阴影里，如下图所示：<br><img src="http://oqcvzqam1.bkt.clouddn.com/OpenGL28%E9%98%B4%E5%BD%B1%E6%98%A0%E5%B0%8410.png" alt=""></p>
<p>有两个解决方案：</p>
<ol>
<li>把正交投影矩阵的参数加大，让正交视锥能包含更大的区域。</li>
<li>如果当前正交视锥之外没有物体（或者没有需要投射阴影的物体），可以让视锥外的片元索引深度纹理得到的深度值总是1.0，这样这些片元就不会处在阴影里了。其实也就是想用绝对值大于1的坐标去索引深度纹理，总是得到1.0这个值，所以我们可以把深度纹理的环绕方式设为GL_CLAMP_TO_BORDER，让超出1.0的坐标永远得到的都是边界上的值，同时要设置边界颜色的r分量为1.0：<pre class="line-numbers language-c++"><code class="language-c++">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER);
GLfloat BorderColor[] = { 1.0,0.0,0.0,1.0 };
glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, BorderColor);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
结果如下图所示：<br><img src="http://oqcvzqam1.bkt.clouddn.com/OpenGL28%E9%98%B4%E5%BD%B1%E6%98%A0%E5%B0%8411.png" alt=""></li>
</ol>
<p>可以发现在视锥横截面之外的片元都不再处于阴影里了，远处还有片元处于阴影里，是因为那块区域超过视锥的远平面，计算出来的深度值是大于1.0的，会永远比从深度纹理中取出来的值要大，所以会处于阴影里。有两种解决方案：</p>
<ol>
<li>在正交投影矩阵里加大远平面的距离。</li>
<li>在片元着色器里计算裁剪坐标的时候，如果最后发现裁剪坐标的z值大于1.0，则把其z值强制更改为0：<pre class="line-numbers language-c++"><code class="language-c++">vec3 getDepthInLightSpace(vec4 vLightSpacePos)
{
 vec3 Temp = (vLightSpacePos / vLightSpacePos.w).xyz;
 Temp = Temp * 0.5 + 0.5;
 if(Temp.z > 1.0)
     Temp.z = 0.0;
 return Temp;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<p>运行结果如下图：<br><img src="http://oqcvzqam1.bkt.clouddn.com/OpenGL28%E9%98%B4%E5%BD%B1%E6%98%A0%E5%B0%8412.png" alt=""><br>到此的所有源码都在<a href="https://github.com/Popperelay/BlogCode/tree/master/LearnOpenGL28_ShadowMap/LearnOpenGL28_ShadowMap_2" target="_blank" rel="external">这里</a>。其中解开一些注释代码就能看到这一小节说过的各种结果。</p>
<p><font size="4" color="red">PCF</font><br>拉近了看，会发现阴影边缘走样很严重，有明显的锯齿，如下图所示：<br><img src="http://oqcvzqam1.bkt.clouddn.com/OpenGL28%E9%98%B4%E5%BD%B1%E6%98%A0%E5%B0%8413.png" alt=""><br>这是因为深度纹理的分辨率有限，多个片元可能对应同一个阴影，这样采样计算阴影时就会产生锯齿边。当然可以通过增加深度纹理分辨率的方式来降低锯齿块。但是这样会增加很多内存开销。</p>
<p>我们可以用一种叫做PCF（percentage-closer filtering）的技术来得到更柔和一点的阴影：对片元裁剪坐标的四周多次采样，对采样的结果（在或者不在阴影里）求均值。实现代码如下：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#version 330 core

in vec2 VS_TexCoords;
in vec3 VS_Normal;
in vec3 VS_WorldPos;
in vec4 VS_LightSpacePos;

out vec4 Color;

uniform sampler2D u_DiffuseMapSampler1;
uniform sampler2D u_DepthMapSampler2;
uniform vec3 u_LightPos;
uniform vec3 u_LightDirection;
uniform vec3 u_ViewPos;
uniform vec3 u_LightColor;

vec3 getDepthInLightSpace(vec4 vLightSpacePos)
{
    vec3 Temp = (vLightSpacePos / vLightSpacePos.w).xyz;
    Temp = Temp * 0.5 + 0.5;
    //远平面外的深度值更改为0.0
    if(Temp.z > 1.0)
        Temp.z = 0.0;
    return Temp;
}

void main()
{
    vec3 ObjectColor = texture(u_DiffuseMapSampler1, VS_TexCoords).rgb;

    //Ambient Lighting
    float AmbientStrength = 0.3f;
    vec3  AmbientColor = AmbientStrength * ObjectColor;

    vec3 LightClipSpacePos = getDepthInLightSpace(VS_LightSpacePos);

    vec3 Normal = normalize(VS_Normal);
    vec3 LightDir = normalize(-u_LightDirection);

    //PCF阴影测试
    float Offset = max(0.002, 0.0025 * (1.0 - dot(Normal, LightDir)));
    float Shadow = 0.0;
    vec2 texelSize = 1.0 / textureSize(u_DepthMapSampler2, 0);

    if(LightClipSpacePos.z != 0.0)
    {
        for(int x = -1; x <= 1; ++x)
        {
            for(int y = -1; y <= 1; ++y)
            {
                if(LightClipSpacePos.z >= texture(u_DepthMapSampler2, LightClipSpacePos.xy + vec2(x, y) * texelSize).r + Offset)
                    Shadow += 1.0;
            }
        }
    }
    Shadow /= 9.0;

    //Diffuse Lighting
    float DiffuseFactor = max(dot(Normal, LightDir), 0.0);
    vec3 DiffuseColor = DiffuseFactor * u_LightColor;

    //Specular Lighting
    vec3 ViewDir = normalize(u_ViewPos - VS_WorldPos);
    vec3 HalfDir = normalize(LightDir + ViewDir);
    float SpecularFactor = pow(max(dot(HalfDir, Normal), 0.0f), 32);
    vec3 SpecularColor = SpecularFactor * u_LightColor;

    Color = vec4((AmbientColor + (1.0 - Shadow) * (DiffuseColor + SpecularColor)) * ObjectColor, 1.0);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中texelSize 是深度纹理中每个纹素的大小。</p>
<p>运行结果如下图所示：<br><img src="http://oqcvzqam1.bkt.clouddn.com/OpenGL28%E9%98%B4%E5%BD%B1%E6%98%A0%E5%B0%8414.png" alt=""><br>可以发现，阴影边缘确实较之前柔和了一些。</p>
<p>所有源码请看<a href="https://github.com/Popperelay/BlogCode/tree/master/LearnOpenGL28_ShadowMap/LearnOpenGL28_ShadowMap_3" target="_blank" rel="external">这里</a>。</p>
<p><font size="5" color="orange">透视投影渲染深度贴图</font></p>
<hr>
<p>之前用的是正交投影来渲染深度纹理，这对于平行光比较适用，但是对于点光源和聚光灯，透视投影更适合。只是透视投影渲染得到的深度纹理里的深度值是非线性的，有两种就解决方案：</p>
<ol>
<li>在片元着色器里，计算片元在光源视角下的裁剪坐标时，手动做一次透视除法，这样也就变为非线性的深度。</li>
<li>不在片元着色器里计算片元的裁剪坐标，计算到它在观察空间里的深度就好了，然后把从深度纹理中的非线性深度转变为观察空间里的线性深度。怎么转换呢？可以参考<a href="http://popperelay.cn/2017/01/14/OpenGL15%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95/" target="_blank" rel="external">《OpenGL15：深度测试》</a>里说过的非线性深度公式：<br>$$<br>\begin{equation}<br>F_{depth} = \frac{1/z - 1/near}{1/far - 1/near}<br>\end{equation}<br>$$<pre class="line-numbers language-c++"><code class="language-c++">float LinearizeDepth(float depth)
{
 float z = depth * 2.0 - 1.0; // Back to NDC 
 return (2.0 * near_plane * far_plane) / (far_plane + near_plane - z * (far_plane - near_plane));
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
&nbsp; </li>
</ol>
<hr>
<p>参考文献：<a href="https://learnopengl.com/" target="_blank" rel="external">LearnOpenGL</a></p>
]]></content>
      
        <categories>
            
            <category> OpenGL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ShadowMap </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[老张培训笔记第五课责任链模式和适配器模式]]></title>
      <url>/2017/08/31/%E8%80%81%E5%BC%A0%E5%9F%B9%E8%AE%AD%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%BA%94%E8%AF%BE/</url>
      <content type="html"><![CDATA[<p>感谢老张！<br><a id="more"></a></p>
<hr>
<p>案例：实现员工请假系统，要求如下：</p>
<ul>
<li>公司有三个级别的可以批假的员工，其批假权限为：<ul>
<li>TeamLeader：可以批准10天以内的请假。</li>
<li>ProjectLeader：可以批准20天以内的请假。</li>
<li>HR：可以批准30天以内的请假。</li>
<li>30天以上的假期不能批准，只能离职。</li>
</ul>
</li>
<li>审批流程：先由TeamLeader进行审批，若权限不够则交由ProjectLeader处理，若权限还不够则交由HR处理。</li>
</ul>
<p>分析上述案列，我们需要实现如下几个功能：</p>
<ul>
<li>审批流程：TeamLeader→ProjectLeader→HR。</li>
<li>审批权限：每级都有自己独立的审批权限。</li>
<li>审批：审批动作本身。</li>
</ul>
<p><font size="5" color="orange">最常见的方式</font></p>
<hr>
<p>通常最容易想到的就是按C语言的方式在主程序里通过if-else的判断来实现这种逐级处理。</p>
<p>我们先把请假请求封装成一个类，当中有一个表示请假天数的成员变量（封装成类是为了后续需求变化考虑，因为可能请假可能不仅考虑到天数，还考虑到职位、在团队里的重要性等等）：</p>
<pre class="line-numbers language-c++"><code class="language-c++">class CLeaveRequest {
public:
    CLeaveRequest() {}
    CLeaveRequest(int vLeaveDays) : m_LeaveDays(vLeaveDays) {}

    int getLeaveDays() const { return m_LeaveDays; }

private:
    int m_LeaveDays;
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们再创建一个员工的基类（依赖倒置原则），它只有一个表示审批动作本身的函数，至于通不通过我们在主程序里通过if-else去实现：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#include "LeaveRequest.h"

class CEmployee{
public:
    virtual void approveLeaveV(const CLeaveRequest *vLeaveRequest) const = 0;
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后实现员工类的3个子类，它们各自有自己具体的审批动作：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>
#include "Employee.h"

class CTeamLeader : public CEmployee{
public:
    virtual void approveLeaveV(const CLeaveRequest *vLeaveRequest) const override {
        std::cout << "The leave request of" << vLeaveRequest->getLeaveDays() << " days has been approved by team leader." << std::endl;
    }
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>
#include "Employee.h"

class CProjectLeader : public CEmployee {
public:
    virtual void approveLeaveV(const CLeaveRequest *vLeaveRequest) const override {
        std::cout << "The leave request of" << vLeaveRequest->getLeaveDays() << " days has been approved by project leader." << std::endl;
    }
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>
#include "Employee.h"

class CHR : public CEmployee {
public:
    virtual void approveLeaveV(const CLeaveRequest *vLeaveRequest) const override {
        std::cout << "The leave request of" << vLeaveRequest->getLeaveDays() << " days has been approved by HR." << std::endl;
    }
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后我们在主函数里创建请求以及三类员工的对象：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#include "TeamLeader.h"
#include "ProjectLeader.h"
#include "HR.h"

int main() {
    CTeamLeader *pTeamLeader = new CTeamLeader;
    CProjectLeader *pProjectLeader = new CProjectLeader;
    CHR *pHR = new CHR;
    CLeaveRequest *pLeaveRequest = new CLeaveRequest(25);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后从TeamLeader开始，使用if-else判断请假类里的天数是否满足他的天数限制，如果不满足，则看是否满足他的上司的天数限制，以此类推：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    if (pLeaveRequest->getLeaveDays() < 10) {
        pTeamLeader->approveLeaveV(pLeaveRequest);
    }
    else {
        if (pLeaveRequest->getLeaveDays() < 20) {
            pProjectLeader->approveLeaveV(pLeaveRequest);
        }
        else {
            if (pLeaveRequest->getLeaveDays() < 30) {
                pHR->approveLeaveV(pLeaveRequest);
            }
            else {
                std::cout << "The only way to get " << pLeaveRequest->getLeaveDays() << " leave days to quit the company." << std::endl;
            }
        }
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>程序输出的结果如下：</p>
<pre class="line-numbers language-c++"><code class="language-c++">The leave request of 25 days has been approved by HR.
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>但是这多重if-else明显不符合开闭原则，审批条件和审批流程完全在客户端实现，即客户端和审批业务耦合太紧。</p>
<p><font size="5" color="orange">责任链模式</font></p>
<hr>
<p>上面的实现不符合开闭原则，我们需要把审批条件以及审批流程移到CEmployee及其派生类中，降低客户端和业务类的耦合度。</p>
<p>怎么把审批流程移过去呢？审批是一级一级上交的，自己这级权限不够，就需要交给上级来处理，所以关键就是两点：</p>
<ul>
<li>怎么知道自己权限不够？</li>
<li>怎么知道自己上级是谁？</li>
</ul>
<p>我们先看怎么知道自己的上级，某个员工要知道自己的上级是谁，其实很简单，在员工基类里加一个表示上级的成员变量就可以了：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#include "LeaveRequest.h"

class CEmployee{
public:
    CEmployee() :m_Superior(NULL) {}

    virtual void approveLeaveV(const CLeaveRequest *vLeaveRequest) const = 0;

    void setSuperior(CEmployee *vSuperior) { m_Superior = vSuperior; }
    const CEmployee* getSuperior() const { return m_Superior; }

private:
    const CEmployee *m_Superior;
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>每级员工都知道自己的权限天数是多少，不满足则交给他的上级m_Superior来处理：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>
#include "Employee.h"

class CTeamLeader : public CEmployee{
public:
    virtual void approveLeaveV(const CLeaveRequest *vLeaveRequest) const override {
        if (vLeaveRequest->getLeaveDays() < 10)
            std::cout << "The leave request of " << vLeaveRequest->getLeaveDays() << " days has been approved by team leader." << std::endl;
        else
            if(getSuperior())
                getSuperior()->approveLeaveV(vLeaveRequest);
    }
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>
#include "Employee.h"

class CProjectLeader : public CEmployee {
public:
    virtual void approveLeaveV(const CLeaveRequest *vLeaveRequest) const override {
        if (vLeaveRequest->getLeaveDays() < 20)
            std::cout << "The leave request of " << vLeaveRequest->getLeaveDays() << " days has been approved by project leader." << std::endl;
        else
            if (getSuperior())
                getSuperior()->approveLeaveV(vLeaveRequest);
    }
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>
#include "Employee.h"

class CHR : public CEmployee {
public:
    virtual void approveLeaveV(const CLeaveRequest *vLeaveRequest) const override {
        if (vLeaveRequest->getLeaveDays() < 30)
            std::cout << "The leave request of " << vLeaveRequest->getLeaveDays() << " days has been approved by HR." << std::endl;
        else
            std::cout << "The only way to get " << vLeaveRequest->getLeaveDays() << " leave days to quit the company." << std::endl;
    }
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这时主函数就变得很简单了，只需要把请求交给底层的TeamLeader就行，它会自动逐级上交审批请求的：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#include "TeamLeader.h"
#include "ProjectLeader.h"
#include "HR.h"

int main() {
    CTeamLeader *pTeamLeader = new CTeamLeader;
    CProjectLeader *pProjectLeader = new CProjectLeader;
    CHR *pHR = new CHR;
    CLeaveRequest *pLeaveRequest = new CLeaveRequest(25);

    pTeamLeader->setSuperior(pProjectLeader);
    pProjectLeader->setSuperior(pHR);

    pTeamLeader->approveLeaveV(pLeaveRequest);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这就是责任链模式：在具有上下级关系的一串对象中，每一级对象都含有其直接上级对象的指针。这样就将请求的处理者组织成一条链，客户端无需关心请求的处理细节以及请求的传递，只需要将请求发送到链上，实现请求的发送者和处理者解耦。请求会沿着链向上传递。但是，很明显的，系统性能会受到一定影响。</p>
<p>但是上面代码里，三类员工的approveLeaveV函数有没有太像了？几乎只有一个10、20、30不同，外加审批通过后作出的反应不同（这里是输出的字符串不同）。这代码明显重复得太厉害了，确定写的时候没有CtrlC、CtrlV？有没有什么办法能够减少重复代码？如果能够把这段approveLeaveV函数代码移到基类CEmployee当然就可以减少每个子类重复写了，但是那两个不同的地方怎么处理？<br>先看第一个不同地方：每一级员工的权限天数不一样，我们在基类里设置一个表示权限天数的变量就可以了，子类在创建后分别给这个变量赋以不同的值就OK：</p>
<pre class="line-numbers language-c++"><code class="language-c++">class CEmployee{
public:
    ...
    void  setMaxApproveDays(int vMaxApproveDays) { m_MaxApproveDays = vMaxApproveDays; }
    int   getMaxApproveDays() const { return m_MaxApproveDays; }
    ...

private:
    const CEmployee *m_Superior;
    int m_MaxApproveDays;
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>那么第二个不同的地方：审批通过后的反应不同，这个我们可以用多态啊！在基类里设置一个表示审批通过的函数：</p>
<pre class="line-numbers language-c++"><code class="language-c++">class CEmployee{
public:
    ...
    virtual void approvePassedV(const CLeaveRequest *vLeaveRequest) const = 0;
    ...

private:
    const CEmployee *m_Superior;
    int m_MaxApproveDays;
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>把这两个不同的地方都用基类的变量或者虚函数处理掉以后，就可以把approvePassedV函数搬到基类了：</p>
<pre class="line-numbers language-c++"><code class="language-c++">Employee.h:
#include "LeaveRequest.h"

class CEmployee{
public:
    CEmployee() :m_Superior(NULL), m_MaxApproveDays(0) {}

    void approveLeave(const CLeaveRequest *vLeaveRequest) const {
        if (vLeaveRequest->getLeaveDays() < getMaxApproveDays())
            approvePassedV(vLeaveRequest);
        else
            if (getSuperior())
                getSuperior()->approveLeave(vLeaveRequest);
    }

    void  setSuperior(CEmployee *vSuperior) { m_Superior = vSuperior; }
    const CEmployee* getSuperior() const { return m_Superior; }
    void  setMaxApproveDays(int vMaxApproveDays) { m_MaxApproveDays = vMaxApproveDays; }
    int   getMaxApproveDays() const { return m_MaxApproveDays; }

    virtual void approvePassedV(const CLeaveRequest *vLeaveRequest) const = 0;

private:
    const CEmployee *m_Superior;
    int m_MaxApproveDays;
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>子类会去分别重写这个虚函数：</p>
<pre class="line-numbers language-c++"><code class="language-c++">CTeamLeader.h:
#include <iostream>
#include "Employee.h"

class CTeamLeader : public CEmployee{
public:
    virtual void approvePassedV(const CLeaveRequest *vLeaveRequest) const override {
        std::cout << "The leave request of " << vLeaveRequest->getLeaveDays() << " days has been approved by team leader." << std::endl;
    }
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">CProjectLeader.h:
#include <iostream>
#include "Employee.h"

class CProjectLeader : public CEmployee {
public:
    virtual void approvePassedV(const CLeaveRequest *vLeaveRequest) const override {
        std::cout << "The leave request of " << vLeaveRequest->getLeaveDays() << " days has been approved by project leader." << std::endl;
    }
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">CHR.h:
#include <iostream>
#include "Employee.h"

class CHR : public CEmployee {
public:
    virtual void approvePassedV(const CLeaveRequest *vLeaveRequest) const override {
        std::cout << "The leave request of " << vLeaveRequest->getLeaveDays() << " days has been approved by HR." << std::endl;
    }
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">main.cpp:
#include "TeamLeader.h"
#include "ProjectLeader.h"
#include "HR.h"

int main() {
    CTeamLeader *pTeamLeader = new CTeamLeader;
    CProjectLeader *pProjectLeader = new CProjectLeader;
    CHR *pHR = new CHR;
    CLeaveRequest *pLeaveRequest = new CLeaveRequest(25);

    pTeamLeader->setSuperior(pProjectLeader);
    pProjectLeader->setSuperior(pHR);
    pTeamLeader->setMaxApproveDays(10);
    pProjectLeader->setMaxApproveDays(20);
    pHR->setMaxApproveDays(30);

    pTeamLeader->approveLeave(pLeaveRequest);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这样一来，就减少了子类里重复的代码，看起来更简洁，扩展性也更好。主要是要通过这个过程了解怎样把子类的相似代码抽象到父类中，体会抽象、多态的思想，尽可能用更少的代码去实现相同的功能。</p>
<p><font size="5" color="orange">另一个案例</font></p>
<hr>
<p>案例：某公司需要实现验证客户信息的功能（姓名、地址、电话号码、社保号码等），实现了一个抽象类来完成这些功能：</p>
<pre class="line-numbers language-c++"><code class="language-c++">class CInfoValidation {
    virtual bool isValidName() = 0;
    virtual bool isValidAddress() = 0;
    virtual bool isValidPhoneNumber() = 0;
    virtual bool isValidSSN() = 0;
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>为了加快开发进度，购买了别人的产品，其中提供了类CLegacyInfoValidation，但是只完成了部分功能，而且只有动态链接库和头文件，卖方没有提供源码：</p>
<pre class="line-numbers language-c++"><code class="language-c++">class CLegacyInfoValidation {
public:
    bool isNameValid();
    bool isAddressValid();
    bool isPhoneNumberValid();
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可见少了一个严重SSN的功能，而且卖方提供的接口和已有的抽象类接口不一致，那么应该怎么复用别人已经实现好的功能呢？</p>
<p><font size="5" color="orange">最码农的做法</font></p>
<hr>
<p>最直接也是最码农的做法，就是把自己抽象类的接口改成和别人接口形式一样，让自己的抽象类CInfoValidation 派生别人的类CLegacyInfoValidation ，再增加一个验证SSN的函数：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#include "LegacyInfoValidation.h"

class CInfoValidation : public CLegacyInfoValidation {
public:
    virtual bool isSSNValid() {...}
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这样就能在自己的抽象类里复用别人实现的其他3个功能了，但是这明显不符合开闭原则，改动了已有代码，导致程序中依赖原始接口的代码必须发生相应修改：</p>
<pre class="line-numbers language-c++"><code class="language-c++">bool ValidateInfo(CInfoValidation *vValidator) {
    if (!vValidator->isValidName())            return false;
    if (!vValidator->isValidAddress())        return false;
    if (!vValidator->isValidPhoneNumber())  return false;
    if (!vValidator->isValidSSN())            return false;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中vValidator调用的函数名都要改。。。</p>
<p><font size="5" color="orange">类适配器模式</font><br>别人实现了前三个验证，公司自己实现第四个验证，想要复用别人的函数完全可以靠继承嘛！上面最码农的做法也是靠继承来复用的，但是它改变了原有的类设计，我们完全可以不改嘛，在自己原有的isValidName函数里调用别人的isNameValid函数：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#include "LegacyInfoValidation.h"

class CInfoValidation :public CLegacyInfoValidation {
    virtual bool isValidName() {
        isNameValid();
    }
    virtual bool isValidAddress() {
        isAddressValid();
    }
    virtual bool isValidPhoneNumber() {
        isPhoneNumberValid();
    }
    virtual bool isValidSSN() = 0;
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这样程序中依赖原始接口的代码就不需要改变了（比如上面ValidateInfo函数中的方法调用就不需要改动了），但是这还是或多或少改动了原有的CInfoValidation 类代码。</p>
<p>如果想一点都不改动，只是增加新代码，也就是既想用CLegacyInfoValidation 类的三个方法，又想用CInfoValidation 类的isValidSSN方法，想用到两个类的方法，我们可以多重继承啊，派生一个新的类：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#include "InfoValidation.h"
#include "LegacyInfoValidation.h"

class CInfoValidationAdapter : public CInfoValidation, private CLegacyInfoValidation{
public:
    virtual bool isValidName() override {
        isNameValid();
    }

    virtual bool isValidAddress() override {
        isAddressValid();
    }

    virtual bool isValidPhoneNumber() override {
        isPhoneNumberValid();
    }

    virtual bool isValidSSN() {
        if(...)
            return true;
    }
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">class CInfoValidation {
    virtual bool isValidName() = 0;
    virtual bool isValidAddress() = 0;
    virtual bool isValidPhoneNumber() = 0;
    virtual bool isValidSSN() = 0;
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">class CLegacyInfoValidation {
public:
    bool isNameValid();
    bool isAddressValid();
    bool isPhoneNumberValid();
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>一样的，程序中依赖原始接口的代码还是不用改，比如之前的ValidateInfo方法中的函数调用，不过传入的CInfoValidation对象指针应该是来自新的CInfoValidationAdapter 类对象了，而不是原始的CInfoValidation 类对象。但是这基本上是在客户端才做出的改动，影响很小。</p>
<p>这就是类对象适配器：通过类继承来复用别的类的函数代码。</p>
<p><font size="5" color="orange">对象适配器模式</font></p>
<hr>
<p>上面的代码有个比较麻烦的地方，新的类是通过多重继承得到的，当程序变得复杂以后，这可能会带来一些不必要的麻烦，比如野指针、类爆炸等等。</p>
<p>可以通过合成复用原则来解决这个问题，不派生CLegacyInfoValidation 类，而是使用该类对象作为新的类的成员变量，通过变量对象来使用CLegacyInfoValidation 的函数：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#include "InfoValidation.h"
#include "LegacyInfoValidation.h"

class CInfoValidationAdapter : public CInfoValidation{
public:
    virtual bool isValidName() override {
        m_LegacyValidator.isNameValid();
    }

    virtual bool isValidAddress() override {
        m_LegacyValidator.isAddressValid();
    }

    virtual bool isValidPhoneNumber() override {
        m_LegacyValidator.isPhoneNumberValid();
    }

    virtual bool isValidSSN() {
        if (...)
            return true;
    }

private:
    CLegacyInfoValidation m_LegacyValidator;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>为什么使用CLegacyInfoValidation 类对象作为成员变量，而不使用CInfoValidation类对象，这个道理很简单啊~。因为程序里原本可能会有很多依赖原有抽象类CInfoValidation的地方，我们让新类派生自CInfoValidation类，就可以使用多态了，原来存在依赖的代码不用做任何修改，只是在传入对象参数的时候，实参由原来的CInfoValidation类对象，改成了现在的CInfoValidationAdapter 子类对象而已。</p>
<p>这就是对象适配器模式：通过合成复用（对象成员），来复用别的类的函数代码。</p>
]]></content>
      
        <categories>
            
            <category> 设计模式 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 责任链模式适配器模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[老张培训笔记第四课外观模式、观察者模式和命令模式]]></title>
      <url>/2017/08/30/%E8%80%81%E5%BC%A0%E5%9F%B9%E8%AE%AD%E7%AC%94%E8%AE%B0%E7%AC%AC%E5%9B%9B%E8%AF%BE/</url>
      <content type="html"><![CDATA[<p>感谢老张！<br><a id="more"></a></p>
<hr>
<p>案例：房间里有一台电视和一台空调，按下遥控器的Open键后，可以同时打开空调和电视。设计程序来实现该按键的功能。</p>
<p><font size="5" color="orange">最普通的解决方案</font></p>
<hr>
<p>最普通也是最容易想到的方法，就是分别建一个电视类、空调类、遥控器类，在遥控器类里调用电视类和空调类的打开方法，然后在主程序里调用遥控器类：</p>
<pre class="line-numbers language-c++"><code class="language-c++">TV.h:
#pragma once

#include <iostream>

class CTV{
public:
    void open(){
        std::cout << "The TV is turned on." << std::endl;
    }
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">AirCondition.h:
#pragma once

#include <iostream>

class CAirCondition{
public:
    void open(){
        std::cout << "The AirCondition is turned on." << std::endl;
    }
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">RemoteController.h:
#pragma once

#include "TV.h"
#include "AirCondition.h"

class CRemoteController {
public:
    void onOpenClicked(CTV *vTV, CAirCondition *vAirCondition) {
        vTV->open();
        vAirCondition->open();
    }
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">main.cpp:
#include <iostream>;
#include "AirCondition.h"
#include "TV.h"
#include "RemoteController.h"

int main() {
    CTV *pTV = new CTV();
    CAirCondition *pAirCondition = new CAirCondition();
    CRemoteController *pRemoteController = new CRemoteController();

    pRemoteController->onOpenClicked(pTV, pAirCondition);

    return 0;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>不过这种方法很明显太粗糙了，首先CRemoteController 类的onOpenClicked直接依赖于某个具体对象，这种依赖性太强，让它在调用之前就事先确定了自己要调用的只有电视和空调，如果还要加些别的电器呢？就得去增加参数，修改函数体内容，不符合开闭原则。我们可以使用之前课程讲的依赖倒置原则，让该函数只依赖于抽象类：电视和空调的抽象父类CDevice：</p>
<pre class="line-numbers language-c++"><code class="language-c++">Device.h:
#pragma once

class CDevice {
public:
    virtual void openV() = 0;
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">TV.h:
#pragma once

#include <iostream>
#include "Device.h"

class CTV :public CDevice {
public:
    virtual void openV() override {
        std::cout << "The TV is turned on." << std::endl;
    }
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">AirCondition.h:
#pragma once

#include <iostream>
#include "Device.h"

class CAirCondition :public CDevice {
public:
    virtual void openV() override {
        std::cout << "The AirCondition is turned on." << std::endl;
    }
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">RemoteController.h:
#pragma once

#include <vector>
#include "TV.h"
#include "AirCondition.h"

class CRemoteController {
public:
    void onOpenClicked(std::vector<CDevice*>& vDevice) {
        for each (CDevice* e in vDevice)
        {
            e->openV();
        }
    }
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">main.cpp:
#include <iostream>;
#include <vector>
#include "AirCondition.h"
#include "TV.h"
#include "RemoteController.h"

int main() {
    std::vector<CDevice*> pDevice;
    pDevice.push_back(new CTV);
    pDevice.push_back(new CAirCondition);
    CRemoteController *pRemoteController = new CRemoteController();

    pRemoteController->onOpenClicked(pDevice, 2);

    return 0;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>CRemoteController类的onOpenClicked函数现在只是依赖抽象类CDevice ，而不是具体的某个类，这样当房间里电器个数增加时，CRemoteController类不需要任何改变，将符合开闭原则。</p>
<p>但是，客户端程序（main）知道的太多了，因为是在客户端里创建房间内的物品，因此它需要知道房间里有哪些物品这个细节。</p>
<p><font size="5" color="orange">外观模式</font></p>
<hr>
<p>我们需要把客户端创建物品的程序移出去，移到一个房间类CRoom里，让这个房间类来负责创建房间里的所有物品，而客户端程序不需要知道有哪些物品被创建了，只需要调用房间内类的一个接口就行，在这个接口里，房间里的所有物品执行打开函数：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#pragma once

#include "AirCondition.h"
#include "TV.h"

class CRoom {
public:
    CRoom() {
        m_pTV = new CTV;
        m_pAirCondition = new CAirCondition;
    }

    void onEnterRoom() {
        m_pTV->openV();
        m_pAirCondition->openV();
    }

private:
    CTV *m_pTV;
    CAirCondition *m_pAirCondition;
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">#pragma once

#include "Room.h"

class CRemoteController {
public:
    void onOpenClicked(CRoom *vRoom) {
        vRoom->onEnterRoom();
    }
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>;
#include "RemoteController.h"
#include "Room.h"

int main() {
    CRoom *pRoom = new CRoom();
    CRemoteController *pRemoteController = new CRemoteController();
    pRemoteController->onOpenClicked(pRoom);

    return 0;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这样一来减轻了应用程序的负担，让应用程序不必知道房间里具体有什么东西。这其实就是外观模式：把一堆接口（/函数）组合到一个单独的类里。如下图所示：<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E8%80%81%E5%BC%A0%E7%AC%AC%E5%9B%9B%E8%AF%BE1.jpg" alt=""><br>将一堆子系统组合起来，合到一个外观类里，客户端通过外观类来间接和内部的子系统打交道，这样客户端和子系统之间的复杂关系可以通过外观模式来简化，降低了系统的耦合度以及复杂程度，也提高了客户端使用的便捷性，使得客户端无须关心子系统的工作细节，通过外观角色即可调用相关功能。</p>
<p>不过外观模式显然不符合开闭原则，因为房间里物品增多时，需要去改变CRoom类，但是它把这种变化限制在CRoom里了，程序并没有发生连锁反应。所以，外观模式在一定程度上还是可以接受的。</p>
<p><font size="5" color="orange">迪米特法则</font></p>
<hr>
<p>迪米特法则：一个软件应该尽可能少地与其他实体发生相互作用。</p>
<p>比如某系统与数据访问类之间的调用关系较为复杂，如下图：<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E8%80%81%E5%BC%A0%E7%AC%AC%E5%9B%9B%E8%AF%BE2.jpg" alt=""><br>根据迪米特法则，在中间加一层Controller：<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E8%80%81%E5%BC%A0%E7%AC%AC%E5%9B%9B%E8%AF%BE3.jpg" alt=""><br>很明显，系统复杂度降低了很多。</p>
<p><font size="5" color="orange">观察者模式</font></p>
<hr>
<p>既然外观模式不符合开闭原则，那么我们从另一个角度考虑：我们从客户端发出了一个按键事件，然后需要空调、电视来响应这个事件。但是空调电视要怎么去接收这个事件呢？需要它们去时时刻刻监听事件，简单点，就是服务端CRemoteController里有一堆事件集合（每种事件一个集合），由客户端向这个事件集合里push事件，在最后服务端会让空调、电视等来执行这些事件。</p>
<p>但是这个事件集合是什么东东呢？ 比如我们把按遥控器开关键作为一个事件，但是不能把按开关键作为一个事件发给服务端，因为这只是一个动作，只发送一个动作过去，服务端并不知道由哪个具体对象来执行这个动作，所以我们可以发给服务端响应这个动作的对象（观察者）。这里响应按键的对象是空调、电视，也就是要把空调、电视等对象发送给服务端，这个时候的事件其实就是响应动作的对象，但是服务端需要的是事件集合，所以需要对空调、电视等等对象做一层抽象，抽象为CDevice，这样服务端所存储的事件集合，其实就可以是CDevice对象的集合（这个适合我觉得换个名字更好：观察者集合）。最后服务端执行集合里所有CDevice对象的openV函数，就可以完成对按键这个事件的响应了：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#pragma once

#include <vector>
#include "AirCondition.h"
#include "TV.h"

class CRoom {
public:
    CRoom() {
        m_Devices.push_back(new CTV);
        m_Devices.push_back(new CAirCondition);
    }

    std::vector<CDevice*> fetchDevices() {
        return m_Devices;
    }

private:
    std::vector<CDevice*> m_Devices;
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">#pragma once

#include <vector>
#include "TV.h"
#include "AirCondition.h"

class CRemoteController {
public:
    void onOpenClicked() {
        for each (auto* e in m_pObservers)
        {
            e->openV();
        }
    }

    void registerObserver(CDevice *vDevice) {
        m_pObservers.push_back(vDevice);
    }

private:
    std::vector<CDevice*> m_pObservers;
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">#include <vector>
#include "AirCondition.h"
#include "TV.h"
#include "RemoteController.h"
#include "Room.h"

int main() {
    CRemoteController *pRemoteController = new CRemoteController();
    CRoom *pRoom = new CRoom;
    for each (CDevice *e in pRoom->fetchDevices())
    {
        pRemoteController->registerObserver(e);
    }

    pRemoteController->onOpenClicked();

    return 0;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在服务端里存储着观察者集合，由客户端向里面注册事件的观察者，最后由服务端调用注册好的所有观察者的公用函数（监听），这个过程就是观察者模式。</p>
<p>其实我们注意到，服务端其实只是用到了观察者对象的公用虚函数而已，不需要用到整个观察者对象，所以观察者集合还可以进一步变成函数指针集合，存储着电视、冰箱等子类重写的虚函数指针集合（例如指向子类重写的openV函数的指针）。</p>
<p>总结一下：<br>观察者模式定义了对象间的一种一对多的依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。</p>
<ul>
<li>发生改变的对象称为观察目标</li>
<li>被通知的对象称为观察者</li>
<li>一个观察目标可以对应多个观察者</li>
<li>观察者之间没有相互联系，可以根据需要增加和删除观察者，使得系统更易于扩展。</li>
</ul>
<p><font size="5" color="orange">命令模式</font></p>
<hr>
<p>现在需求变了：用户不仅可以按开关键，还可以通过其他按键控制空调风速、电视声音大小等等。这样就好像客户端发送了不同的命令，服务端接收到命令后取出命令来执行。但是同样的问题，客户端发送的打开命令，应该由哪个设备来执行呢？所以，打开命令还必须和一个设备相关联，可以把设备作为打开命令的成员：</p>
<pre class="line-numbers language-c++"><code class="language-c++">class CDevice {
public:
    virtual void openV() = 0;
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>
#include "Device.h"

class CTV :public CDevice {
public:
    virtual void openV() override {
        std::cout << "The TV is turned on." << std::endl;
    }
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>
#include "Device.h"

class CAirCondition :public CDevice {
public:
    virtual void openV() override {
        std::cout << "The AirCondition is turned on." << std::endl;
    }
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">class CCommand {
public:
    virtual void executeV() = 0;
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">#include "Command.h"
#include "Device.h"

class COpenCommand :public CCommand{
public:
    COpenCommand(CDevice *vDevice) {
        m_pDevice = vDevice;
    }

    virtual void executeV() override {
        m_pDevice->openV();
    }

private:
    CDevice *m_pDevice;
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">#include <vector>
#include "Command.h"
#include "Room.h"

class CRemoteController {
public:
    void addCommand(CCommand *vCommand) {
        m_pCommandSet.push_back(vCommand);
    }

    void executeCommand() {
        for each (auto* e in m_pCommandSet)
        {
            e->executeV();
        }
    }

private:
    std::vector<CCommand*> m_pCommandSet;
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">#include "RemoteController.h"
#include "Room.h"
#include "OpenCommand.h"

int main() {
    CRemoteController *pRemoteController = new CRemoteController();
    CRoom *pRoom = new CRoom;
    for each (CDevice *e in pRoom->fetchDevices())
    {
        pRemoteController->addCommand(new COpenCommand(e));
    }
    pRemoteController->executeCommand();

    return 0;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>客户端（main函数）发出打开命令（new COpenCommand(e)），在打开命令创建的时候就已经与房子里的具体物体关联上了，然后会把打开命令添加到服务端（CRemoteController），服务端里存储着一系列命令集合，服务端最后会执行所有命令，但是它并不知道命令是和谁相关的。产生命令的客户端就是生产者，而执行命令的一段是消费者。如下图所示（AI模块是生产者，产生AI命令，角色模块是消费，执行AI命令，中间是命令队列）：<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E8%80%81%E5%BC%A0%E7%AC%AC%E5%9B%9B%E8%AF%BE4.jpg" alt=""><br>值得注意的是：在客户端对命令绑定具体对象时，绑定的是虚基类CDevice对象指针，而不是具体的某个电视或者空调对象，这样在产生命令的时候就只需要知道抽象类就可以了，而不必知道具体的消费者对象是哪些。所以这样一来就实现了生产者和消费者解耦：生产者生成自己的命令就好，不用管由哪些具体对象来消费命令，而消费者也不必知道命令的生成过程是怎样。</p>
<p>如果要增加一个关闭命令，需要更改或添加如下代码：<br>在CDevice里增加关闭的函数接口：</p>
<pre class="line-numbers language-c++"><code class="language-c++">virtual void closeV() = 0;
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>在CTV里重写关闭函数接口：</p>
<pre class="line-numbers language-c++"><code class="language-c++">virtual void closeV() override {
    std::cout << "The TV is closed." << std::endl;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>在CAirCondition里重写关闭函数接口：</p>
<pre class="line-numbers language-c++"><code class="language-c++">virtual void closeV() override {
    std::cout << "The AirCondition is closed." << std::endl;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>增加一个派生自CCommand的CCloseCommand类：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#pragma once
#include "Command.h"
#include "Device.h"

class CCloseCommand : public CCommand {
public:
    CCloseCommand(CDevice *vDevice) {
        m_pDevice = vDevice;
    }

    virtual void executeV() override {
        m_pDevice->closeV();
    }

private:
    CDevice *m_pDevice;
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在客户端main函数里添加创建和发送关闭命令的代码：</p>
<pre class="line-numbers language-c++"><code class="language-c++">for each (CDevice *e in pRoom->fetchDevices())
{
    pRemoteController->addCommand(new COpenCommand(e));
    pRemoteController->addCommand(new CCloseCommand(e));
}
pRemoteController->executeCommand();
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>程序运行的结果如下：</p>
<pre class="line-numbers language-c++"><code class="language-c++">The TV is turned on.
The TV is closed.
The AirCondition is turned on.
The AirCondition is closed.
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看出，命令模式实际上是把客户端发出的命令封装成了对象，而服务端存储着一堆命令集合，由客户端向这个集合里添加具体命令（和观察者模式很像，不过观察者模式在服务端存储的是观察者集合）。</p>
<p><font size="5" color="orange">外观模式、观察者模式、命令模式的比较</font></p>
<hr>
<p><font size="4" color="red">各自的优点和侧重点</font><br>外观模式会将子系统的细节隐藏到外观对象中。<br>观察者模式可以根据需要增加和删除观察者，使得系统更易于扩展。<br>命令模式实现请求调用者和执行者之间的完全解耦。</p>
<p>每个模式都有其适用的环境，无法说哪一个设计模式一定比另一个设计模式更好。这是随着需求的变化而不同的。</p>
<p><font size="4" color="red">需求变化时各自的缺点</font><br>比如房间里新增了物品，那么增加相应的物品类是必不可少的，除此之外：<br>外观模式需要修改已有的类CRoom，<br>观察者模式需要在客户端增加一行代码， 注册新的物品为观察者，<br>命令模式需要在客户端增加和新物品相关联的命令（如果所有物品都放在CRoom里，那就和外观模式一样需要去修改类CRoom了）。</p>
<p>那么是不是就是观察者模式好于命令模式，命令模式好于外观模式？当然不是的，比如需求变成增加了一种按键，这种情况下就不是观察者模式最好了。</p>
<p>总之，记住一点：对客户端的修改不易引起连锁反应，对客户端做出改动的危险往往低于对业务类的修改。在某种需求变化下，对非客户端程序改动越小的设计方案就是越好的。</p>
]]></content>
      
        <categories>
            
            <category> 设计模式 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 外观 观察 者命令 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Fermi Asynchronous Texture Transfer]]></title>
      <url>/2017/08/20/Fermi-Asynchronous-Texture-Transfer/</url>
      <content type="html"><![CDATA[<p><font size="5" color="orange">简介</font><br><a id="more"></a></p>
<hr>
<p>NVIDIA Fermi 架构里存在拷贝引擎硬件，专门用于GPU到CPU之间以DMA的方式进行双向数据传输。Quadro中高端显卡会有两个拷贝引擎硬件，一个用于从GPU上下载数据到CPU，一个用于CPU上传数据到GPU。如下图所示：<br><img src="http://oqcvzqam1.bkt.clouddn.com/FermiTransfer_Insight29_1.png" alt=""></p>
<p><font size="5" color="orange">CPU上异步纹理传输：CPU Asynchronous Texture Transfers</font></p>
<hr>
<p>使用多个PBO异步传输数据的图示如下：<br><img src="http://oqcvzqam1.bkt.clouddn.com/FermiTransfer_Insight29_2.png" alt=""><br>代码如下：</p>
<pre class="line-numbers language-c++"><code class="language-c++">GLuint pbo[2]; // The ping-pong pbo ? s
unsigned int curPBO = 0;
// Bind current pbo for app->pbo transfer
glBindBuffer(GL_PIXEL_UNPACK_BUFFER, pbo[curPBO]);
GLubyte *ptr;
ptr = (GLubyte *)glMapBufferRange(GL_PIXEL_UNPACK_BUFFER_ARB, 0, size, GL_MAP_WRITE_BIT | GL_MAP_INVALIDATE_BUFFER_BIT);
memcpy(ptr, pData , width * height * sizeof(GLubyte) * nComponents);
glUnmapBuffer(GL_PIXEL_UNPACK_BUFFER);
glBindTexture(GL_TEXTURE_2D , texId);
// Bind next pbo for upload from pbo to texture object
glBindBuffer(GL_PIXEL_UNPACK_BUFFER, pbo[1 - curPBO]);
glTexSubImage2D(GL_TEXTURE_2D , 0, 0, 0, width , height, GL_RGBA, GL_UNSIGNED_BYTE, 0);
glBindBuffer(GL_PIXEL_UNPACK_BUFFER, 0);
glBindTexture(GL_TEXTURE_2D , 0);
curPBO = 1 - curPBO;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注意这只是在单个渲染线程上，不同PBO的数据传输在并行执行，属于CPU异步输出。并没有用到GPU的Copy引擎。</p>
<p><font size="5" color="orange">GPU上异步纹理传输：GPU Asynchronous Texture Transfers</font></p>
<hr>
<ol>
<li>GPU的Copy引擎硬件默认是不开启的，因为对于少量的数据传输，使用它会带来一些性能瓶颈。</li>
<li>为了触发Copy引擎，需要把数据传输(transfers)放在一个单独的线程里，这样GPU调度程序就会把渲染线程(render thread)发出的命令交由图形渲染引擎来完成，而数据传输线程(transfer thread)发出的命令会交由Copy引擎来并行执行。这就是GPU异步传输。图示如下：<br><img src="http://oqcvzqam1.bkt.clouddn.com/FermiTransfer_Insight29_3.png" alt=""></li>
</ol>
<p><font size="5" color="orange">Implementation Details</font></p>
<hr>
<p><font size="4" color="red">多线程</font><br>实现GPU异步传输时，需要为上传、渲染、下载分别建立一个单独的线程。下图是上传线程和渲染线程异步工作的图解：<br><img src="http://oqcvzqam1.bkt.clouddn.com/FermiTransfer_Insight29_4.png" alt=""><br>下图是渲染线程和下载线程异步工作的图解：<br><img src="http://oqcvzqam1.bkt.clouddn.com/FermiTransfer_Insight29_5.png" alt=""><br>值得注意的是我们是通过多张纹理数据来达到并行执行的效果，确保渲染线程在工作的同时，上传线程或下载线程会保持繁忙（busy）。</p>
<p><font size="4" color="red">管理线程并发访问共享纹理</font><br>为了管理线程到共享纹理的并发访问，需要为每个纹理创建类似signal这种同步原语。</p>
<p>OpenGL的绘制函数（glDraw*等）是异步的，所以函数返回时并不能保证渲染完成了，但是我们经常需要知道一些事会在什么时候完成，比如渲染线程需要知道纹理是什么时候上传完成的，它才能开始用这张纹理。这种信号交换由GL_ARB_Sync机制的同步对象（synchronization object）来负责管理，这些同步对象在不同的OpenGL上下文之间可以共享。一个上下文里创建的同步对象可以用来阻塞另一个上下文。</p>
<p> 上传线程和渲染线程之间的同步机制如下图所示，渲染线程必须在上传线程传输完纹理数据后才能使用该纹理，渲染线程在使用某纹理的时候上传线程不能对该纹理传输数据：<br><img src="http://oqcvzqam1.bkt.clouddn.com/FermiTransfer_Insight29_6.png" alt=""><br>渲染线程和下载线程之间的同步机制如下图所示：<br><img src="http://oqcvzqam1.bkt.clouddn.com/FermiTransfer_Insight29_7.png" alt=""><br>其中 endUploadValid、endDownloadValid等用于避免线程之间出现忙等（？？？）。</p>
<p><font size="5" color="orange">Copy引擎注意事项</font></p>
<hr>
<ol>
<li>连接Copy引擎的OpenGL上下文也可以发送非非DMA命令，但是这些命令可能会和渲染线程分时，导致丢失并行性。如果序列化传输线程和渲染线程中的命令，可能会产生错误：“Pixeltransferis synchronizedwith 3Drendering.”</li>
<li>Fermi的Copy引擎只允许pixel传输，而不允许vertex传输。</li>
<li>FBO和Copy引擎结合使用时，由于纹理附件和渲染缓存附件的验证，可能会带来一些性能瓶颈。出于这个原因，建议用glGetTexImage来下载数据，而非用glReadPixels从渲染缓存或者纹理附件里下载数据。</li>
<li>应该根据渲染时间和传输时间的比例来设置最佳共享纹理数，这需要很多次实验才能得出好的结果。两个时间平衡后，使用双缓冲纹理就足够了。</li>
</ol>
<p><font size="5" color="orange">总结</font></p>
<hr>
<ol>
<li>上传数据时，在Quadro上比在GeForce上有更大的性能提升。</li>
<li>传输的纹理大小小于1MB时，Copy引擎带来的性能提升很小。</li>
<li>下载数据时，在GeForce上比在Quadro上有更大的性能提升。</li>
<li>对于渲染时间和传输时间平衡的应用程序，Copy引擎能够带来最大的性能提升。</li>
</ol>
<hr>
<p>参考文献：《OpenGL Insight》- Chapter29:Fermi Asynchronous Texture Transfers</p>
]]></content>
      
        <categories>
            
            <category> OpenGL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 异步传输 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Asyn Buffer Transfers]]></title>
      <url>/2017/08/20/Asyn-Buffer-Transfers/</url>
      <content type="html"><![CDATA[<p><font size="5" color="orange">CPU和GPU之间的数据传输简介</font><br><a id="more"></a></p>
<hr>
<ol>
<li>调用OpenGL函数时，驱动程序会将其转换为一系列命令，并把这些命令添加到CPU端的命令队列中。这些命令会被GPU以异步的方式取出来执行。也就是说，OpenGL命令不一定会被立即执行，只是被放进了命令队列，实际的渲染执行都有可能在几帧以后了。</li>
<li>CPU和GPU之间的数据通过PCIe（PCI Express）总线来传输，是双向传输的。</li>
<li>CPU和GPU之间的数据传输是使用DMA机制来实现的。</li>
<li>pinned memory（固定内存）：<br>固定内存也称作不可分页内存。由于不可以分页，所以操作系统不会将固定内存进行分页并交换到磁盘上，这块内存会始终驻留在物理内存中，不会被破坏或者重新定位。<br>如果是分页的内存，CPU上的数据会先拷贝到一块不可见的pined memory（临时的页锁定内存）中，再传输<br>拷贝到GPU中，会存在两次数据拷贝。malloc分配的是分页内存，cudaHostAlloc分配的是页锁定内存。<br>使用pinned memory可以加速CPU和GPU之间的数据传输，性能可以提高两倍左右，但是不能滥用，因为固定内存驻留在物理内存中，如果固定内存很多，会导致系统内存被耗尽，程序无法正常运行，还会影响系统上其他应用程序的性能。用到的时候采取申请固定内存，不用的时候立即释放。</li>
<li>集成显卡（Integrated GPU）和CPU共享内核和内存空间，所以在CPU和GPU之间传输数据时不受限于PCIe总线的传输能力。但传输速度还是比不过对应的独立显卡（Discrete GPU）。</li>
</ol>
<p><font size="5" color="orange">内存传输</font></p>
<hr>
<p><font size="4" color="red">CPU到GPU的数据传输函数</font><br>使用glBufferData系列函数将数据从CPU传到GPU上时（即Buffer Object有可能存在于CPU，也可能存在于GPU上，由glBufferData函数的usage参数决定），会先将数据写到CPU内存（比如常用的GLfloat Verrtices[ ]）上，再由glBufferData函数将存储在CPU内存上的数据传到驱动（driver）的固定内存里，上传完之后，会立即以DMA的方式将数据从驱动的固定内存传到GPU内存上，同时glBufferData函数结束使命，函数返回。图示如下：<br> <img src="http://oqcvzqam1.bkt.clouddn.com/Transfer_Insight28_1.png" alt=""><br> 使用glMapBuffer函数可以得到驱动里固定内存的地址，直接将数据写到固定内存里，不用先把数据拷贝到CPU内存里，会比glBufferData函数更快。图示如下：<br> <img src="http://oqcvzqam1.bkt.clouddn.com/Transfer_Insight28_2.png" alt=""></p>
<p><font size="4" color="red">Usage参数</font><br>OpenGL可以把应用程序的数据最终存在CPU或者GPU上（存在CPU上时GPU通过PCIe总线来访问数据）。对于glBufferData和glMapBuffer函数，其usage参数可以帮助驱动程序（driver）决定最终要把数据存在哪个位置（不全由usage参数决定，驱动程序可能不会遵从usage指定的内容）。如下图所示：<br><img src="http://oqcvzqam1.bkt.clouddn.com/Transfer_Insight28_3.png" alt=""></p>
<p><font size="5" color="orange">隐式同步</font></p>
<hr>
<p>驱动在绘制上一帧的数据（存在VBO里）时，可能应用程序已经想要开始传下一帧的数据了，如果用的同一个VBO，那么应用程序如果传下一帧数据就会破坏上一帧存在VBO里的数据，导致绘制结果不正确，所以OpenGL会存在一个隐式同步（Implict synchronization），等待驱动利用上一帧数据绘制完以后，应用程序才开始下一帧数据传输。如下图所示：<br><img src="http://oqcvzqam1.bkt.clouddn.com/Transfer_Insight28_4.png" alt=""><br>这种隐式同步等待，可能会对程序程序性能造成严重损害（可能会增加好几毫秒的渲染时间）。<br> 【注】：</p>
<ul>
<li>绘制图形时，同时存在应用程序线程（负责发送OpenGL函数）和驱动程序线程（负责转换和处理OpenGL命令）。</li>
<li>应用程序线程里有调用glClear等等函数，驱动程序线程同样有glClear等等函数，这些函数是从应用程序传过来的，实际上在驱动里存储的是glClear等等函数的命令形式。</li>
</ul>
<p><font size="5" color="orange">上传UpLoad</font></p>
<hr>
<p><font size="4" color="red">避免隐式同步的方法</font></p>
<ul>
<li>缓冲对象循环链 （多缓冲）</li>
<li>重新分配缓存</li>
<li>使用glFenceSync、glClientWaitSync和glMapBufferRange函数来完全手动同步<br><font size="4" color="red">缓冲对象循环链（多缓冲）方法避免隐式同步</font><br>之前会出现隐式同步，一个很重要的原因是应用程序线程和驱动程序线程使用的是同一个VBO，它们向同一块缓冲中写入和读取帧数据。所以，我们可以让它们循环使用不同的VBO来避免隐式同步：应用程序先向vbo[0]中写入帧数据，然后驱动程序在使用vbo[0]绘制的同时，应用程序向vbo[1]中传入帧数据，接下来驱动程序在使用vbo[1]绘制的同时，应用程序又向vbo[0]中写入帧数据……。如下图所示：<br><img src="http://oqcvzqam1.bkt.clouddn.com/Transfer_Insight28_5.png" alt=""><br><font size="4" color="red">重新分配缓存方法避免隐式同步</font><br>上面是让两个线程分别操作两个不同的缓存对象，来避免隐式同步，其实还有另一种办法来保证应用线程的glSubBufferData函数和驱动线程的glDrawElements函数操作的不是同一个缓存：在应用程序调用glBufferSubData之前，先调用glBufferData函数在GPU上重新分配一块显存区域（新的VBO显存），用来接收后续glBufferSubData函数传过来的数据，原先的VBO显存不会被覆盖，依然可以为驱动线程的glDrawElements函数提供绘制图形的数据源。图示如下：<br><img src="http://oqcvzqam1.bkt.clouddn.com/Transfer_Insight28_6.png" alt=""><br>驱动程序在调用glDrawElements绘制第n-1帧时，应用程序已经同时调用glBufferData函数在GPU上为VBO重新开辟了一段显存空间，然后用glBufferSubData为这块新的显存空间传输数据，但是glDrawElement还是用的原来的VBO显存在绘制，这样glDrawElements和glBufferSubData就是操作的不同的VBO缓存，就不会出现隐式同步了。<br>【注】：<ul>
<li>上图中左下角的memory block是指驱动程序里的固定内存，右下角VBO里的memory block是GPU显存。</li>
<li>glBufferData函数才会重新分配缓存空间，glBufferSubData不会。</li>
</ul>
</li>
</ul>
<p>除此之外，也可以使用glMapBufferRange函数配合 GL_MAP_INVALIDATE_BUFFER_BIT或者GL<em>MAP</em> INVALIDATE_RANGE_BIT参数，来让VBO对应的固定内存失效，也就是对VBO和固定内存进行解绑，固定内存将对VBO不可见，这时通过映射后的指针向固定内存里写入数据，但是却不会将固定内存的数据传到VBO里，也就是不会影响glDrawElements使用的VBO显存数据，这样就可以在传数据的同时，驱动线程也并行执行glDrawElements。当使用映射指针传输完数据后，调用glUnmapBuffer函数，会重新让固定内存对VBO可见，这时才会开始把固定内存里的数据传入到VBO里：</p>
<pre class="line-numbers language-c++"><code class="language-c++">glBindBuffer(GL_ARRAY_BUFFER , my_buffer_object);
void *mydata_ptr = glMapBufferRange(GL_ARRAY_BUFFER , 0, data_size, GL_MAP_WRITE_BIT | GL_MAP_INVALIDATE_BUFFER_BIT);
// Fill mydata_ptr with useful data
glUnmapBuffer(GL_ARRAY_BUFFER);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><font size="4" color="red">缺点</font><br>但是上面两种方法只要和渲染操作一起同时使用，还是会造成高昂的同步代价（为什么？？？），而且使用glMapBufferRange里的这些参数标志，还会涉及到驱动器内存管理，这可能会带来10倍的性能消耗，所以不推荐使用这两种方式来避免隐式同步。可以使用接下来的异步缓存映射。</p>
<p><font size="4" color="red">更好的方法：异步缓存映射方法避免隐式同步</font><br>首先需要给glMapBufferRange函数传递 GL_MAP_UNSYNCHRONIZED_BIT标志，告诉OpenGL驱动不需要任何同步操作和重新分配内存操作，然后使用多个VBO缓存（通常3个就足够了，因为函数延迟一般不会超过两帧），每一帧使用各自的缓冲区进行数据读写和渲染。如下图所示：<br><img src="http://oqcvzqam1.bkt.clouddn.com/Transfer_Insight28_7.png" alt=""><br>不过需要保证一个缓存区不会被多帧使用，比如第0帧在使用buffer[0]进行glDrawBufferRange，而第1帧也在使用buffer[0]进行glMapBufferRange。可以通过glFencSync和glClientWaitSync函数来实现：先调用glClientWaitSync函数对缓存对象对应的同步对象加锁，防止其他帧的函数也进来访问该缓存对象，使用glMapBufferRange函数取得的内存指针，写完数据后，开始绘制，绘制完后释放同步对象，这时其他帧的函数才能进来访问该缓存对象。</p>
<pre class="line-numbers language-c++"><code class="language-c++">const int buffer_number = frame_number++ % 3;
// Wait until buffer is free to use, in most cases this should not wait
// because we are using three buffers in chain , glClientWaitSync
// function can be used for check if the TIMEOUT is zero
GLenum result = glClientWaitSync(fences[buffer_number], 0, TIMEOUT);
if (result == GL_TIMEOUT_EXPIRED || result == GL_WAIT_FAILED)
{
    // Something is wrong
}
glDeleteSync(fences[buffer_number]);
glBindBuffer(GL_ARRAY_BUFFER , buffers[buffer_number]);
void *ptr = glMapBufferRange(GL_ARRAY_BUFFER , offset, size, GL_MAP_WRITE_BIT | GL_MAP_UNSYNCHRONIZED_BIT);
// Fill ptr with useful data
glUnmapBuffer(GL_ARRAY_BUFFER);
// Use buffer in draw operation
glDrawArray(...);
// Put fence into command queue
fences[buffer_number] = glFenceSync(GL_SYNC_GPU_COMMANDS_COMPLETE, 0);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>大多数情况下都是不需要同步的，因为我们还有第3个缓冲区，足够应用程序线程和驱动线程使用了。</p>
<p>其中glFenceSync函数用于发出信号，让阻塞在同步对象里的glWaitSync和glClientWaitSync命令变为非阻塞状态，返回释放的同步对象的名字；glWaitSync会导致OpenGL服务端被阻塞，直到指定的同步对象发出释放信号或者等待超时；glClientWaitSync会导致OpenGL客户端（应用程序）被阻塞，直到指定的同步对象发出释放信号或者等待超时。</p>
<p><font size="5" color="orange">下载Download</font></p>
<hr>
<p><font size="4" color="red">使用PBO下载数据</font><br>大多数情况下我们都是从GPU上下载纹理到CPU，这时就需要用到glReadPixels和PBO了（直接glGetTexImage很慢）。先将数据渲染到纹理，再使用glReadPixels将纹理数据读入到PBO中，值得注意的是，在为PBO缓存对象分配内存空间时，即调用glBufferData时，需要指定usage参数为GL_*_READ形式，这样OpenGL就会把PBO放在驱动的固定内存里，可以直接被应用程序通过映射指针来访问。如下图所示：<br><img src="http://oqcvzqam1.bkt.clouddn.com/Transfer_Insight28_8.png" alt=""><br>但是应用程序需要同步等待数据从GPU完全传输到驱动内存里以后，才可以调用glMapBuffer来访问驱动固定内存里的数据，那么怎么避免这个等待呢？</p>
<p><font size="4" color="red">在read和map之间做一些别的工作来避免闲置等待</font><br>在调用glReadPixels函数后，做一些无关的CPU操作，等DMA数据传输完以后，再调用glMapBuffer函数。这种方法其实不实用，因为不好控制执行多少CPU操作数据才会传输完，而且这样做会增加代码的难度，难以写出高效的代码。</p>
<p><font size="4" color="red">错帧调用map来避免闲置等待</font><br>在调用glReadPixels函数的前一帧或者后两帧，再调用glMapBuffer函数。因为这时候数据通常都已经传输完了。这种方法也需要多缓冲来实现（用多缓冲来控制前一帧或者后两帧使用map来读取对应缓冲）。</p>
<p><font size="4" color="red">信号锁明确告知数据传输完成时间点，结合多张纹理来避免闲置等待</font><br>和上传时的异步缓存映射方法一样，使用信号锁。先调用glReadPixels函数，将数据从GPU传到驱动内存里，传输完后调用glFenceSync函数释放同步对象，在glMapBuffer之前，先判断同步对象是否被释放，如果被释放则说明数据已经全部从GPU传到了驱动内存里，立即开始映射数据到应用程序内存：</p>
<pre class="line-numbers language-c++"><code class="language-c++">if (rb_tail != rb_head)
{
    const int tmp_tail = (rb_tail + 1) & RB_BUFFERS_MASK;
    GLenum res = glClientWaitSync(fences[tmp_tail], 0, 0);
    if (res == GL_ALREADY_SIGNALED || res == GL_CONDITION_SATISFIED)
    {
        rb_tail = tmp_tail;
        glDeleteSync(sc->_fence);
        glBindBuffer(GL_PIXEL_PACK_BUFFER, buffers[rb_tail ]);
        glMapBuffer(GL_PIXEL_PACK_BUFFER, GL_READ_ONLY);
        // Process data
        glUnmapBuffer(GL_PIXEL_PACK_BUFFER);
    }
}
const int tmp_head = (rb_head + 1) & RB_BUFFERS_MASK;
if (tmp_head != rb_tail)
{
    glReadBuffer(GL_BACK);
    glBindBuffer(GL_PIXEL_PACK_BUFFER, buffers[rb_head]);
    glReadPixels(0, 0, width , height, GL_BGRA, GL_UNSIGNED_BYTE , (void*)offset);
    fences[tmp_head] = glFenceSync(GL_SYNC_GPU_COMMANDS_COMPLETE, 0);   //new add
}
else
{
    // We are too fast
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>由于有多张纹理在同时从GPU传到CPU里，所以一个被阻塞，另一个可能还在继续传输数据，这样相当于同步等待的时间也没有被浪费，被其他纹理传输利用起来了。</p>
<p>在AMD显卡上，glUnmapBuffer有时候是同步的，如果需要异步，需要用AMD_pinned_memory扩展。在NVIDIA显卡上，先使用glReadPixels把数据读到一个缓存（GPU上的一个临时buffer）里，再使用glCopyBufferSubData把这个缓存里的数据拷贝到CPU缓存里，速度会快两倍：</p>
<pre class="line-numbers language-c++"><code class="language-c++">glBindBuffer(GL_COPY_READ_BUFFER, source_buffer);
glBindBuffer(GL_COPY_WRITE_BUFFER, dest_buffer);
glCopyBufferSubData(GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, source_offset , write_offset , data_size);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><font size="5" color="orange">多线程和共享上下文</font></p>
<hr>
<p><font size="4" color="red">线程和上下文</font><br>每一个用到OpenGL函数的额外线程都需要有自己的上下文，并且需要显式地连接到第一个上下文以便共享OpenGL对象，驱动程序会为每一个线程创建一个命令队列。如下图所示：<br><img src="http://oqcvzqam1.bkt.clouddn.com/Transfer_Insight28_9.png" alt=""></p>
<p><font size="4" color="red">多线程共享上下文时会的同步问题</font></p>
<ul>
<li>由于多个线程之间没有隐式同步，可能会发生一个线程正在上传数据你，而另一个线程在用这些数据，这样可能会导致用的时候只上传了部分mesh或者部分实例化数据等等。</li>
<li>可能由于多个线程在驱动里共享上下文的原因， 会导致每帧的渲染时长增加0.5ms左右。</li>
<li>多线程共享上下文并不会让数据传输和渲染并行执行。</li>
</ul>
<p><font size="4" color="red">避免多线程共享上下文</font><br>建议即使用到多个线程离线上传数据或任务时，也不要共享上下文。如下图所示：<br><img src="http://oqcvzqam1.bkt.clouddn.com/Transfer_Insight28_10.png" alt=""><br>这幅图中没有画出驱动线程。在单线程环境下，客户端只有一个应用程序线程，同时负责将数据从CPU传输到驱动内存的任务，以及利用这些数据进行渲染的任务。在客户端有两个线程和一个上下文的环境下，应用程序线程负责将数据传输到驱动内存，同时渲染线程会比应用程序线程滞后一帧，渲染N-1帧的数据。可以看到多线程单上下文的环境下，帧渲染时长比单线程短了很多。</p>
<p><font size="5" color="">补充和总结</font></p>
<hr>
<ol>
<li>在渲染循环中，如果在某一帧使用glEnable改变了某个状态，由于OpenGL会发生一个漫长的状态验证过程，所以可能会增加很多渲染时间。</li>
<li>通常情况下，建议使用单线程和多缓冲（map时设置 GL_MAP_UNSYCHRONIZED_BIT标志），因为对于提升现有程序的性能它是一个更简单有效地方式。</li>
</ol>
<hr>
<p>参考文献：《OpenGL Insight》- Chapter28:Asynchronous Buffer Transfers</p>
]]></content>
      
        <categories>
            
            <category> OpenGL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 异步传输 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[老张培训笔记第三课工厂模式和单例模式]]></title>
      <url>/2017/07/18/%E8%80%81%E5%BC%A0%E5%9F%B9%E8%AE%AD%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%89%E8%AF%BE/</url>
      <content type="html"><![CDATA[<p>感谢老张！<br><a id="more"></a></p>
<hr>
<p>案例：暴发户有几两汽车：Benz、Audi，上不同的车都会有对应的开车行为。</p>
<p><font size="5" color="orange">简单工厂</font></p>
<hr>
<p>最简单的实现方式如下：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>
#include <string>

class CCar {
public:
    virtual void driveV() = 0;
};

class CBenz : public CCar{
public:
    virtual void driveV() override{
        std::cout << "Driving Benz..." << std::endl;
    }
};

class CAudi : public CCar {
public:
    virtual void driveV() override {
        std::cout << "Driving Audi..." << std::endl;
    }
};

class CCarFactory {
public:
    CCar* createCar(std::string vCarName) {
        if ("Benz" == vCarName)
            return new CBenz;
        else if ("Audi" == vCarName)
            return new CAudi;
        else
            return NULL;
        }
};

int main() {
    std::string CarName;
    std::cin >> CarName;
    CCarFactory CarFactory;
    CCar* Car = CarFactory.createCar(CarName);
    if(Car)
        Car->driveV();
    return 0;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>奔驰CBenz和奥迪CAudi都继承自基类车CCar。有一个专门的工厂类来负责实例对象的创建，被创建的实例都具有相同的父类，这就是简单工厂模式。</p>
<p>其优点是只需要提供车的名字，就可以在工厂类里创建出对应的车类，不用去关心具体的创建过程。让对象的业务（即开车），与对象的创建（即造车）分离开来，降低了系统的耦合度。但是缺点也是很明显的，它不符合开闭原则，因为用到了类似switch-case的if-else语句，当增加新的车类型时，需要去修改工厂类的代码。</p>
<p><font size="5" color="orange">工厂方法</font></p>
<hr>
<p>简单工厂是把所有车的创建都放在一个工厂里完成，但是随着车类型越来越多，每种车还需要在工厂里生产、装配、维护，工序变得更复杂，无疑这个工厂太繁重了。一个解决方案是：每种车都由一个专属的工厂来生产，这些工厂又被一个boss工厂来管理。</p>
<pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>
#include <string>
#include <vector>

class CCar {
public:
    virtual void driveV() = 0;
};

class CBenz : public CCar{
public:
    virtual void driveV() override{
        std::cout << "Driving Benz..." << std::endl;
    }
};

class CAudi : public CCar {
public:
    virtual void driveV() override {
        std::cout << "Driving Audi..." << std::endl;
    }
};

class CAbstractFactory {
public:
    virtual CCar* createCar() = 0;
};

class CBenzFactory : public CAbstractFactory{
public:
    virtual CCar* createCar() override {
        return new CBenz();
    }
};

class CAudiFactory : public CAbstractFactory {
public:
    virtual CCar* createCar() override {
        return new CAudi();
    }
};

int main() {
    CAbstractFactory* AbstractFactory = new CBenzFactory();
    CCar* Car = AbstractFactory->createCar();
    Car->driveV();
    return 0;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当需要增加保时捷这种车时，只需要增加一个派生自CCar的CPorsche类，和一个派生自CAbstractFactory的CPorscheFactory工厂类。符合开闭原则。</p>
<p>但是上面的代码需要用户知道奔驰车对应的工厂类名是什么，无法直接通过字符串来创建对应的车，还是需要加如下的代码：</p>
<pre class="line-numbers language-c++"><code class="language-c++">CCar* createCar(const std::string& vCarName) {
    if ("Benz" == vCarName) {
        CAbstractFactory* AbstractFactory = new CBenzFactory();
        return AbstractFactory->createCar();
    }
    else if ("Audi" == vCarName) {
        CAbstractFactory* AbstractFactory = new CAudiFactory();
        return AbstractFactory->createCar();
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这样就还是无法满足开闭原则了。如果用户输入一个字符串，就直接给他创建一个对应的车该多好。需要让字符串和车联系在一起，很容易想到在车类里增加一个字符串变量<code>m_CarName</code>，标志这辆车的名字。如果用户输入的字符串和车对象里的名字匹配，就返回这辆车：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>
#include <string>
#include <vector>

class CCar {
private:
    std::string m_CarName;
public:
    virtual void driveV() = 0;

    void setCarName(const std::string& vCarName) {
        m_CarName = vCarName;
    }

    const std::string& getCarName() const {
        return m_CarName;
    }
};

class CBenz : public CCar {
public:
    virtual void driveV() override {
        std::cout << "Driving Benz..." << std::endl;
    }
};

class CAudi : public CCar {
public:
    virtual void driveV() override {
        std::cout << "Driving Audi..." << std::endl;
    }
};

std::vector<CCar*> Cars;

class CAbstractFactory {
public:
    virtual void createCar() = 0;

    CCar* getCar(std::string vCarName) {
        for (int i = 0; i < Cars.size(); i++) {
            if (vCarName == Cars[i]->getCarName())
                return Cars[i];
        }
        return NULL;
    }
};

class CBenzFactory : public CAbstractFactory {
public:
    virtual void createCar() override {
        CCar* Car = new CBenz();
        Car->setCarName("Benz");
        Cars.push_back(Car);
    }

    CBenzFactory() {
        createCar();
    }
};

class CAudiFactory : public CAbstractFactory {
public:
    virtual void createCar() override {
        CCar* Car = new CAudi();
        Car->setCarName("Audi");
        Cars.push_back(Car);
    }

    CAudiFactory() {
        createCar();
    }
};

int main() {
    CBenzFactory BenzFactory;
    CAudiFactory AudiFactory;
    CAbstractFactory* AbstractFactory = &BenzFactory;
    CCar* Car = AbstractFactory->getCar("Porsche");
    if (Car)
        Car->driveV();
    return 0;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面的代码是在每个工厂的构造函数里，把奥迪CAudi、奔驰CBenz等车创建好了存入仓库（即全局变量Cars）里，当用户需用某种车时，根据用户输入的字符串（车名）去仓库里找到这辆车返回给用户。具体方法时把用户输入的字符串和仓库里所有车的属性：车名，进行匹配。</p>
<p>当需要增加保时捷时，只需要添加保时捷类和保时捷工厂类：</p>
<pre class="line-numbers language-c++"><code class="language-c++">class CPorsche :public CCar {
    virtual void driveV() override {
        std::cout << "Driving Porsche" << std::endl;
    }
};

class CPorscheFactory :public CAbstractFactory {
public:
    virtual void createCar() override {
        CCar* Car = new CPorsche();
        Car->setCarName("Porsche");
        Cars.push_back(Car);
    }

    CPorscheFactory() {
        createCar();
    }
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在main函数开头添加对保时捷工厂对象：</p>
<pre class="line-numbers language-c++"><code class="language-c++">CPorscheFactory PoscheFactory;
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>很显然，这种设计是符合开闭原则的，并没有去改动已有的代码设计。但是需要将所有车对象都存储到仓库里，这无疑很占内存，如果暴发户在某一时刻只需要用到奔驰，但是上面的代码在这一刻实际上是奔驰、奥迪、宝马都已经生成了，是种内存浪费。其实上面的代码体现了对象池模式：事先将对象new好存储到对象池里，需要时从对象池里取出，不需要时放回对象池。对象池模式对需要频繁创建、销毁的对象很有好处，因为需要了去取，不需要了放回去，就省去了频繁的耗时好性能的new和delete操作（一次就好）。</p>
<p>而且上面的代码有个问题：工厂模式存在的初衷就是代替new，在用户需要时才立即创建对象，上面代码是在用户需要之前就创建好了。这其实是个致命的问题，如果有两个暴发户都需要奔驰车，那么他们去工厂里拿的将是同一辆车（取到的奔驰车对象的地址是一样的），这明显不对。还是应该每个人都去找奔驰厂商，让厂商给他们每个人都new一辆奔驰。</p>
<p>那我们这样考虑：当用户输入字符串时，去工业园区找对应的厂商（这里厂商的意思是具体的工厂对象，比如生产奔驰的工厂），让厂商立即造车。这样做就和new的功能一样了。更改一下上面的代码，取消车的字符串标志，移到厂商类里：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>
#include <string>
#include <vector>

class CCar {

public:
    virtual void driveV() = 0;
};

class CBenz : public CCar {
public:
    virtual void driveV() override {
        std::cout << "Driving Benz..." << std::endl;
    }
};

class CAudi : public CCar {
public:
    virtual void driveV() override {
        std::cout << "Driving Audi..." << std::endl;
    }
};

class CAbstractFactory {
private:
    std::string m_CarName;

public:
    virtual CCar* createCar() = 0;

    void setCarName(const std::string& vCarName) {
        m_CarName = vCarName;
    }

    const std::string& getCarName() const {
        return m_CarName;
    }
};

std::vector<CAbstractFactory*> g_Factoris;

class CBenzFactory : public CAbstractFactory {
public:
    virtual CCar* createCar() override {
        return new CBenz();
    }

    CBenzFactory() {
        setCarName("Benz");
        g_Factoris.push_back(this);
    }
};

class CAudiFactory : public CAbstractFactory {
public:
    virtual CCar* createCar() override {
        return new CAudi();
    }

    CAudiFactory() {
        setCarName("Audi");
        g_Factoris.push_back(this);
    }
};

class CFactoryProducer {
public:
    CAbstractFactory* getCar(std::string vCarName) {
        for (int i = 0; i < g_Factoris.size(); i++) {
            if (vCarName == g_Factoris[i]->getCarName())
                return g_Factoris[i];
        }
        return NULL;
    }
};

int main() {
    CBenzFactory BenzFactory;
    CAudiFactory AudiFactory;
    CFactoryProducer FactoryProducer;
    CCar* Car = FactoryProducer.getCar("Benz")->createCar();
    if (Car)
        Car->driveV();
    return 0;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>由于无法在CAbstractFactory 类里直接使用CAbstractFactory *类型的全局变量g_Factoris，所以上面的代码增加了一个工厂生成器的类CFactoryProducer ，用来根据字符串找出对应的厂商。</p>
<p>上面的代码可以直接用字符串生成对应的车对象，符合开闭原则，而且和new的功能一样，对象是用户需要时才创建的。虽然在工业园区（即全局变量g_Factoris）里也需要事先保存所有的工厂对象，但是这比上一个方案要好一些，通常情况下车对象都比工厂对象要复杂、要大一些，工厂毕竟只需要new一个车对象就可以了，而车里可能还会添加很多其他的属性，诸如引擎、座椅、制动系统等等。</p>
<p><font size="5" color="orange">直接通过字符串来生成对象的工厂模式</font></p>
<hr>
<p>而且这两个方案都有一个不好的地方：需要去遍历仓库里的所有车或者工业园区里的所有厂商，速度比较慢。能不能直接通过字符串去找到对应的厂商？可以的，这可以用map数据结构来实现，让字符串和对应的厂商类对象组成键值对，存入到map中。需要时直接根据字符串去map中找到对应的厂商。</p>
<pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>
#include <string>
#include <vector>
#include <map>

class CCar {
public:
    virtual void driveV() = 0;
};

class CBenz : public CCar {
public:
    virtual void driveV() override {
        std::cout << "Driving Benz..." << std::endl;
    }
};

class CAudi : public CCar {
public:
    virtual void driveV() override {
        std::cout << "Driving Audi..." << std::endl;
    }
};

class CAbstractFactory {
public:
    virtual CCar* createCar() = 0;
};

std::map<std::string, CAbstractFactory*> g_FactoriesMap;

class CBenzFactory : public CAbstractFactory {
public:
    virtual CCar* createCar() override {
        return new CBenz();
    }

    CBenzFactory(const std::string vCarName) {
        g_FactoriesMap[vCarName] = this;
    }
};

class CAudiFactory : public CAbstractFactory {
public:
    virtual CCar* createCar() override {
        return new CAudi();
    }

    CAudiFactory(const std::string vCarName) {
        g_FactoriesMap[vCarName] = this;
    }
};

class CFactoryProducer {
public:
    CAbstractFactory* getCar(std::string vCarName) {
        if (g_FactoriesMap[vCarName]) {
            return g_FactoriesMap[vCarName];
        }
        return NULL;
    }
};

int main() {
    CBenzFactory BenzFactory("Benz");
    CAudiFactory AudiFactory("Audi");
    CFactoryProducer FactoryProducer;
    CCar* Car = FactoryProducer.getCar("Audi")->createCar();
    if (Car)
        Car->driveV();
    return 0;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在上面的代码中用map来代替了之前的vector，这样就可以直接用字符串在map中找到对应的厂商了，不用去遍历map中的所有厂商。</p>
<p>上面的代码还有可以改进的地方：</p>
<ul>
<li>所有的厂商可以通过一个模板类来生成，而不需要通过抽象工厂类CAbstractFactory来派生了（所有的车就不要通过模板来生成了，因为还需要通过派生来实现驾车行为的多态，而且可以通过奔驰类作为模板参数来生成对应的奔驰厂商，但是车没有合适的模板参数）。</li>
<li>可以把全局变量g_FactoriesMap封装到CFactoryProducer类里。</li>
<li>字符串和对应厂商注册到g_FactoriesMap这件事散落于产商的构造函数里，应该将它移到CFactoryProducer类里，毕竟现在g_FactoriesMap已经是它的数据成员了。</li>
</ul>
<pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>
#include <string>
#include <vector>
#include <map>

class CCar {
public:
    virtual void driveV() {};
};

class CBenz : public CCar {
public:
    virtual void driveV() override {
        std::cout << "Driving Benz..." << std::endl;
    }
};

class CAudi : public CCar {
public:
    virtual void driveV() override {
        std::cout << "Driving Audi..." << std::endl;
    }
};

template <typename CarByFactory>
class CCarFactory;

class CFactoryProducer {
private:
    std::map<std::string, CCarFactory<CCar>*> g_Factories;

public:
    CCarFactory<CCar>* getCar(std::string vCarName) {
        if (g_Factories[vCarName]) {
            return g_Factories[vCarName];
        }
        return NULL;
    }

    void registerFactory(const std::string& vCarName, CCarFactory<CCar>* vFactory) {
        g_Factories[vCarName] = vFactory;
    }
};

CFactoryProducer g_FactoryProducer;

template <typename CarByFactory>
class CCarFactory {
public:
    CCarFactory(const std::string vCarName) {
        g_FactoryProducer.registerFactory(vCarName, reinterpret_cast<CCarFactory<CCar>*>(this));
    }

    virtual CCar* createCarV() {
        return new CarByFactory();
    }
};

int main() {
    CCarFactory<CBenz> BenzFactory("Benz");
    CCarFactory<CAudi> AudiFactory("Audi");
    CCarFactory<CCar>* CarFactory = g_FactoryProducer.getCar("Audi");
    if (CarFactory) {
        CCar* Car = CarFactory->createCarV();
        if (Car)
            Car->driveV();
    }
    return 0;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>把这些类写到不同文件中，代码如下：</p>
<pre class="line-numbers language-c++"><code class="language-c++">CCar.h:
#pragma once
class CCar {
public:
    virtual void driveV() {};
    virtual ~CCar() {}
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">CAudi.h:
#pragma once
#include "CCar.h"

class CAudi :public CCar{
public:
    virtual void driveV() override;
    ~CAudi() {}
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">CAudi.cpp
#include "CAudi.h"
#include <iostream>

void CAudi::driveV() {
    std::cout << "Driving Audi..." << std::endl;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">CBenz.h:
#pragma once
#include "CCar.h"

class CBenz : public CCar {
public:
    virtual void driveV() override;
    ~CBenz(){}
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">CBenz.h:
#include "CBenz.h"
#include <iostream>

void CBenz::driveV() {
    std::cout << "Driving Benz..." << std::endl;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">CCarFactory.h:
#pragma once
#include <iostream>
#include "CCar.h"
#include "CFactoryProducer.h"

extern CFactoryProducer g_FactoryProducer;

template <typename CarByFactory>
class CCarFactory {
public:
    CCarFactory(const std::string vCarName) {
        g_FactoryProducer.registerFactory(vCarName, reinterpret_cast<CCarFactory<CCar>*>(this));
    }

    virtual CCar* createCarV() {
        return new CarByFactory();
    }
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">CFactoryProducer .h:
#pragma once
#include <map>

class CCar;

template <typename CarByFactory>
class CCarFactory;

class CFactoryProducer {
private:
    std::map<std::string, CCarFactory<CCar>*> g_Factories;

public:
    CCarFactory<CCar>* getCar(std::string vCarName);
    void registerFactory(const std::string& vCarName, CCarFactory<CCar>* vFactory);
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">CFactoryProducer.cpp
#include "CFactoryProducer.h"
#include "CCarFactory.h"
#include "CCar.h"

CCarFactory<CCar>* CFactoryProducer::getCar(std::string vCarName) {
    if (g_Factories[vCarName]) {
        return g_Factories[vCarName];
    }
    return NULL;
}

void CFactoryProducer::registerFactory(const std::string& vCarName, CCarFactory<CCar>* vFactory) {
    g_Factories[vCarName] = vFactory;
}

CFactoryProducer g_FactoryProducer;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">main.cpp:
#include "CFactoryProducer.h"
#include "CCarFactory.h"
#include "CBenz.h"
#include "CAudi.h"

int main() {
    CCarFactory<CBenz> AudiFactory("Benz");
    CCarFactory<CAudi> BenzFactory("Audi");
    CCarFactory<CCar>* CarFactory = g_FactoryProducer.getCar("Benz");
    if (CarFactory) {
        CCar* Car = CarFactory->createCarV();
        if (Car)
            Car->driveV();
    }
    return 0;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面代码有几个值得注意的地方：</p>
<ul>
<li>模板类、模板函数的声明和定义应该放在一个文件中。</li>
<li>不要在头文件中定义全局变量。应该在cpp中定义，然后在头文件中用到时用extern声明一下。比如上面代码g_FactoryProducer在CFactoryProducer.cpp中定义，在CCarFactory.h中声明，扩大了该变量的作用域。</li>
<li>在模板类CCarFactory中，createCarV函数使用了关键字virtual修饰，就会为当前的实体类创建虚表和虚指针，比如在执行<code>CCarFactory&lt;CBenz&gt; AudiFactory(&quot;Benz&quot;);</code>时，构造函数会把虚指针指向CBenz生的模板类对象AudiFactory，虚指针指向的虚表里保存了AudiFactory对象的createCarV函数的入口地址，即使在执行registerFactory函数后，将AudiFactory对象指针强制转换为了CCarFactory<ccar>*类型，但是虚指针指向的地址是不会变的，所以main函数中执行CarFactory-&gt;createCarV()函数时，还是调用的CCarFactory<cbenz>对象的createV函数，new的还是CBenz对象。这种模板类使用虚函数，来模拟多态的方式是很有意思的（其实多态本质上也是这种原理，可参考<a href="http://blog.csdn.net/menyangyang/article/details/24779257" target="_blank" rel="external">《virtual C++多态实现原理》</a>一文）。</cbenz></ccar></li>
<li>reinterpret_cast<t*>用于将一个指针强制转换为另一种毫不相干的指针类型，但是要慎用，可参考<a href="http://blog.csdn.net/coding_hello/article/details/2211466" target="_blank" rel="external">《reinterpret_cast的本质》</a>一文。上面代码由于是从子类参数模板指针，转换为父类参数模板指针，无法像子类指针向父类指针那样自动转换，所以需要用reinterpret_cast来强制转换。</t*></li>
<li><p>dynamic_cast<t>用于类层次间的上行转换和下行转换，在下行转换时，会判断基类指针是否原本就是指向子类对象的，否则的话会返回NULL，所以它又称为类型安全的转换。</t></p>
<pre class="line-numbers language-c++"><code class="language-c++">  class A {
      virtual void f() {}
  };

  class B : public A {
      virtual void f() {}
  };

  int main() {
      A *pA = new A();
      A *pA1 = new B();
      B *pB = dynamic_cast<B*>(pA);   //返回NULL
      B *pB1 = dynamic_cast<B*>(pA1); //返回的指针正确指向原先new出来的B对象
      return 0;
  }
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注意使用dynamic_cast转换时，基类必须要有虚函数，因为它本身就是用于多态类型指针之间的转换。</p>
</li>
<li><p>在CFactoryProducer .h中对要使用的类进行了声明，而不是直接包含如下头文件：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#include "CCarFactory.h"
#include "CCar.h"
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>因为这样会造成CCarFactory.h头文件和CFactoryProducer .h头文件相互包含，会出错：C4430 缺少类型说明符-假定为int，原因可参考<a href="http://popperelay.com/2017/05/09/C++%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5/" target="_blank" rel="external">《编译链接错误》</a>一文第6条。</p>
</li>
<li><p>还有一点需要注意的是CCarFactory实体类对象是写在main函数中的，并没有写作全局对象，这样可以保证在执行其构造函数时另一个全局变量g_FactoryProducer已经初始化。</p>
</li>
</ul>
<p><font size="5" color="orange">Bug来了，单例来了</font></p>
<hr>
<p>但是，上面程序中，我们是把CCarFactory实体类对象（AudiFactory等）写在main函数中的，将它们写到对应车类的cpp文件中更好，比如在CAudi.cpp中定义AudiFactory对象，因为毕竟改main函数也不符合开闭原则。这样一来程序就会有多个全局变量：AudiFactory、BenzFactory和g_FactoryProducer，运行程序会出错：读取访问权限冲突。这是因为C++全局变量初始化的顺序是不定的，在CCarFactory<cbenz>的构造函数中用到了g_FactoryProducer，这时候g_FactoryProducer可能还没有被初始化，导致程序运行出错。<br>【温馨提示：要找到这个错误原因还是有一定难度的，但是如果养成良好的编码习惯，在使用g_FactoryProducer之前先判断其是否为空，就会很快发现问题所在】</cbenz></p>
<p>很容易想到的解决方案就是：将g_FactoryProducer从对象改为指针，在CCarFactory构造函数中使用它之前先进行非空判断，如果空就初始化。增改代码如下：</p>
<pre class="line-numbers language-c++"><code class="language-c++">CFactoryProducer.cpp: 
CFactoryProducer *g_FactoryProducer=new CFactoryProducer();
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">CCarFactory.h:
extern CFactoryProducer *g_FactoryProducer;

public:
    CCarFactory(const std::string vCarName) {
        if (!g_FactoryProducer)
            g_FactoryProducer = new CFactoryProducer();
        g_FactoryProducer->registerFactory(vCarName, reinterpret_cast<CCarFactory<CCar>*>(this));
    }
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>好像并没有什么问题，但是运行发现并没有输出任何结果。这是因为在CCarFactory.h中初始化g_FactoryProducer后，是向该g_FactoryProducer中注册信息，但是在CFactoryProducer.cpp中又为g_FactoryProducer赋予了另外不同的内存地址，导致前后两者的g_FactoryProducer并不是指向同一个对象，造成最后并没有结果输出。</p>
<p>解决这个问题的方法就是使用单例模式，让g_FactoryProducer只被创建一次（或者说只被初始化一次），所以我们需要将CFactoryProducer类改为单例类：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#pragma once
#include <map>

class CCar;

template <typename CarByFactory>
class CCarFactory;

class CFactoryProducer {
private:
    std::map<std::string, CCarFactory<CCar>*> g_Factories;
    static CFactoryProducer* g_FactoryProducer;

    CFactoryProducer() {}

public:
    CCar* getCar(std::string vCarName);

    void registerFactory(const std::string& vCarName, CCarFactory<CCar>* vFactory);

    static CFactoryProducer* getInstance() {
        if (!g_FactoryProducer)
            g_FactoryProducer = new CFactoryProducer();
        return g_FactoryProducer;
    }
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当然，以前和g_FactoryProducer相关的地方都要改。如果运行出错：LNK2001 无法解析的外部符号，有可能是我们没有在cpp中对静态变量g_FactoryProducer初始化（静态变量必须初始化以后才能用）：</p>
<pre class="line-numbers language-c++"><code class="language-c++">CFactoryProducer* CFactoryProducer::g_FactoryProducer = NULL;
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>由于在getInstance函数中，会先判断g_FactoryProducer 是否存在，如果不存在就会立即创建，所以在CCarFactory类构造函数中调用registerFactory函数时g_FactoryProducer一定初始化过了，不会再出现之前的读取访问权限冲突（g_FactoryProducer还没有被初始化而导致的空指针）：</p>
<pre class="line-numbers language-c++"><code class="language-c++">CFactoryProducer::getInstance()->registerFactory(vCarName, reinterpret_cast<CCarFactory<CCar>*>(this));
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>其实上面CFactoryProducer类中的成员变量g_FactoryProducer不是必须的，因为它是静态变量，而且只在getInstance函数中使用到，所以可以直接在getInstance中初始化一个临时变量，然后返回即可：</p>
<pre class="line-numbers language-c++"><code class="language-c++">static CFactoryProducer* getInstance() {
    static CFactoryProducer* g_FactoryProducer = NULL;
    if (!g_FactoryProducer)
        g_FactoryProducer = new CFactoryProducer();
    return g_FactoryProducer;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>下面给出工厂模式的所有源码：</p>
<pre class="line-numbers language-c++"><code class="language-c++">CCar.h
#pragma once
class CCar {
public:
    virtual ~CCar() {}
    virtual void driveV() {};
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">CAudi.h
#pragma once
#include "CCar.h"

class CAudi :public CCar{
public:
    virtual void driveV() override;
    ~CAudi() {}
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">CAudi.cpp
#include "CAudi.h"
#include <iostream>
#include "CCarFactory.h"

void CAudi::driveV() {
    std::cout << "Driving Audi..." << std::endl;
}

CCarFactory<CAudi> BenzFactory("Audi");
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">CBenz.h
#pragma once
#include "CCar.h"

class CBenz : public CCar {
public:
    virtual void driveV() override;
    ~CBenz(){}
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">CBenz.cpp
#include "CBenz.h"
#include <iostream>
#include "CCarFactory.h"

void CBenz::driveV() {
    std::cout << "Driving Benz..." << std::endl;
}

CCarFactory<CBenz> AudiFactory("Benz");
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">CCarFactory.h
#pragma once
#include <iostream>
#include "CCar.h"
#include "CFactoryProducer.h"

extern CFactoryProducer *g_FactoryProducer;

template <typename CarByFactory>
class CCarFactory {
public:
    CCarFactory(const std::string vCarName) {
        CFactoryProducer::getInstance()->registerFactory(vCarName, reinterpret_cast<CCarFactory<CCar>*>(this));
    }

    virtual CCar* createCarV() {
        return new CarByFactory();
    }
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">CFactoryProducer .h
#pragma once
#include <map>

class CCar;

template <typename CarByFactory>
class CCarFactory;

class CFactoryProducer {
private:
    std::map<std::string, CCarFactory<CCar>*> g_Factories;

    CFactoryProducer() {}

public:
    CCar* getCar(std::string vCarName);

    void registerFactory(const std::string& vCarName, CCarFactory<CCar>* vFactory);

    static CFactoryProducer* getInstance() {
        static CFactoryProducer* g_FactoryProducer = NULL;
        if (!g_FactoryProducer)
            g_FactoryProducer = new CFactoryProducer();
        return g_FactoryProducer;
    }
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">CFactoryProducer.cpp
#include "CFactoryProducer.h"
#include "CCarFactory.h"
#include "CCar.h"

CCar* CFactoryProducer::getCar(std::string vCarName) {
    if (g_Factories[vCarName]) {
        return g_Factories[vCarName]->createCarV();
    }
    return NULL;
}

void CFactoryProducer::registerFactory(const std::string& vCarName, CCarFactory<CCar>* vFactory) {
    g_Factories[vCarName] = vFactory;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">main.cpp
#include "CFactoryProducer.h"
#include "CBenz.h"
#include "CAudi.h"

int main() {
    CCar* Car = CFactoryProducer::getInstance()->getCar("Audi");
    if (Car) Car->driveV();
    return 0;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><font size="5" color="orange">单例模式里释放单例对象</font></p>
<hr>
<p>由于单例被创建的初衷，就是和main函数（或者整个程序）同生共死，当程序结束时，单例才完成它的使命。先看下面最简单的单例代码：</p>
<pre class="line-numbers language-c++"><code class="language-c++">SingletonA.h:
#include <iostream>

class CSingletonA {
public:
    static CSingletonA *getInstance(){
        if (!m_pInstance)
            m_pInstance = new CSingletonA;
        return m_pInstance;
    }

    void print() {
        std::cout << "Singleton A" << std::endl;
    }

private:
    static CSingletonA *m_pInstance;

    CSingletonA() {}
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">SingletonA.cpp:
#include "SingletonA.h"

CSingletonA* CSingletonA::m_pInstance = NULL;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><font size="4" color="red">释放单例对象方法1：使用内部类对象</font><br>我们注意到，上面代码中，单例对象指针m_pInstance是由new动态分配在堆上的，在程序结束时，分配在堆上的内存是不会自动由操作系统释放的，必须我们调用delete来释放。而delete的时间应该是在程序结束时，由于在程序结束时系统会自动释放一些分配在栈上的内存，所以我们可以在系统释放栈内存时调用delete。具体做法是：在CSingletonA里，加一个内部类，该内部类的析构函数里调用delete删除单例对象指针，然后定义一个该内部类对象：</p>
<pre class="line-numbers language-c++"><code class="language-c++">SingletonA.h:
#include <iostream>

class CSingletonA {
public:
    class CGarbageCollection {
    public:
        virtual ~CGarbageCollection() {
            if (m_pInstance)
                delete m_pInstance;
        }
    };

    static CSingletonA *getInstance(){
        if (!m_pInstance)
            m_pInstance = new CSingletonA;
        return m_pInstance;
    }

    void print() {
        std::cout << "Singleton A" << std::endl;
    }

    virtual ~CSingletonA() {
        std::cout << "Singleton A deleted" << std::endl;
    }

private:
    static CSingletonA *m_pInstance;
    static CGarbageCollection m_GarbageCollection;

    CSingletonA() {}
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">SingletonA.cpp:
include "SingletonA.h"

CSingletonA* CSingletonA::m_pInstance = NULL;
CSingletonA::CGarbageCollection CSingletonA::m_GarbageCollection;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">main.cpp:
#include "SingletonA.h"

int main()
{
    CSingletonA::getInstance()->print();
    return 0;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注意，内部类CGarbageCollection的对象m_GarbageCollection需要声明为静态的，这样它才会被存储在静态栈空间里，当程序结束（退出main函数）时，系统会释放m_GarbageCollection对象，调用其虚构函数，释放单例对象m_pInstance。所以输出结果如下：</p>
<pre class="line-numbers language-c++"><code class="language-c++">Singleton A
Singleton A deleted
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><font size="4" color="red">释放单例对象方法2：不把单例对象写作指针类型</font><br>当然，既然是因为单例对象被动态创建在堆上，导致它无法被系统自动释放其内存，那么我们也可以不把单例对象写作指针类型，直接用对象类型：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>

class CSingletonA {
public:
    static CSingletonA* getInstance(){
        return &m_pInstance;
    }

    void print() {
        std::cout << "Singleton A" << std::endl;
    }

    virtual ~CSingletonA() {
        std::cout << "Singleton A deleted" << std::endl;
    }

private:
    static CSingletonA m_pInstance;

    CSingletonA() {}
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">#include "SingletonA.h"

CSingletonA CSingletonA::m_pInstance;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>由于单例对象m_pInstance不是new动态创建的，而是被分配在程序栈空间里的，所以当程序结束时，会自动释放该内存，调用其析构函数，main函数不变输出结果和之前一样。这种方法虽然简单，但是会让单例对象在程序一开始就被分配内存，直到程序结束，但是第一种方法，单例对象只是在程序第一次调用getInstance函数时才被创建出来。</p>
<p><font size="5" color="orange">单例继承</font><br>如果我们的单例类需要被继承怎么办？看下面的例子（SingletonA的代码和上面使用内部类对象时的一样）：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#include "SingletonA.h"

class CSingletonB : public CSingletonA {
public:
    CSingletonB() {}

    void print() {
        std::cout << "Sigleton B" << std::endl;
    }
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在其构造函数<code>CSingletonB() {}</code>处，会发生编译错误：</p>
<pre class="line-numbers language-c++"><code class="language-c++">error C2248: “CSingletonA::CSingletonA”: 无法访问 private 成员(在“CSingletonA”类中声明)
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这是因为在执行CSingletonB 的构造函数时，会去访问父类CSingletonA 的构造函数，但是父类是一个单例类，其构造函数是私有的，这样子类就会访问不到，出现上面的编译错误。</p>
<p><font size="4" color="red">单例继承1：保护的构造函数</font><br>最容易想到的就是，把父类的构造函数声明为保护的，这样子类就可以访问到了：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>

class CSingletonA {
public:
    class CGarbageCollection {
    public:
        virtual ~CGarbageCollection() {
            if (m_pInstance)
                delete m_pInstance;
        }
    };

    static CSingletonA *getInstance() {
        if (!m_pInstance)
            m_pInstance = new CSingletonA;
        return m_pInstance;
    }

    void print() {
        std::cout << "Singleton A" << std::endl;
    }

    virtual ~CSingletonA() {
        std::cout << "Singleton A deleted" << std::endl;
    }

private:
    static CSingletonA *m_pInstance;
    static CGarbageCollection m_GarbageCollection;

protected:
    CSingletonA() {}
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><font size="4" color="red">单例继承2：把子类声明为父类的友元类</font><br>如果觉得把构造函数声明为保护的，封装性不好，可以把在父类中，把子类声明为其友元类，这样子类就可以访问到父类的任何私有成员或者函数了：</p>
<pre class="line-numbers language-c++"><code class="language-c++">SingletonA.h:
#include <iostream>

namespace NameSpaceB {
    class CSingletonB;
}

namespace NameSpaceA {
    class CSingletonA {
    public:
        class CGarbageCollection {
        public:
            virtual ~CGarbageCollection() {
                if (m_pInstance)
                    delete m_pInstance;
            }
        };

        static CSingletonA *getInstance() {
            if (!m_pInstance)
                m_pInstance = new CSingletonA;
            return m_pInstance;
        }

        void print() {
            std::cout << "Singleton A" << std::endl;
        }

        virtual ~CSingletonA() {
            std::cout << "Singleton A deleted" << std::endl;
        }

    private:
        static CSingletonA *m_pInstance;
        static CGarbageCollection m_GarbageCollection;

        CSingletonA() {}

        friend class NameSpaceB::CSingletonB;
    };
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">SingletonA.cpp:
#include "SingletonA.h"

NameSpaceA::CSingletonA* NameSpaceA::CSingletonA::m_pInstance = NULL;
NameSpaceA::CSingletonA::CGarbageCollection NameSpaceA::CSingletonA::m_GarbageCollection;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">SingletonB.h:
#include "SingletonA.h"

namespace NameSpaceB {
    class CSingletonB : public NameSpaceA::CSingletonA {
    public:
        CSingletonB() {}

        void print() {
            std::cout << "Singleton B" << std::endl;
        }
    };
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">main.cpp:
#include "SingletonA.h"
#include "SingletonB.h"

int main()
{
    NameSpaceA::CSingletonA::getInstance()->print();
    NameSpaceB::CSingletonB B;
    B.print();
    return 0;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里把父类CSingletonA和子类CSingletonB 分别放在了两个命名空间里，在父类中声明子类为其友元类：</p>
<pre class="line-numbers language-c++"><code class="language-c++">friend class NameSpaceB::CSingletonB;
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>注意父类要访问到另一个命名空间里的子类，需要做如下前置声明，来扩大子类的作用域：</p>
<pre class="line-numbers language-c++"><code class="language-c++">namespace NameSpaceB {
    class CSingletonB;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>程序运行后输出如下：</p>
<pre class="line-numbers language-c++"><code class="language-c++">Singleton A
Singleton B
Singleton A deleted
Singleton A deleted
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      
        <categories>
            
            <category> 设计模式 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 工厂模式单例模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[老张培训笔记第二课面向对象设计原则]]></title>
      <url>/2017/07/18/%E8%80%81%E5%BC%A0%E5%9F%B9%E8%AE%AD%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%BA%8C%E8%AF%BE/</url>
      <content type="html"><![CDATA[<p>感谢老张！<br><a id="more"></a></p>
<hr>
<ol>
<li>新增加代码的是否是必须的？判断标准是：<ul>
<li>程序不会因为新增加的代码而发生连锁反应</li>
<li>新增加的代码不用了解源程序过多的细节</li>
</ul>
</li>
<li>枚举就不是一个好的设计风格，因为枚举类型增加时，需要去修改原有的代码，需要去了解源程序与枚举相关的很多地方。</li>
<li>开闭原则：团队开发中，需求增加时，只增加自己的代码，不应该更改已有的代。即对扩展开放，对修改关闭。开闭原则是面向对象最重要的设计原则，其关键在于抽象。</li>
<li><p>案例：绘制圆和正方形。<br>最粗暴的做法如下：</p>
<pre class="line-numbers language-c++"><code class="language-c++"> #include <iostream>

 class CCircle {
 public:
     void draw() {
         std::cout << "Drawing cirlce..." << std::endl;
     }
 };

 class CSquare {
 public:
     void draw() {
         std::cout << "Drawing square..." << std::endl;
     }
 };

 int main() {
     enum EShapeType {
         Circle, Square
     };
     EShapeType shapeType[] = { Circle, Square };
     for (int i = 0; i < sizeof(shapeType) / sizeof(EShapeType); i++) {
         switch (shapeType[i]) {
         case Circle:
             CCircle circle;
             circle.draw();
             break;
         case Square:
             CSquare square;
             square.draw();
             break;
         default:
             break;
         }
     }
     return 0;
 }
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当需求增加时，比如再绘制一个三角形，那么需要加上或更改如下代码：</p>
<pre class="line-numbers language-c++"><code class="language-c++"> class CTriangle {
 public:
     void draw() {
         std::cout << "Drawing triangle..." << std::endl;

     }
 };

 int main() {
     enum EShapeType {
         Circle, Square, Triangle
     };
     EShapeType shapeType[] = { Circle, Square, Triangle };
     for (int i = 0; i < sizeof(shapeType) / sizeof(EShapeType); i++) {
         switch (shapeType[i]) {
         case Circle:
             CCircle circle;
             circle.draw();
             break;
         case Square:
             CSquare square;
             square.draw();
             break;
         case Triangle:
             CTriangle triangle;
             triangle.draw();
         default:
             break;
         }
     }
     return 0;
 }
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>增加的这些代码都是必须的吗？增加的Triangle类是必须的，毕竟多了一种图元，但是改动的枚举类型和增加的case语句是必须的吗？而且需求增加时，改动了原来已有的代码。尤其是程序比较大以后，可能有很多地方都与这些枚举类型有关，那么需求一变，和这些枚举相关的代码都需要随之作出改变，而且还需要事先比较了解整个程序，才能不把程序改坏。很显然不符合开闭原则。这一切的根源都在于枚举的使用，只要使用了枚举就必然伴随类似switch-case的语句，枚举一变，和枚举相关的地方都要变，关联太大，可能会有连锁反应。switch几乎都不符合开闭原则，但是如果switch的是系统枚举值，是无法避免的，系统枚举值很少的话也无伤大雅，这时的函数允许超过50行。</p>
<p>可以为这些图元定义一个虚基类CShape，通过虚基类指针以多态的方式来调用所有子类的绘制函数：</p>
<pre class="line-numbers language-c++"><code class="language-c++"> #include <iostream>
 #include <vector>

 class CShape {
 public:
     virtual void drawV() = 0;
 };

 class CTriangle : public CShape {
 public:
     void drawV() override {
         std::cout << "Drawing triangle..." << std::endl;
     }
 };

 class CQuad : public CShape {
 public:
     void drawV() override {
         std::cout << "Drawing Quad..." << std::endl;
     }
 };

 class CCircle :public CShape {
 public:
     void drawV() override {
         std::cout << "Drawing circle..." << std::endl;
     }
 };

 int main() {
     std::vector<CShape*> shapes;
     shapes.push_back(new CQuad());
     shapes.push_back(new CCircle());
     shapes.push_back(new CTriangle());
     for (unsigned int i = 0; i < shapes.size(); i++) {
         shapes[i]->drawV();
     }
     return 0;
 }
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当要绘制的图元类型增加时，只需要增加一个继承自CShape的子类，再将其对象加入到vector容器里就ok。很明显没有枚举、switch-case牵一发动全身的麻烦。 符合开闭原则。</p>
</li>
<li><p>现实中，没有任何一个程序或软件100%符合开闭原则。因为需求千奇百怪，不可能考虑到每一种情况，不可能对每一种需求都做到开闭原则。比如4中的程序，如果需求变为：按用户指定的顺序来绘制所有图元。此时4中的程序就必须针对该需求作出改变了，实现代码如下：</p>
<pre class="line-numbers language-c++"><code class="language-c++"> #include <iostream>
 #include <algorithm>
 #include <vector>

 class CShape {
 private:
     int priority;

 public:
     virtual void drawV() = 0;

     void setPriority(int iPriority) {
         priority = iPriority;
     }

     friend bool operator<(const CShape& iShape1, const CShape& iShape2) {
         return iShape1.priority < iShape2.priority;
     }

     friend bool priorityLess(CShape* shape1, CShape* shape2) {
         return *shape1 < *shape2;
     }
 };

 class CTriangle : public CShape{
 public:
     CTriangle(int iPriority) {
         setPriority(iPriority);
     }

     void drawV() override {
         std::cout << "Drawing triangle..." << std::endl;
     }
 };

 class CQuad : public CShape {
 public:
     CQuad(int iPriority) {
         setPriority(iPriority);
     }

     void drawV() override {
         std::cout << "Drawing Quad..." << std::endl;
     }
 };

 class CCircle :public CShape {
 public:
     CCircle(int iPriority) {
         setPriority(iPriority);
     }

     void drawV() override {
         std::cout << "Draw circle..." << std::endl;
     }
 };

 int main() {
     std::vector<CShape*> shapes;
     shapes.push_back(new CQuad(2));
     shapes.push_back(new CCircle(1));
     shapes.push_back(new CTriangle(3));
     sort(begin(shapes), end(shapes), priorityLess);
     for (unsigned int i = 0; i < 3; i++) {
         shapes[i]->drawV();
     }
     return 0;
 }
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面的程序值得注意的是：</p>
<ul>
<li>可以使用STL中的sort函数对类对象进行排序，不过需要重载&lt;运算符，因为sort内部是将两个对象进行小于比较来排序的（或者直接用自定义的比较函数作为sort的第三个参数来排序）。</li>
<li>使用sort进行排序，必须是针对对象，而不能是对象指针，否则将会是对指针进行排序，指针实际上是4个字节的整型数据，也就是在对整型数据排序了，这样就根本不会进入到对&lt;符号的重载函数里。但是要实现多态，必须使用对象指针或者引用，所以上面的程序给sort函数指定了第三个参数：priorityLess函数，执行sort函数时会先调用该函数，在该函数里将对象指针shape1、shape2转换为对象<em>shape1、</em>shape2，再将这两个对象进行小于比较，这样就会进入到自定义的&lt;符号重载函数里，按照优先级priority来确定对象的小于关系是否成立。这样就能正常工作了，如果没有priorityLess函数，将是对对象指针这个int型数据在进行排序，多次运行程序时将得到不同的结果，显然是错误的。</li>
</ul>
</li>
<li><p>在实际开发中，需要通过重构不断改善原有的设计（这是很频繁的）。</p>
</li>
<li>重构的目标是：需求变化时尽量满足开闭原则。</li>
<li>在敏捷开发中应该拒绝不成熟的抽象，避免过度设计。</li>
<li><p>案例：母亲给孩子讲故事。</p>
<pre class="line-numbers language-c++"><code class="language-c++"> #include <iostream>

 class CBook {
 public:
     void getContent() {
         std::cout << "This is a book..." << std::endl;
     }
 };

 class CMother {
 public:
     void read(CBook *vBook) {
         std::cout << "Mother is reading: ";
         vBook->getContent();
     }
 };
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>大多数初学者的实现方案都会是像上诉代码一样，这种设计是有问题的。CMother为什么要依赖于CBook呢？母亲除了给孩子读书，就不能读报纸这些了吗？如果要求母亲除了读书还能读报，最粗暴的就是再增加一个CNewspaper类，然后给read函数增加一个CNewspaper指针。很明显，这不符合开闭原则，需求增加时，改变了原有的CMother类。</p>
<p>可以考虑用抽象，将书、报纸等抽象出一个虚基类：出版物类CPublication，让CMother的read函数依赖于这个抽象类，而非具体的类，这样所有继承自这个抽象类的书、报纸等等子类都能被母亲类阅读了：</p>
<pre class="line-numbers language-c++"><code class="language-c++"> #include <iostream>

 class CPublication {
 public:
     virtual void getContentV() = 0;
 };

 class CBook : public CPublication{
 public:
     virtual void getContentV() override {
         std::cout << "This is a book..." << std::endl;
     }
 };

 class CNewspaper : public CPublication {
 public:
     virtual void getContentV() override {
         std::cout << "This is a newspaper..." << std::endl;
     }
 };

 class CMother {
 public:
     void read(CPublication *vPublication) {
         std::cout << "Mother is reading: ";
         vPublication->getContentV();
     }
 };
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>像上面代码CMother类的read函数一样，代码不依赖于具体类，而是依赖于抽象的类，这就是依赖倒置原则。</p>
</li>
<li><p>开闭原则是面向对象设计的目标，依赖倒置原则是实现开闭特性的主要手段。</p>
</li>
<li><p>案例：纠结的正方形和矩形。<br>讲道理，正方形是矩形的特例，让正方形派生自矩形，好像没有什么不对：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>

class CRectangle {
private:
    double m_Width;
    double m_Height;

public:
    virtual void setWidthV(double w) { m_Width = w; }
    virtual void setHeightV(double h) { m_Height = h; }
    double getArea() { return m_Width*m_Height; }
};

class CSquare : public CRectangle {
public:
    void setWidthV(double w) { 
        CRectangle::setWidthV(w); 
        CRectangle::setHeightV(w);
    }

    void setWidthH(double h) {
        CRectangle::setWidthV(h);
        CRectangle::setHeightV(h);
    }
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>若现在有一个函数：</p>
<pre class="line-numbers language-c++"><code class="language-c++">void g(CRectangle* vioRect) {
    vioRect->setWidthV(5);
    vioRect->setHeightV(4);
    assert(vioRect->getArea() == 20);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果外界传给函数g的实参是一个CSquare类指针，但是函数内部并不知道传入的是正方形，还是当做普通矩形来处理，这样一来assert语句将无法通过。也就是说对普通的基类对象可以通过，但是换成子类却无法通过。根源在于在基类CRectangle中长度和宽度的设置互不影响，但是子类CSquare不满足这个条件，实际上就不应该把正方形作为矩形的子类，应该分为两个独立的类。</p>
<p>这个正方形和矩形的例子体现了Liskov替换原则：把基类替换成它的子类，程序不应该产生任何错误和异常。这是判断抽象是否正确的重要依据。</p>
</li>
<li><p>案例：业务需要数据库操作。<br>最粗暴的就不赘述了。由于可能会有多种数据库，我们将多种数据库先抽象出一个数据库的基类：CDBUtility。</p>
<pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>

class CDBUtility {
public:
    virtual void buildConnectionV() = 0;
};

class CMySQLUtility : public CDBUtility{
public:
    virtual void buildConnectionV() override {
        std::cout << "Building connection to MySQL..." << std::endl;
    }
};

class COracleUtility : public CDBUtility {
public:
    virtual void buildConnectionV() override {
        std::cout << "Building connection to Oracle..." << std::endl;
    }
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果现在业务需要使用Oracle数据库，可以让业务类继承COracleUtility 类，就可以使用这个类中的方法了：</p>
<pre class="line-numbers language-c++"><code class="language-c++">class CCustomerDAO : public COracleUtility {
public:
    void doSomething() {
        buildConnectionV();
    }
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>但是这种派生是不符合开闭原则的，当业务使用的数据库发生变化时，需要去更改业务类所继承的父类，改动了原有的CCustomerDAO 类代码。而且让业务类继承数据库类，看着就怪怪的。</p>
<p>应该让数据库类成为业务类的成员变量，通过这个成员变量去使用数据库类中的方法：</p>
<pre class="line-numbers language-c++"><code class="language-c++">class CCustomerDAO{
private:
    CDBUtility* m_pDBUtility;

public:
    void setDBUtility(CDBUtility *vUtility) {
        m_pDBUtility = vUtility;
    }
    void doSomething() {
        m_pDBUtility->buildConnectionV();
    }
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以在main函数中动态地指定业务使用何种数据库：</p>
<pre class="line-numbers language-c++"><code class="language-c++">int main() {
    CCustomerDAO CustomerDAO;
    CustomerDAO.setDBUtility(new COracleUtility());
    CustomerDAO.doSomething();
    return 0;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这样一来无论业务使用何种数据库，只需要在main函数中修改传入的数据库类型即可，而不用去更改原有的类设计。不过这时候main函数不符合开闭原则了，需要修改main函数，后面会讲如何使main函数符合开闭原则的方法。</p>
<p>这个例子体现了合成复用的原则：尽量使用对象成员，而不是继承的方式来达到复用的目的。</p>
</li>
<li><p>绘制图元的一种具体实现方案如下：先将图元转化为像素点，再绘制出所有像素点。代码设计如下：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>
#include <vector>

class CShape {
private:
    std::vector<std::pair<int, int>> m_Pixels;

public:
    virtual void generatePixelV() = 0;

    void drawShape() {
        generatePixelV();
        std::cout << "Drawing pixels on window..." << std::endl;
    }
};

class CRectangle : public CShape{
public:
    virtual void generatePixelV() override {
        std::cout << "Generating pixels on rectangle..." << std::endl;
    }
};

class CTriangle : public CShape {
public:
    virtual void generatePixelV() override {
        std::cout << "Generating pixels on triangle..." << std::endl;
    }
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>现在需求变为：在不同操作系统上，比如windows和linux，实现不同图元的绘制。</p>
<p>前面的虚基类只针对不同图元生成像素点给出了虚函数接口，现在再针对不同操作系统上绘制像素点来增加一个接口：</p>
<pre class="line-numbers language-c++"><code class="language-c++">class CShape {
private:
    std::vector<std::pair<int, int>> m_Pixels;

public:
    virtual void generatePixelV() = 0;

    void drawShape() {
        generatePixelV();
        _drawPixelsV();
    }

protected:
    virtual void _drawPixelsV() = 0;
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在Windows上绘制矩形就可以用下面的类来实现：</p>
<pre class="line-numbers language-c++"><code class="language-c++">class CRectangleOnWindows : public CShape{
public:
    virtual void generatePixelV() override {
        std::cout << "Generating pixels on rectangle..." << std::endl;
    }

protected:
    virtual void _drawPixelsV() override {
        std::cout << "Drawing pixels on windows..." << std::endl;
    }
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在Linux上绘制矩形用下面的类：</p>
<pre class="line-numbers language-c++"><code class="language-c++">class CRectangleOnLinux : public CShape {
public:
    virtual void generatePixelV() override {
        std::cout << "Generating pixels on rectangle..." << std::endl;
    }

protected:
    virtual void _drawPixelsV() override {
        std::cout << "Drawing pixels on linux..." << std::endl;
    }
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>问题很明显了，还有在window和linux上绘制三角形、圆的类还没写呢，如果有m个图元要在n个平台上绘制，那么就会有m*n个类。导致这个问题的根本原因就在于：在一个基类里面有两个独立的变化，通过继承来实现这两种变化，类的数量肯定会很多。</p>
<p>解决方案就是把这两个对立的变化分别作为两个基类：</p>
<pre class="line-numbers language-c++"><code class="language-c++">class CShape {
private:
    std::vector<std::pair<int, int>> m_Pixels;

public:
    virtual void generatePixelV() = 0;

    void drawShape() {
        generatePixelV();
        std::cout << "Drawing pixels on kinds of platform..." << std::endl;
    }
};

class CPlatform {
public:
    virtual void drawPixels(const std::vector<std::pair<int, int>>& vPixels) = 0;
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>那么这两个基类如何联系起来呢？让CShape继承CPlatform？显然不合常理。让子类去多重继承这两个基类？这样的话子类就需要去同时实现<code>generatePixelV()</code>和<code>drawPixels()</code>这两个虚函数接口，实现在不同平台下绘制不同图元又会产生出m*n个子类。而且合成复用原则建议少用继承，所以这里可以考虑遵循合成复用原则：将CPlatform类对象作为CShape类的成员变量：</p>
<pre class="line-numbers language-c++"><code class="language-c++">class CShape {
private:
    std::vector<std::pair<int, int>> m_Pixels;
    CPlatform* m_Platform;

public:
    virtual void generatePixelV() = 0;

    void drawShape() {
        generatePixelV();
        m_Platform->drawPixels(m_Pixels);
    }

    void setPlatform(CPlatform* vPlatform) {
        m_Platform = vPlatform;
    }
};

class CPlatform {
public:
    virtual void drawPixels(const std::vector<std::pair<int, int>>& vPixels) = 0;
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这两个基类的各自的子类只要实现一个虚函数就可以了，互不影响：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>
#include <vector>

class CPlatform {
public:
    virtual void drawPixels(const std::vector<std::pair<int, int>>& vPixels) = 0;
};

class CShape {
private:
    std::vector<std::pair<int, int>> m_Pixels;
    CPlatform *m_pPlatform;

public:
    virtual void generatePixelV() = 0;

    void drawShape() {
        generatePixelV();
        m_pPlatform->drawPixels(m_Pixels);
    }

    void setPlatform(CPlatform* vPlatform) {
        m_pPlatform = vPlatform;
    }
};

class CRectangle : public CShape{
public:
    virtual void generatePixelV() {
        std::cout << "Generating pixels on rectangle...";
    }
};

class CCircle : public CShape {
public:
    virtual void generatePixelV() {
        std::cout << "Generating pixels on circle...";
    }
};

class CWindows : public CPlatform {
public:
    virtual void drawPixels(const std::vector<std::pair<int, int>>& vPixels) {
        std::cout << "Drawing pixels on windows..." << std::endl;
    }
};

class CLinux : public CPlatform {
public:
    virtual void drawPixels(const std::vector<std::pair<int, int>>& vPixels) {
        std::cout << "Drawing pixels on linux..." << std::endl;
    }
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在主函数中可以通过设置子类对象的m_pPlatform变量来指定在哪个平台下绘制图元：</p>
<pre class="line-numbers language-c++"><code class="language-c++">int main() {
    CRectangle Rect;
    Rect.setPlatform(new CWindows());
    Rect.drawShape();
    Rect.setPlatform(new CLinux());
    Rect.drawShape();

    CCircle Circle;
    Circle.setPlatform(new CWindows());
    Circle.drawShape();
    Circle.setPlatform(new CLinux());
    Circle.drawShape();

    return 0;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>运行结果如下：</p>
<pre class="line-numbers language-c++"><code class="language-c++">Generating pixels on rectangle...Drawing pixels on windows...
Generating pixels on rectangle...Drawing pixels on linux...
Generating pixels on circle...Drawing pixels on windows...
Generating pixels on circle...Drawing pixels on linux...
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>优势很明显，只用m+n个类再加上两个基类，就可以完成在m个平台上绘制n个图元的工作。</p>
<p>这用的实际上就是桥接模式。</p>
<p>桥接模式：独立的变化因素应该封装到独立的类中。比如需要在不同的操作系统上绘制矩形、圆、三角形等图元。操作系统是一个独立的变化因素，应该将它单独封装到一个类中，提供在不同操作系统上画像素点的方法。图元是另一个独立的变化因素，也应该将它单独封装到一个类中，提供将不同图元转化为像素点的方法。</p>
</li>
<li><p>函数不应该超过50行，类不应该超过400行。</p>
</li>
<li>小结：<ul>
<li>开闭原则是面向对象设计的最基本原则</li>
<li>依赖倒置原则是实现开闭原则的主要手段，其实就是抽象、多态。</li>
<li>Liskov替换原则用来判断抽象是否正确，保证依赖倒置的正确性。</li>
<li>但完全通过集成来实现开闭原则，可能导致类爆炸，可以用合成复用原则来解决，它是实现开闭原则的另一种手段。</li>
</ul>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 设计模式 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 面向对象设计原则 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[老张培训笔记第一课码农]]></title>
      <url>/2017/07/10/%E8%80%81%E5%BC%A0%E5%9F%B9%E8%AE%AD%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%80%E8%AF%BE/</url>
      <content type="html"><![CDATA[<p>感谢老张！<br><a id="more"></a></p>
<hr>
<ol>
<li>用设计模式去解决一些实际问题。</li>
<li>团队交流的重要性不亚于个人的编码能力。</li>
<li><p>若有一个简单的函数要实现几十个int型数据的加法，最粗暴的写法如下：</p>
<pre class="line-numbers language-c++"><code class="language-c++">int Add(int n) {
 int sum = 0;
 for (int i = 0; i < n; i++) {
     sum += i;
 }
 return sum;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>但是如果需求变成几十个float型数据相加呢，是不是需要把上面函数中的int都换为float，如果还增加了double、char等等呢，需要重复写上诉代码？</p>
<p>很显然，这样做就真的是码农了，花大把时间做体力活。应该使用模板，如下：</p>
<pre class="line-numbers language-c++"><code class="language-c++">template <typename T>
T Add(T n) {
 T sum = 0;
 for (T i = 0; i < n; i++) {
     sum += i;
 }
 return sum;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这样就可以很方便的调用Add(100)，Add(100.0f)，Add(‘!’)等等了。值得注意的是，在模板函数中声明变量时必须同时赋值来初始化，如上面程序中的<code>T sum=0;</code></p>
</li>
<li>码农的定义：需求变化时，会有很多体力活要做。</li>
<li>对同一个功能，应该用更少的代码去实现。</li>
<li>多调试团队里其他人的代码，包括bug。</li>
<li>函数不能超过50行，这样函数的功能就会比较单一，方便给函数起名字，这样一来也能减少甚至达到不写注释。</li>
<li>在代码中应该尽量不要写注释，但注释不同于文档。注释是在说明变量代表什么，函数实现了什么功能，文档是在说明为什么这么设计，比如该函数为什么是私有的或者保护的。</li>
<li>在写代码中，不要ctrl+c、ctrl+v，也不要copy团队里其他人的代码，要使用别人的代码时，应该只需要调用别人预留的函数接口，而非具体的代码实现。</li>
<li>做起来像体力活的东西都需要改进。</li>
<li>用不同的设计模式来解决同一个问题。</li>
<li>问题示例：写日子文件。很多人的做法是仅仅实现了往文件里写东西的功能，但是没有考虑到效率问题，每收到一条log就打开文件、写文件、关闭文件。应该增加一个缓冲区，将日志信息先放到缓冲区中，每隔一段时间将缓冲区里的内容一起写入日志文件。</li>
<li>具体的实现细节应该隐藏在类内部，外部只需要知道类的功能是什么。</li>
<li><p>类的成员变量都应该尽量是私有的。甚至接口、虚基类里的成员变量也应该尽量私有（非保护）。为私有成员变量添加get、set函数，这样可以在get、set函数中对变量的读取、写入添加一些条件限制。</p>
<p>比如某个私有成员变量m_Money，只有当它的值大于1000时，才允许被读取到外界：</p>
<pre class="line-numbers language-c++"><code class="language-c++">int getMoney() {
if (m_Money > 1000)
    return m_Money;
else
    return -1;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果将m_Money直接写为公有的，那么外界就可以直接读取到该变量，但是如果增加了上面这个读取条件限制，那么就需要在每个读取该变量的地方，加上条件限制，很显然体力活又来了。这就是为何需要将成员变量写为私有的原因。</p>
</li>
<li><p>如下代码：</p>
<pre class="line-numbers language-c++"><code class="language-c++">vector<int> getMoney() {
vector<int> array;
for (int i = 0; i < 100; i++) {
    array.push_back(i);
}
return array;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这样的函数是不够好的，因为它向外界暴露了函数内部数据的存储方式为vector<int>，如果哪天把vector改为了List，那么外界所有调用该函数的地方可能都需要随之改变，把外界的vector改为List，体力活又来了。</int></p>
<p>如果想返回vector里的所有数据，通常get函数会接收一个输入输出参数，比如数组，来存储vector里的所有数据。当然，这样好的设计风格确实带来了数据复制时的性能开销。</p>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 设计模式 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 码农 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++浅层拷贝和深层拷贝]]></title>
      <url>/2017/05/31/C++%E6%B5%85%E5%B1%82%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E5%B1%82%E6%8B%B7%E8%B4%9D/</url>
      <content type="html"><![CDATA[<p><font size="5" color="orange">拷贝构造函数</font><br><a id="more"></a></p>
<hr>
<p><font size="4" color="red">什么是拷贝构造函数</font><br>拷贝构造函数是一种特殊的构造函数，其形参是本类对象的引用。它的作用是：在建立一个新对象时，使用一个已经存在的对象去初始化这个新对象。例如：</p>
<pre class="line-numbers language-c++"><code class="language-c++">Point p2(p1);
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>在建立新对象p2时，用已经存在的对象p1去初始化新对象p2，在这个过程中就要调用拷贝构造函数。</p>
<p><font size="4" color="red">拷贝构造函数的特点</font><br>拷贝构造函数具有以下特点：</p>
<ol>
<li>因为它也是一种构造函数，所以其函数名与类名相同，并且没有返回值类型。</li>
<li>只有一个参数，并且是同类对象的引用。</li>
<li>每个类都必须有一个拷贝构造函数。如果我们没有自定义某个类的拷贝构造函数，那么系统会自动生成一个默认的拷贝构造函数，用于复制出数据成员值完全相同的新对象。</li>
</ol>
<p><font size="4" color="red">拷贝构造函数的一般形式</font><br>自定义拷贝构造函数的一般形式如下：</p>
<pre class="line-numbers language-c++"><code class="language-c++">类名(const 类名& 对象名){
    ...
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>例如：</p>
<pre class="line-numbers language-c++"><code class="language-c++">class Point {
private:
    int x, y;
public:
    Point(int a, int b) {
        x = a;
        y = b;
    }
    Point(const Point& p) {
        x = 2 * p.x;
        y = 2 * p.y;
    }
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><font size="4" color="red">什么时候会调用拷贝构造函数</font><br>有3种情况下会调用拷贝构造函数：</p>
<ol>
<li>用一个对象去初始化另一个对象时。如下：<pre class="line-numbers language-c++"><code class="language-c++">Point p2(p1);
Point p3=p1;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li>类对象作为函数参数时。如下：<pre class="line-numbers language-c++"><code class="language-c++">void func(Point p){
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
调用函数func，实参传入形参时会调用拷贝构造函数来初始化形参p。</li>
<li><p>函数返回值是类对象时。如下：</p>
<pre class="line-numbers language-c++"><code class="language-c++">Point func(){
   Point p1(10,20);
   return p1;
}

int main(){
   Point p2;
   p2 = func();
   return 0;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>执行语句<code>return p1</code>时，将会调用拷贝构造函数将p1的值复制到一个临时对象中，这个临时对象是编译系统在主程序中临时创建的，函数运行结束时对象p1消失，但临时对象将会通过语句<code>p2=func()</code>将它的值赋给对象p2，执行完这个语句后，临时对象的使命也就完成了，该临时对象便自动消失了。</p>
</li>
</ol>
<p><font size="5" color="orange">浅层拷贝构造函数</font></p>
<hr>
<p>编译器会提供默认的拷贝构造函数，但它只是把传递进来的对象的每个成员复制到新对象的成员变量中去，两个对象的变量共享内存区域，我们把这种拷贝叫做浅层拷贝。</p>
<p>如果浅层拷贝的两个对象共享指针变量，那么当其中一个对象释放掉该存放指针变量的内存空间时，另一个对象的该指针变量就变成了野指针（迷途指针），会报错。如下所示：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>
using namespace std;

class Point {
private:
    int *x;
public:
    Point(int a) {
        x = new int();
        *x = a;
    }
    ~Point() {
        cout << "delete" << endl;
        delete x;
        x = NULL;
    }
    Point(const Point& p) {
        x = p.x;
    }
    int getX() {
        return *x;
    }
};


int main() {
    Point *p1 = new Point(14);
    Point p2 = *p1;
    delete p1;
    cout << p2.getX() << endl;
    return 0;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当删除p1之后，p1和p2共用的指针x就会通过析构函数被释放掉，在执行<code>cout &lt;&lt; p2.getX() &lt;&lt; endl;</code>将无法得到想要的值14（会得到一个随机内存的值，可能会很大），在main函数结束时，程序会调用p2的析构函数再次释放指针x，但是x在此之前已经被释放掉了，所以程序会报错。程序输出结果如下：</p>
<pre class="line-numbers language-c++"><code class="language-c++">delete
-572662307
delete
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>去掉上面程序中的拷贝构造函数也是一样的错误，因为程序默认的拷贝构造函数就是浅层拷贝，跟上面程序中的拷贝构造函数几乎是一样的。</p>
<p><font size="5" color="orange">深层拷贝构造函数</font></p>
<hr>
<p>为了解决浅层拷贝导致的野指针问题，必须创建自己的拷贝构造函数，并且在函数里为成员变量分配内存。这样两个对象的成员变量都各自拥有自己的内存区域。这就是深层拷贝，可以使拷贝结果与拷贝源不共用内存。如下所示：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>
using namespace std;

class Point {
private:
    int *x;
public:
    Point(int a) {
        x = new int();
        *x = a;
    }
    ~Point() {
        cout << "delete" << endl;
        delete x;
        x = NULL;
    }
    Point(const Point& p) {
        x = new int();
        *x = *(p.x);
    }
    int getX() {
        return *x;
    }
};


int main() {
    Point *p1 = new Point(14);
    Point p2 = *p1;
    delete p1;
    cout << p2.getX() << endl;
    return 0;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在拷贝构造函数<code>Point(const Point&amp; p)</code>中，对当前类对象的成员变量又重新分配了内存空间，并且完成了变量内容复制（注意不要写成x=p.x，否则指针相同导致对应的变量还是共用的一个地址），程序运行正常，输出结果如下：</p>
<pre class="line-numbers language-c++"><code class="language-c++">delete
14
delete
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>当释放p1调用析构函数时，释放的是p1的指针变量x，并不会影响到p2的指针变量x，因为深层拷贝下p1和p2的成员变量x不再共用内存。<br>&nbsp;</p>
<hr>
<p>参考文献：<a href="http://blog.csdn.net/cainv89/article/details/47285453" target="_blank" rel="external">《C++基础–浅层及深层拷贝构造函数》</a></p>
]]></content>
      
        <categories>
            
            <category> C++ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 拷贝构造函数 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++ const详解]]></title>
      <url>/2017/05/30/C++const%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>被const修饰的东西（包括变量、函数、返回值等等）都强制为只读的，可以防止外界意外地改动，可以提高程序的健壮性，所以我们可能经常看到一句话：“Use const whenever you need”。<br><a id="more"></a></p>
<p><font size="5" color="orange">用const修饰变量</font></p>
<hr>
<ul>
<li><p>对于<code>const int *m;</code>，const修饰的是整型变量<code>*m</code>，不是指针变量<code>m</code>，所以*m是不可变的，m是可变的，即：</p>
<pre class="line-numbers language-c++"><code class="language-c++">const int *m;
int *n;
m = n;      //合法，m所指向的对象是可变的
*m = 14;    //不合法，m指向的对象的内容是不可变的
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>const int *m</code>和<code>int const *m</code>是一样的。</p>
</li>
<li><p>对于<code>int * const m;</code>，const修饰的是指针变量m，所以m是不可变的，但*m是可变的，即：</p>
<pre class="line-numbers language-c++"><code class="language-c++">int p;
int * const m = &p;
int *n;
m = n;      //不合法，m所指向的对象是不可变的
*m = 14;    //合法，m指向的对象的内容是可变的
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>而且<code>int * const m</code>是必须在定义时赋初值的，否则m将指向随机的内存地址，这个内存地址是可能会变的，即m会变，则不符合const修饰的只读属性，所以必须在定义时为其指定一个确切的地址，而且一经赋值就不能再变了。</p>
</li>
<li>对于<code>const int m</code>，const修饰的是m，m的值是不可变的，如下：<pre class="line-numbers language-c++"><code class="language-c++">int n;
const int m = n;
int p = m;      //合法，因为p是m的复制，不共用地址，不是同一个变量，可以有不同的读写属性
int& q = m;     //不合法，因为p和m共用地址，是同一个变量，但p和m却具有不同的读写属性，不合语义
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
在定义m时也是需要赋初值的，因为m的值是一经确定不能再改变的，它需要从一开始就知道自己的值是多少，不能后续再通过赋值语句来确定自己的值，即<code>m = 14;</code>是非法的。<code>int&amp; q = m</code>不合法是因为m是只读的，q是可读可写的，但是m和q共用一个地址，实际上是同一个变量，但却有不同的读写属性，即可以通过改变q来改变m的值，这是不符合const语义的，所以它不合法。而<code>int p = m</code>合法是因为p是m的复制，和m不共用地址，不是同一个变量，可以拥有不同的读写属性，改变p并不会影响到m。</li>
</ul>
<p>【注】：</p>
<ul>
<li>上面的<code>const int *m</code>可以不用赋初值，是因为const虽然修饰的是<code>*m</code>，<code>*m</code>是不可以直接赋值改变的，但是指针m指向的内容（即<code>*m</code>）是可以通过改变m来间接改变的：<pre class="line-numbers language-c++"><code class="language-c++">const int *k;
int m = 10;
int n = 20;
k = &m;
cout << *k << endl;
k = &n;
cout << *k << endl;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
输出如下：<pre class="line-numbers language-c++"><code class="language-c++">10
20
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
</ul>
<p><font size="5" color="orange">用const修饰函数参数</font></p>
<hr>
<p>如果函数参数需要作输出参数用，那么该参数就不能用const修饰，因为一旦用const修饰，该参数就无法在函数内部做任何改变，输入的是什么值，输出的将还是同样的值，强制对该参数赋值会编译报错，无法达到向函数外输出有效数据的作用。但是如果函数参数只作输入参数用，使用const修饰可以保证函数内部不会意外改动该参数，尤其是当函数参数是地址、引用等地址类型时，使用const能够起到保护作用，使函数实参不会被改变。如下：</p>
<pre class="line-numbers language-c++"><code class="language-c++">void copyString(char* strDest, const char* strSrc);
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>strSrc是输入参数，在字符串复制时并不希望改变它，所以用const将它修饰为只读的，函数内部如果企图改变strSrc的内容，编译器将报错。strDest是输出参数，将复制过后的字符串传到函数外部的对应实参。</p>
<p>对于采用值传递的参数，由于函数会自动产生临时变量来复制实参，此时的函数参数（形参）和其实参具有不同的地址，即实参已经受到了保护，形参改变时并不会影响到其实参，所以无需加const修饰。例如：</p>
<pre class="line-numbers language-c++"><code class="language-c++">void func1(int x);
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>不需要用const来修饰采用值传递的形参x：</p>
<pre class="line-numbers language-c++"><code class="language-c++">void func(const int x);
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>同样地，无需将<code>void func(A a)</code>写为<code>void func(const A a)</code>，A为我们自定义的类、结构体等数据类型，非<a href="http://www.cnblogs.com/zrtqsk/p/4369864.html" target="_blank" rel="external">C++基本数据类型</a>。</p>
<p>对于非C++基本数据类型的参数而言，像<code>void func(A a)</code>这样直接传递对象效率会比较低，因为函数内部会再产生一个A类型的临时对象a来复制对应实参，而临时对象将会产生构造、复制、析构等时间内存开销。为了提高效率，可以将函数改为：</p>
<pre class="line-numbers language-c++"><code class="language-c++">void func(A& a);
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这样函数参数将采用址传递，形参只是实参的别名，共用同一个地址空间，不会产生临时对象。但是a可能只需要做输入参数用，并不希望函数内部改变参数a的内容，这时就可以将参数a用const来修饰为只读的：</p>
<pre class="line-numbers language-c++"><code class="language-c++">void func(const A& a);
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这样既达到了提高效率的目的，也保护了参数a对应的实参。那么为了提高效率是否应该将<code>void func(int x);</code>改为<code>void func(int&amp; x);</code>呢？不需要的，因为C++基本数据类型在赋值/复制时没有构造、析构的过程，复制也非常快，基本类型的值传递和引用传递效率几乎一致。注：这里x只作输入参数用，如果需要作输出参数，还是要采用址传递的。</p>
<p>综上：</p>
<ul>
<li>对于非基本数据类型的输入参数，应该将“值传递”的方式改为“const 引用传递”来提高效率。例如将<code>void func(A a);</code>改为<code>void func(const A&amp; a);</code>。</li>
<li>对于基本数据类型的输入参数，不需要做上述改变，否则既不能提高效率也降低了函数的可读性。例如不要将<code>void func(int x);</code>改为<code>void func(const int&amp; x);</code>。</li>
</ul>
<p><font size="5" color="orange">用const修饰函数返回值</font></p>
<hr>
<p>如果函数返回值采用值传递方式，用const修饰是没有价值的，因为函数会把返回值复制到外部的临时变量中，对函数内部的返回变量已经起到了保护作用。如果函数返回值采用址传递方式，比如指针，用const修饰返回值，能够保证函数返回值（即指针）的内容不能被修改，<strong>该返回值只能赋给const修饰的同类型指针</strong>。</p>
<p>若返回值是非基本数据类型，将<code>A get();</code>改为<code>const A&amp; get()</code>确实可以提高效率，但是要注意函数到底是想返回一个对象的拷贝还是对象的别名，不然程序容易出错。比如外界想对get函数返回的对象值作进一步处理，但是又不想影响到A对象中的成员，那么无论使用<code>A&amp; get()</code>还是<code>const A&amp; get()</code>都达不到效果，还是得使用<code>A get()</code>。其实函数返回值采用引用传递的场合并不多，一般出现在类的赋值函数中，目的是为了实现链式表达式。如下：</p>
<pre class="line-numbers language-c++"><code class="language-c++">class A {
    const A& operator= (const A& other);
};

int main(){
    A a, b, c;
    a = b = c;     //合法
    (a = b) = c;   //不合法
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在a=b=c时，先执行b=c，返回值是const A类型，再将它作为参数传给other，最后赋值给A类型的a；但是在(a=b)=c时，先执行a=b，返回值是const A类型，接下来会将c作为参数传给other，最后赋值给const A类型，这与const变量只读冲突，所以是不合法的。</p>
<p><font size="5" color="orange">用const修饰成员函数</font></p>
<hr>
<p>用const修饰成员函数用于保证函数内部不会修改数据成员，且不能调用其他非const成员函数（因为其他非const成员函数可能会修改数据成员）。如下：</p>
<pre class="line-numbers language-c++"><code class="language-c++">class Test
{
private:
    int value;
public:
    Test() {
        value = 100;
    }
    int& GetValue() const;

};
int& Test::GetValue() const
{
    return value;   //value此时具有const属性，不合法
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>由于每个非static非const的成员函数都有一个隐含的this，所以用const修饰函数相当于是在修饰this，由于函数的作用域只在函数内部，所以只在函数内部时this指针是const类型的，是只读的，也就是说在const修饰的函数内部，this的任何成员变量和成员函数都是只读的。所以上面<code>GetValue</code>函数里，value（即this.value）也是const类型的，返回的是const int类型，但函数指定的返回值却是int&amp;，这与前面讲的<code>int&amp; q = m</code>是一样的道理，不合法。</p>
<p>可以这样改：</p>
<ol>
<li>把变量声明<code>int value</code>改为<code>mutable int value</code>，因为mutable修饰的变量是易变的，是const的反义词，可以在const函数中被修改。</li>
</ol>
<ul>
<li>将<code>return value</code>改为<code>return const_cast&lt;int&amp;&gt;(value)</code>，因为const_value去掉了const性质（其实是去掉了指向value指针的const性质，可以间通过前文说的间接方式来改变value的值，value自身的const属性是去不掉的）。</li>
<li>将函数改为<code>const int&amp; Test::GetValue() const</code>。</li>
<li>将函数改为<code>int Test::GetValue() const</code>。</li>
<li>将函数后面的const去掉。</li>
<li>return的不是成员变量，即如下：<pre class="line-numbers language-c++"><code class="language-c++">int& Test::GetValue() const
{
  int tempValue = value;
  return tempValue;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<p>对于第4种将&amp;去掉，其原理与上面讲的<code>int p = m</code>是一致的，非地址类型是直接复制的，前后不是同一个变量，可以有不同的读写属性。</p>
<p>如果将value改为指针类型，如下程序：</p>
<pre class="line-numbers language-c++"><code class="language-c++">class Test
{
private:
    int *value;
public:
    Test() {
        value = new int();
        *value = 100;
    }
    int* GetValue() const;

};
int* Test::GetValue() const
{
    return value; //value此时具有const属性
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面程序是不会报错的，但是函数返回的是指针，与上文返回引用有什么不同吗？上文返回引用是报错的。这是因为这里返回的指针，而函数返回类型也是指针类型的，指针本身就相当于一个4字节的整型变量，存储着其他变量的地址，所以这里还是相当于上面第4种修改方式，是两个int型变量之间的复制。<br>如果把程序改成下面这样是会出错的：</p>
<pre class="line-numbers language-c++"><code class="language-c++">class Test
{
private:
    int value;
public:
    Test() {
        value = 100;
    }
    int* GetValue() const;

};
int* Test::GetValue() const
{
    return &value;   //value此时具有const属性，不合法
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>原理还是一样的，const int类型的返回值value和函数返回的int*类型的临时变量具有相同的地址，实际上是同一个变量，但却具有不同的读写属性，返回的临时变量是可写的，但value只读，所以是不合法的。<br>&nbsp;</p>
<hr>
<p>参考文献：<a href="http://blog.csdn.net/zheng19880607/article/details/23883437" target="_blank" rel="external">C++ const修饰成员函数</a></p>
]]></content>
      
        <categories>
            
            <category> C++ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> const </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[《GPP》第一章 架构、性能和游戏]]></title>
      <url>/2017/05/25/GPP%E7%AC%AC%E4%B8%80%E7%AB%A0%E6%9E%B6%E6%9E%84%E6%80%A7%E8%83%BD%E5%92%8C%E6%B8%B8%E6%88%8F/</url>
      <content type="html"><![CDATA[<p><font size="5" color="orange">软件架构</font><br><a id="more"></a></p>
<hr>
<ul>
<li>衡量一个设计好坏的方法就是看它应对变化的灵活性。</li>
<li>如果两块代码耦合，意味着我们必须同时了解这两块代码，如果让它们解耦，那么只需了解其一。耦合得越低，更改所波及的范围就会越小。</li>
</ul>
<p><font size="5" color="orange">好架构的代价</font></p>
<hr>
<ul>
<li>解耦意味着我们在进行扩展时仅需理解少量代码，但同时抽象却也增加了理解代码的难度。</li>
<li>如果过度关注代码的设计架构，便会得到一个架构已经失控的代码库。我们会看到接口和抽象无处不在。插件系统、抽象基类、虚方法众多，还有各种的扩展点。我们将花费大量时间去找到有实际功能的代码。要避免过度设计。</li>
</ul>
<p><font size="5" color="orange">性能和速度</font></p>
<hr>
<ul>
<li>使用接口，能够让代码可以与任何实现这些接口的类进行工作，而不是使用具体类。</li>
<li>模板元编程可以让我们获得抽象接口而没有任何运行时开销，在编译期间就能决定在模板实例化时调用哪个类。</li>
<li>性能优化总是在某些假设下进行的。</li>
<li>软件架构好，灵活性高，但是会降低游戏性能，一种折中的办法是保持代码的灵活性，直到设计稳定下来，然后去除一些抽象，以提高游戏性能。</li>
</ul>
<p><font size="5" color="orange">坏代码中的好代码</font></p>
<hr>
<ul>
<li>只是为了验证游戏想法、迟早会扔掉的一些代码，在编写时不必在意设计架构。</li>
<li>我们需要确保那些使用一次性代码的人明白这种一次性代码看起来能够运行，但是它却不可维护，必须被重写。让boss明白原型代码只能用1次，以后要接着用就不要要求快速原型。</li>
<li>有一个小技巧确保我们的原型代码不会变成真正的代码，就是使用不同于我们游戏使用的语言来编写。这样的话，我们就必须用游戏使用的语言重写一遍了。</li>
</ul>
<p><font size="5" color="orange">简单性</font></p>
<hr>
<ul>
<li>保持简单性，代码量就会变少。这意味着更改代码时，我们的脑袋里只需装载更少的代码。</li>
<li>但是一个好的解决方案并不是更少的实际代码量，而是对代码的升华。</li>
<li>Blaise Pascal曾说：“我会写一封更简短的信，但我没有足够的时间。”</li>
<li>Antoine de Saint-Exupery（书，小王子）：“极臻完美，并非无以复加，而是简无可减。”</li>
</ul>
<p><font size="5" color="orange">More..</font></p>
<hr>
<ul>
<li>抽象和解耦能够使我们的程序开发变得更快和更简单。但不要浪费时间来做这件事，除非我们确信存在问题的代码需要这种灵活性。</li>
<li>在我们的开发周期中要对性能进行思考和设计，但是要推迟那些降低灵活性的、底层的、详尽的优化，能晚则晚。</li>
<li>如果我们将要删除代码，那么不要浪费时间将它整理得很整洁。摇滚明星把酒店弄得很乱是因为他们知道第二天就要结账走人。</li>
<li>在游戏发布前的两个月并不是我们开始担心“游戏的FPS只有1帧”问题的时候。<br>&nbsp;</li>
</ul>
<hr>
<p>参考文献：Nystrom R. Game Programming Patterns[M]. ?:Genever Benning, 2014.11.</p>
]]></content>
      
        <categories>
            
            <category> 游戏设计模式 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[OpenGL27：Gamma校正]]></title>
      <url>/2017/05/24/OpenGL27Gamma%E6%A0%A1%E6%AD%A3/</url>
      <content type="html"><![CDATA[<p>现在的很多监视器都是<a href="http://popperelay.com/2016/10/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E6%98%BE%E7%A4%BA%E7%B3%BB%E7%BB%9F/" target="_blank" rel="external">阴极射线管显示器（CRT）或者LED显示器</a>，它们在显示颜色时并非按照线性方式工作，我们在程序中输出的颜色，最终显示到屏幕上亮度会减弱，这对于计算光照和实时渲染的图形质量有一定影响，需要我们进行Gamma校正。<br><a id="more"></a></p>
<p><font size="5" color="orange">Gamma校正的概念及意义</font></p>
<hr>
<p>我们在自己的图形程序中认为颜色(1.0,0.0,0.0)的红色强度应该是颜色(0.5,0.0,0.0)的两倍，但是实际上显示设备对于输入的原始值，是按照2.2次幂的的指数形式（简称Gamma指数变换）进行处理的，即$C_{out}=C_{in}^{2.2}$，其中2.2是Gamma系数，不同显示器的Gamma系数值会略有不同，通常在2.0到2.4之间。所以程序中红色分量增大到了2倍，但是显示器显示出来的红色亮度并不是2倍，而是暗一些，比2倍低（因为原始颜色值都是在0到1之间的小数）。显示器所做的这种Gamma指数变换如下图所示：</p>
<p><div align="center"><br><img src="http://oqcvzqam1.bkt.clouddn.com/Gamma%E6%A0%A1%E6%AD%A31.png" alt=""><br>图1<br></div><br>图中间的点线是我们在图形程序中通常认定的线性颜色，即我们希望在程序中颜色分量（横轴）增加的同时显示器显示出来的亮度也会同比例增加。当显示器接收了来自程序的线性原始值后，会进行上诉的指数运算，完成Gamma变换，然后输出图中下方实线所示的非线性颜色，除了0和1这两个端点以外，其他颜色分量的亮度都会降低。</p>
<ul>
<li>【注】：<br>线性颜色可以通俗地理解为我们最终想要的颜色。</li>
</ul>
<p>所以，要想最终显示器按照我们在程序中预期的中间线性颜色来输出，我们需要在显示器执行Gamma指数变换之前，先做一个Gamma指数变换的逆变换：$C_{corrected}=C_{in}^{1.0/2.2}$，这样最终输出的颜色才会是我们在程序中指定的颜色，这个逆变换称为Gamma校正（Gamma Correction），对应图1中最上面的短划线。Gamma系数取2.2进行校正在大多数显示器上效果都比较理想。例如颜色(0.5，0.0，0.0)进行Gamma校正后会变为：$(0.5,0.0,0.0)^{1/2.2}=(0.73,0.0,0.0)$，校正后的颜色接下来会被发送给显示器，由于现实器会对输入的颜色做Gamma指数变换，所以最显示出来的颜色是：$(0.73,0.0,0.0)^{2.2}={0.5,0.0,0.0}$，与我们在程序中最初想要输出的颜色一致。</p>
<p>下图是Gamma变换前后的效果图，可以看到Gamma变换后的亮度增大了，恢复为程序想要的正常颜色。</p>
<p><div align="center"><br><img src="http://oqcvzqam1.bkt.clouddn.com/Gamma%E6%A0%A1%E6%AD%A32.png" alt=""><br>图2<br></div></p>
<p><font size="5" color="orange">在程序中使用Gamma校正</font></p>
<hr>
<p>有两种在场景中应用Gamma校正的方式：</p>
<ol>
<li><p>使用OpenGL内置的sRGB帧缓冲。使用<code>glEnable(GL_FRAMEBUFFER_SRGB)</code>开启sRGB帧缓冲，告诉OpenGL每个后续的绘制命令里，在颜色存储到颜色缓冲之前都先校正sRGB颜色，即OpenGL会自动使用硬件为自定义帧缓冲和默认帧缓冲执行Gamma校正。sRGB这个颜色空间大致对应于Gamma2.2。</p>
<p>值得注意的是，Gamma校正应该放在最后一步，即把颜色输出给默认帧缓冲的前一步。如果在最后输出给屏幕之前就进行Gamma校正，那么后续操作都将是在操作不正确的颜色值（非线性的颜色值）。例如，如果使用多个帧缓冲，同时想要在两个帧缓冲之间传递的中间结果依然是线性颜色，那么只应该给最后的那个帧缓冲应用Gamma校正。</p>
</li>
<li>自己在像素着色器的最后使用程序进行Gamma校正。如下代码所示：<pre class="line-numbers language-c++"><code class="language-c++">void main(){
 ...
 float gamma=2.2;
 color = vec4(pow(resultColor.rgb, vec3(1.0/gamma)), 1.0f);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
该方法有个问题就是为了保持场景中所有物体都应用了Gamma校正，必须在每个像素着色器里加上该Gamma校正。解决方案是使用后处理，在后处理窗口四边形上应用Gamma校正，这样就只用做一次Gamma校正就好了。</li>
</ol>
<p><font size="5" color="orange">并非任何时候都要进行Gamma校正</font></p>
<hr>
<p>我们在本地资源管理器中通过看图软件打开一张图片，想要通过图形程序显示和这张图片一模一样的效果，即看图软件中图片的颜色是我们想要的最终颜色，是线性颜色。由于图片显示到屏幕上会经过Gamma指数变换，所以内存中实际存储的图片颜色数据是经过Gamma校正以后的，因为这样才能在显示器上显示我们想要的线性颜色。换句话说，绘图或者编辑图片的过程就是对内存中颜色数据进行人为的Gamma校正。 </p>
<p>如果我们在图形程序中做了Gamma校正，那么最终图形程序在显示器上显示的就是经过两次Gamma校正和一次Gamma指数变换后的非线性颜色（对应图1中最上面的短划线），但是本地看图软件打开的图片是线性颜色，这就会造成图形程序最终显示的图片比看本地看图软件打开的图片更亮，不是我们想要的一模一样的效果，如下图所示：</p>
<p><div align="center"><br><img src="http://oqcvzqam1.bkt.clouddn.com/Gamma%E6%A0%A1%E6%AD%A33.png" alt=""><br>图3<br></div><br>为了解决这个问题，我们可以首先使用Gamma指数变换把sRGB纹理的纹素值变回线性空间，再继续其他光照计算等等，最后再做一次Gamma校正，然后输出给帧缓冲：</p>
<pre class="line-numbers language-c++"><code class="language-c++">float gamma=2.2;
vec3 diffuseColor = pow(texture(diffuse, texCoords).rgb, vec3(gamma));
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>为每个sRGB空间的纹理做这件事很麻烦，幸运的是，OpenGL为我们提供了GL_SRGB和GL_SRGB_ALPHA内部纹理格式，使用这两种内部纹理格式，OpenGL会自动将颜色校正到线性空间中。可以这样定义一个sRGB纹理：</p>
<pre class="line-numbers language-c++"><code class="language-c++">glTexImage2D(GL_TEXTURE_2D, 0, GL_SRGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, image);
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>值得注意的是，不是所有纹理都在sRGB空间中，比如diffuse漫反射纹理几乎都是在sRGB空间，但是specular镜面贴图和法线贴图几乎都在线性空间中，因为这样比较容易获取光照参数，如果把镜面贴图和法线贴图都存储为sRGB纹理的话，光照就废了。</p>
<p><font size="5" color="orange">Gamma校正对光照衰减的影响</font></p>
<hr>
<p>光照衰减的物理公式应该是二次的，比如之前文章里介绍的二次衰减方程，简化版如下：</p>
<pre class="line-numbers language-c++"><code class="language-c++">float attenuation = 1.0 / (distance * distance);
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>还可以用不太标准的双曲线函数来实现光源衰减：</p>
<pre class="line-numbers language-c++"><code class="language-c++">float attenuation = 1.0 / distance;
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>但是有趣的是，在不使用Gamma校正时，双曲线函数比二次函数有更好的衰减效果；使用Gamma校正时，二次函数比双曲线函数有更好的衰减效果。如下图所示：</p>
<p><div align="center"><br><img src="http://oqcvzqam1.bkt.clouddn.com/Gamma%E6%A0%A1%E6%AD%A34.png" alt=""><br>图4<br></div><br>这是因为不应用Gamma校正时，经过显示器Gamma指数变换后二次函数衰减方程变为$(1.0/distance^2)^{2.2}$，双曲线函数变为$(1.0/distance)^{2.2}=1.0/distance^{2.2}$，这和物体公式很接近，所以不应用Gamma校正时，二次衰减方程衰减得会非常快，而双曲线函数的衰减效果比较好。</p>
<p>总之，Gamma校正使我们可以在线性颜色空间中进行操作，因为线性空间更符合物理世界，使大多数物理公式都可以获得较好的效果，比如真实的二次光照衰减方程。<br>&nbsp; </p>
<hr>
<p>参考文献：<a href="https://learnopengl.com/" target="_blank" rel="external">LearnOpenGL</a></p>
]]></content>
      
        <categories>
            
            <category> OpenGL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Gamma校正 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OpenGL26：Blinn-Phong模型]]></title>
      <url>/2017/05/24/OpenGL26Blinn-Phong%E6%A8%A1%E5%9E%8B/</url>
      <content type="html"><![CDATA[<p><font size="5" color="orange">Phong模型的缺陷</font><br><a id="more"></a></p>
<hr>
<p>在<a href="http://popperelay.com/2016/12/12/OpenGL10%E5%85%89%E7%85%A7%E5%9F%BA%E7%A1%80/" target="_blank" rel="external">《OpenGL10：光照基础Phong模型》</a>中，我们使用了Phong模型来模拟光照效果，但是在镜面高光系数很低（比如0.5），即镜面光半径很大的时候，它的镜面反射会失效，如下图所示：<br><img src="http://oqcvzqam1.bkt.clouddn.com/Blinn-Phong1.png" alt=""><br>可以看到，镜面区域边缘迅速减弱并截止，出现这个问题的原因是视线向量和反射光向量之间的夹角大于90度了，根据Phong模型中<code>max(dot(reflectDir, viewDir), 0);</code>，夹角大于90度时，镜面反射系数会被设置为0，所以一旦视线方向和反射光之间夹角大于90度，镜面光就会突然消失，变为0，产生镜面光硬边缘。但是<strong>大于90度变为0</strong>这只适用于漫反射光，而不适用于镜面光。计算漫反射光需要的夹角是入射方向和法线之间的夹角，大于90度时，入射光转到了物体背面，变为0；但是计算镜面反射光需要的夹角是视线方向和反射光方向之间的夹角，大于90度时，光线不一定转到了物体背面，如下图：<br><img src="http://oqcvzqam1.bkt.clouddn.com/Blinn-Phong2.png" alt=""><br>所以对于镜面光，不能在夹角大于90度时令镜面光反射系数变为0。</p>
<p>当镜面高光系数较大时，高光比较集中，当高光突变为0时还有很强的漫反射光存在，所以人眼观察到的镜面光硬边缘不明显；但是当镜面高光系数较小时，高光半径会很大，高光在边缘处突变为0时漫反射强度很弱，镜面光成分较高，此时的镜面光硬边缘就会很明显。</p>
<p><font size="5" color="orange">Blinn-Phong模型</font></p>
<hr>
<p>1977年James F. Blinn提出了Blinn-Phong模型，它是对Phong模型的改进：放弃反射光向量，改用半程向量，半程向量是入射光线向量与视线向量的和向量，再归一化之后的单位向量。如下图中的向量H：<br><img src="http://oqcvzqam1.bkt.clouddn.com/Blinn-Phong3.png" alt=""><br>Blinn-Phong模型不再使用法线与反射向量的夹角来计算镜面光，而是使用半程向量和法线向量之间的夹角。半程向量越靠近法线向量，人眼观察到的镜面光强度越大。只要不从物体背面去看，半程向量和法线向量之间的夹角永远都小于等于90度。</p>
<p><font size="5" color="orange">Blinn-Phong模型的代码实现</font></p>
<hr>
<p>Phong模型计算镜面光的代码如下：</p>
<pre class="line-numbers language-c++"><code class="language-c++">vec3 reflectDir = normalize(reflect(-lightDir, normal));
vec3 viewDir = normalize(viewPos - positionInWorld); 
float specularFactor = pow(max(dot(reflectDir, viewDir), 0.0), 1); 
vec3 specularColor =  specularFactor * lightColor;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>Blinn-Phong模型舍弃反射光向量，使用半程向量，代码如下：</p>
<pre class="line-numbers language-c++"><code class="language-c++">vec3 viewDir = normalize(viewPos - positionInWorld);
vec3 halfDir = normalize(lightDir + viewDir);
float specularFactor = pow(max(dot(halfDir, normal), 0.0f), 1);
vec3 specularColor =  specularFactor * lightColor;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以发现Blinn-Phong模型除了表现效果更真实以外，还有个很大的优势：不用去计算复杂的反射光向量，降低了计算量，相比Phong模型性能更高。</p>
<p>当镜面高光系数为0.5时，Phong模型表现效果如第一幅图。Blinn-Phong模型表现效果如下图：<br><img src="http://oqcvzqam1.bkt.clouddn.com/Blinn-Phong4.png" alt=""><br>由于半程向量和法线向量之间的夹角通常会比视线向量和反射向量之间的夹角更小，即余弦值更大，所以相同镜面高光系数下，Blinn-Phong模型的镜面光会比Phong模型更亮，Blinn-Phong模型要达到和Phong模型一样的效果，需要增大镜面高光系数，通常是Phong模型中的镜面高光系数的2到4倍。</p>
<p>所有源码请看<a href="https://github.com/Popperelay/BlogCode/tree/master/LearnOpenGL26_BlinnPhong" target="_blank" rel="external">这里</a>。</p>
<p>&nbsp;</p>
<hr>
<p>参考文献：<a href="https://learnopengl.com/" target="_blank" rel="external">LearnOpenGL</a></p>
]]></content>
      
        <categories>
            
            <category> OpenGL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Blinn-Phong </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[交流中的启迪]]></title>
      <url>/2017/05/23/%E4%BA%A4%E6%B5%81%E4%B8%AD%E7%9A%84%E5%90%AF%E8%BF%AA/</url>
      <content type="html"><![CDATA[<p><font size="5" color="orange"> 求取一个物体从某点看过去的轮廓（边缘检测）</font><br><a id="more"></a><br>物体的边缘是由很多三角面片的边组成的，某条边是不是位于轮廓上，可以通过其三角形法线与视线方向向量的点乘来计算。如下图所示：<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E4%BA%A4%E6%B5%81%E4%B8%AD%E7%9A%84%E5%A5%BD%E6%96%B9%E6%B3%951.png" alt=""><br>每条边会被两个三角形共享，如果视线方向与其中一个三角形的点乘是正数，与另一个三角形的点乘是负数，则共享该边的两个三角形一个能被看见一个被挡住了，说明该边就是位于轮廓上。</p>
<p>此方法其实和冯氏漫反射光照很像。可以在几何着色器里实现，几何着色器可以接收类型为<code>triangles_adjacency</code>的图元，即接收一个三角面片的三个顶点和该三角面片的三个邻接顶点，如下图所示：<br><img src="http://oqcvzqam1.bkt.clouddn.com/%E4%BA%A4%E6%B5%81%E4%B8%AD%E7%9A%84%E5%A5%BD%E6%96%B9%E6%B3%952.png" alt=""><br>根据这六个点计算出三角面片和其邻接面片的法线，用上述方法即可判断该三角面片的三条边是否有位于轮廓上。<br>邻接顶点需要在CPU上事先算好（可以先存储由边构成的三角形，再判断当前边属于哪些三角形，再取出所属的邻接三角形的邻接顶点），存入顶点数据中传给顶点着色器。<br>交流来源：师兄王振<br>参考文献：<a href="http://wiki.jikexueyuan.com/project/modern-opengl-tutorial/tutorial39.html" target="_blank" rel="external">《边缘检测》</a></p>
]]></content>
      
        
        <tags>
            
            <tag> 交流 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[毕设笔记]]></title>
      <url>/2017/05/22/%E6%AF%95%E8%AE%BE%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<ol>
<li>在投影变换的过程中，就会剔除掉所有在视见体之外的片段，它们是不会从顶点着色器进入片元着色器的。也就是说那些在视见体之外的片段不会执行片元着色器。<a id="more"></a></li>
<li>深度测试是在片元着色器的过程中的，即使是那些被挡住的片段也是会执行片元着色器里的内容（比如片元着色器里的所有光照计算），很明显的证明例子就是延迟着色，延迟着色的优点就是剔除掉了对那些被遮挡的片段的光照计算。虽然被遮挡的和没被遮挡的片段都会执行光照计算，但是最后留在帧缓冲里的都是没被遮挡的片段，因为开启了深度测试。</li>
<li>透视除法也是在片元着色器之前的。当我们在顶点着色器输出一个裁剪空间顶点位置到<code>gl_Position</code>时，OpenGL会自动进行一个透视除法，将裁剪空间坐标范围的-w到w转换为-1到1。这要通过将x、y、z元素除以w元素来实现。</li>
<li>纹理采样时，纹理坐标是在每一个纹素的中心位置采样的。比如一张1024 * 768的纹理，如果传入的纹理坐标范围是0~1，那么采样最左下角的纹理坐标应该是（1/1024*0.5，1/768*0.5），它的右边的纹理坐标应该是（1/1024*1.5，1/768*1.5）。 片段坐标gl_FragCoord也是这样。</li>
<li>memset函数不能对数组置0和-1以外的值。</li>
<li>CPU上的结构体可以有构造函数，但是GPU上着色器里的结构体内不能有任何函数。想要对着色器里的结构体初始化，只能到CPU上进行。</li>
<li>如果前面有用过glActiveTexture()，那么后面绑定纹理时，也必须得用该函数激活对应的纹理单元，即使这时只有一个纹理要绑定（或者说要去采样）。如果前面激活了GL_TEXTURE0，且用完纹理后解绑了，那么后面绑定时可以再激活绑定到GL_TEXTURE0上；如果没有解绑，就得绑定到其他没用过的纹理单元上。</li>
<li>使用完纹理后，一定要记得立即解绑，否则可能出现很诡异的结果。</li>
<li><p>shader里的着色器缓冲对象SSBO和uniform缓冲对象UBO等等，有std140或者std430的修饰时，一定要注意字节对齐。</p>
<p>比如下面这个着色器里的缓冲对象SSBO：</p>
<pre class="line-numbers language-c++"><code class="language-c++">struct Light{
 vec3 Position;    //世界坐标
 vec3 Color;
 float radius;     //光体积半径
};
layout (std430, binding = 3) buffer LightsData{
 Light lights[];
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>因为buffer里的成员是结构体，而根据std140和std430的对齐规则，结构体对齐值应该是结构体内最大成员的对齐值，所有上面结构体Light的对齐值就应该是vec4，即16字节对齐（vec3需要按vec4算）。也就是说GPU每次是按16字节一起读的，所以为了值正确，我们需要把上述结构体改为：</p>
<pre class="line-numbers language-c++"><code class="language-c++">struct Light{
 vec3 Position;    //世界坐标
 float none;       //用作16字节对齐
 vec3 Color;
 float radius;     //光体积半径
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>或者：</p>
<pre class="line-numbers language-c++"><code class="language-c++">struct Light{
 vec4 Position;    //世界坐标
 vec3 Color;
 float radius;     //光体积半径
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果还是原来的Light结构体的话，读vec3类型的Position时，会一次直接读走32个字节（vec4），这样就把Position后面的Color的前4个字节读走了，导致Position和Color的值都不正确。所以我们可以把Position改成vec4，或者在它后面添加一个float，来补足16字节。后面vec3类型的Color和float类型的radius正好组成16字节，可以一次读走，每个成员数据在读的时候没有被中断而分成两半，所以这样读出来的值才是正确的。</p>
</li>
<li>使用<code>glTexImage2D</code>函数生成图片后一定要设置图片的过滤方式，否则图片不会显示。</li>
<li>实验证明，如果不使用<code>glClear</code>清除深度缓冲，OpenGL默认深度值是0.0。使用该函数清除了深度缓冲之后，才会将深度值设为1.0。所以如果一直不使用<code>glClear(GL_DEPTH_BUFFER_BIT)</code>，而且开启了深度测试，将会黑屏，画不出来任何东西，因为深度值是0.0，每个片段都无法通过深度测试。</li>
<li>如果在自定义的帧缓冲里有深度测试，一定要给自定义的帧缓冲绑定深度附件（渲染缓冲或者纹理附件都可以），否则深度测试无效。傻B又惨痛的教训~~</li>
<li><p>某个变量在shader里没有被赋值给别的变量，那么它就不会被NSight显示出正确的值。想要看出它的正确值，只有把它再赋值给另一个变量了，观察另一个变量的值是多少。如下面的程序：</p>
<pre class="line-numbers language-c++"><code class="language-c++">for(int i = 0; i < 5; i++){
    ...
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>在循环过程中，由于i没有被赋值给别的变量，所以NSight所显示出来的i值就一直是0，如果想看到i的值，可以加一行代码，如下：</p>
<pre class="line-numbers language-c++"><code class="language-c++">for(int i = 0; i < 5; i++){
    int j = i;
    ...
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>用NSight调试可以看到，i的值虽然一直都是0，但是j的值却会从0变到4。</p>
<p>这个结论不一定正确，只是经验之谈。不过却提供了一种调试的方法，当发现NSight给出的值明显不正确时（它可能给出的是0或者？？？等等），可以把它赋给另一个变量，就可以看到正确的值了。</p>
</li>
<li><p>GPU对于if-else的处理，并不像LearnOpenGL中（Deferred Shading那一节）讲得那样：为了GPU高度并行if分支和else分支都会被执行，执行完之后再回滚。做实验如下：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#version 430 core

out vec4 color;

void main(){
    if(true){
      color=vec4(1,0,0,1);
    }
    else{
      while(true){}        
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果if和else分支都执行，那么程序将陷入死循环，但是实际运行结果是屏幕上会出现红色矩形（该着色器用于绘制一个矩形），说明else分支没有被执行。如果把程序改成如下，将会陷入死循环（实验的结果就是重启电脑吧！卡住了！）：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#version 430 core

out vec4 color;

void main(){
    if(true){
      while(true){}  
      color=vec4(1,0,0,1);
    }
    else{
      while(true){}        
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>自定义程序实现的前置深度测试：比如我们需要对一个模型进行很多很复杂的光照计算，为了不让被遮挡住的片元也去进行光照计算（因为被遮挡的片元颜色是不会显示出来的，它所进行的关照计算对最后的显示结果是多余的），我们可以采用延迟着色（Deferred Shading）或前向着色（forward shading）。延迟着色很好理解，而对于前向着色，为了不让被遮挡的片元也进行光照计算，我们也可以向延迟着色一样，把光照阶段剥离出来：先开启深度测试把模型绘制一遍，把深度值保存到深度纹理中，这样在深度纹理中的深度值就是模型最靠近摄像机的片元的深度值了（这是第一个pass）；接着我们再把模型绘制一遍，在这次绘制中，我们先在片元着色器里，判断当前片元的深度值是否大于深度纹理中对应位置的深度值，如果是则直接返回，不用再进行接下来的光照计算，否则照常进行光照计算，赋予片元光照下的颜色值：</p>
<pre class="line-numbers language-c++"><code class="language-c++">void main(){
    if(gl_FragCoord.z > texture(TexForDepth, vec2(gl_FragCoord.x/1024.0f, gl_FragCoord.y/768.0f)).r ){
        return;
    }
    //执行光照计算
    ...
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这样一来，就只有最后会被显示到窗口上的片元才会去执行光照计算，大大减少了光照计算的次数。</p>
<p>但是在实际运用中，按照上诉代码来实现前置深度测试，会出现如下图所示的抖动现象：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/149225097087.png" alt=""><br>这通常是由于计算机对浮点数精度表示的不准确而造成的，我们在条件判断的时候加上一个很小的误差就能解决这个问题了：</p>
<pre class="line-numbers language-c++"><code class="language-c++">void main(){
    if(gl_FragCoord.z > texture(TexForDepth, vec2(gl_FragCoord.x/1024.0f, gl_FragCoord.y/768.0f)).r  + 0.00001){
        return;
    }
    //执行光照计算
    ...
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>结果如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/149225097469.png" alt=""></p>
</li>
<li>GLFW的回调函数：按键回调函数、鼠标位置回调函数、鼠标滚轮回调函数等等，都是在事件触发之后才会执行的。也就是说鼠标放在窗口里不动，是不会调用鼠标位置回调函数的。</li>
<li>类的私有构造函数是不会被执行的。比如单例模式中的私有构造函数。</li>
<li>在单例模式中，返回的实例对象最好是指针类型的，如果是直接返回静态的实例对象，那么在其他地方对返回的这个实例对象的修改是不会影响到原单例类的实例对象的：<pre class="line-numbers language-c++"><code class="language-c++">单例类A：
static A getInstance(){
    return m_Instance;
}
void init(){
    m_Count = 10;
}
其他类B：
A::getInstance().init();
另一个类C：
cout<<A::getInstance().m_Count<<endl;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
A只是返回了实例对象，而不是对象指针，也就是说B类中通过<code>getInstance</code>得到的对象和A类中的<code>m_Instance</code>不是同一个对象，所以即使在B类中对成员变量<code>m_Count</code>做了初始化，但是<code>m_Instance</code>是没有任何变化的，所以在C类里再去得到<code>m_Instance</code>实例对象的<code>m_Count</code>属性，输出将会是0。<br>应该改为：<pre class="line-numbers language-c++"><code class="language-c++">static A* getInstance(){
    return &m_Instance;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>可能出现黑屏的原因：</p>
<ul>
<li>没有清空颜色缓冲，即没有使用glClearColor和glClear函数。</li>
<li>绘制时不在默认帧缓冲上。</li>
<li>用到了但是没有给着色器传入模型矩阵、观察矩阵和投影矩阵。</li>
<li>没有激活着色器程序</li>
</ul>
</li>
<li><p>OpenGL默认使用<code>glEnable(GL_MULTISAMPLE)</code>开启多重采样，想要关闭多重采样，需要注释掉<code>glfwWindowHint(windon, 4);</code>，只使用<code>glDisable(GL_MULTISAMPLE)</code>是不够的。</p>
</li>
<li><p>复制帧缓冲时，如果帧缓冲上有多个纹理附件，需要使用<code>glReadBuffer</code>和<code>glDrawBuffer</code>函数指定附件来一个一个地复制：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    glBindFramebuffer(GL_READ_FRAMEBUFFER, m_DeferredFBO);
    glReadBuffer(GL_COLOR_ATTACHMENT0);
    glBindFramebuffer(GL_DRAW_FRAMEBUFFER, m_CommonFBO);
    glDrawBuffer(GL_COLOR_ATTACHMENT0);
    glBlitFramebuffer(0, 0, WIDTH, HEIGHT, 0, 0, WIDTH, HEIGHT, GL_COLOR_BUFFER_BIT, GL_NEAREST);

    glBindFramebuffer(GL_READ_FRAMEBUFFER, m_DeferredFBO);
    glReadBuffer(GL_COLOR_ATTACHMENT1);
    glBindFramebuffer(GL_DRAW_FRAMEBUFFER, m_CommonFBO);
    glDrawBuffer(GL_COLOR_ATTACHMENT1);
    glBlitFramebuffer(0, 0, WIDTH, HEIGHT, 0, 0, WIDTH, HEIGHT, GL_COLOR_BUFFER_BIT, GL_NEAREST);

    glBindFramebuffer(GL_READ_FRAMEBUFFER, m_DeferredFBO);
    glReadBuffer(GL_COLOR_ATTACHMENT2);
    glBindFramebuffer(GL_DRAW_FRAMEBUFFER, m_CommonFBO);
    glDrawBuffer(GL_COLOR_ATTACHMENT2);
    glBlitFramebuffer(0, 0, WIDTH, HEIGHT, 0, 0, WIDTH, HEIGHT, GL_COLOR_BUFFER_BIT, GL_NEAREST);

    glBindFramebuffer(GL_FRAMEBUFFER, 0);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>运行时屏幕上出现分块的原因：<ol>
<li>没有清空存储影响光源编号的SSBO缓存。</li>
<li>取影响光源编号时，不能根据是否等于-1（没有存储编号时的默认值）来判断是否终止取光源操作。因为对于数组<code>tiles[768][100]</code>，若<code>tiles[2]</code>中都存满了，即<code>tiles[2][99]</code>都是有值不等于-1的，那么会继续去取<code>tiles[2][100]</code>，这时其实取的是<code>tiles[3][0]</code>，即取到了下一个分块的影响光源编号，导致第2个分块的影响光源多算了，出现明显的分块现象。</li>
<li>存储分块影响光源编号的内存空间太小。</li>
</ol>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 毕设 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[项目中遇到的C++特性问题]]></title>
      <url>/2017/05/09/C++%E7%89%B9%E6%80%A7%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p><font size="5" color="orange">多态</font><br><a id="more"></a><br>使用基类实现多态时，是使用基类指针，而不是基类对象：</p>
<pre class="line-numbers language-c++"><code class="language-c++">class A{
    virtual print(){
        cout << "A" <<endl;
    }
};
class B : public A{
    print(){
        cout << "B" <<endl;
    }
};
int main(){
    A a = B();
    a.print();
    return 0;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面程序输出结果将是B，并没有实现多态。这是因为定义的是基类A的对象，将B对象赋值给它，只会赋值成员变量，并不会将成员函数也一起赋值给它，所以对象a还是使用的A类的print函数。但是改为：</p>
<pre><code>A* a = &amp;B();
</code></pre><p>a将指向B对象地址，再调用print函数时，执行的将是B类的print函数。<br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">C++数组越界问题</font><br>如下代码：</p>
<pre class="line-numbers language-c++"><code class="language-c++">int c[5];
c[7] = 123;
cout << c[7] << endl;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>在运行过程中编译器是不会报数组越界的错误的，这是因为c[7]的地址很可能还在程序栈空间中，如果是访问c[1000]就会出现数组越界的错误，因为c[1000]的地址可能已经超出了程序栈空间，非法访问其它地址。</p>
<p>不过在GLSL里面编译时是会出现数组越界错误的。但是下面这样GLSL也不会报错：</p>
<pre class="line-numbers language-c++"><code class="language-c++">int c[5];
int i = 7;
c[i] = 123;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>因为i是变量，在编译时无法确定它的值，所以不会报错，在运行时无论i多大glsl都不会报错。</p>
<p>如果定义<code>int a[3][4];</code>，那么a[1][4]其实是等于a[2][0]。</p>
<p><font size="5" color="orange">纯虚基类（抽象类）里的私有成员变量</font></p>
<hr>
<p>为了程序更好的设计风格和可修改性，应该尽量把类里的成员变量声明为私有的。对于纯虚基类也是如此，代码示例如下：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>
using namespace std;

class A {
private:
    int m_N;

public:
    virtual void draw() = 0;

    A() {
        m_N = 400;
    }

    int getN() {
        return m_N;
    }
};

class B : public A {
public:
    void draw() {
    }

    void print() {
        cout << getN() << endl;
    }
};

int main() {
    B b;
    b.print();

    return 0;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>运行结果如下：</p>
<pre class="line-numbers language-c++"><code class="language-c++">400
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>虚基类里的成员变量也应该是私有的，虽然无法被子类继承，但是公有的成员函数是可以继承的，子类可以通过继承自虚基类的getN函数，来间接访问虚基类的私有成员变量。</p>
<p>值得注意的是继承自父类的成员函数，是可以访问父类的私有成员变量的。</p>
<p><font size="5" color="orange">成员函数中用本类对象作为参数</font></p>
<hr>
<p>如果在类的成员函数里，其参数是本类对象，那么在函数内部可以通过对象名.的方式来直接访问私有成员变量：</p>
<pre class="line-numbers language-c++"><code class="language-c++">class A {
private:
    int n;
public:
    A() {
        n = 100;
    }
    int add(A a) {
        return n + a.n;
    }
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面的代码是可以正常工作的，形参a可以直接用a.n来访问其私有成员变量。</p>
<p>但是参数如果是别的类的对象，就没有访问权限了：</p>
<pre class="line-numbers language-c++"><code class="language-c++">class B {
private:
    int m;
public:
    B() {
        m = 200;
    }
};

class A {
private:
    int n;
public:
    A() {
        n = 100;
    }
    int add(B b) {
        return n + b.m;
    }
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面的代码会报错：B::m不可访问。</p>
<p>值得注意的是如果函数是处于类内部的友元函数（虽然它不是类的成员函数），也是可以直接访问到本类的私有成员变量的。这在重载运算符中有实际应用：</p>
<pre class="line-numbers language-c++"><code class="language-c++">class CShape {
private:
    int priority;
public:
    friend bool operator<(const CShape& iShape1, const CShape& iShape2);
}

bool operator<(const CShape& iShape1, const CShape& iShape2) {
    return iShape1.priority < iShape2.priority;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面的代码用友元函数重载了&lt;运算符，函数里可以直接通过对象名访问到其所在类的私有成员变量。</p>
<p><font size="5" color="orange">多态分配内存的对象指针</font><br>在实现多态时，需要用到基类指针，如果需要为基类指针用new动态分配内存，可以使用指向指针的指针：</p>
<pre class="line-numbers language-c++"><code class="language-c++">CShape **shapes = new CShape*[3];
shapes[0] = new CQuad();
shapes[1] = new CCircle();
shapes[2] = new CTriangle();
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中CShape是基类，CQuad、CCircle、CTriangle都是其子类。值得注意的是，new运算符返回的是指针，所以shapes[0]也应该是一个指针。如果用<code>CShape *shapes = new CShape[3];</code>，那么shapes[0]将会是一个CShape对象，这很好理解，和下述代码一样：</p>
<pre class="line-numbers language-c++"><code class="language-c++">int *array = new int[3];
array[0] = 10;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>其中array[0]就是一个整型，而非指针，同理上面的shapes[0]也是对象，而非指针。但是如果想要shapes[0]代表一个指针的话，就得将等号右边的<code>new CShape[3]</code>改为<code>new CShape*[3]</code>，等号左边改为指向指针的指针，*shapes表示一个CShape对象，**shapes才表示指向CShape对象的指针。</p>
]]></content>
      
        <categories>
            
            <category> c++ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> c++特性 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[项目中遇到的C++编译链接错误]]></title>
      <url>/2017/05/09/C++%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5/</url>
      <content type="html"><![CDATA[<ol>
<li>编译时出现重定义，可参考<a href="http://popperelay.com/2017/03/15/C++%E9%87%8D%E5%AE%9A%E4%B9%89/" target="_blank" rel="external">这篇文章</a><a id="more"></a></li>
<li>链接时出现LINK1120：无法解析的外部符号，这种情况通常都是没有包含对应的库文件，或者库文件没有包含正确。库文件包括.lib和.dll。</li>
<li>链接过程中出现读取访问冲突，很可能是空指针造成的。如果是在调用OpenGL函数的时候出现该问题，无法访问某个地址，则很有可能是在初始化GLEW之前就调用了该函数。要知道没有初始化GLEW，有可能某些OpenGL函数是无法使用的（版本问题）。</li>
<li>使用静态成员变量时出现无法解析的外部符号：原因是静态成员变量必须在类外进行初始化，否则的话是不会给它们分配内存空间的。</li>
<li>c++对bool变量的默认值是没有规定的，根据编译器不同，可能默认是true，也可能是false，应该自己显示对bool变量赋初始值，不要让编译来决定。</li>
<li><p>如下代码：</p>
<pre class="line-numbers language-c++"><code class="language-c++">test1.h:
#pragma once
#include "test2.h"

class A {
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">test1.cpp:
#include "test1.h"

int n = 10;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">test2.h:
#pragma once
#include "test1.h"
#include <iostream>
extern int n;
class B {
public:
 void draw() {
     std::cout << n << std::endl;
 }
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>程序时可以正常编译通过的，输出10。<br>但是下面的程序却无法通过：</p>
<pre class="line-numbers language-c++"><code class="language-c++">test1.cpp:
#include "test1.h"

A a;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">test2.h:
#pragma once
#include "test1.h"
#include <iostream>
extern A a;
class B {
public:
  void draw() {
  }
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>编译报错：C4430 缺少类型说明符 - 假定为 int。注意: C++ 不支持默认int。</p>
<p>这是因为C++头文件加载的顺序是不定的，有可能在加载test2之前，test1就已经加载好了，那么#include “test1.h”这句将不再起作用，由于test1.h和test2.h是两个独立的编译单元，test2又没有去加载test1，导致test2中无法识别类A，出现上诉错误。但是前面用int n是不报错的，因为int是系统基础类型，肯定认识它。</p>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> C++ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 编译链接错误 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C测试笔记]]></title>
      <url>/2017/04/19/C%E6%B5%8B%E8%AF%95%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<ol>
<li>C语言中默认没有bool类型。需要加上stdbool.h头文件以后才能使用bool类型。<a id="more"></a></li>
<li>符号常量（用define定义的）和变量不同，符号常量是不占内存的，只是一个临时符号，预编译后这个符号就不存在了。</li>
<li>变量名实际上是以一个名字代表的一个存储地址。编译链接时，编译系统会给每一个变量名分配对应的内存地址。</li>
<li>常变量（用const定义的）和常量不同，常变量具有变量的基本属性，有类型，占存储单元，而常量只是一个数，没有名字不占内存。</li>
<li>编码中常用的字符’1’、’A’等等，在内存中是以ASCII码存储的，占一个字节。字符’1’和整数1是不同的，整数1是以整数存储方式（二进制补码）存储的，占4个字节。例如：<pre class="line-numbers language-c++"><code class="language-c++">char c = '1';
printf("%d",c);
char a = 1;
printf("%d",a);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
输出结果是49和1。</li>
<li>字符型char也有signed和unsigned。</li>
<li>表达式如下：<pre class="line-numbers language-c++"><code class="language-c++">printf("%7.2f\n",12.345678f);
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
输出结果如下：<pre class="line-numbers language-c++"><code class="language-c++">12.35
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
整数部分12前面还有两个空格，%7.2表示输出结果总共占7列（包括小数点），保留两位小数并且会有四舍五入。</li>
<li>c语言中没有string类型，但是却可以使用<code>strlen</code>、’strcpy’等字符串函数：<pre class="line-numbers language-c++"><code class="language-c++">#include <stdio.h>
int main() {
 char str[4] = "acd";
 char str1[4];
 strcpy(str1,str);
 printf("%d\n",strlen(str));
 printf("%s",str1);
 return 0;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
输出结果是：<pre class="line-numbers language-c++"><code class="language-c++">3
adc
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
注意上面字符数组str的长度是4，这样赋值后C语言会自动在末尾添加一个<code>\0</code>。末尾有’\0’的字符数组才相当于字符串，才可以使用这些字符串函数。如果把str数组的长度改为3，是得不到正确结果的：<pre class="line-numbers language-c++"><code class="language-c++">char str[3] = "acd";     //不能正常使用字符串函数
char str[] = "acd";      //可以正常使用字符串函数
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
使用这些字符串函数时不需要加额外的头文件。</li>
<li>float型小数只能保证6位有效数字，double型小数只能保证15位有效数字。</li>
<li><code>printf(&quot;%-10.6f&quot;, a);</code>是左对齐的，不足的列数在右端用空格补齐；<br><code>printf(&quot;%10.6f&quot;, a);</code>是右对齐的，不足的列数在左端用空格补齐。</li>
<li>指数格式输出：<pre class="line-numbers language-c++"><code class="language-c++">printf("%e\n", 123.456);
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
输出结果是：<pre class="line-numbers language-c++"><code class="language-c++">1.234560e+002
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li>如果想输出‘%’，应该使用两个’%’：<pre class="line-numbers language-c++"><code class="language-c++">printf("%%");
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li>如果是<code>scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);</code>，则应该像这样输入<code>1 2 3</code>，以空格或者回车来分隔每个输入的数据。<br>但如果是<code>scanf(&quot;%d,%d,%d&quot;, &amp;a, &amp;b, &amp;c);</code>，则需要像这样输入<code>1,2,3</code>，需要加上逗号。</li>
<li>C语言中求log_10 x 的函数是<code>log10</code>，也有<code>log</code>函数，不过它求的是lnx。</li>
<li><p>求最大公约数的核心思想：<br>对于辗转相除法（欧几里德算法），核心点在于m、n和m%n的最大公约数是相等的，一直除余到0后，得到的除数或者说被除数就是最大公约数：</p>
<pre class="line-numbers language-c++"><code class="language-c++">int gcd(int m,int n){
  if(m<n){
      int t;
      t=m;
      m=n;
      n=t;
  }
  while(m%n!=0){
      int k=n;
      n=m%n;
      m=k;
  }
  return n;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对于更相减损法，核心点在于m、n和m-n的最大公约数是相等的，一直相减到差是0后，得到的减数或者说被减数就是最大公约数：</p>
<pre class="line-numbers language-c++"><code class="language-c++">int gcd(int m,int n){
  if(m<n){
      int t;
      t=m;
      m=n;
      n=t;
  }

  int k;
  while((k=m-n)!=0){
      if(k>n){
          m=k;
      }
      else{
          m=n;
          n=k;
      }
  }
  return m;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>仔细想一想，其实辗转相除法和更相减损法的核心思想是一样的，更相减损法是两个数和它们的差的公约数相等，辗转相除法不过是多做了几次差变成了余数而已。</p>
<p>最小公倍数就是两个数的成绩除以最大公约数。</p>
</li>
<li><p>虽然通常情况下不能定义数组的大小为变量，即a[n]是非法的，只能是a[10]这种的；但是在自定义函数中，如果数组大小n是函数的参数，那么a[n]是合法的：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#include <stdio.h>

void func(int n);
int main() {
    int n = 10;
    func(n);
    return 0;
}

void func(int n) {
    int a[n];
    int i;
    for (i = 0; i<n; i++) {
        a[i] = i;
    }
    for (i = 0; i<n; i++) {
        printf("%d ", a[i]);
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>输出结果是：</p>
<pre class="line-numbers language-c++"><code class="language-c++">0 1 2 3 4 5 6 7 8 9
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>如下程序：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#include <stdio.h>

int main() {
    char a[]={'i',' ','a','m',' ','a',' ','b','o','y'};
    char b[]={'i',' ','a','m',' ','a',' ','b','o','y','\0'};
    char c[]="i am a boy";
    printf("%s\n",a);
    printf("%s\n",b);
    printf("%s\n",c);
    return 0;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>输出结果是：</p>
<pre class="line-numbers language-c++"><code class="language-c++">i am a boy?@
i am a boy
i am a boy
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>说明使用{ }对字符数组赋值时，系统不会自动在末尾加’\0’，而使用” “的形式对字符数组赋值时，系统会自动在末尾加’\0’。末尾有’\0’的字符数组才相当于字符串。</p>
</li>
<li>一次输入多个字符串时，以空格分隔开：<pre class="line-numbers language-c++"><code class="language-c++">char str1[5],str2[5],str3[5];
scanf("%s%s%s",str1,str2,str3);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
输入是应该像下面这样：<pre class="line-numbers language-c++"><code class="language-c++">How are you?
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
如果只定义了一个<code>char str[15]; scanf(&quot;%s&quot;,str);</code>，如果还是像上面那样输入，因为是以空格作为字符串分隔标志的，所以传入str的就只有How。</li>
<li>字符串输入函数<code>gets(str);</code>可以接受字符串中有空格。</li>
<li><code>strncpy(str1, str2, n);</code>表示用字符串str2的前n个字符复制到str1中，取代str1的<strong>前n个字符</strong>。如下面的程序：<pre class="line-numbers language-c++"><code class="language-c++">char str1[]="i am a boy";
char str2[]="she is";
strncpy(str1,str2,6);
printf("%s\n",str1);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
输出结果是：<pre class="line-numbers language-c++"><code class="language-c++">she is boy
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li>将字符串转换为小写的函数：<code>strlwr(str)</code>。<br>将字符串转化为大写的函数：<code>strupr(str)</code>。<br>注意它们的返回类型是void。</li>
<li><p>魔方阵：各行、各列、对角线的和都相等的n*n矩阵（矩阵元素是从1到n*n）。<br>注意偶数阶（n为偶数）的魔方阵是不存在的。</p>
<p>求解魔方阵的算法如下：</p>
<ol>
<li>把1放在第一行的中间位置</li>
<li>从2开始直到n*n的数，准备放在前一个数的右上角（行减1，列加1）。如果行减到小于0，则行变为n-1，如果列加到大于n-1，则列变为0。</li>
<li>如果要放置的位置已经被占了，则把这个数直接放在上一个数的下面（行加1，列不变）。</li>
</ol>
<p>实现代码如下：</p>
<pre class="line-numbers language-c++"><code class="language-c++">void MagicMatrix(int n){  //n不要大于10
    if(n%2==0){
        printf("not!\n");
        return;
    }
    int a[10][10]={0};
    int i,j;
    int k=n/2;
    int col=k,row=0;
    int lastRow,lastCol;
    a[0][k]=1;
    for(i=2;i<=n*n;i++){
        lastRow=row;
        lastCol=col;
        col++;
        if(col>n-1)
            col=0;
        row--;
        if(row<0)
            row=n-1;
        if(a[row][col]==0)
            a[row][col]=i;
        else{
            row = lastRow+1;
            col = lastCol;
            a[row][col]=i;
        }
    }
    for(i=0;i<n;i++){
        for(j=0;j<n;j++){
            printf("%d ",a[i][j]);
        }
        printf("\n");
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>C语言中memset函数的头文件是string.h。</li>
<li><p>汉诺塔问题：A塔上有64个盘子，大的在下，小的在上，还有两座空的B塔和C塔。每次只移动一个盘子，而且移动过程中所有塔都是大盘在下，小盘在上，要求把A盘上的64个盘子移到C盘。</p>
<p>分析：这是一个递归问题。</p>
<ol>
<li>要从A移动n个盘子到C，需要先把n-1个盘子移动到B，</li>
<li>然后把A最下面的大盘子移动到C，</li>
<li>再把B上的n-1个盘子移动到C。</li>
</ol>
<p>移动n-1个盘子，这就是递归问题。只不过是从哪个盘子移动到哪个盘子变了而已，第二步是从A移动到C，第三步是从B移动到C，这个我们在递归调用的时候调整一下参数顺序就ok了。</p>
<p>代码实现如下：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#include <stdio.h>

void Hanoi(int n,char one,char two,char three);
int main() {
    Hanoi(3,'A','B','C');
    return 0;
}

void Hanoi(int n,char one,char two,char three){
    if(n==1){
        printf("%c->%c\n",one,three);
        return;
    }
    Hanoi(n-1,one,three,two);
    printf("%c->%c\n",one,three);
    Hanoi(n-1,two,one,three);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>输出结果如下：</p>
<pre class="line-numbers language-c++"><code class="language-c++">A->C
A->B
C->B
A->C
B->A
B->C
A->C
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>C语言变量存储类别有4种：自动的（auto）、静态的（static）、寄存器的（ register）、外部的（extern）。</li>
<li>静态局部变量（在函数中定义的static变量）是在编译时赋初值的，即只赋值一次，以后每次调用函数时不再重新赋初值，而是保留上一次函数调用结束后的值。如果不对静态局部变量赋初值，编译时会自动赋为0或者空字符<code>\0</code>，但是如果不对自动变量赋初值，它的值就会是不确定的。因为静态局部变量是存放在静态存储区的，程序执行过程中不会改变位置，而自动变量是存放在动态存储区的，在每次函数结束后都会释放存储单元，下次调用时又重新分配存储单元，而所分配的存储单元中的内容是不可知的。</li>
<li>寄存器变量使用register声明的变量，如下：<pre class="line-numbers language-c++"><code class="language-c++">register int i;
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
寄存器变量用于存储那些使用非常频繁的变量，比如在10000次循环中每次都要用到的变量。其实现在的编译系统通常都能识别使用频繁的变量，从而自动把这些变量放到寄存器里，不需要程序设计者指定。所以用register声明变量的必要性不大。</li>
<li><p>extern外部变量：<br>其实用extern声明的外部变量是强制把变量的作用域扩大了。比如在同一个文件中，变量在后面声明的，但是在前面就想要用到这个变量，那么可以在用这个变量时，使用extern声明一下这个变量，把它的作用域扩展到此声明处。如下：</p>
<pre class="line-numbers language-c++"><code class="language-c++">int main(){
    extern int A,B,C;
    ...
}

int A,B,C;

int max(int a, int b){
    ...
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>还可以使用extern把全局变量的作用域扩展到另一个文件：比如在一个程序文件中声明了全局变量Num，在另一个程序文件里也想使用这个变量，那么可以在另一文件中用extern对Num扩大作用域，即<code>extern Num;</code>。在编译连接时，系统会由此知道Num有外部链接，就会从别的文件找到已定义的Num变量，并把作用域扩展到本文件。</p>
</li>
<li>把全局变量的作用域强制限制在本文件，可以使用static关键字声明。这样有利于不同文件独立，即使在不同文件中定义了同名的全局变量，甚至使用了extern关键字，都会互不影响。</li>
<li><p>注意对于全局变量来说，无论是否用static关键字声明，它都是存储在静态存储区的，这一点和局部变量不同：</p>
<ul>
<li>对局部变量用static关键字声明，会把它分配在静态存储区，该变量在整个程序执行期间不释放其存储单元，知道程序结束。</li>
<li>对全局变量用static声明，是限制该变量的作用域只限于本文件模块（即被声明的文件中）。</li>
</ul>
<p>【注】：全局变量是指在函数外部定义的变量，不一定是在文件开头处定义的外部变量。也就是说这里的全局变量就是外部变量。</p>
</li>
<li>在函数定义时用static声明，是把该函数作为静态函数，限制在本文件中使用，如果在函数定义时用extern声明，则该函数可以在其他文件中使用，在其他文件中使用时需要先用extern声明该函数，表示该函数是在其他文件中定义的。其实在C语言中可以省写extern，因为函数在本质上就是外部的。可以知道，函数原型声明其实就是扩大函数的作用域（到本文件的该函数前面区域，甚至扩大到其他文件都可以）。函数原型会通知编译系统，该函数在本文件稍后定义，或在另一文件中定义。利用函数原型扩展函数作用域最常见的例子就是<code>#include &lt;....h&gt;</code>，因为通常在 #include指定的头文件中包含了很多函数原型，以此来扩展函数作用域到本文件。</li>
<li>变量名其实就是地址的别名，可以通过变量名直接访问到对应地址中的内容；而指针是另一个变量，它存储着别的变量所对应的地址，访问时，指针变量会根据自己对应的地址去取出地址里的内容，而这个内容就是另一个变量的地址，再根据取出来的这个地址，就可以去访问另一个变量里存储的内容了。总之，通常所说的指针是一个存储着别人的地址的变量。</li>
<li>如果指针是字符型的，那么指针加1，是使它存储的地址值加1；如果是整型的，那么指针加1，是使它存储的地址值加4。</li>
<li>指针运算符*和自加运算符++是同等优先级的，所以*p++等价于*(p++)，都是先取*p，再使p加1。*(++p)是先使p加1，再取*。</li>
<li>对于二维数组a[m][n]来说，a表示首行（第0行）的首地址，a+1表示第1行的首地址，就是指向a[1]，和&amp;a[1]等价。注意对于二维数组来说，a[i]只是第i行的首地址，是个指针，a[i]和*(a+i)等价，a[i][j]和*(*(a+i)+j)等价。要表示二维数组中某个元素的值，应该是两层指针*。还有，&amp;a[0]与a等价，都是指向第0行的，a[0]是指向第0行第0列的；&amp;a[1]与a+1等价，都是指向第1行的。总之a、a+i等是二维指针，有两个**，a[0]等是一维指针，有1个*。<br>如下面的程序：<pre class="line-numbers language-c++"><code class="language-c++">int a[2][2]={0};
printf("%d\n",a);
printf("%d\n",*a);
printf("%d\n",**a);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
输出结果如下：<pre class="line-numbers language-c++"><code class="language-c++">2686720
2686720
0
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li>可以使用指针指向的字符串来代替printf函数中的格式字符串：<pre class="line-numbers language-c++"><code class="language-c++">char* format;
format = "a=%d,b=%f\n";
printf(format,a,b);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
它相当于：<pre class="line-numbers language-c++"><code class="language-c++">printf("a=%d,b=%f\n",a,b);
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
只要改变format所指向的字符串，就可以改变输入输出的格式，这种printf称为可变格式输出函数。当然用字符数组代替上面的指针也是可以的。</li>
<li><p>函数指针：指向函数代码存储空间首地址的指针。如下：</p>
<pre class="line-numbers language-c++"><code class="language-c++">int (*p)(int,int);
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这个p就是指向函数的指针变量，它可以指向函数类型为int且有两个int型参数的函数。除了用函数名来调用函数，我们还可以通过函数指针来调用函数：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#include <stdio.h>

int max(int a,int b);
int main() {
    int a=1,b=2;
    int(*p)(int,int);
    p=max;
    printf("max is %d\n",(*p)(a,b));
    return 0;
}

int max(int a,int b){
    return a>b?a:b;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其实就是用函数指针*p代替了函数名max而已。</p>
<p>函数指针可以作为其他函数的参数，这样在不同情况下通过传入不同的实参，就能实现调用不同的函数。</p>
</li>
<li><code>int *p[4]</code>和<code>int (*p)[4]</code>是不一样的，前者是指针数组（有4个指针的数组），后者是指向一维数组的指针变量。</li>
<li>带参数的main函数：<pre class="line-numbers language-c++"><code class="language-c++">int main(int argc, char* argv[]){
    ...
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
main函数也是可以带有参数的，argc是argument count的缩写，表示参数个数，argv是argument vector的缩写，是一个char*指针数组，数组中的每一个元素指向命令行中的一个字符串。由于main函数是有操作系统调用的，所以它的参数也是由操作系统提供。通常在命令行状态下，我们可以通过类似DOS界面给main函数指定参数。在DOS下的命令行一般形式是：<pre class="line-numbers language-c++"><code class="language-c++">可执行文件名  参数1  参数2......参数n
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
它们之间用空格分开。可执行文件里应该包含main函数，且实际上应该还要包含文件路径。如果我们给出的命令行像这样：<pre class="line-numbers language-c++"><code class="language-c++">file1 China Beijing
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
main函数像这样：<pre class="line-numbers language-c++"><code class="language-c++">int main(int argc, char* argv[]){
    while(argc>1){
        ++argv;
        printf("%s\n",argv);
        --argc;
    }
    return 0;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
执行程序后会输出如下：<pre class="line-numbers language-c++"><code class="language-c++">China
Beijing
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li>C语言里的动态分配内存相关函数（声明在stdlib.h头文件中）：<ul>
<li>malloc函数：<br>函数原型是：<code>void* malloc(unsigned int size);</code>，用于在内存的动态存储区中分配一个长度为size字节的连续空间。</li>
<li>calloc函数：<br>函数原型是：<code>void* calloc(unsigned n, unsigned size);</code>，用于在内存的动态存储区分配n个长度为size字节的连续空间。例如：<code>p=calloc(50,4);</code>。</li>
<li>free函数：<br>函数原型是：<code>void free(void* p);</code>，用于释放指针变量p所指向的动态空间。</li>
<li>realloc函数：<br>函数原型是：<code>void* realloc(void* p, unsigned int size);</code>，用于改变指针p所指向的动态空间的大小为size字节。</li>
</ul>
</li>
<li>约瑟夫环：n个人围成一圈，从任意某个人从1开始报数，报到第m个的人拖出去，剩下的人接着从1开始报数，报到第m个的人再拖出去，……，如此循环，问最后一个人是原来的第几个人。该问题可用<a href="http://blog.163.com/soonhuisky@126/blog/static/157591739201321341221179/" target="_blank" rel="external">数学方法</a>解决，也可用循环链表实现。</li>
<li>下面的程序是正确的：<pre class="line-numbers language-c++"><code class="language-c++">int* p;
p=malloc(sizeof(int));
p[2]=200;
printf("%d\n",p[2]);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
但是如果把第二行去掉，会报错，这是因为没有指明指针p指向哪个位置，p[2]是无意义的。</li>
<li>使用union声明的共用体，它里面的所有成员都是从同一个位置开始存放的（覆盖技术）。每一瞬间只能存放一个成员。</li>
<li>用typedef声明新类型名：<pre class="line-numbers language-c++"><code class="language-c++">typedef int Interger;   //指定用Integer为类型名，作用与int相同
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li>文件分为ASCII文件和二进制文件。比如整数10000，用ASCII码存储到文件时，占用5个字节；而以二进制形式存储到文件时，只占用4个字节。</li>
<li><p>C语言使用<code>File* fopen(文件名，文件打开方式);</code>来打开文件；<br>使用<code>int fclose(File*)</code>来关闭文件；<br>使用<code>char fgetc(File*)</code>来从文件读取一个字符，使用<code>char fputc(char, File*)</code>来把一个字符写入到文件。<br>使用<code>char* fgets(char* str, int n, File* fp)</code>来从文件读取n-1个字符到str字符串中（末尾加’\0’）。<br>使用<code>int fputs(str, fp)</code>来把字符串输出到文件。</p>
<p>例如，从一个文件中读取数据写入到另一个文件中：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#include <stdio.h>
#include <stdlib.h>

int main() {
    FILE *fin,*fout;
    char ch;
    fin=fopen("test1.txt","r");
    if(fin==NULL){
        printf("open file1 failed!\n");
    }
    fout=fopen("test2.txt","w");
    if(fout==NULL){
        printf("open file2 failed\n");
    }
    while(!feof(fin)){
        ch=fgetc(fin);
        fputc(ch,fout);
    }
    fclose(fin);
    fclose(fout);
    return 0;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>上面是对文件以字符的形式进行输入输出，还可以格式化的方式读写文件：</li>
</ol>
<ul>
<li>fprintf函数：<pre class="line-numbers language-c++"><code class="language-c++">fprintf(fout, "%d%f", i, f);
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li>fscanf函数：<pre class="line-numbers language-c++"><code class="language-c++">fscanf(fin, "%d%f", &i, &f);
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
由于fprintf函数在输出时要将内存中的二进制转换为字符，fscanf函数在输入时要将文件中的ASCII码字符转换为二进制在保存到内存变量中，这种转换要花费很多时间，所以我们通常使用fread和fwrite函数来代替他俩进行二进制的读写。</li>
</ul>
<ol>
<li>fread函数一次从文件中读取一个数据块，fwrite函数向文件写一个数据块。它们都是以二进制形式进行读写的。<ul>
<li>fread函数原型：<code>fread(buffer, size, count, fp);</code><br>buffer是存储从文件读出的数据的内存起始地址，size是每个数据项的字节数，count要读取的数据项个数，fp是文件指针。</li>
<li>fwrite函数原型：<code>fwrite(buffer, size, count, fp);</code><br>buffer是准备写入文件的内存数据的内存起始地址，size、count、fp同上。</li>
</ul>
</li>
<li>更改文件读写位置的相关函数：<ul>
<li><code>void rewind(FILE* fp)</code>函数：强制将文件读写位置更改为文件开头。</li>
<li>fseek函数：函数原型是：<code>fseek(文件指针，位移量，起始点);</code><br>起始点有0、1、2三个选项，0表示文件开头，1表示当前位置，2表示文件末尾。位移量是以起始点为基准，向前移动的字节数。注意位移量数据类型是long型。例如：<pre class="line-numbers language-c++"><code class="language-c++">fseek(fp, 100L, 0);
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li>long ftell(FILE* p)函数：读出当前的文件读写位置。返回的是当前位置相对于文件开头的位移量。</li>
</ul>
</li>
<li>牛顿迭代法求方程f(x)=0的根，实际上是从估计值x0开始，不断对fx切线方程，该切线与x轴（y=0）的交点x1会比x0更加精确（更容易使得f(x)=0），然后以x2求fx的切线，得到与x轴的交点x3…直到前后两次交点的差值满足一定的精度（小于某个值）。</li>
<li>long类型通常是4个字节。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> C语言 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++里XXX重定义]]></title>
      <url>/2017/03/15/C++%E9%87%8D%E5%AE%9A%E4%B9%89/</url>
      <content type="html"><![CDATA[<p>有时候我们编译工程会出现重定义的编译错误，在同一个源文件里定义两个相同的变量就不说了，这是最低级的错误。我们来说一下其他可能造成重定义的原因和解决办法。<a id="more"></a></p>
<ol>
<li>没有在头文件最前面加<code>#pragma once</code>：<br>如果我们在同一个文件中包含了某个头文件两次：<pre class="line-numbers language-c++"><code class="language-c++">#include "A.h"
#include "A.h"
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
那么在A里面定义的变量就会出现重定义的错误。</li>
<li>我们在某个文件中包含了A.h和B.h，但是在B.h里面也包含了A.h，那么就会造成A.h里面变量的重定义。</li>
</ol>
<p>这种重复包含头文件，就会造成头文件被重复编译，出现重定义的编译错误。即使没有出现重定义的错误，但是这样重复编译头文件，也会使编译效率低下。一个解决办法是在头文件前面加上<code>#pragma once</code>，它的意思是让该头文件只编译一次。</p>
<p>但是如果在不同的头文件中定义了相同的类型，即使是加上了<code>#pragma once</code>，也会出现重定义。如下：</p>
<pre class="line-numbers language-c++"><code class="language-c++">----A.h文件：-----
#pragma once
int A;  //全局变量

----B.h文件：-----
#pragma once
int A;  //同样的全局变量

----主程序：------
#include "A.h"
#include "B.h"
int main() {
    return 0;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>还有一种会出现重定义的可能是在映射虚拟盘的时候，可参考<a href="http://www.cnblogs.com/baiyanhuang/archive/2009/09/17/1730732.html" target="_blank" rel="external">这篇文章</a>。</p>
<p>其实避免上述重定义的最好解决办法是使用<code>#ifndef/#define/#endif</code>，以这样的方式来保证头文件里的相同内容只被编译一次：</p>
<pre class="line-numbers language-c++"><code class="language-c++">----A.h文件：-----
#ifndef A_H
#define A_H
int A;  //全局变量
...
#endif // !A_H

----B.h文件：-----
#ifndef A_H
#define A_H
int A;  //同样的全局变量
...
#endif // !A_H

----主程序：------
#include "A.h"
#include "B.h"
int main() {
    return 0;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这样<code>int A</code>就不会被多次编译了。要实现整个头文件只被编译一次（代替#pragma once的作用），可以这样做（把原来的整个头文件放在#define 和#endif的中间）：</p>
<pre class="line-numbers language-c++"><code class="language-c++">//#pragma once
#ifndef A_H
#define A_H

class A {
    ...
};

#endif // !A_H
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用#ifndef虽然比较古老，但是却有很好的稳定性和可移植性。<br>&nbsp;</p>
<hr>
<p>参考文献：<br><a href="http://www.cnblogs.com/baiyanhuang/archive/2009/09/17/1730732.html" target="_blank" rel="external">http://www.cnblogs.com/baiyanhuang/archive/2009/09/17/1730732.html</a><br><a href="http://blog.csdn.net/abc5382334/article/details/18052757" target="_blank" rel="external">http://blog.csdn.net/abc5382334/article/details/18052757</a></p>
]]></content>
      
        <categories>
            
            <category> 调试错误集锦 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 重定义错误 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OpenGL25：反走样初步]]></title>
      <url>/2017/03/09/OpenGL25%E5%8F%8D%E8%B5%B0%E6%A0%B7%E5%88%9D%E6%AD%A5/</url>
      <content type="html"><![CDATA[<p><font size="5" color="orange">锯齿效果</font><br><a id="more"></a></p>
<hr>
<p>在我们的渲染中，可能会遇到模型边缘有锯齿的问题。锯齿边出现的原因是由顶点数据像素化成为片段的方式引起的。比如直线上的点是连续的，而屏幕上的像素却是离散的，用屏幕上的像素来近似表示直线段，必然会出现锯齿效果（可参考<a href="http://popperelay.com/2016/11/06/%E5%9F%BA%E6%9C%AC%E5%85%89%E6%A0%85%E5%9B%BE%E5%BD%A2%E7%94%9F%E4%BA%A7%E6%8A%80%E6%9C%AF/" target="_blank" rel="external">《基本光栅图形生成技术》</a>一文中的直线扫描转换）。</p>
<p>下面是一个简单的立方体，可以看到它有锯齿边的效果：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148896296658.png" alt=""><br>放大后会更明显：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148896296704.png" alt=""><br>很明显能看到边是由像素所构成的，这种现象叫做走样（Aliasing）。有很多技术能够减少走样，产生更平滑的边缘，这些技术叫做抗锯齿技术（Anti-aliasing，也被称为反走样技术）。<br>&nbsp; </p>
<hr>
<p><font size="5" color="orange">超级采样抗锯齿技术</font><br>超级采样反走样技术（Super-Sampled Anti-Aliasing，SSAA），是通过以更高的分辨率来采样图形，然后再显示在低分辨率的设备上，从而减少失真的方法。例如下图表示了增加分辨率后，绘制直线的差别：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148896296771.png" alt=""><br>通过将高分辨率的图形，显示在低分辨率的设备上，确实能有效减轻走样现象，但是存在的弊端就是：要为这些多出来的像素，进行更多的计算，并且内存开销很大。这是一种比较传统的方法。<br>&nbsp; </p>
<hr>
<p><font size="5" color="orange">多重采样抗锯齿技术</font><br>多重采样抗锯齿技术（Multi-Sampled Anti-Aliasing，MSAA）是对SSAA的改进，改进之处在于执行像素着色器的次数并没有明显增加，对边缘部分却进行了很好的反走样。多采样相对于单采样，单采样在一个像素上，以像素中心为标准，当光栅化时，如果这个中心采样点在图元内部，那么就生成这个像素对应的片段，否则如果采样点不在图元内部，那么就不生成对应片段。而多采样，是在每个像素上进行细分，在每个像素上分出更多的子采样点（sub-sample），如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148902896823.png" alt=""><br>当图元覆盖了像素中的子采样点时，则会执行像素着色器。像素着色器的执行不是以子采样点为单位，也就是说不管有多少个子采样点，这个像素只执行一次像素着色器。执行的结果会存储到每个被覆盖的子样本中（没有被覆盖的子样本还是保持背景色）。最终的像素颜色将取为像素里这些子采样点颜色的平均值。</p>
<p>例如上图中，三角形图元覆盖了某个像素中的2个采样点，那么这个像素的最终颜色由三角形覆盖的2个采样点的颜色和另外两个采样点的颜色（可能是<code>glClearColor指定的颜色</code>）的均值决定。</p>
<p>下图是单采样对应的光栅化过程：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148902896869.png" alt=""><br>下图是多采样对应的光栅化过程：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148902896923.png" alt=""><br>用过多采样，绘制的三角形的边缘部分，因为有了和背景颜色的混合，从而减轻了走样现象，如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148902896972.png" alt=""><br>开启MSAA以后，不仅颜色会多采样，深度和模板测试也同样会多采样，每个子样本都会去存储颜色值、深度值和模板值。也就是说所需要的颜色、深度和模板缓冲大小都会增加。<br>&nbsp; </p>
<hr>
<p><font size="5" color="orange">在OpenGL中使用MSAA</font><br>为了在OpenGL中使用MSAA，我们需要一个更大的缓冲来存储多采样点的采样结果，称之为多样本缓冲。</p>
<p>我们所使用的GLFW窗口系统就给我们提供了这个多样本缓冲，来代替默认的颜色缓冲。我们需要用<code>glfwWindowHint</code>来设置：</p>
<pre class="line-numbers language-c++"><code class="language-c++">glfwWindowHint(GLFW_SAMPLES, 4);
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>它会告诉OpenGL。每个像素使用一个包含4个子样本的颜色缓冲。</p>
<p>接下来我们需要使用<code>glEnable</code>函数来开启多采样：</p>
<pre class="line-numbers language-c++"><code class="language-c++">glEnable(GL_MULTISAMPLE);
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>由于实际的多采样算法在OpenGL驱动光栅化里已经实现了，所以我们不需要做别的了。运行效果如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148902600407.png" alt=""><br>可以看到还是有很明显的抗锯齿效果的。</p>
<p>直接使用<code>glEnable</code>开启多采样，实现反正样的源码请看<a href="https://github.com/Popperelay/BlogCode/tree/master/LearnOpenGL25_MSAA/LearnOpenGL25_MSAA_1" target="_blank" rel="external">这里</a>。</p>
<p><font size="5" color="orange">离屏MSAA</font></p>
<hr>
<p>有的时候需要让MSAA的效果渲染到我们自定义的帧缓冲中。</p>
<p>我们首先为自定义的帧缓冲创建多采样纹理，来存储多采样结果。</p>
<p><font size="4" color="red">多采样纹理附件</font><br>创建多采样纹理和普通纹理的不同之处在于，使用<code>glTexImage2DMultisample</code>函数来代替<code>glTexImage2D</code>，而且纹理目标得改为<code>GL_TEXTURE_2D_MULTISAMPLE</code>：</p>
<pre class="line-numbers language-c++"><code class="language-c++">glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, tex);
glTexImage2DMultisample(GL_TEXTURE_2D_MULTISAMPLE, samples, GL_RGB, width, height, GL_TRUE);
glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, 0);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>第二个参数samples是我们打算让纹理拥有的样本数。最后一个参数设置为<code>GL_TRUE</code>，可以让图像上的每一个纹理像素使用相同的样本位置，以及同样的子样本数量。</p>
<p>创建好多采样纹理后，我们还是使用<code>glFramebufferTexture2D</code>函数来把它附加到帧缓冲上，不过纹理类型改为<code>GL_TEXTURE_2D_MULTISAMPLE</code>：</p>
<pre class="line-numbers language-c++"><code class="language-c++">glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D_MULTISAMPLE, tex, 0);
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><font size="4" color="red">多采样渲染缓冲对象附件</font><br>除了多采样纹理附件外，我们还可以使用渲染缓冲对象rbo。跟以前不同的是，在为渲染缓冲分配内存的时候，要将<code>glRenderbufferStorage</code>改为<code>glRenderbufferStorageMultisample</code>：</p>
<pre class="line-numbers language-c++"><code class="language-c++">glRenderbufferStorageMultisample(GL_RENDERBUFFER, 4, GL_DEPTH24_STENCIL8, width, height);
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>注意上面的4就是我们设置的样本数量。</p>
<p><font size="4" color="red">渲染到多采样帧缓冲</font><br>绑定我们自定义的帧缓冲以后，正常绘制就能把颜色、深度、模板等信息写入多采样帧缓冲。但是多采样缓冲有点特别，不能直接使用渲染得到的缓冲图像，比如在着色器中进行采样作后处理。</p>
<p>这是因为多采样图像包含了比普通图像更多的信息，我们需要压缩（或还原）图像。通常用<code>glBlitFramebuffer</code>函数来还原多采样帧缓冲，它会从一个帧缓冲中复制一个区域粘贴到另一个帧缓冲里，同时会将多采样缓冲还原。</p>
<p><code>glBlitFramebuffer</code>函数把一个4屏幕坐标源区域传递到另一个也是4空间坐标的目标区域。在这之前，我们需要先设置读缓冲区（源区域）和写缓冲区（目标区域）：</p>
<pre class="line-numbers language-c++"><code class="language-c++">glBindFramebuffer(GL_READ_FRAMEBUFFER, multisampledFBO);
glBindFramebuffer(GL_DRAW_FRAMEBUFFER, 0);
glBlitFramebuffer(0, 0, width, height, 0, 0, width, height, GL_COLOR_BUFFER_BIT, GL_NEAREST);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>编译运行后，我们将得到和之前一样的结果，边缘锯齿明显减少了：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148902600494.png" alt=""><br>【注】：</p>
<ul>
<li>渲染到自定义的帧缓冲时，不需要使用<code>glfwWindowHint</code>和开启反走样。因为在指定缓冲附件的时候，我们已经指明了使用多采样缓冲附件。</li>
</ul>
<p>渲染到自定义帧缓冲的反走样源码（不用开启OpenGL的反走样）在<a href="https://github.com/Popperelay/BlogCode/tree/master/LearnOpenGL25_MSAA/LearnOpenGL25_MSAA_2" target="_blank" rel="external">这里</a>。</p>
<p><font size="5" color="orange">多采样纹理转换为普通2D纹理</font></p>
<hr>
<p>上面我们把多采样缓冲还原到默认缓冲了，可以正常渲染出MSAA效果。但是如果我们不想还原到默认缓冲，需要继续做后处理怎么办？原理其实一样的，我们就不还原到默认缓冲，而是还原到另一个自定义的帧缓冲，只是这次的帧缓冲使用正常的缓冲附件，而非多采样缓冲附件。伪代码如下：</p>
<pre class="line-numbers language-c++"><code class="language-c++">//创建多采样的fbo
GLuint msFBO;
...
//创建正常的fbo
GLuint intermediateFBO;
...

while(!glfwWindowShouldClose(window))
{
    ...

    glBindFramebuffer(msFBO);
    ClearFrameBuffer();
    DrawScene();
    // 将多采样缓冲还原到普通的自定义帧缓冲
    glBindFramebuffer(GL_READ_FRAMEBUFFER, msFBO);
    glBindFramebuffer(GL_DRAW_FRAMEBUFFER, intermediateFBO);
    glBlitFramebuffer(0, 0, width, height, 0, 0, width, height, GL_COLOR_BUFFER_BIT, GL_NEAREST);
    // 将得到的普通自定义帧缓冲的纹理图贴到屏幕四边形上
    glBindFramebuffer(GL_FRAMEBUFFER, 0);
    ClearFramebuffer();
    glBindTexture(GL_TEXTURE_2D, screenTexture);
    DrawPostProcessingQuad();  

    ...
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果我们实现之前在<a href="http://popperelay.com/2017/01/21/OpenGL19%E5%B8%A7%E7%BC%93%E5%86%B2/" target="_blank" rel="external">《OpenGL19：帧缓冲》</a>中的后处理效果，比如模糊kernel，结果会像这样：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/14890260054.png" alt=""></p>
<p>将多采样纹理转换为普通2D纹理，实现反走样的所有源码请看<a href="https://github.com/Popperelay/BlogCode/tree/master/LearnOpenGL25_MSAA/LearnOpenGL25_MSAA_3" target="_blank" rel="external">这里</a>。</p>
<p>由于屏幕纹理重新变回了只有一个采样点的普通纹理，有些后处理，比如边缘检测（edge-detection）将会再次导致锯齿边问题。为了修正此问题，我们应该对这个屏幕纹理进行模糊处理，或者自定义抗锯齿算法。</p>
<p>注意开启多采样会明显降低性能，样本越多越明显，MSAA4是最常用的。</p>
<p><font size="5" color="orange">自定义反走样算法</font></p>
<hr>
<p>其实也可以直接把一个多采样纹理图像传到着色器里，就是不需要先还原。这个时候我们就得将uniform采样器定义为sampler2DMS了，而不是sampler2D：</p>
<pre class="line-numbers language-c++"><code class="language-c++">uniform sampler2DMS screenTextureMS;
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>然后使用<code>texelFetch</code>函数来获取每个样本的信息（比如样本颜色）：</p>
<pre class="line-numbers language-c++"><code class="language-c++">vec4 colorSample = texelFetch(screenTextureMS, TexCoords, 3);
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>3是指我们想获取像素中第4个样本的信息。</p>
<p>获取到像素中每个样本的信息后，我们就可以自定义反走样算法，来决定如何生成最终的像素颜色。能够获取到MSAA中每个样本的颜色、深度、模板等信息，有时候还是很需要的！<br>&nbsp; </p>
<hr>
<p>参考文献：<a href="https://learnopengl.com/" target="_blank" rel="external">LearnOpenGL</a></p>
]]></content>
      
        <categories>
            
            <category> OpenGL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 反走样 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OpenGL24：实例化]]></title>
      <url>/2017/02/06/OpenGL24%E5%AE%9E%E4%BE%8B%E5%8C%96/</url>
      <content type="html"><![CDATA[<p>假如我们有一个许多模型的场景，而这些模型的顶点数据都一样，只是进行了不同的世界空间的变换。想象一下，有一个场景中充满了草：每根草都是几个三角形组成的。最终一次渲染循环中可能有成千上万个草需要绘制。<a id="more"></a>渲染多个物体的时候，代码类似下面这样：</p>
<pre class="line-numbers language-c++"><code class="language-c++">for(GLuint i = 0; i < amount_of_models_to_draw; i++)
{
    DoSomePreparations(); //在这里绑定VAO、绑定纹理、设置uniform变量等
    glDrawArrays(GL_TRIANGLES, 0, amount_of_vertices);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>像这样多次绘制同一个模型，很快会达到一个瓶颈，这是因为我们调用的<code>glDrawArrays</code>或<code>glDrawElements</code>这样的函数（Draw Call）过多。因为在使用它们绘制之前，必须做一些准备工作，比如告诉GPU从哪个缓冲读取数据，以及在哪里 找到顶点属性，所有这些命令从CPU到GPU是需要花费时间的，会使CPU到GPU的总线变慢。</p>
<p>如果能够一次就绘制多个模型就好了，这就是实例化。</p>
<p><font size="5" color="orange">实例化</font></p>
<hr>
<p>实例化（Instancing）是一种只调用一次渲染函数却能绘制出很多物体的技术，它节省渲染物体时从CPU到GPU的通信时间，只需要做一次即可。</p>
<p>要使用实例化渲染，我们必须将<code>glDrawArrays</code>和<code>glDrawElements</code>各自改为<code>glDrawArraysInstanced</code>和<code>glDrawElementsInstanced</code>。它们相比各自之前的函数，只是多了一个参数，叫做实例数量，它设置我们打算渲染的实例的数量。</p>
<p>我们使用这个函数确实可以一次渲染很多个相同的物体，但是它们都会处在同一个位置，我们只能看到一个物体。不过GLSL为我们提供了一个内置变量<code>gl_InstanceID</code>，表示当前绘制的实例序号，初始值是0。我们可以利用这个当前实例序号，去索引一个位置数组，来把每个实例放在不同的位置上。</p>
<p>下面我们使用实例化来一次绘制100个方块。首先我们设置好方块的顶点数据：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    //方块的顶点数据
    GLfloat quadVertices[] = {
        //  ---位置---   ------颜色-------
        -0.05f,  0.05f,  1.0f, 0.0f, 0.0f,
         0.05f, -0.05f,  0.0f, 1.0f, 0.0f,
        -0.05f, -0.05f,  0.0f, 0.0f, 1.0f,

        -0.05f,  0.05f,  1.0f, 0.0f, 0.0f,
         0.05f, -0.05f,  0.0f, 1.0f, 0.0f,
         0.05f,  0.05f,  0.0f, 1.0f, 1.0f
    };
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>接下里是我们的顶点着色器：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#version 330 core
layout (location=0) in vec2 position;
layout (location=1) in vec3 color;
out vec3 fColor;

uniform vec2 offsets[100];

void main(){
    gl_Position = vec4(position + offsets[gl_InstanceID], 0.0f, 1.0f);
    fColor = color;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在顶点着色器中，我们设置了一个uniform数组，它是在主程序里被赋值的，表示了100个方块的位置。它在主程序中是这样被赋值的：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    //100个方块的位置
    vec2 quadOffsets[100];
    int index = 0;
    for (GLfloat y = -0.9; y <= 0.9; y += 0.2) {
        for (GLfloat x = -0.9; x <= 0.9; x += 0.2) {
            quadOffsets[index].x = x;
            quadOffsets[index].y = y;
            index++;
        }
    }
    ... 
    quad_shader.Use();
    for (int i = 0; i < 100; i++) {
            glUniform2f(glGetUniformLocation(quad_shader.shaderProgram, ("offsets[" + IntToString(i) + "]").c_str()), quadOffsets[i].x, quadOffsets[i].y);
    }
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中<code>IntToString</code>是我们用于把整数变成字符串的自定义函数：</p>
<pre class="line-numbers language-c++"><code class="language-c++">//把int类型转换为string类型
string IntToString(int number) {
    ostringstream outs;
    outs << number;
    return outs.str();
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>像素着色器就很简单了，显示从顶点着色器接收的颜色即可：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#version 330 core
in vec3 fColor;
out vec4 color;

void main(){
    color=vec4(fColor, 1.0f);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>最后我们使用<code>glDrawArraysInstanced</code>函数来一次绘制100个方块：</p>
<pre class="line-numbers language-c++"><code class="language-c++">        glBindVertexArray(quadVAO);
        glDrawArraysInstanced(GL_TRIANGLES, 0, 6, 100);
        glBindVertexArray(0);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>编译运行后的结果如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148634885972.png" alt=""></p>
<p><font size="5" color="orange">实例化数组</font></p>
<hr>
<p>前面我们使用了100个uniform来标识方块的不同位置，但是uniform数量是有上线的，想要绘制更多方块显然不能再使用uniform了。解决这个问题的另一个可替代方案是实例化数组（Instanced Array），它用顶点属性来存储这些方块的位置。下面我们在顶点着色器中加入方块位置属性：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#version 330 core
layout (location = 0) in vec2 position;
layout (location = 1) in vec3 color;
layout (location = 2) in vec2 offset;
out vec3 fColor;

void main(){
    gl_Position = vec4(position + offset, 0.0f, 1.0f);
    fColor = color;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们不再使用<code>gl_InstanceID</code>，而是直接使用offset属性。</p>
<p>我们需要把100个方块的位置存储到另一个顶点缓冲对象里，同时解析这些数据，告诉GPU怎么读取识别：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    //将100个方块位置存储到另一个顶点缓冲对象中
    GLuint instanceVBO;
    glGenBuffers(1, &instanceVBO);
    glBindBuffer(GL_ARRAY_BUFFER, instanceVBO);
    glBufferData(GL_ARRAY_BUFFER, sizeof(quadOffsets), &quadOffsets, GL_STATIC_DRAW);
    glEnableVertexAttribArray(2);
    glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, 2 * sizeof(GL_FLOAT), (GLvoid*)0);
    glBindBuffer(GL_ARRAY_BUFFER, 0);
    //声明顶点的2号属性是一个实例数组，每1个实例更新内容
    glVertexAttribDivisor(2, 1);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>GPU在读取顶点数据时，通常是每一个顶点就会往后面去重新读取新的顶点数据，比如<code>glVertexAttribPointer</code>函数指定步长为5个float，那么每读一个顶点，指针就会往后移动5个浮点数，再读下一个顶点。但是我们的方块位置offset明显不是给单独的一个顶点用的，而是同属一个方块的6个顶点共用一个方块位置数据offset。上面的<code>glVertexAttribDivisor(2, 1);</code>就是在告诉OpenGL每绘制一个实例（方块）才更新一次2号属性offset的内容。它的第一个参数是顶点属性号；第二个参数是属性除数（attribute divisor），默认属性除数是0，表示每个顶点更新一次属性内容，设置为1表示OpenGL会在开始渲染一个新的实例时才去更新属性内容，设置为2表示每2个实例更新内容，以此类推。把属性除数设置为非0，我们可以高效地告诉OpenGL对应的顶点属性是一个实例数组（instanced array）。</p>
<p>我们依然使用<code>glDrawArraysInstanced</code>绘制100个方块，会得到和之前一样的结果，但是速度会快很多。这次是使用实例数组实现的，它让我们可以绘制更多的相同实例，而不受uniform数量上线限制。</p>
<p>我们还可以使用<code>gl_InstanceID</code>从右上向左下缩小每个四边形：</p>
<pre class="line-numbers language-c++"><code class="language-c++">void main(){
    gl_Position = vec4(position * (gl_InstanceID / 100.0f) + offset, 0.0f, 1.0f);
    fColor = color;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>编译运行后的结果如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148634886029.png" alt=""><br>所有源码在<a href="https://github.com/Popperelay/BlogCode/tree/master/LearnOpenGL24_Instance/LearnOpenGL24_Instance_1" target="_blank" rel="external">这里</a>。</p>
<p><font size="5" color="orange">Demo：小行星带</font></p>
<hr>
<p>想象一下，在一个场景中一个很大的行星（<a href="http://learnopengl.com/data/models/planet.rar" target="_blank" rel="external">从这里下载</a>），行星周围有一圈小行星带。这样一个小行星带可能包含成千上万的石块(<a href="http://learnopengl.com/data/models/rock.rar" target="_blank" rel="external">从这里下载</a>)，对于多达数显卡来说一个一个地渲染几乎是难以完成的渲染任务。但是对于实例化渲染来说却不在话下，每个小行星都可以使用一个模型来表示，经过一个变换矩阵后他们就是一个独一无二的小行星了。</p>
<p><font size="4" color="red">老方法绘制小行星带</font><br>我们先使用老办法，一个一个地渲染出这些石块：<br>由于行星周围的陨石块在不同的位置，所以我们给这些陨石块设置不同的模型矩阵：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    //1000个陨石块的模型矩阵
    GLuint amount = 1000;
    mat4* modelMatrices = new mat4[amount];
    srand(glfwGetTime());
    GLfloat radius = 20.0f;
    GLfloat offset = 2.5f;
    for (GLuint i = 0; i < amount; i++) {
        mat4 model;
        /********平移*********/
        GLfloat angle = (GLfloat)i / amount* 360.0f;
        //获得一个在-offset到offset之间的随机数
        GLfloat displacement = (rand() % (GLint)(2 * offset * 100)) / 100.0f - offset;
        GLfloat x = sin(angle)*radius + displacement;
        displacement = (rand() % (GLint)(2 * offset * 100)) / 100.0f - offset;
        GLfloat y = displacement*0.4;
        displacement = (rand() % (GLint)(2 * offset * 100)) / 100.0f - offset;
        GLfloat z = cos(angle)*radius + displacement;
        model = translate(model, vec3(x, y, z));
        /********旋转*********/
        GLfloat rotAngle = rand() % 360;
        model = rotate(model, rotAngle, vec3(0.4f, 0.6f, 0.8f));
        /********缩放*********/
        GLfloat scaleSize = (rand() % 20) / 100.0f + 0.05f;
        model = scale(model, vec3(scaleSize));

        modelMatrices[i] = model;
    }
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这段代码看起来挺吓的，其实做的事很简单：先计算得到一个在-offset到offset之间的随机数，然后圆圈上的某个随机点以这个offset偏移为x、y、z方向偏移，得到陨石块的最终位置（在y方向上的偏移量只有0.4倍，可以让这个环带成为扁平的）。接着就是随机的旋转和缩放变换了。总共随机生成了1000个模型矩阵，每个陨石块一个，代表了陨石块在世界空间里的位置。</p>
<p>然后我们加载行星和石块的模型文件：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    Model planet("planet/planet.obj");
    Model rock("rock/rock.obj");
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>顶点着色器和像素着色器都很简单，可参考后面的源码。</p>
<p>定义的着色器类对象如下：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    shader planetAndRock_shader("planet.vertex", "planet.fragment");
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>接下里我们就可以绘制小行星和它周围的陨石了：</p>
<pre class="line-numbers language-c++"><code class="language-c++">        planetAndRock_shader.Use();
        mat4 view = mycamera.GetViewMatrix();
        mat4 projection = perspective(radians(mycamera.cameraFov), (GLfloat)WIDTH / (GLfloat)HEIGHT, 0.1f, 100.0f);
        glUniformMatrix4fv(glGetUniformLocation(planetAndRock_shader.shaderProgram, "view"), 1, GL_FALSE, value_ptr(view));
        glUniformMatrix4fv(glGetUniformLocation(planetAndRock_shader.shaderProgram, "projection"), 1, GL_FALSE, value_ptr(projection));
        //绘制小行星
        mat4 model;
        model = translate(model, vec3(0.0f, -5.0f, 0.0f));
        model = scale(model, vec3(3.0f, 3.0f, 3.0f));
        glUniformMatrix4fv(glGetUniformLocation(planetAndRock_shader.shaderProgram, "model"), 1, GL_FALSE, value_ptr(model));
        planet.Draw(planetAndRock_shader);
        //绘制小行星周边的陨石带
        for (int i = 0; i < amount; i++) {
            glUniformMatrix4fv(glGetUniformLocation(planetAndRock_shader.shaderProgram, "model"), 1, GL_FALSE, value_ptr(modelMatrices[i]));
            rock.Draw(planetAndRock_shader);
        }
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>编译运行后的结果如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148634886131.png" alt=""><br>用老办法渲染小行星带的所有源码在<a href="https://github.com/Popperelay/BlogCode/tree/master/LearnOpenGL24_Instance/LearnOpenGL24_Instance_2" target="_blank" rel="external">这里</a>。</p>
<p>这个场景包含1001次渲染函数调用，每帧渲染1001个模型。但是当我们开始增加数量的时候，很快会注意到帧数下降得很厉害，amount设置为2000的时候，场景明显出现卡顿。上升到100000时，场景已经卡得很难移动了。</p>
<p>下面我们使用实例化来渲染同样的场景。</p>
<p><font size="4" color="red">实例化绘制小行星带</font><br>由于行星不需要实例化绘制，而岩石需要。所以行星和陨石得分别使用各自的一套着色器了。</p>
<p>行星的着色器不变。陨石的顶点着色器相比行星的顶点着色器，增加了一个<code>mat4</code>类型的顶点属性，表示陨石的模型矩阵（同时不需要再使用uniform类型的模型矩阵了）：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#version 330 core
layout (location = 0) in vec3 position;
layout (location = 2) in vec2 texCoords;
layout (location = 3) in mat4 instanceMatrix;
out vec2 TexCoords;

uniform mat4 view;
uniform mat4 projection;

void main(){
    gl_Position = projection * view * instanceMatrix * vec4(position, 1.0f);
    TexCoords = texCoords;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这样一来，我们就将成千上万个陨石的模型矩阵，存储为顶点属性。可以在主程序里一次把所有陨石的模型矩阵发送给GPU，而不像在使用uniform模型矩阵时每绘制一个陨石，都需要从CPU把模型矩阵发送给GPU，所以使用实例化绘制同种物体明显会提升渲染效率。</p>
<p>除了在模型加载类里给陨石mesh绑定并解析顶点位置、法线、纹理坐标等，现在我们还需要绑定、发送数据并解析第3个顶点属性：陨石的模型矩阵<code>instanceMatrix</code>（实例数组）。不过有一点需要注意，虽然我们在顶点着色器里给<code>instanceMatrix</code>的location编号为3，但是GLSL要求顶点属性被允许的最大数据量是vec4，所以mat4类型的<code>instanceMatrix</code>和4个vec4相等，即相当于是4个顶点属性：3、4、5、6。在主程序里被赋值时，应该以这4个属性编号，分4次为<code>instanceMatrix</code>矩阵赋值：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    Model rock("rock/rock.obj");

    //将陨石位置作为实例数组，作为新的顶点属性数据，每个实例更新一次
    for (GLuint i = 0; i < rock.meshes.size(); i++) {
        GLuint VAO = rock.meshes[i].VAO;
        GLuint VBO;
        glBindVertexArray(VAO);
        glGenBuffers(1, &VBO);
        glBindBuffer(GL_ARRAY_BUFFER, VBO);
        glBufferData(GL_ARRAY_BUFFER, amount * sizeof(mat4), &modelMatrices[0], GL_STATIC_DRAW);
        glEnableVertexAttribArray(3);
        glVertexAttribPointer(3, 4, GL_FLOAT, GL_FALSE, 4 * sizeof(vec4), (GLvoid*)0);
        glEnableVertexAttribArray(4);
        glVertexAttribPointer(4, 4, GL_FLOAT, GL_FALSE, 4 * sizeof(vec4), (GLvoid*)(sizeof(vec4)));
        glEnableVertexAttribArray(5);
        glVertexAttribPointer(5, 4, GL_FLOAT, GL_FALSE, 4 * sizeof(vec4), (GLvoid*)(2 * sizeof(vec4)));
        glEnableVertexAttribArray(6);
        glVertexAttribPointer(6, 4, GL_FLOAT, GL_FALSE, 4 * sizeof(vec4), (GLvoid*)(3 * sizeof(vec4)));

        glVertexAttribDivisor(3, 1);
        glVertexAttribDivisor(4, 1);
        glVertexAttribDivisor(5, 1);
        glVertexAttribDivisor(6, 1);

        glBindVertexArray(0);
    }
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面通过4次<code>glVertexAttribDivisor</code>函数将<code>instanceMatrix</code>顶点属性设置为了实例数组。<strong>不要忘了还要把MeshLoader类的meshes成员和Mesh类的VAO成员改成公有的（public）</strong>（这样改还是很破坏模块独立性的，为了简单起见就这样吧~！）。</p>
<p>陨石的像素着色器和行星的一样，可参见文后的源码。为陨石和行星定义的着色器类对象如下：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    Model planet("planet/planet.obj");
    Model rock("rock/rock.obj");
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>然后我们可以在渲染循环里使用<code>glDrawElementsInstanced</code>函数绘制成千上万的陨石了：</p>
<pre class="line-numbers language-c++"><code class="language-c++">        //绘制小行星周边的陨石带
        rock_shader.Use();
        glUniformMatrix4fv(glGetUniformLocation(rock_shader.shaderProgram, "view"), 1, GL_FALSE, value_ptr(view));
        glUniformMatrix4fv(glGetUniformLocation(rock_shader.shaderProgram, "projection"), 1, GL_FALSE, value_ptr(projection));
        for (int i = 0; i < rock.meshes.size(); i++) {
            glBindVertexArray(rock.meshes[i].VAO);
            glBindTexture(GL_TEXTURE_2D, rock.meshes[i].textures[0].id);
            glDrawElementsInstanced(GL_TRIANGLES, rock.meshes[i].indices.size(), GL_UNSIGNED_INT, 0, amount);
            glBindVertexArray(0);
        }
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>绘制行星的代码和之前一样，不再赘述了。</p>
<p>编译运行后的结果和使用老方法绘制的结果一样，不过速度变快了。不实例渲染我们可以流畅渲染1000到1500个陨石；而使用了实例渲染，我们可以渲染100000个陨石！每个模型有576个顶点，这就是5千7百万个顶点，但是帧率几乎没有下降（有些渲染性能不太好的机器可能会下降一点）。调整为100000陨石后编译运行的结果如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148634886269.png" alt=""></p>
<p>实例渲染通常用来渲染草、草虫、粒子以及想小行星带这样的场景，基本上只要场景中有很多重复物体，使用实例渲染都会获得好处。</p>
<p>实例化绘制小行星带的所有源码在<a href="https://github.com/Popperelay/BlogCode/tree/master/LearnOpenGL24_Instance/LearnOpenGL24_Instance_3" target="_blank" rel="external">这里</a>。<br>&nbsp; </p>
<hr>
<p>参考文献：<a href="https://learnopengl.com/" target="_blank" rel="external">LearnOpenGL</a></p>
]]></content>
      
        <categories>
            
            <category> OpenGL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 实例化 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OpenGL23：几何着色器]]></title>
      <url>/2017/02/05/OpenGL23%E5%87%A0%E4%BD%95%E7%9D%80%E8%89%B2%E5%99%A8/</url>
      <content type="html"><![CDATA[<p>在顶点和片段着色器之间有一个可选的着色器，叫做几何着色器（Geometry Shader）。<br><a id="more"></a></p>
<p><font size="5" color="orange">几何着色器</font></p>
<hr>
<p>几何着色器以一个或多个基本图形的顶点作为输入，比如一个点或者三角形。几何着色器可以将这些顶点转变为完全不同的基本图形，可以生成比原来多得多的顶点，再把这些顶点发送到下一个着色器阶段。</p>
<p>我们直接来看一个几何着色器的例子：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#version 330 core
layout (points) in;
layout (line_strip, max_vertices = 2) out;

void main() {
    gl_Position = gl_in[0].gl_Position + vec4(-0.1, 0.0, 0.0, 0.0);
    EmitVertex();

    gl_Position = gl_in[0].gl_Position + vec4(0.1, 0.0, 0.0, 0.0);
    EmitVertex();

    EndPrimitive();
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在几何着色器中，我们需要声明输入的基本图形（primitive）类型，这个输入是我们从顶点着色器中接收到的。需要在in关键字前面声明一个layout标识符，括号里表示可以从一个顶点着色器接收的基本图形。可以有以下基本图形值：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148628384767.png" alt=""><br>这是我们能够给渲染函数的几乎所有的基本图形。如果我们在主程序中选择以<code>GL_TRIANGLES</code>方式绘制顶点，我们就要把这里的输入修饰符设置为triangles。括号里的数字代表对应基本图形的最少顶点数。</p>
<p>当我们需要指定几何着色器所输出的基本图形类型时，我们就在out关键字前面加一个layout标识符。和输入layout标识符一样，输出的layout标识符也可以接受以下基本图形值：</p>
<ul>
<li>points</li>
<li>line_strip</li>
<li>triangle_strip</li>
</ul>
<p>使用这三个输出修饰符，我们可以从输入的基本图形创建任何我们想要的形状。为了生成一个三角形，我们定义一个<code>triangle_strip</code>作为输出标识符，然后在其main函数里输出3个顶点，就能够输出一个三角形。同时，我们需要指定几何着色器能够输出的顶点数量的最大值（如果超出了这个数值，OpenGL就会忽略剩下的顶点），如上面的<code>line_strip, max_vertices=2</code>，表示我们将使用2个顶点输出一个line_strip。<br>【注】：</p>
<ul>
<li>line_strip就是首位相连的线条。线条是把多个点链接起来表示出一个连续的线，它最少有两个点来组成。后一个点在前一个新渲染的点后面渲染。line_strip如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148628384832.png" alt=""><br>在上面的着色器里，当然不能得到上图的线条，因为输出顶点数量的最大值被我们设置为了2，只能输出一个线段。</li>
</ul>
<p>顶点着色器的数据是通过什么传递到几何着色器的呢？GLSL为我们提供了一个内置变量<code>gl_in</code>，它的内部像这样：</p>
<pre class="line-numbers language-c++"><code class="language-c++">in gl_Vertex
{
    vec4 gl_Position;
    float gl_PointSize;
    float gl_ClipDistance[];
} gl_in[];
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>它被声明为一个借口块，表示从顶点着色器接收的顶点数组。其中就包含了与顶点着色器输出相似的位置向量<code>gl_Position</code>。要注意<code>gl_in</code>是一个数组，因为几何着色器一次接收一个基本图形的所有顶点来填充<code>gl_in</code>数组，作为它的输入。</p>
<p>使用来自顶点着色器的顶点数据，我们可以开始输出新的顶点数据了。这需要通过<code>EmitVertex</code>函数（输出一个顶点）和<code>EndPrimitive</code>函数（结束基本图形）来实现。<br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">使用几何着色器把点转化为线</font><br>这里我们用一个demo：在几个着色器里接收一些点的输入，转化为线条输出，来完整地使用一次几何着色器。</p>
<p>首先我们在顶点着色器里定义4个顶点的顶点数据：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    GLfloat pointsVertices[] = {
        //位置坐标     
        0.5f, 0.5f,
        0.5f,-0.5f,
       -0.5f,-0.5f,
       -0.5f, 0.5f,
    };

    //点的pointsVAO和数据解析
    GLuint pointsVAO, pointsVBO;
    glGenVertexArrays(1, &pointsVAO);
    glBindVertexArray(pointsVAO);
    glGenBuffers(1, &pointsVBO);
    glBindBuffer(GL_ARRAY_BUFFER, pointsVBO);
    glBufferData(GL_ARRAY_BUFFER, sizeof(pointsVertices), &pointsVertices, GL_STATIC_DRAW);
    glEnableVertexAttribArray(0);
    glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 2 * sizeof(GL_FLOAT), (GLvoid*)0);
    glBindVertexArray(0);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后是我们的几何着色器（写在points.geometry）：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#version 330 core
layout (points) in;
layout (line_strip,max_vertices=2) out;

void main(){
    gl_Position = gl_in[0].gl_Position + vec4(-0.1f,0.0f,0.0f,0.0f);
    EmitVertex();
    gl_Position = gl_in[0].gl_Position + vec4(0.1f,0.0f,0.0f,0.0f);
    EmitVertex();
    EndPrimitive();
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在该几何着色器里，我们接收的输入是点这种基本图形的顶点，输出是线条这种基本图形，同时指定输出的图形最多由两个顶点组成。在main函数里，我们先把接收到的第一个顶点向x方向移动-0.1，把得到的新顶点用<code>EmitVertex</code>函数发送出去；接着再把第一个顶点向x方向移动0.1，把得到的新顶点用<code>EmitVertex</code>函数发送出去，两个顶点发完了，我们的线条这个基本图形到此结束。注意，由于这里几何着色器的输入基本图形是点points，所以它每次得到的来自顶点着色器的输入顶点只有1个，而不是4个，这4个顶点是分4次传到几何着色器里的；如果输入基本图形是triangles，那么几何着色器每次得到的顶点个数就是3个。</p>
<p>当然，不要忘了，我们的着色器类得改改了。得把几何着色器也加进来，编译后附加到着色器程序对象上：</p>
<pre class="line-numbers language-c++"><code class="language-c++">        const GLchar* geometryShaderSource = GetShaderSourceFromFile(geometryPath);
        GLuint geometryShader;
        geometryShader = glCreateShader(GL_GEOMETRY_SHADER);
        glShaderSource(geometryShader, 1, &geometryShaderSource, NULL);
        glCompileShader(geometryShader);
        glGetShaderiv(geometryShader, GL_COMPILE_STATUS, &success);
        if (!success) {
            glGetShaderInfoLog(geometryShader, 512, NULL, infolog);
            cout << "geometry shader compilation failed" << infolog << endl;
        }
        glAttachShader(shaderProgram, geometryShader);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后在主程序里定义着色器类对象：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    //定义自定义着色器类shader的对象
    shader points_shader("points.vertex", "points.fragment", "points.geometry");
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>最后我们在渲染循环里绘制4个顶点：</p>
<pre class="line-numbers language-c++"><code class="language-c++">        points_shader.Use();
        glBindVertexArray(pointsVAO);
        glDrawArrays(GL_POINTS, 0, 4);
        glBindBuffer(GL_UNIFORM_BUFFER, 0);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>编译运行后的结果如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148628384876.png" alt=""><br>还是很神奇的！因为我们渲染时是用的<code>GL_POINTS</code>，但是却能够根据这些点绘制出几个线条，这都是几何着色器的功劳。<br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">使用几何着色器把点画成房子</font><br>绘制点和线好像挺枯燥的，所以我们将在每个点上使用几何着色器绘制一个房子。它是由几个三角形构成的，如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148628384921.png" alt=""><br>在OpenGL里这样挨在一起的三角形，用trangle_strip绘制起来更搞笑，因为它所需要的顶点更少。所以我们把几何着色器里的输出基本图形设置为<code>triangle_strip</code>。这个房子总共有5个顶点，使用<code>triangle_strip</code>时，每3个毗邻的顶点都会构成一个三角形，所以得到这些三角形：（1,2,3）、（2,3,4）、（3,4,5）。其实有N个顶点就能得到N-2个三角形。注意，上图的房子里只有中间的蓝色点才是来自顶点着色器的输入，而房子的5个顶点都是根据这个蓝色点，在几何着色器里生成的：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#version 330 core
layout (points) in;
layout (triangle_strip,max_vertices=5) out;

void main(){
    gl_Position = gl_in[0].gl_Position + vec4(-0.2f, -0.2f, 0.0f, 0.0f);// 1:左下角
    EmitVertex();
    gl_Position = gl_in[0].gl_Position + vec4( 0.2f, -0.2f, 0.0f, 0.0f);// 2:右下角
    EmitVertex();
    gl_Position = gl_in[0].gl_Position + vec4(-0.2f,  0.2f, 0.0f, 0.0f);// 3:左上
    EmitVertex();
    gl_Position = gl_in[0].gl_Position + vec4( 0.2f,  0.2f, 0.0f, 0.0f);// 4:右上
    EmitVertex();
    gl_Position = gl_in[0].gl_Position + vec4( 0.0f,  0.4f, 0.0f, 0.0f);// 5:屋顶
    EmitVertex();
    EndPrimitive();
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>因为要从一个输入顶点变成5个顶点连线构成的房子，所以几何着色器的输出需要加上标识符<code>layout (triangle_strip, max_vertices = 5) out;</code>。</p>
<p>顶点着色器如下：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#version 330 core
layout (location=0) in vec2 position;

void main(){
    gl_Position = vec4(position, 0.0f, 1.0f);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>像素着色器如下：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#version 330 core
out vec4 color;

void main(){
    color= vec4(1.0f, 0.0f, 0.0f, 1.0f);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>编译运行后的结果如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148628384965.png" alt=""><br>这4个房子都一个颜色，现在我们让每个房子都有不同的颜色。我们给每个顶点再加上一个颜色属性，同时更新对顶点属性数据的解析：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    GLfloat pointsVertices[] = {
        //位置坐标   //颜色
        0.5f, 0.5f,  1.0f, 0.0f, 0.0f,
        0.5f,-0.5f,  0.0f, 1.0f, 0.0f,
       -0.5f,-0.5f,  0.0f, 0.0f, 1.0f,
       -0.5f, 0.5f,  1.0f, 1.0f, 0.0f
    };

    //点的pointsVAO和数据解析
    GLuint pointsVAO, pointsVBO;
    glGenVertexArrays(1, &pointsVAO);
    glBindVertexArray(pointsVAO);
    glGenBuffers(1, &pointsVBO);
    glBindBuffer(GL_ARRAY_BUFFER, pointsVBO);
    glBufferData(GL_ARRAY_BUFFER, sizeof(pointsVertices), &pointsVertices, GL_STATIC_DRAW);
    glEnableVertexAttribArray(0);
    glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 5 * sizeof(GL_FLOAT), (GLvoid*)0);
    glEnableVertexAttribArray(1);
    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 5 * sizeof(GL_FLOAT), (GLvoid*)(2 * sizeof(GL_FLOAT)));
    glBindVertexArray(0);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>接着在顶点着色器中，增加输入变量来接收这个颜色属性，并且我们使用接口块来把顶点颜色发送给几何着色器：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#version 330 core
layout (location=0) in vec2 position;
layout (location=1) in vec3 color;

out VS_OUT{
    vec3 color;
} vs_out;

void main(){
    gl_Position = vec4(position, 0.0f, 1.0f);
    vs_out.color = color;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当然也可以不使用接口块，直接使用<code>out vec3 color</code>也是可以的。</p>
<p>接下里需要在几何着色器中声明同样的接口块（块名相同，块变量可以不同名）：</p>
<pre class="line-numbers language-c++"><code class="language-c++">in VS_OUT{
    vec3 color;
} gs_in[];
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>注意这里的块变量是一个数组，这是因为几何着色器一次接收的是组成基本图形的所有顶点，可能会有多个顶点被一次传到几何着色器里（现在我们是<code>layout (points) in;</code>，只有一个顶点被传过来，即<code>gs_in[0]</code>）。</p>
<p>我们最后需要把颜色输出给像素着色器，所以还需要在几何着色器里声明一个输出颜色向量：</p>
<pre class="line-numbers language-c++"><code class="language-c++">out vec3 fcolor;
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>接下来我们在几何着色器的main函数里，让这个输出颜色向量等于来自顶点着色器的颜色向量：</p>
<pre class="line-numbers language-c++"><code class="language-c++">void main(){
    fcolor = gs_in[0].color;
    gl_Position = gl_in[0].gl_Position + vec4(-0.2f, -0.2f, 0.0f, 0.0f);// 1:左下角
    EmitVertex();
    gl_Position = gl_in[0].gl_Position + vec4( 0.2f, -0.2f, 0.0f, 0.0f);// 2:右下角
    EmitVertex();
    gl_Position = gl_in[0].gl_Position + vec4(-0.2f,  0.2f, 0.0f, 0.0f);// 3:左上
    EmitVertex();
    gl_Position = gl_in[0].gl_Position + vec4( 0.2f,  0.2f, 0.0f, 0.0f);// 4:右上
    EmitVertex();
    gl_Position = gl_in[0].gl_Position + vec4( 0.0f,  0.4f, 0.0f, 0.0f);// 5:屋顶
    EmitVertex();
    EndPrimitive();
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>由于房子的5个顶点都是相同的颜色，都等于对应的顶点着色器的输出颜色，所以只需要做一次<code>fcolor = gs_in[0].color;</code>即可，后面几何着色器使用<code>EmitVertex</code>函数发送顶点时，都会包含最新的out变量<code>fcolor</code>的值。</p>
<p>在像素着色器里，片段颜色应该是等于接收到的顶点颜色了，房子内部的点就由像素着色器自己去插值了：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#version 330 core
in vec3 fcolor;
out vec4 color;

void main(){
    color= vec4(fcolor, 1.0f);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>编译运行后的结果如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148628385008.png" alt=""><br>如果我们还想给房子的屋顶上加点白色，就像落了雪一样，其实也就是说房子的5个顶点不是同一个颜色了，屋顶顶点变成了白色。我们只需要做如下改变即可：</p>
<pre class="line-numbers language-c++"><code class="language-c++">void main(){
    fcolor = gs_in[0].color;
    gl_Position = gl_in[0].gl_Position + vec4(-0.2f, -0.2f, 0.0f, 0.0f);// 1:左下角
    EmitVertex();
    gl_Position = gl_in[0].gl_Position + vec4( 0.2f, -0.2f, 0.0f, 0.0f);// 2:右下角
    EmitVertex();
    gl_Position = gl_in[0].gl_Position + vec4(-0.2f,  0.2f, 0.0f, 0.0f);// 3:左上
    EmitVertex();
    gl_Position = gl_in[0].gl_Position + vec4( 0.2f,  0.2f, 0.0f, 0.0f);// 4:右上
    EmitVertex();
    gl_Position = gl_in[0].gl_Position + vec4( 0.0f,  0.4f, 0.0f, 0.0f);// 5:屋顶
    fcolor = vec3(1.0f, 1.0f, 1.0f);
    EmitVertex();
    EndPrimitive();
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>让屋顶顶点的输出颜色等于白色即可。</p>
<p>编译运行后的结果如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148628385054.png" alt=""><br>所有源码在<a href="https://github.com/Popperelay/BlogCode/tree/master/LearnOpenGL23_GeometryShader/LearnOpenGL23_GeometryShader_1" target="_blank" rel="external">这里</a>。</p>
<p>可以看到，使用几何着色器，可以使用最简单的基本图形就能获得漂亮的新玩意。因为这些形状是在GPU这种超快硬件上动态生成的，这要比使用顶点缓冲自己定义这些形状更为高效。几何缓冲在简单的经常被重复的形状（比如体素的世界和室外的草地）上，是一种非常强大的优化工具。</p>
<p><font size="5" color="orange">Demo：爆破物体</font></p>
<hr>
<p>下面我们使用几何着色器来实现纳米铠甲的爆破效果。其实就是在几何着色器里让每个三角形面片沿着法线向外移动了一段距离，好像纳米铠甲爆炸了一样。也就是在几何着色器里，三角形的每个顶点沿着法线向外移动了一段距离。</p>
<p>这时的几何着色器接收的基本图形应该是三角形，输出的应该也是三角形。所以：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#version 330 core
layout (triangles) in;
layout (triangle_strip, max_vertices = 3) out;
...
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>由于我们要使用纳米铠甲这个模型，我们需要从顶点着色器里接收顶点的法线、世界坐标、纹理坐标等属性，在几何着色器里处理完毕后再把它们输出给像素着色器（可以参考<a href="http://popperelay.com/2017/01/12/OpenGL14%E6%A8%A1%E5%9E%8B%E5%8A%A0%E8%BD%BD/" target="_blank" rel="external">《OpenGL14：模型加载》</a>） 一文中的顶点着色器和像素着色器）。所以在几何着色器里我们用接口块VS_OUT来接收来自顶点着色器的顶点属性，并且设置对应的输出变量：</p>
<pre class="line-numbers language-c++"><code class="language-c++">in VS_OUT{
    vec3 Normal;
    vec3 positionInWorld;
    vec2 TexCoords;
} gs_in[];
out vec3 Normal;
out vec3 positionInWorld;
out vec2 TexCoords;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>由于三角形的每个顶点需要沿着三角形的法线，向外移动一段距离，所以我们需要先算出三角形的法线，我们把它写在<code>GetNormal</code>中：</p>
<pre class="line-numbers language-c++"><code class="language-c++">vec3 GetNormal(){
    vec3 a = vec3(gl_in[0].gl_Position) - vec3(gl_in[1].gl_Position);
    vec3 b = vec3(gl_in[1].gl_Position) - vec3(gl_in[2].gl_Position);
    return normalize(cross(a, b));
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后我们用<code>explode</code>函数来计算顶点沿着法线向外移动一段距离后的位置：</p>
<pre class="line-numbers language-c++"><code class="language-c++">vec4 explode(vec4 position, vec3 normal){
    float magnitude = 2.0f;
    vec3 direction = normal * magnitude * ((sin(time) + 1.0f)/2.0f);
    return position + vec4(direction, 0.0f);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>它接收两个参数：顶点原来的位置和法线向量。上面我们乘了一个时间变量time，来实现动态的爆炸效果。这个time变量是个uniform变量，需要从主程序给它赋值：</p>
<pre class="line-numbers language-c++"><code class="language-c++">uniform float time;
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>在几何着色器的main函数里，只需要改变三个顶点的位置为爆炸后的位置，顶点的法线、世界坐标、纹理坐标等原样输出即可。需要在main函数里发送3次顶点：</p>
<pre class="line-numbers language-c++"><code class="language-c++">void main(){
    vec3 normal = GetNormal();

    gl_Position = explode(gl_in[0].gl_Position, normal);
    Normal = gs_in[0].Normal;
    positionInWorld = gs_in[0].positionInWorld;
    TexCoords = gs_in[0].TexCoords;
    EmitVertex();

    gl_Position = explode(gl_in[1].gl_Position, normal);
    Normal = gs_in[1].Normal;
    positionInWorld = gs_in[1].positionInWorld;
    TexCoords = gs_in[1].TexCoords;
    EmitVertex();

    gl_Position = explode(gl_in[2].gl_Position, normal);
    Normal = gs_in[2].Normal;
    positionInWorld = gs_in[2].positionInWorld;
    TexCoords = gs_in[2].TexCoords;
    EmitVertex();

    EndPrimitive();
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>不要忘了在主程序中对time变量赋值，而且顶点着色器也得作出相应调整（改成接口块）。编译运行后的结果如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148628385114.png" alt=""><br>全部源码在<a href="https://github.com/Popperelay/BlogCode/tree/master/LearnOpenGL23_GeometryShader/LearnOpenGL23_GeometryShader_2" target="_blank" rel="external">这里</a>。</p>
<p><font size="5" color="orange">显示法向量</font></p>
<hr>
<p>下面我们将使用几何着色器来显示纳米铠甲每个顶点的法线向量。当编写光照着色器的时候，经常会遇到奇怪的视频输出问题，很难分辨是哪里出了问题。通常是因为不正确地加载了顶点数据，以及给它们指定了不合理的顶点属性，或者是在着色器中不合法的管理，导致产生了不正确的法线向量。我们希望可以用某种方式检测出法线向量是否正确，而我们这里的把法向量显示出来就是一种不错的方法。</p>
<p>显示法线向量的思路：先不使用几何着色器，正常绘制物体；然后使用我们用于显示法线向量的几何着色器，再绘制一次物体，这次只绘制物体上顶点的法线，不会绘制物体的面片。看起来就像这样：</p>
<pre class="line-numbers language-c++"><code class="language-c++">lightObject.Use();
mymodel.Draw(lightObject);
normalDisplay.Use();
mymodel.Draw(normalDisplay);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们先写一个显示法线的顶点着色器（写在normalDisplay.vertex中）：</p>
<pre class="line-numbers language-c++"><code class="language-c++">//顶点着色器
#version 330 core
layout (location=0) in vec3 position;  //顶点位置属性的位置值为0
layout (location=1) in vec3 normal;    //顶点法线属性的位置值为1
out    VS_OUT{
    vec3 Normal;
} vs_out;

//模型矩阵
uniform mat4 model;
//观察矩阵
uniform mat4 view;
//投影矩阵
uniform mat4 projection;
void main(){
    gl_Position = projection * view * model * vec4(position,1.0f);
    vs_out.Normal = normalize(vec3(projection * view * vec4(mat3(transpose(inverse(model))) * normal, 1.0f)));
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注意，这里的法线向量我们将它变换到裁剪空间了，因为接下来显示法线向量也是在裁剪空间中进行的。而在对模型的光照处理时，这些法线是在世界空间下，不会乘以proection和view，因为点光源等等计算向量夹角是在世界坐标系下进行的。</p>
<p>接着我们在几何着色器里接收三角形基本图元，但是输出的是线条。在main函数里，三角形的每个顶点和它法线方向上指定距离的某个点，构成一个线段基本图元。这样进行3次<code>EndPrimitive()</code>就能产生3条线段，输出的最大顶点数就是6（写在normalDisplay.geometry中）：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#version 330 core
layout (triangles) in;
layout (line_strip, max_vertices = 6) out;

in VS_OUT {
    vec3 Normal;
} gs_in[];

const float MAGNITUDE = 0.1f;

void main(){
    gl_Position = gl_in[0].gl_Position;
    EmitVertex();
    gl_Position = gl_in[0].gl_Position + vec4(gs_in[0].Normal, 0.0f) * MAGNITUDE;
    EmitVertex();
    EndPrimitive();

    gl_Position = gl_in[1].gl_Position;
    EmitVertex();
    gl_Position = gl_in[1].gl_Position + vec4(gs_in[1].Normal, 0.0f) * MAGNITUDE;
    EmitVertex();
    EndPrimitive();

    gl_Position = gl_in[2].gl_Position;
    EmitVertex();
    gl_Position = gl_in[2].gl_Position + vec4(gs_in[2].Normal, 0.0f) * MAGNITUDE;
    EmitVertex();
    EndPrimitive();
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>MAGNITUDE</code>是为了控制绘制的法线向量的长度。</p>
<p>至于像素着色器就很简单了，让这些法线线段显示一个颜色即可（写在normalDisplay.fragment中）：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#version 330 core
out vec4 color;

void main(){
    color = vec4(1.0f, 1.0f, 0.0f, 1.0f);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后在主程序里，两次使用着色器类对象，一次用于绘制模型物体，接着另一次用于绘制模型顶点的法线向量：</p>
<pre class="line-numbers language-c++"><code class="language-c++">lightObject.Use();
...
mymodel.Draw(lightObject);
...
normalDisplay.Use();
...
mymodel.Draw(normalDisplay);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>编译运行后的结果如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148628385163.png" alt=""></p>
<p>所有源码在<a href="https://github.com/Popperelay/BlogCode/tree/master/LearnOpenGL23_GeometryShader/LearnOpenGL23_GeometryShader_3" target="_blank" rel="external">这里</a>。<br>&nbsp; </p>
<hr>
<p>参考文献：<a href="https://learnopengl.com/" target="_blank" rel="external">LearnOpenGL</a></p>
]]></content>
      
        <categories>
            
            <category> OpenGL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 几何着色器 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OpenGL22：高级GLSL]]></title>
      <url>/2017/01/25/OpenGL22%E9%AB%98%E7%BA%A7GLSL/</url>
      <content type="html"><![CDATA[<p>本文将会讨论一些GLSL内置变量、接口块和uniform缓冲对象。<br><a id="more"></a><br>&nbsp; </p>
<hr>
<p><font size="5" color="orange">GLSL的内置变量</font><br>GLSL有几个以<strong>gl_</strong>为前缀的变量，我们可以用它们来实现对着色器的输入输出数据。其中两个我们已经接触过：<code>gl_Position</code>和<code>gl_FragCoord</code>，前一个是顶点着色器的输出向量，后一个是像素着色器的变量。接下里我们再多了解几个内置变量。</p>
<p><font size="4" color="red">顶点着色器的内置变量</font><br>我么已经了解到<code>gl_Position</code>是顶点着色器裁剪空间输出的位置向量，如果想让窗口上渲染出东西，必须使用它，否则我们什么都看不到。除此之外，还有几个顶点着色器的内置变量：</p>
<p><font size="3" color="blue"><strong>内置变量gl_PointSize</strong></font><br>渲染的基本图形不仅可以是我们常用的<code>GL_TRIANGLES</code>，还可以是<code>GL_POINTS</code>，顾名思义，它是渲染每一个顶点。除了在主程序中可以使用<code>glPointSize</code>函数来设置这个点的大小以外，我们还可以在顶点着色器里通过内置输出变量<code>gl_Pointsize</code>来设置点的大小。</p>
<p> <code>gl_Pointsize</code>是一个float变量。要使用它我们必须要先开启OpenGL的<code>GL_PROGRAM_POINT_SIZE</code>，因为在着色器中影响点的大小默认是关闭的：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    glEnable(GL_PROGRAM_POINT_SIZE);
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>现在我们来画几个点，着色器都很简单：<br>点的顶点着色器（写在points.vertex中）：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#version 330 core
layout (location=0) in vec3 position;

 void main(){
    gl_Position = vec4(position, 1.0f);
    gl_PointSize = position.z * 10;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里我们让内置变量<code>gl_PointSize</code>（也就是顶点大小）等于顶点z坐标的10倍。</p>
<p> 点的像素着色器（points.fragment）：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#version 330 core
out vec4 color;

 void main(){
    color= vec4(1.0f, 0.0f, 0.0f, 1.0f);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>完整源码<a href="https://github.com/Popperelay/BlogCode/tree/master/LearnOpenGL22_AdvancedGLSL/LearnOpenGL22_AdvancedGLSL_1" target="_blank" rel="external">在这里</a>。</p>
<p>编译运行后的结果如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148535051623.png" alt=""><br>可以看到z值越大的点越大。想象一下，每个顶点表示出来的点的大小不同，如果用在像粒子生成之类的技术里会挺有意思的。</p>
<p><font size="3" color="blue"><strong>内置变量gl_VertexID</strong></font><br>顶点着色器给我们提供了一个有趣的输入变量<code>gl_VertexID</code>，它是只读的。</p>
<p> <code>gl_VertexID</code>是个整型变量，它存储着我们绘制的当前顶点的ID。当进行索引渲染（indexed rendering，使用<code>glDrawElements</code>函数绘制）时，这个变量保存着当前绘制顶点的索引；如果用的不是索引绘制（使用<code>glDrawArrays</code>函数绘制），这个变量保存的是从渲染开始直到当前处理的这个顶点（当前顶点）的编号。</p>
<p><font size="4" color="red">片段着色器的内置变量</font></p>
<p><font size="3" color="blue"><strong>内置变量gl_FragCoord</strong></font><br>在<a href="http://popperelay.com/2017/01/14/OpenGL15%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95/" target="_blank" rel="external">《OpenGL15：深度测试》</a>中，我们已经用过<code>gl_FragCoord</code>了，因为它的z值表示片段的深度值。</p>
<p> <code>gl_FragCoord</code>的x和y元素是当前片段的窗口空间坐标，它的起始处（原点）是窗口的左下角。</p>
<p> <code>gl_FragCoord</code>变量的一个常用方式是与一个不同的片段计算出来的视频输出进行对比，通常在技术演示中常见。比如我们可以把物体分为两部分，某个x值左侧渲染一个输出，右侧渲染另一个输出。如下面的像素着色器：</p>
<pre class="line-numbers language-c++"><code class="language-c++">void main(){
    if(gl_FragCoord.x < 400){
        color = vec4(1.0f, 0.0f, 0.0f, 1.0f);
    }
    else{
        color = vec4(0.0f, 1.0f, 0.0f, 1.0f);
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们用这个像素着色器代码绘制一个立方体，源码不再赘述了，之前的文章里有很多，编译运行后的结果如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148535051683.png" alt=""></p>
<p><font size="3" color="blue"><strong>内置变量gl_FrontFacing</strong></font><br>像素着色器另一个有意思的输入变量是<code>gl_FrontFacing</code>。在<a href="http://popperelay.com/2017/01/18/OpenGL18%E8%83%8C%E9%9D%A2%E5%89%94%E9%99%A4/" target="_blank" rel="external">《OpenGL18：背面剔除》</a>中，我们知道OpenGL可以根据顶点绘制顺序弄清楚一个面是正面还是背面。如果我们不使用面剔除，那么<code>gl_FrontFacing</code>变量能告诉我们当前片段是某个正面的一部分还是背面的一部分。</p>
<p> <code>gl_FrontFacing</code>变量是一个布尔值，如果当前片段时正面的一部分那么就是true，否则就是false。这样我们可以创建一个立方体，里面和外面使用不同的纹理：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#version 330 core
out vec4 color;
in vec2 TexCoords;

 uniform sampler2D frontTexture;
uniform sampler2D backTexture;

 void main()
{
    if(gl_FrontFacing)
        color = texture(frontTexture, TexCoords);
    else
        color = texture(backTexture, TexCoords);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>编译运行后，如果我们移动摄像机到箱子的一角里，就能看到里面和外面使用的是不同的纹理：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148535051745.png" alt=""><br>注意不要开启面剔除，否则摄像机进入箱子后，不会看到箱子的任何部分。</p>
<p><font size="3" color="blue"><strong>内置变量gl_FragDepth</strong></font><br>输入变量<code>gl_FragCoord</code>让我们可以读得当前片段的窗口空间坐标和深度值。但是GLSL给我们提供了一个叫做<code>gl_FragDepth</code>的变量，我们可以用它在着色器中设置像素的深度值（片段的窗口空间坐标是没法改变的）：</p>
<pre class="line-numbers language-c++"><code class="language-c++">gl_FragDepth = 0.0f; //现在片段的深度值被设为0
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>如果着色器中没有显式设置<code>gl_FragDepth</code>的值，它就会自动采样<code>gl_FragCoord.z</code>的值。</p>
<p> 我们自己设置深度值有一个显著缺点，因为只要我们在像素着色器中对<code>gl_FragDepth</code>写入什么，OpenGL就会关闭所有的前置深度测试，因为在我们运行片段着色器之前，OpenGL搞不清楚像素的深度值，因为片段着色器可能会完全改变这个深度值。因此需要考虑到<code>gl_FragDepth</code>写入所带来的性能的下降。</p>
<p> 然而从OpenGL4.2起，我们仍然可以对二者进行一定的调和，这需要在片段着色器的顶部使用深度条件（depth condition）来重新声明<code>gl_FragDepth</code>：</p>
<pre class="line-numbers language-c++"><code class="language-c++">layout (depth_<condition>) out float gl_FragDepth;
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>condition可以使用下面的值：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148535051792.png" alt=""><br>下面是一个在像素着色器里增加深度值得例子，不过仍可开启前置深度测试：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#version 330 core
layout (depth_greater) out float gl_FragDepth;
out vec4 color;

 void main()
{
    color = vec4(1.0f);
    gl_FragDepth = gl_FragCoord.z + 0.1f;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>一定要记住这个功能只能在OpenGL4.2以上版本才有。<br>&nbsp; </p>
<hr>
<p><font size="5" color="orange">接口块</font><br>到目前为止，每次我们打算从顶点着色器向片段着色器发送数据，我们都会声明一个相互匹配的输出/输入变量。但是随着应用变得越来越大，我们也许会打算发送的不仅仅是变量，最好还可以包括数组和结构体等。</p>
<p>为了帮助我们组织这些变量，GLSL为我们提供了一些叫做接口块（Interface Blocks）的东西，好让我们能够组织这些变量。声明接口块和声明结构体比较像，只是结构使用struct关键字，而接口块使用in和out关键字来定义一个输入或输出块。示例如下：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#version 330 core
layout (location = 0) in vec3 position;
layout (location = 1) in vec2 texCoords;

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;

out VS_OUT
{
    vec2 TexCoords;
} vs_out;

void main()
{
    gl_Position = projection * view * model * vec4(position, 1.0f);
    vs_out.TexCoords = texCoords;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们声明了一个叫做vs_out的接口块，它把我们需要发送给下个阶段着色器的所有输出变量组合起来。</p>
<p>然后我们还需要在像素着色器中声明一个输入接口块，快名应该是一样的，但是实例名可以不一样：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#version 330 core
out vec4 color;

in VS_OUT
{
    vec2 TexCoords;
} fs_in;

uniform sampler2D texture;

void main()
{
    color = texture(texture, fs_in.TexCoords);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果两个接口块的快名一致，它们对应的输入和输出就会匹配起来。<br>&nbsp; </p>
<hr>
<p><font size="5" color="orange">Uniform缓冲对象UBO</font><br>在之前的文章中，我们肯定有感受：箱子、地面等等不同的物体，它们使用不同的着色器，但是每种着色器里都有相同的uniform变量：观察矩阵view和投影矩阵projection。我们之前的做法是为每种着色器都设置这些uniform变量的值。既然对于每个着色器来说它们都是一样的，那为何还多次设置它们呢？</p>
<p>OpenGL为我们提供了一个叫做uniform缓冲对象（uniform buffer object）的工具，使我们能够声明一系列的全局uniform变量，它们会在几个着色器程序中保持一致。当使用uniform缓冲对象时相关的uniform就只需设置一次了。但是我们还是需要为每个着色器手动设置uniform块，只是不需要在主程序里为这些uniform变量重复赋值了。</p>
<p>如何在多个着色器之间简洁地共享变量，GLSL中可以通过uniform buffer来实现。实现思路是：在多个着色器中定义相同的uniform块（就是上面的接口块，但是使用uniform关键词），然后将这些uniform块绑定到对应的uniform缓冲对象ubo，而uniform缓冲对象中实际存储这些需要共享的变量。着色器中的uniform块和主程序中的uniform缓冲对象，是通过OpenGL的绑定点（binding points）连接起来的，它们的关系如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148535051835.png" alt=""><br>使用时，每个shader中定义的uniform块有一个索引，通过这个索引连接到OpenGL的绑定点x；而主程序中创建uniform缓冲对象，传递数据后，将这个UBO绑定到对应的绑定点x，这样shader中的uniform块就和主程序中的UBO连续起来了，我们在主程序中操作UBO的数据，就能够在不同着色器之间共享了。例如上图中，着色器A和着色器B中的Matrices的索引都指向绑定点0，他们共享主程序的uboMatrices这个UBO的数据。同时着色器A的Lights和着色器B的Data，分别指向不同的UBO。</p>
<p>下面是一个使用uniform块的着色器例子：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#version 330 core
layout (location = 0) in vec3 position;

layout (std140) uniform Matrices
{
    mat4 projection;
    mat4 view;
};
uniform mat4 model;

void main()
{
    gl_Position = projection * view * model * vec4(position, 1.0);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里我们声明了一个叫做Matrices的uniform块，它存储两个4x4矩阵。在uniform块中的变量可以直接获取，而不用使用块名作为前缀。</p>
<p>但是上面的<code>layout (std140)</code>是什么意思呢？它的意思是说为当前的uniform块的内容使用特定的内存布局，这个声明实际上就是在设置uniform块布局（uniform block layout）。<br>&nbsp; </p>
<hr>
<p><font size="5" color="orange">Uniform块布局</font><br>在主程序中对UBO的实现（或者说数据填充），依赖于着色器中uniform块的内存布局。uniform块的内存布局有四种形式：shared、packed、std140、std430（GLSL4.3以上才支持），默认是shared共享内存布局。 </p>
<p>我们先来了解一下字节对齐的概念：</p>
<p><font size="4" color="red">字节对齐的概念</font><br>字节对齐的一个经典案例就是C语言中的结构体变量，例如下面的结构体：</p>
<pre class="line-numbers language-c++"><code class="language-c++">struct StructExample {
    char c;  
    int i;  
    short s; 
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>估计他占用内存大小是多少字节？如果int占用4字节，short占用2字节，char占用1字节，那么整体大小等于1+4+2=7字节吗？</p>
<p>答案是否定的。在Windows平台上测试的结果是占用12个字节。这是因为结构体里的变量存在字节对齐（或者叫字节补齐）的概念。实际上上述结构体的内存布局为：</p>
<pre class="line-numbers language-c++"><code class="language-c++">struct StructExample {
    char c;  // 0 bytes offset, 3 bytes padding
    int i;   // 4 bytes offset
    short s; // 8 bytes offset, 2 bytes padding
}; // End of 12 bytes
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>内存布局如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148535051878.png" alt=""><br>字节对齐的一个重要原因是为了使机器访问更迅速。例如在32位字长的机器中，每次会读取4个字节数据，所以将字节对齐到0x0000、0x0004、0x0008、0x000C等，将使读取更加迅速。否则，如果上面的结构体里，字符c后面不填充三个字节而直接紧邻int，那么int将会跨越两个字长（0x0000和0x0004，32位机中4个字节为一个字），就需要两次读取操作，影响效率。还有一些更详细的原因，可参考<a href="http://stackoverflow.com/questions/381244/purpose-of-memory-alignment" target="_blank" rel="external">SO Purpose of memory alignment</a>。</p>
<p>关于字节对齐，需要记住以下几个要点：</p>
<ul>
<li>每个基本变量的起始位置，一定是自己长度的整数倍（对齐）</li>
<li>对齐后的总长度必须是最长元素长度的整数倍，不够的话用额外的字节补齐</li>
<li>复杂类型（结构体、联合等）以其中的最长成员的长度对齐。</li>
</ul>
<p>上面的结构体中，int变量的起始地址应该是自身长度4的整数倍，为了int类型对齐，需要在char后面填充3个字节。这样一来，char、int、short总共占了10字节，但是总长度需要是最长元素int长度4的整数倍，所以需要在末尾再补上2个字节，让总长度达到12字节。</p>
<p><font size="4" color="red">std140的字节对齐</font><br>std140内存布局同样存在字节对齐的概念，可以参考<a href="https://www.opengl.org/registry/specs/ARB/uniform_buffer_object.txt" target="_blank" rel="external">官方文档</a>获取完整描述。常用标量int、float、bool等要求4字节对齐。4字节也被作为一个基础值N，下面是几个常用的类型的字节对齐要求：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148535051929.png" alt=""><br>例如一个复杂的uniform块定义如下：</p>
<pre class="line-numbers language-c++"><code class="language-c++">layout (std140) uniform ExampleBlock
{
                     // base alignment ----------  // aligned offset
    float value;     // 4                          // 0
    vec3 vector;     // 16                         // 16 (必须是16的倍数，因此 4->16)
    mat4 matrix;     // 16                         // 32  (第 0 行)
                     // 16                         // 48  (第 1 行)
                     // 16                         // 64  (第 2 行)
                     // 16                         // 80  (第 3 行)
    float values[3]; // 16 (数组中的标量与vec4相同)  //96 (values[0])
                     // 16                         // 112 (values[1])
                     // 16                         // 128 (values[2])
    bool boolean;    // 4                          // 144
    int integer;     // 4                          // 148
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>根据std140布局规则，使用计算出来的偏移量，我们可以用<code>glBufferSubData</code>这样的函数来传递数据并填充缓冲。虽然不是很高效，但std140布局可以保证在每个程序中声明的这个uniform块的布局保持一致。<br>&nbsp; </p>
<hr>
<p><font size="5" color="orange">使用uniform缓冲</font><br>首先我们需要使用<code>glGenBuffers</code>函数创建一个uniform缓冲对象，然后绑定到<code>GL_UNIFORM_BUFFER</code>目标上，接着需要调用<code>glBufferData</code>函数来给它分配足够的内存空间：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    //创建uniform缓冲对象
    GLuint ubo;
    glGenBuffers(1, &ubo);
    glBindBuffer(GL_UNIFORM_BUFFER, ubo);
    glBufferData(GL_UNIFORM_BUFFER, 150, NULL, GL_STATIC_DRAW);
    glBindBuffer(GL_UNIFORM_BUFFER, 0);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>以后当我们打算往缓冲中更新或插入数据，我们就绑定一下该缓冲对象<code>uboExampleBlock</code>，并使用<code>glBufferSubData</code>来更新它的内存。</p>
<p>我们可以使用<code>glUniformBlockBinding</code>函数来把uniform块绑定到一个指定的绑定点上。在此之前，我们需要先用<code>glGetUniformBlockIndex</code>函数来获取指定着色器中uniform块的索引位置：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    //把uniform块绑定到绑定点2
    GLuint uniform_index = glGetUniformBlockIndex(cube_shader.shaderProgram, "Matrices");
    glUniformBlockBinding(cube_shader.shaderProgram, uniform_index, 2);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><code>glGetUniformBlockIndex</code>的第一个参数是着色器程序对象，第二个参数就是该着色器里的块名称。<code>glUniformBlockBinding</code>函数的第一个参数也是着色器程序对象，第二个参数是uniform块索引，第三个参数是绑定点。注意，我们必须对每个着色器的uniform块都要做这件事。</p>
<p>【注】：</p>
<ul>
<li>从OpenGL4.2起，也可以在着色器中通过添加另一个局部标识符来存储一个uniform块的绑定点，就不用我们调用<code>glGetUniformBlockIndex</code>和<code>glUniformBlockBinding</code>了。如下所示：<pre class="line-numbers language-c++"><code class="language-c++">layout(std140, binding = 2) uniform Lights { ... };
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
添加一个binding标识符就能指定了uniform块的绑定点了。</li>
</ul>
<p>然后我们还需要把uniform缓冲对象绑定到同样的绑定点上，可以使用<code>glBindBufferBase</code>函数或<code>glBindBufferRange</code>函数来完成：</p>
<pre class="line-numbers language-c++"><code class="language-c++">glBindBufferBase(GL_UNIFORM_BUFFER, 2, uboExampleBlock);
// 或者
glBindBufferRange(GL_UNIFORM_BUFFER, 2, uboExampleBlock, 0, 150);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>函数<code>glBindBufferBase</code>的第一个参数是绑定目标，这里当然是uniform缓冲；第二个参数是绑定点，第三个参数就是uniform缓冲对象。函数<code>glBindBufferRange</code>多了两个参数，可以指定把一定范围内的uniform缓冲绑定到一个绑定点上。所以使用<code>glBindBufferRange</code>函数，能够将让一个uniform缓冲对象对应多个uniform块。</p>
<p>最后我们可以开始想uniform缓冲中添加数据了。可以使用<code>glBufferSubData</code>函数来实现。例如为了更新之前那个uniform块里的boolean变量，我们可以使用下面的代码：</p>
<pre class="line-numbers language-c++"><code class="language-c++">glBindBuffer(GL_UNIFORM_BUFFER, uboExampleBlock);
GLint b = true; // GLSL中的布尔值是4个字节，因此我们将它创建为一个4字节的整数
glBufferSubData(GL_UNIFORM_BUFFER, 144, 4, &b);
glBindBuffer(GL_UNIFORM_BUFFER, 0);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>&nbsp; </p>
<hr>
<p><font size="5" color="orange">Demo</font><br>下面我们上一个Demo，使用uniform缓冲对象。将观察矩阵view和投影矩阵projection放到uniform块中。由于模型矩阵是频繁变化的，在不同的着色器里模型矩阵的值可能不同，所以不需要把模型矩阵model也放入uniform块中。uniform块中存储着的应该是被大多数着色器共享的uniform变量，在这些着色器里的值都应该一样才行。</p>
<p>我们将在窗口上绘制红、绿、蓝、黄4个立方体，它们有各自的像素着色器，共用一个顶点着色器（当然也可以是4个顶点着色器，不过它们的代码是一样的）。它们的代码很简单，可参考文末的源码汇总。</p>
<p>写好4个立方体各自的着色器之后，我们给它们各自创建一个着色器类对象：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    //定义自定义着色器类shader的对象
    shader redCube_shader("cube.vertex", "redCube.fragment");
    shader greenCube_shader("cube.vertex", "greenCube.fragment");
    shader blueCube_shader("cube.vertex", "blueCube.fragment");
    shader yellowCube_shader("cube.vertex", "yellowCube.fragment");
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>接下里我们把每个着色器程序里的uniform块<code>Matrices</code>绑定到绑定点2上（其他绑定点也可以）：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    //把uniform块绑定到绑定点2
    //红方块的uniform块
    GLuint uniform_index = glGetUniformBlockIndex(redCube_shader.shaderProgram, "Matrices");
    glUniformBlockBinding(redCube_shader.shaderProgram, uniform_index, 2);
    //绿方块的uniform块
    uniform_index = glGetUniformBlockIndex(greenCube_shader.shaderProgram, "Matrices");
    glUniformBlockBinding(greenCube_shader.shaderProgram, uniform_index, 2);
    //蓝方块的uniform块
    uniform_index = glGetUniformBlockIndex(blueCube_shader.shaderProgram, "Matrices");
    glUniformBlockBinding(blueCube_shader.shaderProgram, uniform_index, 2);
    //黄方块的uniform块
    uniform_index = glGetUniformBlockIndex(yellowCube_shader.shaderProgram, "Matrices");
    glUniformBlockBinding(yellowCube_shader.shaderProgram, uniform_index, 2);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>还需要创建一个uniform缓冲对象，并且把它绑定到相同的绑定点2上：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    //将uniform缓冲对象绑定到相同的绑定点2
      //创建uniform缓冲对象
    GLuint ubo;
    glGenBuffers(1, &ubo);
    glBindBuffer(GL_UNIFORM_BUFFER, ubo);
    glBufferData(GL_UNIFORM_BUFFER, 150, NULL, GL_STATIC_DRAW);
    glBindBuffer(GL_UNIFORM_BUFFER, 0);
      //绑定ubo到绑定点2
    glBindBufferBase(GL_UNIFORM_BUFFER, 2, ubo);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这样一来，每个着色器里的uniform块<code>Matrices</code>就都和这个uniform缓冲对象ubo连接在一起了。</p>
<p>然后我们就可以在渲染循环里给这个uniform缓冲对象填充数据了（使用<code>glBufferSubData</code>函数），也就是给uniform块的view矩阵和projection矩阵赋值：</p>
<pre class="line-numbers language-c++"><code class="language-c++">        //为uniform缓冲对象填充数据
        mat4 view = mycamera.GetViewMatrix();
        mat4 projection = perspective(radians(mycamera.cameraFov), (GLfloat)WIDTH / (GLfloat)HEIGHT, 0.1f, 100.0f);
        glBindBuffer(GL_UNIFORM_BUFFER, ubo);
        glBufferSubData(GL_UNIFORM_BUFFER, 0, sizeof(mat4), value_ptr(view));
        glBufferSubData(GL_UNIFORM_BUFFER, sizeof(mat4), sizeof(mat4), value_ptr(projection));
        glBindBuffer(GL_UNIFORM_BUFFER, 0);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>最后当然就是绘制这4个立方体：</p>
<pre class="line-numbers language-c++"><code class="language-c++">        //绘制红绿蓝黄四个立方体
        //红色立方体
        redCube_shader.Use();
        mat4 model;
        model = translate(model, vec3(-0.75f, 0.75f, 0.0f));
        glUniformMatrix4fv(glGetUniformLocation(redCube_shader.shaderProgram, "model"), 1, GL_FALSE, value_ptr(model));
        glBindVertexArray(cubeVAO);
        glDrawElements(GL_TRIANGLES, 36, GL_UNSIGNED_INT, 0);
        //绿色立方体
        greenCube_shader.Use();
        model = mat4();
        model = translate(model, vec3(-0.75f, -0.75f, 0.0f));
        glUniformMatrix4fv(glGetUniformLocation(greenCube_shader.shaderProgram, "model"), 1, GL_FALSE, value_ptr(model));
        glBindVertexArray(cubeVAO);
        glDrawElements(GL_TRIANGLES, 36, GL_UNSIGNED_INT, 0);
        //蓝色立方体
        blueCube_shader.Use();
        model = mat4();
        model = translate(model, vec3(0.75f, 0.75f, 0.0f));
        glUniformMatrix4fv(glGetUniformLocation(blueCube_shader.shaderProgram, "model"), 1, GL_FALSE, value_ptr(model));
        glBindVertexArray(cubeVAO);
        glDrawElements(GL_TRIANGLES, 36, GL_UNSIGNED_INT, 0);
        //黄色立方体
        yellowCube_shader.Use();
        model = mat4();
        model = translate(model, vec3(0.75f, -0.75f, 0.0f));
        glUniformMatrix4fv(glGetUniformLocation(yellowCube_shader.shaderProgram, "model"), 1, GL_FALSE, value_ptr(model));
        glBindVertexArray(cubeVAO);
        glDrawElements(GL_TRIANGLES, 36, GL_UNSIGNED_INT, 0);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>编译运行后的结果如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148535051966.png" alt=""><br>所有源码请看<a href="https://github.com/Popperelay/BlogCode/tree/master/LearnOpenGL22_AdvancedGLSL/LearnOpenGL22_AdvancedGLSL_2" target="_blank" rel="external">这里</a>。<br>&nbsp; </p>
<hr>
<p><font size="5" color="orange">使用uniform缓冲对象的好处</font><br>uniform缓冲对象比单独的uniform有很多好处：</p>
<ul>
<li>一次设置多个uniform比一次设置一个速度快。</li>
<li>如果打算改变一个横跨多个着色器的uniform，只需要在uniform缓冲中更改一次。</li>
<li>使用uniform缓冲对象让我们可以在着色器中使用更多的uniform。因为OpenGL对uniform缓冲对象最大个数比uniform最大个数大。<br>&nbsp; </li>
</ul>
<hr>
<p><font size="5" color="orange">shared共享内存布局</font><br>同std140内存布局方式不一样，shared方式的内存布局依赖于具体实现，因此我们无法提前根据某种字节对齐规范计算出UBO中变量的位移偏量和整体大小，所以在使用shared方式时，我们需要多次利用OpenGL的函数来查询UBO的信息。如下面的部分程序所示：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#version 330 core
// 使用默认shared​方式的UBO
uniform mixColorSettings {
    vec4  anotherColor;
    float mixValue;
};
out vec4 color;
void main()
{
    color = mix(vec4(0.0, 0.0, 1.0, 1.0), anotherColor, mixValue);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">// 通过查询获取uniform buffer中各个变量的索引和位移偏量
const GLchar* names[] = {
    "anotherColor", "mixValue"
};
GLuint indices[2];
glGetUniformIndices(redShader.programId, 2, names, indices);
GLint offset[2];
glGetActiveUniformsiv(redShader.programId, 2, indices, GL_UNIFORM_OFFSET, offset);
// 使用获取的位移偏量更新数据
glm::vec4 anotherColor = glm::vec4(0.0f, 1.0f, 1.0f, 1.0f);
GLfloat mixValue = 0.5f;
glBindBuffer(GL_UNIFORM_BUFFER, colorUBOId);
glBufferSubData(GL_UNIFORM_BUFFER, offset[0], sizeof(glm::vec4), glm::value_ptr(anotherColor));
glBufferSubData(GL_UNIFORM_BUFFER, offset[1], sizeof(glm::vec4), &mixValue);
glBindBuffer(GL_UNIFORM_BUFFER, 0);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>&nbsp; </p>
<hr>
<p>参考文献：<a href="https://learnopengl.com/" target="_blank" rel="external">LearnOpenGL</a></p>
]]></content>
      
        <categories>
            
            <category> OpenGL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> GLSL </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OpenGL21：缓冲对象及其相关函数]]></title>
      <url>/2017/01/23/OpenGL21%E7%BC%93%E5%86%B2%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<p><font size="5" color="orange">缓冲对象的概念</font><br><a id="more"></a><br>在OpenGL中，缓冲对象（buffer  object）是OpenGL的绘制上下文，是GPU分配的，完成未格式化数据区域的存储，例如完成顶点数据、帧缓冲数据的存储。</p>
<p>缓冲对象中的数据实际上就是原始的字节流，例如我们在程序中指定顶点属性数据，然后使用<code>glBufferData</code>这个函数将数据从CPU传送至GPU中，这一步只完成了数据的上传，关于这份数据，OpenGL是不知道其具体格式的，因此在实际使用中还必须告诉OpenGL如何具体使用这些数据，这是通过<code>glVertexAttribPointer</code>这样的函数来完成的。</p>
<p>每个缓冲对象，必须绑定到一个具体的目标（target）后，OpenGL才知道如何具体操作这个缓冲对象，例如绑定到<code>GL_ARRAY_BUFFER</code>，OpenGL使用这个缓冲对象作为顶点属性数据；例如绑定到<code>GL_ELEMENT_ARRAY_BUFFER</code>，则OpenGL使用这个缓冲对象的数据作为索引绘图的索引数据。</p>
<p>缓冲对象的数据，也存在读写、复制、清除等操作，同时缓存对象在适当时候也可以使用<code>glDeleteBuffers</code>这类函数释放。<br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">数据从CPU传递到GPU内存的函数</font><br>把数据从CPU传递到GPU的函数有：<code>glBufferData</code>函数、<code>glBufferSubData</code>函数、<code>glMapBuffer</code>和<code>memcpy</code>函数。</p>
<p><font size="4" color="red">glBufferData函数</font><br>函数原型为：<code>glBufferData(GLenum target, GLsizeiptr size, const void* data, GLenum usage)</code></p>
<p><code>glBufferData</code>函数可以把数据从CPU传递到GPU，并且能够在GPU上开辟一块大小等于其第二个参数的内存，然后把来自CPU的数据存储到这片内存里。如果第三个参数data传递的是NULL，那么OpenGL只会帮我们分配内存，而不会填充它。这对后面的<code>glBufferSubData</code>函数很有用。</p>
<p><font size="4" color="red">glBufferSubData函数</font><br>函数原型为：<code>glBufferSubData(GLenum targrt, GLintptr offset, GLsizeiptr size, const void* data)</code></p>
<p><code>glBufferSubData</code>函数也可以把数据从CPU传递到GPU，但是它不会再GPU上开辟内存，所以在调用该函数之前，必须调用<code>glBufferData</code>函数分配好足够的内存，然后该函数才能把来自CPU的数据放到这片内存的指定位置。</p>
<p><code>glBufferData</code>函数是从开辟的内存的起始地址开始，把所有数据一次性地填充到这片内存里，而<code>glBufferSubData</code>函数是从开辟的内存的offset位置开始，把数据填充到这片内存的指定位置上，只要不越界就可以（不超过开辟的内存的结束地址）。例如：</p>
<pre class="line-numbers language-c++"><code class="language-c++">glBufferSubData(GL_ARRAY_BUFFER, 24, sizeof(data), &data); // 范围： [24, 24 + sizeof(data)]
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><font size="4" color="red">glMapBuffer和memcpy函数</font><br>使用<code>glMapBuffer</code>函数可以返回一个当前绑定缓冲的内存的地址，是一个指针，我们可以把这个返回的内存地址作为<code>memcpy</code>函数的参数，从而把数据传递到该内存地址所指定的位置：</p>
<pre class="line-numbers language-c++"><code class="language-c++">glBindBuffer(GL_ARRAY_BUFFER, buffer);
// 获取当前绑定缓存buffer的内存地址
void* ptr = glMapBuffer(GL_ARRAY_BUFFER, GL_WRITE_ONLY);
// 向缓冲中写入数据
memcpy(ptr, data, sizeof(data));
// 完成够别忘了告诉OpenGL我们不再需要它了
glUnmapBuffer(GL_ARRAY_BUFFER);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>别忘了调用<code>glUnmapBuffer</code>函数告诉OpenGL我们已经用完指针了，需要解映射，这样这个地址指针将不再可用。</p>
<p>把数据直接映射到缓冲区上使用<code>glMapBuffer</code>很有用，因为它不用把它存储在临时内存里，可以从文件读取数据然后直接复制到缓冲的内存里。而<code>glBufferData</code>和<code>glBufferSubData</code>是需要先开辟临时内存，再存储到对应的缓冲内存里。<br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">分批处理顶点数据</font><br>使用<code>glVertexAttribPointer</code>函数可以指定缓冲中顶点数组的属性的布局（layout）。我们之前一直是把顶点属性交叉存放在顶点数组里的，比如123123123123这种交叉布局，这个时候是使用<code>glBufferData</code>函数来传递数据，，而且每种属性下<code>glVertexAttribPointer</code>函数的步长参数stride应该设置为sizeof(123)，即所有属性大小之和。注：1、2、3可能还是几个GL_FLOAT大小。</p>
<p>其实我们还可以把顶点属性连续放置，比如111222333这种批量方式，这时传递数据应该使用<code>glBufferSubData</code>函数了，使用该函数指定每种属性的起始位置和该属性的所有数据大小。示例如下：</p>
<pre class="line-numbers language-c++"><code class="language-c++">GLfloat positions[] = { ... };
GLfloat normals[] = { ... };
GLfloat tex[] = { ... };
// 填充缓冲
glBufferSubData(GL_ARRAY_BUFFER, 0, sizeof(positions), &positions);
glBufferSubData(GL_ARRAY_BUFFER, sizeof(positions), sizeof(normals), &normals);
glBufferSubData(GL_ARRAY_BUFFER, sizeof(positions) + sizeof(normals), sizeof(tex), &tex);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在使用<code>glVertexAttribPointer</code>函数解析顶点数据时，每种属性下的步长就应该是对应属性的GL_FLOAT大小了。而且偏移量应该是批量属性开始的位置，不再像是交叉属性在第一组里的偏移量：</p>
<pre class="line-numbers language-c++"><code class="language-c++">glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(GLfloat), 0);  
glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(GLfloat), (GLvoid*)(sizeof(positions)));  
glVertexAttribPointer(
  2, 2, GL_FLOAT, GL_FALSE, 2 * sizeof(GLfloat), (GLvoid*)(sizeof(positions) + sizeof(normals)));
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>当然，选用哪种方式全凭喜好了，效率上没有多大区别。<br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">复制缓冲</font><br>当我们的缓冲被数据填充以后，可能打算让其他缓冲也能够分享这些数据或者打算把缓冲的内容复制到另一个缓冲里。<code>glCopyBufferSubData</code>函数让我们能够相对容易地把一个缓冲里的数据复制到另一个缓冲里。函数原型如下：</p>
<pre class="line-numbers language-c++"><code class="language-c++">void glCopyBufferSubData(GLenum readtarget, GLenum writetarget, GLintptr readoffset, GLintptr writeoffset, GLsizeiptr size);
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><code>readtarget</code>和<code>writetarget</code>是复制的来源缓冲目标和目的缓冲目标，例如我们可以从<code>VERTEX_ARRAY_BUFFER</code>复制到<code>VERTEX_ELEMENT_ARRAY_BUFFER</code>。该函数的意思就是从源目标<code>readtarget</code>缓冲的<code>readoffset</code>位置开始，复制<code>size</code>大小的数据到目的目标<code>writetarget</code>缓冲的<code>writeoffset</code>位置开始的内存区里。</p>
<p>但是如果我们的源和目的都是顶点数组缓冲<code>(GL_VERTEX_ARRAY_BUFFER)</code>怎么办？我们显然不能把源和目的都设置为它。为此，OpenGL 给我们设了额外的两个缓冲目标：<code>GL_COPY_READ_BUFFER</code>和<code>GL_COPY_WRITE_BUFFER</code>。这时我们可以使用下面的代码来实现两个顶点数组缓冲之间的数据复制：</p>
<pre class="line-numbers language-c++"><code class="language-c++">GLfloat vertexData[] = { ... };
glBindBuffer(GL_COPY_READ_BUFFER, vbo1);
glBindBuffer(GL_COPY_WRITE_BUFFER, vbo2);
glCopyBufferSubData(GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, 0, 0, sizeof(vertexData));
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>也可以只把目标缓冲设为<code>GL_COPY_WRITE_BUFFER</code>，如下代码：</p>
<pre class="line-numbers language-c++"><code class="language-c++">GLfloat vertexData[] = { ... };
glBindBuffer(GL_ARRAY_BUFFER, vbo1);
glBindBuffer(GL_COPY_WRITE_BUFFER, vbo2);
glCopyBufferSubData(GL_ARRAY_BUFFER, GL_COPY_WRITE_BUFFER, 0, 0, sizeof(vertexData));
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>下一篇文章里我们将会讨论uniform缓冲对象，到时候我们会充分利用<code>glBufferSubData</code>函数。<br>&nbsp; </p>
<hr>
<p>参考文献：<a href="https://learnopengl.com/" target="_blank" rel="external">LearnOpenGL</a></p>
]]></content>
      
        <categories>
            
            <category> OpenGL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 缓冲对象 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OpenGL20：立方体贴图]]></title>
      <url>/2017/01/22/OpenGL20%E7%AB%8B%E6%96%B9%E4%BD%93%E8%B4%B4%E5%9B%BE/</url>
      <content type="html"><![CDATA[<p><font size="5" color="orange">立方体贴图概念及采样方法</font><br><a id="more"></a><br>立方体贴图包含6个2D纹理，每个2D纹理是立方体的一个面，也就是说它是一个有贴图的立方体。使用立方体贴图可以实现很多有意思的效果，比如天空盒、环境映射等等。</p>
<p>对于2D纹理，可以通过纹素的2D坐标来采样，那么立方体纹理怎样采样呢？它的采样方式类似下图：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148508140727.png" alt=""><br>如果立方体的中心位于原点上，那么可以通过原点到立方体表面片段的向量来采样，如上图中的橘黄色向量。也就是说，我们可以直接使用片段的位置向量（或者说片段坐标）来进行采样，在顶点着色器里将片段的位置坐标直接赋值给输出变量纹理坐标：</p>
<pre class="line-numbers language-c++"><code class="language-c++">void main(){
    gl_Position = position;
    TexCoords = position;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>利用(s,t,r)采样时，首先根据(s,t,r)中模最大的分量决定在哪个面采样，然后使用剩下的2个坐标在对应的面上做2D纹理采样。例如，如果(s,t,r)中s分量的模最大，且符号为正，则决定选取+x面作为采样的2D纹理，然后使用(t,r)坐标在+x面上做2D纹理采样。</p>
<p>这6个面在OpenGL中指定如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148508140813.png" alt=""><br>这几个枚举常量其实是连续的，可以循环遍历，在OpenGL中它们定义如下：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#define GL_TEXTURE_CUBE_MAP_POSITIVE_X 0x8515
#define GL_TEXTURE_CUBE_MAP_NEGATIVE_X 0x8516
#define GL_TEXTURE_CUBE_MAP_POSITIVE_Y 0x8517
#define GL_TEXTURE_CUBE_MAP_NEGATIVE_Y 0x8518
#define GL_TEXTURE_CUBE_MAP_POSITIVE_Z 0x8519
#define GL_TEXTURE_CUBE_MAP_NEGATIVE_Z 0x851A
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>&nbsp; </p>
<hr>
<p><font size="5" color="orange">创建立方体贴图</font><br>既然立方体贴图有6个纹理，那么我们需要把这6张纹理都加载进来，生成一个最终的立方体纹理贴图。我们把这部分代码写入自定义类<code>CubemapLoader</code>的<code>loadCubemap</code>方法中：</p>
<p>首先，创建立方体贴图对象和创建普通纹理一样，只是绑定目标变成了<code>GL_TEXTURE_CUBE_MAP</code>：</p>
<pre class="line-numbers language-c++"><code class="language-c++">        GLuint cubemap;
        glGenTextures(1, &cubemap);
        glBindTexture(GL_TEXTURE_CUBE_MAP, cubemap);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>接下来我们加载立方体贴图的6张纹理：</p>
<pre class="line-numbers language-c++"><code class="language-c++">        int width, height;
        unsigned char* image;
        for (int i = 0; i < facePaths.size(); i++) {
            image = SOIL_load_image(facePaths[i], &width, &height, 0, SOIL_LOAD_RGB);
            glTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, image);
        }
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中<code>facePaths</code>是函数<code>loadCubemap</code>的参数，指明6张纹理的路径。在使用<code>glTexImage2D</code>函数生成纹理时，目标应该是具体的立方体的某个面。由于立方体的每个面都有一个常数来表示，而且是连续的，所以我们就用<code>GL_TEXTURE_CUBE_MAP_POSITIVE_X</code>和迭代遍历i来循环遍历了。</p>
<p>接着需要设置立方体纹理贴图的参数，环绕方式和过滤方式设置如下：</p>
<pre class="line-numbers language-c++"><code class="language-c++">        glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
        glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
        glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);
        glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
        glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>将立方体贴图在S、T、R方向上的环绕方式设为了<code>GL_CLAMP_TO_EDGE</code>，这是指明当(s,t,r)坐标没有落在哪个面，而是落在两个面之间时，采样为边缘的纹理值。</p>
<p>完整的<code>CubemapLoader</code>类可见后面的源码。<br>&nbsp; </p>
<hr>
<p><font size="5" color="orange">立方体贴图应用之天空盒</font><br>我们之前的场景背景一直都是用的<code>glClearColor</code>，现在我们想让场景的背景是一片天空。而立方体贴图完全满足这个要求，我们在场景中绘制一个使用cubemap纹理的立方体，将这个立方体总是置于场景外围，让玩家感觉好像场景很长大，触不可及像天空一样，但是实际上他还是在一个小盒子中。我们要用到的天空盒子贴图可在<a href="https://learnopengl-cn.github.io/img/04/06/skybox.rar" target="_blank" rel="external">这里下载</a>。</p>
<p> 天空盒也是一个立方体，当然也需要为它设置顶点属性，VAO以及顶点数据解析。顶点数据如下，其它的可参考后面的主程序源码：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    //天空盒的顶点坐标
    GLfloat skyboxVertices[] = {
        //位置坐标         
        //立方体前面
        1.0f, 1.0f, 1.0f,
        1.0f,-1.0f, 1.0f,
       -1.0f,-1.0f, 1.0f,
       -1.0f, 1.0f, 1.0f,
        //立方体后面
        1.0f, 1.0f,-1.0f,
        1.0f,-1.0f,-1.0f,
       -1.0f,-1.0f,-1.0f,
       -1.0f, 1.0f,-1.0f,
        //立方体上面
        1.0f, 1.0f, 1.0f,
        1.0f, 1.0f,-1.0f,
       -1.0f, 1.0f,-1.0f,
       -1.0f, 1.0f, 1.0f,
        //立方体下面
        1.0f,-1.0f, 1.0f,
        1.0f,-1.0f,-1.0f,
       -1.0f,-1.0f,-1.0f,
       -1.0f,-1.0f, 1.0f,
        //立方体右面
        1.0f, 1.0f, 1.0f,
        1.0f, 1.0f,-1.0f,
        1.0f,-1.0f,-1.0f,
        1.0f,-1.0f, 1.0f,
        //立方体左面
       -1.0f, 1.0f, 1.0f,
       -1.0f, 1.0f,-1.0f,
       -1.0f,-1.0f,-1.0f,
       -1.0f,-1.0f, 1.0f
    };
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里我们让这个天空盒的坐标绝对值都取为1，好让它填充满整个窗口。</p>
<p>然后我们生成天空盒的立方体贴图，需要加载6个纹理：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    //立方体贴图的6个纹理的路径
    vector<const GLchar*> facePaths;
    facePaths.push_back("skybox/right.jpg");
    facePaths.push_back("skybox/left.jpg");
    facePaths.push_back("skybox/top.jpg");
    facePaths.push_back("skybox/bottom.jpg");
    facePaths.push_back("skybox/back.jpg");
    facePaths.push_back("skybox/front.jpg");
    CubemapLoader cubemapLoader;
    GLuint cubemap = cubemapLoader.loadCubemap(facePaths);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>要画出这个天空盒，我们还需要给它写顶点着色器（写在cubemap.vertex中）和像素着色器（写在cubemap.fragment中）：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#version 330 core
layout (location=0) in vec3 position;
out vec3 TexCoords;

uniform mat4 view;
uniform mat4 projection;

void main(){
    gl_Position = projection * view * vec4(position,1.0f);
    TexCoords = position;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>天空盒子不需要从模型坐标系到世界坐标系的平移、旋转、缩放，所以这里就没有写model矩阵。其实OpenGL是会自动给乘上一个model单位矩阵的。我们还让纹理坐标直接等于片段的位置坐标，因为此时的天空盒子中心是在原点的，可以直接使用片段的位置向量作为采样向量。注意纹理坐标是3维的。</p>
<pre class="line-numbers language-c++"><code class="language-c++">#version 330 core
in vec3 TexCoords;
out vec4 color;

uniform samplerCube cubemap;

void main(){
    color = texture(cubemap,TexCoords);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>像素着色器很简单，直接让片段最终颜色等于立方体贴图采样的纹素颜色就可以。</p>
<p>当然，肯定还需要给天空盒子定义一个着色器类对象：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    shader skybox_shader("cubemap.vertex", "cubemap.fragment");
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>接下来我们在渲染循环里绘制这个天空盒子。在绘制天空盒子之前，我们需要关闭面剔除，否则天空盒子不会显示，因为我们现在是正处于天空盒子内部的，如果不关闭面剔除，它的每个面都将被剔除掉；而且还要禁用深度写入，否则场景中的其他物体都会被天空盒子覆盖掉，其他物体将不能通过深度测试而被抛弃：</p>
<pre class="line-numbers language-c++"><code class="language-c++">        //Draw skybox
        glDisable(GL_CULL_FACE);
        glDepthMask(GL_FALSE);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>接下来就是和绘制普通立方体一样，来绘制天空盒了：</p>
<pre class="line-numbers language-c++"><code class="language-c++">        skybox_shader.Use();
        mat4 view = mycamera.GetViewMatrix();
        mat4 projection = perspective(radians(mycamera.cameraFov), (GLfloat)WIDTH / (GLfloat)HEIGHT, 0.1f, 100.0f);
        glUniformMatrix4fv(glGetUniformLocation(skybox_shader.shaderProgram, "view"), 1, GL_FALSE, value_ptr(view));
        glUniformMatrix4fv(glGetUniformLocation(skybox_shader.shaderProgram, "projection"), 1, GL_FALSE, value_ptr(projection));
        glBindVertexArray(skyboxVAO);
        glBindTexture(GL_TEXTURE_CUBE_MAP, cubemap);
        glDrawElements(GL_TRIANGLES, 36, GL_UNSIGNED_INT, 0);
        glDepthMask(GL_TRUE);
        glEnable(GL_CULL_FACE);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>后面再照常绘制其他物体就可以了。</p>
<p>编译运行后的结果如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148508141071.png" alt=""><br>移动摄像机，会发现天空盒子也会跟着移动，给人的感觉确实就是个盒子，而不是一片浩瀚的天空。要解决这个问题，我们需要让天空盒子不会随着摄像机移动而移动。天空盒子之所以会移动，是因为在它的顶点着色器中顶点坐标乘上了观察矩阵view，这个观察矩阵是随着摄像机移动而改变的。我们可以去掉观察矩阵的平移部分，把4x4的矩阵改成3x3即可（线性代数知识）。我们在主程序中完成这个操作，然后把新的观察矩阵发送给顶点着色器：</p>
<pre class="line-numbers language-c++"><code class="language-c++">        mat4 view = mat4(mat3(mycamera.GetViewMatrix()));
        glUniformMatrix4fv(glGetUniformLocation(skybox_shader.shaderProgram, "view"), 1, GL_FALSE, value_ptr(view));
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>这样编译运行后的结果就正常了：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148508141352.png" alt=""><br>&nbsp; </p>
<hr>
<p><font size="5" color="orange">优化</font><br>上面再绘制天空包围盒时，我们首先禁用了深度缓冲写入，再绘制包围盒，让它处于场景外围，这样做虽然能正常工作，缺点是如果场景中有的物体挡住了天空，按照上面的绘制方式，这部分被挡住的天空还是被绘制了，只是后来又被其他物体（比如场景中的箱子）覆盖了，这导致了不必要的着色器调用，是一种性能上的损失。</p>
<p>所以，绘制天空盒时，我们还是得允许深度写入。但是我们想办法让天空盒的深度最大（1.0），因为它是最外围的。如果有物体挡住了它，被遮挡住的天空盒部分将无法通过深度测试，会被丢弃。那么如何让天空盒的每一个片段的深度值都等于1.0呢？我们在天空盒的顶点着色器中做如下操作：</p>
<pre class="line-numbers language-c++"><code class="language-c++">void main(){
    vec4 pos = projection * view * vec4(position,1.0f);
    gl_Position = pos.xyww;
    TexCoords = position;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们把顶点坐标的z值改成了w。正如我们以前就知道的，z值代表了该片段的深度值。在投影变换之后OpenGL会进行透视除法，顶点的x、y、z都会去除以w，因为我们把z值变成了w，所以透视除法的结果就是每个顶点的z值都变成了1.0。</p>
<p>注意这时我们应该改变一下通过深度测试的条件：应该是小于等于时通过深度测试，而不是默认的小于，否则下一次渲染循环的天空深度值因为等于1.0，和深度缓冲的深度值里一样，将会被丢弃，导致天空无法显示出来：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    //深度测试函数
    glDepthFunc(GL_LEQUAL);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>所有源码<a href="https://github.com/Popperelay/BlogCode/tree/master/LearnOpenGL20_CubeMap/LearnOpenGL20_CubeMap_1" target="_blank" rel="external">在这里</a>。<br>&nbsp; </p>
<hr>
<p><font size="5" color="orange">环境映射</font><br>我们使用立方体贴图能够渲染的不只是天空盒，可以是任何大环境，比如一个山谷、一个空间内部等等。我们可以利用这些带有场景的立方体贴图，让物体可以反射或折射周围的环境。像这样使用了环境立方体贴图的技术叫做环境贴图技术，其中最重要的是反射和折射。由于我们着重关注怎么让物体反射和折射环境，所以我们还是使用之前的天空盒，让箱子反射和折射天空。</p>
<p><font size="4" color="red">反射</font><br>反射是一个物体（或物体的，某部分）反射（Reflect）它周围环境的属性，比如物体的颜色多少有些等于它周围的环境，这要基于观察者的角度。</p>
<p>下图展示了如何计算反射向量，然后使用这个反射向量去立方体贴图中采样：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148509525977.png" alt=""><br>计算反射向量的方法已经在<a href="http://popperelay.com/2016/12/12/OpenGL10%E5%85%89%E7%85%A7%E5%9F%BA%E7%A1%80/" target="_blank" rel="external">《OpenGL10：光照基础Phong模型》</a> 里讲过了，原理很简单，我们直接上代码：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#version 330 core
in vec3 Normal;
in vec3 PositionInWorld;
out vec4 color;

uniform vec3 cameraPos;
uniform samplerCube cubemap;

void main(){
    vec3 I = normalize(PositionInWorld - cameraPos);
    vec3 R = reflect(I,normalize(Normal));
    color = texture(cubemap,R);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对应的顶点着色器为：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#version 330 core
layout (location=0) in vec3 position;
layout (location=1) in vec3 normal;
out vec3 Normal;
out vec3 PositionInWorld;

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;

void main(){
    gl_Position = projection * view * model * vec4(position,1.0f);
    Normal = mat3(transpose(inverse(model))) * normal;
    PositionInWorld = vec3(model * vec4(position,1.0f));
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>既然要用到法线向量，那还得给立方体顶点添加法线数据：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    //立方体顶点的坐标、法线向量
    GLfloat cubeVertices[] = {
        //位置坐标          //法线
        //立方体前面
        0.5f, 0.5f, 0.5f,   0, 0, 1,
        0.5f,-0.5f, 0.5f,   0, 0, 1,
        -0.5f,-0.5f, 0.5f,  0, 0, 1,
        -0.5f, 0.5f, 0.5f,  0, 0, 1,
        //立方体后面
        0.5f, 0.5f,-0.5f,   0, 0,-1,
        0.5f,-0.5f,-0.5f,   0, 0,-1,
        -0.5f,-0.5f,-0.5f,  0, 0,-1,
        -0.5f, 0.5f,-0.5f,  0, 0,-1,
        //立方体上面
        0.5f, 0.5f, 0.5f,   0, 1, 0,
        0.5f, 0.5f,-0.5f,   0, 1, 0,
        -0.5f, 0.5f,-0.5f,  0, 1, 0,
        -0.5f, 0.5f, 0.5f,  0, 1, 0,
        //立方体下面
        0.5f,-0.5f, 0.5f,   0,-1, 0,
        0.5f,-0.5f,-0.5f,   0,-1, 0,
        -0.5f,-0.5f,-0.5f,  0,-1, 0,
        -0.5f,-0.5f, 0.5f,  0,-1, 0,
        //立方体右面
        0.5f, 0.5f, 0.5f,   1, 0, 0,
        0.5f, 0.5f,-0.5f,   1, 0, 0,
        0.5f,-0.5f,-0.5f,   1, 0, 0,
        0.5f,-0.5f, 0.5f,   1, 0, 0,
        //立方体左面
        -0.5f, 0.5f, 0.5f, -1, 0, 0,
        -0.5f, 0.5f,-0.5f, -1, 0, 0,
        -0.5f,-0.5f,-0.5f, -1, 0, 0,
        -0.5f,-0.5f, 0.5f, -1, 0, 0
    };
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当然，对应的数据解析也得作调整了，不再赘述。环境反射的所有源码<a href="https://github.com/Popperelay/BlogCode/tree/master/LearnOpenGL20_CubeMap/LearnOpenGL20_CubeMap_2" target="_blank" rel="external">在这里</a>。</p>
<p>编译运行后的结果如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148509526094.png" alt=""><br>可以看到我们得到了一个镜子一样的箱子，完美地反射了周围的天空盒。如果是球模型，会更明显：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148509526198.png" alt=""></p>
<p><font size="4" color="red">折射</font><br>环境映射的另一个形式是折射。如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148509526251.png" alt=""><br>我们可以通过折射向量R来从立方体贴图上采样。</p>
<p>折射可以通过GLSL的内置函数refract来计算，它需要3个参数：观察向量、法线向量、折射指数：</p>
<pre class="line-numbers language-c++"><code class="language-c++">void main(){
    //折射
    float ratio = 1.00/1.52;
    vec3 I = normalize(PositionInWorld - cameraPos);
    vec3 R = refract(I,normalize(Normal),ratio);
    color = texture(cubemap,R);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>折射指数决定了一个材质上光线扭曲的数量，每个材质都有自己的折射指数。下表是常见的折射指数：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148509526295.png" alt=""><br>编译运行后的结果如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148509526374.png" alt=""><br>环境折射的所有源码<a href="https://github.com/Popperelay/BlogCode/tree/master/LearnOpenGL20_CubeMap/LearnOpenGL20_CubeMap_3" target="_blank" rel="external">在这里</a>。<br>&nbsp; </p>
<hr>
<p><font size="5" color="orange">动态环境贴图</font><br>现在我们的环境立方体贴图还只是静态的。但是如果我们有个镜子一样的物体，它周围有多个物体，当移动摄像机或者移动镜子物体时，它所反射/折射的环境应该是变化挺大的，用静态的立方体贴图显然不够逼真。</p>
<p>可以使用帧缓冲为镜子物体的所有6个不同角度创建一个场景的纹理，把它们每次渲染迭代存储为一个立方体贴图。之后我们可以使用这个（动态生成的）立方体贴图来创建真实的反射和折射表面。这种方法叫做动态环境映射（Dynamic Environment Mapping），因为我们动态地创建了一个物体的以其四周为参考的立方体贴图，并把它用作环境贴图。</p>
<p>这种方法看起来效果很好，但是有一个缺点：我们必须为每个物体渲染场景6次，这需要非常大的开销。我们还是应该尽量使用静态的天空盒子，尽量减少动态环境贴图的使用。想要在不降低执行效率的情况下实现动态环境贴图还需要很多巧妙的技巧。<br>&nbsp; </p>
<hr>
<p>参考文献：<a href="https://learnopengl.com/" target="_blank" rel="external">LearnOpenGL</a></p>
]]></content>
      
        <categories>
            
            <category> OpenGL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 天空盒子 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OpenGL19：帧缓冲]]></title>
      <url>/2017/01/21/OpenGL19%E5%B8%A7%E7%BC%93%E5%86%B2/</url>
      <content type="html"><![CDATA[<p>颜色缓冲、深度缓冲、模板缓冲统称帧缓冲。到目前为止，我们在使用OpenGL渲染时，最终的目的地都是默认的帧缓冲区，实际上OpenGL也允许我们创建自定义的帧缓冲区。使用自定义的帧缓冲区，可以实现镜面、离屏渲染，以及很酷的后处理效果。<br><a id="more"></a><br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">帧缓冲FBO概念</font><br>在OpenGL中，渲染管线中的顶点、纹理等经过一系列处理后，最终显示在2D屏幕上，渲染管线的最终目的地就是帧缓冲区。帧缓冲包括颜色缓冲区、深度缓冲区、模板缓冲区。默认的缓冲区由窗口系统创建，例如我们一直使用GLFW库来完成这项任务。这个默认的帧缓冲区，就是目前我们一直使用的绘图命令的作用对象， 称之为<strong>窗口系统提供的帧缓冲区</strong>。</p>
<p>OpenGL也允许我们手动创建一个帧缓冲区，并将渲染结果重定向到这个缓冲区。在创建时允许我们自定义帧缓冲区的一些特性，这个自定义的帧缓冲区，称之为<strong>应用程序帧缓冲区</strong>。</p>
<p>和默认的帧缓冲区一样，自定义的帧缓冲区也包含颜色缓冲、深度和模板缓冲，这些逻辑上的缓冲区在FBO中称之为附件（可附加的文件，Attachment），它们是可以附加到FBO的数组内存空间。</p>
<p>FBO中包含两种类型的附件：纹理图像、渲染缓冲（renderbuffer）对象。之所以用附加这个词，表达的是FBO可以附加多个缓冲区，而且可以灵活地在缓冲区间切换，一个重要的概念是附加点（其实就是指针）。FBO中可以包含多个颜色附加点，但只能有一个深度和模板附加点，如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148491821495.png" alt=""><br>从图中可以看到FBO本身并不包含任何缓冲对象，实际上是通过附加点指向实际缓冲对象的。这样FBO就可以快速地切换缓冲对象。<br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">创建帧缓冲FBO</font><br>和创建其他缓冲对象一样，使用<code>glGenFramebuffers</code>函数创建FBO如下：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    //创建FBO
    GLuint fbo;
    glGenFramebuffers(1, &fbo);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>然后我们需要将创建的fbo绑定到目标对象（读帧缓冲/写帧缓冲/读写帧缓冲）：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    glBindFramebuffer(GL_FRAMEBUFFER, fbo);
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>绑定到目标<code>GL_FRAMEBUFFER</code>后，接下来所有的读、写帧缓冲操作都会影响到当前绑定的帧缓冲，并且该缓冲区可以执行读和写操作。绑定的目标还可以是<code>GL_READ_FRAMEBUFFER</code>，这时该帧缓冲区只能执行读操作，比如<code>glReadPixels</code>；目标还可以是<code>GL_DRAW_FRAMEBUFFER</code>，这时该帧缓冲区允许进行渲染、清空等等写入操作。大多数时候我们都用的<code>GL_FRAMEBUFFER</code>。</p>
<p>构建一个完整的帧缓冲FBO必须满足以下条件：</p>
<ul>
<li>至少附加一个附件（或者说缓冲区，就是颜色、深度、模板缓冲等）</li>
<li>至少有一个颜色附件</li>
<li>所有的附件必须完整（预分配了内存）</li>
<li>每个缓冲区的采样数需要一致</li>
</ul>
<p>从上面可以看到，我们需要为帧缓冲创建一些附件，还需要把这些附件添加到帧缓冲上。当我们做完上面的所有条件后，我们可以使用<code>glCheckFramebufferStatus</code>函数来检查FBO是否完整：</p>
<pre class="line-numbers language-c++"><code class="language-c++">if(glCheckFramebufferStatus(GL_FRAMEBUFFER) == GL_FRAMEBUFFER_COMPLETE)
    ...
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>后续的所有渲染操作将渲染到当前绑定的帧缓冲所附加的对应缓冲中。由于我们这里的帧缓冲是自己创建的，不是默认的帧缓冲，渲染命令对窗口的视频输出不会产生任何影响，所以称为离屏渲染（off-screen rendering）。为了让所有的渲染操作对主窗口产生影响，我们必须在最后通过绑定帧缓冲到0（即默认帧缓冲），来激活默认帧缓冲，才能才窗口上实现最终的绘制效果：</p>
<pre class="line-numbers language-c++"><code class="language-c++">glBindFramebuffer(GL_FRAMEBUFFER, 0);
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>&nbsp;</p>
<hr>
<p>前面提到了，我们需要把一个或多个附件附加到帧缓冲上。一个附件其实就是一个指向颜色缓冲（或深度缓冲、或模板缓冲）的指针。有两张类型的附件（缓冲区）：纹理、渲染缓冲对象。</p>
<p><font size="5" color="orange">附件：纹理</font><br>当把一个纹理附加到帧缓冲上的时候，所有渲染命令会写入到该纹理上，就像它是一个普通的颜色/深度/模板缓冲一样。使用纹理的好处是，所有渲染操作的结果都会被存储为一个纹理图像，这样我们就可以在着色器中访问并使用这个渲染出来的纹理，可以实现很多特效。</p>
<p>创建一个用于附加到帧缓冲的纹理，和创建普通纹理差不多：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    //创建纹理附件
    GLuint texAttachment;
    glGenTextures(1, &texAttachment);
    glBindTexture(GL_TEXTURE_2D, texAttachment);
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, NULL);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>主要区别是：</p>
<ul>
<li>我们把纹理大小设置为渲染窗口的大小。因为后边把这张纹理绘入到默认帧缓冲里，让这张纹理铺满整个渲染窗口，以达到和只使用默认帧缓冲一样的效果</li>
<li>在<code>glTexImage2D</code>函数中，传入NULL作为纹理的data数据。因为我们只需要分配内存，不会用加载的纹理数据去填充它，纹理填充会在渲染到帧缓冲的时候自动完成。</li>
<li>不用关心环绕方式和Mipmap。因为在作为帧缓冲的纹理附件时，大多数时候都不需要它们。</li>
</ul>
<p>【注】：</p>
<ul>
<li>如果打算渲染到一个当前渲染窗口大一点或者小一点的纹理上，需要使用<code>glViewport</code>函数调整当前的渲染窗口。因为最好让渲染窗口和纹理附件尺寸大小一致。</li>
</ul>
<p>创建完纹理附件后，还需要把它附加到帧缓冲上：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    //将纹理附件附加到帧缓冲上
    glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, texAttachment, 0);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>该函数参数说明如下：</p>
<ul>
<li>第一个参数target：我们所创建的帧缓冲类型（读/写/读写的帧缓冲）。<ul>
<li>第二个参数attachment：指明我们所要附加的附件类型。这里我们附加的是一个颜色附件。后面那个0表示我们可以附加1个以上的颜色附件。</li>
<li>第三个参数textarget：指明希望附加的纹理类型</li>
<li>第四个参数level：指明多级渐远纹理的层级，这里设置为0就可以。</li>
</ul>
</li>
</ul>
<p>除了可以把纹理附件附加为帧缓冲的颜色缓冲外，还可以作为深度缓冲和模板缓冲。如果是要附加为深度缓冲，需要把<code>glFramebufferTexture2D</code>函数的第二个参数附件类型指定为<code>GL_DEPTH_ATTACHMENT</code>，而且用<code>glTexImage2D</code>函数生成纹理时，纹理格式和内部格式不再是<code>GL_RGB</code>了，而是<code>GL_DEPTH_COMPONENT</code>，这样才可以存储为深度缓冲所需要的存储格式；如果是要附加为模板缓冲，需要把附件类型指定为<code>GL_STENCIL_ATTACHMENT</code>，把纹理格式和内部格式指定为<code>GL_STENCIL_INDEX</code>。</p>
<p>还可以把纹理附件同时作为帧缓冲的深度缓冲和模板缓冲。这样纹理的每32位数值就包含了24位的深度信息和8位的模板信息，这时需要把附件类型指定为<code>GL_DEPTH_STENCIL_ATTACHMENT</code>，生成纹理时内部格式应该指定为<code>GL_DEPTH24_STENCIL8</code>，纹理格式应该设置为<code>GL_DEPTH_STENCIL</code>，如下所示：</p>
<pre class="line-numbers language-c++"><code class="language-c++">glTexImage2D( GL_TEXTURE_2D, 0, GL_DEPTH24_STENCIL8, 800, 600, 0, GL_DEPTH_STENCIL, GL_UNSIGNED_INT_24_8, NULL );

glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_TEXTURE_2D, texture, 0);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>&nbsp;</p>
<hr>
<p><font size="5" color="orange">附件：渲染缓冲对象</font><br>除了纹理附件，另外一种附件是渲染缓冲对象。和纹理图像一样，渲染缓冲对象也是一个缓冲，它可以是一堆字节、整数、像素或者其他东西。渲染缓冲对象的一大优点是：它以OpenGL原生渲染格式存储它的数据，因此在离屏渲染到帧缓冲的时候，这些数据就相当于被优化过的了。</p>
<p>渲染缓冲对象将所有渲染数据直接存储到它们的缓冲里，而不会进行针对特定纹理格式的任何转换，这样它们就成了一种可快速可写的存储介质了。然而，渲染缓冲对象是只写的，不能修改它们（就是只能写一次，后面不能再修改了）。可以用<code>glReadPixels</code>函数去读取。</p>
<p>因为它所存储的数据已经是原生格式了，在写入或把它们的数据简单地拷贝到其他缓冲的时候会非常快。所以使用渲染缓冲对象时，像切换缓冲这种操作会变得异常高速。我们在每个渲染循环末尾使用的那个<code>glfwSwapBuffers</code>函数，同样可以缓冲对象实现：我们简单地写入到一个渲染缓冲对象，最后交换到另一个里。渲染缓冲对象对于这种切换缓冲的操作来说很完美。</p>
<p><font size="4" color="red">创建渲染缓冲对象</font><br>创建渲染缓冲对象和创建一般的缓冲对象类似：</p>
<pre class="line-numbers language-c++"><code class="language-c++">GLuint rbo;
glGenRenderbuffers(1, &rbo);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>接下来需要绑定到渲染缓冲上，这样所有后续渲染操作都会影响到当前绑定的渲染缓冲对象：</p>
<pre class="line-numbers language-c++"><code class="language-c++">glBindRenderbuffer(GL_RENDERBUFFER, rbo);
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>大多数时候，我们不需要从深度和模板缓冲中读取数据，不需要进行采样，只要能进行深度和模板测试就可以，而渲染缓冲对象通常是只写的，所以它经常作为深度和模板附件来使用，优点是它们等于是被优化过的。</p>
<p>我们可以调用<code>glRenderbufferStorage</code>函数为rbo预分配内存空间，这里把rbo存储为24位深度缓冲和8位模板缓冲的格式：</p>
<pre class="line-numbers language-c++"><code class="language-c++">glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH24_STENCIL8, 800, 600);
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>【注】：</p>
<ul>
<li>渲染缓冲对象是专门被设计用于图像的，而不是通用目的的数据缓冲。</li>
</ul>
<p>最后需要把帧缓冲对象附件附加到帧缓冲上：</p>
<pre class="line-numbers language-c++"><code class="language-c++">glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_RENDERBUFFER, rbo);
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>在帧缓冲项目中，渲染缓冲对象可以提供一些优化，但更重要的是知道何时使用渲染缓冲对象，何时使用纹理附件。通常的规则是：如果永远都不需要从特定的缓冲中进行采样，渲染缓冲对象对特定缓冲是更明智的选择；如果需要从比如颜色或深度这样的特定缓冲中采样数据的话，最好还是使用纹理附件。<br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">渲染到纹理</font><br>现在我们来上个demo，把场景渲染到一个颜色纹理上（这个纹理是附加到我们创建的帧缓冲上的），然后我们把纹理绘制到一个简单的四边形上（这个四边形铺满整个屏幕）。最后输出的图像看似和没用帧缓冲一样，但是其实是直接输出到了一个单独的四边形上面。后面会看到这样做的好处。</p>
<p>首先，我们需要创建一个帧缓冲对象，并绑定它：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    //创建FBO
    GLuint fbo;
    glGenFramebuffers(1, &fbo);
    glBindFramebuffer(GL_FRAMEBUFFER, fbo);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>接下来创建一个纹理附件，它将附加为帧缓冲的颜色缓冲：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    //创建纹理附件
    GLuint texColorBuffer;
    glGenTextures(1, &texColorBuffer);
    glBindTexture(GL_TEXTURE_2D, texColorBuffer);
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, NULL);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glBindTexture(GL_TEXTURE_2D, 0);
    //将纹理附件附加到帧缓冲上
    glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, texColorBuffer, 0);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们还想让OpenGL可以进行深度测试和模板测试，所以我们还需要向帧缓冲中添加一个深度和模板附件。由于我们只采样颜色缓冲，并不采样深度缓冲，所以深度附件可以用渲染缓冲对象来实现。</p>
<p>创建并绑定渲染缓冲对象，同时预分配内存空间：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    //创建渲染缓冲对象
    GLuint rbo;
    glGenRenderbuffers(1, &rbo);
    glBindRenderbuffer(GL_RENDERBUFFER, rbo);
    glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH24_STENCIL8, width, height);
    glBindRenderbuffer(GL_RENDERBUFFER, 0);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后需要把渲染缓冲对象附加到帧缓冲上：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    //将渲染缓冲对象附加到帧缓冲上
    glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_RENDERBUFFER, rbo);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>接下里我们检查一下帧缓冲是否真的做完整了，如果没有就打印一个错误消息：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    //检查帧缓冲是否完整
    if (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE) {
        std::cout << "Framebuffer is not complete!" << std::endl;
    }
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>接着我们就可以把场景渲染到我们所创建的帧缓冲上了。一般按照以下步骤来做：</p>
<ol>
<li>绑定帧缓冲为我们所创建的帧缓冲对象，好场景渲染到我们自己的帧缓冲里。</li>
<li>像往常那样渲染场景</li>
<li>绑定帧缓冲到默认帧缓冲（就是绑定为0）</li>
<li>绘制一个四边形，让它平铺到整个屏幕上，使用前面渲染出来的纹理附件（也就是我们的帧缓冲里的颜色缓冲）作为这个四边形的纹理。</li>
</ol>
<p>为了绘制出铺满窗口的四边形，我们先定义四边形的顶点属性如下：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    //窗口四边形的顶点坐标、纹理坐标
    GLfloat windowQuadVertices[] = {
        //位置坐标
        1.0f, 1.0f,  1.0f,1.0f,
        1.0f,-1.0f,  1.0f,0.0f,
       -1.0f, 1.0f,  0.0f,1.0f,

       -1.0f, 1.0f,  0.0f,1.0f,
        1.0f,-1.0f,  1.0f,0.0f,
       -1.0f,-1.0f,  0.0f,0.0f
    };
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>该四边形的VAO绑定和数据解析如下：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    //窗口四边形windowQuadVAO和数据解析
    GLuint windowQuadVAO, windowQuadVBO;
    glGenVertexArrays(1, &windowQuadVAO);
    glBindVertexArray(windowQuadVAO);
    glGenBuffers(1, &windowQuadVBO);
    glBindBuffer(GL_ARRAY_BUFFER, windowQuadVBO);
    glBufferData(GL_ARRAY_BUFFER, sizeof(windowQuadVertices), windowQuadVertices, GL_STATIC_DRAW);
    glEnableVertexAttribArray(0);
    glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 4 * sizeof(GL_FLOAT), (GLvoid*)0);
    glEnableVertexAttribArray(1);
    glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 4 * sizeof(GL_FLOAT), (GLvoid*)(2 * sizeof(GLfloat)));
    glBindVertexArray(0);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>再给这个四边写一个顶点着色器和像素着色器：<br>四边形的顶点着色器（写在quad.vertex中）</p>
<pre class="line-numbers language-c++"><code class="language-c++">#version 330 core
layout (location=0) in vec2 position;
layout (location=1) in vec2 texCoords;
out vec2 TexCoords;

void main(){
    gl_Position = vec4(position,0.0f,1.0f);
    TexCoords = texCoords;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>四边形的像素着色器（写在quad.fragment中）：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#version 330 core
in vec2 TexCoords;
out vec4 color;

uniform sampler2D texture1;

void main(){
    color = texture(texture1,TexCoords);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>为四边形创建的着色器对象如下：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    shader windowQuad_shader("quad.vertex", "quad.fragment");
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>然后在渲染循环中，我们先把帧缓冲切换为我们自己创建的帧缓冲：</p>
<pre class="line-numbers language-c++"><code class="language-c++">        glBindFramebuffer(GL_FRAMEBUFFER, fbo);
        glClearColor(0.3f, 0.4f, 0.5f, 1.0f);
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
        glEnable(GL_DEPTH_TEST);
        glEnable(GL_CULL_FACE);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>切换成我们自己的帧缓冲对象fbo，同时刷新颜色缓冲、深度缓冲，并且开启深度测试和面剔除。接下来就是照常渲染场景。</p>
<p>场景渲染完后，我们再切换到默认帧缓冲：</p>
<pre class="line-numbers language-c++"><code class="language-c++">        //将帧缓冲切换为默认帧缓冲
        glBindFramebuffer(GL_FRAMEBUFFER, 0);
        glClearColor(1.0f, 1.0f, 1.0f, 1.0f);
        glClear(GL_COLOR_BUFFER_BIT);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>由于我们只需要把一张二维纹理渲染到二维四边形上，所以不需要深度测试和面剔除，应该关掉：</p>
<pre class="line-numbers language-c++"><code class="language-c++">        glDisable(GL_DEPTH_TEST);
        glDisable(GL_CULL_FACE);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>接下来就是渲染这个铺满窗口的四边形了：</p>
<pre class="line-numbers language-c++"><code class="language-c++">        windowQuad_shader.Use();
        glBindVertexArray(windowQuadVAO);
        glBindTexture(GL_TEXTURE_2D, texColorBuffer);
        glDrawArrays(GL_TRIANGLES, 0, 6);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>在渲染四边形之前，我们给它绑定了在自定义帧缓冲中已经渲染好的纹理（附件）。</p>
<p>编译运行后的结果如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148499563004.png" alt=""><br>全部源码<a href="https://github.com/Popperelay/BlogCode/tree/master/LearnOpenGL19_FrameBuffer" target="_blank" rel="external">在这里</a>。<br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">后期处理</font><br>现在，我们把整个场景渲染到了一个单独的纹理上，只需要简单操纵纹理数据，我么就能创建一些有趣的效果。下面，会展示出一些流行的后期处理（Post-processing）特效。</p>
<p><font size="4" color="red">反相</font><br>我们已经在纹理上存储了渲染输出的每个颜色，可以在四边形的像素着色器中用1减去每个颜色，就能得到这些颜色的反射：</p>
<pre class="line-numbers language-c++"><code class="language-c++">void main(){
    color = 1.0 - texture(texture1,TexCoords);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>编译运行后的结果如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148499950269.png" alt=""><br>想象一下，如果不先把场景渲染到纹理上，而是用我们之前的直接渲染到默认帧缓冲里，要实现这种效果，那我们就得在每一种着色器中去做上面的反色操作（每一种物体可能都有它们各自的着色器）。</p>
<p><font size="4" color="red">灰度</font><br>另一个有意思的效果是把整个场景图像变成黑白的。实现它的简单方式是获得每一个颜色分量，然后将它们平均化：</p>
<pre class="line-numbers language-c++"><code class="language-c++">void main(){
    color = texture(texture1,TexCoords);
    float average = (color.r + color.g + color.b)/3;
    color = vec4(average,average,average,1.0f);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>编译运行后的结果如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148499950349.png" alt=""><br>&nbsp;</p>
<hr>
<p>在单独纹理图像上进行后处理的另一个好处是我们可以从纹理的其他部分进行采样。比如我们可以从当前纹理值的周围采样多个纹理值。这样我们可以使用一些图像处理技巧，来实现很多后处理效果。比如接下来的后处理效果中的Kernel效果。</p>
<p><font size="5" color="orange">Kernel effects</font><br>kernel是一个长得有点像一个小矩阵的数值数组，通常是一个3x3的矩阵，而且所有元素加起来的和通常等于1。</p>
<p><font size="4" color="red">锐化Kernel：麻醉效果</font><br>下面是一个锐化Kernel的例子：<br>$$<br>\begin{bmatrix}-1 &amp; -1 &amp; -1 \\ -1 &amp; 9 &amp; -1 \\ -1 &amp; -1 &amp; -1 \end{bmatrix}<br>$$<br>通过Kernel矩阵，将当前纹素扩展到周围9个纹素，然后通过加权和得到最终的当前片段颜色。</p>
<p>为了得到当前片段周围的9个纹素值，我们需要知道这9个纹素的坐标是多少，然后才能通过采样取得纹素值。所以，我们先定义一个纹理坐标偏移量，就是这9个纹理坐标离中心纹素坐标的偏移量：</p>
<pre class="line-numbers language-c++"><code class="language-c++">//离中心纹素的s或t距离
const float offset = 1.0/300;

void main(){
    //9个纹素的坐标偏移量
    vec2 offsets[9] =vec2[](
        vec2(-offset, offset),  // top-left
        vec2(0.0f,    offset),  // top-center
        vec2(offset,  offset),  // top-right
        vec2(-offset, 0.0f),    // center-left
        vec2(0.0f,    0.0f),    // center-center
        vec2(offset,  0.0f),    // center-right
        vec2(-offset, -offset), // bottom-left
        vec2(0.0f,    -offset), // bottom-center
        vec2(offset,  -offset)  // bottom-right
    );
    ...
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>接着我们就可以用这9个纹素坐标偏移量，采样得到周围9个纹素值了：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    //当前纹素周围的9个纹素
    vec3 sampleTex[9];
    for(int i=0;i<9;i++){
        sampleTex[i] = vec3(texture(texture1,TexCoords.st + offsets[i]));
    }
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们定义的Kernel矩阵如下：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    float kernel[9] = float[](
        -1, -1, -1,
        -1,  9, -1,
        -1, -1, -1
    );
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>片段的最终颜色应该是在Kernel矩阵作用下的，9个周围像素的加权和：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    vec3 col;
    //kernel矩阵作用下的加权和
    for(int i=0;i<9;i++){
        col += sampleTex[i] * kernel[i];
    }
    color = vec4(col,1.0f);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>四边形的像素着色器完整源码如下：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#version 330 core
in vec2 TexCoords;
out vec4 color;

uniform sampler2D texture1;

//离中心纹素的s或t距离
const float offset = 1.0/300;

void main(){
    //9个纹素的坐标偏移量
    vec2 offsets[9] =vec2[](
        vec2(-offset, offset),  // top-left
        vec2(0.0f,    offset),  // top-center
        vec2(offset,  offset),  // top-right
        vec2(-offset, 0.0f),    // center-left
        vec2(0.0f,    0.0f),    // center-center
        vec2(offset,  0.0f),    // center-right
        vec2(-offset, -offset), // bottom-left
        vec2(0.0f,    -offset), // bottom-center
        vec2(offset,  -offset)  // bottom-right
    );
    //当前纹素周围的9个纹素
    vec3 sampleTex[9];
    for(int i=0;i<9;i++){
        sampleTex[i] = vec3(texture(texture1,TexCoords.st + offsets[i]));
    }
    float kernel[9] = float[](
        -1, -1, -1,
        -1,  9, -1,
        -1, -1, -1
    );
    vec3 col;
    //kernel矩阵作用下的加权和
    for(int i=0;i<9;i++){
        col += sampleTex[i] * kernel[i];
    }
    color = vec4(col,1.0f);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>编译运行后的结果如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148499950443.png" alt=""><br>这是一个锐化的Kernel，就好像玩家吞了麻醉剂产生的幻觉一样。</p>
<p><font size="4" color="red">kernel模糊效果Blur</font><br>创建模糊效果的kernel如下：<br>$$<br>\begin{bmatrix} 1 &amp; 2 &amp; 1 \\ 2 &amp; 4 &amp; 2 \\ 1 &amp; 2 &amp; 1 \end{bmatrix} / 16<br>$$<br>我们像素着色器里的kernel数组现在变成：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    float kernel[9] = float[](
        1.0 / 16, 2.0 / 16, 1.0 / 16,
        2.0 / 16, 4.0 / 16, 2.0 / 16,
        1.0 / 16, 2.0 / 16, 1.0 / 16 
    );
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>编译运行后的结果如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148499950506.png" alt=""></p>
<p><font size="4" color="red">kernel边缘检测效果</font><br>边缘检测的kernel矩阵如下，和锐化kernel有点像：<br>$$<br>\begin{bmatrix} 1 &amp; 1 &amp; 1 \\ 1 &amp; -8 &amp; 1 \\ 1 &amp; 1 &amp; 1 \end{bmatrix}<br>$$<br>现在的kernel数组变为：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    float kernel[9] = float[](
        1, 1, 1,
        1,-8, 1,
        1, 1, 1
    );
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>编译运行后的结果如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/14849995058.png" alt=""><br>当偏移量offset不同时，效果会有所改变。更多kernel效果可查看<a href="http://setosa.io/ev/image-kernels/" target="_blank" rel="external">Image Kernels</a>。<br>&nbsp; </p>
<hr>
<p>参考文献：<a href="https://learnopengl.com/" target="_blank" rel="external">LearnOpenGL</a></p>
]]></content>
      
        <categories>
            
            <category> OpenGL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 帧缓冲 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OpenGL18：背面剔除]]></title>
      <url>/2017/01/18/OpenGL18%E8%83%8C%E9%9D%A2%E5%89%94%E9%99%A4/</url>
      <content type="html"><![CDATA[<p>对于一个立方体，从任何一个方向最多只能看到3个面，那我们为何还需要去绘制那3个看不到的面呢？如果我们可以以某种方式丢弃它们，那我们至少会为像素着色器提高50%的性能！<br><a id="more"></a><br>我们如何知道哪个面是能看到的（即正面，朝向观察者），哪个面是不能看到的（即背面，背对观察者）呢？</p>
<p>【注】：</p>
<ul>
<li>一个三角形相对于观察者只可能是正面或者背面，不可能既是正面又是背面</li>
<li>这里所说的正面背面都是相对于封闭形状来说的，能够看到的是正面，被挡住的是背面。</li>
<li>后面说到的三角形，请带入封闭形状里考虑，不然一个单独的三角形是不存在正面、背面之说的。<br>&nbsp; </li>
</ul>
<hr>
<p><font size="5" colorr="orange">顶点绕序</font><br>我们需要丢弃背对观察者的三角形片元，那如何确定一个面是否背对观察者呢？OpenGL使用顶点绕序（winding order）来解决这个问题。</p>
<p>顶点绕序就是当几何对象细分为三角形时，三角形顶点相对于中心的定义顺序，如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148472939189.png" alt=""><br>左图中的顶点绕序是顺时针的，右边是逆时针的。</p>
<p>默认情况下，OpenGL认为三角形的正面都是逆时针的顶点绕序，顺时针的顶点绕序都是三角形的背面，背对观察者。</p>
<p>我们在定义顶点属性数据时，需要从三角形的正面看过去（保证能够看到三角形），以逆时针绕序进行定义。如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148473026998.png" alt=""><br>右边的三角形顶点和左边的三角形顶点都是以逆时针顺序进行定义的，它们在各自的方向上都能被看到：右边的三角形从右边能够被看到，左边的三角形从左边能够被看到。但是如果现在观察点在右边，OpenGL会根据三角形顶点被定义的顺序，来计算相对于观察者来说这个顺序是逆时针还是顺时针。如果是逆时针，说明该面是正面，朝向观察者；如果是顺时针，说明该面是背面，背对观察者。根据三角形顶点的本身绕序，来计算相对于观察者的相对绕序（即相对于观察者是逆时针/顺时针），这是在光栅化阶段由OpenGL自动完成的。<br>&nbsp; </p>
<hr>
<p><font size="5" color="orange">在OpenGL中使用背面剔除</font><br>首先，我们需要把立方体每个面的顶点按逆时针顺序去定义。注意，一定要从正面去看立方体的每个面，这时再去确定逆时针顺序的顶点。由于我们是用索引去绘制立方体，所以只需要按逆时针指定索引就可以了:</p>
<pre class="line-numbers language-c++"><code class="language-c++">    //三角形顶点的坐标、纹理坐标
    GLfloat cubeVertices[] = {
        //位置坐标          //纹理坐标
        //立方体前面
        0.5f, 0.5f, 0.5f,   1.0f,1.0f,
        0.5f,-0.5f, 0.5f,   1.0f,0.0f,
       -0.5f,-0.5f, 0.5f,   0.0f,0.0f,
       -0.5f, 0.5f, 0.5f,   0.0f,1.0f,
        //立方体后面
        0.5f, 0.5f,-0.5f,   1.0f,1.0f,
        0.5f,-0.5f,-0.5f,   1.0f,0.0f,
       -0.5f,-0.5f,-0.5f,   0.0f,0.0f,
       -0.5f, 0.5f,-0.5f,   0.0f,1.0f,
        //立方体上面
        0.5f, 0.5f, 0.5f,   1.0f,1.0f, 
        0.5f, 0.5f,-0.5f,   1.0f,0.0f,
       -0.5f, 0.5f,-0.5f,   0.0f,0.0f,
       -0.5f, 0.5f, 0.5f,   0.0f,1.0f,
        //立方体下面
        0.5f,-0.5f, 0.5f,   1.0f,1.0f,
        0.5f,-0.5f,-0.5f,   1.0f,0.0f,
       -0.5f,-0.5f,-0.5f,   0.0f,0.0f,
       -0.5f,-0.5f, 0.5f,   0.0f,1.0f,
        //立方体右面
        0.5f, 0.5f, 0.5f,   1.0f,1.0f,
        0.5f, 0.5f,-0.5f,   1.0f,0.0f,
        0.5f,-0.5f,-0.5f,   0.0f,0.0f,
        0.5f,-0.5f, 0.5f,   0.0f,1.0f,
        //立方体左面
       -0.5f, 0.5f, 0.5f,   1.0f,1.0f,
       -0.5f, 0.5f,-0.5f,   1.0f,0.0f,
       -0.5f,-0.5f,-0.5f,   0.0f,0.0f,
       -0.5f,-0.5f, 0.5f,   0.0f,1.0f
    };
    //顶点索引
    GLuint cubeIndices[] = {
        //立方体前面
        0,3,1,
        1,3,2,
        //立方体后面
        4,5,7,
        5,6,7,
        //立方体上面
        8,9,11,
        9,10,11,
        //立方体下面
        12,15,13,
        13,15,14,
        //立方体右面
        16,19,17,
        17,19,18,
        //立方体左面
        20,21,23,
        21,22,23
    };
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后，我们需要开启面剔除：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    //开启面剔除
    glEnable(GL_CULL_FACE);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>编译运行后，所有不是正面朝向观察者的面都会被丢弃，尝试移动摄像机到箱子里面，会发现看不到箱子了：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148474153975.png" alt=""><br>如果不开启背面剔除，运行的结果会是这样：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148474154426.png" alt=""><br>目前，因为使用了背面剔除，在渲染片段上我们节约了超过50%的性能，但记住这只对像立方体这样的封闭形状有效。</p>
<p>所有源码<a href="https://github.com/Popperelay/BlogCode/tree/master/LearnOpenGL18_FaceCulling" target="_blank" rel="external">在这里</a>。<br>&nbsp; </p>
<hr>
<p><font size="5" color="orange">更多剔除</font></p>
<p><font size="4" color="red">还可以剔除正面</font><br>OpenGL默认是剔除背面三角形，但是也可以使用<code>glCullFace</code>函数来剔除正面等：</p>
<pre class="line-numbers language-c++"><code class="language-c++">glCullFace(GL_FRONT);
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>该函数的参数有一下三个可选项：</p>
<ul>
<li>GL_BACK：只剔除背面</li>
<li>GL_FRONT：只剔除正面</li>
<li>GL_FRONT_AND_BACK：剔除正面和背面</li>
</ul>
<p><font size="4" color="red">正面也可以是顺时针</font><br>之前我们使用逆时针来代表正面，其实也可以通过<code>glCullFace</code>函数来设置顺时针代表正面：</p>
<pre class="line-numbers language-c++"><code class="language-c++">glFrontFace(GL_CW);
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>默认值是<code>GL_CCW</code>，表示逆时针，<code>GL_CW</code>表示顺时针。<br>&nbsp; </p>
<hr>
<p>参考文献：<a href="https://learnopengl.com/" target="_blank" rel="external">LearnOpenGL</a></p>
]]></content>
      
        <categories>
            
            <category> OpenGL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 背面剔除 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OpenGL17：混合]]></title>
      <url>/2017/01/17/OpenGL17%E6%B7%B7%E5%90%88/</url>
      <content type="html"><![CDATA[<p>在OpenGL中，物体透明技术通常被叫做混合（Blending）。<a id="more"></a><br>&nbsp; </p>
<hr>
<p><font size="5" color="orange">透明</font><br>透明是指物体自身颜色与它背面物体颜色不同程度的混合，而在OpenGL中就是使用混合技术来实现的，将当前要绘制的物体的颜色和颜色缓冲区中已经绘制了的物体颜色进行混合，最终决定当前物体的颜色。下图是一副全透明和半透明的窗子：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148462342512.png" alt=""><br>物体的透明度是由片段颜色的alpha值（颜色向量的第4个元素）决定的，全透明的alpha值是0.0即透明度是100%，不透明的alpha值是1.0即透明度是0%。<br>&nbsp; </p>
<hr>
<p><font size="5" color="orange">丢弃片段来实现全透明</font><br>有些纹理是纹理部分要么全透明，要么不透明，不存在半透明的部分。如下面的草纹理，它没有半透明的部分：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148463674953.png" alt=""><br>对于这种纹理，我们可以直接丢弃全透明部分的片段，没有必要将它存储到颜色缓冲中，更没有必要使用混合技术。</p>
<p>首先，我们需要更改一下SOIL加载图片的方式，我们需要以RGBA的方式去加载带有alpha值的纹理（如果某些像素没有alpha值将会被设为1.0）：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    //加载纹理图像
    unsigned char* image = SOIL_load_image(texturePath, &imageWidth, &imageHeight, 0, SOIL_LOAD_RGBA);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>不要忘记还要改变OpenGL生成纹理的方式：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    //生成2D纹理
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, imageWidth, imageHeight, 0, GL_RGBA, GL_UNSIGNED_BYTE, image);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>绘制草的着色器很简单，仅仅是让片段颜色等于纹素颜色而已，代码如下：<br>顶点着色器（写在grass.vertex中）：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#version 330 core
layout (location=0) in vec3 position;
layout (location=1) in vec2 texCoords;

out vec2 TexCoords;

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;

void main(){
    gl_Position = projection * view * model * vec4(position,1.0f);
    TexCoords = vec2(texCoords.x ,1 - texCoords.y); 
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>像素着色器（写在grass.fragment中）：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#version 330 core
in vec2 TexCoords;
out vec4 color;

uniform sampler2D texture1;

void main(){
    color = texture(texture1,TexCoords);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>设置草平面的顶点属性如下：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    //草平面的顶点属性（位置坐标、纹理坐标）
    GLfloat grass_vertices[] = {
        //顶点位置坐标    //纹理坐标
        0.5f, 0.5f, 0.0f, 1.0f,1.0f,
        0.5f,-0.5f, 0.0f, 1.0f,0.0f,
       -0.5f, 0.5f, 0.0f, 0.0f,1.0f,

        0.5f,-0.5f, 0.0f, 1.0f,0.0f,
       -0.5f, 0.5f, 0.0f, 0.0f,1.0f,
       -0.5f,-0.5f, 0.0f, 0.0f,0.0f,

    };
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>接下来需要对它进行VAO绑定和数据解析：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    //草平面顶点数据的绑定和解析
    GLuint grassVAO, grassVBO;
    glGenVertexArrays(1, &grassVAO);
    glBindVertexArray(grassVAO);
    glGenBuffers(1, &grassVBO);
    glBindBuffer(GL_ARRAY_BUFFER, grassVBO);
    glBufferData(GL_ARRAY_BUFFER, sizeof(grass_vertices), grass_vertices, GL_STATIC_DRAW);
    glEnableVertexAttribArray(0);
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 5 * sizeof(GL_FLOAT), (GLvoid*)0);
    glEnableVertexAttribArray(1);
    glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 5 * sizeof(GL_FLOAT), (GLvoid*)(3 * sizeof(GL_FLOAT)));
    glBindVertexArray(0);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>还需要加载草纹理：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    TextureLoader texLoader;
    GLuint grassTexture = texLoader.LoadTexture("grass.png");
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>由于要绘制多株草，我们给每株草设置不同的位置：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    //草的位置
    vector<vec3> grass_location;
    grass_location.push_back(vec3(-1.5f, 0.0f, -0.48f));
    grass_location.push_back(vec3(1.5f, 0.0f, 0.51f));
    grass_location.push_back(vec3(0.0f, 0.0f, 0.7f));
    grass_location.push_back(vec3(-0.3f, 0.0f, -2.3f));
    grass_location.push_back(vec3(0.5f, 0.0f, -0.6f));
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>为了绘制草所定义的着色器对象如下：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    shader grass_shader("grass.vertex", "grass.fragment");
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>最后就是在渲染循环里绘制几株草了：</p>
<pre class="line-numbers language-c++"><code class="language-c++">        //绘制几株草
        glBindVertexArray(grassVAO);
        glBindTexture(GL_TEXTURE_2D, grassTexture);
        for (int i = 0; i < grass_location.size(); i++) {
            model = mat4();
            model = translate(model, grass_location[i]);
            glUniformMatrix4fv(glGetUniformLocation(grass_shader.shaderProgram, "model"), 1, GL_FALSE, value_ptr(model));
            glDrawArrays(GL_TRIANGLES, 0, 6);
        }
        glBindVertexArray(0);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>编译运行后的结果如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/14846367522.png" alt=""><br>出现这种结果是因为OpenGL默认是不知道如何处理alpha值得，需要我们自己来设置。在像素着色器中，当片段的alpha值小于某一指定值时，就使用discard命令丢弃它。discard是GLSL为我们提供的用于丢弃片段的命令：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#version 330 core
in vec2 TexCoords;
out vec4 color;

uniform sampler2D texture1;

void main(){
    vec4 texColor = texture(texture1,TexCoords);
    if(texColor.a < 0.1)
        discard;
    color=texColor;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>编译运行后的结果如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148463921017.png" alt=""><br>可以看到绘制出来的每张草纹理上方会有一个白边，这是因为我们的纹理设置得是REPEAT环绕方式，在采样纹理边缘的时候，OpenGL会在该边缘和环绕的下一张重复纹理的边缘之间插值，这里上方的白边就是草纹理的透明上边缘和下边缘（绿色）插值的结果。为了防止四周这种白边的出现，我们需要把纹理环绕方式设置为<code>GL_CLAMP_TO_EDGE</code>：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    //设置纹理s和t方向的环绕方式
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>编译运行后的结果如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148463922702.png" alt=""><br>草确实没有了白边，但是地面很诡异了，地面纹理边缘也被拉伸了。地面纹理和草纹理应该是不同的环绕方式，所以，我们给TextureLoader类的<code>LoadTexture</code>函数加一个参数，表示s和t方向上的环绕方式，函数声明如下：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    GLuint LoadTexture(const GLchar* texturePath, GLint wrap_st = GL_REPEAT);
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>在<code>LoadTexture</code>函数的实现中，就用这个<code>wrap_st</code>参数来设置纹理环绕方式：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    //设置纹理s和t方向的环绕方式
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, wrap_st);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, wrap_st);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>现在加载草纹理和地面纹理应该是这样：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    TextureLoader texLoader;
    GLuint grassTexture = texLoader.LoadTexture("grass.png", GL_CLAMP_TO_EDGE);
    GLuint planeTexture = texLoader.LoadTexture("container.jpg");
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>编译运行后的结果如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148463924882.png" alt=""><br>所有源码<a href="https://github.com/Popperelay/BlogCode/tree/master/LearnOpenGL17_Blend/LearnOpenGL17_Blend_1" target="_blank" rel="external">在这里</a>。<br>&nbsp; </p>
<hr>
<p><font size="5" color="orange">混合原理</font><br>上诉丢弃片段的方式，虽然可以实现全透明效果，但是不能渲染半透明图像。为了能够实现半透明，我们需要先开启混合：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    //开启混合
    glEnable(GL_BLEND);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><font size="4" color="red">混合方程</font><br>OpenGL是按照以下混合方程进行混合的：<br>$$<br>\begin{equation}<br>Result=source*sFactor+destination*dFactor<br>\end{equation}<br>$$<br>source是源颜色向量，是将要绘制的纹理的颜色向量；destination是目标颜色向量，是存储在颜色缓冲中当前位置的颜色向量。sFactor和dFactor分别是对源颜色目标颜色的影响系数。</p>
<p>系数着色器运行完成并且所有的测试都通过以后，混合方程才开始执行。方程中的源和目标颜色会自动被OpenGL设置，而源和目标颜色的影响因子是由我们来设置的。比如现在有以下两个方块（或者说放大了的片段）：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148464152063.png" alt=""><br>我们希望在红色方块上绘制绿色方块。红色方块将是目标颜色（它会先进入颜色缓冲中），绿色方块将是源颜色。如果我们把源颜色影响因子设为源颜色的alpha值0.6， 把目标颜色影响因子设为剩下（1-0.6），那么混合方程将是：<br>$$<br>\begin{equation}<br>Result =<br>\begin{pmatrix}<br>0.0 \\<br>1.0 \\<br>0.0 \\<br>0.6<br>\end{pmatrix}<br>* 0.6 +<br>\begin{pmatrix}<br>1.0 \\<br>0.0 \\<br>0.0 \\<br>1.0 \\<br>\end{pmatrix}<br>* (1 - 0.6)<br>\end{equation}<br>$$<br>最终方块将包含60%的绿色和40的红色：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/14846421609.png" alt=""></p>
<p><font size="4" color="red">设置源和目标颜色的影响因子</font><br>我们使用<code>glBlendFunc</code>函数来设置这两个影响因子，函数原型如下：</p>
<pre class="line-numbers language-c++"><code class="language-c++">void glBlendFunc(GLenum sfactor, GLenum dfactor)
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这两个参数可以设置为下列选项：<br><img src="" alt=""><br>为了获得混合效果，把源颜色的alpha给源因子，1-alpha给目标因子：</p>
<pre class="line-numbers language-c++"><code class="language-c++">glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><code>glBlendFunc</code>函数是为R、G、B、A这四个分量都设置了相同的影响因子。其实我们还可以不用混合方程，直接使用<code>glBlendFuncSeperate</code>函数为最终颜色的每个分量设置一个值，例如：</p>
<pre class="line-numbers language-c++"><code class="language-c++">glBlendFuncSeperate(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA,GL_ONE, GL_ZERO);
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><font size="4" color="red">混合方程不止于加</font><br>我们之前给的混合方程是源颜色和目标颜色按比例相加，其实还可以是减、逆序减。这需要用到<code>glBlendEquation</code>函数。函数原型如下：</p>
<pre class="line-numbers language-c++"><code class="language-c++">void glBlendEquation(GLenum mode)
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>它的参数有以下选项：</p>
<ul>
<li>GL_FUNC_ADD：相加，这是默认的，$Result = Src + Dst$。</li>
<li>GL_FUNC_SUBTRACT：相减，$Result = Src - Dst$。</li>
<li>GL_FUNC_REVERSE_SUBTRACT：反过来相减，$Result = Dst - Src$。<br>通常可以省略<code>glBlendEquation</code>函数，因为大多数时候我们需要的混合效果都是相加的，这恰好是默认的。<br>&nbsp; </li>
</ul>
<hr>
<p><font size="5" color="orange">渲染半透明纹理</font><br>现在我们开始用OpenGL来渲染下面这个半透明的窗子：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/14846446012.png" alt=""></p>
<p>首先我们需要开启混合，并设置合适的混合方程：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    //开启混合
    glEnable(GL_BLEND);
    //混合方程
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里是让源颜色影响因子等于源颜色的alpha值，目标颜色的影响因子等于1-源颜色的alpha。</p>
<p> 现在我们是用混合来绘制半透明窗子的，不需要丢弃片段了，将像素着色器改回来：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#version 330 core
in vec2 TexCoords;
out vec4 color;

uniform sampler2D texture1;

void main(){
    /*vec4 texColor = texture(texture1,TexCoords);
    if(texColor.a < 0.1)
        discard;
    color=texColor;*/
    color = texture(texture1,TexCoords);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>编译运行后的结果如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148464557355.png" alt=""><br>&nbsp; </p>
<hr>
<p>但是有个很明显的问题，前面的窗子并不能透明显示后面的窗子。这是因为深度测试并不关心alpha值，所以前面的窗子就会挡住后面的窗子，即使前面的窗子是透明的，它也会把后面窗子被挡住的片段丢弃。</p>
<p><font size="5" color="orange">由远及近地绘制透明物体</font><br>对于包含不透明和透明物体的场景，绘制顺序应该是：</p>
<ol>
<li>首先绘制不透明物体</li>
<li>先绘制离摄像机远的透明物体，再绘制近的透明物体</li>
</ol>
<p>如果由远及近地绘制透明物体，那么在绘制近一些的透明物体时，就会混合远处的透明物体，最终会产生正确的结果。</p>
<p>几个窗子的位置如下：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    //窗子的位置
    vector<vec3> window_location;
    window_location.push_back(vec3(-1.5f, 0.0f, -0.48f));
    window_location.push_back(vec3(1.5f, 0.0f, 0.51f));
    window_location.push_back(vec3(0.0f, 0.0f, 0.7f));
    window_location.push_back(vec3(-0.3f, 0.0f, -2.3f));
    window_location.push_back(vec3(0.5f, 0.0f, -0.6f));
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们以窗子到摄像机的距离作为键，以窗子的位置作为键对应的值，会 建键值对数据结构map，map会自动对键进行排序，也就是map会自动排序窗子到摄像机的距离。<br>【注】：</p>
<ul>
<li>map是STL库中的数据结构，是键值对的集合，可以用键作为下标来访问对应的值。</li>
</ul>
<p>在渲染循环中，我们创建一个map，并且把窗子到摄像机的距离作为键，把当前窗子作为键对应的值： </p>
<pre class="line-numbers language-c++"><code class="language-c++">        //把多个窗子位置存入map数据结构中，以窗子到摄像机的距离为键
        map<float, vec3> sortedWindow;
        for (int i = 0; i < window_location.size(); i++) {
            GLfloat distance = length(mycamera.cameraPos - window_location[i]);
            sortedWindow[distance] = window_location[i];
        }
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在绘制时，我们逆序遍历这个map，就能由远及近地绘制出每个窗子：</p>
<pre class="line-numbers language-c++"><code class="language-c++">        //逆序访问键值对map，由远及近地绘制透明窗子
        for (map<float, vec3>::reverse_iterator it = sortedWindow.rbegin(); it != sortedWindow.rend(); ++it) {
            model = mat4();
            model = translate(model, it->second);
            glUniformMatrix4fv(glGetUniformLocation(grass_shader.shaderProgram, "model"), 1, GL_FALSE, value_ptr(model));
            glDrawArrays(GL_TRIANGLES, 0, 6);
        }
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>reverse_iterator</code>是逆序迭代器，<code>it-&gt;second</code>是键值对中的第二个元素，这里就是键对应的值，窗子的位置。</p>
<p>编译运行后的结果如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148465013058.png" alt=""></p>
<p>全部源码<a href="https://github.com/Popperelay/BlogCode/tree/master/LearnOpenGL17_Blend/LearnOpenGL17_Blend_2" target="_blank" rel="external">在这里</a>。</p>
<p>在这个场景里，我们是按照窗子到摄像机的距离来由远及近地排序的，但是这种方法不是通用的。我们这个场景里所有的窗子都是相互平行，没有交叉折叠的，如果物体比较奇怪复杂，就需要其他排序方式了。对场景中的物体进行排序是很有难度的，完美地渲染带透明和不透明物体的场景也不那么容易，如果感兴趣可以了解一些更高级的技术，比如次序无关透明度（order independent transparency）。<br>&nbsp; </p>
<hr>
<p>参考文献：<a href="https://learnopengl.com/" target="_blank" rel="external">LearnOpenGL</a></p>
]]></content>
      
        <categories>
            
            <category> OpenGL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 混合 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OpenGL16：模板测试]]></title>
      <url>/2017/01/15/OpenGL16%E6%A8%A1%E6%9D%BF%E6%B5%8B%E8%AF%95/</url>
      <content type="html"><![CDATA[<p><font size="5" color="orange">什么是模板测试</font><br><a id="more"></a><br>当像素着色器处理完片段之后，深度测试之前，模板测试（stencil test）就开始执行了，和深度测试一样，它能丢弃一些片段：如果片段的模板值和当前模板缓冲区的对应位置上的模板值，满足指定关系，则不会被丢弃。这就是模板测试。仍然保留下来的片段将进入深度测试阶段，深度测试又会丢弃一些片段。</p>
<p>在渲染管线里包括很多种测试，它们的执行顺序如下图：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148440287648.png" alt=""><br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">模板缓冲</font><br>模板缓冲类似于颜色缓冲和深度缓冲，不过模板值通常是8位的，每个片段可以有256种不同的模板值（最大值255）</p>
<p><font size="4" color="red">模板缓冲的作用</font><br>下面举一个模板缓冲的简单例子：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148440287724.png" alt=""><br>左边的场景在中间的模板作用下，只有对应模板值为1的片段才会被显示，不为1的片段都被丢弃了，最终呈现右图的结果。</p>
<p>可以看到，使用模板缓冲，我们可以根据模板值对决定是否丢弃特定的片段。<br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">使用模板缓冲</font><br>使用模板缓冲的步骤一般如下：</p>
<ol>
<li>开启模板测试</li>
<li>绘制模板，写入模板缓冲（不写入color buffer和depth buffer）</li>
<li>关闭模板缓冲写入</li>
<li>利用模板缓冲中的值，绘制后续场景</li>
</ol>
<p>首先我们需要开启模板测试：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    glEnable(GL_STENCIL_TEST);
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>而且像颜色缓冲和深度缓冲一样，每次渲染循环之前，需要先清空模板缓冲：</p>
<pre class="line-numbers language-c++"><code class="language-c++">        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>同样，和深度测试的<code>glDepthMask</code>函数一样，模板缓冲也有一个类似的函数<code>glStencilMask</code>，它用于控制模板缓冲区的写入，使用位掩码的方式决定是否可以写入模板缓冲区。使用的较多的是0x00表示禁止写入，0xFF表示允许任何写入：</p>
<pre class="line-numbers language-c++"><code class="language-c++">// 0xFF == 0b11111111
//此时，模板值与它进行按位与运算结果是模板值，模板缓冲可写
glStencilMask(0xFF);

// 0x00 == 0b00000000 == 0
//此时，模板值与它进行按位与运算结果是0，模板缓冲不可写
glStencilMask(0x00);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><font size="4" color="red">模板函数</font><br>和深度测试一样，对于模板测试，我们也可以选择在什么条件下通过模板测试（使用<code>glStencilFunc</code>函数来完成），而且还可以选择以何种方式更新模板缓冲（比如通过模板测试后模板值不变、讲模板值变为0或者替换为另一个值等等，这使用<code>glStencilOp</code>函数来完成）。</p>
<ul>
<li><p><code>glStencilFunc</code>函数（指定模板测试通过条件）：<br>函数原型：<code>void glStencilFunc(GLenum func,GLint ref,GLuint mask)</code>：</p>
<ul>
<li>参数func：和深度测试一样，指定在什么条件通过模板测试，可用选项有：<code>GL_NEVER</code>、<code>GL_LEQUAL</code>、<code>GL_GREATER</code>、<code>GL_GEQUAL</code>、<code>GL_EQUAL</code>、<code>GL_NOTEQUAL</code>、<code>GL_ALWAYS</code>。</li>
<li>参数ref：和当前模板模板缓冲中的值stencil进行比较的指定值。</li>
<li>参数mask：指定一个遮罩，在比较时，分别与指定值ref和缓冲中的模板值stencil进行按位与操作，初始值为1。</li>
</ul>
<p>【注】：</p>
<ul>
<li>比较的方式是：如果func指定的是在<code>GL_LESS</code>条件下通过测试，其实是在<code>(ref &amp; mask) &lt; (stencil &amp; mask)</code>的条件下才通过测试；如果指定的是<code>GL_GEQUAL</code>，就相当于<code>(ref &amp; mask) &gt;= (stencil &amp; mask)</code>。</li>
</ul>
<p>为了比较时简单直接，我们通常将mask设为0xFF：</p>
<pre class="line-numbers language-c++"><code class="language-c++">  glStencilFunc(GL_EQUAL, 1, 0xFF);
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>表示当前模板缓冲区中值为1的部分通过模板测试，这部分片元将被保留，其余的则被丢弃。</p>
</li>
<li><p><code>glStencilOp</code>函数（指定模板缓冲更新方式）：<br>函数原型：<code>void glStencilOp(GLenum sfail, GLenum dpfail, GLenum dppass)</code>：</p>
<ul>
<li>参数sfail：如果模板测试失败将采取的动作</li>
<li>参数dpfail：如果模板测试通过，但是深度测试失败时采取的动作</li>
<li>参数dppass：如果模板测试和深度测试都通过，将采取的动作</li>
</ul>
<p>这三个参数是同一种枚举类型，每个参数都可以使用下列任何一个动作，来更新模板缓冲：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/14844482123.png" alt=""><br>&nbsp;</p>
</li>
</ul>
<hr>
<p><font size="5" color="orange">绘制矩形模板</font><br>首先我们设置好矩形的顶点属性并解析：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    //模板矩形的顶点坐标
    GLfloat stencilRectVertices[] = {
        0.5f,  0.5f, 0.0f,
        0.5f, -0.5f, 0.0f,
       -0.5f,  0.5f, 0.0f,

       -0.5f,  0.5f, 0.0f,
        0.5f, -0.5f, 0.0f,
       -0.5f, -0.5f, 0.0f
    };
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">    //模板矩形stencilRectVAO和数据解析
    GLuint stencilRectVAO, stencilRectVBO;
    glGenVertexArrays(1, &stencilRectVAO);
    glBindVertexArray(stencilRectVAO);
    glGenBuffers(1, &stencilRectVBO);
    glBindBuffer(GL_ARRAY_BUFFER, stencilRectVBO);
    glBufferData(GL_ARRAY_BUFFER, sizeof(stencilRectVertices), &stencilRectVertices, GL_STATIC_DRAW);
    glEnableVertexAttribArray(0);
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(GL_FLOAT), (GLvoid*)0);
    glBindVertexArray(0);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>画这个模板矩形，当然也需要着色器（最简单的那种着色器就可以）：<br>模板矩形的顶点着色器（写在stencilRect.vertex中）：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#version 330 core
layout (location=0) in vec3 position;

void main(){
    gl_Position = vec4(position,1.0f);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>模板矩形的像素着色器（写在stencilRect.fragment中）</p>
<pre class="line-numbers language-c++"><code class="language-c++">#version 330 core
out vec4 color;

void main(){
    color = vec4(1.0f);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当然，需要开启模板缓冲：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    glEnable(GL_STENCIL_TEST);
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>在渲染循环开始的时候，清除模板缓冲区：</p>
<pre class="line-numbers language-c++"><code class="language-c++">        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>我们将要绘制一个矩形，用它来更新模板缓冲，但是不希望这个矩形被显示出来，所以绘制矩形之前需要先用掩码禁用颜色缓冲和深度缓冲：</p>
<pre class="line-numbers language-c++"><code class="language-c++">        glColorMask(GL_FALSE, GL_FALSE, GL_FALSE, GL_FALSE);
        glDepthMask(GL_FALSE);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>然后我们使用位掩码设置允许模板缓冲区写入：</p>
<pre class="line-numbers language-c++"><code class="language-c++">        glStencilMask(0xFF);
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>接下来我们设置将要绘制的矩形片段总是通过模板测试，而且通过测试之后，把对应模板值设为1：</p>
<pre class="line-numbers language-c++"><code class="language-c++">        glStencilFunc(GL_ALWAYS, 1, 0xFF);
        glStencilOp(GL_KEEP, GL_KEEP, GL_REPLACE);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>当矩形片段通过模板测试和深度测试后，会用函数<code>glStencilFunc</code>的ref参数（这里是1）来替换对应模板值。</p>
<p>接下来我们就可以来画这个矩形了（注意，由于禁用了颜色缓冲和深度缓冲，这个矩形不会被画到窗口上，只是被画到了模板缓冲里）：</p>
<pre class="line-numbers language-c++"><code class="language-c++">        stencilRect_shader.Use();
        glBindVertexArray(stencilRectVAO);
        glDrawArrays(GL_TRIANGLES, 0, 6);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>矩形模板已经绘制好了，接下来我们开始绘制<a href="http://popperelay.com/2017/01/14/OpenGL15%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95/" target="_blank" rel="external">上一篇文章</a>里的箱子和地面。</p>
<p>肯定需要先把禁用了的颜色缓冲和深度缓冲重新开启：</p>
<pre class="line-numbers language-c++"><code class="language-c++">        glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);
        glDepthMask(GL_TRUE);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>绘制箱子和地面的时候，应该不会去改变模板缓冲中的值，所以我们禁用模板缓冲区写入：</p>
<pre class="line-numbers language-c++"><code class="language-c++">        glStencilMask(0x00);
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>我们希望用矩形模板来绘制箱子和地面，只有被包含在矩形内的部分才被绘制出来，其余的被丢弃。由于在模板缓冲中已经被我们绘制了一个矩形（由好多1构成的一个矩形），所以绘制箱子和地面时，我们设置片段模板值等于1时才通过模板测试（模板值不会改变）：</p>
<pre class="line-numbers language-c++"><code class="language-c++">        glStencilFunc(GL_EQUAL, 1, 0xFF);
        glStencilOp(GL_KEEP, GL_KEEP, GL_KEEP);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>接下来就按照<a href="http://popperelay.com/2017/01/14/OpenGL15%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95/" target="_blank" rel="external">上一篇文章</a>里的方式来绘制箱子和地面即可：<br>编译运行后的结果如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148446758101.png" alt=""><br>全部源码<a href="https://github.com/Popperelay/BlogCode/tree/master/LearnOpenGL16_StencilTest/LearnOpenGL16_StencilTest_1" target="_blank" rel="external">在这里</a>。<br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">物体轮廓outline</font><br>接下来我们再使用模板测试来实现一个很有意识的效果：物体轮廓（object outline），如下图这样：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148446778193.png" alt=""><br>给箱子添加轮廓的大致思路如下：</p>
<ol>
<li>绘制出箱子，绘制时允许模板缓冲写入。这样就能在绘制箱子的同时，把箱子画入模板缓冲里（注意是窗口上二维显示的箱子，不是空间三维的箱子），其实就是一堆数字1。</li>
<li>绘制出地面，绘制时禁用模板缓冲。因为我们的模板跟地面没关系，不希望在绘制地面时受到影响。</li>
<li>禁用模板缓冲，绘制稍微大一点的纯色箱子（或者其他想要的边框颜色都行），同时设置模板值不等于1的片段无法通过模板测试，将会被丢弃。这样我们就能给之前的箱子绘出一个边框了。</li>
</ol>
<p><font size="4" color="red">绘制箱子</font><br>因为我们要在绘制箱子的同时，把箱子模板画入模板缓冲中，所以需要先设置模板测试总是通过，并且通过后用1替换模板值，当然还需要允许模板缓冲写入：</p>
<pre class="line-numbers language-c++"><code class="language-c++">        //Draw Cube，绘制箱子的同时绘制箱子模板
        glStencilFunc(GL_ALWAYS, 1, 0xFF);
        glStencilOp(GL_KEEP, GL_KEEP, GL_REPLACE);
        glStencilMask(0xFF);
        ...
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>剩下的就是照常绘制箱子了，不再赘述，可参考文末的源码。</p>
<p><font size="4" color="red">绘制地面</font><br>绘制地面的时候，模板缓冲应该不受影响，所以需要先禁用模板缓冲写入：</p>
<pre class="line-numbers language-c++"><code class="language-c++">        //Draw Plane，绘制地面时应禁用模板写入
        glStencilMask(0x00);
        ...
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>接下里就是照常绘制地面了，不再赘述。</p>
<p><font size="4" color="red">绘制箱子轮廓</font><br>绘制箱子轮廓，其实就是绘制一个模板值不等于1的稍微大一点的箱子。需要设置模板测试通过的条件是模板值不等于1：</p>
<pre class="line-numbers language-c++"><code class="language-c++">        glStencilFunc(GL_NOTEQUAL, 1, 0xFF);
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>而且，利用箱子模板绘制箱子轮廓时，模板缓冲不能受到影响，需要禁用模板缓冲写入：</p>
<pre class="line-numbers language-c++"><code class="language-c++">        glStencilMask(0x00);
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>接下来就是照常绘制稍微大一点的箱子了，这里我们是绘制一个1.1倍大小的箱子，可参见文末源码。而且这个稍大的边框箱子和实际箱子不是同一套着色器，因为它们的颜色不同（实际箱子是纹理颜色，而边框箱子我们用的纯色，着色器代码也可参见文末源码）。</p>
<p>最后，绘制完箱子轮廓后，不要忘了重新允许模板缓冲写入：</p>
<pre class="line-numbers language-c++"><code class="language-c++">        glStencilMask(0xFF);
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>其实，每当改变深度缓冲、模板缓冲等写入方式时，利用完了让它们恢复到最初状态是个很好的习惯，不容易出错。</p>
<p>编译运行后的结果如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148447497001.png" alt=""><br>可以看到下轮廓和地面交界的地方，轮廓只显示了很细的一条线，这是因为下轮廓片段的深度值大于交界处地面片段的深度值，被挡住了，在深度测试时被丢弃了。解决办法是在画轮廓时关闭深度测试：</p>
<pre class="line-numbers language-c++"><code class="language-c++">        glDisable(GL_DEPTH_TEST); //保证轮廓不被挡住
        ...
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>轮廓画完了以后，不要忘了重新开启深度测试：</p>
<pre class="line-numbers language-c++"><code class="language-c++">        glEnable(GL_DEPTH_TEST);
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>编译运行后的结果如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148447497145.png" alt=""><br>&nbsp;</p>
<hr>
<p>箱子轮廓的所有源码<a href="https://github.com/Popperelay/BlogCode/tree/master/LearnOpenGL16_StencilTest/LearnOpenGL16_StencilTest_2" target="_blank" rel="external">在这里</a>。<br>&nbsp;</p>
<hr>
<p>参考文献：<a href="https://learnopengl.com/" target="_blank" rel="external">LearnOpenGL</a></p>
]]></content>
      
        <categories>
            
            <category> OpenGL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 模板测试 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OpenGL15：深度测试]]></title>
      <url>/2017/01/14/OpenGL15%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95/</url>
      <content type="html"><![CDATA[<p>使用深度缓冲所存储的深度值，可以确定一个片段是否被其他片段遮挡。<a id="more"></a></p>
<p><font size="5" color="orange">什么是深度测试</font><br>深度缓冲区、颜色缓冲区和窗口像素是一一对应的，也就是说窗口上的每一个像素都有一个颜色值和一个深度值。颜色缓冲区存储的是像素的颜色信息，而深度缓冲区存储的是像素的深度信息。</p>
<p>在决定是否绘制一个片段时，首先让该片段的深度值与当前深度缓冲区对应位置上的深度值作比较，如果小于深度缓冲区中的值，则用该片段的颜色值和深度值去更新颜色缓冲区和深度缓冲区；否则，说明三维空间中该片段在对应屏幕像素后面，被挡住了，将丢弃该片段。这个过程就叫做深度测试（Depth Testing）。<br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">在OpenGL中使用深度测试</font><br>深度缓冲区一般由窗口管理系统（例如GLFW）来自动创建，深度值一般是16位、24位或32位，位数越高，深度的精确度越高。大多数系统的深度缓冲区都是24位。</p>
<p>要在OpenGL中使用深度测试，需要先开启深度测试，因为默认是关闭的：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    glEnable(GL_DEPTH_TEST);
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>而且在每一次渲染循环开始之前，还需要清除深度缓冲区，否则深度缓冲区将保留上一次进行深度测试时所写的深度值：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>有的时候我们需要进行深度测试，但不希望更新深度缓冲区，这时可以用<code>glDepthMask</code>函数将深度掩码设置为<code>GL_FALSE</code>来关闭深度缓冲区写入：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    glDepthMask(GL_FALSE);
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>【注】：</p>
<ul>
<li>使用<code>glDepthMask</code>函数来关闭深度缓冲区写入，只在深度测试被启用的时候有效。</li>
</ul>
<p><font size="4" color="red">深度测试函数</font><br>上面说片段深度值小于深度缓冲区对应深度值的时候，深度测试通过。其实也可以是其他关系，比如大于、等于等等。这就需要我们使用’glDepthFunc’函数来设置什么时候通过深度测试了，因为默认情况下是小于的时候才通过深度测试：</p>
<pre class="line-numbers language-c++"><code class="language-c++">glDepthFunc(GL_LESS);
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>除了小于<code>GL_LESS</code>以外，还有其他比较运算符：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148431155779.png" alt=""><br>下面我们把<code>glDepthFunc</code>函数的参数设为<code>GL_ALWAYS</code>来看看效果，源码请看<a href="https://github.com/Popperelay/BlogCode/tree/master/LearnOpenGL15_DepthTest/LearnOpenGL15_DepthTest_1" target="_blank" rel="external">这里</a>。</p>
<p>编译运行后的结果如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148438222783.png" alt=""><br>可以看到<code>GL_ALWAYS</code>和我们没有启用深度测试得到了相同的效果。深度测试总是通过，所以后绘制的片段肯定会覆盖之前绘制的片段。在上面的程序中我们先绘制立方体，再绘制的地面，所以地面就把立方体遮住了。<br>把参数设为<code>GL_LESS</code>后的结果如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148438222864.png" alt=""><br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">可视化深度值</font><br>深度测试是在像素着色器运行之后（也在模板测试运行之后），在屏幕空间中执行的。屏幕空间坐标与OpenGL的<code>glViewport</code>函数定义的视口（viewport）直接相关，可以在像素着色器中通过GLSL的内置变量<code>gl_FragCoord</code>来获取片段的屏幕空间坐标。<code>gl_FragCoord</code>的x和y元素表示片段的屏幕空间坐标（(0,0)是左下角），而它的z元素就是片段的实际深度值。</p>
<p>我们把地面的顶点坐标更改如下：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    //地面的顶点坐标、纹理坐标
    GLfloat planeVertices[] = {
        //位置坐标            //纹理坐标
        5.0f,  -0.05f,  5.0f,  2.0f, 0.0f,
        -5.0f, -0.05f,  5.0f,  0.0f, 0.0f,
        -5.0f, -0.05f, -5.0f,  0.0f, 2.0f,

        5.0f,  -0.05f,  5.0f,  2.0f, 0.0f,
        -5.0f, -0.05f, -5.0f,  0.0f, 2.0f,
        5.0f,  -0.05f, -5.0f,  2.0f, 2.0f
    };
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>地面在y方向上更靠近摄像机了（摄像机在y=0的位置上）。</p>
<p>再把像素着色器更改如下：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#version 330 core
in vec2 TexCoords;
out vec4 color;

uniform sampler2D texture1;

void main(){
    //color = texture(texture1,TexCoords);
    color = vec4(vec3(gl_FragCoord.z),1.0f);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们让箱子和地面不输出纹理颜色，而只是输出深度值。源码在<a href="https://github.com/Popperelay/BlogCode/tree/master/LearnOpenGL15_DepthTest/LearnOpenGL15_DepthTest_2" target="_blank" rel="external">这里</a>。得到结果如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/14843822296.png" alt=""><br>可以看到地面靠近摄像机的地方有些黑色，说明深度值比较小，但是黑色部分很少。它向白色的过渡变化并不是均匀的，近的地方深度值变化很快，只远离几英寸就让暗色完全变亮了，剩余的部分大多都是亮色。</p>
<p>这是因为片段在屏幕空间里的深度值和它们在三维空间里的z值并不是线性关系。z很小的时候（准确的是靠近摄像机的时候），片元的深度值变化得会很快，能够很好地反映出摄像机近处物体的空间位置关系；但是当z比较大的时候，物体远离摄像机，远处的物体谁在前谁在后通常都不会太影响我们的视觉效果，这时远离摄像机的片元的深度值就不需要变化那么快了。而OpenGL的深度值恰好符合这种视觉规律：z较小时深度变化快，z较大时深度变化慢。</p>
<p>通常深度值$F_depth$和z具有如下关系：<br>$$<br>\begin{equation}<br>F_{depth} = \frac{1/z - 1/near}{1/far - 1/near}<br>\end{equation}<br>$$</p>
<p>【注】：</p>
<ul>
<li>从公式里可以看出，更准确地应该是越靠近近裁剪面，深度值变化越快。因为近裁剪面通常是0.1，相距摄像机很近，所以通常才说成越靠近摄像机深度值变化越快。</li>
</ul>
<p>在下图中可以看到z值和对应的深度缓冲值的非线性关系：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148438521782.png" alt=""><br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">深度冲突z-fighting</font><br>两个平面或三角形相互接近通常会出现一种视觉失真，深度缓冲没有足够的精确度来弄清哪个形状在前，哪个形状在后（比如两个三角形实际深度是0.801和0.802，但是如果24位深度缓冲只能精确到0.80，那就无法分清这两个三角形谁在前谁在后）。结果就是两个形状持续地交换顺序，产生了诡异的差错样式。这叫做z-fighting，就像两个形状为了显示在上面而打架。</p>
<p>使用最开始的代码，让箱子和地面显示不同的纹理，我们把摄像机移动到箱子里面，就会看到下图所示的这种深度冲突效果（箱子的底部和地面持续地相互交换，产生了锯齿样式）：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148438643797.png" alt=""><br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">减弱z-fighting</font><br>深度冲突z-fighting是深度缓冲区中常见的问题，通常当物体越远的时候越严重（因为越远的地方深度变化越慢，深度值越接近，精确度低）。z-fighting至今无法完全避免，但是有些技术能够帮助我们减弱z-fighting</p>
<ol>
<li>永远不要把物体放得彼此太近，不要让物体间的三角形重合。两个物体间留有一小段用户难以观察到的距离，可以完美地避免z-fighting。但是，这需要我们手工干涉每个物体以及仔细测试才能确保场景中的物体没有产生z-fighting。</li>
<li>把近平面设置得尽可能远。因为近裁剪面附近深度变化很快，精确度很高，因此尽可能让近裁剪面远一些（也就是尽可能靠近场景中的物体）的话，会使整个裁剪范围内的精确度变高一些。但是这种方式会使距离观察者较近的物体被裁剪掉，所以需要不断调整才能找到一个合适的近裁剪面参数。</li>
<li>使用更高位数的深度缓冲区，通常使用的深度缓冲区是24位的，但现在显卡支持32位深度值，这会让深度值得精度提高很多。但是同时也带来了一些更大的运算开销。<br>&nbsp;</li>
</ol>
<hr>
<p>参考文献：<a href="https://learnopengl.com/" target="_blank" rel="external">LearnOpenGL</a></p>
]]></content>
      
        <categories>
            
            <category> OpenGL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 深度测试 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OpenGL14：模型加载]]></title>
      <url>/2017/01/12/OpenGL14%E6%A8%A1%E5%9E%8B%E5%8A%A0%E8%BD%BD/</url>
      <content type="html"><![CDATA[<p>之前我们的场景里用的全都是小方块，现在我们想要去加载一些其他模型。<a id="more"></a>我们是无法像定义小方块一样，用程序去手动地指定房子、人这些复杂模型的顶点、法线和纹理坐标。这些复杂模型通常是由美工用Blender、3DS Max和Maya这些建模软件来制作的，我们要做的只是把这些已经做好的模型打入到我们的应用程序中。在建模软件导出模型文件时，会自动生成模型的所有顶点坐标、顶点法线和纹理坐标，而我们需要去解析这些导出的模型文件，并将其中的模型数据存储为OpenGL能够使用的数据。</p>
<p>由于导出的模型文件通常有几十种格式，为每种格式都写一种解析方式是很麻烦的。这里我们直接使用市面上一个很流行的模型加载库，叫做Assimp。<br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">模型加载库Assimp</font><br>Assimp是一个常用的模型加载库，全称是Open Asset Import Library。它可以导入几十种不同格式的模型文件（也可以导出部分模型格式），并且可以把不同的模型文件都转换为一个统一的数据结构，所以无论我们导入哪种格式的模型文件，都可以用同一个方式去访问我们需要的模型数据。<br>它能读取以下格式的模型文件：</p>
<ul>
<li>Autodesk ( .fbx )</li>
<li>Collada ( .dae )</li>
<li>glTF ( .gltf, .glb )</li>
<li>Blender 3D ( .blend )</li>
<li>3ds Max 3DS ( .3ds )</li>
<li>3ds Max ASE ( .ase )</li>
<li>Wavefront Object ( .obj )</li>
<li>Industry Foundation Classes (IFC/Step) ( .ifc )</li>
<li>XGL ( .xgl,.zgl )</li>
<li>Stanford Polygon Library ( .ply )</li>
<li>AutoCAD DXF ( .dxf )</li>
<li>LightWave ( .lwo )</li>
<li>LightWave Scene ( .lws )</li>
<li>Modo ( .lxo )</li>
<li>Stereolithography ( .stl )</li>
<li>DirectX X ( .x )</li>
<li>AC3D ( .ac )</li>
<li>Milkshape 3D ( .ms3d )</li>
<li>TrueSpace ( .cob,.scn )</li>
<li>Biovision BVH ( .bvh )</li>
<li>CharacterStudio Motion ( .csm )</li>
<li>Ogre XML ( .xml )</li>
<li>Irrlicht Mesh ( .irrmesh )</li>
<li>Irrlicht Scene ( .irr )</li>
<li>Quake I ( .mdl )</li>
<li>Quake II ( .md2 )</li>
<li>Quake III Mesh ( .md3 )</li>
<li>Quake III Map/BSP ( .pk3 )</li>
<li>Return to Castle Wolfenstein ( .mdc )</li>
<li>Doom 3 ( .md5* )</li>
<li>Valve Model ( .smd,.vta )</li>
<li>Open Game Engine Exchange ( .ogex )</li>
<li>Unreal ( .3d )</li>
<li>BlitzBasic 3D ( .b3d )</li>
<li>Quick3D ( .q3d,.q3s )</li>
<li>Neutral File Format ( .nff )</li>
<li>Sense8 WorldToolKit ( .nff )</li>
<li>Object File Format ( .off )</li>
<li>PovRAY Raw ( .raw )</li>
<li>Terragen Terrain ( .ter )</li>
<li>3D GameStudio (3DGS) ( .mdl )</li>
<li>3D GameStudio (3DGS) Terrain ( .hmp )</li>
<li>Izware Nendo ( .ndo )</li>
</ul>
<p>还能导出几种常见格式的模型：</p>
<ul>
<li>Collada ( .dae )</li>
<li>Wavefront Object ( .obj )</li>
<li>Stereolithography ( .stl )</li>
<li>Stanford Polygon Library ( .ply )</li>
</ul>
<p><font size="4" color="red">Assimp生成的模型数据结构</font><br>当Assimp导入一个模型文件时，它会加载整个模型文件到一个scene对象，它包含了所有被导入的模型和场景数据（一个模型文件可能包含多个模型或场景）。Assimp会为这个模型文件中的所有场景节点、模型节点都生成一个对应的数据结构，每个节点包含着存储在scene对象中的数据的索引，有的可能还包含几个子节点。下图展示了一个简化的Assimp生成的模型数据结构：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148248044044.png" alt=""></p>
<ul>
<li>所有的模型、场景数据都包含在scene对象中，如所有的材质和Mesh。而且，场景的根节点应用也在这个scene对象中。</li>
<li>场景的根节点包含很多子节点和很多指向scene对象中的Mesh网格数据的引用。因为根节点的mMeshes数组才包含着实际的网格对象，其他节点的mMeshes数组的值都只是根节的mMeshes的索引。</li>
<li>一个mesh由顶点、边、面片组成，它包含了渲染所需的所有相关数据，比如顶点位置、法线向量、纹理坐标、面片、材质等，一个mesh是一个可绘制的独立实体，如一条手臂、一条腿。</li>
<li>一个mesh会包含多个面片Face。一个面片表示渲染中的一个最基本的图元（如点、线、三角面片、矩形面片）。一个面片记录了一个图元的顶点索引，通过这个索引，可以在mMeshes中寻找到对应的顶点位置数据。因为顶点和索引是分开的，所以我们很容易使用索引缓冲来进行高速渲染。</li>
<li>一个mesh还会包含一个材质对象，用于指定物体的一些材质属性，如颜色、纹理贴图（漫反射贴图、镜面反射贴图等）。</li>
</ul>
<p>我们后面会用上诉的数据结构来创建我们自己的Model类和Mesh类，用于加载和保存那些导入的模型。我们不需要去渲染整个模型的所有数据，而只是去渲染这个模型所包含的所有独立的Mesh。</p>
<p><font size="4" color="red">构建Assimp</font><br>要使用Assimp模型加载库，我们需要先构建它。下载地址在<a href="https://sourceforge.net/projects/assimp/files/assimp-3.1/" target="_blank" rel="external">这里</a>。最好我们自己用CMake去编译Assimp库，因为Assimp官方的已编译库不能很好地在所有平台上正常运行。具体编译、构建和链接过程可以回顾<a href="http://popperelay.com/2016/10/18/OpenGL%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" target="_blank" rel="external">《OpenGL1：OpenGL概述及环境配置》</a>。</p>
<p>下面给出一些编译Assimp时可能遇到的问题：</p>
<ul>
<li>在使用CMake进行Configure时，可能遇到如下错误：<pre class="line-numbers language-c++"><code class="language-c++">Could not locate DirecXCMake Error at cmake-modules/FindPkgMacros.cmake:110 (message):Required library DirectX not found! Install the library (including dev packages) and try again. If the library is already installed, set the missing variables manually in cmake.
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
这是因为你之前没有安装过DirectX SDK，那么<a href="https://www.microsoft.com/en-us/download/details.aspx?id=6812" target="_blank" rel="external">下载</a>安装吧！</li>
<li>在安装DirectX SDK时，可能会遇到一个错误码为S1023的错误。解决步骤如下：<ol>
<li>在命令行窗口运行下面两行命令：<pre class="line-numbers language-c++"><code class="language-c++">MsiExec.exe /passive /X{F0C3E5D1-1ADE-321E-8167-68EF0DE699A5}
MsiExec.exe /passive /X{1D8E6291-B0D5-35EC-8441-6616F567A0F7}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
删除掉Visual C++ 2010 Redistributable Package。<br>如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148250222242.png" alt=""></li>
<li>安装DirectX SDK</li>
<li>重新安装Visual C++ 2010 Redistributable Package。可以在<a href="https://www.microsoft.com/zh-CN/download/details.aspx?id=26999" target="_blank" rel="external">这里</a>下载到。注意x64系统需要安装vcredist_x86.exe和vcredist_x64.exe两个版本。</li>
</ol>
</li>
</ul>
<p>【注】：</p>
<ul>
<li>使用默认配置构建的Assimp是一个动态库，所以我们需要把编译出来的assimpd.dll文件拷贝到我们自己的源文件所在的目录里。</li>
<li>如果想要让Assimp使用多线程来提高性能，可以使用Boost库来编译Assimp。在<a href="http://assimp.sourceforge.net/lib_html/install.html" target="_blank" rel="external">Boost安装页面</a>，可以找到关于Boost的完整安装介绍。<br>&nbsp;</li>
</ul>
<hr>
<p><font size="5" color="orange">网格类Mesh</font><br>使用Assimp可以把多种不同格式的模型加载到程序中，但是一旦载入，它们就都被存储为Assimp自己的数据结构。我们需要将其转变为OpenGL可读的数据，才能用OpenGL来渲染物体。</p>
<p><font size="4" color="red">绘制网格所需数据</font><br>一个网格代表一个可绘制的实体，我们把Assimp加载的模型转变成很多个网格，分别绘出这些网格，就能绘制出整个模型。现在我们来自定义一个自己的网格类，便于转换Assimp的数据结构为OpenGL可读的数据结构。一个网格应该至少需要一组顶点，每个顶点包含一个位置向量、一个法线向量、一个纹理坐标，还需要包含顶点索引以及用纹理（漫反射贴图、镜面贴图）形式表现的材质数据。</p>
<p>那我们先来定义一个顶点：</p>
<pre class="line-numbers language-c++"><code class="language-c++">struct Vertex {
    vec3 position;
    vec3 normal;
    vec2 texCoords;
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>顶点中包含了顶点位置、法线和纹理坐标。</p>
<p>接着我们来定义绘制网格所需要的纹理：</p>
<pre class="line-numbers language-c++"><code class="language-c++">struct Texture {
    GLuint id;
    string samplerName;
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>纹理中包含了纹理加载后的ID，和在像素着色器（在文末有像素着色器代码，和上一篇文章几乎一样）中纹理所对应的采样器名称。</p>
<p><font size="4" color="red"> 建立网格类</font><br>然后，我们可以开始建立Mesh类了：</p>
<pre class="line-numbers language-c++"><code class="language-c++">class Mesh {
public:
    vector<Vertex> vertices;
    vector<GLuint> indices;
    vector<Texture> textures;
    float shininess;
    ...
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>它包含了绘制网格所需的一堆顶点、顶点索引和纹理，它们都是vector类型（使用vector需要包含vector文件<code>#include &lt;vector&gt;</code>），还包含了计算镜面光时所需要的镜面反射系数。这些顶点位置、纹理等等都是从Assimp加载后的数据里面得到的（在后面自定义的模型加载类ModelLoader里通过参数传递到Mesh类里）。</p>
<p>我们可以在Mesh类的构造函数里，用传递过来的参数初始化这些顶点、纹理：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    Mesh(vector<Vertex> vertices, vector<GLuint> indices, vector<Texture> textures, float shininess) {
        this->vertices = vertices;
        this->indices = indices;
        this->textures = textures;
        this->shininess = shininess;
        ...
    }
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>和之前的绘制流程一样，在绘制之前先对这些数据绑定VAO、VBO、EBO以及解析顶点数据，我们把它写在<code>PrepareBeforeDraw</code>函数里：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    GLuint VAO, VBO, EBO;
    //在绘制之前的绑定、发送数据、解析等准备工作
    void PrepareBeforeDraw() {
        glGenVertexArrays(1, &VAO);
        glGenBuffers(1, &VBO);
        glGenBuffers(1, &EBO);
        glBindVertexArray(VAO);
        glBindBuffer(GL_ARRAY_BUFFER, VBO);
        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);
        glBufferData(GL_ARRAY_BUFFER, vertices.size() * sizeof(Vertex), &vertices[0], GL_STATIC_DRAW);
        glBufferData(GL_ELEMENT_ARRAY_BUFFER, indices.size() * sizeof(GLuint), &indices[0], GL_STATIC_DRAW);
        glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (GLvoid*)0);
        glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (GLvoid*)offsetof(Vertex, normal));
        glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, sizeof(Vertex), (GLvoid*)offsetof(Vertex, texCoords));
        glEnableVertexAttribArray(0);
        glEnableVertexAttribArray(1);
        glEnableVertexAttribArray(2);
        glBindVertexArray(0);
    }
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后在构造函数里调用该函数：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    Mesh(vector<Vertex> vertices, vector<GLuint> indices, vector<Texture> textures, float shininess) {
        this->vertices = vertices;
        this->indices = indices;
        this->textures = textures;
        this->shininess = shininess;
        PrepareBeforeDraw();
    }
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>绘制网格所需的数据以及绑定解析好了，接下来就可以绘制网格了：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    void Draw(shader myshader) {
        for (GLuint i = 0; i < textures.size(); i++) {
            glActiveTexture(GL_TEXTURE0 + i);
            glBindTexture(GL_TEXTURE_2D, textures[i].id);
            glUniform1i(glGetUniformLocation(myshader.shaderProgram, ("material." + textures[i].samplerName).c_str()), i);
        }
        glUniform1f(glGetUniformLocation(myshader.shaderProgram, "material.shininess"), shininess);
        glBindVertexArray(VAO);
        glDrawElements(GL_TRIANGLES, indices.size(), GL_UNSIGNED_INT, 0);
        glBindVertexArray(0);
    }
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>先对每一张纹理激活纹理单元和设置对应的uniform采样器，再设置uniform镜面反射系数的值，最后再次绑定VAO调用<code>glDrawElements</code>函数就可以绘制出整个网格了。<br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">模型加载类ModelLoader</font><br>我们需要使用Assimp把模型文件加载到我们的程序里，再读出一些Assimp数据（比如顶点、索引、纹理等 ）传到Mesh里用以绘制（这里我们使用<a href="http://learnopengl.com/data/models/nanosuit.rar" target="_blank" rel="external">纳米铠甲</a>的模型）。</p>
<p><font size="4" color="red">加载模型文件</font><br>要使用Assimp，除了编译链接好以外，还需要在我们的程序中包含以下头文件：</p>
<pre class="line-numbers language-c++"><code class="language-c++">//Assimp
#include <Assimp/Importer.hpp>
#include <Assimp/scene.h>
#include <Assimp/postprocess.h>
using namespace Assimp;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后我们在自定义的LoadModel函数里使用Assimp的Importer对象的<code>ReadFile</code>函数，来把模型文件读取到场景对象中：</p>
<pre class="line-numbers language-c++"><code class="language-c++">const aiScene* scene;

void LoadModel(string path) {
        //用Assimp加载模型文件到场景对象中
        Importer importer;
        scene = importer.ReadFile(path, aiProcess_Triangulate | aiProcess_FlipUVs);
        if (!scene || !scene->mRootNode || scene->mFlags == AI_SCENE_FLAGS_INCOMPLETE) {
            cout << "Error:Assimp:" << importer.GetErrorString() << endl;
            return;
        }
        ...
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>首先定义Importer对象，Importer对象的<code>ReadFile</code>函数里第一个参数指明模型文件的路径，第二个参数是后处理选项。除了可以简单加载文件外，Assimp运行我们定义几个选项来强制Assimp去对导入的数据做一些额外的计算或操作：</p>
<ul>
<li><code>aiProcess_Triangulate</code>：告诉Assimp如果模型不是（全部）由三角形组成，应该转换所有的模型的原始几何形状为三角形。</li>
<li><code>aiProcess_FlipUVs</code>：基于y轴翻转纹理坐标（在<a href="http://popperelay.com/2016/11/29/OpenGL5%E7%BA%B9%E7%90%86/" target="_blank" rel="external">OpenGL5：纹理</a>一文中说过OpenGL会将大多数图像沿着y轴翻转，不翻转回来的话会导致画出来的图像是上下颠倒的，这里做了这个处理后顶点着色器就不用再<code>1-纹理y坐标</code>了）。</li>
<li><code>aiProcess_GenNormals</code>：如果模型没有包含法线向量，就为每个顶点创建法线。</li>
<li><code>aiProcess_SplitLargeMeshes</code>：把大的网格分成几个小的夏季网格，当渲染一个有最大数量顶点的限制或者只能处理小块网格时会很有用。</li>
<li><code>aiProcess_OptimizeMeshes</code>：和上一个选项相反，它把几个网格结合为一个更大的网格，以减少绘制函数调用次数的方式来实现优化。</li>
</ul>
<p>更多更详细的后处理内容可以在<a href="http://assimp.sourceforge.net/lib_html/postprocess_8h.html" target="_blank" rel="external">这里</a>找到。</p>
<p><code>ReadFile</code>函数返回一个aiScene指针对象，将加载的模型数据都存储在这个返回的场景对象指针中（Assimp的很多变量和方法名称都带有ai标识）。接着通过场景对象指针是否为空、场景对象的根结点是否为空和场景的加载标志flag是否为非完整加载<code>AI_SCENE_FLAGS_INCOMPLETE</code>来判断Assimp加载是否成功，如果不成功，使用加载器Importer对象的<code>GetErrorString</code>函数来返回错误报告。</p>
<p><font size="4" color="red">遍历aiMesh</font><br>现在所有的模型数据都存储在场景对象指针中，但是这些数据并不是配对的，我们不知道哪些材质（材质里有纹理）应该属于哪些mesh，就无法给每个mesh对应上正确的纹理贴图。所以我们需要去遍历每一个mesh，取出它里面的顶点、法线、纹理等等。</p>
<p>首先定义一个全局遍历meshes，用于存储遍历出来的每一个mesh：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    vector<Mesh> meshes;
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>遍历所有mesh的方法有两种，一种是直接遍历场景对象指针scene下的所有mesh：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    //遍历所有mesh
    void TraverseNode(aiNode* node) {
        //方法1：直接遍历场景对象指针scene中的所有mesh
        for (int i = 0; i < scene->mNumMeshes; i++) {
            meshes.push_back(ProcessMesh(scene->mMeshes[i]));
        }
    }
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>另外一种是从根结点开始递归遍历子结点，取出每一个结点包含的所有mesh。</p>
<pre class="line-numbers language-c++"><code class="language-c++">    //遍历所有mesh
    void TraverseNode(aiNode* node) {
        //方法2：递归每个结点
        //取出自身结点中的所有mesh
        for (GLuint i = 0; i < node->mNumMeshes; i++) {
            aiMesh* aimesh = scene->mMeshes[node->mMeshes[i]];
            meshes.push_back(ProcessMesh(aimesh));
        }
        //递归遍历子节点
        for (GLuint i = 0; i < node->mNumChildren; i++) {
            TraverseNode(node->mChildren[i]);
        }
    }
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在每一个结点中存储的mesh，都只是场景对象scene包含的mesh的一个索引。所以需要使用形如<code>scene-&gt;mMeshes[node-&gt;mMeshes[i]]</code>的方式去scene中获得真正的mesh。</p>
<p><font size="4" color="red">从aiMesh中提取数据转换为Mesh类对象</font><br>函数<code>ProcessMesh</code>是我们的自定义函数，用于从Assimp加载的aiMesh里提取出顶点、索引、纹理等，转变为Mesh类对象。</p>
<p>先在<code>ProcessMesh</code>函数里定义我们的Mesh所需要的顶点、索引和纹理：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    //把Assimp的aiMesh转换为我们自定义的Mesh
    Mesh ProcessMesh(aiMesh* aimesh) {
        vector<Vertex> vertices;
        vector<GLuint> indices;
        vector<Texture> textures;
        ...
    }
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>【注】：</p>
<ul>
<li>这里的Vertex、Texture都是在Mesh类之前定义的结构体，所以需要先包含mesh.h：<code>#include &quot;mesh.h&quot;</code></li>
</ul>
<p>接下来我们取出aiMesh中所有顶点的位置、法线、纹理坐标等顶点属性，赋值给我们自定义的顶点结构体：</p>
<pre class="line-numbers language-c++"><code class="language-c++">        //获取aiMesh中的所有顶点数据（包括顶点位置、法线向量、纹理坐标）
        for (GLuint i = 0; i < aimesh->mNumVertices; i++) {
            Vertex vertex;
            vertex.position = vec3(aimesh->mVertices[i].x, aimesh->mVertices[i].y, aimesh->mVertices[i].z);
            vertex.normal = vec3(aimesh->mNormals[i].x, aimesh->mNormals[i].y, aimesh->mNormals[i].z);
            if (aimesh->mTextureCoords[0]) {
                vertex.texCoords = vec2(aimesh->mTextureCoords[0][i].x, aimesh->mTextureCoords[0][i].y);
            }
            else {
                vertex.texCoords = vec2(0.0f, 0.0f);
            }
            vertices.push_back(vertex);
        }
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>【注】：</p>
<ul>
<li>Assimp允许一个模型的每个顶点有8个不同的纹理坐标，所以mTextureCoords是2维的，第一维指明是那组纹理坐标，第二维才指明是某组的哪一个纹理坐标。这里我们只关心顶点的第一组纹理坐标，所以第一维是0。</li>
</ul>
<p>当然，每次循环完后，不要忘记把Vertex结构体变量添加到vertices里。</p>
<p>接着我们取出aiMesh中的所有顶点索引，这些顶点索引都保存在每一个面片中：</p>
<pre class="line-numbers language-c++"><code class="language-c++">        //获取aiMesh中所有面片（这里就是三角形）的顶点索引
        for (GLuint i = 0; i < aimesh->mNumFaces; i++) {
            aiFace aiface = aimesh->mFaces[i];
            for (GLuint j = 0; j < aiface.mNumIndices; j++) {
                indices.push_back(aiface.mIndices[j]);
            }
        }
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们再来取出aiMesh的所有纹理，这些纹理都存储在材质中，所以需要先获取到材质：</p>
<pre class="line-numbers language-c++"><code class="language-c++">        //获取aiMesh的材质的所有材质纹理
        if (aimesh->mMaterialIndex >= 0) {
            aiMaterial* aimat = scene->mMaterials[aimesh->mMaterialIndex];
            ...
        }
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果某个mesh没有材质，那么它的<code>mMaterialIndex</code>属性会小于0。</p>
<p>由于Mesh类里需要纹理加载和绑定后的ID，所以我们需要aiMesh的每一个纹理的存储路径。纹理的名称可以由aiMaterial对象的<code>GetTexture</code>函数得到：</p>
<pre class="line-numbers language-c++"><code class="language-c++">            aiString str;
            //获取第i个漫反射纹理的名称
            aimat->GetTexture(aiTextureType_DIFFUSE, i, &str);
            string texRelativePath = str.C_Str();
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>GetTexture</code>函数的第一个参数是纹理类型，可以是漫反射纹理或者镜面纹理，第二个参数是第几个对应纹理，第三个参数用于存储纹理名称。注意第三个参数纹理名称是aiString类型的，需要使用<code>C_Str</code>函数转换为string类型。</p>
<p>只得到了纹理名称还不够，还应该有这个纹理所在的文件夹路径，这个我们可以用字符串自己指定。由于我们已经把纹理和模型文件nanosuit.obj放在同一个文件夹，而且在调用之前的<code>LoadModel</code>函数时，我们传入了模型文件的路径（<code>LoadModel</code>函数参数path），所以我们可以根据这个路径得到纹理所在的文件夹路径：</p>
<pre class="line-numbers language-c++"><code class="language-c++">string directory;
directory = path.substr(0, path.find_last_of('/'));
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><code>substr</code>函数的第一个参数指明截取字符串的起始位置，第二个参数指明截取字符串的终止位置。</p>
<p>但是<code>GetTexture</code>的第二个参数该怎么指定呢？我们怎么知道有多少个漫反射纹理，i应该取为多少才不会越界。可以使用aiMaterial对象的<code>GetTextureCount</code>函数来获取材质中相应纹理的数量，它只有一个参数，指明是漫反射纹理还是镜面纹理：</p>
<pre><code>        //获取aiMesh的材质的所有材质纹理
        if (aimesh-&gt;mMaterialIndex &gt;= 0) {
            aiMaterial* aimat = scene-&gt;mMaterials[aimesh-&gt;mMaterialIndex];
            //获取所有的漫反射纹理
            for (GLuint i = 0; i &lt; aimat-&gt;GetTextureCount(aiTextureType_DIFFUSE); i++) {
                aiString str;
                //获取第i个漫反射纹理的名称
                aimat-&gt;GetTexture(aiTextureType_DIFFUSE, i, &amp;str);
                string texName = str.C_Str(); //纹理名称 
                string texPath = directory + &#39;/&#39; + texName;  //纹理路径
                ...
            }
        }
</code></pre><p>纹理路径有了，接下来我们就可以用之前文章里的纹理加载类<code>TextureLoader</code>，来加载纹理了：</p>
<pre class="line-numbers language-c++"><code class="language-c++">        //获取aiMesh的材质的所有材质纹理
        if (aimesh->mMaterialIndex >= 0) {
            aiMaterial* aimat = scene->mMaterials[aimesh->mMaterialIndex];
            //获取所有的漫反射纹理
            for (GLuint i = 0; i < aimat->GetTextureCount(aiTextureType_DIFFUSE); i++) {
                aiString str;
                //获取第i个漫反射纹理的名称
                aimat->GetTexture(aiTextureType_DIFFUSE, i, &str);
                string texName = str.C_Str(); //纹理名称
                string texPath = directory + '/' + texName;  //纹理路径

                Texture texture;
                TextureLoader textureLoader;
                texture.id = textureLoader.LoadTexture(texPath.c_str());
                texture.samplerName = "diffuse_texture" + IntToString(i);
                textures.push_back(texture);
            }
        }
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>加载后的纹理ID赋值给Texture结构体变量的id属性，同时我们给Texture结构体变量的samplerName 属性赋值，对应像素着色器中的纹理采样器名称。当然不要忘了把Texture结构体变量添加到textures中。<br>【注】：</p>
<ul>
<li>由于C++没有提供把字符转换为字符串的函数，所以我们自己写了一个<code>IntToString</code>函数来实现这个功能：<pre class="line-numbers language-c++"><code class="language-c++">  //把int类型转换为string类型
  string IntToString(int number) {
      ostringstream outs;
      outs << number;
      return outs.str();
  }
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<p>对于镜面纹理的获取，和上面的漫反射纹理一样：</p>
<pre class="line-numbers language-c++"><code class="language-c++">            //获取所有的镜面纹理
            for (GLuint i = 0; i < aimat->GetTextureCount(aiTextureType_SPECULAR); i++) {
                aiString str;
                //获取第i个镜面反射纹理的存储路径
                aimat->GetTexture(aiTextureType_SPECULAR, i, &str);
                string texName = str.C_Str(); //纹理名称
                string texPath = directory + '/' + texName;  //纹理路径

                Texture texture;
                TextureLoader textureLoader;
                texture.id = textureLoader.LoadTexture(texPath.c_str());
                texture.samplerName = "specular_texture" + IntToString(i);
                textures.push_back(texture);
            }
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们再指定一下mesh的镜面反射系数，用以计算镜面反射光：</p>
<pre class="line-numbers language-c++"><code class="language-c++">        float shininess = 32;
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>最后，我们把这些顶点、索引、纹理和镜面反射系数，传递给Mesh类，Mesh类就会用它的构造函数，生成一个用于我们绘制的Mesh对象：</p>
<pre class="line-numbers language-c++"><code class="language-c++">        return Mesh(vertices, indices, textures, shininess);
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><font size="4" color="red">绘制每一个mesh</font><br>万事俱备，只欠东风。在LoadModel类里，我们已经把所有aiMesh转换为可以绘制的Mesh对象了，最后要做的就是在LoadModel类里调用所有Mesh对象的Draw函数，我们把它写在LoadModel类的Draw函数里：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    void Draw(shader myshader) {
        for (GLuint i = 0; i < meshes.size(); i++) {
            meshes[i].Draw(myshader);
        }
    }
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>&nbsp;</p>
<hr>
<p><font size="5" color="orange">绘制模型</font><br>绘制模型，只需要在主程序里定义<code>LoadModel</code>类对象，然后在渲染循环里调用它的Draw函数就可以了：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    Model mymodel("nanosuit/nanosuit.obj");
    ...
    mymodel.Draw(lightObject);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>&nbsp;</p>
<hr>
<p><font size="5" color="orange">重大优化</font><br>之前对每一个mesh的所有材质纹理，我们都会使用<code>TextureLoader</code>类去加载绑定，这个加载纹理的过程是很费时的。由于不同的mesh，它们的纹理可能是相同的，所以很有可能会出现同一张纹理加载了好几次。这无疑是浪费，需要避免。</p>
<p>怎么判断要加载的纹理已经被加载过了呢？判断要加载的纹理路径是否和已加载的纹理的路径相同即可。所以，我们需要给Texture结构体添加一个属性<code>texPath</code>来标识纹理的路径：</p>
<pre class="line-numbers language-c++"><code class="language-c++">struct Texture {
    GLuint id;
    string samplerName;
    string texPath;
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>还需要设置一个Texture结构体数组，用来存储已经加载过的纹理：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    vector<Texture> loadedTextures;  //存储已经加载过的纹理
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>在加载纹理之前，我们先判断要加载的纹理路径是否有和已加载纹理的路径相同的：</p>
<pre class="line-numbers language-c++"><code class="language-c++">                bool skip = false;  //纹理是否已经加载过
                for (int j = 0; j < loadedTextures.size(); j++) {
                    if (texPath == loadedTextures[j].texPath) {
                        skip = true;
                        textures.push_back(loadedTextures[j]);
                        break;
                    }
                }
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>用bool变量<code>skip</code>来标识纹理是否已经加载过，如果要加载的纹理路径和已加载的某一纹理的路径相同，那么textures直接添加已加载的纹理即可，不用再去加载一次纹理，并且设置<code>skip</code>为真，标识纹理已经加载过，退出循环。</p>
<p>如果纹理没有被加载过，for循环里的内容就一直不会被执行，<code>skip</code>将为假，这时就需要去加载纹理了。加载完后不要忘了把纹理路径存储到Texture结构体变量中，并且把该结构体变量添加到已加载纹理数组<code>loadedTextures</code>中：</p>
<pre class="line-numbers language-c++"><code class="language-c++">                if (!skip) {
                    Texture texture;
                    TextureLoader textureLoader;
                    texture.id = textureLoader.LoadTexture(texPath.c_str());
                    texture.samplerName = "diffuse_texture" + IntToString(i);
                    texture.texPath = texPath;
                    textures.push_back(texture);
                    loadedTextures.push_back(texture);
                }
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对于镜面纹理，也是一样的优化处理，不再赘述。</p>
<p><font size="5" color="orange">所有源码</font><br>到此，所有源码<a href="https://github.com/Popperelay/BlogCode/tree/master/LearnOpenGL14_LoadModel" target="_blank" rel="external">在这里</a></p>
<p>【注】：</p>
<ul>
<li>主程序里去掉了对光源物体的绘制。</li>
</ul>
<p>编译运行后的结果如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148421809914.png" alt=""><br>&nbsp;</p>
<hr>
<p>参考文献：<a href="https://learnopengl.com/" target="_blank" rel="external">LearnOpenGL</a></p>
]]></content>
      
        <categories>
            
            <category> OpenGL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 模型加载 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OpenGL13：常见光源]]></title>
      <url>/2016/12/17/OpenGL13%E5%B8%B8%E8%A7%81%E5%85%89%E6%BA%90/</url>
      <content type="html"><![CDATA[<p><font size="5" color="orange">几种常见的光源类型</font><br><a id="more"></a><br>在前面的文章中，我们使用的其实都是一个点光源。现在我们将介绍几种常见的的光源类型：</p>
<ul>
<li>定向光Directional Light：类似太阳光，每条光线平行，指向同一个方向</li>
<li>点光源Point Light：类似灯泡，向四周发光</li>
<li>聚光Spot Light：类似手电筒，只向某个方向照射</li>
</ul>
<p>它们的图示如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148179453303.png" alt=""><br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">定向光Directional Light</font><br>定向光源类似于太阳，光源很远，每条光线接近于平行，所有光线都是同一个方向。定向光的方向和光源在哪个位置无关，因为无限远嘛。</p>
<p>由于定向光方向是一个固定值，所以在计算漫反射光时，就不需要用光源位置和片元位置来计算入射光线方向了，直接使用定向光方向这个固定值就可以（对所有片元来说入射光方向都是这个值）。我们先把定向光方向加入光源结构体里：</p>
<pre class="line-numbers language-c++"><code class="language-c++">//定向光源
struct Light{
    vec3 direction;
    vec3 ambient;
    vec3 diffuse;
    vec3 specular;
};
uniform Light light;       //光源变量
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对于定向光来说，就不需要定义光源位置了，因为定向光源是无限远的，而且也用不上。</p>
<p>当然，需要给这个定向光方向赋值：</p>
<pre class="line-numbers language-c++"><code class="language-c++">        //设置定向光的方向
        glUniform3f(glGetUniformLocation(lightObject.shaderProgram, "light.direction"), 1.0f, -1.0f, -1.0f);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>在计算漫反射光时，入射光方向需要变一下，现在是定向光方向的反方向（因为入射光方向需要从片元到光源，而定向光方向是从光源到片元的）：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    vec3 lightDir=normalize(-light.direction); //光线入射方向的单位向量
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>为了清晰地看出定向光对所有物体都有相同的影响，我们还是画10个箱子出来：</p>
<pre class="line-numbers language-c++"><code class="language-c++">        glBindVertexArray(lightObjectVAO);
        for (int i = 0; i < 10; i++) {
            mat4 lightObject_model;
            lightObject_model = translate(lightObject_model, cubeTranlate[i]);
            lightObject_model = rotate(lightObject_model, radians(105.0f), vec3(0.5f, 1.0f, 1.0f));
            glUniformMatrix4fv(glGetUniformLocation(lightObject.shaderProgram, "model"), 1, GL_FALSE, value_ptr(lightObject_model));
            glDrawElements(GL_TRIANGLES, 36, GL_UNSIGNED_INT, 0);
        }
        glBindVertexArray(0);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>编译运行后的结果如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148180680412.png" alt=""><br>在场景中移动摄像机，会感觉有一个太阳一样的光源照射在这些物体上。</p>
<p>下面是受光物体的像素着色器源码：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#version 330 core
//材质结构体
struct Material{
    sampler2D diffuse;
    sampler2D specular;
    float shininess;
};
//定向光源
struct Light{
    //vec3 position;  //定向光不再需要光源位置了，因为它是无限远的
    vec3 direction;
    vec3 ambient;
    vec3 diffuse;
    vec3 specular;
};
in vec3 Normal;
in vec3 positionInWorld;
in vec2 TexCoords;
out vec4 color;
uniform Material material; //材质变量
uniform Light light;       //光源变量
uniform vec3 viewPos;      //观察位置

void main(){
    //计算最终的环境光
    vec3 ambientColor=light.ambient * vec3(texture(material.diffuse,TexCoords));  //环境光
    //计算最终的漫反射光
    vec3 normal=normalize(Normal);  //单位法向量
    vec3 lightDir=normalize(-light.direction); //光线入射方向的单位向量
    float diffuseFactor=max(dot(normal,lightDir),0.0); //漫反射系数（两个向量夹角的余弦）
    vec3 diffuseColor=diffuseFactor * light.diffuse * vec3(texture(material.diffuse,TexCoords));   //漫反射光
    //计算最终的镜面反射光
    vec3 reflectDir=normalize(reflect(-lightDir,normal));   //反射光方向
    vec3 viewDir=normalize(viewPos-positionInWorld);  //观察方向
    float specularFactor=pow(max(dot(reflectDir,viewDir),0.0),material.shininess); //镜面反射系数
    vec3 specularColor=specularFactor * light.specular * vec3(texture(material.specular,TexCoords)); //镜面反射光

    color=vec4(ambientColor+diffuseColor+specularColor,1.0f);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>&nbsp;</p>
<hr>
<p><font size="5" color="orange">点光源Point Light</font><br>点光源就是我们之前一直用的那种光源，它类似于一个灯泡在向四周发光。它需要用点光源位置和片元位置去计算入射光方向。</p>
<p><font size="4" color="red">从前的点光源</font><br>下面是点光源照射的一个例子：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148180680466.png" alt=""><br>可以看到，离点光源越近的地方越亮，离得越远越暗。点光源的亮度随着距离增大应该是有一个衰减过程的。但是我们之前一直在用的点光源并没有考虑到这一点。下面的图片是我们用从前的点光源照射情况：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148180680549.png" alt=""><br>可以看到离点光源（白色方块）越远的箱子并没有越暗。</p>
<p><font size="4" color="red">点光源亮度衰减</font><br>随着光线穿越距离的变远，亮度也随之降低的现象，通常称之为衰减。这种衰减不是线性的，它是开始的时候衰减得非常快，之后随着距离增加，减少的速度回慢下来。 其实衰减系数和$F_{att}$和$d$之间的关系如下：<br>$$<br>\begin{equation}<br>F_{att} = \frac{1.0}{K_c + K_l * d + K_q * d^2}<br>\end{equation}<br>$$<br>这里d表示片元到光源的距离，$K_c$表示常系数，值通常是1.0，它的作用是保证分母不会比1小，$K_l$是线性衰减系数，$K_q$是二次衰减系数。</p>
<p>下面的图展示了d在100以内的衰减趋势：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148180855127.png" alt=""></p>
<p><font size="4" color="red">一些经验值</font><br>上面公式的常系数、一次项系数、二次项系数应该取多少才有较好的效果呢？经过很多实验和经验总结，下表展示的各项值会有比较好的衰减效果：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148180855177.png" alt=""><br>【注】：</p>
<ul>
<li>上表中的距离d是我们想要点光源照射到的距离（球半径），比如第一行，当距离到达7的时候亮度几乎为0。</li>
</ul>
<p><font size="4" color="red">实现衰减的点光源</font><br>下面我们在像素着色器中来计算这个衰减系数，实现点光源的衰减效果。</p>
<p>由于按公式计算衰减系数，我们需要常数项、一次项、二次项这三个系数，所以我们先把它们定义到点光源结构体中：</p>
<pre class="line-numbers language-c++"><code class="language-c++">//点光源结构体
struct Light{
    vec3 position;
    vec3 ambient;
    vec3 diffuse;
    vec3 specular;
    float constant; //常数项
    float linear;   //一次项
    float quadric;  //二次项
};
uniform Light light;       //光源变量
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里我们希望点光源覆盖50的距离，从表中找到对应的各项系数，在主程序中把它们赋值给点光源结构体的相应变量：</p>
<pre class="line-numbers language-c++"><code class="language-c++">        //设置点光源衰减公式的常数项、一次项、二次项
        glUniform1f(glGetUniformLocation(lightObject.shaderProgram, "light.constant"), 1.0f);
        glUniform1f(glGetUniformLocation(lightObject.shaderProgram, "light.linear"), 0.09f);
        glUniform1f(glGetUniformLocation(lightObject.shaderProgram, "light.quadric"), 0.032);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>有了衰减公式中的这些系数，还需要片元到点光源的距离，我们就能在像素着色器中计算出衰减系数了。我们可以使用GLSL的内置函数<code>length</code>来计算片元到点光源的距离：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    float distance=length(light.position-positionInWorld);
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>然后使用距离和这些系数来计算衰减系数：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    float attenuation=1.0f/(light.constant+light.linear*distance+light.quadric*distance*distance);
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>最后，需要让点光源的每种成分光都执行这种衰减，即乘上衰减系数：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    //点光源的每种成分光都执行衰减
    ambientColor*=attenuation;
    diffuseColor*=attenuation;
    specularColor*=attenuation;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>编译运行后的结果如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148181038051.png" alt=""><br>可以看到离点光源远的物体明显越来越暗了。</p>
<p><font size="4" color="red">全部源码</font><br>实现衰减的点光源的全部源码<a href="https://github.com/Popperelay/BlogCode/tree/master/LearnOpenGL13_CommonLightSource/LearnOpenGL13_CommonLightSource_1" target="_blank" rel="external">在这里</a>。<br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">聚光Spot Light</font></p>
<p><font size="4" color="red">聚光计算原理</font><br>聚光类似手电筒发出的光，只在一个指定的范围内发散，如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148181058212.png" alt=""><br>聚光灯可以由3个参数确定：</p>
<ul>
<li>SpotDir：聚光灯的灯轴方向，即图中的红线</li>
<li>LightPos：聚光灯的位置</li>
<li>Cutoff：聚光灯的张角，即图中的$\phi$</li>
</ul>
<p>我们要做的就是：判断片元是不是在聚光灯照射的范围内。比如图中圈出来的那个片元，聚光灯到该片元的方向是那条黑线，和红线灯轴的夹角（称为偏轴角）为$\theta$，如果$\theta \lt \phi$，则片元在聚光范围内，应该受到光照；否则，片元落在聚光范围外，将得不到光照。</p>
<p><font size="4" color="red">实现聚光</font><br>聚光灯可以由灯轴方向、灯位置、张角来确定，需要把它们添加到像素着色器的聚光灯结构体中：</p>
<pre class="line-numbers language-c++"><code class="language-c++">//聚光灯结构体
struct Light{
    vec3 position;   //聚光灯位置
    vec3 lightAxis;  //灯轴方向
    float cutOff;    //张角

    float constant; //常数项
    float linear;   //一次项
    float quadric;  //二次项

    vec3 ambient;
    vec3 diffuse;
    vec3 specular;
};
uniform Light light;       //光源变量
``
聚光也有随着距离衰减的效果，所以我们保留了点光源的参数和相应计算。

接下来需要对新添加的这三个元素赋值：`
```c++
        //设置聚光灯的位置、灯轴、张角
        glUniform3f(glGetUniformLocation(lightObject.shaderProgram, "light.position"), mycamera.cameraPos.x, mycamera.cameraPos.y, mycamera.cameraPos.z);
        glUniform3f(glGetUniformLocation(lightObject.shaderProgram, "light.lightAxis"), mycamera.cameraToTarget.x, mycamera.cameraToTarget.y, mycamera.cameraToTarget.z);
        glUniform1f(glGetUniformLocation(lightObject.shaderProgram, "light.cutOff"), cos(radians(12.5f)));
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>因为在游戏中，很多时候聚光都用在主角身上，所以我们把聚光灯的位置设为了摄像机的位置，灯轴设为了摄像机照射的方向（从摄像机指向目标的向量），张角这里我们设为了12.5度的余弦值，因为后面用点乘计算出来的片元偏轴角是余弦值，所以我们这里张角也用余弦值，否则用<code>acos</code>转化为弧度的话计算代价是很高昂的。<br>【注】：</p>
<ul>
<li>在特殊需要下，聚光灯也可以在其他位置，其他朝向，可以自定义</li>
</ul>
<p>有了聚光灯的这三个值，我们就可以在像素着色器中，计算片元的偏轴角了：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    //计算聚光灯下片元的偏轴角（余弦值）
    float theta=dot(normalize(positionInWorld-light.position),normalize(light.lightAxis));
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>然后让片元的偏轴角$\theta$余弦值和聚光灯的张角$\phi$余弦值作比较，如果大于，则说明片元在聚光范围内，执行跟点光源一样的光照计算；否则该片元就显示黑色，表示没有受到光照：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    //计算聚光灯下片元的偏轴角（余弦值）
    float theta=dot(normalize(positionInWorld-light.position),normalize(light.lightAxis));
    if(theta > light.cutOff){
        //执行和点光源一样的光照计算
    }
    else{  //片元在聚光范围外呈现黑色
        color=vec4(0.0f,0.0f,0.0f,1.0f);
    }
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>编译运行后的结果如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148198128403.png" alt=""><br>当然，片元超出聚光范围后不一定只能是黑色，也可以是其他颜色，看我们怎么设置了。如果片元超出聚光范围后，呈现环境光颜色：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    else{  //片元在聚光范围外时使用环境光，使其不至于完全黑暗
        color=vec4(light.ambient*vec3(texture(material.diffuse,TexCoords)),1.0f);
    }
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>那么显示结果会是下面这样：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148197856581.png" alt=""></p>
<p><font size="4" color="red">软化边缘</font><br>上面的聚光灯看起来有点假，因为聚光边缘有个硬边。在像素着色器的逻辑中，片元一旦操作聚光范围，它就会理解黑下来，变成环境光，却没有任何平滑减弱的过度。真实的聚光在它的边界应该是慢慢向外减弱的。</p>
<p>为了实现聚光在边缘的平滑减弱，我们给聚光灯定义一个内张角$\phi$和外张角$\gamma$：内张角还是原来的张角，外张角比内张角稍大：</p>
<pre class="line-numbers language-c++"><code class="language-c++">//聚光灯结构体
struct Light{
    vec3 position;   //聚光灯位置
    vec3 lightAxis;  //灯轴方向
    float inCutOff;  //内张角
    float outCutOff; //外张角
    ...
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">        glUniform1f(glGetUniformLocation(lightObject.shaderProgram, "light.inCutOff"), cos(radians(12.5f)));
        glUniform1f(glGetUniformLocation(lightObject.shaderProgram, "light.outCutOff"), cos(radians(17.5f)));
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>在内张角里的片元还是像上面一样，执行和点光源一样的光照计算；处在内张角和外张角之间的片元，亮度$I$在内张角余弦外张角余弦之间线性插值：<br>$$<br>\begin{equation}<br>I = \frac{\theta - \gamma}{\phi - \gamma}<br>\end{equation}<br>$$<br>如果片元在内张角里面，这个值会大于1，我们把它截断为1；如果片元在外张角外面，这个值会小于0，我们把它截断为0：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    //计算聚光灯下片元的偏轴角（余弦值）
    float theta=dot(normalize(positionInWorld-light.position),normalize(light.lightAxis));
    //计算片元在聚光灯下的光强
    float intensity=clamp((theta-light.outCutOff)/(light.inCutOff-light.outCutOff),0.0,1.0);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>这样一来，乘以光照计算出来的颜色值后，在内张角里面的片元会正常执行光照，在外张角外面的片元会显示黑色，在内外张角之间的片元会插值变暗（不再需要if-else了，如果想要在外张角外显示其他颜色，那还是需要的）：</p>
<pre class="line-numbers language-c++"><code class="language-c++">        //聚光的每种成分光都执行衰减和亮度插值
        ambientColor*=attenuation*intensity;
        diffuseColor*=attenuation*intensity;
        specularColor*=attenuation*intensity;

        color=vec4(ambientColor+diffuseColor+specularColor,1.0f);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>编译运行后的结果如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148198233165.png" alt=""><br>使用聚光的全部源码<a href="https://github.com/Popperelay/BlogCode/tree/master/LearnOpenGL13_CommonLightSource/LearnOpenGL13_CommonLightSource_2" target="_blank" rel="external">在这里</a>。<br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">多个光源</font><br>为了简介、提高代码重用率，我们把各种光源的计算分别写成一个函数：对定向光的计算写在<code>CalcDirLight</code>函数中，对点光源的计算写在<code>CalcPointLight</code>函数中，对聚光的计算写在<code>CalcSpotLight</code>函数中。这三个函数的代码和原来的几乎一样，只不过是拿出来放到了函数里而已。</p>
<p>当我们要使用多个光源时，就可以直接使用这几个光源函数了，一般都是下面这种使用结构：</p>
<pre class="line-numbers language-c++"><code class="language-c++">out vec4 color;
#define NUM_POINT_LIGHTS 4  
void main(){
    //添加定向光计算结果到输出颜色里
    vec3 result = CalcDirLight();
    //添加点光源计算结果到输出颜色里
    for(int i=0; i<NUM_POINT_LIGHTS; i++){
        result += CalcPointLight();
    }
    //添加聚光计算结果到输出颜色里
    result += CalcSpotLight();

    color=vec4(result,1.0f);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中<code>NUM_POINT_LIGHTS</code>表示点光源的数目，是一个预编译指令，这样我们才能用它来作为数组下标。</p>
<p>这里，我们在场景中创建1个定向光、4个点光源和1个聚光。代码很好理解，所有源码<a href="https://github.com/Popperelay/BlogCode/tree/master/LearnOpenGL13_CommonLightSource/LearnOpenGL13_CommonLightSource_3" target="_blank" rel="external">在这里</a>。</p>
<p>其余代码和上一篇文章<a href="http://popperelay.com/2016/12/14/OpenGL12%E5%85%89%E7%85%A7%E8%B4%B4%E5%9B%BE/" target="_blank" rel="external">《OpenGL12：光照贴图》</a>一样。<br>编译运行后的结果如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148241070837.png" alt=""><br>&nbsp;</p>
<hr>
<p>参考文献：<a href="https://learnopengl.com/" target="_blank" rel="external">LearnOpenGL</a></p>
]]></content>
      
        <categories>
            
            <category> OpenGL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 常见光源 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OpenGL12：光照贴图Lighting Maps]]></title>
      <url>/2016/12/14/OpenGL12%E5%85%89%E7%85%A7%E8%B4%B4%E5%9B%BE/</url>
      <content type="html"><![CDATA[<p><font size="5" color="orange">为何需要光照贴图</font><br><a id="more"></a><br>在上一篇文章<a href="http://popperelay.com/2016/12/12/OpenGL11%E6%9D%90%E8%B4%A8/" target="_blank" rel="external">《OpenGL11：材质》</a>中，我们给整个立方体定义了一个材质，但是显示世界的物体往往不是同一种材料构成的，物体上的不同部分可能需要不同的材质。例如汽车的车身喷漆了往往很光亮，而轮胎的橡胶部分则比较暗淡。为了更好地模拟现实中物体接收光照的效果，我们应该为物体的不同部分指定不同的材质属性，而不是整个物体共用一个材质属性。</p>
<p>要让不同的部分对应不同的材质属性，如果不同材质的部分比较多，要精确定义很多材质是很麻烦的。其实为不同部分对应不同的材质属性，有点类似于不同的像素根据纹理坐标获取不同的纹素，这里我们我们的解决方案类似，也是使用一张纹理的纹素来作为物体上对应位置的材质属性（环境属性、漫反射属性、镜面反射属性，这些属性都是vec3类型的颜色）。对应光照下的材质属性的这种纹理叫做光照贴图lighting maps。我们这里主要介绍漫反射贴图diffuse map和镜面反射贴图specular maps（当然除此之外还有其他类型的光照贴图）。<br>【注】：</p>
<ul>
<li>材质的环境属性和漫反射属性通常都是相等的，都是一个颜色，所以就都使用漫反射贴图了，一般不再需要环境贴图了。<br>&nbsp;</li>
</ul>
<hr>
<p><font size="5" color="orange">漫反射贴图diffuse map</font><br>我们使用漫反射贴图的纹素颜色来代替材质的环境属性和漫反射属性。</p>
<p>首先，我们加载下面一张图片，它是一个由一圈钢边的<a href="https://learnopengl-cn.github.io/img/02/04/container2.png" target="_blank" rel="external">木箱</a>：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148170663195.png" alt=""><br>需要用到<a href="http://popperelay.com/2016/11/29/OpenGL5%E7%BA%B9%E7%90%86/" target="_blank" rel="external">《OpenGL5：纹理》</a>一文中的纹理加载类，所以先创建和包含相应的头文件：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#include "TextureLoader.h"
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>接着使用该类的<code>LoadTexture</code>函数加载木箱图片：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    TextureLoader textureLoader;
    GLuint diffuseMap = textureLoader.LoadTexture("container2.png");
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>为了合理使用这张纹理，我们的顶点属性里面也应该加上纹理坐标属性：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    //立方体各面顶点的坐标、法线、纹理坐标
    GLfloat vertices[] = {
        //位置坐标           //法线     //纹理坐标
        //立方体前面
         0.5f, 0.5f, 0.5f,   0, 0, 1,   1.0f, 1.0f,
         0.5f,-0.5f, 0.5f,   0, 0, 1,   1.0f, 0.0f,
        -0.5f,-0.5f, 0.5f,     0, 0, 1,   0.0f, 0.0f,
        -0.5f, 0.5f, 0.5f,   0, 0, 1,   0.0f, 1.0f,
        //立方体后
         0.5f, 0.5f,-0.5f,   0, 0,-1,   1.0f, 1.0f,
         0.5f,-0.5f,-0.5f,   0, 0,-1,   1.0f, 0.0f,
        -0.5f,-0.5f,-0.5f,   0, 0,-1,   0.0f, 0.0f,
        -0.5f, 0.5f,-0.5f,   0, 0,-1,   0.0f, 1.0f,
        //立方体上面
         0.5f, 0.5f, 0.5f,   0, 1, 0,   1.0f, 1.0f,
         0.5f, 0.5f,-0.5f,   0, 1, 0,   1.0f, 0.0f,
        -0.5f, 0.5f,-0.5f,   0, 1, 0,   0.0f, 0.0f,
        -0.5f, 0.5f, 0.5f,   0, 1, 0,   0.0f, 1.0f,
        //立方体下面
         0.5f,-0.5f, 0.5f,   0,-1, 0,   1.0f, 1.0f,
         0.5f,-0.5f,-0.5f,   0,-1, 0,   1.0f, 0.0f,
        -0.5f,-0.5f,-0.5f,   0,-1, 0,   0.0f, 0.0f,
        -0.5f,-0.5f, 0.5f,   0,-1, 0,   0.0f, 1.0f,
        //立方体右面
         0.5f, 0.5f, 0.5f,   1, 0, 0,   1.0f, 1.0f,
         0.5f, 0.5f,-0.5f,   1, 0, 0,   1.0f, 0.0f,
         0.5f,-0.5f,-0.5f,   1, 0, 0,   0.0f, 0.0f,
         0.5f,-0.5f, 0.5f,   1, 0, 0,   0.0f, 1.0f,
        //立方体左面
        -0.5f, 0.5f, 0.5f,  -1, 0, 0,   1.0f, 1.0f,
        -0.5f, 0.5f,-0.5f,  -1, 0, 0,   1.0f, 0.0f,
        -0.5f,-0.5f,-0.5f,  -1, 0, 0,   0.0f, 0.0f,
        -0.5f,-0.5f, 0.5f,  -1, 0, 0,   0.0f, 1.0f
    };
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当然，这下对顶点属性的解析也应该更新一下了：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(GLfloat), (GLvoid*)0);
    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(GLfloat), (GLvoid*)(3 * sizeof(GLfloat)));
    glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(GLfloat), (GLvoid*)(6 * sizeof(GLfloat)));
    glEnableVertexAttribArray(0);
    glEnableVertexAttribArray(1);
    glEnableVertexAttribArray(2);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>还需要在受光物体的顶点着色器中增加输入变量，用来接收纹理坐标，还要把它输出到像素着色器：</p>
<pre class="line-numbers language-c++"><code class="language-c++">layout (location=2) in vec2 texCoords; //顶点纹理坐标属性的位置值为2

out vec2 TexCoords;

void main(){
    ...
    TexCoords=texCoords;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>像素着色器要设置一个输入变量，来接收来自顶点着色器的纹理坐标：</p>
<pre class="line-numbers language-c++"><code class="language-c++">in vec2 TexCoords;
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>既然是用纹素颜色来代替材质的环境属性和漫反射属性，那么：</p>
<pre class="line-numbers language-c++"><code class="language-c++">//材质结构体
struct Material{
    sampler2D diffuse;
    vec3 specular;
    float shininess;
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>和读取纹素颜色一样，我们需要把diffuse设置为一个采样器，用于根据纹理坐标，从纹理中提取纹素颜色。材质的环境属性和漫反射属性通常是等值的，所以这里就省略环境属性的采样器了。</p>
<p>需要在主函数中，对这个采样器赋值：</p>
<pre class="line-numbers language-c++"><code class="language-c++">        //设置材质的环境属性和漫反射属性（都来自漫反射贴图，这里设置的是采样器/纹理单元的值）
        glUniform1i(glGetUniformLocation(lightObject.shaderProgram, "material.diffuse"), 0);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>接下来就是使用纹素颜色来更新环境光和漫反射光的计算了：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    //计算最终的环境光
    vec3 ambientColor=light.ambient * vec3(texture(material.diffuse,TexCoords));  //环境光
    //计算最终的漫反射光
    vec3 normal=normalize(Normal);  //单位法向量
    vec3 lightDir=normalize(light.position-positionInWorld); //光线入射方向的单位向量
    float diffuseFactor=max(dot(normal,lightDir),0.0); //漫反射系数（两个向量夹角的余弦）
    vec3 diffuseColor=diffuseFactor * light.diffuse * vec3(texture(material.diffuse,TexCoords));   //漫反射光
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>最后，需要激活相应纹理单元和绑定纹理，再进行渲染：</p>
<pre class="line-numbers language-c++"><code class="language-c++">        //激活纹理单元
        glActiveTexture(GL_TEXTURE0);
        glBindTexture(GL_TEXTURE_2D, diffuseMap);
        glBindVertexArray(lightObjectVAO);
        glDrawElements(GL_TRIANGLES, 36, GL_UNSIGNED_INT, 0);
        glBindVertexArray(0);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>编译运行后的结果如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148170663345.png" alt=""><br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">镜面贴图speculate map</font><br>上面的物体是一个带钢边的木箱，木箱部分应该是没有高光的（或者高光很弱）才对。也就是说一个物体的不同部分可能有不同的镜面反射效果。和不同部分有不同漫反射效果类似，我们使用一张镜面贴图来表示对应不同部分的不同镜面反射效果，即用镜面贴图的纹素来代替材质的镜面反射属性。通常在镜面贴图中，镜面反射强度大的用接近白色的颜色表示，反射强度小的用接近黑色的颜色表示。使用ps或gimp之类的工具，通过将图片进行裁剪，将某部分调整成黑白图样，并调整亮度/对比度，可以很容易吧一个diffuse贴图处理成specular贴图。我们这里给准备上面的箱子使用的<a href="https://learnopengl-cn.github.io/img/02/04/container2_specular.png" target="_blank" rel="external">镜面贴图</a>如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148170873539.png" alt=""><br>木箱子部分不镜面反射，只有钢边部分才有镜面光。</p>
<p>使用这张镜面贴图的过程和上面漫反射贴图类似，简单走一下：</p>
<p>首先加载镜面贴图：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    GLuint specularMap = textureLoader.LoadTexture("container2_specular.png");
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>然后在受光物体的像素着色器中，把材质的镜面属性改为采样器类型：</p>
<pre class="line-numbers language-c++"><code class="language-c++">//材质结构体
struct Material{
    sampler2D diffuse;
    sampler2D specular;
    float shininess;
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>需要对specular采样器赋值：</p>
<pre class="line-numbers language-c++"><code class="language-c++">//设置材质的镜面反射属性（来自镜面贴图）
glUniform1i(glGetUniformLocation(lightObject.shaderProgram, "material.specular"), 1);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>在像素着色器中更新对镜面光的计算：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    vec3 specularColor=specularFactor * light.specular * vec3(texture(material.specular,TexCoords)); //镜面反射光
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>最后，在主程序渲染前激活相应纹理单元并绑定：</p>
<pre class="line-numbers language-c++"><code class="language-c++">        //激活纹理单元0并绑定
        glActiveTexture(GL_TEXTURE0);
        glBindTexture(GL_TEXTURE_2D, diffuseMap);
        //激活纹理单元1并绑定
        glActiveTexture(GL_TEXTURE1);
        glBindTexture(GL_TEXTURE_2D, specularMap);
        glBindVertexArray(lightObjectVAO);
        glDrawElements(GL_TRIANGLES, 36, GL_UNSIGNED_INT, 0);
        glBindVertexArray(0);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>编译运行后的结果如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148170873632.png" alt=""><br>可以看到这个箱子明显真实多了！<br>&nbsp;</p>
<hr>
<p>使用漫反射光照贴图和镜面贴图的所有源码<a href="https://github.com/Popperelay/BlogCode/tree/master/LearnOpenGL12_LightingMaps" target="_blank" rel="external">在这里</a>。</p>
<p>其余代码不变，和<a href="http://popperelay.com/2016/12/12/OpenGL10%E5%85%89%E7%85%A7%E5%9F%BA%E7%A1%80/" target="_blank" rel="external">《OpenGL10：光照基础Phong模型》</a>一样。<br>&nbsp;</p>
<hr>
<p>参考文献：<a href="https://learnopengl.com/" target="_blank" rel="external">LearnOpenGL</a></p>
]]></content>
      
        <categories>
            
            <category> OpenGL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 光照贴图 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OpenGL11材质]]></title>
      <url>/2016/12/12/OpenGL11%E6%9D%90%E8%B4%A8/</url>
      <content type="html"><![CDATA[<p><font size="5" color="orange">材质概述</font><br>在真实世界里，每个物体会对光产生不同的反应。<a id="more"></a>钢看起来比陶瓷花瓶更闪闪发光，木头箱子肯定不会像钢箱子那样对光产生很强的反射。每个物体对镜面高光也有不同的反应。有些物体不会散射（scatter）很多光却会反射（reflect）很多光，结果看起来就有一个较小的高光点（highlight）；有些物体散射了很多，它们就会产生一个半径更大的高光（这其实就是镜面高光系数的体现）。如果我们想要模拟不同物体接受光照后的效果，就需要考虑物体的材质属性， 利用材质属性模拟出不同的效果。材质就是不同光属性组成的一个结构体。最终用材质颜色来代替<a href="http://popperelay.com/2016/12/12/OpenGL10%E5%85%89%E7%85%A7%E5%9F%BA%E7%A1%80/" target="_blank" rel="external">《OpenGL10》</a>中的物体本身颜色<code>objectColor</code>。<br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">定义材质结构体</font><br>在OpenGL10中，我们使用了冯氏光照模型来模拟复杂的光照，它有三种元素：环境光颜色、漫反射光颜色、镜面反射光颜色，我们这里再加上镜面高光系数，一起作为材质的属性，在像素着色器中组成材质结构体：</p>
<pre class="line-numbers language-c++"><code class="language-c++">//材质结构体
struct Material{
    vec3 ambient;
    vec3 diffuse;
    vec3 specular;
    float shininess;
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中<code>ambientColor</code>材质属性定义了在环境光照下这个物体反射的是什么颜色，通常这个值和物体本身颜色相同；<code>diffuseColor</code>材质属性定义了在漫反射光照下物体的颜色；<code>specularColor</code>材质属性定义了在镜面光照下的反射颜色；<code>shininess</code>材质属性定义了镜面高光系数。</p>
<p>这些属性指定了物体在不同光照下的颜色效果，用这些颜色来代替物体本身的颜色。让物体在环境光、漫反射光、镜面光下有不同的颜色，不同的颜色组合，就有了不同的材质。</p>
<p>当然，要使用这个材质结构体，我们还要定义一个结构变量：</p>
<pre class="line-numbers language-c++"><code class="language-c++">uniform Material material; //材质变量
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>定义为uniform变量后，我们就可以在主程序中设置这个材质的各个属性值。<br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">为材质赋值</font><br>我们可以在主程序中为这个uniform变量material赋值，不过在<code>glGetUniformLocation</code>函数中，填写uniform变量名称时需要带上结构体变量名字作为前缀：</p>
<pre class="line-numbers language-c++"><code class="language-c++">        //设置材质的环境属性
        GLint matAmbientLoc = glGetUniformLocation(lightObject.shaderProgram, "material.ambient");
        glUniform3f(matAmbientLoc, 1.0f, 0.5f, 0.31f);
        //设置材质的漫反射属性
        GLint matDiffuseLoc = glGetUniformLocation(lightObject.shaderProgram, "material.diffuse");
        glUniform3f(matDiffuseLoc, 1.0f, 0.5f, 0.31f);
        //设置材质的镜面反射属性
        GLint matSpecularLoc = glGetUniformLocation(lightObject.shaderProgram, "material.specular");
        glUniform3f(matSpecularLoc, 0.5f, 0.5f, 0.5f);
        //设置材质的镜面高光系数属性
        GLint matShininessLoc = glGetUniformLocation(lightObject.shaderProgram, "material.shininess");
        glUniform1f(matShininessLoc, 32.0f);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里我们把<code>ambient</code>和<code>diffuse</code>属性都设置为我们想要让物体所呈现的颜色（物体本身颜色是珊瑚红，这里也设置为珊瑚红）；由于我们不希望<code>specular</code>镜面反射属性对这个物体产生过于强烈的影响，所以设置成了（0.5f,0.5f,0.5f）；把镜面高光系数<code>shininess</code>依旧设置为32。<br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">更新三光的计算方式</font><br>我们已经使用材质颜色来代替物体本身颜色了，所以我们需要更新环境光、漫反射光、镜面光的计算方式。</p>
<p>对于环境光，我们使用材质的环境光属性乘上光源颜色，就是片元最终的环境光颜色了：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    //计算最终的环境光
    vec3 ambientColor=lightColor*material.ambient;  //环境光
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>对于漫反射光，我们依旧需要先计算出漫反射系数，漫反射系数、光源颜色和材质的漫反射属性的乘积，就是最终的漫反射光颜色：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    //计算最终的漫反射光
    vec3 normal=normalize(Normal);  //单位法向量
    vec3 lightDir=normalize(lightPos-positionInWorld); //光线入射方向的单位向量
    float diffuseFactor=max(dot(normal,lightDir),0.0); //漫反射系数（两个向量夹角的余弦）
    vec3 diffuseColor=diffuseFactor*lightColor*material.diffuse;   //漫反射光
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对于镜面光，依旧需要先计算出镜面反射系数，镜面反射系数、光源颜色和材质的镜面反射属性的乘积，就是最终的镜面反射光颜色：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    //计算最终的镜面反射光
    vec3 reflectDir=normalize(reflect(-lightDir,normal));   //反射光方向
    vec3 viewDir=normalize(viewPos-positionInWorld);  //观察方向
    float specularFactor=pow(max(dot(reflectDir,viewDir),0.0),material.shininess); //镜面反射系数
    vec3 specularColor=specularFactor*lightColor*material.diffuse; //镜面反射光
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>编译运行后的结果如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148164024107.png" alt=""><br>有点太亮了~~~<br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">分解光源颜色</font><br>上面的物体太亮了。主要是因为物体的环境属性、漫反射属性、镜面反射属性都是直接乘以光源颜色，但是我们的这个光源是环境光、漫反射光和镜面光组合在一起的，应该是环境光只对材质的环境属性起作用，不应该对材质的漫反射属性起作用。光源的成分和材质的属性应该是一一对应的。</p>
<p>所以，直接乘以光源颜色是不对的，会造成物体太亮。我们应该把光源颜色分解为环境光颜色、漫反射光颜色和镜面反射光颜色。和材质一样，我们也使用结构体来实现：</p>
<pre class="line-numbers language-c++"><code class="language-c++">//光源
struct Light{
    vec3 position;
    vec3 ambient;
    vec3 diffuse;
    vec3 specular;
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当然，同样需要定义一个光源结构体变量：</p>
<pre class="line-numbers language-c++"><code class="language-c++">uniform Light light;       //光源变量
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>接下里需要为光源结构体的这几个属性赋值了：</p>
<pre class="line-numbers language-c++"><code class="language-c++">        //设置光源的位置
        GLint lightPosLoc = glGetUniformLocation(lightObject.shaderProgram, "light.position");
        glUniform3f(lightPosLoc, lightPos.x, lightPos.y, lightPos.z);
        //设置光源的环境光成分
        GLint lightAmbientLoc = glGetUniformLocation(lightObject.shaderProgram, "light.ambient");
        glUniform3f(lightAmbientLoc, 0.2f, 0.2f, 0.2f);
        //设置光源的漫反射光成分
        GLint lightDiffuseLoc = glGetUniformLocation(lightObject.shaderProgram, "light.diffuse");
        glUniform3f(lightDiffuseLoc, 0.5f, 0.5f, 0.5f);
        //设置光源的镜面反射光成分
        GLint lightSpecularLoc = glGetUniformLocation(lightObject.shaderProgram, "light.specular");
        glUniform3f(lightSpecularLoc, 1.0f, 1.0f, 1.0f);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>环境光ambient通常设置为一个比较低的亮度，因为我们不希望环境色太过显眼；漫反射光是我们想要的光源颜色，通常是白色，这里我们把这个光调暗一点，看起来会更自然，设置为（0.5,0.5,0.5）；镜面反射光颜色通常被设置为（1.0f,1.0f,1.0f）的全强度发光。</p>
<p>最后我们需要再次更新三光的计算方式，把原来的光源颜色替换成对应的光源分量：</p>
<pre class="line-numbers language-c++"><code class="language-c++">void main(){
    //计算最终的环境光
    vec3 ambientColor=light.ambient*material.ambient;  //环境光
    //计算最终的漫反射光
    vec3 normal=normalize(Normal);  //单位法向量
    vec3 lightDir=normalize(light.position-positionInWorld); //光线入射方向的单位向量
    float diffuseFactor=max(dot(normal,lightDir),0.0); //漫反射系数（两个向量夹角的余弦）
    vec3 diffuseColor=diffuseFactor*light.diffuse*material.diffuse;   //漫反射光
    //计算最终的镜面反射光
    vec3 reflectDir=normalize(reflect(-lightDir,normal));   //反射光方向
    vec3 viewDir=normalize(viewPos-positionInWorld);  //观察方向
    float specularFactor=pow(max(dot(reflectDir,viewDir),0.0),material.shininess); //镜面反射系数
    vec3 specularColor=specularFactor*light.specular*material.specular; //镜面反射光

    color=vec4(ambientColor+diffuseColor+specularColor,1.0f);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>编译运行后的结果如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148164024164.png" alt=""><br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">不同的光源颜色</font><br>上面我们给光源的各个成分赋了一个固定的颜色，现在我们把颜色变一变，让它随着时间不停变换。由于镜面反射光通常都设为白色（1.0f,1.0f,1.0f），所以我们这里只改变环境光和漫反射光：</p>
<pre class="line-numbers language-c++"><code class="language-c++">        //随着时间变化的环境光
        vec3 ambientColor(0.2f, 0.2f, 0.2f);
        ambientColor *= vec3(sin(glfwGetTime()* 2), sin(glfwGetTime()*0.7), sin(glfwGetTime()*1.3));
        //随着时间变化的漫反射光
        vec3 diffuseColor(0.5f, 0.5f, 0.5f);
        diffuseColor *= ambientColor;
        //设置光源的环境光成分
        GLint lightAmbientLoc = glGetUniformLocation(lightObject.shaderProgram, "light.ambient");
        glUniform3f(lightAmbientLoc, ambientColor.x, ambientColor.y, ambientColor.z);
        //设置光源的漫反射光成分
        GLint lightDiffuseLoc = glGetUniformLocation(lightObject.shaderProgram, "light.diffuse");
        glUniform3f(lightDiffuseLoc, diffuseColor.x, diffuseColor.y, diffuseColor.z);
        //设置光源的镜面反射光成分
        GLint lightSpecularLoc = glGetUniformLocation(lightObject.shaderProgram, "light.specular");
        glUniform3f(lightSpecularLoc, 1.0f, 1.0f, 1.0f);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注意这里环境光和漫反射光的三个颜色分量随时间变换的快慢应该不要一致，上面是分别给<code>glfwGetTime</code>函数乘以了2、0.7、1.3。如果不这样做的话，三个颜色分量步调就会一直，只能看到原有的颜色变暗了，没有明显的颜色跨度。<br>&nbsp;</p>
<hr>
<p>到此，所有源码<a href="https://github.com/Popperelay/BlogCode/tree/master/LearnOpenGL11_Material" target="_blank" rel="external">在这里</a>。</p>
<p>编译运行后的结果类似如下：</p>
<p><iframe height="498" width="510" src="https://learnopengl-cn.github.io/img/02/03/materials.mp4" frameborder="0" 'allowfullscreen'=""></iframe><br>&nbsp;</p>
<hr>
<p>参考文献：<a href="https://learnopengl.com/" target="_blank" rel="external">LearnOpenGL</a></p>
]]></content>
      
        <categories>
            
            <category> OpenGL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 材质 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OpenGL10：光照基础Phong模型]]></title>
      <url>/2016/12/12/OpenGL10%E5%85%89%E7%85%A7%E5%9F%BA%E7%A1%80/</url>
      <content type="html"><![CDATA[<p>要模拟现实的光照是很困难的<a id="more"></a>，例如实际光照中，一束光可以经过场景中若干物体反射后，照射到目标物体上，也可以是直接照射到目标物体上。其中经过其他物体反射后再次照射到目标物体上，这是一个递归的过程，将会无比复杂。因此实际模拟光照过程中，总是采用近似模型去接近实现光照。<br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">Phong模型</font><br>冯氏光照模型（Phong Lighting Model）就是其中很经典的一个光照模型，它由三部分光照组成：环境光+漫反射光+镜面光。如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148137706557.png" alt=""><br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148137711634.png" alt=""></p>
<ul>
<li>环境光（ambient lighting）：环境光是场景中光源给定或者全局给定的一个光照常量，它一般很小，主要是为了模拟即使场景中没有光照时，也不是全黑的效果。场景中总有一点环境光，不至于使场景全部黑暗。例如远处的月亮、来自远处的光。</li>
<li>漫反射光：模拟一个发光物对另一个物体的方向性影响。比如面向光源的一面会比其他面更亮。它是Phong模型最显著的组成部分。</li>
<li>镜面光：模拟的是物体表面光滑时反射的高亮的光，效果就是光泽物体表面上出现的两点。镜面光反应的通常是光的颜色，而不是物体的颜色。<br>&nbsp;</li>
</ul>
<hr>
<p><font size="5" color="orange">环境光Ambient Lighting</font><br>一个物体受到的光照可能是光源直射的，也可能是经过物体反射过来的，总之环境光来源有很多。如果我们同时考虑直射光线和非直射光线，这种情况下的算法叫做全局光照算法。可想而知，这种算法肯定是及其复杂而且昂贵的。</p>
<p>这里我们使用一种简化的的全局照明模型来表示环境光：将环境光颜色设定为一个恒定值，加到片元的最终颜色里。</p>
<p>实现起来很简单，用恒定环境光的颜色乘以一个很小的环境因子常量，再乘以受光物体本身的颜色，就是最终在环境光影响下的物体片元颜色：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#version 330 core
out vec4 color;
uniform vec3 lightColor;
uniform vec3 objectColor;
void main(){
    //环境因子
    float ambientStrength=0.3f;
    //环境光
    vec3 ambientColor=ambientStrength*lightColor;
    color=vec4(ambientColor*objectColor,1.0f);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其余程序不变，编译运行后的结果如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/14813794356.png" alt=""><br>可以看到冯氏光照的环境光已经应用到受光物体上了，这个物体变得暗了一下，因为环境光弱了嘛！<br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">漫反射光Diffuse Lighting</font><br>从文首的环境光照图可以看到，环境光本身不提供明显的光照效果，但是漫反射光会对物体产生显著的视觉影响。漫反射光使物体上与光线排布越近的片段越能从光源处获得更多的亮度。<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148144280309.png" alt=""><br>漫反射光强度与光线入射方向和物体表面的法向量之间的夹角$\theta$有关。当$\theta =0$时，光线垂直照射物体表面，这时获得的光照强度最大；当$\theta =90$时，光线与物体表面平行，此时光线照射不到物体，物体获得的光照强度最小；当$\theta &gt;90$后，物体表面转到转到光线背面了，此时物体表面接受不到光照。</p>
<p>所以，我们可以用光线入射方向的单位向量和单位法向量的点乘，来表示光对片元颜色的影响程度。其实也就是用两个向量之间的夹角余弦值，因为两个向量都需要标准化，取的是单位向量。</p>
<p><font size="4" color="red">添加法向量</font><br>法向量是垂直于顶点表面的（单位）向量。由于顶点自身并没有表面（它只是空间中一个独立的点），所以我们利用顶点周围的顶点来计算出这个顶点的表面。我们可以使用叉乘来为立方体所有顶点计算出发现。但是由于3D立方体不是一个复杂的形状，所以我们可以简单的把法线数据手工添加到顶点数据中：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    //立方体各面顶点的坐标、法线
    GLfloat vertices[] = {
        //位置坐标           //法线  
        //立方体前面
         0.5f, 0.5f, 0.5f,   0, 0, 1,
         0.5f,-0.5f, 0.5f,   0, 0, 1,
        -0.5f,-0.5f, 0.5f,     0, 0, 1,
        -0.5f, 0.5f, 0.5f,   0, 0, 1,
        //立方体后
         0.5f, 0.5f,-0.5f,   0, 0,-1,
         0.5f,-0.5f,-0.5f,   0, 0,-1,
        -0.5f,-0.5f,-0.5f,   0, 0,-1,
        -0.5f, 0.5f,-0.5f,   0, 0,-1,
        //立方体上面
         0.5f, 0.5f, 0.5f,   0, 1, 0,
         0.5f, 0.5f,-0.5f,   0, 1, 0,
        -0.5f, 0.5f,-0.5f,   0, 1, 0,
        -0.5f, 0.5f, 0.5f,   0, 1, 0,
        //立方体下面
         0.5f,-0.5f, 0.5f,   0,-1, 0,
         0.5f,-0.5f,-0.5f,   0,-1, 0,
        -0.5f,-0.5f,-0.5f,   0,-1, 0,
        -0.5f,-0.5f, 0.5f,   0,-1, 0,
        //立方体右面
         0.5f, 0.5f, 0.5f,   1, 0, 0,
         0.5f, 0.5f,-0.5f,   1, 0, 0,
         0.5f,-0.5f,-0.5f,   1, 0, 0,
         0.5f,-0.5f, 0.5f,   1, 0, 0,
        //立方体左面
        -0.5f, 0.5f, 0.5f,  -1, 0, 0,
        -0.5f, 0.5f,-0.5f,  -1, 0, 0,
        -0.5f,-0.5f,-0.5f,  -1, 0, 0,
        -0.5f,-0.5f, 0.5f,  -1, 0, 0
    };
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们要把法线数据传递给顶点着色器，所以顶点着色器要增加一个法线属性：</p>
<pre class="line-numbers language-c++"><code class="language-c++">//顶点着色器
#version 330 core
layout (location=0) in vec3 position;  //顶点位置属性的位置值为0
layout (location=1) in vec3 normal;    //顶点法线属性的位置值为1
...
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当然，顶点数据变了，对顶点数据的解析也应该做出调整。由于光源颜色不受影响，所以法线数据对它无用，在光源的VAO中不必解析法线数据，只是把顶点位置属性解析的步长变为6个<code>GLfloat</code>就行：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(GLfloat), (GLvoid*)0);
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>对于受光物体，除此之外还需要解析法线数据：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(GLfloat), (GLvoid*)0);
    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(GLfloat), (GLvoid*)(3 * sizeof(GLfloat)));
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><font size="4" color="red">顶点着色器接收并调整法线数据</font><br>在顶点着色器中需要增加法线输入变量和法线输出变量（传递给像素着色器）：</p>
<pre class="line-numbers language-c++"><code class="language-c++">layout (location=1) in vec3 normal;    //顶点法线属性的位置值为1

out vec3 Normal;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>传进顶点着色器的法线数据是在主程序顶点数据中定义的，它们是局部坐标（模型坐标），但是我们的片元到光源的方向向量却是世界坐标，所以我们需要在顶点着色器中将输入的法线向量转化为世界坐标。</p>
<p>但是却不是简单的用模型矩阵乘以法线向量就可以，如<code>Normal=model*normal;</code>，因为当模型矩阵执行了不等比缩放时，法向量就不一定垂直于表面了，如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148146405809.png" alt=""><br>为了修复这个问题，我们需要先把模型矩阵求逆矩阵，再转置，取左上角三行三列的矩阵部分，来和法向量相乘：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    Normal=mat3(transpose(inverse(model)))*normal;
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>顶点着色器的全部源码见后面。</p>
<p><font size="4" color="red">在像素着色器中计算漫反射光</font><br>现在每个顶点有了正确的法向量，但是我们还需要从片元指向光源的向量，所以还需要光源的位置坐标和顶点的世界坐标。</p>
<p>光源的位置坐标可以从主程序用uniform变量传到像素着色器：<br>在像素着色器中定义光源位置uniform变量：</p>
<pre class="line-numbers language-c++"><code class="language-c++">uniform vec3 lightPos;    //光源位置
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>然后在主程序中给该uniform变量赋值：</p>
<pre class="line-numbers language-c++"><code class="language-c++">        //设置uniform变量光源位置lightPos
        GLint lightPosLoc = glGetUniformLocation(lightObject.shaderProgram, "lightPos");
        glUniform3f(lightPosLoc, lightPos.x, lightPos.y, lightPos.z);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>我们还需要顶点的世界坐标，可以在顶点着色器中让输入的顶点坐标乘以模型矩阵，就变成了顶点的世界坐标了，把结果输出到像素着色器就可以了。</p>
<p>现在顶点着色器中定义输出变量，用于把顶点的世界坐标传递给像素着色器：</p>
<pre class="line-numbers language-c++"><code class="language-c++">out vec3 positionInWorld;
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>然后在顶点着色器的main函数中，计算出顶点的世界坐标：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    positionInWorld=vec3(model*vec4(position,1.0f));
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>当然还需要在像素着色器中定义一个同名输入变量，来接收顶点的世界坐标：</p>
<pre class="line-numbers language-c++"><code class="language-c++">in vec3 positionInWorld;
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>在像素着色器中已经有了光源世界坐标、顶点世界坐标，我们可以用它们来计算从片元到光源的单位方向向量：</p>
<pre class="line-numbers language-c++"><code class="language-c++">vec3 lightDir=normalize(lightPos-positionInWorld); //光线入射方向的单位向量
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>当然，法向量也需要标准化，变成单位向量，再用法向量刚才的光线入射方向的单位向量点乘，就可以得到漫反射光的强度（就是两个向量夹角的余弦）：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    //计算漫反射光
    vec3 normal=normalize(Normal);  //单位法向量
    float diffuseFactor=max(dot(normal,lightDir),0.0); //漫反射光系数（两个向量夹角的余弦）
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>用漫反射光强度乘以光源颜色，就能得到漫反射光颜色了。再加上之前的环境光后，乘以片元本身的颜色，就能得到最终的片元颜色了：</p>
<pre class="line-numbers language-c++"><code class="language-c++">color=vec4((ambientColor+diffuseColor)*objectColor,1.0f);
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>到此，Phong模型中的环境光和漫反射光都搞定了。所有源码<a href="https://github.com/Popperelay/BlogCode/tree/master/LearnOpenGL10_PhongLighting/LearnOpenGL10_PhongLighting_1" target="_blank" rel="external">在这里</a>。</p>
<p><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148163892539.png" alt=""><br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">镜面反射光Specular Lighting</font><br>和环境光一样，镜面反射光也要依据光的入射向量和法向量，但是镜面光还会依据观察方向，例如玩家是从什么方向看着这个片元的：</p>
<p>当镜面反射光和观察方向夹角$\theta$越小时，人眼观察到的镜面光成分越明显。镜面反射系数定义为：$specFactor=\cos (\theta)^s$。其中s是镜面高光系数 ，它的值一般为2的整数幂，值越大高光部分越集中。下图是不同高光系数下的高光效果：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148152626008.png" alt=""></p>
<p><font size="4" color="red">求反射光线的方向向量</font><br>为了计算出夹角$\theta$，我们需要先求出反射光线方向。可以使用<code>reflect</code>函数求出：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    vec3 reflectDir=normalize(reflect(-lightDir,normal));   //反射光方向
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>该函数的第一个参数是从光源到片元的光线入射方向，所以需要把<code>lightDir</code>取反，因为之前求漫反射光的时候它是从片元指向光源的；第二个参数是法向量。当然求得的反射关系方向也需要标准化。</p>
<p><font size="4" color="red">计算观察方向</font><br>然后我们需要求出观察方向，我们这里在像素着色器中设置一个uniform变量来表示观察位置：</p>
<pre class="line-numbers language-c++"><code class="language-c++">uniform vec3 viewPos;     //观察位置
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>然后在主程序中把摄像机的位置赋值给该uniform变量：</p>
<pre class="line-numbers language-c++"><code class="language-c++">        //设置uniform变量观察位置viewPos
        GLint viewPosLoc = glGetUniformLocation(lightObject.shaderProgram, "viewPos");
        glUniform3f(viewPosLoc, mycamera.cameraPos.x, mycamera.cameraPos.y, mycamera.cameraPos.z);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>我们再用观察位置减去顶点的世界坐标，就能得到观察方向了：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    vec3 viewDir=normalize(viewPos-positionInWorld);  //观察方
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><font size="4" color="red">计算镜面反射系数</font><br>有了观察方向和反射光方向，我们就可以用向量点乘求出夹角$\theta$了，从而求出镜面反射系数：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    float specularFactor=pow(max(dot(reflectDir,viewDir),0.0),32); //镜面反射系数
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这里为了不让镜面成分过于显眼，我们把镜面高光系数设置为32。</p>
<p><font size="4" color="red"></font><br>接下来我们还需要设置一个镜面反射强度，我们给镜面高光一个中等亮度颜色，设为0.5：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    float specularStrength=0.5f; //镜面反射强度
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>用这个镜面反射强度乘以镜面高光系数再乘以光源颜色，就能得到镜面反射光颜色了：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    vec3 specularColor=specularStrength*specularFactor*lightColor; //镜面反射光
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><font size="4" color="red">加入镜面反射光</font><br>最后，我们需要加上Phong模型的最后一个成分：镜面反射光：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    color=vec4((ambientColor+diffuseColor+specularColor)*objectColor,1.0f);
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>环境光、漫反射光和镜面反射光的和构成了最终的光照颜色，再乘上物体本身的颜色，就是受光物体最终的输出颜色了。<br>&nbsp;</p>
<hr>
<p>到此，我们为Phong光照模型计算了全部光照元素。全部源码<a href="https://github.com/Popperelay/BlogCode/tree/master/LearnOpenGL10_PhongLighting/LearnOpenGL10_PhongLighting_2" target="_blank" rel="external">在这里</a>。</p>
<p>编译运行后的结果如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148163932939.png" alt=""><br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">per-vertex和per-fragment实现光照的对比</font><br>我们上面的光照计算是在像素着色器中进行的，这种是基于片元计算的，称为Phong Shading（冯氏光照）。但是早期的光照着色器，开发者是在顶点着色器中实现这些光照的，这是基于顶点计算的，称为Gouraud Shading。因为顶点相比片元来说，顶点要少得多，光照的计算频率会更低，所以会更高效。然而，如果在顶点着色器中计算冯氏光照，那么除了顶点以外的其他片元，都只是根据顶点颜色插值得到自己的颜色，这种插值后的光照显得不是很真实，没有冯氏关照的那种平滑的光照效果：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148152749318.png" alt=""><br>基于顶点这是的Gouraud Shading想要获得更平滑的效果，就得使用更多的顶点来加以完善，下面的图分别显示了少量顶点和大量顶点的基于顶点的关照计算效果：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148152749374.png" alt=""><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148152749434.png" alt=""><br>&nbsp;</p>
<hr>
<p>参考文献：<a href="https://learnopengl.com/" target="_blank" rel="external">LearnOpenGL</a></p>
]]></content>
      
        <categories>
            
            <category> OpenGL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 冯氏光照 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OpenGL9：光照场景]]></title>
      <url>/2016/12/10/OpenGL9%E5%85%89%E7%85%A7%E5%9C%BA%E6%99%AF/</url>
      <content type="html"><![CDATA[<p>我们先来看看物体颜色颜色是怎么形成的。<br><a id="more"></a><br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">光照颜色和物体颜色</font><br>计算机中的颜色主要是由三基色（RGB）来表示的，用有限种颜色来模拟现实世界中（无限）的颜色，因为现实世界中能被人眼区分的颜色只有有限种，差别太小的颜色人眼是看不出来的。如果想了解屏幕颜色是如何形成的，可以参考<a href="">《》</a></p>
<p>OpenGL中颜色用一个vec3向量来表示：</p>
<pre class="line-numbers language-c++"><code class="language-c++">vec3 ourColor(1.0f,0.5f,0.31f);
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>在光学物理中，我们知道：我们看到的物体的颜色，其实是物体自身颜色和光源颜色相互作用（或者说相乘）的结果。比如物体本身是绿色，如果用白光去照它，那么物体会反射绿光，吸收其他色光，所以我们看到的物体颜色就是绿色；但是如果物体颜色是绿色，用红光去照它，那么物体就会把红色光全部吸收，没有反射光，所以我们看到的物体颜色就是黑色。</p>
<p>所以，物体颜色可以定义为这个物体从一个光源反射各个颜色分量的多少。</p>
<p>比如光源颜色是深橄榄绿色，物体颜色是珊瑚红，那么最后被人眼看到的物体颜色是：</p>
<pre class="line-numbers language-c++"><code class="language-c++">vec3 lightColor(0.33f, 0.42f, 0.18f);  //深橄榄绿色
vec3 objectColor(1.0f, 0.5f, 0.31f);   //珊瑚红
vec3 result = lightColor * toyColor; // = (0.33f, 0.21f, 0.06f);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>&nbsp;</p>
<hr>
<p>下面我们来创建一个最基本的光照场景。</p>
<p><font size="5" color="orange">创建一个光照场景</font><br>我们需要在场景中创建一个光源，设置为白色；还需要一个受光物体（被光源照射的物体）。光源和受光物体我们都用前面文章里的立方体来表示。</p>
<p>我们这里立方体的顶点数据只有顶点坐标，暂时不要颜色和纹理坐标属性了。顶点数据见后面的完整代码。</p>
<p>由于后面的文章里，我们还需要继续使用这个光照场景，后面会频繁地对物体顶点数据做一些改变，但是我们并不想因此影响到灯，所以我们光源和受光物体应该当做两个不同的立方体来绘制，不像前面文章里的10个物体都可以绑定一个VAO来绘制。我们这里给光源和受光物体分别创建一个VAO：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    //光源VAO
    GLuint lightSourceVAO, VBO, EBO;
    glGenVertexArrays(1, &lightSourceVAO);
    glGenBuffers(1, &VBO);
    glGenBuffers(1, &EBO);
    glBindVertexArray(lightSourceVAO);
    glBindBuffer(GL_ARRAY_BUFFER, VBO);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);
    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(GLfloat), (GLvoid*)0);
    glEnableVertexAttribArray(0);
    glBindVertexArray(0);

    //受光物体VAO
    GLuint lightObjectVAO;
    glGenVertexArrays(1, &lightObjectVAO);
    glBindVertexArray(lightObjectVAO);
    glBindBuffer(GL_ARRAY_BUFFER, VBO);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(GLfloat), (GLvoid*)0);
    glEnableVertexAttribArray(0);
    glBindVertexArray(0);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>由于受光立方体的顶点数据和此时光源立方体的顶点数据相同，所以在受光物体的VAO中可以直接使用光源立方体的VBO和EBO，直接绑定即可，不用再使用<code>glBufferData</code>函数把数据发送到显存。</p>
<p>接下里我们需要给光源和受光物体分别设置顶点着色器和像素着色器（因为这是两个渲染效果不同的物体，不能使用同一套着色器）：<br>光源的顶点着色器和受光物体的顶点着色器都是如下：</p>
<pre class="line-numbers language-c++"><code class="language-c++">//顶点着色器
#version 330 core
layout (location=0) in vec3 position;  //顶点位置变量的属性位置值为0
//模型矩阵
uniform mat4 model;
//观察矩阵
uniform mat4 view;
//投影矩阵
uniform mat4 projection;

void main(){
    gl_Position=projection * view * model * vec4(position,1.0f);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>光源的像素着色器代码如下（光源颜色始终是白色）：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#version 330 core
out vec4 color;
void main(){
    color=vec4(1.0f,1.0f,1.0f,1.0f);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>受光物体的像素着色器代码如下：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#version 330 core
out vec4 color;
uniform vec3 lightColor;
uniform vec3 objectColor;
void main(){
    color=vec4(lightColor*objectColor,1.0f);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>受光物体的像素着色器里有两个uniform变量，用于从主程序里接收光源颜色和物体本身颜色，输出颜色是这两个颜色的乘积。</p>
<p>在主程序里，我们给这两个uniform变量赋值：</p>
<pre class="line-numbers language-c++"><code class="language-c++">        GLint lightColorLoc = glGetUniformLocation(lightObject.shaderProgram, "lightColor");
        GLint objectColorLoc = glGetUniformLocation(lightObject.shaderProgram, "objectColor");
        glUniform3f(lightColorLoc, 1.0f, 1.0f, 1.0f);
        glUniform3f(objectColorLoc, 1.0f, 0.5f, 0.31f);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面<code>lightObject</code>是受光物体的着色器类对象。</p>
<p>我们还需要把这两个物体放在不同位置上。对于光源我们先给它设置一个全局变量，表示光源位置：</p>
<pre class="line-numbers language-c++"><code class="language-c++">//光源位置
vec3 lightPos(1.0f, 0.0f, -3.0f);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>接着在模型矩阵中设置光源所处的位置，旋转角度和缩放系数：</p>
<pre class="line-numbers language-c++"><code class="language-c++">//模型矩阵
        mat4 lightSource_model;
        lightSource_model = translate(lightSource_model, lightPos);
        lightSource_model = rotate(lightSource_model, radians(15.0f), vec3(0.5f, 1.0f, 1.0f));
        lightSource_model = scale(lightSource_model, vec3(0.5f));
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当然，受光物体的模型矩阵也需要做一些类似变换：</p>
<pre class="line-numbers language-c++"><code class="language-c++">        mat4 lightObject_model;
        lightObject_model = translate(lightObject_model, vec3(-1, 0, 0));
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>接下来就是需要给两个物体设置观察矩阵和投影矩阵了，它俩在同一场景里，观察矩阵和投影矩阵应该是一样的：</p>
<pre class="line-numbers language-c++"><code class="language-c++">        //观察矩阵
        mat4 view = mycamera.GetViewMatrix();
        //投影矩阵
        mat4 projection = perspective(radians(mycamera.cameraFov), (GLfloat)WIDTH / (GLfloat)HEIGHT, 0.1f, 100.0f);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>当然，不要忘了把模型、观察、投影矩阵赋值给相应的uniform变量（两个物体的像素着色器里都有这些uniform变量，都需要赋值）。</p>
<p>最后就是渲染出光源物体和受光物体了，需要分别绑定各自的VAO：<br>光源的绑定和渲染：</p>
<pre class="line-numbers language-c++"><code class="language-c++">        //绑定VAO，完成顶点输入初始化
        glBindVertexArray(lightSourceVAO);
        //绘图
        glDrawElements(GL_TRIANGLES, 36, GL_UNSIGNED_INT, 0);
        //解绑VAO
        glBindVertexArray(0);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>受光物体的绑定和渲染：</p>
<pre class="line-numbers language-c++"><code class="language-c++">        glBindVertexArray(lightObjectVAO);
        glDrawElements(GL_TRIANGLES, 36, GL_UNSIGNED_INT, 0);
        glBindVertexArray(0);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><strong>注意，它俩需要分别在各自的<code>program.use</code>激活着色器程序对象之后</strong>。<br>&nbsp;</p>
<hr>
<p>到此，我们就构建完这个最基本的光照场景了。全部源码<a href="https://github.com/Popperelay/BlogCode/tree/master/LearnOpenGL9_LightingScene" target="_blank" rel="external">在这里</a>。</p>
<p>编译运行后，结果如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148137889353.png" alt=""><br>&nbsp;</p>
<hr>
<p>参考文献：<a href="https://learnopengl.com/" target="_blank" rel="external">LearnOpenGL</a></p>
]]></content>
      
        <categories>
            
            <category> OpenGL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 光照场景 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OpenGL8：摄像机]]></title>
      <url>/2016/12/08/OpenGL8%E6%91%84%E5%83%8F%E6%9C%BA/</url>
      <content type="html"><![CDATA[<p>OpenGL本身没有摄像机的概念，是我们虚构的，我们通过把场景往反方向移动的方式来模拟出摄像机，产生一种我们在移动的感觉。<br><a id="more"></a><br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">摄像机坐标系（观察坐标系）</font><br>摄像机默认位置是在世界空间原点，通过观察矩阵把所有的世界坐标转化为相对于摄像机位置与方向的观察坐标。但是通过观察矩阵，摄像机不一定要在原点，也是可以移动的，这就有了我们在游戏中用键盘鼠标手柄等移动视角的效果。</p>
<p>观察矩阵就是把世界坐标系通过矩阵变换转化为观察坐标系。那么观察坐标系是怎么构成的呢？</p>
<p>观察坐标系的组成需要有4个要素构成：</p>
<ul>
<li>摄像机的世界坐标，用来作为观察坐标系的原点，对应下面第一幅图中的摄像机位置。<pre class="line-numbers language-c++"><code class="language-c++">          //摄像机位置
          vec3 cameraPos = vec3(0.0, 0.0, 3.0f);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li>观察坐标系的+z轴。通常用摄像机照射的目标位置到指向摄像机位置的向量来表示，对应下面第二幅图中的蓝色轴。<pre class="line-numbers language-c++"><code class="language-c++">          //摄像机目标位置
          vec3 cameraTarget = vec3(0.0f, 0.0f, 0.0f);
          //摄像机+z轴（从目标位置指向摄像机）
          vec3 targetToCamera = normalize(cameraPos - cameraTarget);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>观察坐标系的+x轴。需要先有一个上向量，指明摄像机的正上方。再用上向量和+z轴做叉乘，得到+x轴，对应下面第三幅图（灰色的是上向量，红色的是+x轴）：<pre class="line-numbers language-c++"><code class="language-c++">          //摄像机上向量
          vec3 upVector = vec3(0.0f, 1.0f, 0.0f);
          //摄像机+x轴（上向量和+z轴的叉乘）
          vec3 cameraRight = normalize(cross(upVector, targetToCamera));
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>观察坐标系的+y轴。由+z轴和+x轴做叉乘得到，对应下面第四幅图中的绿色轴：<pre class="line-numbers language-c++"><code class="language-c++">          //摄像机+y轴（+z轴和+x轴的叉乘）
          vec3 cameraUp = normalize(cross(targetToCamera, cameraRight));
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/149233046198.png" alt=""><br>有了原点、x、y、z轴，我们就可以构建摄像机坐标系（观察坐标系）了。<br>&nbsp;</li>
</ul>
<hr>
<p><font size="5" color="orange">世界坐标系转化到观察坐标系</font><br>怎么把世界坐标系转到到观察坐标系呢？先上一个线性代数中的定理（证明可参考相关线性代数教材）：</p>
<blockquote>
<p>线性变换可以通过基及变换后的基唯一确定，且通过计算线性变换后基的值可以得到线性变换对应的矩阵A。</p>
</blockquote>
<p><font size="4" color="red">直接计算变换矩阵</font><br>在上面已经得到，在世界空间中，观察坐标系的原点：$（P_x，P_y，P_z）$，x基向量（+x轴）：$（X_x，X_y，X_z）$，y基向量（+y轴）：$（Y_x，Y_y，Y_z）$，z基向量（+z轴）：$（Z_x，Z_y，Z_z）$。上诉得到的是世界坐标系下的观察坐标系，由于都是右手坐标系，所以可以由线性变换得到。由定理可知，线性变换矩阵为：<br>$$<br>[Camera]_{world}=<br>\begin{pmatrix}<br>X_x &amp; Y_x &amp; Z_x &amp; P_x\\<br>X_y &amp; Y_y &amp; Z_y &amp; P_y \\<br>X_z &amp; Y_z &amp; Z_z &amp; P_z \\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{pmatrix}<br>$$<br>但是，上面得到的是世界坐标系下的观察坐标系，但我们要的是观察坐标系下的世界坐标系，所以观察矩阵应该是上述矩阵的逆矩阵：<br>$$<br>view=[World]_{camera}=[Camera]_{world}^{-1}<br>$$<br>这个矩阵代表了观察坐标系的世界坐标系，再乘以点P在世界坐标系下的位置向量，就可以得到该点在观察坐标下的位置向量。</p>
<p><font size="4" color="red">由旋转平移得到变换矩阵</font><br>由于世界坐标系和观察坐标系都是右手坐标系，所以世界坐标系可以通过直接旋转（线性变换）、平移（仿射变换）到观察坐标系。先由世界坐标系在原点旋转，再平移过去，和观察坐标系重合。<br>旋转矩阵R为：<br>$$<br>R=<br>\begin{pmatrix}<br>X_x &amp; Y_x &amp; Z_x &amp; 0\\<br>X_y &amp; Y_y &amp; Z_y &amp; 0 \\<br>X_z &amp; Y_z &amp; Z_z &amp; 0 \\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{pmatrix}<br>$$<br>平移矩阵T为：<br>$$<br>T=<br>\begin{pmatrix}<br>0 &amp; 0 &amp; 0 &amp; P_x \\<br>0 &amp; 0 &amp; 0 &amp; P_y \\<br>0 &amp; 0 &amp; 0 &amp; P_z \\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{pmatrix}<br>$$<br>T*R就是从世界坐标系旋转平移到观察坐标系，但是和前一种方法一样，得到的依旧是世界坐标系下的观察坐标系，而我们需要的是观察坐标系下的世界坐标系。所以观察矩阵$view=(T*R)^{-1}=R^{-1}*T^{-1}$，因为此时的R矩阵是正交矩阵，正交矩阵的逆矩阵就是其转置矩阵，所以$view=R^T*T^{-1}$。<br>又因为：<br>$$<br>R^T=<br>\begin{pmatrix}<br>X_x &amp; X_y &amp; X_z &amp; 0 \\<br>Y_x &amp; Y_y &amp; Y_z &amp; 0 \\<br>Z_x &amp; Z_y &amp; Z_z &amp; 0 \\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{pmatrix}<br>$$</p>
<p>$$<br>T^{-1}=<br>\begin{pmatrix}<br>1 &amp; 0 &amp; 0 &amp; -P_x \\<br>0 &amp; 1 &amp; 0 &amp; -P_y \\<br>0 &amp; 0 &amp; 1 &amp; -P_z \\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{pmatrix}<br>$$<br>所以：<br>$$<br>view=R^T*T^{-1}=<br>\begin{pmatrix}<br>X_x &amp; X_y &amp; X_z &amp; 0 \\<br>Y_x &amp; Y_y &amp; Y_z &amp; 0 \\<br>Z_x &amp; Z_y &amp; Z_z &amp; 0 \\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{pmatrix}<br>*<br>\begin{pmatrix}<br>1 &amp; 0 &amp; 0 &amp; -P_x \\<br>0 &amp; 1 &amp; 0 &amp; -P_y \\<br>0 &amp; 0 &amp; 1 &amp; -P_z \\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{pmatrix}<br>$$</p>
<p>通过具体例子或者证明，都可以很得到这两种方法得到的view矩阵最终是相等的。<br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">LookAt矩阵</font><br>上面两种方法得到的view矩阵也叫作LookAt矩阵，它会创建一个看着（look at）给定目标的观察矩阵，可以很高效地把世界坐标转化为观察坐标。</p>
<p>当然，我们可以自己用代码定义和实现这个LookAt矩阵，把它封装成一个函数，专门用于求看着给定目标的观察矩阵。不过GLM已经给我们实现好了，它为我们提供了一个<code>lookAt</code>函数：</p>
<pre class="line-numbers language-c++"><code class="language-c++">            //观察矩阵
            mat4 view = lookAt(vec3(0.0f, 0.0f, 3.0f), vec3(0.0f, 0.0f, 0.0f), vec3(0.0f, 1.0f, 0.0f));
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><code>lookAt</code>函数的第一个参数是摄像机的位置；第二个参数是目标的位置；第三个参数是摄像机的上向量。因为有这个三个参数就足以计算并构建出观察坐标系了（+z轴是目标指向摄像机，+x轴是上向量和+z轴的叉乘，+y轴是+z轴和+x轴的叉乘）。通过该函数就能构建出一个观察矩阵，以创建观察坐标系。</p>
<p>下面上个demo，通过改变<code>lookAt</code>函数的第一个参数摄像机的位置，让它围绕目标转圈：</p>
<pre class="line-numbers language-c++"><code class="language-c++">            //观察矩阵
            GLfloat radius = 10.0f;
            GLfloat cameraX = radius*sin(glfwGetTime());
            GLfloat cameraZ = radius*cos(glfwGetTime());
            mat4 view = lookAt(vec3(cameraX, 0.0f, cameraZ), vec3(0.0f, 0.0f, 0.0f), vec3(0.0f, 1.0f, 0.0f));
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>所有源码<a href="https://github.com/Popperelay/BlogCode/tree/master/LearnOpenGL8_Camera/LearnOpenGL8_Camera_1" target="_blank" rel="external">在这里</a>。</p>
<p>编译运行后，结果类似如下：</p>
<iframe height="498" width="510" src="https://learnopengl-cn.github.io/img/01/09/camera_circle.mp4" frameborder="0" 'allowfullscreen'=""></iframe>

<p>可以看到随着时间流逝，摄像机在围绕场景（准确说是世界坐标原点）转动了。<br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">上向量</font><br>上面的lookAt观察矩阵中以及观察坐标系构建中，有一个很诡异的上向量，它通常赋值为（0.0f,1.0f,0.0f）。</p>
<p>为何不直接将这个上向量作为观察坐标系的y轴呢？这是因为上向量不一定和+z轴正交，而我们需要得到正交的坐标系。所以就需要用上向量和+z轴叉乘得到正交的+x轴，再有+z轴+x轴叉乘才能得到正交的+y轴。</p>
<p>上向量指定了相机的头顶方向。对于相机而言，指定了相机位置、相机目标位置后，虽然相机的位置不变、指向不变，但还是可以通过改变这个上向量而影响成像的。这类似于你眼睛的位置不变，看的方向不变，但还是可以通过转动脑袋来改变哪个方向是向上，这个上向量就好比头顶的方向。其实上向量方向不同时，叉乘后得到的x轴、y轴也会发生相应变化，观察坐标系都变了，肯定会影响成像结果。</p>
<p>下面三张图片分别是上向量为（0,1,0）、（1,0,0）、（0,-1,0）的成像结果：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148101261664.png" alt=""><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148101261735.png" alt=""><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148101261795.png" alt=""><br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">用键盘移动摄像机</font><br>当我们按下A、S、W、D时，摄像机会向前后左右移动，所以我们需要先给出或计算出摄像机前、右这两个方向（即-z轴和+x轴）：</p>
<pre class="line-numbers language-c++"><code class="language-c++">//摄像机位置
vec3 cameraPos = vec3(0.0f, 0.0f, 3.0f);
//上向量
vec3 upVector = vec3(0.0f, 1.0f, 0.0f);
//摄像机照射方向（观察坐标系-z轴）
vec3 cameraFront = normalize(vec3(0, 0, -1));
//摄像机+x轴方向（观察坐标系+x轴）
vec3 cameraRight = normalize(cross(upVector, -cameraFront));
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>摄像机上方向就是摄像机前面的方向就是摄像机照射的方向，是观察坐标系的-z轴，也就是从摄像机指向目标位置；摄像机右方向就是观察坐标系的+x轴，是上向量和+z轴的叉乘。</p>
<p>接下来就是响应按键了。最初在响应键盘的ESC键时，创建了一个<code>key_callback</code>回调函数来关闭窗口，现在我们还是在这个函数里响应其它按键：</p>
<pre class="line-numbers language-c++"><code class="language-c++">//按键回调函数
void key_callback(GLFWwindow* window, int key, int scancode, int action, int mode) {
    if (key == GLFW_KEY_ESCAPE&&action == GLFW_PRESS) {
        glfwSetWindowShouldClose(window, GL_TRUE);
    }
    //响应键盘按键来移动摄像机
    float cameraSpeed = 0.05f;
    if (key == GLFW_KEY_W) {
        cameraPos += cameraSpeed * vec3(cameraFront.x, 0, cameraFront.z);
    }
    if (key == GLFW_KEY_S) {
        cameraPos -= cameraSpeed * vec3(cameraFront.x, 0, cameraFront.z);
    }
    if (key == GLFW_KEY_D) {
        cameraPos += cameraSpeed * cameraRight;
    }
    if (key == GLFW_KEY_A) {
        cameraPos -= cameraSpeed * cameraRight;
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>每当有按键按下时，OpenGL就会自动调用该函数。</p>
<p>接下来我们在使用<code>lookAt</code>函数构造观察矩阵时，传入的第二个参数目标位置，应该是摄像机位置加上摄像机照射方向向量（注意摄像机其实最关心的是它的照射方向，目标位置可以是照射方向上的任意一点，所以我们这里就直接加上了照射方向向量来得到目标位置）：</p>
<pre class="line-numbers language-c++"><code class="language-c++">        //观察矩阵
        mat4 view = lookAt(cameraPos, cameraPos + cameraFront, upVector);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>到此，我们就能通过WSAD键控制摄像机移动了。所有源码<a href="https://github.com/Popperelay/BlogCode/tree/master/LearnOpenGL8_Camera/LearnOpenGL8_Camera_2" target="_blank" rel="external">在这里</a>。</p>
<p>编译运行后的结果类似如下：</p>
<iframe height="498" width="510" src="https://learnopengl-cn.github.io/img/01/09/camera_inside.mp4" frameborder="0" 'allowfullscreen'=""></iframe>

<p>但是这个摄像机不能同时朝两个方向移动（对角线移动），而且按下一个按键时，它会先顿一下才开始移动。这是因为大多数事件输入系统一次只能处理一个键盘输入。</p>
<p>解决方案是我们在回调函数中只存储哪个按键被按下/释放的状态信息，记录到bool数组中（true表示按下）。在渲染循环中我们读取这些值，检查哪个按键是激活的，然后做出相应反应。</p>
<p>由于<code>GLFW_KRY_W</code>等本身就是int类型的，所以我们可以用它们作为bool数组下标，对应相应的按键状态信息。为了能够存储更多的按键信息，我们定义bool数组（全局变量）如下：</p>
<pre class="line-numbers language-c++"><code class="language-c++">//存储按键状态（按下/释放）的数组
bool keys[1024];
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>然后在<code>key_callbak</code>函数中设置被按下/释放的按键为true/false：</p>
<pre class="line-numbers language-c++"><code class="language-c++">//按键回调函数
void key_callback(GLFWwindow* window, int key, int scancode, int action, int mode) {
    if (key == GLFW_KEY_ESCAPE&&action == GLFW_PRESS) {
        glfwSetWindowShouldClose(window, GL_TRUE);
    }
    //响应键盘按键来设置相应按键状态
    if (action == GLFW_PRESS) {
        keys[key] = GL_TRUE;
    }
    else if(action==GLFW_RELEASE){
        keys[key] = GL_FALSE;
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后在渲染循环里读取按键状态，并做出相应反应。我们把这部分功能封装到<code>do_movement</code>函数中：</p>
<pre class="line-numbers language-c++"><code class="language-c++">//根据按键状态移动摄像机
void do_movement() {
    GLfloat cameraSpeed = 5.0f*deltaTime;
    if (keys[GLFW_KEY_W]) {
        cameraPos += cameraSpeed * vec3(cameraFront.x, 0, cameraFront.z);
    }
    if (keys[GLFW_KEY_S]) {
        cameraPos -= cameraSpeed * vec3(cameraFront.x, 0, cameraFront.z);
    }
    if (keys[GLFW_KEY_D]) {
        cameraPos += cameraSpeed*cameraRight;
    }
    if (keys[GLFW_KEY_A]) {
        cameraPos -= cameraSpeed*cameraRight;
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>最后就是在渲染循环中调用<code>do_movement</code>函数了：</p>
<pre class="line-numbers language-c++"><code class="language-c++">while (!glfwWindowShouldClose(window)) {
        ...
        do_movement();
        ...
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>编译运行后会发现，可以同时向多个方向移动了，并且按下按钮时也会立刻移动了，操作灵活了很多。<br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">平衡不同处理器的移动速度</font><br>上面的摄像机移动速度是个常量，但是实际情况下根据处理器的能力不同，有些人可能会比其他人每秒绘制更多帧，也就是以更高的频率调用<code>do_movement</code>函数，结果就是，由于处理器性能不同，有些人可能移动很快，而有些人会移动很慢。尤其是在网游中，这是很不公平的，我们需要确保在所有硬件上的移动速度都一样。</p>
<p>图形程序和游戏通常会跟踪一个时间差(deltaTime)变量，它储存了渲染上一帧所用的时间。我们把所有速度都去乘以deltaTime值。结果就是，如果我们的deltaTime很大，就意味着上一帧的渲染花费了更多时间，所以这一帧的速度需要变得更高，来平衡渲染所花去的时间。这样一来，渲染时间长的移动速度较快，渲染时间短的移动速度较慢，单位时间内的移动速度就都差不多了，这样每个用户的体验就都一样了。</p>
<p>首先设置两个全局变量来计算<code>deltaTime</code>值：</p>
<pre class="line-numbers language-c++"><code class="language-c++">//当前帧与上一帧的时间差
GLfloat deltaTime = 0.0f;
//上一帧开始的时间
GLfloat lastTime = 0.0f;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>在每一帧（一帧可以看做一次渲染循环）开始时计算出deltaTime：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    //渲染循环（游戏循环）
    while (!glfwWindowShouldClose(window)) {
        //计算deltaTime
        GLfloat currentTime = glfwGetTime();
        deltaTime = currentTime - lastTime;
        lastTime = currentTime;
        ...
    }
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>现在我们有了deltaTime，在计算速度的时候可以将其考虑进去了：</p>
<pre class="line-numbers language-c++"><code class="language-c++">//根据按键状态移动摄像机
void do_movement() {
    GLfloat cameraSpeed = 5.0f*deltaTime;
    ...
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>编译运行后的结果类似如下：</p>
<iframe height="498" width="510" src="https://learnopengl-cn.github.io/img/01/09/camera_smooth.mp4" frameborder="0" 'allowfullscreen'=""></iframe>

<p>&nbsp;</p>
<hr>
<p><font size="5" color="orange">用鼠标移动摄像机视角 </font><br>现在我们要开始用鼠标来移动摄像机了。</p>
<p>先来点基础数学知识。旋转共3个欧拉角：俯仰角（pitch）、偏航角（yaw）、滚转角（roll）。下面的图片展示了它们的含义：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148103336736.png" alt=""><br>俯仰角pitch是描述我们往上或往下看的角；偏航角yaw是描述我们往左或往右看的角；滚转角roll是描述我们如何翻滚摄像机的角（通常在太空飞船的摄像机中使用）。</p>
<p>大多数摄像机系统都支持往上下左右看，除非特殊情况一般不考虑滚转角，我们这里只关心俯仰角和偏航角。旋转摄像机的视角其实就是旋转摄像机的照射方向（也就是摄像机指向目标的向量<code>cameraToTarget</code>），摄像机的照射方向正好可以用俯仰角和偏航角来表示。为了计算简单，我们以摄像机所在位置为原点（计算结果后加上摄像机位置就是实际位置了），有如下图示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148103336799.png" alt=""><br>其中摄像机方向就是从原点发出的那条黄色线，它的俯仰角设为pitch，偏航角设为yaw。设这条向量的长度为1，那么该向量坐标应该是<code>（cos(pitch)*cos(yaw),sin(pitch),cos(pitch)*sin(yaw)）</code>。由于摄像机在旋转过程中，摄像机到目标的距离应该是不变的，所以用该向量乘以这个恒定距离，就是摄像机指向目标的向量的实际坐标，再加上摄像机位置，就能得到旋转过程中目标的实际位置。把目标实际位置传参给<code>lookAt</code>函数，就能实现摄像机旋转了。</p>
<p>但是俯仰角pitch和偏航角yaw怎么得到呢？我们把俯仰角和偏航角的初始值都设为0，用前后两帧鼠标位置的x差值作为偏航角的增量，y差值作为俯仰角的增量。这样就能从一开始得到每一帧里摄像机的俯仰角和偏航角了。</p>
<p>下面我们来实现这个功能：</p>
<p><font size="4" color="red">设置鼠标位置回调函数</font><br>首先为了让GLFW监听鼠标移动事件，我们需要注册鼠标位置回调函数（和键盘回调函数类似）：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    //注册鼠标位置回调函数
    glfwSetCursorPosCallback(window, cursor_callback);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>鼠标位置回调函数原型如下：</p>
<pre class="line-numbers language-c++"><code class="language-c++">void cursor_callback(GLFWwindow* window, double xpos, double ypos);
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><code>xpos</code>和<code>ypos</code>代表当前鼠标的位置，当我们用GLFW注册了鼠标位置回调函数后，鼠标一移动该函数就会被调用。</p>
<p><font size="4" color="red">计算鼠标位移量</font><br>接下来我们在鼠标位置回调函数<code>cursor_callback</code>中计算出前后两帧的位移量：<br>需要先声明两个全局变量用以计算位移量：</p>
<pre class="line-numbers language-c++"><code class="language-c++">//上一帧鼠标位置
GLfloat lastCursorX = WIDTH / 2;
GLfloat lastCursorY = HEIGHT / 2;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>然后在回调函数中利用这两个全局变量进行计算：</p>
<pre class="line-numbers language-c++"><code class="language-c++">GLfloat sensitivity = 0.03f;
void cursor_callback(GLFWwindow* window, double xpos, double ypos) {
    //计算前后两帧的鼠标位移量
    GLfloat xOffset = (xpos - lastCursorX)*sensitivity;
    GLfloat yOffset = (lastCursorY - ypos)*sensitivity;
    lastCursorX = xpos;
    lastCursorY = ypos;
    ...
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>由于鼠标位移量每次太大了，不可能直接作为摄像机度数的增量，不然摄像机移动太快了。所以需要给位移量乘以<code>sensitivity</code>灵敏度值。要注意的是鼠标坐标原点在窗口左上角，当我们把鼠标从下往上拉时，我们应该是希望俯仰角增大。但是由于鼠标坐标原点在窗口左上角，+x轴向右，+y轴向下，所以鼠标如果从下往上，<code>xpos - lastCursorY</code>的值会是负数，导致俯仰角不断变小。这与我们期待的相反。应该是正数才对，改成<code>lastCursorY - ypos</code>才合适。</p>
<p>由于<code>lastCursorX</code>和<code>lastCursorY</code>的初始值设在窗口中央，当我们的鼠标第一次从窗口外进入窗口内时，<code>xOffset</code>和<code>xOffset</code>就会很大，摄像机镜头就会突然旋转很大角度。为了避免这种突变，我们改动如下：</p>
<pre class="line-numbers language-c++"><code class="language-c++">//鼠标位置回调函数
bool firstCursor = true;
void cursor_callback(GLFWwindow* window, double xpos, double ypos) {
    if (firstCursor) {
        lastCursorX = xpos;
        lastCursorY = ypos;
        firstCursor = false;
    }
    //计算前后两帧的鼠标位移量
    GLfloat sensitivity = 0.03f;
    GLfloat xOffset = (xpos - lastCursorX) * sensitivity;
    GLfloat yOffset = (lastCursorY - ypos) * sensitivity;
    lastCursorX = xpos;
    lastCursorY = ypos;
    ...
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>增加了一个<code>firstCursor</code>变量来判断鼠标是否是第一次进入窗口（隐藏鼠标开启的情况下），如果是，就让<code>lastCursorX</code>和<code>lastCursorY</code>等于当前的鼠标位置值，从而避免了镜头突变。</p>
<p><font size="4" color="red">计算偏航角和俯仰角</font><br>接下来就可以用鼠标x位移量和y位移量来作为摄像机偏航角和俯仰角的增量了。在此之前我们需要声明两个全局变量表示偏航角和俯仰角，但是它们的初始值不是随意指定的。</p>
<p>摄像机俯仰角和偏航角的初始值，与摄像机照射方向（即<code>cameraDirection</code>）的初始值有关，因为需要满足之前推导出的照射方向向量公式：<code>（cos(pitch)*cos(yaw),sin(pitch),cos(pitch)*sin(yaw)）</code>。根据<code>cameraDirection</code>的初始值和该公式，可以求出俯仰角pitch和偏航角yaw的初始值：</p>
<pre class="line-numbers language-c++"><code class="language-c++">//摄像机俯仰角（弧度）
GLfloat Pitch = asin(cameraFront.y);
//摄像机偏航角（弧度）
//GLfloat Yaw = asin(sqrt((1 - cameraFront.y * cameraFront.y)));
GLfloat Yaw = asin(cameraFront.z / cos(Pitch));
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如上，偏航角的求法有两种，一种是根绝三角函数公式，另一种是直接根据向量公式做除法。注意，求出来的是弧度，不是度数。</p>
<p>有了初始值，接下来就需要在鼠标位置回调函数求每一帧的俯仰角pitch和偏航角yaw了（就是累加鼠标位移量）：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    //计算偏航角和俯仰角（弧度）
    Yaw += radians(xOffset);
    Pitch += radians(yOffset);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>摄像机的俯仰角还需要有一些限制，不能让用户看到高于89度和低于-89度的地方，因为在90度和-90度时，视角会发生逆转。所以俯仰角需要在-89度到89度之间：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    //俯仰角限制在-89度~89度之间
    if (Pitch > radians(89.0f)) {
        Pitch = radians(89.0f);
    }
    else if (Pitch < radians(-89.0f)) {
        Pitch = radians(89.0f);
    }
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>偏航角不需要限制了，因为我们希望用户能够在水平面上360转圈看。</p>
<p><font size="4" color="red">计算摄像机到目标的向量</font><br>然后就是求出，摄像机旋转之后新的摄像机照射方向（即-z轴）（该照射方向向量从一开始就一直是归一化的）：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    //摄像机到目标的向量
    cameraFront.x = cos(Pitch) * cos(Yaw);
    cameraFront.y = sin(Pitch);
    cameraFront.z = cos(Pitch) * sin(Yaw);
    cameraFront = normalize(cameraFront);
    cameraRight = normalize(cross(upVector, -cameraFront));
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><font size="4" color="red">传参给lookAt函数</font><br>最后，我们需要把求出来的，旋转中的摄像机到目标的向量，传参给<code>lookAt</code>函数，让它和摄像机位置相加，得到旋转中的目标位置，作为<code>lookAt</code>函数的第二个参数：</p>
<pre class="line-numbers language-c++"><code class="language-c++">            //观察矩阵
            mat4 view = lookAt(cameraPos, cameraPos + cameraFront, upVector);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>到此，摄像机可以旋转了，源码在缩放后面一起给出。<br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">用鼠标滚轮缩放摄像机视角</font><br>我们再来实现一个用鼠标滚轮缩放摄像机视角的功能。</p>
<p>摄像机视角是由投影矩阵<code>perspective</code>函数的第一个参数fov（视野，field of view）来指定的。我们通常在指定的视野大小在45度。这个视野指定了我们可以看到场景中多大的范围。当视野变小时，场景投影出来的空间就会减小，更小的投影空间变换到固定尺寸的窗口上，会产生放大了的感觉。</p>
<p>需要先设置一个摄像机视野的全局变量：</p>
<pre class="line-numbers language-c++"><code class="language-c++">//摄像机视野
GLfloat fov = 45.0f;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>同鼠标位置和按键一样，我们先注册一个鼠标滚轮回调函数：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    //注册鼠标滚轮回调函数
    glfwSetScrollCallback(window, scroll_callback);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>接着我们需要在鼠标滚轮回调函数中，把鼠标滚轮y值的偏移量作为视野的增量，来计算视野值，并且把视野值限制在1到45度之间：</p>
<pre class="line-numbers language-c++"><code class="language-c++">//鼠标滚轮回调函数
void scroll_callback(GLFWwindow* window, double xoffset, double yoffset) {
    if (fov >= 1.0f&& fov <= 45.0f) {
        fov -= yoffset;
    }
    if (fov < 1.0f) {
        fov = 1.0f;
    }
    else if (fov > 45.0f) {
        fov = 45.0f;
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当滚动鼠标滚轮时，yoffset值表示我们竖直滚动的大小。</p>
<p>最后，把视野值传参给投影矩阵函数：</p>
<pre class="line-numbers language-c++"><code class="language-c++">        //投影矩阵
        mat4 projection = perspective(radians(fov), (GLfloat)WIDTH / (GLfloat)HEIGHT, 0.1f, 100.0f);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>到此，我们的摄像机就实现了按键移动、鼠标旋转、滚轮缩放的功能。所有源码<a href="https://github.com/Popperelay/BlogCode/tree/master/LearnOpenGL8_Camera/LearnOpenGL8_Camera_3" target="_blank" rel="external">在这里</a>。</p>
<p>编译运行后的结果类似如下：</p>
<iframe height="498" width="510" src="https://learnopengl-cn.github.io/img/01/09/camera_mouse.mp4" frameborder="0" 'allowfullscreen'=""></iframe>

<p><font size="5" color="orange">隐藏鼠标</font><br>如果我们想要隐藏窗口上的鼠标，可以使用<code>glfwSetInputMode</code>函数：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    //隐藏鼠标
    glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>第一个参数是窗口对象，第二个参数是要设置的输入模式，我们这里要改变的是鼠标输入这种方式，第三个参数指明不显示鼠标。</p>
<p>编译运行后，可以发现无论我们怎么移动鼠标，它都不会显示了，而且有一点好处：不管把鼠标移得多远，它也不会离开窗口。<br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">摄像机类</font><br>为了减轻主函数的负担，更为了方便程序移植和模块独立，我们把有关摄像机的代码封装成一个摄像机类。</p>
<p>所有源码<a href="https://github.com/Popperelay/BlogCode/tree/master/LearnOpenGL8_Camera/LearnOpenGL8_Camera_4" target="_blank" rel="external">在这里</a>。<br>&nbsp;</p>
<hr>
<p>参考文献：<a href="https://learnopengl.com/" target="_blank" rel="external">LearnOpenGL</a></p>
]]></content>
      
        <categories>
            
            <category> OpenGL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OpenGL摄像机 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OpenGL7：坐标系统]]></title>
      <url>/2016/12/05/OpenGL7%E5%9D%90%E6%A0%87%E7%B3%BB%E7%BB%9F/</url>
      <content type="html"><![CDATA[<p>OpenGL希望每次顶点着色器运行后，我们所有可见的顶点都化为标准化设备坐标（NDC，normalized device coordinate）。<a id="more"></a>也就是说，每个顶点的x、y、z坐标都应该在-1.0到1.0之间，超出这个坐标范围的顶点都将不可见。我们通常会自己设定一个可见的坐标范围，之后再顶点着色器中将这些坐标变换为标准化设备坐标，然后将这些标准化设备坐标传入光栅器（Rasterizer），把它们变换为屏幕上的二维坐标/像素。<br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">坐标转化过程</font></p>
<p><font size="4" color="red">坐标转化过程中的坐标系统</font><br>物体的顶点在最终化为屏幕坐标之前，还会被变换到多个坐标系统。这是因为，在中间的那些特定的坐标系统里，一些操作或运算更加方便和容易。其实这个过程类似现实世界的物体被我们看到的过程：最开始由物体出发，物体上可能有各种细节需要去研究，这时候是在局部空间（或称物体空间）；接着这个物体肯定是和我们身处在一个世界里，它身边可能还有其他物体，这时候是在世界空间；但是并不是世界里所有的物体都能被我们看到，只有在我们眼睛前方的物体，才能被我们看到，脑后的东西肯定看不到了，我们眼睛视角前方的世界范围都是观察空间（或称视觉空间）；但是受视力限制，在我们眼睛前方的世界（观察空间）不是都能看得到，我们只能看到目力所能及的观察空间，眼睛前方的视觉范围就是裁剪空间，即使在我们眼睛前方，但太近或者太远不在我们的视力范围内也是看不到的，处在裁剪空间里的物体会通过反射光投影到我们的视网膜上（根据是点光线/点光源还是平行光线/太阳光，可以分为透视投影和正交投影）；在视网膜上的投影最终会转换为我们脑海中的事物，在我们脑海中形成一个世界，这就是屏幕空间。</p>
<p>总之，一个顶点在被转换为屏幕像素之前需要经历5个坐标系统：</p>
<ol>
<li>局部空间（Local Space，或称物体空间Object Space）</li>
<li>世界空间（World Space）</li>
<li>观察空间（View Space，或称视觉空间Eye Space）</li>
<li>裁剪空间（Clip Space）</li>
<li>屏幕空间（Screen Space）</li>
</ol>
<p><font size="4" color="red">坐标转化过程中的变换矩阵</font><br>流程图如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148075489991.png" alt=""><br>为了将坐标从一个坐标系转化到另一个坐标系，我们需要用到几个变换矩阵，最重要的是模型矩阵（Model）、观察矩阵（View）、投影矩阵（Projection）。我们的顶点坐标起始于局部空间，在这里它们称为局部坐标；通过模型矩阵的平移旋转缩放之后，物体被放在世界里的不同位置上，变成世界坐标；接下来会把世界坐标通过观察矩阵转化为观察坐标，使得每个坐标都是从摄像机或者说观察者的角度进行观察的；接着在观察坐标会通过投影矩阵转化为裁剪坐标，只有那些在-1.0到1.0之间的裁剪坐标，才会被裁剪出来有机会出现在屏幕上；最后，需要把裁剪坐标通过视口变换（Viewport Transform）转化为屏幕坐标，视口变换将位于-1.0到1.0范围内的坐标变换到由<code>glViewport</code>函数所定义的坐标范围内。最后变换出来的坐标将会送到光栅器，将其转化为像素。</p>
<p>我们之所以将顶点转化到各个不同的空间，是因为有些操作在特定的坐标系统中才有意义且更方便。例如，当需要对物体内部进行修改时，在局部空间中来操作会更方便；当需要对一个物体做出相对于其他物体的操作时，在世界空间中会更方便，等等。当然，也可以定义一个直接从局部坐标转化到裁剪坐标的变换矩阵，但是那样会失去很多灵活性。<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148076836196.png" alt=""><br>图中左边的过程包括模型变换、观察变换、投影变换，这些变换由用户根据需要自行指定，这些变换都在顶点着色器中完成；而图中右边的过程包括透视除法、视口变换，都是由OpenGL自动执行的，在顶点着色器处理后的阶段执行。<br>&nbsp;</p>
<hr>
<p>接下里我们更详细地讨论各个坐标系统和变换矩阵。</p>
<p><font size="5" color="orange">局部空间</font><br>局部空间是指物体所在的坐标空间，即对象最开始所在的地方。比如在建模软件（如3Dmax）中创建了一个立方体，在建模软件里的这个立方体的所有顶点都是在局部空间里。<br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">世界空间</font><br>如果将我们在建模软件中创建的所有的物体，导入到我们的程序当中，它们可能会全挤在世界的原点（0,0,0）上，这可能并不是我们想要的结果。我们想要为每一个物体定义一个位置。让它们放在世界中的不同位置上。世界坐标就是顶点在（游戏）世界里的坐标。<br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">模型变换</font><br>物体的坐标从局部空间转化到世界空间，是由模型矩阵来实现的。模型矩阵是一种变换矩阵，其实说白了就是<a href="http://popperelay.com/2016/12/02/OpenGL6%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2/" target="_blank" rel="external">《OpenGL6：坐标变换》</a>一文中的变换矩阵，它通过对物体进行平移、旋转、缩放来将物体放在世界的不同位置或朝向上。可以想象现在在建模软件里创建了一个茶壶，但是它在局部空间中太大了，我们先将它缩小，把它位移到大世界里，然后围绕着旋转一下，以搭配附近的茶壶：<br>下图是在模型空间中定义的茶壶模型：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148076831958.png" alt=""><br>茶壶通过模型变换，转化到世界坐标系中：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/14807683201.png" alt=""><br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">观察空间</font><br>观察空间经常被人们称之为OpenGL的摄像机（所以也称摄像机空间Camera Space或视觉空间Eye Space）。观察空间是将世界坐标转化为用户眼睛前方空间的坐标而产生的结果，在观察空间里的物体只是留待我们去观察的，不一定能被我们看到，得在我们视觉范围内才行。</p>
<p>OpenGL中的相机默认位于原点，指向-Z轴，通常不移动相机（因为OpenGL中实际上没有摄像机，是虚构的），而是以相反的方式来调整场景中的物体，从而达到相同的效果。例如一个物体中心位于原点，照相机也位于初始位置原点，方向指向-Z轴。为了对物体的+Z面成像，一种方式是将照相机向+Z方向后退，仍指向-Z轴；另一种方式是照相机不动，让物体沿着-Z方向移动。OpenGL采用第二种方式。<br>【注】：</p>
<ul>
<li>其实无论是眼睛还是摄像机，都是假想的概念，是为了便于计算而引入的，并不真实存在。</li>
</ul>
<p>OpenGL观察空间（或者说OpenGL的照相机）采用的是右手坐标系。想象屏幕处于三个轴的中心，则z轴穿过你的屏幕指向你。坐标系画起来如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148083756886.png" alt=""><br>之所以叫做右手坐标系，看下图：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148083781285.png" alt=""><br>可以看到大拇指指向正x轴方向，食指指向正y轴方向，中指指向正z轴方向，正好符合右手坐标系（如果用左手来做这个动作，会发现z轴的方向是相反的，这个叫做左手坐标系，它被DirectX广泛使用）。<br>【注】：</p>
<ul>
<li>OpenGL提供给用户的是右手坐标系，即局部坐标系、世界坐标系、观察坐标系等是一个右手坐标系，但是标准化设备坐标系中OpenGL使用的实际上是左手坐标系，因为投影矩阵交换了左右手。<br>&nbsp;</li>
</ul>
<hr>
<p><font size="5" color="orange">观察变换</font><br>观察变换是把世界坐标变化到观察坐标。</p>
<p>在世界坐标系中指定相机的位置、指向的目标位置（相机朝向）以及相机的正上方向（viewUp）（第三个方向轴可以由前两个方向叉乘得到）可以构造出一个观察坐标系，在通过观察矩阵，就可以将物体坐标从世界坐标系转化到观察坐标系。</p>
<p>观察矩阵是一系列平移和旋转的组合，用于平移/旋转场景从而使得特定的对象被变换到摄像机的前方。</p>
<p>观察变化前后图示如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148077063103.png" alt=""><br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">裁剪空间</font><br>在一个顶点着色器运行的最后，OpenGL期望所有要显示的顶点的观察坐标都落在一个特定的范围内，任何在这个范围之外的点都不会显示，会被裁剪掉。这个范围就是裁剪空间，通常是一个视见体（简单说就是一个观察空间里的一个棱台）。</p>
<p>根据投影方式不同，裁剪空间（视见体）可分为以下两种：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148077131993.png" alt=""><br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">投影变换</font><br>投影变换将顶点坐标从观察空间变化到裁剪空间。为了实现投影变换，我们需要定义一个投影矩阵（Projection Matrix），它会把观察坐标变换为裁剪坐标。所有在视见体内的坐标被映射为裁剪坐标后，其x、y、z坐标分量的值都会在-w和w（第四个坐标分量）之间。而在视见体外的点的坐标分量不都会在-w到w之间，所以会被裁剪掉。比如投影矩阵指定的范围时-1000到1000，那么坐标（1250,500,700）将是不可见的，因为他的x坐标超出了范围，最后它被转化为了一个大于w的裁剪坐标分量，所以被裁剪掉了。<br>【注】：</p>
<ul>
<li>如果是像三角形这种基本图元，如果它的一部分超出了裁剪范围，则OpenGL会重新构建这个三角形为一个或多个三角形，让它在裁剪范围内的那部分能够显示出来。</li>
</ul>
<p>投影方式不同，就会有不同的投影矩阵。</p>
<p><font size="4" color="red">正交投影</font><br>正交投影的投影线相互平行，且正交与投影面。它的视见体是一个立方体：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148077209888.png" alt=""><br>需要指定这个视见体的宽、高、近平面和远平面，任何在视见体之外的坐标都会被裁减掉。在视见体内部的所有坐标都会被映射为标准化设备坐标。</p>
<p>使用glm命名空间里的<code>ortho</code>函数来创建一个正交投影矩阵：</p>
<pre class="line-numbers language-c++"><code class="language-c++">mat4 proj = ortho(0.0f, 800.0f, 0.0f, 600.0f, 0.1f, 100.0f);
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>前两个参数指定了视见体的最左和最右值，第三四个参数指定了视见体的最上下和最上值，第五六个参数指定了近平面和远平面的距离。这个投影矩阵会将处于这些x、y、z值范围内的坐标变换为标准化设备坐标。<br>【注】：</p>
<ul>
<li>正交投影下顶点的w坐标值是1</li>
</ul>
<p><font size="4" color="red">透视投影</font><br>透视投影的投影线汇于一点，会造成近大远小的透视效果：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148077209937.png" alt=""><br>透视投影的视见体是一个四棱台：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148077210356.png" alt=""><br>需要指定这个视见体的视野、宽高比、近平面和远平面，任何在视见体之外的坐标都会被裁减掉。在视见体内部的所有坐标都会被映射为标准化设备坐标。</p>
<p>使用glm命名空间里的<code>perspective</code>函数来创建一个透视投影矩阵：</p>
<pre class="line-numbers language-c++"><code class="language-c++">mat4 proj = perspective(45.0f, (float)width/(float)height, 0.1f, 100.0f);
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>该函数的第一个参数指定了视野fov（field of view）的值，并以此设置了观察空间的大小（如果想要一个真实的观察效果，它的值通常是45.0f，如果想要一个末日风格的结果可以把它设得稍大点）；第二个参数指定了视口的宽高比，由视口的宽除以高所得；第三四个参数指定了近平面和远平面的距离。所有在近平面和远平面内且处于视见体内的顶点都会被渲染。<br>【注】：</p>
<ul>
<li>如果把透视矩阵的近平面值设置得太大（比如10.0f），OpenGL会将靠近摄像机的坐标（在0.0f到10.0f之间）都裁减掉，这会导致一个我们在游戏中很熟悉的视觉效果：在太过靠近一个物体的时候，视线会直接穿过去。</li>
</ul>
<p>除此之外，透视投影矩阵还修改了每个顶点坐标的w值，离观察者越远的顶点啊坐标w分量越大，从而使得在做透视除法后，产生近大远小的效果。</p>
<p><font size="4" color="red">透视除法</font><br>注意透视除法不在投影变换的范畴内，它是在投影变换之后，由OpenGL自动进行透视除法和裁剪。投影变换后的坐标范围是在-w到w之间，做完透视除法之后坐标范围在-1.0到1.0之间，变为标准化设备坐标NDC。</p>
<p>一旦坐标处在裁剪空间之后，透视除法就会被应用到裁剪空间坐标上：<br>$$<br>out =<br>\begin{pmatrix}<br>x /w \\<br>y / w \\<br>z / w<br>\end{pmatrix}<br>$$<br>顶点坐标的每个分量都会除以它的w分量，透视投影时距离观察者越远顶点坐标就会越小。这也是w分量非常重要的另一个原因，它能帮助我们进行透视投影。当使用正交投影时，虽然也要进行透视除法，但是正交投影的所有顶点w分量都是1，因此除以w分量之后不会有透视效果。</p>
<p>正交投影主要用于二维渲染以及一些建筑或工程的程序，因为这些场景中更希望顶点不会被透视所干扰。透视投影看起来更真实。</p>
<p>透视投影和正交投影效果如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148083660398.png" alt=""><br>&nbsp;</p>
<hr>
<p>总之，模型矩阵针对物体在世界里的位置角度，观察矩阵针对场景移动（或者反方向摄像机移动，因为场景移动用反方向模拟了摄像机移动效果），投影矩阵针对视见体。<br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">Demo</font><br>来一个demo，把<a href="http://popperelay.com/2016/11/29/OpenGL5%E7%BA%B9%E7%90%86/" target="_blank" rel="external">《OpenGL5：纹理》</a>一文中的纹理通过模型、观察、投影矩阵，变成向后旋转45度下的透视效果，如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148084274389.png" alt=""></p>
<p><font size="4" color="red">创建模型、观察、投影矩阵</font><br>首先，我们创建一个模型矩阵。这个模型矩阵包含了平移、旋转、缩放操作，它们会在顶点着色器中被应用到所有物体顶点上，以变换它们到全局的世界空间。这里我们让纹理平面绕着x轴旋转55度，让它看起来就像放在地上一样：</p>
<pre class="line-numbers language-c++"><code class="language-c++">        //模型矩阵
        mat4 model;
        model = rotate(model, radians(-45.0f), vec3(1.0f, 0.0f, 0.0f));
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>接着我们创建一个观察矩阵。因为纹理平面默认是处在世界原点（0,0,0）的，而摄像机也是处在世界原点的，这时候摄像机照不到纹理平面，为了让纹理平面可见，我们让场景向负z轴方向移动（因为一般要让摄像机处在原点不动）：</p>
<pre class="line-numbers language-c++"><code class="language-c++">        //观察矩阵
        mat4 view;
        view = translate(view, vec3(0.0f, 0.0f, -3.0f));
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>然后在创建一个投影矩阵。我们使用透视投影：</p>
<pre class="line-numbers language-c++"><code class="language-c++">        //投影矩阵
        mat4 projection;
        projection = perspective(radians(45.0f), (GLfloat)WIDTH / (GLfloat)HEIGHT, 0.1f, 100.0f);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><font size="4" color="red">更改顶点着色器</font><br>因为要用这三个变换矩阵去影响顶点坐标，所以我们需要先更改一下着色器，让着色器有接收这三个矩阵的变量：</p>
<pre class="line-numbers language-c++"><code class="language-c++">//顶点着色器
#version 330 core
layout (location=0) in vec3 position;  //顶点位置变量的属性位置值为0
layout (location=1) in vec3 color;     //顶点颜色变量的属性位置值为1
layout (location=2) in vec2 texCoord;  //顶点纹理坐标的属性位置值为2
out vec3 ourColor;
out vec2 TexCoord;
//模型矩阵
uniform mat4 model;
//观察矩阵
uniform mat4 view;
//投影矩阵
uniform mat4 projection;

void main(){
    gl_Position=projection * view * model * vec4(position,1.0f);
    ourColor=color;
    TexCoord=vec2(texCoord.x,1-texCoord.y);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>设置了3个uniform变量，用于从主程序接收3个变换矩阵。然后在顶点着色器的main函数里，内置变量<code>gl_Position</code>的值是几个变换矩阵与顶点坐标向量的乘积。注意这里矩阵运算的顺序是相反的（我们需要从右往左阅读三个矩阵的乘法）。</p>
<p><font size="4" color="red">把变换矩阵传递给顶点着色器</font><br>我们使用给uniform变量赋值的方法，从主程序把变换矩阵传递给着色器：</p>
<pre class="line-numbers language-c++"><code class="language-c++">        GLint modelLocation = glGetUniformLocation(myshader.shaderProgram, "model");
        glUniformMatrix4fv(modelLocation, 1, GL_FALSE, value_ptr(model));
        GLint viewLocation = glGetUniformLocation(myshader.shaderProgram, "view");
        glUniformMatrix4fv(viewLocation, 1, GL_FALSE, value_ptr(view));
        GLint projectionLocation = glGetUniformLocation(myshader.shaderProgram, "projection");
        glUniformMatrix4fv(projectionLocation, 1, GL_FALSE, value_ptr(projection));
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>全部源码<a href="https://github.com/Popperelay/BlogCode/tree/master/LearnOpenGL7_CoordinateSystem/LearnOpenGL7_CoordinateSystem_1" target="_blank" rel="external">在这里</a>。<br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">3D箱子</font><br>我们的顶点坐标都是3D的，但是到目前为止，我们还是在使用一个2D平面。因为我们只渲染了一个平面，下面我们尝试渲染一个立方体箱子。</p>
<p>说到立方体，很容易想到应该设置8个顶点，但是我们的立方体每个面上都会有一张纹理，一个顶点紧邻着三个面，也就是说要让一个顶点表示3个纹理的顶点纹素，这是不可能的，因为一个顶点只对应着一个纹理坐标。所以我们需要把每个面上的纹理分开来画。一个面有4个顶点，6个面就应该设置24个顶点。每个顶点都会出现3次，但只是顶点坐标相同，对应的纹理坐标是不同的：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    GLfloat vertices[] = {
        //位置坐标          //颜色           //纹理坐标
        //立方体前面
         0.5f, 0.5f, 0.5f,  1.0f,0.0f,0.0f,  1.0f,1.0f,
         0.5f,-0.5f, 0.5f,  0.0f,1.0f,0.0f,  1.0f,0.0f,
        -0.5f,-0.5f, 0.5f,  0.0f,0.0f,1.0f,  0.0f,0.0f,
        -0.5f, 0.5f, 0.5f,  1.0f,1.0f,0.0f,  0.0f,1.0f,
        //立方体后面
         0.5f, 0.5f,-0.5f,  1.0f,0.0f,0.0f,  1.0f,1.0f,
         0.5f,-0.5f,-0.5f,  0.0f,1.0f,0.0f,  1.0f,0.0f,
        -0.5f,-0.5f,-0.5f,  0.0f,0.0f,1.0f,  0.0f,0.0f,
        -0.5f, 0.5f,-0.5f,  1.0f,1.0f,0.0f,  0.0f,1.0f,
        //立方体上面
         0.5f, 0.5f, 0.5f,  1.0f,0.0f,0.0f,  1.0f,1.0f,
         0.5f, 0.5f,-0.5f,  0.0f,1.0f,0.0f,  1.0f,0.0f,
        -0.5f, 0.5f,-0.5f,  0.0f,0.0f,1.0f,  0.0f,0.0f,
        -0.5f, 0.5f, 0.5f,  1.0f,1.0f,0.0f,  0.0f,1.0f,
        //立方体下面
         0.5f,-0.5f, 0.5f,  1.0f,0.0f,0.0f,  1.0f,1.0f,
         0.5f,-0.5f,-0.5f,  0.0f,1.0f,0.0f,  1.0f,0.0f,
        -0.5f,-0.5f,-0.5f,  0.0f,0.0f,1.0f,  0.0f,0.0f,
        -0.5f,-0.5f, 0.5f,  1.0f,1.0f,0.0f,  0.0f,1.0f,
        //立方体右面
         0.5f, 0.5f, 0.5f,  1.0f,0.0f,0.0f,  1.0f,1.0f,
         0.5f, 0.5f,-0.5f,  0.0f,1.0f,0.0f,  1.0f,0.0f,
         0.5f,-0.5f,-0.5f,  0.0f,0.0f,1.0f,  0.0f,0.0f,
         0.5f,-0.5f, 0.5f,  1.0f,1.0f,0.0f,  0.0f,1.0f,
        //立方体左面
        -0.5f, 0.5f, 0.5f,  1.0f,0.0f,0.0f,  1.0f,1.0f,
        -0.5f, 0.5f,-0.5f,  0.0f,1.0f,0.0f,  1.0f,0.0f,
        -0.5f,-0.5f,-0.5f,  0.0f,0.0f,1.0f,  0.0f,0.0f,
        -0.5f,-0.5f, 0.5f,  1.0f,1.0f,0.0f,  0.0f,1.0f
    };
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当然接下来需要对每个面指定索引了：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    //顶点索引
    GLuint indices[] = {
        //立方体前面
        0,1,3,  
        1,2,3,   
        //立方体后面
        4,5,7,
        5,6,7,
        //立方体上面
        8,9,11,
        9,10,11,
        //立方体下面
        12,13,15,
        13,14,15,
        //立方体右面
        16,17,19,    
        17,18,19,
        //立方体左面
        20,21,23,
        21,22,23
    };
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>【注】：</p>
<ul>
<li>也可以不用索引，直接画组成立方体的每个三角形，这样6个面，每个面2个三角形，每个三角形3个顶点，那就应该是36个顶点了。</li>
</ul>
<p>为了有趣点，我们让立方体随着时间旋转：</p>
<pre class="line-numbers language-c++"><code class="language-c++">        //模型矩阵
        mat4 model;
        model = rotate(model, (GLfloat)glfwGetTime()*radians(55.0f), vec3(0.5f, 1.0f, 0.0f));
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>最后使用<code>glDrawElements</code>函数来绘制立方体，这次需要根据36个顶点索引来绘制36个顶点：</p>
<pre class="line-numbers language-c++"><code class="language-c++">        //绘图
        glDrawElements(GL_TRIANGLES, 36, GL_UNSIGNED_INT, 0);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>编译运行后应该得到类似下面的效果：</p>
<iframe height="498" width="510" src="https://learnopengl-cn.github.io/img/01/08/coordinate_system_no_depth.mp4" frameborder="0" 'allowfullscreen'=""></iframe>

<p>但是这个立方体有点怪，有些面本应该被挡住的，却绘制在了这个立方体的其他面之上。这是因为OpenGL是一个三角形一个三角形来绘制我们的立方体的，后绘制的三角形会覆盖之前绘制的，它并不会到某个三角形被遮挡了不该绘制。</p>
<p>幸运的是，OpenGL把每个像素的深度信息（通常是像素的z坐标值）存储在了一个叫做Z缓冲（Z-buffer）的缓冲中，它允许OpenGL决定何时覆盖一个像素而何时不覆盖。<br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">Z缓冲</font><br>OpenGL存储窗口上所有像素的深度信息于一个Z缓冲（Z-buffer）中，也称深度缓冲（Depth Buffer）。GLFW会自动为我们生成这样一个缓冲（就像它有一个颜色缓冲来存储图像的颜色）。当一个片元（还没绘制到窗口上的像素）准备输出它的颜色时，OpenGL会将它的深度值（z值）和相应坐标上的z缓冲进行比较，如果当前的片元在窗口像素之后（片元深度值小于窗口像素深度值，它们都是负数，越大的离摄像机越近），它将会被丢弃，否则将会覆盖。这个过程称为深度测试（Depth Testing），它是由OpenGL自动完成的。</p>
<p>我们首先需要用<code>glEnable</code>函数告诉OpenGL，我们想要开启深度测试，因为它默认是关闭的：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    glEnable(GL_DEPTH_TEST);
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><code>glEnable</code>和<code>glDisable</code>函数允许我们启用或禁用某个OpenGL功能。这个功能会一直保持启用/禁用状态，直到另一个调用来禁用/启用它。所以上面的那行代码就不用写到渲染循环里面了，因为一开启后就会一直开启，直到显式关闭。</p>
<p>接着还需要在每次渲染循环之前清除深度缓冲，否则前一帧的深度信息仍然保存在缓冲中。就像清除颜色缓冲一样，我们可以通过在<code>glClear</code>函数中指定<code>GL_DEPTH_BUFFER_BIT</code>位来清除深度缓冲：</p>
<pre class="line-numbers language-c++"><code class="language-c++">        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>添加上面的代码，编译运行后的结果类似如下：</p>
<p><iframe height="498" width="510" src="https://learnopengl-cn.github.io/img/01/08/coordinate_system_depth.mp4" frameborder="0" 'allowfullscreen'=""></iframe><br>&nbsp;</p>
<hr>
<p>到此，所有源码<a href="https://github.com/Popperelay/BlogCode/tree/master/LearnOpenGL5_Texture/LearnOpenGL5_Texture_2" target="_blank" rel="external">在这里</a>。<br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">多个立方体</font><br>因为要创建的10个立方体长得一样的，只是位置方向不同而已。所以我们只需要调用<code>glDrawElements</code>函数10次，并且每一次调用时给顶点着色器传递不同的模型矩阵就可以：</p>
<pre class="line-numbers language-c++"><code class="language-c++">        vec3 cubeTranlate[] = {
            vec3(0.0f,  0.0f,  0.0f),
            vec3(2.0f,  5.0f, -15.0f),
            vec3(-1.5f, -2.2f, -2.5f),
            vec3(-3.8f, -2.0f, -12.3f),
            vec3(2.4f, -0.4f, -3.5f),
            vec3(-1.7f,  3.0f, -7.5f),
            vec3(1.3f, -2.0f, -2.5f),
            vec3(1.5f,  2.0f, -2.5f),
            vec3(1.5f,  0.2f, -1.5f),
            vec3(-1.3f,  1.0f, -1.5f)
        };

        //绑定VAO，完成顶点输入初始化
        glBindVertexArray(VAO);
        for (int i = 0; i < 10; i++) {
            mat4 model;
            model = translate(model, cubeTranlate[i]);
            model = rotate(model, (GLfloat)glfwGetTime()*radians(50.0f), vec3(0.5f, 1.0f, 1.0f));
            glUniformMatrix4fv(modelLocation, 1, GL_FALSE, value_ptr(model));
            //绘图
            glDrawElements(GL_TRIANGLES, 36, GL_UNSIGNED_INT, 0);
        }
        //解绑VAO
        glBindVertexArray(0);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这样就能在不同位置上显示10个立方体了，而且它们都在转。</p>
<p>所有源码<a href="https://github.com/Popperelay/BlogCode/tree/master/LearnOpenGL5_Texture/LearnOpenGL5_Texture_3" target="_blank" rel="external">在这里</a>。</p>
<p>编译运行后结果如下：</p>
<p><iframe height="498" width="510" src="http://player.youku.com/embed/XMTg0OTk1MjY4OA==" frameborder="0" 'allowfullscreen'=""></iframe><br>&nbsp;</p>
<hr>
<p>参考文献：<a href="https://learnopengl.com/" target="_blank" rel="external">LearnOpenGL</a></p>
]]></content>
      
        <categories>
            
            <category> OpenGL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OpenGL坐标系统 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OpenGL6坐标变换]]></title>
      <url>/2016/12/02/OpenGL6%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2/</url>
      <content type="html"><![CDATA[<p>在本文将会介绍利用矩阵来对图形进行坐标变化，如平移、旋转、缩放。<a id="more"></a>下面先简单介绍一些数学知识，更详细的可以参考[《几何变换》]一文。<br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">向量</font><br>向量的乘积分为点乘和叉乘。</p>
<p><font size="4" color="orange">向量点乘</font><br>两个向量的点乘等于它们的模和夹角余弦值的乘积：<br>$$<br>\vec x \cdot \vec y = || \vec x || \cdot ||\vec y|| \cdot \cos \theta<br>$$<br>当两个向量的夹角$\theta$是90度时，余弦值就为0，那么点乘结果就是0,；如果两个向量的夹角是0度，余弦值就为1，那么点乘结果就是两个向量模的乘积。所以，使用点乘可以很容易测试两个向量是否正交或平行。</p>
<p>上面的公式是点乘的一般数学计算，是根据向量模长和夹角来计算的。除此之外，还可以通过向量的坐标来计算，也就是向量的矩阵运算。举例如下：<br>$$<br>\begin{pmatrix}<br>\color{red}{0.6} \\<br>-\color{green}{0.8} \\<br>\color{blue}0<br>\end{pmatrix}<br>\cdot<br>\begin{pmatrix}<br>\color{red}0 \\<br>\color{green}1 \\<br>\color{blue}0<br>\end{pmatrix}<br>= (\color{red}{0.6} * \color{red}0) + (-\color{green}{0.8} * \color{green}1) + (\color{blue}0 * \color{blue}0) = -0.8<br>$$<br>点乘在计算光照的时候会非常有用。</p>
<p><font size="4" color="red">向量叉乘</font><br>向量的叉乘只在3D空间中有定义，它需要两个不平行的向量作为输入，生成一个正交于两个输入向量的第三个向量。如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148058188369.png" alt=""><br>向量叉乘只有一种计算方法，公式如下：<br>$$<br>\begin{pmatrix}<br>\color{red}{A_{x}} \\<br>\color{green}{A_{y}} \\<br>\color{blue}{A_{z}}<br>\end{pmatrix}<br>\times<br>\begin{pmatrix}<br>\color{red}{B_{x}} \\<br>\color{green}{B_{y}} \\<br>\color{blue}{B_{z}}<br>\end{pmatrix}<br>=<br>\begin{pmatrix}<br>\color{green}{A_{y}} \cdot \color{blue}{B_{z}} - \color{blue}{A_{z}} \cdot \color{green}{B_{y}} \\<br>\color{blue}{A_{z}} \cdot \color{red}{B_{x}} - \color{red}{A_{x}} \cdot \color{blue}{B_{z}} \\<br>\color{red}{A_{x}} \cdot \color{green}{B_{y}} - \color{green}{A_{y}} \cdot \color{red}{B_{x}}<br>\end{pmatrix}<br>$$</p>
<p><font size="5" color="orange">矩阵</font><br>向量其实就是矩阵列数为1的特例。但是矩阵乘法只有点乘，没有叉乘。</p>
<p><font size="4" color="red">矩阵点乘</font><br>直接看例子吧：<br>$$<br>\begin{bmatrix}<br>\color{red}4 &amp; \color{red}2 &amp; \color{red}0 \\<br>\color{green}0 &amp; \color{green}8 &amp; \color{green}1 \\<br>\color{blue}0 &amp; \color{blue}1 &amp; \color{blue}0<br>\end{bmatrix}<br>\cdot<br>\begin{bmatrix}<br>\color{red}4 &amp; \color{green}2 &amp; \color{blue}1 \\<br>\color{red}2 &amp; \color{green}0 &amp; \color{blue}4 \\<br>\color{red}9 &amp; \color{green}4 &amp; \color{blue}2<br>\end{bmatrix}<br>=<br>\begin{bmatrix} \color{red}4 \cdot \color{red}4 + \color{red}2 \cdot \color{red}2 + \color{red}0 \cdot \color{red}9 &amp; \color{red}4 \cdot \color{green}2 + \color{red}2 \cdot \color{green}0 + \color{red}0 \cdot \color{green}4 &amp; \color{red}4 \cdot \color{blue}1 + \color{red}2 \cdot \color{blue}4 + \color{red}0 \cdot \color{blue}2 \\<br>\color{green}0 \cdot \color{red}4 + \color{green}8 \cdot \color{red}2 + \color{green}1 \cdot \color{red}9 &amp; \color{green}0 \cdot \color{green}2 + \color{green}8 \cdot \color{green}0 + \color{green}1 \cdot \color{green}4 &amp; \color{green}0 \cdot \color{blue}1 + \color{green}8 \cdot \color{blue}4 + \color{green}1 \cdot \color{blue}2 \\<br>\color{blue}0 \cdot \color{red}4 + \color{blue}1 \cdot \color{red}2 + \color{blue}0 \cdot \color{red}9 &amp; \color{blue}0 \cdot \color{green}2 + \color{blue}1 \cdot \color{green}0 + \color{blue}0 \cdot \color{green}4 &amp; \color{blue}0 \cdot \color{blue}1 + \color{blue}1 \cdot \color{blue}4 + \color{blue}0 \cdot \color{blue}2<br>\end{bmatrix}<br>=<br>\begin{bmatrix}<br>20 &amp; 8 &amp; 12 \\<br>25 &amp; 4 &amp; 34 \\<br>2 &amp; 0 &amp; 4<br>\end{bmatrix}<br>$$<br>矩阵相乘不满足交换律。</p>
<p><font size="4" color="red">单位矩阵</font><br>单位矩阵是主对角线元素为1，其他元素全为0的矩阵：<br>$$<br>\begin{bmatrix}<br>\color{red}1 &amp; \color{red}0 &amp; \color{red}0 &amp; \color{red}0 \\<br>\color{green}0 &amp; \color{green}1 &amp; \color{green}0 &amp; \color{green}0 \\<br>\color{blue}0 &amp; \color{blue}0 &amp; \color{blue}1 &amp; \color{blue}0 \\<br>\color{purple}0 &amp; \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}1<br>\end{bmatrix}<br>\cdot<br>\begin{bmatrix}<br>1 \\<br>2 \\<br>3 \\<br>4<br>\end{bmatrix}<br>=<br>\begin{bmatrix}<br>\color{red}1 \cdot 1 \\<br>\color{green}1 \cdot 2 \\<br>\color{blue}1 \cdot 3 \\<br>\color{purple}1 \cdot 4<br>\end{bmatrix}<br>=<br>\begin{bmatrix}<br>1 \\<br>2 \\<br>3 \\<br>4<br>\end{bmatrix}<br>$$<br>上面是一个单位矩阵和另外一个向量的点乘，可以看到结果还是那个向量，没有发生变换。一个没有变换的变换矩阵有何用？其实单位矩阵是其他变换矩阵的起点，后面会看到其他变换矩阵和单位矩阵很像。<br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">平移变换</font><br>平移是把一个向量从一个位置平移到另一个位置。在数学上其实就是在原始向量的基础上乘了一个位移矩阵（齐次坐标下的矩阵，关于齐次坐标也可以参考前面链接的那篇文章）：<br>$$<br>\begin{bmatrix}<br>\color{red}1 &amp; \color{red}0 &amp; \color{red}0 &amp; \color{red}{T_x} \\<br>\color{green}0 &amp; \color{green}1 &amp; \color{green}0 &amp; \color{green}{T_y} \\<br>\color{blue}0 &amp; \color{blue}0 &amp; \color{blue}1 &amp; \color{blue}{T_z} \\<br>\color{purple}0 &amp; \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}1<br>\end{bmatrix}<br>\cdot<br>\begin{pmatrix}<br>x \\<br>y \\<br>z \\<br>1<br>\end{pmatrix}<br>=<br>\begin{pmatrix}<br>x + \color{red}{T_x} \\<br>y + \color{green}{T_y} \\<br>z + \color{blue}{T_z} \\<br>1<br>\end{pmatrix}<br>$$<br>那个4x4的矩阵就是我们的位移矩阵，在x、y、z方向上的位移量分别是$T_x、T_y、T_z$。<br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">旋转变换</font><br>在3D空间中旋转需要定义一个角和一个旋转轴。图形会沿着给定的旋转轴旋转指定角度。</p>
<p>对于不同的旋转轴，有不同的旋转矩阵：</p>
<p>沿x轴旋转：<br>$$<br>\begin{pmatrix}<br>\color{red}1 &amp; \color{red}0 &amp; \color{red}0 &amp; \color{red}0 \\<br>\color{green}0 &amp; \color{green}{\cos \theta} &amp; - \color{green}{\sin \theta} &amp; \color{green}0 \\<br>\color{blue}0 &amp; \color{blue}{\sin \theta} &amp; \color{blue}{\cos \theta} &amp; \color{blue}0 \\<br>\color{purple}0 &amp; \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}1<br>\end{pmatrix}<br>\cdot<br>\begin{pmatrix}<br>x \\<br>y \\<br>z \\<br>1<br>\end{pmatrix}<br>=<br>\begin{pmatrix}<br>x \\<br>\color{green}{\cos \theta} \cdot y - \color{green}{\sin \theta} \cdot z \\<br>\color{blue}{\sin \theta} \cdot y + \color{blue}{\cos \theta} \cdot z \\<br>1<br>\end{pmatrix}<br>$$</p>
<p>沿y轴旋转：<br>$$<br>\begin{pmatrix}<br>\color{red}{\cos \theta} &amp; \color{red}0 &amp; \color{red}{\sin \theta} &amp; \color{red}0 \\<br>\color{green}0 &amp; \color{green}1 &amp; \color{green}0 &amp; \color{green}0 \\<br>-\color{blue}{\sin \theta} &amp; \color{blue}0 &amp; \color{blue}{\cos \theta} &amp; \color{blue}0 \\<br>\color{purple}0 &amp; \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}1<br>\end{pmatrix}<br>\cdot<br>\begin{pmatrix}<br>x \\<br>y \\<br>z \\<br>1<br>\end{pmatrix}<br>=<br>\begin{pmatrix}<br>\color{red}{\cos \theta} \cdot x + \color{red}{\sin \theta} \cdot z \\<br>y \\<br>-\color{blue}{\sin \theta} \cdot x + \color{blue}{\cos \theta} \cdot z \\<br>1<br>\end{pmatrix}<br>$$</p>
<p>沿z轴旋转：<br>$$<br>\begin{bmatrix}<br>\color{red}{\cos \theta} &amp; - \color{red}{\sin \theta} &amp; \color{red}0 &amp; \color{red}0 \\<br>\color{green}{\sin \theta} &amp; \color{green}{\cos \theta} &amp; \color{green}0 &amp; \color{green}0 \\<br>\color{blue}0 &amp; \color{blue}0 &amp; \color{blue}1 &amp; \color{blue}0 \\<br>\color{purple}0 &amp; \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}1<br>\end{bmatrix}<br>\cdot<br>\begin{pmatrix}<br>x \\<br>y \\<br>z \\<br>1<br>\end{pmatrix}<br>=<br>\begin{pmatrix}<br>\color{red}{\cos \theta} \cdot x - \color{red}{\sin \theta} \cdot y  \\<br>\color{green}{\sin \theta} \cdot x + \color{green}{\cos \theta} \cdot y \\<br>z \<br>1<br>\end{pmatrix}<br>$$<br>【注】：</p>
<ul>
<li>当把多个旋转矩阵结合起来时，比如先沿着x轴旋转再沿着y轴旋转，这可能会导致万向节死锁（Gimbal Lock，当两个旋转轴位于同一平面时，图形/物体就不能再旋转到任意位置了，有些方向怎么也旋转不过去）。关于万向节死锁可以参考下面这个视频：<br><iframe height="498" width="510" src="http://player.youku.com/embed/XNzkyOTIyMTI=" frameborder="0" 'allowfullscreen'=""></iframe><br>避免万向节死锁的真正解决方案是使用四元素，它不仅安全，而且计算更加友好（之后的文章会讲）。<br>&nbsp;</li>
</ul>
<hr>
<p><font size="5" color="orange">缩放变换</font><br>对一个向量进行缩放变换就是对向量的长度进行缩放，而保持它的方向不变：<br>$$<br>\begin{bmatrix}<br>\color{red}{S_1} &amp; \color{red}0 &amp; \color{red}0 &amp; \color{red}0 \\ \color{green}0 &amp; \color{green}{S_2} &amp; \color{green}0 &amp; \color{green}0 \\<br>\color{blue}0 &amp; \color{blue}0 &amp; \color{blue}{S_3} &amp; \color{blue}0 \\ \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}1<br>\end{bmatrix}<br>\cdot<br>\begin{pmatrix}<br>x \\<br>y \\<br>z \\<br>1<br>\end{pmatrix}<br>=<br>\begin{pmatrix}<br>\color{red}{S_1} \cdot x \\<br>\color{green}{S_2} \cdot y \\<br>\color{blue}{S_3} \cdot z \\<br>1<br>\end{pmatrix}<br>$$<br>&nbsp;</p>
<hr>
<p>下面来看看在OpenGL中怎么用代码实现这些坐标变换。</p>
<p><font size="5" color="orange">GLM</font><br>由于高版本的OpenGL没有自带任何的矩阵和向量知识，低版本中的<code>glTranslate</code>、<code>glRotate</code>、<code>glScale</code>等等都不能再用了。所以现在我们使用GLM，它是专门为OpenGL量身定制的数学库，易于使用。</p>
<p>GLM（OpenGL Mathematics），是一个只有头文件的库，也就是我们只需包含对应的头文件就可以使用了（包含整个glm文件夹，方法参考<a href="http://popperelay.com/2016/10/18/OpenGL%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" target="_blank" rel="external">《OpenGL1：OpenGL概述及环境配置》</a>一文），不用链接和编译。</p>
<p><font size="4" color="red">坐标变换头文件</font><br>我们需要的GLM的大多数功能基本上都在下面3个头文件里：</p>
<pre class="line-numbers language-c++"><code class="language-c++">//GLM
#include <GLM/glm/glm.hpp>
#include <GLM/glm//gtc/matrix_transform.hpp>
#include <GLM/glm/gtc/type_ptr.hpp>
using namespace glm;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><font size="4" color="red">定义变换矩阵</font><br>接下来需要定义坐标变换矩阵，使用<code>mat4</code>类型：</p>
<pre class="line-numbers language-c++"><code class="language-c++">        //定义变换矩阵（单位矩阵）
        mat4 transform;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>按这种方式定义好的变换矩阵，初始值一般都是单位矩阵。</p>
<p><font size="4" color="red">坐标变换（平移旋转缩放）</font><br>我们先对上一篇文章中的纹理，进行旋转变换：</p>
<pre class="line-numbers language-c++"><code class="language-c++">        //随着时间绕z轴旋转
        transform = rotate(transform, (GLfloat)glfwGetTime()*1.0f, vec3(0.0f, 0.0f, 1.0f));
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>使用glm命名空间里的<code>rotate</code>函数，第一个参数是旋转之前的变换矩阵；第二个参数是旋转角度（弧度值），这里旋转角度随着时间不断增加，图形将会一直旋转；第三个参数是旋转轴。</p>
<p>接下来对图形进行变换：</p>
<pre class="line-numbers language-c++"><code class="language-c++">        //平移（0.5，-0.5，0）
        transform = translate(transform, vec3(0.5f, -0.5f, 0.0f));
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>使用glm命名空间里的<code>translate</code>函数，第一个参数是平移之前的变换矩阵（准备拿去平移的矩阵）；第二个参数是位移向量，指定了平移的方向和距离。</p>
<p><font size="4" color="red">发送变换矩阵给着色器</font><br>变换矩阵已经搞定了，但是怎么把矩阵传递给着色器呢？我们使用uniform变量来实现：在顶点着色器里定义一个mat4类型的uniform变量：</p>
<pre class="line-numbers language-c++"><code class="language-c++">//顶点着色器
#version 330 core
layout (location=0) in vec3 position;  //顶点位置变量的属性位置值为0
layout (location=1) in vec3 color;     //顶点颜色变量的属性位置值为1
layout (location=2) in vec2 texCoord;  //顶点纹理坐标的属性位置值为2
out vec3 ourColor;
out vec2 TexCoord;
//坐标变换矩阵
uniform mat4 transform;
void main(){
    gl_Position=transform*vec4(position,1.0f);
    ourColor=color;
    TexCoord=vec2(texCoord.x,1-texCoord.y);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在顶点着色器的main函数里，让内置变量<code>gl_Position</code>的值等于变换矩阵和顶点坐标向量的乘积，这样就能把图形顶点进行坐标变换了（注意变换矩阵必须<strong>左乘</strong>顶点坐标向量）。</p>
<p>接下里就需要在主函数里对这个mat4类型的uniform变量赋值了：</p>
<pre class="line-numbers language-c++"><code class="language-c++">        //获取uniform全局变量transform（变换矩阵）的位置
        GLint transformLoc = glGetUniformLocation(myshader.shaderProgram, "transform");
        //给uniform变量（变换矩阵）赋矩阵值
        glUniformMatrix4fv(transformLoc, 1, GL_FALSE, value_ptr(transform));
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>首先获取到这个mat4类型的uniform变量的位置，再使用<code>glUniformMatrix4fv</code>函数对它赋值，该函数的第一个参数是获取到的uniform变量的位置；第二个参数是要传递多少个矩阵，这里是1；第三个参数指明是否要对矩阵进行转置（交换矩阵的行和列），OpenGL通常使用列主序的矩阵布局，而GLM的矩阵默认就是列朱旭，所以不需要转置矩阵，我们填GL_FALSE。最后一个参数是真正的矩阵数据，但是GLM矩阵并不是OpenGL所希望接受的数据形式，所以需要先用GLM自带的函数<code>value_ptr</code>来进行转换。<br>&nbsp;</p>
<hr>
<p>到此，关于坐标变换的所有源码<a href="https://github.com/Popperelay/BlogCode/tree/master/LearnOpenGL6_Transform" target="_blank" rel="external">在这里</a>。</p>
<p>编译运行后，效果类似如下：</p>
<iframe height="498" width="510" src="https://learnopengl-cn.github.io/img/01/07/transformations.mp4" frameborder="0" 'allowfullscreen'=""></iframe>

<p>【注】：</p>
<ul>
<li><code>translate</code>、<code>rotate</code>等函数，单独作用的时候它们都是以原点（窗口中心）为基准的，即相对于原点进行平移、旋转。</li>
<li>越靠近渲染函数<code>glDrawElements</code>的变换越先执行，所以上诉渲染循环中应该是先指定旋转变换，再指定平移变换。<br>&nbsp;</li>
</ul>
<hr>
<p>参考文献：<a href="https://learnopengl.com/" target="_blank" rel="external">LearnOpenGL</a></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[OpenGL5：纹理]]></title>
      <url>/2016/11/29/OpenGL5%E7%BA%B9%E7%90%86/</url>
      <content type="html"><![CDATA[<p>在前面的文章中，我们画过矩形，画过彩色三角形。<a id="more"></a>那么能不能画出现实生活中的图片呢？比如画一面砖墙，画一朵花。这样的图形无疑看起来更真实。但是这些更真实的图形也无疑很复杂，因为它们的每个像素颜色之间并没有什么明显的规律，如果要去画的话，就得一个像素一个像素的去画，要我们自己去指定大量的顶点颜色，这个开销太庞大了~~~<br>&nbsp; </p>
<hr>
<p><font size="5" color="orange">纹理概述</font><br>幸运的是，还有另一种方式。我们可以先照一张砖墙的照片，让GPU自动提取这张照片上的像素，然后画到屏幕上。这张用于GPU提取像素颜色的照片，就叫做纹理。纹理通常是一个2D图片（也有1D和3D的纹理）。可以想象纹理是一张绘有砖块的纸，无缝折叠贴合到我们的3D房子上，这样我们的房子看起来就像有砖墙外表了。这样我们就不用去一个一个地去指定纹理中每个纹素（纹理中的像素）的颜色了，只需要指定怎样把纹理贴到我们的模型（比如一个三角形、矩形甚至3D房子）上。举个例子：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148025320358.png" alt=""><br>为了把这张木箱纹理贴到图中红色三角形上，我们需要指定三角形的顶点对应纹理的那个位置。这个位置我们叫做纹理坐标，表示纹素在纹理上的位置，通常坐标值在0.0到1.0之间，原点通常在纹理左下角。我们把三角形左下角顶点对应纹理坐标（0,0），把三角形右下角顶点对应纹理坐标（1,0），把三角形上中顶点对应纹理坐标（0.5,1.0）。我们只要给顶点着色器传递这三个顶点纹理坐标就行了，接下来它们会被传到像素着色器中，GPU会根据三角形顶点纹理坐标，去为三角形内部点进行插值（根据内部点坐标和顶点坐标的关系，去纹理中找相应纹素颜色）。使用纹理坐标获取纹理颜色叫做采样。</p>
<p>这么说来，纹理坐标也应该是三角形顶点的一个属性，所以我们定义如下：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    //三角形顶点的坐标、颜色、纹理坐标
    GLfloat vertices[] = {
        //位置坐标         //颜色           //纹理坐标
        0.5f, 0.5f, 0.0f,  1.0f,0.0f,0.0f,  1.0f,1.0f,
        0.5f, -0.5f,0.0f,  0.0f,1.0f,0.0f,  1.0f,0.0f, 
        -0.5f,-0.5f,0.0f,  0.0f,0.0f,1.0f,  0.0f,0.0f,
        -0.5f,0.5f, 0.0f,  1.0f,1.0f,0.0f,  0.0f,1.0f
    };
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>&nbsp;</p>
<hr>
<p><font size="5" color="orange">告诉OpenGL如何解析顶点数据</font><br>由于顶点数据中增加了纹理坐标，我们需要重新设置OpenGL如何解析顶点数据：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    //告诉OpenGL如何解析显存中的顶点位置属性数据
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(GLfloat), (GLvoid*)0);
    //打开顶点位置属性数组
    glEnableVertexAttribArray(0);
    //告诉OpenGL如何解析显存中的顶点颜色属性数据
    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(GLfloat), (GLvoid*)(3 * sizeof(GLfloat)));
    //打开顶点颜色属性数组
    glEnableVertexAttribArray(1);
    //告诉OpenGL如何解析显存中的顶点纹理坐标属性数据
    glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(GLfloat), (GLvoid*)(6 * sizeof(GLfloat)));
    //打开顶点纹理坐标属性数组
    glEnableVertexAttribArray(2);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>每个顶点属性的步长都变成了<code>8*sizeof(GLfloat)</code>，起始偏移量（最后一个参数）也发生了变化。顶点纹理坐标属性对应顶点着色器中的location为2。<br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">创建纹理和绑定对象</font><br>和创建顶点数组对象VAO等一样，使用纹理前，我们需要创建和绑定纹理对象：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    GLuint texture;
    //生成纹理对象texture
    glGenTextures(1, &texture);
    //给纹理对象绑定目标（2D纹理）
    glBindTexture(GL_TEXTURE_2D, texture);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们使用的是2D纹理，所以纹理目标是GL_TEXTURE_2D。<br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">加载纹理</font><br>创建和绑定完纹理对象之后，我们把纹理从文件中加载进来。</p>
<p>纹理图像可能被存储为各种各样的格式，每种都有自己的数据结构和排列方式，那么我们如何才能把这些图像加载到应用中呢？一个解决方案是选一个需要的文件格式，比如png，然后自己写一个图像加载器，把图像转化为字节序列。但是如果要支持更多文件格式呢？就得为每种希望支持的格式写加载器了。</p>
<p>另一种解决方案就是借前人之树乘凉：使用一个支持多种流行格式的图像加载库来解决这个问题。比如我们要用的SOIL库（文末还介绍了另一种加载库）。</p>
<p><font size="4" color="">简易OpenGL图像库SOIL</font><br>SOIL是简易OpenGL图像库（Simple OpenGL Image Library）的缩写，它支持大多数流行的图像格式。可以从<a href="http://www.lonesock.net/soil.html" target="_blank" rel="external">这里</a>下载。下载完成后用VS打开\projects\VC8目录下的SOIL.sln，生成解决方案后，从debug文件夹里取得SOIL.lib文件，将它添加到我们自己建的Libs文件夹里，再把src文件夹下的所有.h头文件添加到我们自己建的Includes文件夹里，并且在自己的VS项目中链接上SOIL.lib（具体过程和<a href="http://popperelay.com/2016/10/18/OpenGL%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" target="_blank" rel="external">《OpenGL1：OpenGL概述及环境配置》</a>一文中构建GLFW类似）。</p>
<p>当然，在我们的源文件中还需要包含SOIL.h头文件：<code>#include &lt;SOIL.h&gt;</code></p>
<p><font size="4" color="red">使用SOIL加载图片</font><br>下面我们加载一张<a href="https://learnopengl-cn.github.io/img/01/06/container.jpg" target="_blank" rel="external">木箱</a>图片。<br>首先使用SOIL库的<code>SOIL_load_image</code>函数把木箱图片数据加载到内存：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    int iamgeWidth, iamgeHeight;
    unsigned char* image = SOIL_load_image("container.jpg", &iamgeWidth, &iamgeHeight, 0, SOIL_LOAD_RGB);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>函数<code>SOIL_load_image</code>的第一个参数是需要加载的图片路径；然后需要两个int指针作为第二个和第三个参数，函数会分别返回图片的宽度和高度到其中；第4个参数指定图片的通道数量，这里设为0即可；最后一个参数告诉SOIL如何来加载图片，由于我们只关注图片的RGB值，所以设为SOIL_LOAD_RGB。函数返回一个很大的char（或者说byte）数组。<br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">生成纹理</font><br>图像数据已经有了，存储在image数组中，下面我们利用这些图形数据来在GPU上生成一张纹理：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, iamgeWidth, iamgeHeight, 0, GL_RGB, GL_UNSIGNED_BYTE, image);
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>函数<code>glTexImage2D</code>的参数都表示什么？</p>
<ul>
<li>第一个参数是纹理绑定的目标GL_TEXTURE_2D</li>
<li>第二个参数是纹理的多级渐远纹理（后面会讲）级别，这里我们设置为0，也就是原始纹理</li>
<li>第三个参数告诉OpenGL我们希望把纹理存储为何种格式。我们的图形只有RGB值，所以我们也把纹理存储为RGB</li>
<li>第四个和第五个参数设置最终的纹理宽度和高度。我们之前加载图像的时候读取到了图像的宽度和高度，现在刚好用上</li>
<li>第6个参数总是设为0（历史遗留问题）</li>
<li>第7个参数指定源图的格式</li>
<li>第8个参数指定源图的数据类型</li>
<li>最后一个参数是真正的图形数据</li>
</ul>
<p>当调用函数<code>glTexImage2D</code>时，当前绑定的纹理对象就会被附加上纹理图像。</p>
<p>使用完图像内存数据后，释放所占用的内存是个好习惯：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    SOIL_free_image_data(image);
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>&nbsp;</p>
<hr>
<p>接下来还需要对纹理进行一系列的配置，先来看对纹理环绕方式的配置。</p>
<p><font size="5" color="orange">纹理环绕方式</font><br>纹理坐标的范围通常是（0,0）到（1,1），那如果我们把纹理坐标设置在这个范围之外会发生什么？OpenGL默认是重复这个纹理图像（即忽略纹理坐标的整数部分，只有小数部分有效），除此之外，OpenGL还提供了几种环绕方式（Wrapping）：</p>
<ul>
<li>GL_REPEAT：重复纹理图像。这是默认的。</li>
<li>GL_MIRRORED_REPEAT：镜像重复纹理图像。</li>
<li>GL_CLAMP_TO_EDGE：纹理坐标会被约束在0到1之间，超出部分会重复纹理边缘，产生一种边缘被拉伸的效果。</li>
<li>GL_CLAMP_TO_BORDER：超出坐标为用户指定的边缘颜色。</li>
</ul>
<p>当纹理坐标不在0到1之间时，每个选项都有不同的视觉输出效果：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148025552863.png" alt=""><br>可以使用<code>glTextParameteri</code>函数来设置纹理的环绕方式：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>第一个参数指定了纹理对象所绑定的目标；第二个参数指定需要配置的选项和应用的纹理轴，因为我们打算配置的是纹理环绕方式wrap，并且需要配置S和T方向（纹理中的s、t、r轴等价于通常的x、y、z轴）的环绕方式。最后一个参数指定环绕方式，这里我们指定的都是重复纹理图像这种方式。</p>
<p>【注】：</p>
<ul>
<li>如果我们选择GL_CLAMP_TO_BORDER这种纹理环绕方式，就还需要再指定一个边缘颜色。这时就需要再使用<code>glTexParameterfv</code>函数了：<pre class="line-numbers language-c++"><code class="language-c++">  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER);
  GLfloat borderColor[] = { 1.0f,1.0f,0.0f,1.0f };
  glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, borderColor);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
函数<code>glTexParameterfv</code>的第一个参数依旧是纹理对象绑定的目标；因为要设置边缘颜色，所以第二个参数变成了<code>GL_TEXTURE_BORDER_COLOR</code>；第三个参数是表示颜色的一个float数组。<br>&nbsp;</li>
</ul>
<hr>
<p>接下来我们看看对纹理过滤方式的配置</p>
<p><font size="5" color="orange">纹理过滤</font><br>当使用顶点坐标映射相应纹素时，由于是根据位置关系进行插值计算的，所以得到的内部点的纹理坐标不一定是整数，比如说如果纹素位置（即纹理坐标）为（152.34,255,38）该怎么办呢？这种情况称为纹理过滤。</p>
<p>纹理过滤有很多种方法，这里只讨论最重要的两种：GL_NEAREST（最邻近滤波）和GL_LINEAR（线性滤波）</p>
<p><font size="4" color="red">最邻近滤波</font><br>最邻近滤波是选择中心点距离浮点数纹理坐标最近的那个纹素。图示如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148032559086.png" alt=""><br>因为图中红色纹素离纹理坐标最近，所以选择该红色作为最终的输出纹素。</p>
<p>最邻近滤波容易导致走样误差，明显有像素块的感觉。</p>
<p><font size="4" color="red">线性滤波</font><br>线性滤波是使用纹理坐标附近的一组纹素的加权平均值（插值）来确定最终的纹素值。这个权值就是纹素中心到这个纹理坐标的距离，距离越近的纹素对最终的纹素值贡献越大。如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148032559137.png" alt=""></p>
<p>最邻近滤波和线性滤波的对比效果如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148032631514.png" alt=""><br>GL_NEAREST产生了颗粒状的图案，能够清晰地看到纹素，而GK_LINEAR能够产生更平滑的图案，很难看出单个的纹素。GL_LINEAR可以产生更真实的输出，不过GL_NEAREST却可以产生出8-bit风格（像素风），也有很多人喜欢。</p>
<p>还有一些其它的滤波方式，比如三线性滤波（Trilinear Filtering）等。</p>
<p><font size="4" color="red">纹素放大缩小时滤波</font><br>除了对纹理坐标取整时需要用到滤波以外，在纹素到像素时的放大和缩小时，也可能要用到滤波。</p>
<p>什么是纹素到像素的放大、缩小？</p>
<ul>
<li>一个纹素最终对应屏幕上的多个像素，称为放大（magnification）</li>
<li>一个纹素最终对应屏幕上的一个像素，这时不需要滤波</li>
<li>一个纹素最终对应少于一个像素，称为缩小</li>
</ul>
<p>放大和缩小图示如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148033138491.png" alt=""></p>
<p>我们可以使用<code>glTexParameteri</code>函数在图像放大滤波和缩小滤波选项时设置纹理滤波：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>第二个参数是放大滤波或者缩小滤波，第三个参数指定滤波方式。<br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">多级渐远纹理mipmap</font><br>一个物体，当它距离我们比较近时，需要很多像素去表现它；而当距离我们很远时，会看不大清楚，只有很少的像素需要被绘制，这时再从该物体对应的纹理中去找几个纹素来表现它，是很难的。因为它需要跨过纹理很大部分只拾取一个纹素，而且最终拾取出来的纹素凑在一起可能就面目全非了。更何况对于很远的物体去使用高分辨率的纹理无疑是浪费内存。</p>
<p>OpenGL使用多级渐远纹理Mipmap来解决这个问题。mipmap其实就是一系列纹理图像，后一个纹理图像只有前一个纹理图像的一半大小。在观察者的距离在不同的距离范围时使用不同级别的mipmap。mipmap的另一个加分点是它的性能非常好。mipmap图示如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148033241373.png" alt=""></p>
<p><font size="4" color="red">mipmap滤波</font><br>在渲染中切换不同级别的mipmap时，会产生一些很明显的边界。对纹素的滤波也可以用到这里，来消除这些很生硬的边界。由于mipmap其实也相当于是把纹理缩小，所以它的滤滤波也是通过<code>glTexParameteri</code>函数在缩小滤波<code>GL_TEXTURE_MIN_FILTER</code>选项时来实现：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST_MIPMAP_LINEAR);
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>函数的第三个参数就是要设置的mipmap滤波方式，它有一下几种选项（“mipmap”之后是mipmap滤波方式，之前是纹素滤波方式）：</p>
<ul>
<li><code>GL_NEAREST_MIPMAP_NEAREST</code>：使用最接近像素大小的mipmap，纹理内部使用最邻近滤波</li>
<li><code>GL_LINEAR_MIPMAP_NEAREST</code>：使用最接近像素大小的mipmap，纹理内部使用线性滤波</li>
<li><code>GL_NEAREST_MIPMAP_LINEAR</code>：在两个最接近像素大小的mipmap中做线性插值，纹理内部使用最邻近滤波</li>
<li><code>GL_LINEAR_MIPMAP_LINEAR</code>：在两个最接近像素大小的mipmap中线性插值，纹理内部使用线性滤波</li>
</ul>
<p>设置好mipmap的滤波之后，就可以来创建mipmap了。</p>
<p><font size="4" color="red">创建mipmap</font><br>手工为每个纹理图像创建一系列mipmap挺麻烦的，不过OpenGL有一个<code>glGenerateMipmaps</code>函数，在创建完一个纹理后调用它，OpenGL就会自动建立该纹理的一系列mipmap了：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    glGenerateMipmap(GL_TEXTURE_2D);
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>【注】：</p>
<ul>
<li>如果不需要mipmap，那关于mipmap这里的操作可以不要。<br>&nbsp;</li>
</ul>
<hr>
<p><font size="5" color="orange">解绑纹理对象</font><br>设置完纹理参数后，需要和别的对象一样，使用完之后解绑纹理对象：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    glBindTexture(GL_TEXTURE_2D, 0);
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>&nbsp;</p>
<hr>
<p><font size="5" color="orange">更改顶点着色器</font></p>
<pre class="line-numbers language-c++"><code class="language-c++">//顶点着色器
#version 330 core
layout (location=0) in vec3 position;  //顶点位置变量的属性位置值为0
layout (location=1) in vec3 color;     //顶点颜色变量的属性位置值为1
layout (location=2) in vec2 texCoord;  //顶点纹理坐标的属性位置值为2
out vec3 ourColor;
out vec2 TexCoord;
void main(){
    gl_Position=vec4(position,1.0f);
    ourColor=color;
    TexCoord=texCoord;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>顶点着色器需要增加一个纹理坐标的输入变量，由于只有s、t坐标，所以是vec2类型；还需要增加一个输出变量，用于输出纹理坐标给像素着色器。在main函数内把输入纹理坐标赋值给输出纹理坐标。<br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">更改像素着色器</font></p>
<pre class="line-numbers language-c++"><code class="language-c++">//像素着色器
#version 330 core
in vec3 ourColor;
in vec2 TexCoord;
out vec4 color;
uniform sampler2D ourTexture;

void main(){
    color = vec4(ourColor,1.0f) * texture(ourTexture,TexCoord);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>像素着色器需要增加一个纹理坐标的输入变量；只有纹理坐标还不足以在像素着色器中输出对应纹素的颜色，我们还需要一个采样器（设置为uniform变量），让它结合纹理坐标、顶点坐标、纹理图像，进行插值获得每一个像素颜色。使用texture函数来使用采样器，第一个参数是我们设置的采用器，第二个参数是纹理坐标。</p>
<p>在main函数内最终的输出颜色我们设置为顶点颜色和纹理颜色的混合。<br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">渲染时绑定纹理对象</font><br>设置完了纹理和相应的着色器，最后要做的就是在渲染循环里绑定纹理对象，这样才能渲染出纹理（这和绑定VAO是一个道理）。</p>
<pre class="line-numbers language-c++"><code class="language-c++">        //绑定纹理
        glBindTexture(GL_TEXTURE_2D, texture);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>&nbsp;</p>
<hr>
<p>自此，所有源码<a href="https://github.com/Popperelay/BlogCode/tree/master/LearnOpenGL5_Texture/LearnOpenGL5_Texture_1" target="_blank" rel="external">在这里</a>。</p>
<p>编译运行后，结果如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148033659587.png" alt=""><br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">使用多个纹理</font></p>
<p><font size="4" color="red">载入第二张图片</font><br>载入<a href="https://learnopengl-cn.github.io/img/01/06/awesomeface.png" target="_blank" rel="external">第二张图片</a>和第一张类似：</p>
<pre class="line-numbers language-c++"><code class="language-c++">    GLuint texture1;
    //生成纹理对象texture1
    glGenTextures(1, &texture1);
    //给纹理对象绑定目标（2D纹理）
    glBindTexture(GL_TEXTURE_2D, texture1);
    int iamgeWidth, iamgeHeight;
    //加载纹理图像
    unsigned char* image = SOIL_load_image("container.jpg", &iamgeWidth, &iamgeHeight, 0, SOIL_LOAD_RGB);
    //生成2D纹理
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, iamgeWidth, iamgeHeight, 0, GL_RGB, GL_UNSIGNED_BYTE, image);
    //释放纹理数据内存
    SOIL_free_image_data(image);
    //设置纹理s和t方向的环绕方式
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
    //设置纹理放大和缩写时的过滤方式（纹素过滤、mipmap边界过滤）
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    //生成多级渐远纹理
    glGenerateMipmap(GL_TEXTURE_2D);
    //解绑纹理对象
    glBindTexture(GL_TEXTURE_2D, 0);

    GLuint texture2;
    //生成纹理对象texture2
    glGenTextures(1, &texture2);
    //给纹理对象绑定目标（2D纹理）
    glBindTexture(GL_TEXTURE_2D, texture2);
    //加载纹理图像
    image = SOIL_load_image("awesomeface.png", &iamgeWidth, &iamgeHeight, 0, SOIL_LOAD_RGB);
    //生成2D纹理
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, iamgeWidth, iamgeHeight, 0, GL_RGB, GL_UNSIGNED_BYTE, image);
    //释放纹理数据内存
    SOIL_free_image_data(image);
    //设置纹理s和t方向的环绕方式
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_LINEAR);
    //设置纹理放大和缩写时的过滤方式（纹素过滤、mipmap边界过滤）
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    //生成多级渐远纹理
    glGenerateMipmap(GL_TEXTURE_2D);
    //解绑纹理对象
    glBindTexture(GL_TEXTURE_2D, 0);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><font size="4" color="red">更改像素着色器</font><br>使用多个纹理，我们就需要在像素着色器中使用多个采样器：</p>
<pre class="line-numbers language-c++"><code class="language-c++">//像素着色器
#version 330 core
in vec3 ourColor;
in vec2 TexCoord;
out vec4 color;
//纹理采样器1
uniform sampler2D ourTexture1;
//纹理采样器2
uniform sampler2D ourTexture2;

void main(){
    color = vec4(ourColor,1.0f) * mix(texture(ourTexture1,TexCoord),texture(ourTexture2,TexCoord),0.41);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在main函数中使用mix函数来混合两个纹理，第一个参数是纹理1的纹素颜色，第二个参数是纹理2的纹素颜色，第3个参数是纹素2在最终输出颜色中所占的权重，代码中是59%的纹素1，41%的纹素2。</p>
<p><font size="4" color="red">渲染中激活纹理单元并设置相应采样器</font><br>我们可以看到我们的采样器是被uniform声明的，但是很奇怪的是之前的源程序中，渲染时并没有对uniform全局变量ourTexture赋值，但是依旧有效并没有报错。这是因为我们的ourTexture变量是个采样器，通过多个采样器我们可以使用多个纹理。</p>
<p>每个纹理都有一个位置值，称为纹理单元（有点像多个纹理叠加时的图层）。而对于纹理处在哪一层，即纹理单元是多少，就是通过使用<code>glUniform1i</code>函数来给采样器赋值，从而确定纹理单元值。但是默认情况下，当只使用一个纹理时，纹理单元<code>GL_TEXTURE0</code>总是被激活的，也就是这个采样器（或者说纹理单元）总是对应0（0图层），所以不需要显式使用<code>glUniform1i</code>函数去为采样器赋值。</p>
<p>但是有多个纹理时，就没有默认了，需要显式为每个采样器指定一个整数值，对应被激活的图层（被激活的纹理单元）：</p>
<pre class="line-numbers language-c++"><code class="language-c++">        //激活纹理单元
        glActiveTexture(GL_TEXTURE0);
        //获取uniform变量位置
        GLint uniformLocation1 = glGetUniformLocation(myshader.shaderProgram, "ourTexture1");
        //设置采样器的值（对应纹理单元值）
        glUniform1i(uniformLocation1, 0);
        //绑定纹理对象
        glBindTexture(GL_TEXTURE_2D, texture1);

        glActiveTexture(GL_TEXTURE1);
        GLint uniformLocation2 = glGetUniformLocation(myshader.shaderProgram, "ourTexture2");
        glUniform1i(uniformLocation2, 1);
        glBindTexture(GL_TEXTURE_2D, texture2);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在给采样器赋值之前，我们需要先激活纹理单元，活着说激活纹理图层，再给采样器赋以相应的被激活的纹理单元值，这样采样器才能读出纹素颜色。<br>【注】：</p>
<ul>
<li>如果采样器值对应的纹理单元没有被激活，是无法读出纹素的。因为默认纹理单元0是激活的，所以在只渲染一个纹理时，就不用去激活纹理单元并设置采样器值，默认就是用采样器0去纹理单元0（图层0）采集纹素颜色。</li>
<li>设置完采样器的值后，接下来就需要绑定纹理对象，好把相应纹理放在刚刚激活的纹理单元（图层）上。</li>
<li>OpenGL至少保证有16个纹理单元可供使用，也就是说可以激活从<code>GL_TEXTURE0</code>到<code>GL_TEXTURE15</code>。它们都是按顺序定义的，所以<code>GL_TEXTURE8=GL_TEXTURE0+8</code>，这在当我们需要循环一些纹理单元时会很有用。</li>
</ul>
<p>其余代码和之前的源程序一样，编译运行的结果如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148034269274.png" alt=""></p>
<p><font size="4" color="red">翻转图片</font><br>可以看到第二张纹理上下颠倒了！这是因为OpenGL要求y轴0.0在图片底部，但是通常图片y轴0.0在图片顶部。有一些图片加载器比如DevIL在加载的时候有选项重载y原点，但是SOIL没有。所以，为了修复这个小问题，有两个选择：</p>
<ul>
<li>改变顶点的纹理坐标属性，翻转y值（用1减去y坐标）</li>
<li>更改顶点着色器中对输出纹理坐标的赋值，也是用1减去y坐标：<pre class="line-numbers language-c++"><code class="language-c++">//顶点着色器
#version 330 core
layout (location=0) in vec3 position;  //顶点位置变量的属性位置值为0
layout (location=1) in vec3 color;     //顶点颜色变量的属性位置值为1
layout (location=2) in vec2 texCoord;  //顶点纹理坐标的属性位置值为2
out vec3 ourColor;
out vec2 TexCoord;
void main(){
  gl_Position=vec4(position,1.0f);
  ourColor=color;
  TexCoord=vec2(texCoord.x,1-texCoord.y);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
编译运行后的结果如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148034318836.png" alt=""><br>&nbsp;</li>
</ul>
<hr>
<p>到此，使用两张纹理的全部源程序<a href="https://github.com/Popperelay/BlogCode/tree/master/LearnOpenGL5_Texture/LearnOpenGL5_Texture_2" target="_blank" rel="external">在这里</a>。<br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">纹理加载类</font><br>我们把上面主程序中加载纹理的部分单独封装成一个类：<br>纹理加载类的头文件：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#pragma once
#define GLEW_STATIC
#include <GL/glew.h>
#include <GLFW/glfw3.h>
#include <SOIL/SOIL.h>

class TextureLoader {
public:
    GLuint LoadTexture(GLchar* texturePath);
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>纹理加载类的源文件：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#include "TextureLoader.h"

GLuint TextureLoader::LoadTexture(GLchar* texturePath) {
    GLuint texture;
    //生成纹理对象texture
    glGenTextures(1, &texture);
    //给纹理对象绑定目标（2D纹理）
    glBindTexture(GL_TEXTURE_2D, texture);
    int imageWidth, imageHeight;
    //加载纹理图像
    unsigned char* image = SOIL_load_image(texturePath, &imageWidth, &imageHeight, 0, SOIL_LOAD_RGB);
    //生成2D纹理
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, imageWidth, imageHeight, 0, GL_RGB, GL_UNSIGNED_BYTE, image);
    //释放纹理数据内存
    SOIL_free_image_data(image);
    //设置纹理s和t方向的环绕方式
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
    //设置纹理放大和缩写时的过滤方式（纹素过滤、mipmap边界过滤）
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    //生成多级渐远纹理
    glGenerateMipmap(GL_TEXTURE_2D);
    //解绑纹理对象
    glBindTexture(GL_TEXTURE_2D, 0);

    return texture;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>主程序可以直接使用该类的<code>LoadTexture</code>函数直接加载图片了。全部源码<a href="https://github.com/Popperelay/BlogCode/tree/master/LearnOpenGL5_Texture/LearnOpenGL5_Texture_3" target="_blank" rel="external">在这里</a>。<br>&nbsp;</p>
<hr>
<p>参考文献：<a href="https://learnopengl.com/" target="_blank" rel="external">LearnOpenGL</a></p>
]]></content>
      
        <categories>
            
            <category> OpenGL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 纹理 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++的输入输出]]></title>
      <url>/2016/11/25/C++%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</url>
      <content type="html"><![CDATA[<p><font size="5" color="orange">C++输入输出系统的优势</font><br><a id="more"></a><br>C语言本身有自己的输入输出方式，作为升级版的C++为何还要建立一个输入输出系统呢？原因如下：</p>
<ul>
<li>C++的输入输出系统是类型安全的，也就是说它可以自动识别输出数据的类型，如<code>cout &lt;&lt; 5;</code>会自动识别出要输出的数据是字符串类型，但是如果用C的话就得写成<code>printf(&quot;%d&quot;,5);</code>。因为C++可以自动识别类型，所以可以有效防止格式控制符与输出数据的类型不一致的错误。</li>
<li>C++可以通过重载运算符&lt;&lt;和&gt;&gt;，让用户能够自定义输入和输出的形式，并且可以像预定义（C++已经定义好的\自带的）的一样有效方便。</li>
<li>C++输入输出的书写形式简单清晰，程序代码会有更好的可读性。</li>
</ul>
<p>【注】：</p>
<ul>
<li>在C++中也可以使用C的printf和scanf函数。<br>&nbsp;  </li>
</ul>
<hr>
<p><font size="5" color="orange">C++的输入输出流</font><br>C++的输入输出是以字节流的形式实现的。在输入操作中，字节流从输入设备（如键盘、磁盘、网络连接等）流向内存；输出操作中，字节流从内存流向输出设备（如显示器、打印机、网络连接等）。可以看到输入输出是相对于内存的，流向内存的称为输入，从内存流出的称为输出。</p>
<p>C++编译系统给了一个用于输入输出的库：iostream类库。这个类库中包含了很多头文件，很多用于输入输出操作的类的声明都放在这些头文件中。<br>&nbsp; </p>
<hr>
<p><font size="5" color="orange">C++用于输入输出的常用头文件</font></p>
<ul>
<li>iostream：主要用于基本的输入输出操作。使用cin、cout对标准设备进行IO（输入输出）时，须包含此头文件。</li>
<li>fstream： 用于文件的IO操作。使用文件流对象对磁盘文件进行读写，须包含此头文件。</li>
<li>sstream：用于字符串流的IO操作。使用字符串流对象对内存字符串空间的IO操作，须包含此头文件。</li>
<li>iomanip：用于输入输出时的格式控制。在使用setw、fixed等大多数操作符进行格式控制时，须包含此头文件。</li>
</ul>
<p>【注】：</p>
<ul>
<li>用于字符串流IO的还有strstream头文件。strstream头文件是基于C类型字符串char*类型编写的，返回的是char*类型的字符串；而sstream是基于std::string编写的，返回的是string类型的字符串。<br>&nbsp;  </li>
</ul>
<hr>
<p><font size="5" color="orange">C++用于输入输出的流类</font><br>C++的iostream类库中当然还有很多用于输入输出的类，它们的声明都包含在上诉头文件中。常用的流类有如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147988556066.png" alt=""><br>其中，ios类是所有输入输出类的抽象基类，类istream和ostream单一继承ios类，而类iostream多重继承于类istream和ostream。<br>&nbsp; </p>
<hr>
<p><font size="5" color="orange">C++预定义的流对象</font><br>用上诉的流类定义的对象称为流对象。C++有几个已经定义好的流对象，也就是C++自带的：</p>
<ul>
<li>cin：它是istream类的派生类istream_withassign的对象，与标准输入设备（比如键盘）相联系。</li>
<li>cout：它是ostream类的派生类ostream_withassign的对象，与标准输出设备（比如显示器）相联系。</li>
<li>cerr：它也是ostream类的派生类ostream_withassign的对象，与标准错误输出设备（比如显示器）相联系。</li>
<li>clog：它也是ostream类的派生类ostream_withassign的对象，也是与标准错误输出设备（比如显示器）相联系。</li>
</ul>
<p>【注】：</p>
<ul>
<li>可以看到cerr和clog都用来输出错误信息。区别是cerr不经过缓冲区，直接向显示器输出相关信息，所以发送给它的任何内容都立即输出；而clog中的信息存放在缓冲区中，缓冲区满后或遇上endl后才向显示器输出。<br>&nbsp; </li>
</ul>
<hr>
<p><font size="5" color="orange">基本输入输出流的成员函数</font><br>众所周知，C++的基本输入输出可以用&lt;&lt;（输出运算符\插入运算符）和&gt;&gt;（输入运算符\提取运算符）来实现。除此之外，还可以使用类istream和类ostream对象的一些成员函数来实现字符的输入输出：</p>
<p><font size="4" color="red">put函数</font><br>put函数用于输出一个字符，形如：<code>cout.put(&#39;A&#39;);</code>。</p>
<p>它的参数可以是一个字符，也可以是字符的ASCII码，如<code>cout.put(65);</code>也会在屏幕上显示字符A。</p>
<p><font size="4" color="red">get函数</font><br>get函数用于读入一个字符，赋给指定的字符。形如：<code>char ch;cin.get(ch);</code>。get函数会把从标准输入设备（键盘）上输入的字符赋值给字符类型变量ch。</p>
<p><code>cin.get</code>函数与&gt;&gt;有一点不同，get函数可以读入空白字符，而&gt;&gt;默认情况下是不接收空白字符的。</p>
<p><font size="4" color="red">getline函数</font><br>getline函数用于读取n-1个字符，赋给指定的字符数组，然后插入一个字符串结束标志’\n’。形如：<code>char line[20];cin.getline(line,20,&#39;t&#39;);</code>。如果在读取n-1个字符之前遇到指定的终止字符（比如第三个参数t），则会提前结束读取。</p>
<p>使用<code>cin&lt;&lt;</code>读取数据默认以空白字符（包括空格、tab键、回车键）作为终止字符，而<code>cin.getline</code>是可以读取空格的。</p>
<p><font size="4" color="red">ignore函数</font><br>ignore函数用于跳过输入的n个字符，或者在遇到指定字符时停止跳过。形如:</p>
<pre class="line-numbers language-csharp"><code class="language-csharp">    <span class="token keyword">char</span><span class="token operator">*</span> str<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">char</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cin<span class="token punctuation">.</span><span class="token function">ignore</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">'z'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cin<span class="token punctuation">.</span><span class="token function">getline</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout<span class="token operator">&lt;</span><span class="token operator">&lt;</span>str<span class="token operator">&lt;</span><span class="token operator">&lt;</span>endl<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果输入bcdefghi，ignore函数会跳过头3个字符bcd，getline函数把后面的efghi这5个字符存储到str中，最后在屏幕上输出的就是efghi。</p>
<p>如果输入bzdefga，ignore函数在跳过3个字符之前遇到了指定的终止字符z，getline函数继续读取字符，在读取6-1个字符之前遇到了指定的终止字符a，最后输出defg。<br>&nbsp; </p>
<hr>
<p><font size="5" color="orange">重载&gt;&gt;和&lt;&lt;</font><br>我们可以重载输入运算符&gt;&gt;和输出运算符&lt;&lt;，来达到我们想要的输出方式。</p>
<p><font size="4" color="red">重载输出运算符&lt;&lt;</font><br>重载的格式如下：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp">ostream <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">&lt;</span><span class="token operator">&lt;</span><span class="token punctuation">(</span>ostream <span class="token operator">&amp;</span><span class="token keyword">out</span><span class="token punctuation">,</span> class_name<span class="token operator">&amp;</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">out</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> obj<span class="token punctuation">.</span>item1<span class="token punctuation">;</span>
    <span class="token keyword">out</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> obj<span class="token punctuation">.</span>item2<span class="token punctuation">;</span>
    <span class="token keyword">out</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> obj<span class="token punctuation">.</span>itemn<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">out</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中class_name是我们自定义的类名，函数内部可以根据需要输出我们想输出的内容。以后使用<code>&lt;&lt;对象名</code>就可以一次性输出你想输出的全部内容。举例如下：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token preprocessor property">#include </span><span class="token string">"stdafx.h"</span>
<span class="token preprocessor property">#include&lt;iostream></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Coord</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token punctuation">:</span>
    <span class="token keyword">int</span> x<span class="token punctuation">,</span> y<span class="token punctuation">;</span>

    <span class="token function">Coord</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        x <span class="token operator">=</span> i<span class="token punctuation">;</span>
        y <span class="token operator">=</span> j<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//重载输出运算符&lt;&lt;</span>
ostream <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">&lt;</span><span class="token operator">&lt;</span><span class="token punctuation">(</span>ostream <span class="token operator">&amp;</span><span class="token keyword">out</span><span class="token punctuation">,</span> Coord<span class="token operator">&amp;</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">out</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> obj<span class="token punctuation">.</span>x <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token string">","</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> obj<span class="token punctuation">.</span>y<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">out</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Coord <span class="token function">a</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;</span><span class="token operator">&lt;</span> a <span class="token operator">&lt;</span><span class="token operator">&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>输出的结果如下：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token number">11</span><span class="token punctuation">,</span><span class="token number">22</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><font size="4" color="red">重载输入运算符&gt;&gt;</font><br>重载的格式如下：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp">istream <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">></span><span class="token operator">></span><span class="token punctuation">(</span>istream <span class="token operator">&amp;</span><span class="token keyword">in</span><span class="token punctuation">,</span> class_name<span class="token operator">&amp;</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">in</span> <span class="token operator">></span><span class="token operator">></span> obj<span class="token punctuation">.</span>item1<span class="token punctuation">;</span>
    <span class="token keyword">in</span> <span class="token operator">></span><span class="token operator">></span> obj<span class="token punctuation">.</span>item2<span class="token punctuation">;</span>
    <span class="token keyword">in</span> <span class="token operator">></span><span class="token operator">></span> obj<span class="token punctuation">.</span>itemn<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">in</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中class_name是我们自定义的类名，函数内部可以根据需要输入我们需要的内容。以后使用<code>&gt;&gt;对象名</code>就可以一次性输入需要的全部内容。举例如下：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token preprocessor property">#include </span><span class="token string">"stdafx.h"</span>
<span class="token preprocessor property">#include&lt;iostream></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Coord</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token punctuation">:</span>
    <span class="token keyword">int</span> x<span class="token punctuation">,</span> y<span class="token punctuation">;</span>

    <span class="token function">Coord</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        x <span class="token operator">=</span> i<span class="token punctuation">;</span>
        y <span class="token operator">=</span> j<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

istream <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">></span><span class="token operator">></span><span class="token punctuation">(</span>istream <span class="token operator">&amp;</span><span class="token keyword">in</span><span class="token punctuation">,</span> Coord<span class="token operator">&amp;</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">in</span> <span class="token operator">></span><span class="token operator">></span> obj<span class="token punctuation">.</span>x<span class="token punctuation">;</span>
    <span class="token keyword">in</span> <span class="token operator">></span><span class="token operator">></span> obj<span class="token punctuation">.</span>y<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">in</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Coord a<span class="token punctuation">;</span>
    cin <span class="token operator">></span><span class="token operator">></span> a<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;</span><span class="token operator">&lt;</span> a<span class="token punctuation">.</span>x <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token string">","</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> a<span class="token punctuation">.</span>y <span class="token operator">&lt;</span><span class="token operator">&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果输入如下：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token number">11</span> <span class="token number">22</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>那么会有如下输出结果：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token number">11</span><span class="token punctuation">,</span><span class="token number">22</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>【注】：</p>
<ul>
<li>上述两个重载代码虽然简单易懂，但是在工程设计上确实有点糟糕啊~-~！<br>&nbsp;  </li>
</ul>
<hr>
<p>对于文件的输入输出请参考<a href="http://popperelay.com/2016/11/24/C++%E6%96%87%E4%BB%B6IO/" target="_blank" rel="external">《C++文件的输入输出》</a>，对于字符串流的输入输出这篇文章也有简单介绍。</p>
]]></content>
      
        <categories>
            
            <category> C++ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C++IO </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OpenGL4：着色器]]></title>
      <url>/2016/11/25/OpenGL4%E7%9D%80%E8%89%B2%E5%99%A8/</url>
      <content type="html"><![CDATA[<p>在上一篇文章中，我们已经知道了简单的着色器和它们的使用方法，本文再详细地来看看着色器。<br><a id="more"></a><br>着色器是运行在GPU上的小程序，是一种相当独立的程序，它们不能相互通信，只能通过输入和输出的方式进行沟通：在链接程序对象的时候，上一个阶段着色器的输出变量，和下一阶段的同名同类型输入变量，会链接到一起。<br>&nbsp; </p>
<hr>
<p><font size="5" color="orange">GLSL概述</font><br>在OpenGL中着色器是用GLSL语言来编写的，它是为图形计算量身定制的，尤其是向量和矩阵运算。</p>
<p>着色器的开头总是要声明GLSL的版本，用于匹配对应的OpenGL版本。接着是输入变量和输出变量、uniform和main函数。和大多数程序一样，着色器的入口点也是main函数，在main函数中我们处理所有的输入变量，并且用输出变量输出结果。</p>
<p>着色器一般都形如：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token preprocessor property">#version version_number</span>

<span class="token keyword">in</span> type in_variable_name<span class="token punctuation">;</span>
<span class="token keyword">in</span> type in_variable_name<span class="token punctuation">;</span>

<span class="token keyword">out</span> type out_variable_name<span class="token punctuation">;</span>

uniform type uniform_name<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//处理输入并进行一些图形操作</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment" spellcheck="true">//输出处理的结果到输出变量</span>
    out_variable_name<span class="token operator">=</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对于顶点着色器，每个输入变量也叫顶点属性（vertex attribute）。由于硬件有限，我们能够声明的顶点属性是有上限的。不同的硬件上限可能不同，想知道你的电脑最多能支持多少个顶点属性的话，可以查询一下：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp">GLint maxVertexAttribs<span class="token punctuation">;</span>
<span class="token function">glGetIntegerv</span><span class="token punctuation">(</span>GL_MAX_VERTEX_ATTRIBS<span class="token punctuation">,</span> <span class="token operator">&amp;</span>maxVertexAttribs<span class="token punctuation">)</span><span class="token punctuation">;</span>
cout <span class="token operator">&lt;</span><span class="token operator">&lt;</span> maxVertexAttribs <span class="token operator">&lt;</span><span class="token operator">&lt;</span> endl<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>通常情况下至少会返回16个，大部分情况够用了。OpenGL也确保至少16个包含4分量的顶点属性可用。<br>&nbsp; </p>
<hr>
<p><font size="5" color="orange">GLSL中的向量</font><br>前面提到GLSL对向量提供了特别支持，下面来看一下。GLSL中的向量是一个可以包含有1、2、3或4个分量的容器，分量的类型可以是基础类型中的任意一个。根据分量类型和支持的分量个数，有如下几种向量（n代表分量数量）：</p>
<ul>
<li>vecn：包含n个float分量的默认向量</li>
<li>bvecn：包含n个bool分量的向量</li>
<li>ivecn：包含n个int分量的向量</li>
<li>uven：包含n个unsigned int分量的向量</li>
<li>dvecn：包含n个double分量的向量</li>
</ul>
<p>除此之外，GLSL还允许对颜色使用rgba向量，对纹理使用stpq向量。</p>
<p>GLSL所支持的向量有很灵活的分量组成方式，叫做重组（swizzling）。重组允许像这样的语法：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp">vec2 someVec<span class="token punctuation">;</span>
vec4 differentVec <span class="token operator">=</span> someVec<span class="token punctuation">.</span>xyxx<span class="token punctuation">;</span>
vec3 anotherVec <span class="token operator">=</span> differentVec<span class="token punctuation">.</span>zyw<span class="token punctuation">;</span>
vec4 otherVec <span class="token operator">=</span> someVec<span class="token punctuation">.</span>xxxx <span class="token operator">+</span> anotherVec<span class="token punctuation">.</span>yxzy<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以利用向量现有的分量重组成其它个数的向量。</p>
<p>当然向量（或其分量）还可以作为另一个向量的构造参数：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp">vec2 vect <span class="token operator">=</span> <span class="token function">vec2</span><span class="token punctuation">(</span><span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token number">0.7f</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
vec4 result <span class="token operator">=</span> <span class="token function">vec4</span><span class="token punctuation">(</span>vect<span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
vec4 otherResult <span class="token operator">=</span> <span class="token function">vec4</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span>xyz<span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>&nbsp; </p>
<hr>
<p><font size="5" color="orange">输入与输出</font><br>每个着色器都应当有输入和输出，这样才能进行数据交流和传递嘛！GLSL定义了in和out关键字来实现输入输出。</p>
<p>但是在顶点着色器中稍微有点不同，顶点着色器作为渲染管线上的第一个着色器，它的输入是从顶点数据中直接接收输入。为了定义顶点数据该如何管理，我们使用location这一元素指定输入变量（在用<code>glVertexAttribPointer</code>函数解析缓冲中的顶点数据时会用到），这样我们才可以在CPU上配置顶点属性。此外，顶点着色器还需要为它的输入提供一个额外的layout标识，这样我们才能把location链接到顶点数据，形如：<code>layout(location=0)</code>。<br>【注】：</p>
<ul>
<li>也可以不用<code>layout(location=0)</code>，而通过在OpenGL代码中使用<code>glGetAttribLocation</code>函数查询属性位置值（location），只是工作量大了些。</li>
</ul>
<p>还有渲染管线上的最后一个着色器——像素着色器，也有点不同。它需要有一个vec4颜色输出变量，因为像素着色器需要生产一个最终输出的颜色。如果在像素着色器中没有定义输出颜色，OpenGL会把物体渲染为白色（或黑色）。</p>
<p>如果我们打算从一个着色器向另一个着色器发送数据，我们必须在发送方着色器中声明一个输出，在接收方着色器声明一个同名输入。当名字和类型都一样的时候，OpenGL就会把两个变量链接到一起，它们之间就可以发送数据了（这是在链接程序对象时完成的）。</p>
<p>接下来上个demo，让顶点着色器为像素着色器决定颜色：<br>顶点着色器：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token comment" spellcheck="true">//顶点着色器</span>
<span class="token keyword">const</span> GLchar<span class="token operator">*</span> vertexShaderSource <span class="token operator">=</span>
<span class="token string">"#version 330 core\n"</span>
<span class="token string">"layout (location=0) in vec3 position;\n"</span>
<span class="token string">"out vec4 vertexColor;\n"</span>
<span class="token string">"void main(){\n"</span>
<span class="token string">"gl_Position=vec4(position.x,position.y,position.z,1.0f);\n"</span>
<span class="token string">"vertexColor=vec4(0.5,0.0f,0.0f,1.0f);\n"</span>
<span class="token string">"}\0"</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>像素着色器：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token comment" spellcheck="true">//像素着色器</span>
<span class="token keyword">const</span> GLchar<span class="token operator">*</span> fragmentShaderSource <span class="token operator">=</span>
<span class="token string">"#version 330 core\n"</span>
<span class="token string">"in vec4 vertexColor;\n"</span>
<span class="token string">"out vec4 color;\n"</span>
<span class="token string">"void main(){\n"</span>
<span class="token string">"color=vertexColor;\n"</span>
<span class="token string">"}\0"</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到我们在顶点着色器中声明了一个vertexColor变量作为输出，并且在顶点着色器的main函数中为这个输出变量赋了值；然后在像素着色器中声明了一个同名同类型的输入变量，并在其main函数中令输出变量color等于该输入变量。当链接程序对象后，像素着色器的vertexColor就和顶点着色器的vertexColor链接在一起了，因为我们在顶点着色器中设置的是深红色的，所以在像素着色器中输出的结果也是深红色的：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147973357727.png" alt=""><br>我们完成了顶点着色器向像素着色器发送数据！<br>&nbsp; </p>
<hr>
<p><font size="5" color="orange">全局变量uniform</font><br>上面我们完成了一个着色器向另一个着色器发送数据，那么能不能从应用程序向像素着色器发送一个颜色呢？我们可以使用全局变量unifrom来实现。</p>
<p>uniform是一种从CPU中的应用向GPU中的着色器发送数据的方式。但是uniform和顶点属性不同，uniform变量是全局的，在每个着色器程序都是独一无二的，可以在渲染管线的任意一个阶段访问。而且uniform变量会一直保存它们的数据，直到它们被重置或更新。</p>
<p>一般我们都是在着色器代码中声明uniform变量，形如<code>uniform vec4 ourColor</code>。</p>
<p>下面上一个demo，我们通过uniform变量来设置三角形颜色。</p>
<p>像素着色器：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token comment" spellcheck="true">//像素着色器</span>
<span class="token keyword">const</span> GLchar<span class="token operator">*</span> fragmentShaderSource <span class="token operator">=</span>
<span class="token string">"#version 330 core\n"</span>
<span class="token string">"out vec4 color;\n"</span>
<span class="token string">"uniform vec4 ourColor;\n"</span>
<span class="token string">"void main(){\n"</span>
<span class="token string">"color=ourColor;\n"</span>
<span class="token string">"}\0"</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们在像素着色器中声明了一个uniform变量ourColor，并且把像素着色器的输出颜色设置为uniform变量的值。</p>
<p>下面我们到应用程序里，去给这个在像素着色器中声明的uniform变量赋值。首先需要找到这个uniform变量在着色器程序对象中的位置，我们使用<code>glGetUniformLocation</code>函数来完成。然后就可以使用<code>glUniform4f</code>函数来给uniform变量赋值了：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp">        <span class="token comment" spellcheck="true">//激活着色器程序对象</span>
        <span class="token function">glUseProgram</span><span class="token punctuation">(</span>shaderProgram<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//找到uniform变量在着色器程序对象中的位置</span>
        GLint ourColorLocation <span class="token operator">=</span> <span class="token function">glGetUniformLocation</span><span class="token punctuation">(</span>shaderProgram<span class="token punctuation">,</span> <span class="token string">"ourColor"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//给uniform变量赋值</span>
        <span class="token function">glUniform4f</span><span class="token punctuation">(</span>ourColorLocation<span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>glGetUniformLocation</code>函数第一个参数是链接后的着色器程序对象，第二个参数是我们要查找的uniform变量，返回GLint类型变量，代表找到的位置值。<code>glUniform4f</code>函数的第一参数是uniform变量的位置值，接下来几个参数就是R、G、B、A了。<br>【注】：</p>
<ul>
<li>查询uniform变量位置和给uniform变量赋值在<code>glUseProgram</code>前后都可以。</li>
<li>因为OpenGL的核心库是C库，所以它的函数不支持重载，在函数参数不同时就需要为其定义新的函数。<code>glUniform</code>函数就是一个例子。这个函数用后缀标识设定的uniform类型，可能的后缀有：<ul>
<li>f：函数需要1个float作为uniform变量的值</li>
<li>i：函数需要1个int作为uniform变量的值</li>
<li>ui：函数需要1个uint作为uniform变量的值</li>
<li>3f：函数需要3个float作为uniform变量的值</li>
<li>fv：函数需要一个float向量/数组作为uniform变量的值</li>
</ul>
</li>
</ul>
<p>上面我们找到了在着色器程序对象中uniform变量ourColor的位置，并给它赋值为绿色（0,1,0,1），在渲染后就会在窗口上出现一个绿色的三角形。</p>
<p>现在我们把效果做的再灵动点：让三角形的颜色随着时间不断变化。想一想其实很简单吧，只需要把上面程序中的绿色改为随时间变化的颜色就可以了：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp">        <span class="token comment" spellcheck="true">// 更新颜色</span>
        GLfloat timeValue <span class="token operator">=</span> <span class="token function">glfwGetTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        GLfloat greenValue <span class="token operator">=</span> <span class="token function">sin</span><span class="token punctuation">(</span>timeValue<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">0.5</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//给uniform变量赋值</span>
        <span class="token function">glUniform4f</span><span class="token punctuation">(</span>ourColorLocation<span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span> greenValue<span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//激活着色器程序对象</span>
        <span class="token function">glUseProgram</span><span class="token punctuation">(</span>shaderProgram<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>glfwGetTime</code>函数会获取运行的秒数，然后使用sin函数让颜色值在0到1之间变化，把结果存储到greenValue变量里。再使用这个不断变化（每一次循环greenValue的值都会改变）的变量去给uniform变量赋值，这样像素着色器输出的颜色值也就是在随着时间不断变化了。</p>
<p>所有源码<a href="https://github.com/Popperelay/BlogCode/blob/master/LearnOpenGL4_Shader/LearnOpenGL4_Shader_1/main.cpp" target="_blank" rel="external">在这里</a>。</p>
<p>编译运行后的结果如下：</p>
<p><iframe height="498" width="510" src="http://player.youku.com/embed/XMTI3OTI5MjY5Ng==" frameborder="0" 'allowfullscreen'=""></iframe><br>&nbsp; </p>
<hr>
<p><font size="5" color="orange">多个顶点属性</font><br>可以看到上面的三角形内部点都是相同的颜色，或者三角形的每个顶点都是相同的颜色，这是因为三个顶点都是使用像素着色器中的输出颜色来绘制的，那三角形的这三个顶点肯定同色了，而在使用GL_TRIANGLES方式进行绘制时，三角形内部点的颜色是由三个顶点的颜色值插值计算得到，由于三个顶点同色，插值后的结果当然还是和顶点一样的颜色，所以整个三角形中的所有点就都是一个颜色。归根结底就是因为三角形的三个顶点同色造成的，现在如果我们想要三角形中点不同色，那就需要给这三个顶点赋不同的颜色值了。也就是每个顶点现在应该要有两种顶点属性：顶点位置坐标、顶点颜色：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp">    <span class="token comment" spellcheck="true">//三角形顶点的坐标和颜色</span>
    GLfloat vertices<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//位置坐标        //颜色</span>
        <span class="token operator">-</span><span class="token number">0.5f</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">0.5f</span><span class="token punctuation">,</span><span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span><span class="token number">0.0f</span><span class="token punctuation">,</span><span class="token number">0.0f</span><span class="token punctuation">,</span>
        <span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0.5f</span><span class="token punctuation">,</span><span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span><span class="token number">1.0f</span><span class="token punctuation">,</span><span class="token number">0.0f</span><span class="token punctuation">,</span>
        <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span><span class="token number">0.0f</span><span class="token punctuation">,</span><span class="token number">1.0f</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>输入的顶点数据变了，顶点属性也增加了，所以我们还需要使用<code>glVertexAttribPointer</code>函数重新解析顶点数据：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp">    <span class="token comment" spellcheck="true">//告诉OpenGL如何解析显存中的顶点位置属性数据</span>
    <span class="token function">glVertexAttribPointer</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> GL_FLOAT<span class="token punctuation">,</span> GL_FALSE<span class="token punctuation">,</span> <span class="token number">6</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>GLfloat<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>GLvoid<span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//打开顶点位置属性数组</span>
    <span class="token function">glEnableVertexAttribArray</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//告诉OpenGL如何解析显存中的顶点颜色属性数据</span>
    <span class="token function">glVertexAttribPointer</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> GL_FLOAT<span class="token punctuation">,</span> GL_FALSE<span class="token punctuation">,</span> <span class="token number">6</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>GLfloat<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>GLvoid<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">3</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>GLfloat<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//打开顶点颜色属性数组</span>
    <span class="token function">glEnableVertexAttribArray</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对于顶点位置坐标属性，它的location为0，由三个float组成，不需要规范化，因为从位置属性开始每隔6个float数据（3个位置坐标、3个颜色），才会再次回到位置属性，所以步长是6*sizeof(GLfloat)，第一个位置属性在缓冲中的偏移量是0；对于顶点颜色属性，它的location为1，由三个float组成，不需要规范化，颜色属性也是6个float数据一个轮回，所以步长也是6*sizeof(GLfloat)，第一个颜色属性是在3个float坐标分量（x、y、z）之后才开始的，所以偏移量是(GLvoid*)(3*sizeof(GLfloat))。</p>
<p>然后需要在顶点着色器中增加一个颜色输入属性，然后把颜色输出（以便传递给像素着色器）：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token comment" spellcheck="true">//顶点着色器</span>
<span class="token keyword">const</span> GLchar<span class="token operator">*</span> vertexShaderSource <span class="token operator">=</span>
<span class="token string">"#version 330 core\n"</span>
<span class="token string">"layout (location=0) in vec3 position;\n"</span>  <span class="token comment" spellcheck="true">//位置变量的属性位置值为0</span>
<span class="token string">"layout (location=1) in vec3 color;\n"</span>     <span class="token comment" spellcheck="true">//颜色变量的属性位置值为1</span>
<span class="token string">"out vec3 ourColor;\n"</span>
<span class="token string">"void main(){\n"</span>
<span class="token string">"gl_Position=vec4(position,1.0f);\n"</span>
<span class="token string">"ourColor=color;\n"</span>
<span class="token string">"}\0"</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>接着在像素着色器接收颜色，并把它赋值给输出颜色变量：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token comment" spellcheck="true">//像素着色器</span>
<span class="token keyword">const</span> GLchar<span class="token operator">*</span> fragmentShaderSource <span class="token operator">=</span>
<span class="token string">"#version 330 core\n"</span>
<span class="token string">"in vec3 ourColor;\n"</span>
<span class="token string">"out vec4 color;\n"</span>
<span class="token string">"void main(){\n"</span>
<span class="token string">"color=vec4(ourColor,1.0f);\n"</span>
<span class="token string">"}\0"</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这样我们就能给三角形三个顶点赋不同的颜色值了，并且三角形内部的点会由三个顶点颜色插值得到。</p>
<p>全部源码<a href="https://github.com/Popperelay/BlogCode/blob/master/LearnOpenGL4_Shader/LearnOpenGL4_Shader_2/main.cpp" target="_blank" rel="external">在这里</a>。</p>
<p>编译运行后的结果如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147978386887.png" alt=""><br>&nbsp; </p>
<hr>
<p><font size="5" color="orange">自定义着色器类</font><br>从上面的程序里可以看到，主函数main太庞杂了，我们希望减轻main函数的负担，把有关着色器的内容拿出来，单独封装成一个类，用于读取、编译、管理着色器，也便于程序理解和移植。</p>
<p>前面是直接把着色器代码写到字符串里，很不方便，IDE也没法检查是否有语法错误。所以我们选择把着色器代码单独写在另一个文件里，要用的时候从文件里读出来。读文件的代码如下：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token comment" spellcheck="true">//从指定路径的文件中读取着色器源码</span>
<span class="token keyword">const</span> GLchar<span class="token operator">*</span> shader<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">GetShaderSourceFromFile</span><span class="token punctuation">(</span><span class="token keyword">const</span> GLchar<span class="token operator">*</span> shaderPath<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//以二进制方式打开指定路径的文件</span>
    ifstream <span class="token function">fin</span><span class="token punctuation">(</span>shaderPath<span class="token punctuation">,</span> ios<span class="token punctuation">:</span><span class="token punctuation">:</span>binary<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//检测是否成功打开文件</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>fin<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token string">"Cannot open input file"</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> endl<span class="token punctuation">;</span>
        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">//将读指针设置到文件尾</span>
    fin<span class="token punctuation">.</span><span class="token function">seekg</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> ios<span class="token punctuation">:</span><span class="token punctuation">:</span>end<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//读出当前文件位置，以获取文件长度</span>
    <span class="token keyword">int</span> length <span class="token operator">=</span> fin<span class="token punctuation">.</span><span class="token function">tellg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//定义长度为length+1的字符串来存储文件内容</span>
    <span class="token keyword">char</span><span class="token operator">*</span> shaderSource <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">char</span><span class="token punctuation">[</span>length <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//重新将读指针设置到文件头</span>
    fin<span class="token punctuation">.</span><span class="token function">seekg</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> ios<span class="token punctuation">:</span><span class="token punctuation">:</span>beg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//读出整个文件</span>
    fin<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>shaderSource<span class="token punctuation">,</span> length<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//给字符串末尾加上字符串结束符'\0'</span>
    shaderSource<span class="token punctuation">[</span>length<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'\0'</span><span class="token punctuation">;</span>
    fin<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> shaderSource<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里把读文件写在一个名为<code>GetShaderSourceFromFile</code>的函数里，函数返回的就是从文件里读出的着色器代码。注释很详细，就不再赘述了，关于C++的文件IO可以参考<a href="http://popperelay.com/2016/11/24/C++%E6%96%87%E4%BB%B6IO/" target="_blank" rel="external">《C++文件的输入输出》</a>。</p>
<p>其余的代码和之前差不多，只是关于着色器的都转移到了类里而已，全部源码<a href="https://github.com/Popperelay/BlogCode/tree/master/LearnOpenGL4_Shader/LearnOpenGL4_Shader_3" target="_blank" rel="external">在这里</a>：<br>&nbsp;</p>
<hr>
<p>参考文献：<a href="https://learnopengl.com/" target="_blank" rel="external">LearnOpenGL</a></p>
]]></content>
      
        <categories>
            
            <category> OpenGL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 着色器 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++文件的输入输出]]></title>
      <url>/2016/11/24/C++%E6%96%87%E4%BB%B6IO/</url>
      <content type="html"><![CDATA[<p>计算机领域的文件，其实是指存放在外部介质上的数据的集合。<br><a id="more"></a></p>
<p>如果想查找存放在外部介质上的数据，必须先按文件名找到所指定的文件，然后再从该文件中读取数据；而要把数据存储在外部介质上，必须先建立一个文件（以文件名标识），才能向它存入数据。<br>&nbsp; </p>
<hr>
<p><font size="5" color="orange">文本文件和二进制文件</font><br>C++按照数据的组织形式，把文件分为文本文件和二进制文件。</p>
<p><font size="4" color="red">文本文件</font><br>文本文件又称ASCII文件，它的每个字节存放一个ASCII码，代表一个字符。</p>
<p>比如，对于一个整数10000，它如果按照文本形式输出到磁盘上，因为有5个数字，每个字符占一个字节，所以需要5个字节来保存这个整数。用文本形式输出时，一个字节对应一个字符，这便于对字符进行逐个处理，也便于输出字符，但是占用的存储空间较大。</p>
<p><font size="4" color="orange">二进制文件</font><br>二进制文件是把内存中的数据，按照其在内存中的存储形式<strong>原样</strong>写到磁盘上存放。</p>
<p>比如，对于一个整数10000，它在内存中只需要两个字节就能存储10000的二进制形式，它如果按照二进制形式输出到磁盘上，当然还是在磁盘上占用两个字节就能表示出10000的二进制。用二进制形式输出数据，可以节省存储空间和转换时间，但是一个字节不能对应一个字符，无法直接以字符形式输出。对于需要暂时保存在外存上，以后又需要输入到内存的中间结果数据，常用二进制形式保存。<br>&nbsp; </p>
<hr>
<p><font size="5" color="orange">C++进行文件输入输出的基本过程</font><br>在C++中，无论对文本文件还是二进制文件，要进行文件的输入输出，必须首先创建一个流对象，然后将这个流对象与文件相关联，即打开文件，此时才能进行读写操作，读写操作完成后再关闭这个文件。</p>
<p>创建流对象 → 打开文件 → 读写操作 → 关闭文件。<br>&nbsp; </p>
<hr>
<p><font size="5" color="orange">创建流对象</font><br>建立流的过程其实就是定义流类的对象。因为与文件IO有关的类fstream、ifstream和ofstream都包含在头文件fstream，所以首先需要在程序中包含此头文件：<code>#include &lt;fstream&gt;</code>。</p>
<p>接下来使用流类来定义流对象，例如：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp">ifstream <span class="token keyword">in</span><span class="token punctuation">;</span>
ofstream <span class="token keyword">out</span><span class="token punctuation">;</span>
fstream both<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>分别定义了输入流对象in、输出流对象out、输入输出流对象both。</p>
<p>其实常用的cin和cout也是流对象，只是已经在头文件iostream中事先定义好了，我们不需要再去自己定义了。<br>&nbsp; </p>
<hr>
<p><font size="5" color="orange">打开文件</font><br>打开文件有两种方式：使用3个文件流类的成员函数open打开文件、在定义流对象时同时打开文件。</p>
<p><font size="4" color="orange">使用成员函数open打开文件</font><br>一般形式是：<code>文件流对象.open(文件名,打开方式);</code></p>
<p>其中文件名可以是相对路径也可以是绝对路径。</p>
<p>打开方式有如下选项：</p>
<ul>
<li>ios::app：打开一个输出文件，用于将数据添加到文件尾部。文件位置指针自动移到文件尾部。</li>
<li>ios::ate：打开一个现存文件，文件位置指针自动移到文件尾部，但数据可以写入文件中任何地方。</li>
<li>ios::in：打开一个文件，用于输入数据，即从文件读出数据到内存。</li>
<li>ios::nocreate：打开一个文件，若文件不存在，则打开失败（通常用open函数打开文件时，如果不存在则创建该文件）。</li>
<li>ios::noreplace：打开一个文件，若文件存在，则打开失败，不存在则新建文件。</li>
<li>ios::out：打开一个文件，用于输出数据，即从内存写入数据到文件。</li>
<li>ios::trunc：打开一个文件，若文件存在，则删除其中全部数据；若文件不存在，则新建文件。</li>
<li>ios::binary：以二进制方式打开一个文件，默认情况下是以文本方式打开文件。</li>
</ul>
<p>对于ifstream对象，文件打开方式默认为ios::in；对于ofstream对象，文件打开方式默认为ios::out。</p>
<p>当一个文件需要多种方式打开时，可以用操作符“|”把几种方式连接在一起。例如，打开一个用于输入和输出的二进制文件：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp">fstream mystream<span class="token punctuation">;</span>
mystream<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"test.dat"</span><span class="token punctuation">,</span>ios<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token keyword">in</span><span class="token operator">|</span>ios<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token keyword">out</span><span class="token operator">|</span>ios<span class="token punctuation">:</span><span class="token punctuation">:</span>binary<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><font size="4" color="red">定义流对象同时打开文件</font><br>可以在定义文件流对象时指定文件路径，来同时打开文件。形如：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp">ofstream <span class="token keyword">out</span><span class="token punctuation">(</span><span class="token string">"test.dat"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>由于这种方式没有指定打开方式，所以使用的是默认打开方式，依旧是：ifstream对象为ios::in打开方式，ofstream对象为ios::out打开方式。所以上面的打开文件代码相当于：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp">ofstream <span class="token keyword">out</span><span class="token punctuation">;</span>
<span class="token keyword">out</span><span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"test.dat"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><font size="4" color="red">检测打开文件是否成功</font><br>执行打开文件操作后，还需要检测打开文件是否成功，如果打开失败，与文件相联系的流对象（比如上面的out）的值将是0。检测代码形如：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">out</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    cout<span class="token operator">&lt;</span><span class="token operator">&lt;</span><span class="token string">"Cannot open file!"</span><span class="token operator">&lt;</span><span class="token operator">&lt;</span>endl<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//其它处理</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>&nbsp; </p>
<hr>
<p><font size="5" color="orange">文件读写</font><br>文件打开以后，就可以进行文件读写了。但是由于数据组织方式不同，文本文件和二进制文件的读写是不一样的（二进制文件在打开时还需要显式指定ios::binary打开方式，默认是以文本方式打开）。</p>
<p><font size="4" color="red">文本文件的读写</font><br>其实和cin、cout一样，使用<code>流对象&gt;&gt;</code>把数据从文件输入到内存，使用<code>流对象&lt;&lt;</code>把数据从内存输出到文件。</p>
<p>下面上个demo，先建立一个输出文件，向它写入数据，然后关闭文件，在按输入方式打开它，并读取信息，保存到变量中，在屏幕上显示出来：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token preprocessor property">#include </span><span class="token string">"stdafx.h"</span>
<span class="token preprocessor property">#include &lt;iostream></span>
<span class="token preprocessor property">#include &lt;fstream></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//定义输出流对象，同时打开文件</span>
    ofstream <span class="token function">fout</span><span class="token punctuation">(</span><span class="token string">"test.dat"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//检测文件是否打开成功</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>fout<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token string">"Cannot open output file!"</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">//把一个字符串写到磁盘文件test.dat中</span>
    fout <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token string">"hello!\n"</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//把一个十进制整数和一个十六进制整数写到test.dat中</span>
    fout <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token number">100</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token string">' '</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> hex <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token number">100</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//关闭文件</span>
    fout<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">//定义输入流对象，同时打开文件</span>
    ifstream <span class="token function">fin</span><span class="token punctuation">(</span><span class="token string">"test.dat"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>fin<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token string">"Cannot open input file!"</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">char</span><span class="token operator">*</span> s<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">char</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>
    <span class="token keyword">int</span> j<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//从磁盘文件test.dat中读取一个字符串赋给s，读取一个整数赋给i</span>
    fin <span class="token operator">></span><span class="token operator">></span> s <span class="token operator">></span><span class="token operator">></span> i <span class="token operator">></span><span class="token operator">></span> j<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//在屏幕上显示</span>
    cout <span class="token operator">&lt;</span><span class="token operator">&lt;</span> s <span class="token operator">&lt;</span><span class="token operator">&lt;</span> endl <span class="token operator">&lt;</span><span class="token operator">&lt;</span> i <span class="token operator">&lt;</span><span class="token operator">&lt;</span> endl <span class="token operator">&lt;</span><span class="token operator">&lt;</span> j <span class="token operator">&lt;</span><span class="token operator">&lt;</span> endl<span class="token punctuation">;</span>
    fin<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>编译运行后，会在该源文件同路径下，创建出一个test.dat文件，文件中内容如下：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp">hello<span class="token operator">!</span>
<span class="token number">100</span> <span class="token number">64</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>并且在屏幕上会输出如下结果：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp">hello<span class="token operator">!</span>
<span class="token number">100</span>
<span class="token number">64</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>64是100的二进制。</p>
<p><font size="4" color="red">二进制文件的读写</font><br>二进制文件的读写不再是使用&gt;&gt;或&lt;&lt;，而是使用类istream和类ostream的成员函数来进行读写。</p>
<p>根据每次读写的数据量不同，二进制文件的读写有两种方式：一种是使用成员函数get和put；另一种是使用成员函数read和write。</p>
<ul>
<li><p>使用get和put函数读写二进制文件：<br>get函数是类istream的成员函数，put函数是类ostream的成员函数，它们每次都只是读写一个字节（字符）。</p>
<p>上个demo体会一下，将a到z的26个英文字母写入二进制文件，而后从该文件中读出并在屏幕上显示出来：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token preprocessor property">#include </span><span class="token string">"stdafx.h"</span>
<span class="token preprocessor property">#include &lt;iostream></span>
<span class="token preprocessor property">#include &lt;fstream></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  ofstream <span class="token function">outb</span><span class="token punctuation">(</span><span class="token string">"binary.dat"</span><span class="token punctuation">,</span> ios<span class="token punctuation">:</span><span class="token punctuation">:</span>binary<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>outb<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      cout <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token string">"Cannot open output file!"</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> endl<span class="token punctuation">;</span>
      <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//退出程序，和abort()作用一样</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">char</span> ch <span class="token operator">=</span> <span class="token string">'a'</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">26</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment" spellcheck="true">//输出字符到磁盘文件binary.dat中</span>
      outb<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">;</span>
      ch<span class="token operator">++</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  outb<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  ifstream <span class="token function">inb</span><span class="token punctuation">(</span><span class="token string">"binary.dat"</span><span class="token punctuation">,</span> ios<span class="token punctuation">:</span><span class="token punctuation">:</span>binary<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>inb<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      cout <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token string">"Cannot open input file"</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> endl<span class="token punctuation">;</span>
      <span class="token function">abort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>inb<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment" spellcheck="true">//从磁盘文件中读取字符赋给ch</span>
      cout <span class="token operator">&lt;</span><span class="token operator">&lt;</span> ch<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  inb<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>编译运行后，会在该源文件同路径下，创建出一个binary.dat，文件内容是26个小写英文字符对应的二进制（用记事本等工具打开后二进制会转为字符，所以用记事本打开看到的不是二进制，而是26个英文字母），并且屏幕上回输出如下结果：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp">abcdefghijklmnopqrstuvwxyz
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>使用read和write函数读写二进制文件：</p>
<ul>
<li>read函数是类istream的成员函数，形如<code>inb .read(char* buf,int len);</code>。用于从与输入文件流对象inb向关联的磁盘文件中，读取len个字节（或遇到EOF提前结束），并把它们存放在字符指针buf所指的一段内存空间内。如果在len个字节（字符）前被读出前，就到达了文件尾，则read函数停止执行。</li>
<li>write函数是类ostream的成员函数，形如<code>outb.write(const char* buf,int len);</code> 。用于将字符指针buf所给出地址开始的len个字节的内容，不加转换地写到与输出文件流对象outb相关联的磁盘文件中。</li>
</ul>
<p>再上个demo体会一下，将课程结构体以二进制形式一次性存放到磁盘文件中：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token preprocessor property">#include </span><span class="token string">"stdafx.h"</span>
<span class="token preprocessor property">#include &lt;iostream></span>
<span class="token preprocessor property">#include &lt;fstream></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//课程结构体</span>
<span class="token keyword">struct</span> Course <span class="token punctuation">{</span>
  <span class="token keyword">char</span> courseName<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> score<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">//课程结构体实例</span>
  Course course <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token string">"computer"</span><span class="token punctuation">,</span><span class="token number">100</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

  ofstream <span class="token function">outb</span><span class="token punctuation">(</span><span class="token string">"binary2.dat"</span><span class="token punctuation">,</span> ios<span class="token punctuation">:</span><span class="token punctuation">:</span>binary<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>outb<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      cout <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token string">"Cannot open output file!"</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> endl<span class="token punctuation">;</span>
      <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment" spellcheck="true">//将课程结构体实例写入磁盘文件binary2.dat中</span>
  outb<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>course<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>course<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  outb<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment" spellcheck="true">//课程结构体实例，用于存储从文件中读取的数据</span>
  Course inCourse<span class="token punctuation">;</span>

  ifstream <span class="token function">inb</span><span class="token punctuation">(</span><span class="token string">"binary2.dat"</span><span class="token punctuation">,</span> ios<span class="token punctuation">:</span><span class="token punctuation">:</span>binary<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>inb<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      cout <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token string">"Cannot open input file!"</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> endl<span class="token punctuation">;</span>
      <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment" spellcheck="true">//从磁盘文件binary2中读取数据存入inCourse结构体实例中</span>
  inb<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>inCourse<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>inCourse<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  cout <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token string">"courseName:"</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> inCourse<span class="token punctuation">.</span>courseName <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token string">' '</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token string">"score:"</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> inCourse<span class="token punctuation">.</span>score <span class="token operator">&lt;</span><span class="token operator">&lt;</span> endl<span class="token punctuation">;</span>
  inb<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>编译运行后，在源文件同路径下回创建出一个binary2.dat文件，用记事本打开结果如下：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp">computer            d
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>因为用记事本打开时会自动将二进制转换为字符，而数字100对应的二进制正好是字母d的ASCII码，所以数字100转变成了字母d。并且屏幕上会出现如下结果：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp">courseName<span class="token punctuation">:</span>computer score<span class="token punctuation">:</span><span class="token number">100</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
</ul>
<p><font size="4" color="red">检测读文件是否结束</font><br>在文件结束的地方有一个标志位，记为EOF（end of file）。采用文件流方式读文件时，使用成员函数<code>eof</code>可以检测到这个结束符：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp">ifstream <span class="token keyword">in</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">in</span><span class="token punctuation">.</span><span class="token function">eof</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>函数<code>eof</code>如果返回值为0，未达到文件尾；如果返回值非0，表示到达文件尾。</p>
<p>其实前面在使用get函数读文件时：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">while</span> <span class="token punctuation">(</span>inb<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//从磁盘文件中读取字符赋给ch</span>
    cout <span class="token operator">&lt;</span><span class="token operator">&lt;</span> ch<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>get函数在读取字符的同时，也通过返回值是否为0，判断是否到达文件尾。</p>
<p><font size="4" color="red">二进制文件的随机读写</font><br>文本文件一般是顺序读写的，但二进制文件还支持从任意位置开始读写，即随机读写。主要是靠设置读指针和写指针的位置来实现。</p>
<p>类istream提供了3个成员函数来设置读指针位置（下面的g是get的缩写）：</p>
<ul>
<li><code>tellg()</code>：返回读指针的当前位置</li>
<li><code>seekg(long position)</code>：将读指针设置到指定的position位置（以字节为单位）</li>
<li><code>seekg(long offset,int way)</code>：以参照位置way为基准移动offset个字节<ul>
<li>参照位置有如下选项：<ul>
<li>ios::beg：文件开头位置</li>
<li>ios::cur：当前文件指针位置</li>
<li>ios::end：文件末尾位置</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>例如<code>inf.seekg(-50,ios::cur);</code>，表示使读指针以当前位置为基准向前（文件开头方向）移动50个字节。</p>
<p>类ostream也提供了3个成员函数来设置写指针位置（下面的p是put的缩写）：</p>
<ul>
<li><code>tellp()</code>：返回当前写指针的位置</li>
<li><code>seekp(long position)</code>：将写指针设置到指定的position位置（以字节为单位）</li>
<li><code>seekp(long offset,int way)</code>：以参考位置way为基准移动offset个字节<ul>
<li>参照位置选项与上面的相同，不赘述了。</li>
</ul>
</li>
</ul>
<p>把读指针位置设置为文件尾ios::end，再使用<code>tellg</code>函数可以获得整个文件的长度：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp">fin<span class="token punctuation">.</span><span class="token function">seekg</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> ios<span class="token punctuation">:</span><span class="token punctuation">:</span>end<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> length <span class="token operator">=</span> fin<span class="token punctuation">.</span><span class="token function">tellg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>知道了整个文件的长度，再使用<code>read</code>函数就可以一次性读出整个文件。上个demo，现在已经有一个binary.dat文件，文件内容如下：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp">abcdefghijklmnopqrstuvwxyz
ABC
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>实现代码如下：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token preprocessor property">#include </span><span class="token string">"stdafx.h"</span>
<span class="token preprocessor property">#include&lt;iostream></span>
<span class="token preprocessor property">#include&lt;fstream></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ifstream <span class="token function">fin</span><span class="token punctuation">(</span><span class="token string">"binary.dat"</span><span class="token punctuation">,</span> ios<span class="token punctuation">:</span><span class="token punctuation">:</span>binary<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//设置读指针到文件尾</span>
    fin<span class="token punctuation">.</span><span class="token function">seekg</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> ios<span class="token punctuation">:</span><span class="token punctuation">:</span>end<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//读出当前读指针的位置，从而得到文件长度</span>
    <span class="token keyword">int</span> length <span class="token operator">=</span> fin<span class="token punctuation">.</span><span class="token function">tellg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//新建字符串str存储文件内容。</span>
    <span class="token comment" spellcheck="true">//需要在读出所有内容后给字符串加'\0'，所以长度设为length+1</span>
    <span class="token keyword">char</span><span class="token operator">*</span> str <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">char</span><span class="token punctuation">[</span>length <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//把读指针重新设到文件头</span>
    fin<span class="token punctuation">.</span><span class="token function">seekg</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> ios<span class="token punctuation">:</span><span class="token punctuation">:</span>beg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//一次性读出整个文件</span>
    fin<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> length<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//给str加上字符串结束符'\0'</span>
    str<span class="token punctuation">[</span>length<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'\0'</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;</span><span class="token operator">&lt;</span> str <span class="token operator">&lt;</span><span class="token operator">&lt;</span> endl<span class="token punctuation">;</span>
    fin<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>编译运行后，在屏幕上的输出结果如下：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp">abcdefghijklmnopqrstuvwxyz
ABC
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>【注】：</p>
<ul>
<li>成员函数<code>get</code>、<code>put</code>、<code>read</code>、<code>write</code>函数不仅可以用于二进制文件，也可以用于文本文件</li>
<li>当要将文件完整读入时，最好使用二进制方式打开ios::binary，因为如果以文本文件方式打开的话，文件流会把一些非字符的数据过滤掉，我们将读取不到那些内容。<br>&nbsp; </li>
</ul>
<hr>
<p><font size="5" color="orange">关闭文件</font><br>输入输出操作完成后，应该将文件关闭，否则可能丢失数据。所谓关闭，其实是将所打开的磁盘文件与流对象断开联系，关闭后流对象就不能再对该文件进行输入输出操作了。使用close成员函数实现，形如：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">in</span><span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">out</span><span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
inb<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
outb<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>&nbsp;</p>
<hr>
<p><font size="5" color="orange">C++字符串流的输入输出</font><br>C++字符串流的输入输出与文件IO类似。文件IO是内存和磁盘文件之间传递数据，而字符串流IO是内存和字符串流之间传递数据。</p>
<p>字符串流IO主要由三个类来实现：</p>
<ul>
<li>istringstream类：从字符串流向内存输入数据</li>
<li>ostringstream类：从内存向字符串流输出数据</li>
<li>stringstream类：既可以向字符串流读数据也可以写数据</li>
</ul>
<p>【注】：</p>
<ul>
<li>string字符串其实也是内存</li>
<li>它们都包含在sstream.h头文件中。</li>
<li>也是通过字符串流对象配合&gt;&gt;和&lt;&lt;运算符来进行IO操作：</li>
</ul>
<pre><code>string line=&quot;ourStr&quot;;
istringstream ins(line);
string str;
ins&gt;&gt;str;
</code></pre><pre><code>string line;
ostringstream outs;
outs&lt;&lt;&quot;ourStr&quot;;
cout&lt;&lt;outs.str()&lt;&lt;endl;
</code></pre>]]></content>
      
        <categories>
            
            <category> C++ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 文件IO </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OpenGL3：着色器画三角形]]></title>
      <url>/2016/11/19/OpenGL3%E7%9D%80%E8%89%B2%E5%99%A8%E7%94%BB%E4%B8%89%E8%A7%92%E5%BD%A2/</url>
      <content type="html"><![CDATA[<p>在高版本的OpenGL中绘制图形，这个过程主要是由OpenGL的<strong>图形输送管道</strong>来完成的。<br><a id="more"></a><br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">图形输送管道</font><br>图形输送管段（pipeline，管线）接收一组3D坐标，然后把它们转变为屏幕上的有色2D像素。图形输送管道可以被划分为几个阶段，每个阶段的输出都是下一个阶段的输入。所有这些阶段都是高度专门化的，它们能够简单地并行执行。由于它们的可并行执行的特征，当今大多数显卡都有成千上万的小处理核心，在GPU上为管线上的每个阶段运行各自的小程序，从而在图形输送管道中快速处理这些它的以及几何运算。这些小程序就叫做着色器（如今CPU最多只有8核，而GPU却有很多很多简单的核，可以大量并行执行那些不是很复杂的计算，比如绘制图形所用的几何运算。关于GPU可以参考这下面这个视频）。</p>
<iframe height="498" width="510" src="http://player.youku.com/embed/XMTYyMzg0MDUzMg==" frameborder="0" 'allowfullscreen'=""></iframe>

<p>有些着色器允许开发者自己配置，用我们自己写的着色器替换默认存在的。这样我们就可以更细致地控制输送管道的特定部分了。因为它们运行在GPU上，所以会节约宝贵的CPU时间。着色器是用OpenGL着色器语言GLSL（OpenGL Shading Language）写的。</p>
<p>图形输送管道的每个阶段如下（蓝色部分代表的是我们可以自定义的着色器）：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147936366377.png" alt=""><br>如你所见，图形输送管道包含很多部分，从最初的顶点数据转变为最终的有色像素。</p>
<p>现在我们用数组的形式传递3个3D坐标作为图形输送管道的输入，它们用来表示一个三角形，这个数组叫做这个三角形的顶点数据（Vertex Data）。除此之外，简单的顶点数据还通常包括顶点的颜色值。</p>
<p>【注】：</p>
<ul>
<li>为了让OpenGL知道我们的坐标和颜色值到底构成了什么，OpenGL需要我们去给出提示，希望这些数据所表示的是什么类型，是一些列的点？一些列的三角形？还是一条线？做出的这些提示叫做基本图形（primitives）。任何一个绘制命令的调用都必须把基本图形类型传递给OpenGL。这是基本图形类型中的几个：GL_POINTS（点）、GL_TRIANGLES（三角形）、GL_LINE_STRIP（连续折线）。</li>
</ul>
<p>下面简单介绍一下图形输送管道的每个部分：</p>
<p>顶点着色器（vertex shader）阶段把一个单独的顶点作为输入。主要目的是把3D坐标转换为另一种3D坐标（后续文章会与解释），同时允许我们队顶点属性进行一些基本处理。顶点着色器阶段会把表示基本图形的所有顶点输出到基本图形组装阶段，作为它的输入。</p>
<p>基本图形组装（primitive assembly）阶段把所有输入的点作组装为特定的基本图形的形状（本文例子是一个三角形）。基本图形组装阶段的输出会传递给几何着色器。</p>
<p>几何着色器（geometry shader）可以通过产生新顶点构造出新的（或是其他的）基本图形，来生成其他形状。</p>
<p>细分着色器（tessellation shader）可以把给定的基本图形细分成更多小基本图形。这样我们就能在物体更接近玩家的时候通过创建更多的三角形，用这种方式创建出更平滑的视觉效果。</p>
<p>像素化（rasterization，也叫光栅化） 阶段会把基本图形映射为屏幕上相应的像素，生成供像素着色器使用的fragment。并且在像素着色器允许之前，会执行裁剪（clipping）。裁剪会丢弃超出视图以外的那些像素，来提升执行效率。</p>
<p>【注】：</p>
<ul>
<li>OpenGL中的一个fragment是OpenGL渲染一个独立像素所需的所有数据。其实就是带有一些额外信息的像素，由于带有额外信息，OpenGL就没有给它取名叫像素。</li>
</ul>
<p>像素着色器的主要目的是计算一个像素的最终颜色，这也是OpenGL高级效果最终产生的地方。通常，像素着色器包含用来计算像素最终颜色的3D场景的一些数据（比如关照、阴影、关的颜色等等）。在所有颜色值确定后，最终它会传到下一个alpha测试和混合（blending）阶段。</p>
<p>alpha测试和混合阶段检测像素的深度值和stencil值，来检查一个像素是否被遮挡了，从而做出取舍（即如果被遮住了就不画这个像素了）。还会查看alpha值（透明度）和物体之间的混合。所以即使在像素着色器中计算出来了一个像素将要输出的颜色，最后的像素颜色在渲染多个三角形的时候也可能会再发生变化，因为有遮挡和alpha混合存在。</p>
<p>应该说这个图形输送管道还是挺复杂的，包含很多要配置的部分。但是大多数场合，我们必须做的只是顶点和像素着色器。几何着色器和细分着色器是可选的，通常使用默认的着色器就行了。<br>&nbsp;</p>
<hr>
<p>在开始绘制之前，我们必须给OpenGL输入一些顶点数据。</p>
<p><font size="5" color="orange">顶点输入</font><br>OpenGL是一个3D图形库，所以我们在OpenGL中指定的坐标都是3D的，即包括x、y、z坐标。因为我们想要渲染一个三角形，所以我们需要指定三角形的3个顶点的3D坐标。为了简单起见，这里我们直接使用标准化设备坐标（x、y、z都在-1到1之间），存储在GLfloat数组中：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp">    <span class="token comment" spellcheck="true">//三角形顶点坐标</span>
    GLfloat vertices<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
        <span class="token operator">-</span><span class="token number">0.5f</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">0.5f</span><span class="token punctuation">,</span><span class="token number">0.0f</span><span class="token punctuation">,</span>
        <span class="token number">0.5f</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">0.5f</span><span class="token punctuation">,</span><span class="token number">0.0f</span><span class="token punctuation">,</span>
        <span class="token number">0.0f</span><span class="token punctuation">,</span><span class="token number">0.5f</span><span class="token punctuation">,</span><span class="token number">0.0f</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>由于我们要画的是一个2D的三角形，所以就把3个顶点的z坐标都设为0了，即每个顶点的深度（depth）都是一样的，看上去就像是2D的。</p>
<p>【注】：</p>
<ul>
<li>标准化设备坐标会通过glViewport函数提供的数据，进行视口变换，最后转换为屏幕空间坐标。这通常都是在顶点着色器中进行的，这些屏幕空间坐标最终会作为像素属性输入到像素着色器。</li>
</ul>
<p>现在有了这样的顶点数据，我们需要把它输入发送给GPU，从而进入顶点着色器阶段。</p>
<p>在发送顶点数据之间，我们需要建立一个顶点数组对象VAO（vertex array object），用于记录顶点数据的存储和如何使用的细节信息。后面我们会告示OpenGL这些顶点数据是怎么存储的以及GPU应该怎么读出来，当我们需要用相同的顶点数据画多个三角形时，就不用每次都去指定这些顶点数据的存储方式和使用方式了，很节省效率：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp">    <span class="token comment" spellcheck="true">//生成顶点数组对象VAO，记录数据的存储和如何使用的细节信息</span>
    GLuint VAO<span class="token punctuation">;</span> 
    <span class="token function">glGenVertexArrays</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>VAO<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>由于CPU把数据发送到显卡相对较慢，但是GPU中顶点着色器却能很快获得顶点。如果从CPU一个顶点一个顶点地发送到显卡，无疑会造成GPU等待，浪费资源。所以我们希望把多个顶点数据一起从CPU发送到显存，这里我们使用顶点缓存对象VBO（vertex buffer object）来实际负责这些顶点数据的存储（包括存储空间和存储过程），它会在<strong>GPU</strong>内存上存储大批顶点：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp">    <span class="token comment" spellcheck="true">//生顶点缓冲对象VBO，负责实际数据的存储</span>
    GLuint VBO<span class="token punctuation">;</span>
    <span class="token function">glGenBuffers</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>VBO<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>正如<a href="http://popperelay.com/2016/10/18/OpenGL%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" target="_blank" rel="external">《OpenGL1：OpenGL概述及环境配置》</a>一文里“OpenGL中的对象”中所诉，接下来要做的就是给顶点数组对象绑定目标（顶点数组）：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp">    <span class="token comment" spellcheck="true">//给顶点数组对象绑定目标(顶点数组，不需要参数)</span>
    <span class="token function">glBindVertexArray</span><span class="token punctuation">(</span>VAO<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>再给顶点缓冲对象绑定目标（数组内存）：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp">    <span class="token comment" spellcheck="true">//给顶点缓冲对象绑定目标（数组内存）</span>
    <span class="token function">glBindBuffer</span><span class="token punctuation">(</span>GL_ARRAY_BUFFER<span class="token punctuation">,</span> VBO<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>已经在显卡上开辟好存储这些顶点的空间了，接下来我们需要顶点数据复制到显存缓冲中：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp">    <span class="token comment" spellcheck="true">//把顶点数据复制到显卡的缓冲内存中</span>
    <span class="token function">glBufferData</span><span class="token punctuation">(</span>GL_ARRAY_BUFFER<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>vertices<span class="token punctuation">)</span><span class="token punctuation">,</span> vertices<span class="token punctuation">,</span> GL_STATIC_DRAW<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>glBufferData函数用来把用户定义的数据复制到当前绑定缓冲里。它的第一个参数是我们希望复制到上面的缓冲类型，这里是数组缓冲这种类型GL_ARRAY_BUFFER；第二个参数是我们希望传递给缓冲的数据大小（字节）；第三个参数是我们希望发送的真实数据；第四个参数指定了我们希望显卡如何管理给定的数据，有三种形式：</p>
<ul>
<li>GL_STATIC_DRAW：数据不会或几乎不会改变。</li>
<li>GL_DYNAMIC_DRAW：数据会被改变很多。</li>
<li>GL_STREAM_DRAW：数据每次绘制时都会改变</li>
</ul>
<p>我们要画的三角形的位置数据不会改变，每次渲染调用时都保持原样，所以它使用的类型最好是GL_STATIC_DRAW。如果一个缓冲中的数据将频繁被改变，那么使用的类型就是GL_DYNAMIC_DRAW或GL_STREAM_DRAW，因为这样能确保图形卡把数据放在高速写入的内存部分。<br>&nbsp; </p>
<hr>
<p><font size="5" color="orange">告诉OpenGL如何读取顶点数据</font><br>到现在我们只是把一堆顶点数据放到了显存的缓冲区中了，但是显卡并不知道这些顶点数据是怎么存放的，该连续多少个字节的数据才表示一个顶点坐标？不知道这些信息就无法用OpenGL函数一个一个地分开读出顶点数据。</p>
<p>下面我们使用    <code>glVertexAttribPointer</code>函数来告知OpenGL如何识别解析显存缓冲中的顶点数据：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp">    <span class="token comment" spellcheck="true">//告诉OpenGL如何识别显存中的顶点数据</span>
    <span class="token function">glVertexAttribPointer</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> GL_FLOAT<span class="token punctuation">,</span> GL_FALSE<span class="token punctuation">,</span> <span class="token number">3</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>GLfloat<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>GLvoid<span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ul>
<li>它的第一个参数指定我们要配置哪一个顶点属性。因为我们在后面的顶点着色器中使用了<code>layout (location=0)</code>来定义顶点属性的位置值为0，所以这里要把这个参数设为0。</li>
<li>第二个参数指定每个属性数据由几个分量组成。因为在本例中，顶点着色器中就一个坐标属性，由3个float组成，所以这个参数设为3（这个参数的值只能是1、2、3、4中的一个）。</li>
<li>第三个参数指定属性分量的数据类型。由于本例中每个顶点位置由3个float组成，所以该参数设为float。</li>
<li>第四个参数指定是否希望数据被规格化。如果设置为GL_TRUE，所有有符号型数据会被映射到-1到1之间，无符号型数据会被映射到0到1之间。这里我们把它设为GL_FLASE。</li>
<li>第五个参数叫做步长，表示相同属性每隔多少字节出现一次。当顶点属性紧密排列时，可以填0，由OpenGL代替我们计算出该值。本例中每隔3*sizeof(GLfloat)字节属性就会重复出现了，即又是x、y、z了。</li>
<li>最后一个参数表示当前绑定到GL_ARRAY_BUFFER缓冲对象的缓冲区中，顶点对应属性的第一个分量距离缓冲起点的偏移量，以字节为单位计算。因为最后一个参数的类型是GLvoid*，而我们的顶点数据就是从数据起点开始的，所以这里设为（GLvoid*）0。</li>
</ul>
<p>现在已经告诉OpenGL应该怎么从缓冲中解析顶点数据了，接着需要使用<code>glEnableVertexAttribArray</code>函数打开顶点属性数组，让这些顶点数据可以用于渲染图形。</p>
<pre class="line-numbers language-csharp"><code class="language-csharp">    <span class="token comment" spellcheck="true">//打开顶点属性数组</span>
    <span class="token function">glEnableVertexAttribArray</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>当然，最后不要忘了解绑VBO和VAO。解绑了之后才能让它们脱离具体的目标，从而再去复用，绑定别的目标：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp">    <span class="token comment" spellcheck="true">//解绑VBO</span>
    <span class="token function">glBindBuffer</span><span class="token punctuation">(</span>GL_ARRAY_BUFFER<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//解绑VAO</span>
    <span class="token function">glBindVertexArray</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>&nbsp; </p>
<hr>
<p><font size="5" color="orange">顶点着色器源码</font><br>顶点着色器是几个着色器中的一个，它是可编程的。现代OpenGL需要我们至少设置一个顶点着色器和一个像素着色器。</p>
<p>我们需要做的第一件事是用着色器语言GLSL写顶点着色器，然后编译这个着色器，这样我们就可以在接下来的程序中使用这个顶点着色器了。下面是一个非常基础的顶点着色器源码：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token comment" spellcheck="true">//顶点着色器</span>
<span class="token keyword">const</span> GLchar<span class="token operator">*</span> vertexShaderSource <span class="token operator">=</span> 
    <span class="token string">"#version 330 core\n"</span>
    <span class="token string">"layout (location=0) in vec3 position;\n"</span>
    <span class="token string">"void main(){\n"</span>
    <span class="token string">"gl_Position=vec4(position.x,position.y,position.z,1.0);\n"</span>
    <span class="token string">"}\0"</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在引号中的就是我们的顶点着色器源码，现在把它存储在一个字符串中，方便后面用着色器名字直接使用着色器。每个着色器都起始于一个版本声明，这是因为要让高版本的GLSL和OpenGL相匹配（GLSL330对应OpenGL3.3）。我们同样在后面显示地表示我们会用core profile功能。</p>
<p>然后就是在顶点着色器中使用in关键字声明所有的<strong>输入</strong>属性。因为现在我们只关心位置数据（position），所以我们使用<code>in vec3 position</code>，同时需要指定属性的索引，即<code>layout (location = 0)</code>，何在一起就是<code>layout (location=0) in vec3 position;</code>。</p>
<p>接下来在着色器的main函数（注意是着色器的main函数）中，我们设置顶点着色器的输出，gl_Position为内置变量（以gl前缀开头的变量一般都表示内置变量），表示顶点输出位置。我们必须把输入的位置数据赋值给预定义的gl_Position（该变量是vec4类型）：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    gl_Position <span class="token operator">=</span> <span class="token function">vec4</span><span class="token punctuation">(</span>position<span class="token punctuation">.</span>x<span class="token punctuation">,</span> position<span class="token punctuation">.</span>y<span class="token punctuation">,</span> position<span class="token punctuation">.</span>z<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>gl_Position会作为顶点着色器的输出发送到图形输送管道的下一阶段。在后续文章会解释vec4的第4个参数为什么是1.0f。</p>
<p>【注】：</p>
<ul>
<li>向量：在GLSL中一个向量最多可以有4个元素：x、y、z、w。但是z元素不是用作表达空间位置的，而是用在透视除法上。后续文章会介绍到。</li>
</ul>
<p>这个顶点着色器应该是能想到的最简单的了，因为我们直接输入的就是标准化设备坐标，在顶点着色器里面什么都没有处理就把输入数据输出了。但是在真是应用里输入数据通常都没有在标准化设备坐标中，所以在顶点着色器中通常都需要把它们转化为标准化设备坐标，放进OpenGL的可视区域内。<br>&nbsp; </p>
<hr>
<p><font size="5" color="orange">编译着色器</font><br>上面我们已经写了一个顶点着色器源码，但是为了让OpenGL能够使用它，我们必须在运行时动态编译它的源码。</p>
<p>通常的流程都是：创建着色器对象 → 把着色器源码附加到着色器对象 → 编译着色器 → 检测编译是否成功。</p>
<p><font size="4" color="red">创建着色器对象</font><br>使用<code>glCreateShader</code>函数创建着色器，参数是着色器类型：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp">    <span class="token comment" spellcheck="true">//创建顶点着色器对象</span>
    GLuint vertexShader <span class="token operator">=</span> <span class="token function">glCreateShader</span><span class="token punctuation">(</span>GL_VERTEX_SHADER<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><font size="4" color="red">附加着色器源码到着色器对象</font><br>使用<code>glShaderSource</code>函数把着色器源码添加到新创建的着色器对象上：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp">    <span class="token comment" spellcheck="true">//把着色器源码附加到着色器对象</span>
    <span class="token function">glShaderSource</span><span class="token punctuation">(</span>vertexShader<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>vertexShaderSource<span class="token punctuation">,</span> NULL<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>第一个参数是着色器对象；第二个参数指定了源码中有多少个字符串，这里只有一个；第三个参数是顶点着色器真正的源码；第四个参数可以设置为NULL，表示每个字符串都没有终止，直到遇到’\0’。</p>
<p><font size="4" color="red">编译着色器</font><br>使用<code>glCompileShader</code>函数来编译着色器，参数是着色器对象：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp">    <span class="token comment" spellcheck="true">//编译顶点着色器</span>
    <span class="token function">glCompileShader</span><span class="token punctuation">(</span>vertexShader<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><font size="4" color="red">检测编译是否成功</font></p>
<pre class="line-numbers language-csharp"><code class="language-csharp">    <span class="token comment" spellcheck="true">//检测编译是否成功</span>
    GLint success<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//编译结果</span>
    GLchar infoLog<span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//错误信息</span>
    <span class="token function">glGetShaderiv</span><span class="token punctuation">(</span>vertexShader<span class="token punctuation">,</span> GL_COMPILE_STATUS<span class="token punctuation">,</span> <span class="token operator">&amp;</span>success<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>success<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">glGetShaderInfoLog</span><span class="token punctuation">(</span>vertexShader<span class="token punctuation">,</span> <span class="token number">512</span><span class="token punctuation">,</span> NULL<span class="token punctuation">,</span> infoLog<span class="token punctuation">)</span><span class="token punctuation">;</span>
        std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token string">"ERROR::SHADER::VERTEX::COMPILATION_FAILED\n"</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> infoLog <span class="token operator">&lt;</span><span class="token operator">&lt;</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>首先定义一个整型success来表示是否成功编译，还需要一个存储错误消息的容器infoLog（如果有错误的话），然后用<code>glGetShaderiv</code>函数来检查是否编译成功了。如果编译失败，用<code>glGetShaderInfoLog</code>函数来获取错误信息，然后打印它。</p>
<p>函数<code>glGetShaderInfoLog</code>的第一个参数是编译失败的着色器，第二个参数是存储错误信息的数组大小，第三个参数是返回的错误信息字符串的长度，如果不需要可以为NULL，第四个参数是存储错误信息的字符数组。<br>&nbsp; </p>
<hr>
<p><font size="5" color="orange">像素着色器源码</font><br>像素着色器是最终我们打算创建的用于渲染三角形的着色器。像素着色器的全部，都是用来计算像素的最后颜色输出。为了简单点，我们的像素着色器只输出橘黄色（每个颜色的强度都是在0到1之间的浮点数，三种颜色可以调配处1600万中不同颜色，颜色值的第4个参数表示alpha透明度）：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token comment" spellcheck="true">//像素着色器</span>
<span class="token keyword">const</span> GLchar<span class="token operator">*</span> fragmentShaderSource <span class="token operator">=</span>
    <span class="token string">"#version 330 core\n"</span>
    <span class="token string">"out vec4 color;\n"</span>
    <span class="token string">"void main(){\n"</span>
    <span class="token string">"color=vec4(1.0,0.5f,0.2f,1.0f);\n"</span>
    <span class="token string">"}\0"</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>像素着色器只需要一个输出变量，这个变量是一个表示最终输出颜色的vec4向量。可以用out关键字来声明输出变量，命名为color，即<code>out vec4 color;</code>。然后在像素着色器的main函数中给输出变量color指定橘黄色，透明度为1（不透明），即<code>color = vec4(1.0f, 0.5f, 0.2f, 1.0f);</code>。<br>&nbsp; </p>
<hr>
<p><font size="5" color="orange">编译像素着色器</font><br>编译像素着色器的过程与顶点着色器一致，如下：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token comment" spellcheck="true">//创建像素着色器对象</span>
    GLuint fragmentShader <span class="token operator">=</span> <span class="token function">glCreateShader</span><span class="token punctuation">(</span>GL_FRAGMENT_SHADER<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//把像素着色器源码附加到像素着色器对象</span>
    <span class="token function">glShaderSource</span><span class="token punctuation">(</span>fragmentShader<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>fragmentShaderSource<span class="token punctuation">,</span> NULL<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//编译像素着色器源码</span>
    <span class="token function">glCompileShader</span><span class="token punctuation">(</span>fragmentShader<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//检测是否编译成功</span>
    <span class="token function">glGetShaderiv</span><span class="token punctuation">(</span>fragmentShader<span class="token punctuation">,</span> GL_COMPILE_STATUS<span class="token punctuation">,</span> <span class="token operator">&amp;</span>success<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>success<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">glGetShaderInfoLog</span><span class="token punctuation">(</span>fragmentShader<span class="token punctuation">,</span> <span class="token number">512</span><span class="token punctuation">,</span> NULL<span class="token punctuation">,</span> infoLog<span class="token punctuation">)</span><span class="token punctuation">;</span>
        std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token string">"ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\n"</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> infoLog <span class="token operator">&lt;</span><span class="token operator">&lt;</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>&nbsp; </p>
<hr>
<p>顶点着色器和像素着色器都已经编译了，剩下的事情就是把两个着色器对象链接到一个着色器程序中，它是用来渲染的。</p>
<p><font size="5" color="orange">着色器程序</font><br>着色器程序对象（shader program object）是多个着色器最后链接的版本。如果要使用刚才编译好的着色器我们必须把它们链接为一个着色器程序对象，然后当渲染物体的时候激活这个着色器程序，才能进行利用着色器进行渲染。</p>
<p>把着色器链接为一个程序就等于把每个着色器的输出链接到下一个着色器的输入。当然，如果你的输出和输入不匹配，那么将得到一个链接错误。</p>
<p><font size="4" color="red">创建着色器程序对象</font><br>首先需要使用glCreateShader函数创建着色器程序对象：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp">    <span class="token comment" spellcheck="true">//创建着色器程序对象</span>
    GLuint shaderProgram <span class="token operator">=</span> <span class="token function">glCreateProgram</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><font size="4" color="red">附加链接</font><br>然后需要把着色器附加到着色器程序对象上，然后链接起来：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp">    <span class="token comment" spellcheck="true">//把着色器附加到着色器程序对象上，然后链接起来</span>
    <span class="token function">glAttachShader</span><span class="token punctuation">(</span>shaderProgram<span class="token punctuation">,</span> vertexShader<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">glAttachShader</span><span class="token punctuation">(</span>shaderProgram<span class="token punctuation">,</span> fragmentShader<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">glLinkProgram</span><span class="token punctuation">(</span>shaderProgram<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><font size="4" color="red">检测是否链接成功</font><br>接下来是需要检测一下链接是否成功，和检测是否成功编译类似：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp">    <span class="token comment" spellcheck="true">//检查是否链接成功</span>
    <span class="token function">glGetProgramiv</span><span class="token punctuation">(</span>shaderProgram<span class="token punctuation">,</span> GL_LINK_STATUS<span class="token punctuation">,</span> <span class="token operator">&amp;</span>success<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>success<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">glGetProgramInfoLog</span><span class="token punctuation">(</span>shaderProgram<span class="token punctuation">,</span> <span class="token number">512</span><span class="token punctuation">,</span> NULL<span class="token punctuation">,</span> infoLog<span class="token punctuation">)</span><span class="token punctuation">;</span>
        std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token string">"ERROR::PROGRAM::LINKING_FAILED\n"</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><font size="4" color="red">删除着色器对象</font><br>最后是删除着色器对象，因为它们已经被成功链接到着色器程序对象了，不再需要着色器对象了，应该释放它们：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp">    <span class="token comment" spellcheck="true">//删除着色器对象</span>
    <span class="token function">glDeleteShader</span><span class="token punctuation">(</span>vertexShader<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">glDeleteShader</span><span class="token punctuation">(</span>fragmentShader<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>&nbsp; </p>
<hr>
<p><font size="5" color="orange">在游戏循环中渲染三角形</font><br>在顶点输入、顶点着色器、像素着色器、着色器程序对象等过程都完成后，迎来了最终的三角形渲染。</p>
<p>OpenGL的glDrawArrays函数为我们提供了绘制物体的能力，它使用当前激活的着色器、前面定义的顶点属性和顶点数组对象VAO来绘制基本图形。</p>
<p>所以我们需要先激活着色器程序对象，再绑定VAO完成顶点输入初始化，接着使用<code>glDrawArrays</code>函数来画三角形，最后解绑VAO：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token comment" spellcheck="true">//激活着色器程序对象</span>
        <span class="token function">glUseProgram</span><span class="token punctuation">(</span>shaderProgram<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//绑定VAO，完成顶点输入初始化</span>
        <span class="token function">glBindVertexArray</span><span class="token punctuation">(</span>VAO<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//绘图</span>
        <span class="token function">glDrawArrays</span><span class="token punctuation">(</span>GL_TRIANGLES<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//解绑VAO</span>
        <span class="token function">glBindVertexArray</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>glDrawArrays函数的第一个参数是我们打算绘制的OpenGL基本图形的类型，这里是三角形GL_TRIANGLES；第二个参数是我们打算绘制的那个顶点数组的起始位置的索引；最后一个参数是我们打算绘制多少个顶点。</p>
<p>当然，在退出渲染后，不要忘了清除掉顶点数组对象VAO和顶点缓冲对象VBO：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp">    <span class="token comment" spellcheck="true">//删除VAO、VBO</span>
    <span class="token function">glDeleteVertexArrays</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>VAO<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">glDeleteBuffers</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>VBO<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>&nbsp;  </p>
<hr>
<p>到此为止，我们已经完成了一个三角形的绘制，全部源码<a href="https://github.com/Popperelay/BlogCode/blob/master/LearnOpenGL3_CreateTriangle/main1.cpp" target="_blank" rel="external">在这里</a>。<br>编译运行后的结果如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147939271602.png" alt=""><br>&nbsp;  </p>
<hr>
<p>下面我们再来看一个，画矩形该怎么画？我们可以绘制两个三角形来组成一个矩形，事实上OpenGL主要就是绘制三角形，我们看到的很多复杂图形，包括3D图形，都是很多个小的三角形拼凑起来的。</p>
<p>画两个三角形的时候，如果直接用顶点去画，将需要2个三角形6个顶点：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp">GLfloat vertices<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 第一个三角形</span>
    <span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span>   <span class="token comment" spellcheck="true">// 右上角</span>
    <span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">// 右下角</span>
    <span class="token operator">-</span><span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">// 左上角 </span>
    <span class="token comment" spellcheck="true">// 第二个三角形</span>
    <span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">// 右下角</span>
    <span class="token operator">-</span><span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 左下角</span>
    <span class="token operator">-</span><span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span>   <span class="token comment" spellcheck="true">// 左上角</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>但是这两个三角形其实有两个顶点是重合的，指定了右下角和左上角的顶点两次！一个矩形应该只有4个顶点而不是6个，这样就产生了50%的额外开销。如果我们有一个模型是大量的三角形拼凑起来的，这将会产生更大的浪费。最好的解决方案当然是每个顶点只存储一次，而在绘制的时候只需要指定打算绘制的那个顶点的索引就可以了。<br>&nbsp; </p>
<hr>
<p><font size="5" color="orange">用索引缓冲对象绘制矩形</font><br>恰巧的是，OpenGL提供了用索引缓冲进行绘制的工作方式。用索引缓冲对象EBO（elements buffer object）是一个像VBO一样的缓冲，专门存储索引，OpenGL调用这些顶点的索引来绘制。</p>
<p><font size="4" color="red">索引数组</font><br>首先我们需要定义一个浮点型数组，来存储矩形的四个顶点坐标；再定义一个整型数组，来存储组成矩形的两个三角形的顶点索引：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp">    <span class="token comment" spellcheck="true">//三角形顶点坐标</span>
    GLfloat vertices<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
        <span class="token number">0.5f</span><span class="token punctuation">,</span><span class="token number">0.5f</span><span class="token punctuation">,</span><span class="token number">0.0f</span><span class="token punctuation">,</span>
        <span class="token number">0.5f</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">0.5f</span><span class="token punctuation">,</span><span class="token number">0.0f</span><span class="token punctuation">,</span>
        <span class="token operator">-</span><span class="token number">0.5f</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">0.5f</span><span class="token punctuation">,</span><span class="token number">0.0f</span><span class="token punctuation">,</span>
        <span class="token operator">-</span><span class="token number">0.5f</span><span class="token punctuation">,</span><span class="token number">0.5f</span><span class="token punctuation">,</span><span class="token number">0.0f</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//顶点索引</span>
    GLuint indices<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
        <span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">//第一个三角形</span>
        <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span>   <span class="token comment" spellcheck="true">//第二个三角形</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><font size="4" color="red">索引缓冲对象</font><br>接下来就是在主函数中生成索引缓冲对象EBO，负责索引数据的存储：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp">    <span class="token comment" spellcheck="true">//生成索引缓冲对象EBO，负责索引数据的存储</span>
    GLuint EBO<span class="token punctuation">;</span>
    <span class="token function">glGenBuffers</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>EBO<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>和VBO一样，接着需要给EBO绑定目标：索引数组内存：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp">    <span class="token comment" spellcheck="true">//给索引缓冲对象绑定目标（索引数组缓冲）</span>
    <span class="token function">glBindBuffer</span><span class="token punctuation">(</span>GL_ELEMENT_ARRAY_BUFFER<span class="token punctuation">,</span> EBO<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>然后就是把索引数据复制到显卡的索引数组缓冲中了：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp">    <span class="token comment" spellcheck="true">//把索引数据复制到显卡的缓冲内存中</span>
    <span class="token function">glBufferData</span><span class="token punctuation">(</span>GL_ELEMENT_ARRAY_BUFFER<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>indices<span class="token punctuation">)</span><span class="token punctuation">,</span> indices<span class="token punctuation">,</span> GL_STATIC_DRAW<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>【注】：</p>
<ul>
<li>对EBO的操作还是应该在VAO绑定和解绑之间的，因为需要让VAO记录下来EBO的存储过程和细节。这样在用索引进行绘制时，还是只需要绑定VAO即可，不用再去对EBO进行一些列的绑定、复制数据等操作。</li>
</ul>
<p><font size="4" color="red">更改绘制方式</font><br>因为现在是改用索引缓冲进行渲染了，所以需要把<code>glDrawArrays</code>函数改为<code>glDrawElements</code>函数：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp">        <span class="token comment" spellcheck="true">//绘图</span>
        <span class="token function">glDrawElements</span><span class="token punctuation">(</span>GL_TRIANGLES<span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> GL_UNSIGNED_INT<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>第一个参数指定了绘制模式；第二个参数是我们打算绘制的顶点数；第三个参数是索引的类型；最后一个参数指定索引被存储的位置（或者说是起始索引在EBO中的偏移量；如果没有使用EBO但是还想使用索引进行绘制，这里可以传递一个索引数组）。</p>
<p><font size="4" color="red">渲染后删除EBO</font><br>当然，绘制完后不要忘了删除索引缓冲对象EBO：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp">    <span class="token function">glDeleteBuffers</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>EBO<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>&nbsp; </p>
<hr>
<p>到此，我们已经绘制了一个由两个三角形组成的矩形，全部源码<a href="https://github.com/Popperelay/BlogCode/blob/master/LearnOpenGL3_CreateTriangle/main2.cpp" target="_blank" rel="external">在这里</a>。<br>编译运行后的结果如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/14795454835.png" alt=""><br>&nbsp;</p>
<hr>
<p>参考文献：<a href="https://learnopengl.com/" target="_blank" rel="external">LearnOpenGL</a></p>
]]></content>
      
        <categories>
            
            <category> OpenGL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 着色器画三角形 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OpenGL2：创建一个窗口]]></title>
      <url>/2016/11/16/OpenGL2%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AA%97%E5%8F%A3/</url>
      <content type="html"><![CDATA[<p>在上一篇<a href="http://popperelay.com/2016/10/18/OpenGL%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" target="_blank" rel="external">《OpenGL1：OpenGL概述及环境配置》</a>中，已经说过接下来的OpenGL项目，我们将使用GLFW和GLEW相结合的方式。<br><a id="more"></a></p>
<p><font size="5" color="orange">头文件</font><br>既然要使用GLFW和GLEW中的函数，那在我们的源文件里肯定要包含它俩的头文件：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token comment" spellcheck="true">//GLEW</span>
<span class="token preprocessor property">#<span class="token directive keyword">define</span> GLEW_STATIC</span>
<span class="token preprocessor property">#include&lt;GL/glew.h></span>
<span class="token comment" spellcheck="true">//GLFW</span>
<span class="token preprocessor property">#include&lt;GLFW/glfw3.h></span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<hr>
<p><font size="5" color="orange">初始化并配置GLFW</font><br>加入了头文件还不够，接下来还需要在main函数中初始化并配置GLFW：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//初始化GLFW</span>
    <span class="token function">glfwInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token comment" spellcheck="true">//GLFW配置</span>
    <span class="token function">glfwWindowHint</span><span class="token punctuation">(</span>GLFW_CONTEXT_VERSION_MAJOR<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//主版本号</span>
    <span class="token function">glfwWindowHint</span><span class="token punctuation">(</span>GLFW_CONTEXT_VERSION_MINOR<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//次版本号</span>
    <span class="token function">glfwWindowHint</span><span class="token punctuation">(</span>GLFW_OPENGL_PROFILE<span class="token punctuation">,</span> GLFW_OPENGL_CORE_PROFILE<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 核心开发模式</span>
    <span class="token function">glfwWindowHint</span><span class="token punctuation">(</span>GLFW_RESIZABLE<span class="token punctuation">,</span> GL_FALSE<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//窗口尺寸不可变</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在main函数中我们首先使用<code>glfwInit</code>来初始化GLFW，然后可以使用glfwWindowHint来配置GLFW。glfwWindowHint的第一个参数是将要配置的选项，可以从一个枚举中选择可用的选项，这些选项带有GLFW_前缀；第二个参数是一个整数，代表我们为选项所设置的值。可用的选项和对应的值可以在<a href="http://www.glfw.org/docs/latest/group__window.html" target="_blank" rel="external">GLFW文档</a>中找到。</p>
<p>因为我用的是OpenGL3.3版本，所以把主版本和次版本都设为3，这会保证如果一个用户没有特定的OpenGL版本，GLFW就会运行失败。开发模式我们尽量用core-proflie核心模式，而且要求用户不可以调整窗口大小。显式地告诉GLFW我们希望是用core-profile，如果我们调用了一个OpenGL的遗留函数将会产生invalid operation错误，当我们意外地使用了不该使用的旧函数时它是一个很好的提醒。<br>&nbsp; </p>
<hr>
<p><font size="5" color="orange">创建窗口对象</font><br>接下来就是创建窗口对象，有了这个窗口对象后，很多GLFW函数才会有意义：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token comment" spellcheck="true">//创建能够使用GLFW函数的窗口对象（指针）</span>
    GLFWwindow<span class="token operator">*</span> window <span class="token operator">=</span> <span class="token function">glfwCreateWindow</span><span class="token punctuation">(</span><span class="token number">800</span><span class="token punctuation">,</span> <span class="token number">600</span><span class="token punctuation">,</span> <span class="token string">"LearnOpenGL"</span><span class="token punctuation">,</span> nullptr<span class="token punctuation">,</span> nullptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>window <span class="token operator">==</span> NULL<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token string">"Failed to create GLFW window"</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>endl<span class="token punctuation">;</span>
        <span class="token function">glfwTerminate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>函数<code>glfwCreateWIndow</code>需要窗口的宽度和高度作为它的头两个参数，第三个参数是窗口的名字，后两个参数（显示器、共享资源）可以忽略。该函数返回已创建的FLFWwindow对象的指针，在后面的其他GLFW操作会需要它。<br>&nbsp; </p>
<hr>
<p><font size="5" color="orange">设置窗口环境</font><br>因为每一个窗口都必须有OpenGL或者OpenGL ES的上下文（环境），如果不给窗口指定环境，将会产生GLFW_NO_WINDIW_CONTEXT错误。这里我们使用<code>glfwMakeContextCurrent</code>函数指定窗口环境是当前线程的主环境：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp">    <span class="token comment" spellcheck="true">//创建窗口环境</span>
    <span class="token function">glfwMakeContextCurrent</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>&nbsp; </p>
<hr>
<p><font size="5" color="orange">初始化GLEW</font><br>后面要做的就是用OpenGL函数进行渲染了。不过在之前的文章里，我们已经知道GLEW管理着OpenGL的函数指针，所以需要在调用任何OpenGL函数之前初始化GLEW：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp">    <span class="token comment" spellcheck="true">//初始化GLEW</span>
    glewExperimental <span class="token operator">=</span> GL_TRUE<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//保证使用现代技术管理OpenGL机能</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">glewInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> GLEW_OK<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token string">"Failed to initialize GLEW"</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>endl<span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注意，在初始化GLEW前我们把glewExperimental变量设置为GL_TRUE。这样可以保证GLEW使用更多的现代技术来管理OpenGL机能。如果不这么设置，它就会使用默认的GL_FALSE，这样当使用core profile时有可能会出问题。<br>&nbsp;  </p>
<hr>
<p><font size="5" color="orange">设置渲染窗口</font><br>在开始渲染前，需要告诉OpenGL渲染窗口的大小和位置：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp">    <span class="token comment" spellcheck="true">//设置渲染窗口位置大小</span>
    <span class="token function">glViewport</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">800</span><span class="token punctuation">,</span> <span class="token number">600</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>前两个参数设置了渲染窗口的左下角位置，后两个参数是渲染窗口的宽度和高度。这里指定的是和GLFW窗口是一样大的。不过我们可以吧这个渲染窗口设置得比GLFW窗口尺寸小，这样OpenGL的渲染都会在一个更小的窗口（区域）进行显示，我们可以在OpenGL的渲染窗口viewport之外显示其他的元素。</p>
<p>【注】：</p>
<ul>
<li>OpenGL中处理的坐标其实是在-1到1之间，原点在显示区域正中间，比如一个被加工的点位置是（-0.5,0.5）（标准化设备坐标），通过glViewport后会把这种2D坐标映射为屏幕上的坐标（200,450）。<br>&nbsp; </li>
</ul>
<hr>
<p><font size="5" color="orange">渲染循环（游戏循环）</font><br>因为我们不希望程序在会在一个图像之后立即退出，然后关闭窗口，这会造成渲染的结果在屏幕上一闪而过。我们想让程序持续地绘制图像，监听用户输入知道程序被明确告知停止。为了达到这个目的，我们必须建立一个while循环，每次while循环都重新绘制（渲染）一次，直到被告知结束渲染。由于程序始终处于while循环，不会自动退出（除非循环条件不满足，即被告知结束渲染），所以渲染结果也会一直于窗口上，不会一闪而过。下面的代码是一个非常简单的游戏循环（渲染循环）：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp">    <span class="token comment" spellcheck="true">//渲染循环（游戏循环）</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">glfwWindowShouldClose</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">glfwPollEvents</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//检测是否有事件被触发（按键按下、鼠标移动）</span>
        <span class="token function">glfwSwapBuffers</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//交换屏幕缓存</span>
    <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>glfwWindowShouldClose</code>函数从开始便检验每一次循环迭代中GLFW窗口是否已经得到关闭提示。如果得到这样的提示，函数就会返回true，导致游戏循环终止。</p>
<p><code>glfwPollEvents</code>函数检验是否有任何时间被触发（比如键盘输入、鼠标移动等事件），如果有就可以调用相应函数进行处理（可以通过回调函数进行设置）。而且经常都是在循环迭代前调用事件处理函数。</p>
<p><code>glfwSwapBuffers</code>函数会交换颜色缓冲（颜色缓冲是一个GLFW窗口为每一个像素存储颜色数值的大缓存，它是在这次迭代中绘制的，也作为输出显示在屏幕上）。</p>
<p>【注】：</p>
<ul>
<li>双缓冲（Double Buffer）：当一个应用以单缓冲方式绘制的时候，图像可能会产生闪烁的问题。这是因为最后的图像输出不是被立即绘制出来的，而是一个像素一个像素绘制出来的，通常是以从左到右从上到下这样的方式。由于这些图像不是立即呈现在用户面前，而是一步一步地生成结果，这就会产生很多不真实感。为了规避这些问题，窗口应用使用双缓冲的方式进行渲染。前缓冲包含最终的输出图像，它被显示在屏幕上，<strong>与此同时</strong>，所有的渲染命令绘制后缓冲。所有的渲染命令执行结束后，我们就把后缓冲交换到前缓冲，这样图像就会立即显示到用户面前了，前面提到的闪烁问题就被解决了。<br>&nbsp; </li>
</ul>
<hr>
<p><font size="5" color="orange">渲染</font><br>我们需要把所有的渲染命令都放在渲染循环里，因为我们打算每个循环迭代都执行所有的渲染命令。通常把渲染命令放在检查事件和交换缓冲之间：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp">    <span class="token comment" spellcheck="true">//渲染循环（游戏循环）</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">glfwWindowShouldClose</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">glfwPollEvents</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//检测是否有事件被触发（按键按下、鼠标移动）</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>               <span class="token comment" spellcheck="true">//这里是渲染命令</span>
        <span class="token function">glfwSwapBuffers</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//交换屏幕缓存</span>
    <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里我们使用一个最简单的渲染命令：用指定的颜色清空屏幕。因为每个渲染迭代开始时，我们都需要清理屏幕，否则只能一直看到前一个迭代的结果：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp">        <span class="token function">glClearColor</span><span class="token punctuation">(</span><span class="token number">0.2f</span><span class="token punctuation">,</span> <span class="token number">0.3f</span><span class="token punctuation">,</span> <span class="token number">0.3f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">glClear</span><span class="token punctuation">(</span>GL_COLOR_BUFFER_BIT<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>使用<code>glClearColor</code>函数来设置清空屏幕用的颜色。使用<code>glClear</code>函数清理屏幕的颜色缓冲，在这个函数中我们以缓冲位（BUFFER_BIT）指定我们希望清理哪个缓冲。可以用的位可以是GL_COLOR_BUFFER_BIT、GL_DEPTH_BUFFER_BIT和GL_STENCIL_BUFFER_BIT。因为我们现在关心的只是颜色值，所以我们只清空颜色缓冲。<br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">响应输入</font><br>之前的while循环是会一直运行下去的，因为没有被告知停止循环。现在我们希望在GLFW中有些控制输入的方式，当用户按下某个按键后结束渲染循环。我们可以使用GLFW的回调函数做到这点。其中有一个GLFW回调函数是KeyCallback函数，它在用户使用键盘交互的时候会被GLFW自动调用。该回调函数的原型是：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span> GLFWkeyfun<span class="token punctuation">)</span><span class="token punctuation">(</span>GLFWwindow<span class="token operator">*</span> window<span class="token punctuation">,</span> <span class="token keyword">int</span> key<span class="token punctuation">,</span> <span class="token keyword">int</span> scancode<span class="token punctuation">,</span> <span class="token keyword">int</span> action<span class="token punctuation">,</span> <span class="token keyword">int</span> mode<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>按键输入回调函数的参数是一个GLFWwindow对象指针，一个代表按下按键的整型数字，按键扫描码，一个表示按键是被按下、释放还是按住的整型数字，一个代表某个标识的整数告诉你shift、control、alt或super按键是否被同时按下。每当用户按下一个按钮，GLFW都会自动调用这个函数，为该函数填充合适的参数。我们给这个按键输入回调函数随便起个名字吧，叫key_callback：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">void</span> <span class="token function">key_callback</span><span class="token punctuation">(</span>GLFWwindow<span class="token operator">*</span> window<span class="token punctuation">,</span><span class="token keyword">int</span> key<span class="token punctuation">,</span><span class="token keyword">int</span> scancode<span class="token punctuation">,</span><span class="token keyword">int</span> action<span class="token punctuation">,</span><span class="token keyword">int</span> mode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> GLFW_KEY_ESCAPE<span class="token operator">&amp;&amp;</span>action <span class="token operator">==</span> GLFW_PRESS<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">glfwSetWindowShouldClose</span><span class="token punctuation">(</span>window<span class="token punctuation">,</span> GL_TRUE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在我们（新创建）的key_callback函数中，我们检查被<strong>按下</strong>的按键是否是ESC键，如果是的话，就用glfwSetWindowShouldClose设置它的WindowShouldClose属性为true来关闭GLFW窗口。下一个主while循环条件不满足，则渲染循环就结束了。</p>
<p>还有最后一点，在使用回调函数之前，是需要先注册的，也就是得给我们的这个按键回调函数声明一下并起个名字：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp">    <span class="token comment" spellcheck="true">//注册回调函数</span>
    <span class="token function">glfwSetKeyCallback</span><span class="token punctuation">(</span>window<span class="token punctuation">,</span> key_callback<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>【注】：</p>
<ul>
<li>除了按键回调函数外，还有许多GLFW回调函数可供于给注册我们自己的函数。</li>
<li>要在创建窗口之后，渲染循环之前注册回调函数。</li>
</ul>
<p>&nbsp; </p>
<hr>
<p><font size="5" color="orange">释放资源</font><br>退出渲染循环后，在程序结束之前，应该释放掉由GLFW分配的资源。使用<code>glfwTerminate</code>函数来完成：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp">    <span class="token comment" spellcheck="true">//结束CLFW，释放由GLFW分配的资源</span>
    <span class="token function">glfwTerminate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>这样会清理所有资源，并正确地退出程序。<br>&nbsp; </p>
<hr>
<p>到此为止的所有源码<a href="https://github.com/Popperelay/BlogCode/blob/master/LearnOpenGL2_CreateWindow/main.cpp" target="_blank" rel="external">在这里</a>。<br>编译运行后的结果是一个黑蓝绿色的窗口：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/14792896857.png" alt=""><br>按下esc键后，窗口关闭程序结束退出。<br>&nbsp;</p>
<hr>
<p>参考文献：<a href="https://learnopengl.com/" target="_blank" rel="external">LearnOpenGL</a></p>
]]></content>
      
        <categories>
            
            <category> OpenGL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OpenGL窗口 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[添加数学公式mathjax]]></title>
      <url>/2016/11/10/%E6%B7%BB%E5%8A%A0%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fmathjax/</url>
      <content type="html"><![CDATA[<p><font size="5" color="orange">配置方法</font><br><a id="more"></a></p>
<ol>
<li><p>在Hexo\themes\transparent\layout_partial路径下新建文件mathjax.ejs（transparent是我的主题名）。打开文件写入如下代码：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> mathjax config similar to math<span class="token punctuation">.</span>stackexchange <span class="token operator">--</span><span class="token operator">></span>

<span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">"text/x-mathjax-config"</span><span class="token operator">></span>
  MathJax<span class="token punctuation">.</span>Hub<span class="token punctuation">.</span><span class="token function">Config</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    tex2jax<span class="token punctuation">:</span> <span class="token punctuation">{</span>
      inlineMath<span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token punctuation">[</span><span class="token string">'$'</span><span class="token punctuation">,</span><span class="token string">'$'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">"\\("</span><span class="token punctuation">,</span><span class="token string">"\\)"</span><span class="token punctuation">]</span> <span class="token punctuation">]</span><span class="token punctuation">,</span>
      processEscapes<span class="token punctuation">:</span> <span class="token keyword">true</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>

<span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">"text/x-mathjax-config"</span><span class="token operator">></span>
    MathJax<span class="token punctuation">.</span>Hub<span class="token punctuation">.</span><span class="token function">Config</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      tex2jax<span class="token punctuation">:</span> <span class="token punctuation">{</span>
        skipTags<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'script'</span><span class="token punctuation">,</span> <span class="token string">'noscript'</span><span class="token punctuation">,</span> <span class="token string">'style'</span><span class="token punctuation">,</span> <span class="token string">'textarea'</span><span class="token punctuation">,</span> <span class="token string">'pre'</span><span class="token punctuation">,</span> <span class="token string">'code'</span><span class="token punctuation">]</span>
     <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>

<span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">"text/x-mathjax-config"</span><span class="token operator">></span>
    MathJax<span class="token punctuation">.</span>Hub<span class="token punctuation">.</span><span class="token function">Queue</span><span class="token punctuation">(</span><span class="token function">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> all <span class="token operator">=</span> MathJax<span class="token punctuation">.</span>Hub<span class="token punctuation">.</span><span class="token function">getAllJax</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> i<span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> all<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            all<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">SourceElement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>parentNode<span class="token punctuation">.</span>className <span class="token operator">+</span><span class="token operator">=</span> <span class="token string">' has-jax'</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>

<span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">"text/javascript"</span> src<span class="token operator">=</span><span class="token string">"http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"</span><span class="token operator">></span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>打开iHexo\themes\transparent\layout_partial目录下的after_footer.ejs文件，在末尾写入如下代码：<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> <span class="token keyword">partial</span><span class="token punctuation">(</span><span class="token string">'mathjax'</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">></span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li>新建一片md文章（<code>hexo new &quot;新文章&quot;</code>），写入如下代码：<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token preprocessor property">## 公式</span>
$$J\_\<span class="token function">alpha</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token operator">=</span>\sum _<span class="token punctuation">{</span>m<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token operator">^</span>\infty \frac<span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">^</span> m<span class="token punctuation">}</span><span class="token punctuation">{</span>m<span class="token operator">!</span> \<span class="token punctuation">,</span> \<span class="token function">Gamma</span> <span class="token punctuation">(</span>m <span class="token operator">+</span> \alpha <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">{</span>\<span class="token function">left</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\frac<span class="token punctuation">{</span>x<span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">}</span>\right<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">^</span><span class="token punctuation">{</span><span class="token number">2</span> m <span class="token operator">+</span> \alpha <span class="token punctuation">}</span>$$
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
部署完后，打开自己的网站查看公式是否成功显示。我的显示效果如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147757680727.png" alt=""></li>
</ol>
<ul>
<li>关于mathjax的更多介绍和语法参见<a href="http://popperelay.com/2016/10/27/Mathjax%E8%AF%AD%E6%B3%95/" target="_blank" rel="external">《Mathjax简介及其语法》</a>。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 博客配置 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> mathjax </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[基本光栅图形生成技术]]></title>
      <url>/2016/11/06/%E5%9F%BA%E6%9C%AC%E5%85%89%E6%A0%85%E5%9B%BE%E5%BD%A2%E7%94%9F%E4%BA%A7%E6%8A%80%E6%9C%AF/</url>
      <content type="html"><![CDATA[<p>先来回顾一下图形显示的过程。<br><a id="more"></a><br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">图形显示的过程</font><br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721606272.png" alt=""><br>可以看到，视频控制器是从帧缓存中读出数据不为0的单元进行显示。但是，正如图中所示，对于三角形，我们一般存储的都只是三个顶点的坐标，那么怎么根据这三个顶点的坐标得到对应的帧缓存数据呢？其实这就是图形的生成过程，从参数形式转换为点阵形式，便于光栅扫描生成相应的图形（参数形式和点阵形式可参考<a href="http://popperelay.com/2016/10/18/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E6%A6%82%E8%BF%B0/" target="_blank" rel="external">《图形学概述》</a>一文中的计算机图形表示方法）。</p>
<p><strong>由参数形式到点阵形式的转换就称为扫描转换</strong>。<br>&nbsp;</p>
<hr>
<p>从上面可以看到，图形信息是存储在帧缓存中的，其实光栅图形显示的缓存机制并不是图示的那样简单。下面来看一下：</p>
<p><font size="5" color="orange">光栅图形生成时的缓存机制</font></p>
<ul>
<li><p>单缓存：其实光栅图形显示时的帧缓存采用两种方式：单缓存、双缓存。<br>采用单缓存时，是在帧缓存填满之后，再由视频控制器驱动电子枪扫描形成一幅图形，接着才能再去生成下一幅图形的帧缓存（否则会覆盖破环图形数据）。这样帧缓存数据（图形点阵形式）的生成和在屏幕上扫描显示图形就是串行的。这样会降低图形的显示速率。</p>
</li>
<li><p>双缓存：现在大多采用的是双缓存，即有两个帧缓存，一幅图形在帧缓存2生成点阵数据后，再交给帧缓存1，视频控制器就可以根据帧缓存1来驱动电子枪扫描形成图形。<strong>与此同时</strong>，下一幅图形就可以在帧缓存2中再生成点阵数据。这样一来，不会覆盖破环要显示的图形数据（因为它已经转储到帧缓存1了），达到了帧缓存图形数据生成和在屏幕上扫描显示图形并行的效果。大大提高了图形显示的速率。</p>
</li>
</ul>
<p>如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721606347.png" alt=""><br>&nbsp; </p>
<hr>
<p>下面我们先来看个简单的：直线段是怎么通过扫描转换画出来的？</p>
<p><font size="5" color="orange">扫描转换线画图元直线段</font><br>我们知道，屏幕上其实是一个一个的像素，如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721606401.png" alt=""><br>想要让像素全部恰好落在直线上是很难的，我们只能去选择距离直线最近的像素点，然后用它们来近似地画出直线段（像素点是很小的，稍微不在直线上一点，肉眼是看不出来的，所以我们看到的还是一条“很直”的直线段）。</p>
<p>那么我们扫描转换画直线段的方法是啥呢（假设我们要画的直线段宽度是一个像素点，<strong>斜率在[0,1]之间（即0~45度）</strong>）？主要有三种方法：直线方程法、DDA、中点算法。都是为了一个一个地找出直线附近的像素点。</p>
<p><font size="4" color="red">扫描转换直线段：直线方程法</font></p>
<ul>
<li>基本思想：<br>直接根据直线的几何方程确定直线段路径上的像素位置。x坐标的值从左端点x遍历到右端点x，对应y坐标通过直线方程算出来。描点时如果发现y坐标不是整数值，需要取为离它最近的整数（如3.4取为3，3.5取为4，程序上用了一个小技巧实现：<code>(int)(y+0.5)</code>）。</li>
<li><p>具体代码如下：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token comment" spellcheck="true">//直线段的直线方程画法。直线方程式：y=mx+b</span>
<span class="token keyword">void</span> <span class="token function">Equation</span><span class="token punctuation">(</span><span class="token keyword">int</span> x0<span class="token punctuation">,</span><span class="token keyword">int</span> y0<span class="token punctuation">,</span><span class="token keyword">int</span> x1<span class="token punctuation">,</span><span class="token keyword">int</span> y1<span class="token punctuation">,</span><span class="token keyword">int</span> red<span class="token punctuation">,</span><span class="token keyword">int</span> green<span class="token punctuation">,</span><span class="token keyword">int</span> blue<span class="token punctuation">)</span><span class="token punctuation">{</span>    
  <span class="token function">glBegin</span><span class="token punctuation">(</span>GL_POINTS<span class="token punctuation">)</span><span class="token punctuation">;</span> 
  <span class="token function">glColor3ub</span><span class="token punctuation">(</span>red<span class="token punctuation">,</span>green<span class="token punctuation">,</span>blue<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment" spellcheck="true">//计算斜率m</span>
      <span class="token keyword">float</span> m<span class="token operator">=</span><span class="token keyword">float</span><span class="token punctuation">(</span>y1<span class="token operator">-</span>y0<span class="token punctuation">)</span><span class="token operator">/</span><span class="token punctuation">(</span>x1<span class="token operator">-</span>x0<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment" spellcheck="true">//计算b</span>
      <span class="token keyword">float</span> b<span class="token operator">=</span>y0<span class="token operator">-</span>m<span class="token operator">*</span>x0<span class="token punctuation">;</span>

      <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token operator">=</span>x0<span class="token punctuation">;</span>x<span class="token operator">&lt;=</span>x1<span class="token punctuation">;</span>x<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
          <span class="token keyword">int</span> y<span class="token operator">=</span>m<span class="token operator">*</span>x<span class="token operator">+</span>b<span class="token punctuation">;</span>
          <span class="token function">glVertex2d</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">(</span>y<span class="token operator">+</span><span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
  <span class="token function">glEnd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>用到的主要运算有：浮点运算、乘法、除法、取整、加法。</li>
</ul>
<p>有计算机基础的朋友应该知道，乘除法、浮点运算的开销是很大的。画个线就这么惨，有没有开销小一点的方法呢？请看下面。</p>
<p><font size="4" color="red">扫描转换直线段：数字差分分析法DDA（Digital Differential Analyzer）</font><br>DDA算法不再直接按照直线方程求像素点，而是打上了直线斜率的主意。在直线方程法中，是根据每个点的横坐标，按直线方程求出对应的纵坐标。这是把直线上的每个点作离散处理的，忽略了直线上点的纵坐标其实是有联系的：相邻点的纵坐标正好差一个斜率。所以纵坐标不用根据方程求解了，直接从上一个点的纵坐标加一个斜率值即可。具体描述如下：</p>
<ul>
<li>基本思想：<br><strong>纵坐标每次加一个斜率值</strong>。x坐标的值从左端点x遍历到右端点x，对应y坐标每次加一个斜率。描点时如果发现y坐标不是整数值，需要取为离它最近的整数（如3.4取为3，3.5取为4，程序上用了一个小技巧实现：<code>(int)(y+0.5)</code>）<br>【注】：只是在描点的时候描在最近的整数点上，即(int)(y+0.5)，而不能把y值变为最近的整数值，即y=int(y+0.5)是不对的。因为每次描点都应该是在其纵坐标的真实值上，进行取整描点；如果是y=int(y+0.5)这样把纵坐标作了近似处理，那么下一个点加斜率值之后，算出来的纵坐标就不是它的真实纵坐标了。</li>
<li><p>具体代码如下：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token comment" spellcheck="true">//直线段的DDA画法。直线方程式：y=mx+b</span>
<span class="token keyword">void</span> <span class="token function">LineDDA</span><span class="token punctuation">(</span><span class="token keyword">int</span> x0<span class="token punctuation">,</span><span class="token keyword">int</span> y0<span class="token punctuation">,</span><span class="token keyword">int</span> x1<span class="token punctuation">,</span><span class="token keyword">int</span> y1<span class="token punctuation">,</span><span class="token keyword">int</span> red<span class="token punctuation">,</span><span class="token keyword">int</span> green<span class="token punctuation">,</span><span class="token keyword">int</span> blue<span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token function">glBegin</span><span class="token punctuation">(</span>GL_POINTS<span class="token punctuation">)</span><span class="token punctuation">;</span> 
  <span class="token function">glColor3ub</span><span class="token punctuation">(</span>red<span class="token punctuation">,</span>green<span class="token punctuation">,</span>blue<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment" spellcheck="true">//计算斜率m</span>
      <span class="token keyword">float</span> m<span class="token operator">=</span><span class="token keyword">float</span><span class="token punctuation">(</span>y1<span class="token operator">-</span>y0<span class="token punctuation">)</span><span class="token operator">/</span><span class="token punctuation">(</span>x1<span class="token operator">-</span>x0<span class="token punctuation">)</span><span class="token punctuation">;</span>

      <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token operator">=</span>x0<span class="token punctuation">,</span>y<span class="token operator">=</span>y0<span class="token punctuation">;</span> x<span class="token operator">&lt;=</span>x1<span class="token punctuation">;</span> x<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
          <span class="token function">glVertex2d</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">(</span>y<span class="token operator">+</span><span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//四舍五入取整</span>
          y<span class="token operator">+</span><span class="token operator">=</span>m<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
  <span class="token function">glEnd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>用到的主要运算有：浮点运算、除法、加法、取整。</li>
</ul>
<p>看出来了吧，DDA比直线方程法少了乘法运算，加快了画线速度，但是还不够好，因为还存在浮点运算和取整运算。想要更好的算法，请看下面。</p>
<p><font size="4" color="red">扫描转换直线段：中点算法</font><br>在DDA中还是存在对浮点数的取整运算，因为要描出在y方向上离直线最近的像素点。能不能不通过取整运算，直接知道哪个像素点在y方向上离直线最近呢？画个图找点灵感（直线段斜率0~45度）：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147755946268.png" alt=""><br>图1和图2最左下角的黑点是当前已经确定的离直线最近的像素点。如果是图1这种情况，邻近的右上方（因为直线斜率0~45度）中点（图1的绿色点）在直线上方，则此时离直线最近的点应该是中点正下方的蓝色点；如果是图2这种情况，邻近的右上方中点（图2的绿色点）在直线下方，则此时离直线最近的点应该是中点正上方的蓝色点。</p>
<p>采用这种分类的方法（邻近的中点在直线上方还是下方），确实可以不再需要取整运算了，因为每种分类下应该取哪个整数点是确定的，通过简单的加法就能算出来（如果是图1的情况，则下一个应该描的像素点是x+1，y不变；如果是图2的情况，则下一个应该描的像素点是x+1，y+1）。问题又来了，怎么知道邻近的中点在直线上方还是下方呢？很简单，学过中学数学的朋友都知道，把中点坐标代入直线方程，如果算出来的结果<0，则在直线下方，如果结果>0，则在直线上方。</0，则在直线下方，如果结果></p>
<p>but，把中点坐标代入直线方程？这不又要算浮点数乘法了嘛~~~。回顾在直线方程法中，之所以会出现乘法，是因为把直线上的点作离散处理的，忽略了各个点之间的联系。这里也是这个原因，因为这些中点坐标也是有联系的。如果是图1的情况，则下一个中点应该是图1中的黄色点（即相比上一个中点x+1，y不变）；如果是图2的情况，则下一个中点应该是图2中的黄色点（即相比上一个中点x+1，y+1）。直线方程是ax+by+c=0，设把中点坐标代入直线方程得到的表达式是：$d=F(M)=ax+by+c$。如果是图1的情况，因为下一个中点相比上一个中点x+1，y不变，代入直线方程很容易得到，下一个中点$d_{i+1}$和上一个中点$d_i$的联系是：$d_{i+1}=d_i+a$；如果是图2的情况，因为下一个中点相比上一个中点x+1、y+1，代入直线方程很容易得到，下一个中点$d_{i+1}$和上一个中点$d_i$的联系是：$d_{i+1}=d_i+a+b$。而图1的情况其实就是$d_{i+1} \le 0$，图2的情况其实就是$d_{i+1}\gt 0$，所以得到如下方程组：<br>$$<br>d_{i+1}=<br>\begin{cases}<br>d_i+a,&amp; d_i \gt 0 \\<br>d_i+a+b,&amp; d_i \le 0 \\<br>\end{cases}<br>$$<br>那么最初的$d_0$是多少呢？看看$d_0$的表达式$d_0=F(M)=F(x_0+1,y_0+0.5)=F(x_0,y_0)+a+0.5b$，因为点$(x_0,y_0)$在直线上，所以$d_0=a+0.5b$。但是这里又出现了浮点数0.5，能不能把它转化成整数？其实我们一直关注的都是d是大于0还是小于0，2d和d的正负性是一样的，所以我们可以给上诉方程组等号两边同时乘以2，把所有的系数都变成整数：<br>$$<br>\begin{array}{l}<br>2d_0=2a+b \\<br>2d_{i+1}=<br>\begin{cases}<br>2d_i+2a,&amp; 2d_i \gt 0 \\<br>2d_i+2a+2b,&amp; 2d_i \le 0 \\<br>\end{cases}<br>\end{array}<br>$$<br>再把$2d_i$换成$x_i$，即$x_i=2d_i$。于是方程组变成如下：<br>$$<br>\begin{array}{l}<br>x_0=2a+b \\<br>x_{i+1}=<br>\begin{cases}<br>x_i+2a,&amp; x_i \gt 0 \\<br>x_i+2a+2b,&amp; x_i \le 0 \\<br>\end{cases}<br>\end{array}<br>$$<br>既然可以换成$x_i$，那么当然也可以换成$d_i$啊！所以方程组还可以是下面这样：<br>$$<br>\begin{array}{l}<br>d_0=2a+b \\<br>d_{i+1}=<br>\begin{cases}<br>d_i+2a,&amp; d_i \gt 0 \\<br>d_i+2a+2b,&amp; d_i \le 0 \\<br>\end{cases}<br>\end{array}<br>$$<br>而描点坐标的方程组也可以表示如下：<br>$$<br>\begin{array}{l}<br>x_{i+1}=x_i+1 \\<br>y_{i+1}=<br>\begin{cases}<br>y_i,&amp; d_i \gt 0 \\<br>y_i+1,&amp; d_i \le 0 \\<br>\end{cases}<br>\end{array}<br>$$<br>【注】：参数表示下直线段两端点坐标为($x_0,y_0$)，($x_1,y_1$)。则ax+by+c=0中的$a=y_0-y_1$、$b=x_1-x_0$。且方程组中诸如2a是可以写成a+a的。</p>
<p>从上述方程组中可以看出中点算法下的直线段扫描转换就只剩下整数加法运算了，效率得到了很大的提升。</p>
<p>总结一下：</p>
<ul>
<li>基本思想：中点算法中只存在整数加法运算。在分类情况下（下一格中点在直线上方还是下方），下一个像素点坐标可以直接通过上一个点坐标做加法得到；同时下一个中点代入方程值也可以在分类情况下，直接通过上一个中点代入方程值做加法得到。<br>【注】：上面只是研究了直线斜率0~45度的情况，其实其它斜率也是同样的研究方法。不再赘述，结论如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147783822848.png" alt=""><br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147783822974.png" alt=""></li>
<li><p>具体代码如下：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token comment" spellcheck="true">//直线段的中点算法。直线方程ax+by+c=0</span>
<span class="token keyword">void</span> <span class="token function">MidPointLine</span><span class="token punctuation">(</span><span class="token keyword">int</span> x0<span class="token punctuation">,</span><span class="token keyword">int</span> y0<span class="token punctuation">,</span><span class="token keyword">int</span> x1<span class="token punctuation">,</span><span class="token keyword">int</span> y1<span class="token punctuation">,</span><span class="token keyword">int</span> red<span class="token punctuation">,</span><span class="token keyword">int</span> green<span class="token punctuation">,</span><span class="token keyword">int</span> blue<span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token function">glBegin</span><span class="token punctuation">(</span>GL_POINTS<span class="token punctuation">)</span><span class="token punctuation">;</span> 
  <span class="token function">glColor3ub</span><span class="token punctuation">(</span>red<span class="token punctuation">,</span>green<span class="token punctuation">,</span>blue<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">//初始化线段方程中的a、b</span>
  <span class="token keyword">int</span> a<span class="token operator">=</span>y0<span class="token operator">-</span>y1<span class="token punctuation">;</span>
  <span class="token keyword">int</span> b<span class="token operator">=</span>x1<span class="token operator">-</span>x0<span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">//中点公式当中的d=d+dPlusPart1</span>
  <span class="token keyword">int</span> dPlusPart1<span class="token punctuation">;</span>
  <span class="token keyword">int</span> dPlusPart2<span class="token punctuation">;</span>

  <span class="token keyword">int</span> d<span class="token punctuation">;</span>
  <span class="token keyword">int</span> y<span class="token operator">=</span>y0<span class="token punctuation">;</span>
  <span class="token keyword">int</span> x<span class="token operator">=</span>x0<span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">//计算斜率</span>
  <span class="token keyword">float</span> k<span class="token operator">=</span><span class="token keyword">float</span><span class="token punctuation">(</span>y1<span class="token operator">-</span>y0<span class="token punctuation">)</span><span class="token operator">/</span><span class="token punctuation">(</span>x1<span class="token operator">-</span>x0<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">int</span> type<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>k<span class="token operator">>=</span><span class="token number">0</span><span class="token operator">&amp;&amp;</span>k<span class="token operator">&lt;=</span><span class="token number">1</span><span class="token punctuation">)</span>
      type<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>k<span class="token operator">></span><span class="token number">1</span><span class="token punctuation">)</span>
      type<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>k<span class="token operator">>=</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">&amp;&amp;</span>k<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span>
      type<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span>
  <span class="token keyword">else</span>
      type<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">;</span>
  <span class="token keyword">switch</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">//斜率大于0小于1 </span>
  <span class="token keyword">case</span> <span class="token number">1</span><span class="token punctuation">:</span>
      dPlusPart1<span class="token operator">=</span>a<span class="token operator">+</span>a<span class="token punctuation">;</span>
      dPlusPart2<span class="token operator">=</span>a<span class="token operator">+</span>a<span class="token operator">+</span>b<span class="token operator">+</span>b<span class="token punctuation">;</span>
      d<span class="token operator">=</span>a<span class="token operator">+</span>a<span class="token operator">+</span>b<span class="token punctuation">;</span>
      <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span>x<span class="token operator">&lt;</span>x1<span class="token punctuation">;</span>x<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
          <span class="token function">glVertex2d</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token keyword">if</span><span class="token punctuation">(</span>d<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
              y<span class="token operator">++</span><span class="token punctuation">;</span>
              d<span class="token operator">+</span><span class="token operator">=</span>dPlusPart2<span class="token punctuation">;</span>
          <span class="token punctuation">}</span>
          <span class="token keyword">else</span><span class="token punctuation">{</span>
              d<span class="token operator">+</span><span class="token operator">=</span>dPlusPart1<span class="token punctuation">;</span>
          <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">//斜率大于1</span>
  <span class="token keyword">case</span> <span class="token number">2</span><span class="token punctuation">:</span>
      d<span class="token operator">=</span>a<span class="token operator">+</span>b<span class="token operator">+</span>b<span class="token punctuation">;</span>
      dPlusPart1<span class="token operator">=</span>a<span class="token operator">+</span>a<span class="token operator">+</span>b<span class="token operator">+</span>b<span class="token punctuation">;</span>
      dPlusPart2<span class="token operator">=</span>b<span class="token operator">+</span>b<span class="token punctuation">;</span>
      <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span>y<span class="token operator">&lt;</span>y1<span class="token punctuation">;</span>y<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
          <span class="token function">glVertex2d</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token keyword">if</span><span class="token punctuation">(</span>d<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
              x<span class="token operator">++</span><span class="token punctuation">;</span>
              d<span class="token operator">+</span><span class="token operator">=</span>dPlusPart1<span class="token punctuation">;</span>
          <span class="token punctuation">}</span>
          <span class="token keyword">else</span><span class="token punctuation">{</span>
              d<span class="token operator">+</span><span class="token operator">=</span>dPlusPart2<span class="token punctuation">;</span>
          <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">//斜率大于-1小于0</span>
  <span class="token keyword">case</span> <span class="token number">3</span><span class="token punctuation">:</span>
      d<span class="token operator">=</span>a<span class="token operator">+</span>a<span class="token operator">-</span>b<span class="token punctuation">;</span>
      dPlusPart1<span class="token operator">=</span>a<span class="token operator">+</span>a<span class="token operator">-</span>b<span class="token operator">-</span>b<span class="token punctuation">;</span>
      dPlusPart2<span class="token operator">=</span>a<span class="token operator">+</span>a<span class="token punctuation">;</span>
      <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span>x<span class="token operator">&lt;</span>x1<span class="token punctuation">;</span>x<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
          <span class="token function">glVertex2d</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token keyword">if</span><span class="token punctuation">(</span>d<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
              y<span class="token operator">--</span><span class="token punctuation">;</span>
              d<span class="token operator">+</span><span class="token operator">=</span>dPlusPart1<span class="token punctuation">;</span>
          <span class="token punctuation">}</span>
          <span class="token keyword">else</span><span class="token punctuation">{</span>
              d<span class="token operator">+</span><span class="token operator">=</span>dPlusPart2<span class="token punctuation">;</span>
          <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">//斜率小于-1</span>
  <span class="token keyword">case</span> <span class="token number">4</span><span class="token punctuation">:</span>
      d<span class="token operator">=</span>a<span class="token operator">-</span>b<span class="token operator">-</span>b<span class="token punctuation">;</span>
      dPlusPart1<span class="token operator">=</span>a<span class="token operator">+</span>a<span class="token operator">-</span>b<span class="token operator">-</span>b<span class="token punctuation">;</span>
      dPlusPart2<span class="token operator">=</span><span class="token operator">-</span>b<span class="token operator">-</span>b<span class="token punctuation">;</span>
      <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span>x<span class="token operator">&lt;</span>x1<span class="token punctuation">;</span>x<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
          <span class="token function">glVertex2d</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token keyword">if</span><span class="token punctuation">(</span>d<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
              y<span class="token operator">--</span><span class="token punctuation">;</span>
              d<span class="token operator">+</span><span class="token operator">=</span>dPlusPart1<span class="token punctuation">;</span>
          <span class="token punctuation">}</span>
          <span class="token keyword">else</span><span class="token punctuation">{</span>
              d<span class="token operator">+</span><span class="token operator">=</span>dPlusPart2<span class="token punctuation">;</span>
          <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
  <span class="token keyword">default</span><span class="token punctuation">:</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">glEnd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>用到的主要运算有：整数加法。</li>
</ul>
<p>为了方便理解，举例如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147783439402.png" alt=""></p>
<hr>
<p>再来看个稍微复杂点的：圆弧是怎么通过扫描转换画出来的？</p>
<p><font size="5" color="orange">扫描转换线画图元圆弧</font><br>扫描转换圆弧也是把圆弧的参数方程转换为一个一个的像素点。不过对于圆这种东西，已经对称得不能再对称了，不利用它的对称性不浪费嘛~-~。利用圆的对称性，我们只需要画出1/8圆弧（一般研究逆时针45~90度的圆弧）就可以了，剩下的7/8都可以通过x对称或y对称得到。既然说到了对称，那肯定是要把圆心放在原点才好对称啊！那如果要画的圆心不再原点怎么办？平移到原点呗（平移会在《图形几何变换》一文中讲到）。<br>那如何扫描转换这段圆弧呢？主要有三种方法：方程法、中点算法、多边形逼近法。</p>
<p><font size="4" color="red">扫描转换圆弧：方程法</font><br>和直线扫描转换方程法原理一致，把(x,y)一个一个算出来。根据圆方程不同，大致分为以下两种方式：</p>
<ol>
<li><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147789990105.png" alt=""></li>
</ol>
<ul>
<li><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147789990162.png" alt=""></li>
</ul>
<p>这方法不说了，效率很着急！</p>
<p><font size="4" color="red">扫描转换圆弧：中点算法</font><br>和直线段扫描转换的中点算法原理一致。先画个图找点思路：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147791765983.png" alt=""><br>哪个点离圆弧最近呢？如果是图中黑色圆弧的情况，即中点M在圆弧外面，则M的竖直方向上，离圆弧最近的点是正下方的SE点；如果是图中红色圆弧的情况，即中点M在圆弧里面，则离圆弧最近的点是正上方的E点。而中点在圆弧外面其实就是中点代入圆方程值d大于0，中点在里面就是中点代入方程值d小于0。那么圆弧是不是和直线段一样，中点代入方程值d也可以由上一个值加一个常量得到呢？</p>
<p>答案是当然的。看上图（圆方程：$x^2+y^2-R^2=0$）如果是红色圆弧的情况，那么下一个中点坐标x+1，y不变，即d增量是$2x_M+1$，但是这里$x_M$是中点的坐标，应该把它换算成圆弧上点的坐标（因为中点算法的目的就是避开中点坐标，并没有求出中点坐标具体是多少，而只是关注中点代入方程的结果值。也就是说在整个过程里中点坐标$(x_M,y_M)$是多少不得而知，所以就得把它换算成$x_i$，即上一个圆弧上点的坐标，这个我们是知道的。具体可以参考程序进行理解），如果点P的坐标是(x,y)，那么$x_M=x+1$，所以d的增量是2x+3；如果是黑色圆弧的情况，那么下一个中点坐标x+1，y-1，即d增量是$2x_M-2y_M+2$，同样的道理，$x_M=x+1，y_M=y-0.5$，所以d的增量是2x-2y+5。那么d的初始值$d_0$是多少呢？因为$d_0=(x_0+1)^2+(y_0-0.5)^2-R^2$且点($x_0,y_0$)=(0,R)，所以$d_0=1.25-R$。整理一下，有如下方程式：<br>$$<br>\begin{array}{l}<br>x_{i+1}=x_i+1 \\<br>y_{i+1}=<br>\begin{cases}<br>y_i,&amp; d \le 0 \\<br>y_i-1,&amp; d \gt 0 \\<br>\end{cases} \\<br>d_{i+1}=<br>\begin{cases}<br>d_i+2x_i+3,&amp; d_i \le 0 \\<br>d_i+2x_i-2y_i+5,&amp; d_i \gt 0 \\<br>\end{cases} \\<br>d_0=1.25-R \\<br>\end{array}<br>$$<br>但是很可恨啊，上面存在1.25这个浮点数，所以仿照前文直线段的中点算法中对浮点数的处理，可以把上诉有关d的方程都在等号两端乘以4，转换为整数。再令$a_i=4d_i$，再令$d_i=a_i$，得到如下方程组：<br>$$<br>\begin{array}{l}<br>x_{i+1}=x_i+1 \\<br>y_{i+1}=<br>\begin{cases}<br>y_i,&amp; d \le 0 \\<br>y_i-1,&amp; d \gt 0 \\<br>\end{cases} \\<br>d_{i+1}=<br>\begin{cases}<br>d_i+8x_i+12,&amp; d_i \le 0 \\<br>d_i+8x_i-8y_i+20,&amp; d_i \gt 0 \\<br>\end{cases} \\<br>d_0=5-4R \\<br>\end{array}<br>$$<br>but，上面又出现了$8x_i$这些乘法，不过由于这是像素点的坐标，相邻点之间具有很明显的常量联系，所以可以仿照上面的原理，把它们转化为加法。令$E_i=8x_i+12，SE_i=8x_i-8y_i+20$，与$d_i$同样的推理过程（不再赘述），会得到如下方程组：<br>$$<br>\begin{array}{l}<br>x_{i+1}=x_i+1 \\<br>y_{i+1}=<br>\begin{cases}<br>y_i,&amp; d \le 0 \\<br>y_i-1,&amp; d \gt 0 \\<br>\end{cases} \\<br>d_{i+1}=<br>\begin{cases}<br>d_i+E_i,&amp; d_i \le 0 \\<br>d_i+SE_i,&amp; d_i \gt 0 \\<br>\end{cases} \\<br>E_i=8x_i+12 \\<br>SE_i=8x_i-8y_i+20 \\<br>E_{i+1}=E_i+8 \\<br>SE_{i+1}=<br>\begin{cases}<br>SE_i+8,&amp; d_i \le 0 \\<br>SE_i+16,&amp; d_i \gt 0 \\<br>\end{cases} \\<br>d_0=5-4R \\<br>E_0=8x_0+12=12 \\<br>SE_0=8x_0-8y_0+20=20-8R \\<br>\end{array}<br>$$</p>
<p>总结一下：</p>
<ul>
<li>基本思想：圆弧扫描转换的中点算法也只存在整数加法运算。在分类情况下（下一格中点在圆弧里面还是外面），下一个像素点坐标可以直接通过上一个点坐标做加法得到；同时下一个中点代入方程值也可以在分类情况下，直接通过上一个中点代入方程值做加法得到。<br>【注】：上面只是研究了逆时针45度到90度的圆弧，其他圆弧可以通过坐标对称得到。</li>
<li>具体代码如下：<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token comment" spellcheck="true">//圆弧的中点算法</span>
<span class="token keyword">void</span> <span class="token function">MidPointCircle</span><span class="token punctuation">(</span><span class="token keyword">int</span> R<span class="token punctuation">,</span><span class="token keyword">int</span> red<span class="token punctuation">,</span><span class="token keyword">int</span> green<span class="token punctuation">,</span><span class="token keyword">int</span> blue<span class="token punctuation">,</span><span class="token keyword">int</span> centre_x<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token keyword">int</span> centre_y<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token function">glBegin</span><span class="token punctuation">(</span>GL_POINTS<span class="token punctuation">)</span><span class="token punctuation">;</span> 
  <span class="token function">glColor3f</span><span class="token punctuation">(</span>red<span class="token punctuation">,</span>green<span class="token punctuation">,</span>blue<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">//初始化中点算法的d,即d</span>
  <span class="token keyword">int</span> d<span class="token operator">=</span><span class="token number">5</span><span class="token operator">-</span><span class="token number">4</span><span class="token operator">*</span>R<span class="token punctuation">;</span>
  <span class="token keyword">int</span> x<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> y<span class="token operator">=</span>R<span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">//初始化E和SE</span>
  <span class="token keyword">int</span> E<span class="token operator">=</span><span class="token number">12</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> SE<span class="token operator">=</span><span class="token number">20</span><span class="token operator">-</span><span class="token number">8</span><span class="token operator">*</span>R<span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">//定义八分之一圆弧x的最大值</span>
  <span class="token keyword">float</span> xMax<span class="token operator">=</span>R<span class="token operator">*</span><span class="token number">1.414</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span>x<span class="token operator">&lt;=</span>xMax<span class="token punctuation">;</span>x<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token function">glVertex2d</span><span class="token punctuation">(</span>x<span class="token operator">+</span>centre_x<span class="token punctuation">,</span>y<span class="token operator">+</span>centre_x<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">glVertex2d</span><span class="token punctuation">(</span><span class="token operator">-</span>x<span class="token operator">+</span>centre_x<span class="token punctuation">,</span>y<span class="token operator">+</span>centre_x<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">glVertex2d</span><span class="token punctuation">(</span>x<span class="token operator">+</span>centre_x<span class="token punctuation">,</span><span class="token operator">-</span>y<span class="token operator">+</span>centre_x<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">glVertex2d</span><span class="token punctuation">(</span><span class="token operator">-</span>x<span class="token operator">+</span>centre_x<span class="token punctuation">,</span><span class="token operator">-</span>y<span class="token operator">+</span>centre_x<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">glVertex2d</span><span class="token punctuation">(</span>y<span class="token operator">+</span>centre_x<span class="token punctuation">,</span>x<span class="token operator">+</span>centre_x<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">glVertex2d</span><span class="token punctuation">(</span><span class="token operator">-</span>y<span class="token operator">+</span>centre_x<span class="token punctuation">,</span>x<span class="token operator">+</span>centre_x<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">glVertex2d</span><span class="token punctuation">(</span>y<span class="token operator">+</span>centre_x<span class="token punctuation">,</span><span class="token operator">-</span>x<span class="token operator">+</span>centre_x<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">glVertex2d</span><span class="token punctuation">(</span><span class="token operator">-</span>y<span class="token operator">+</span>centre_x<span class="token punctuation">,</span><span class="token operator">-</span>x<span class="token operator">+</span>centre_x<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>d<span class="token operator">&lt;=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
          d<span class="token operator">+</span><span class="token operator">=</span>E<span class="token punctuation">;</span>
          E<span class="token operator">+</span><span class="token operator">=</span><span class="token number">8</span><span class="token punctuation">;</span>
          SE<span class="token operator">+</span><span class="token operator">=</span><span class="token number">8</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">else</span><span class="token punctuation">{</span>
          y<span class="token operator">--</span><span class="token punctuation">;</span>
          d<span class="token operator">+</span><span class="token operator">=</span>SE<span class="token punctuation">;</span>
          E<span class="token operator">+</span><span class="token operator">=</span><span class="token number">8</span><span class="token punctuation">;</span>
          SE<span class="token operator">+</span><span class="token operator">=</span><span class="token number">16</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token function">glEnd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<p><font size="4" color="red">扫描转换圆弧：多边形逼近法</font><br>平时生活学习中，我们都知道正多边形边数越多，就会越像一个圆。多边形逼近法就是源自于此：根据已知的圆半径（圆心在原点），求出多边形的各个顶点，再依次连起来就像一个圆了。</p>
<p>那么根据什么规则来求多边形顶点呢？主要有两种，一种是把多边形作为圆的内接正多边形，另一种是把多边形作为与圆等面积且圆心重合的正多边形。如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147792454828.png" alt=""></p>
<ul>
<li><p>内接正多边形逼近法：<br>点$P_i$的坐标如下：<br>$$<br>\begin{array}{l}<br>x_i=R \cos \theta_i \\<br>y_i=R \sin \theta_i \\<br>\end{array}<br>$$<br>点$P_{i+1}$的坐标如下：<br>$$<br>\begin{array}{l}<br>x_{i+1}=R \cos (\theta_i+\alpha) \\<br>y_{i+1}=R \sin (\theta_i+\alpha) \\<br>\end{array}<br>$$<br>用三角变化可以得到如下矩阵方程式：<br>$$<br>\begin{array}{c c c c}<br>\begin{pmatrix}<br>x_{i+1} \\<br>y_{i+1} \\<br>\end{pmatrix}<br>&amp;<br>=<br>&amp;<br>\begin{pmatrix}<br>\cos \alpha &amp; -\sin \alpha \\<br>\sin \alpha &amp; \cos \alpha \\<br>\end{pmatrix}<br>&amp;<br>\begin{pmatrix}<br>x_i \\<br>y_i \\<br>\end{pmatrix}<br>\end{array}<br>$$<br>其中，$\alpha$是正多边形对应的圆心角，是一个常数（为什么是常数后文会讲到）。所以$\sin \alpha，\cos \alpha$只需要在开始时计算一次，之后的每一个顶点坐标都只需要4次乘法即可。</p>
<p>那么圆心角到底是多少呢？也就是正多边形多少条边合适？当然是边数越多越好，越像圆。但是计算机计算能力有限，不可能边数搞得特别特别大，而且在实际问题中经常也不需要那么圆，有时候可能稍微像圆一点就可以，有时候可能需要再圆一点。到底要多圆就根据实际问题能够接受的多大的误差而定了。我们经常用最大逼近误差d来表示这个能接受的最大误差。</p>
<p>最大逼近误差d是什么玩意？词穷了，我也不知道咋描述能简单通俗易懂，所以直接看图吧！<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147798894595.png" alt=""><br>d就是边中点到另一点（其半径与圆弧交点）的距离。<br>也就是说这个d通常是已知的，那么圆心角就能算出来了（计算过程不再赘述了~），即$\alpha=2\arccos(R-d)/R$。<br>总结一下：</p>
<ul>
<li>基本思想：根据最大逼近误差d求出圆心角，再由圆心角和半径求出多边形各顶点的坐标，把各顶点依次连接起来（使用OpenGl画多边形的方法），就成了一个近似圆。</li>
<li>具体代码如下：</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token comment" spellcheck="true">//圆弧的正内接多边形逼近法</span>
<span class="token keyword">void</span> <span class="token function">CircleIn</span><span class="token punctuation">(</span><span class="token keyword">float</span> MaxError<span class="token punctuation">,</span><span class="token keyword">float</span> R<span class="token punctuation">,</span><span class="token keyword">int</span> red<span class="token punctuation">,</span><span class="token keyword">int</span> green<span class="token punctuation">,</span><span class="token keyword">int</span> blue<span class="token punctuation">,</span><span class="token keyword">int</span> centre_x<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token keyword">int</span> centre_y<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">glBegin</span><span class="token punctuation">(</span>GL_LINE_LOOP<span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token function">glColor3f</span><span class="token punctuation">(</span>red<span class="token punctuation">,</span>green<span class="token punctuation">,</span>blue<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//初始化正内接多边形对应圆心角</span>
    <span class="token keyword">float</span> alpha<span class="token operator">=</span><span class="token number">2</span><span class="token operator">*</span><span class="token function">acos</span><span class="token punctuation">(</span><span class="token punctuation">(</span>R<span class="token operator">-</span>MaxError<span class="token punctuation">)</span><span class="token operator">/</span>R<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//初始化边数，即顶点个数</span>
    <span class="token keyword">int</span> n<span class="token operator">=</span><span class="token number">2</span><span class="token operator">*</span><span class="token number">3.14</span><span class="token operator">/</span>alpha<span class="token punctuation">;</span>

    <span class="token keyword">float</span> cosAlpha<span class="token operator">=</span><span class="token function">cos</span><span class="token punctuation">(</span>alpha<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">float</span> sinAlpha<span class="token operator">=</span><span class="token function">sin</span><span class="token punctuation">(</span>alpha<span class="token punctuation">)</span><span class="token punctuation">;</span>    
    <span class="token keyword">float</span> x<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">float</span> y<span class="token operator">=</span>R<span class="token punctuation">;</span>
    <span class="token keyword">float</span> xTemp<span class="token punctuation">;</span>
    <span class="token keyword">float</span> yTemp<span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">glVertex2d</span><span class="token punctuation">(</span>x<span class="token operator">+</span>centre_x<span class="token punctuation">,</span>y<span class="token operator">+</span>centre_y<span class="token punctuation">)</span><span class="token punctuation">;</span>
        xTemp<span class="token operator">=</span>x<span class="token punctuation">;</span>
        yTemp<span class="token operator">=</span>y<span class="token punctuation">;</span>
        x<span class="token operator">=</span>cosAlpha<span class="token operator">*</span>xTemp<span class="token operator">-</span>sinAlpha<span class="token operator">*</span>yTemp<span class="token punctuation">;</span>
        y<span class="token operator">=</span>sinAlpha<span class="token operator">*</span>xTemp<span class="token operator">+</span>cosAlpha<span class="token operator">*</span>yTemp<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">glEnd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><p>等面积正多边形逼近法：<br>在圆内接正多边形逼近法中，正多边形是内接于圆的，总感觉上面画出来的正多边形比圆要小，毕竟是内接嘛~那么有没有和圆差不多大的？减少一点这种差距。那干脆找一个面积和圆一样大，且圆心重合的正多边形把，这就是等面积正多边形逼近法（参见前面的“等面积多边形”一图）。</p>
<p>由于圆面积和正多边形面积相等，所以相同圆心角对应的扇形（圆的一部分）和三角形（正多边形的一部分）面积应该相等，如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147808731637.png" alt=""><br>图中的扇形ODCE和三角形$OP_iP_{i+1}$面积应该相等，再结合给定（在圆的参数方程中给定的）的圆半径R和最大逼近误差d，可以算出圆心角$\alpha$和正多边形半径$OP_i$的长度。知道了正多边形的圆心角和半径长度，自然就能算出正多边形个顶点的坐标了（求法和内接正多边形一致）。</p>
<p>基本原理和具体代码和内接正多边形逼近法类似，不再赘述了。</p>
</li>
</ul>
<p>【注】：可以看出，中点算法是基本线画图元的高效扫面转换算法，因为算法中只用到了整数加法运算，但中点算法是有条件的：所要画的图元必须具有正负划分性，像在直线上方就是正，下方就是负；在圆外面就是正，里面就是负。像Bezier曲线这种可以自交没有正负划分性的曲线，是无法用中点算法画出来的。<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147808824303.png" alt=""><br>&nbsp;</p>
<hr>
<p>上面研究的都是直线、圆弧这些线画图元，那么那些填充图元（包括边界和其内部的图形）又是怎么画出来的呢？主要有两种方法：扫描转换（参数→点阵）、填充（点阵→点阵）。先来看个最简单的：扫描转换矩形。<br>&nbsp;</p>
<hr>
<p><font size="5" color="orange">扫描转换填充图元矩形</font><br>既然是扫描转换，那填充图元——矩形的参数形式提供了哪些参数呢？有两个：左下角坐标、右上角坐标。这足以定义一个填充的矩形了。</p>
<p>扫描转换时，只需要从左下角开始向右（x增大）、向上（y增大）一个一个描像素点，知道右上脚为止。代码就是x和y增大的两重循环，这里不再赘述了。<br>&nbsp;</p>
<hr>
<p>矩形可以这么画，但是其它多边形呢？当然要另寻他法了~~~那矩形也是多边形，为何不归为多边形画法，而要单独分出来呢？这是因为矩形的画法相当简单，没有必要去用其他多边形的那些复杂画法，而且矩形在计算机中相当常见，所以需要把这简单的单独分出来，不能把简单的搞复杂了~-~。下面来看看除了矩形以外的其他多边形是怎么画出来的。</p>
<p><font size="5" color="orange">扫描转换填充图元多边形</font><br>扫描转换多边形其实就是把多边形的顶点表示形式转换成点阵表示形式。在介绍画法之前，先来看看几个问题：</p>
<ul>
<li>共享边界如何处理？<br>如下图：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147809048081.png" alt=""><br>那个共享边界应该属于哪个矩形？介于此，对共享边界有个处理原则：左闭右开、下闭上开。所以上图那个共享边界应该是属于黑色矩形。</li>
<li><p>在扫描转换中，经常会提到多边形的凹凸性。所以做个解释（只考虑简单多边形，即不会自交）：</p>
<ul>
<li>凸多边形：所有内角小于180度。</li>
<li>凹多边形：存在内角大于180度。</li>
</ul>
<p><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147809147096.png" alt=""><br>那么如何区分多边形的凹凸性呢？主要有两种方法：</p>
<ul>
<li>顶点同侧异侧法：对于多边形的每条边，所有顶点都在这条边所在直线的同侧，则是凸多边形；如果存在异侧的，就是凹多边形。</li>
<li>向量叉积法：沿顺时针或逆时针，把每条边看作一个向量，如果所有相邻边向量叉积同号，则是凸多边形，否则是凹多边形。</li>
</ul>
</li>
</ul>
<p>说了这么多，到底怎么扫描转换多边形呢？主要有三种方法： 逐点判断法、扫描线算法、种子填充法。</p>
<p><font size="4" color="red">扫描转换填充多边形：逐点判断法</font><br>逐点判断法就是在绘图窗口内，一个一个地去判断像素是否位于多边形内，若是，则用指定颜色绘制该像素。</p>
<p>那么如何判断一个像素是否位于多边形内呢？第一感觉可能是用数学计算来判断，好吧，那先来一个粗暴的。这里主要介绍射线法。来画个图找点灵感：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147809441075.png" alt=""><br>从上图会发现一个规律：从像素点作一条水平向右的射线，如果与多边形的交点个数是偶数，则该像素点位于多边形外边，如果交点个数是奇数，则该像素点位于多边形里面。</p>
<p>是吗？反例来了~如下图：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147809530882.png" alt=""><br>~居然有出格的~那给个规定：</p>
<ol>
<li>如果射线与边重合，则视为无数个交点，这时直接判断像素点是否在边上。</li>
<li>如果交点为顶点，以此顶点为端点的两条边在射线同侧，则视为两个交点；如果在射线异侧，则视为1个交点。</li>
</ol>
<p>这样应该是没有反例了~根据上诉规律，即可判断一个像素点是否在多边形内。However，交点怎么求？用射线去和多边形的所有边通过方程求交点~不言而喻，射线法的效率低、花费大。</p>
<p>射线法为何效率低？主要是它忽略了多边形内部点的连续性，把它们离散处理了。当一个点在多边形内部时，通常它周围的点也会在多边形内部，这就是这里点的连续性。</p>
<p><font size="4" color="red">扫描转换填充多边形：扫描线算法</font><br>同样，画个图找点灵感：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147817739477.png" alt=""><br>图中的水平虚线就是一条一条的扫描线（一般扫描线都是平行于x轴的，图中每条扫面线之间画的比较远，而实际扫描时扫描线都是以像素为单位，也就是y方向上每个像素都会有一条水平扫描线穿过），我们需要画出图中的多边形。</p>
<p>一条一条来看吧~。y=1的扫描线与多边形交于两点（水平线不参与交点计算）：P1(5，1)、P2(7，1)；y=2的扫描线也与多边形交于两点：(4，2)、(8.25，2)；……而且多边形在这些扫描线上要填充的像素点，也恰好是在扫面与多边形的两个交点之间。比如在y=1时，就把交点P1、P2之间的所有像素点描出来；在y=2时，就把交点(4，2)、(8.25，2)之间的所有像素点描出来…….直到y=7的扫描线时，我们应该已经画出了如下填充图形（不要纠结扫描线宽度，当做扫描线宽度为一个像素来理解就可以了）：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147817896328.png" alt=""><br>但是当y=7时，扫描线与多边形有3个交点，当y=7.5时，扫描线又与多边形有4个交点（扫描线当然不会是小数，不过整数扫描线与多边形有4个交点的情况确实存在，只是这幅图找不出来，所以用7.5冒充了~-~），而且应该填充的像素点在头两个交点之间和后两个交点之间。结合之前只有两个交点的情况，好像有一个规律：把交点两两配对后，要填充的像素就在每一对交点之间。但是y=7却只有3个交点，无法两两配对，回想前面射线法是把顶点P5当做两个交点来看的，正好抄过来用一下，规定：两条边都在扫描线同一侧的顶点看作两个交点。这样y=7也可以两两配对了，扫描线一直上升到y=8甚至y=11时都可以实现交点两两配对。</p>
<p>扫描线从y=1上升到y=11，把配对的交点之间的像素点描上颜色，就画出了这个不规则的填充多边形。这就是扫描线转换多边形。</p>
<p>but同样的，我们要来看看它的效率怎么样。在两个交点之间填充像素点好说，因为扫描线是水平的，两交点的y值肯定相等，只需要让x坐标从左交点一直增大到右交点即可。但是交点怎么办？扫描线虽然是水平的，都是x=？的水平直线，那把它代入多边形边的直线方程求交？显然这又增加了一堆乘除法运算，效率很低。那有没有效率好点的求交点算法？恩~用方程求点，前面我们是不是看到过，扫描转换直线的第一个方法就是方程法，因为每个点都有一堆计算，所以放弃了方程法，效率太低，改为研究DDA算法了。那么这里能不能借用DDA的思想？其实原理是一致的，之前求扫描线与多边形的交点，忽略了扫描线上升时，多条扫描线与同一条边的交点之间其实是有联系的（因为在同一条直线上嘛）：同一条边上相邻交点的y值差1，x值正好差一个斜率的倒数。比如y=1时与边e0的交点P1（5,1）和y=2时与边e0的交点（4,2），第二个交点比第一个交点y+1（因为扫描线上升了一个像素），而第二个交点比第一个交点x-1（因为边e0的斜率为-1）；再比如y=1时与边e2的交点P2（7,1）和y=2时与边e2的交点（8.25,2），第二个交点比第一个交点y+1（因为扫描线上升了一个像素），而第二个交点比第一个交点x+1.25（因为边e2的斜率倒数是1.25）。</p>
<p>这样一来，我们只需要知道多边形中每条边的斜率倒数和其下端点x坐标就行，因为在同一条边上的其他交点都可以通过该边的下端点x坐标和斜率倒数做加法求出来。比如知道了边e0的和边e2的斜率倒数和其下端点坐标P1、P2，那后面边e0在y=2、3、4时的交点都可以求出来了，边e2在y=2、3、4、5时的交点也可以求出来了。但是到了y=4时，边e0变成了边e6；到y=5时，边e2也变成了边e3；到y=7时，又增加了边e5和边e4；到y=8时，边e5、e6都没了；到y=11时，仅剩的边e4和e3也没了，一条边也没了。在这过程中，有些边会加进来，有些边会删除，那什么时候加边？什么时候删除边？在回顾一下上面的过程，我们就会发现当扫描线上升到边的下端点时（扫描线y值达到了边下端点的y值），该边就会加进来配对；当扫描线上升到边的上端点时（扫描线y值达到了边上端点的y值），该边就会被删除，退出配对。所以除了边的斜率和其下端点x坐标，还需要下端点的y坐标、上端点的y坐标。</p>
<p>有这么多边，自然在数据结构中应该设置一个容器来存储这些边（包括边的下端点x坐标、上端点y坐标和斜率倒数，这些是已知的参数，由用户输入），那用什么容器来存储呢？第一反应当然是用数组去存储所有边，当扫描线y=1时，去遍历这个边数组，看哪条边下端点y=1就把该边加入配对队伍里，看哪条边上端点y=1就把该边从配对队伍里剔除。这个配对队伍和存储所有边的数组是同一个容器吗？当然不是~否则剔除之后到哪去遍历所有边，所以还需要另一个容器来存储那些需要去配对的边（给需要去配对的起个名字吧，叫：活性边）。那应该用什么容器来存储这些活性边呢？由于需要频繁插入、删除，而且扫描过程中，活性边容器中有多少边是不确定的，可能一会多一会少，用固定大小的数组无疑很浪费空间，而且不易于插入删除，鉴于此，存储活性边的容器选链表比较合适（可参考<a href="http://popperelay.com/2016/08/24/%E9%93%BE%E8%A1%A8/" target="_blank" rel="external">《数据结构与算法之链表》</a>）一文。</p>
<p>那链表中的活性边如何配对呢？看看上图，比如在y=7.5的扫描线，此时的活性边是e6、e5、e4、e3，应该是e6和e5配对、e4和e3配对，放到图中刚好是从左至右两两配对。从左至右？这不就是x从小到大嘛！e6在e5左边，可见应该是下端点x小的在左边，即活性边按照下端点x坐标从小到大排序；but边e5和e4下端点x相等，e5在e4左边，可见当下端点x相等时，按照上端点x从小到大排序。</p>
<p>故活性边链表中的边，应该是按照下端点x值由小到大排序的，如果下端点x值相等再按照上端点x值由小到大排序（边表中每条链表里的边都是按上端点x值由小到大排序的，所以从边表里依次插入到活性边表后，下端点x值相等的边肯定是按照上端点x值由小到大排序的，所以边结构体中也就不需要上端点x坐标这个数据成员了，可参考代码进行理解）。不管怎么说，这些活性边需要按x值排序，那么采用哪种排序算法呢？因为多边形的活性边数据量不是很大，没有必要采用那些改进排序，用简单排序就好；而这些活性边应该是随着扫描线上升，动态地从链表中加入或删除，并不是一开始就全部在链表中的，所以采用冒泡排序和选择排序都不大适合，而且在简单排序中插入排序效率是最高的，所以这里对活性边的排序应该选择插入排序（关于排序可参考<a href="http://popperelay.com/2016/09/03/%E7%AE%80%E5%8D%95%E6%8E%92%E5%BA%8F/" target="_blank" rel="external">《数据结构与算法之简单排序》</a>和<a href="http://popperelay.com/2016/09/03/%E6%94%B9%E8%BF%9B%E6%8E%92%E5%BA%8F/" target="_blank" rel="external">《数据结构与算法之改进排序》</a>）。<br>活性边表AEL（Active Edge List）中的结点存储着边的相关信息，即边的斜率（用于求同一条边上下一个交点坐标）、当前扫描线与边的交点的x坐标（初始值为其下端点x坐标，由边表复制而来，用于求同一条边上下一个交点坐标）、上端点y坐标（用于从活性边表中删除不再参与配对的边）。活性边表结构如下图：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147823109648.png" alt=""><br>结点中的4个数据成员依次是：上端点y坐标、<strong>当前交点</strong>的x坐标、斜率倒数、指向下一个结点的指针</p>
<p>存储活性边的容器选定为采用插入排序的链表了，再回过头来看看最初存储所有边的容器数组，难道扫描线每上升一次都要去遍历整个数组，找出哪些边该插入哪些边该删除~~~看图中，y=7时，应该把哪些边加入活性边表中？很显然是e5和e4，这是我们根据规律肉眼看出来的。那有没有办法当y=7时，计算机也能直接知道应该加入哪些边？把y=7时应该加入的边事先列出来存储在某一个地方不就好了么~-~就好像今天是星期天，我们应该上哪些课？通常我们是直接去查课表（课表中只有星期几和这天该上的课，不包括诸如8点到10点这些具体时间），因为课表里存储着星期几和该上哪些课。我们这里的y=？（y=几）也就相当于星期几，我们需要另一个类似课表的容器去存储y=？时应该加入活性边表的边。想想如果你要存储上面的课表，你会选用哪种容器。第一反应肯定还是最简单的数组，用数组的下标表示星期几，数组的内容表示当天应该上哪些课。但是每天上的课都不是一样多的啊，数组的内容应该取为多大才好？下标为0的数组元素可以存储2个课程结构体（因为可能想要知道课名、上课老师…等等相关内容，课程就对于多边形的边，需要知道边的斜率、下端点x坐标、上端点y坐标等），还是5个课程结构体，还是其他个数的课程结构体？这显然是不确定的，如果把数组元素内容大小设为最大长度（如一天最多上10节课），这无疑会浪费很多存储空间（可能某一天要上10节课，但另一天一节课也不上，不就浪费了10个存储空间~），所以定容的数组是不适合的，每个数组元素应该采用不定长的链表。注意是每个数组元素，就是说一周有7天是固定的，可以用大小为7的数组来表示这7天，但是每一个数组元素（每一天）能装下的课程数量是不定的，需要用链表来表示。也就是说每一个数组元素应该装一个不定长的链表，但是数组元素的容量是固定的，比如int a[7]，每个数组元素只能存放4个字节，总不能把一整条链表都装到数组元素里去吧！但是既然是链表，我们可以在数组元素里装一个指向链表第一个结点的指针啊，指针的大小是固定的（常见的是4个字节）。</p>
<p>这样，就解决了存储所有边应该用哪种容器：用一个大小等于扫描线条数（其实大小这里可以改进，毕竟不是每一条扫描线都有边会加入到活性边表中去，只存储那些需要加边的扫描线也是可以的）的数组表示扫描线的y=几，每个数组元素里存储着一个指向链表的指针；这个链表中存储着y=？时应该加入活性边表中的边。如下图所示（ET表示边表（Edge Table），即我们这个容器的名字）：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147823109698.png" alt=""><br>如此，当扫描线上升到某个y值时，就可以直接从边表ET中读出需要加入活性边表AET的边。</p>
<p>边表中链表结点是什么样呢？链表中存储着应该加入活性边表的边，也就是这些链表中的每一个结点就表示了多边形的一个边，所以这些结点应该存储着边的相关信息，即边的斜率（用于求同一条边上下一个交点坐标）、其下端点x坐标（用于求同一条边上下一个交点坐标）、上端点y坐标（用于从），而且每条链表中存储的边（即结点）对应到图中都应该是从左到右排序的，即每条链表中的结点是按照边上端点x值由小到大排序的（这种顺序是在建立边表时人为就排好的，一般不需要再使用排序算法让计算机去排序）。因为边表中每一条链表中存储的边，都是按上端点x有序排列的，所以依次复制插入到活性边表后，下端点相同的边也就按照上端点x值由小到大排序好了。省去了到活性边表中按照上端点x再排一次，节省了很多花费。</p>
<p>弄清了边表中结点的数据成员和链接次序后，对图中多边形建立的完整边表如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147824486021.png" alt=""></p>
<ul>
<li>回顾多边形扫描过程结合需要建立的数据结构，扫描线算法总结如下：<ol>
<li>建立边表ET</li>
<li>将扫描线纵坐标y的初始值置为ET中非空元素的最小序号，如图中，y=1</li>
<li>置活性边表AEL为空（初始化活性边表头结点）</li>
<li>执行下列步骤直到ET和AET都为空<br>4.1. 如果ET中的第y类非空，则将其中的所有边取出并复制插入到AEL中<br>4.2. 如果有新边要插入AEL，则对AEL各边进行插入排序<br>4.3. 对AEL中的边两两配对（第1个和第2个为一对，第3个和第4个为一对……），将每队边中x坐标按规则取整，获得有效的填充区段，再填充<br>4.4. 将当前扫描线纵坐标y值加1<br>4.5. 将AEL中满足y=ymax（扫描线达到了某边上端点）的边删去（每条边是被看作下闭上开的，即下端点属于该边，但上端点不属于该边）<br>4.6. 对AEL中剩下的每条边的x加斜率倒数delta，即x=x+delta</li>
</ol>
</li>
</ul>
<p>【注】：由于边的斜率倒数可能是小数，如e2的斜率倒数是1.25，所以每次算出来的交点是一个小数，但是描点的时候只能是整数值，所以4.3中，描点时需要对配对的交点的x坐标取整（这样也能在填充时减少浮点数的出现），取整规则是：让取整后的交点坐标都落在多边形内。即配对的交点中，左边的交点向右取整（通常采用int(…)+1），右边的交点向左取整（通常采用int(…)）。</p>
<ul>
<li><p>用扫描线算法来扫描转换多边形的具体代码如下（代码里的多边形坐标比前面多边形图中扩大了10倍）：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp">  <span class="token preprocessor property">#include&lt;iostream></span>
  <span class="token preprocessor property">#include&lt;math.h></span>
  <span class="token preprocessor property">#include&lt;gl/glut.h></span>
  <span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

  <span class="token keyword">const</span> <span class="token keyword">int</span> infinity<span class="token operator">=</span><span class="token number">65535</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//表示一个不可能的数</span>

  <span class="token comment" spellcheck="true">//建立边表ET中的链表结点（边结点）数据结构</span>
  <span class="token keyword">class</span> <span class="token class-name">ETListNode</span><span class="token punctuation">{</span>
  <span class="token keyword">public</span><span class="token punctuation">:</span>
      <span class="token keyword">float</span> xBottom<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//边的下端点x坐标</span>
      <span class="token keyword">float</span> delta<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//边的斜率倒数</span>
      <span class="token keyword">int</span> yTop<span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">//边的上端点y坐标</span>
      ETListNode<span class="token operator">*</span> nextEdge<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//指向下一个链表结点的指针</span>

      <span class="token function">ETListNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
          xBottom<span class="token operator">=</span>infinity<span class="token punctuation">;</span>
          delta<span class="token operator">=</span>infinity<span class="token punctuation">;</span>
          yTop<span class="token operator">=</span>infinity<span class="token punctuation">;</span>
          nextEdge<span class="token operator">=</span>NULL<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">//建立边表ET中的数组元素的结构</span>
  <span class="token keyword">class</span> <span class="token class-name">ETArray</span><span class="token punctuation">{</span>
  <span class="token keyword">public</span><span class="token punctuation">:</span>
      ETListNode<span class="token operator">*</span> ToETList<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//指向链表的指针</span>

      <span class="token function">ETArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
          ToETList<span class="token operator">=</span>NULL<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">//边表</span>
  <span class="token keyword">class</span> <span class="token class-name">ET</span><span class="token punctuation">{</span>
  <span class="token keyword">public</span><span class="token punctuation">:</span>
      ETArray etArray<span class="token punctuation">[</span><span class="token number">110</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
      ETListNode edges<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

      <span class="token function">ET</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
          edges<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>yTop<span class="token operator">=</span><span class="token number">40</span><span class="token punctuation">;</span>
          edges<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>xBottom<span class="token operator">=</span><span class="token number">50</span><span class="token punctuation">;</span>
          edges<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>delta<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
          edges<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>yTop<span class="token operator">=</span><span class="token number">50</span><span class="token punctuation">;</span>
          edges<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>xBottom<span class="token operator">=</span><span class="token number">70</span><span class="token punctuation">;</span>
          edges<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>delta<span class="token operator">=</span><span class="token number">5.0</span><span class="token operator">/</span><span class="token number">4</span><span class="token punctuation">;</span>
          edges<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span>yTop<span class="token operator">=</span><span class="token number">80</span><span class="token punctuation">;</span>
          edges<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span>xBottom<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">;</span>
          edges<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span>delta<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
          edges<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span>yTop<span class="token operator">=</span><span class="token number">110</span><span class="token punctuation">;</span>
          edges<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span>xBottom<span class="token operator">=</span><span class="token number">120</span><span class="token punctuation">;</span>
          edges<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span>delta<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
          edges<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">.</span>yTop<span class="token operator">=</span><span class="token number">80</span><span class="token punctuation">;</span>
          edges<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">.</span>xBottom<span class="token operator">=</span><span class="token number">70</span><span class="token punctuation">;</span>
          edges<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">.</span>delta<span class="token operator">=</span><span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">;</span>
          edges<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">.</span>yTop<span class="token operator">=</span><span class="token number">110</span><span class="token punctuation">;</span>
          edges<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">.</span>xBottom<span class="token operator">=</span><span class="token number">70</span><span class="token punctuation">;</span>
          edges<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">.</span>delta<span class="token operator">=</span><span class="token number">5.0</span><span class="token operator">/</span><span class="token number">4</span><span class="token punctuation">;</span>

          edges<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>nextEdge<span class="token operator">=</span><span class="token operator">&amp;</span>edges<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
          edges<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">.</span>nextEdge<span class="token operator">=</span><span class="token operator">&amp;</span>edges<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
          etArray<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">.</span>ToETList<span class="token operator">=</span><span class="token operator">&amp;</span>edges<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
          etArray<span class="token punctuation">[</span><span class="token number">40</span><span class="token punctuation">]</span><span class="token punctuation">.</span>ToETList<span class="token operator">=</span><span class="token operator">&amp;</span>edges<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
          etArray<span class="token punctuation">[</span><span class="token number">50</span><span class="token punctuation">]</span><span class="token punctuation">.</span>ToETList<span class="token operator">=</span><span class="token operator">&amp;</span>edges<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
          etArray<span class="token punctuation">[</span><span class="token number">70</span><span class="token punctuation">]</span><span class="token punctuation">.</span>ToETList<span class="token operator">=</span><span class="token operator">&amp;</span>edges<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">//建立活性边表AET的结点结构</span>
  <span class="token keyword">class</span> <span class="token class-name">AETListNode</span><span class="token punctuation">{</span>
  <span class="token keyword">public</span><span class="token punctuation">:</span>
      <span class="token keyword">float</span> xIntersection<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//当前扫描线与活性边的交点的x坐标</span>
      <span class="token keyword">float</span> delta<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//边的斜率倒数</span>
      <span class="token keyword">int</span> yTop<span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">//边的上端点y坐标</span>
      AETListNode<span class="token operator">*</span> nextEdge<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//指向下一个链表结点的指针 </span>

      <span class="token function">AETListNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
          xIntersection<span class="token operator">=</span>infinity<span class="token punctuation">;</span>
          delta<span class="token operator">=</span>infinity<span class="token punctuation">;</span>
          yTop<span class="token operator">=</span>infinity<span class="token punctuation">;</span>
          nextEdge<span class="token operator">=</span>NULL<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">//活性边表</span>
  <span class="token keyword">class</span> <span class="token class-name">AET</span><span class="token punctuation">{</span>
  <span class="token keyword">public</span><span class="token punctuation">:</span>
      AETListNode<span class="token operator">*</span> first<span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//活性边表头结点</span>

      <span class="token function">AET</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
          first<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">AETListNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//初始化头结点</span>
      <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token comment" spellcheck="true">//扫描线算法画多边形</span>
  <span class="token keyword">void</span> <span class="token function">Scan</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      ET et<span class="token punctuation">;</span>
      AET aet<span class="token punctuation">;</span>
      <span class="token keyword">bool</span> etEmpty<span class="token operator">=</span><span class="token keyword">false</span><span class="token punctuation">;</span>
      <span class="token keyword">bool</span> aetEmpty<span class="token operator">=</span><span class="token keyword">false</span><span class="token punctuation">;</span>

      <span class="token keyword">int</span> y<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>                      <span class="token comment" spellcheck="true">//扫描线y值</span>
      <span class="token keyword">while</span><span class="token punctuation">(</span>et<span class="token punctuation">.</span>etArray<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">.</span>ToETList<span class="token operator">==</span>NULL<span class="token punctuation">)</span><span class="token punctuation">{</span>
              y<span class="token operator">++</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">while</span><span class="token punctuation">(</span>y<span class="token operator">&lt;</span><span class="token number">110</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
          ETListNode<span class="token operator">*</span> currentETNode<span class="token operator">=</span>et<span class="token punctuation">.</span>etArray<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">.</span>ToETList<span class="token punctuation">;</span>
          <span class="token keyword">while</span><span class="token punctuation">(</span>currentETNode<span class="token operator">!=</span>NULL<span class="token punctuation">)</span><span class="token punctuation">{</span>
              AETListNode<span class="token operator">*</span> tempAETNode<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">AETListNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
              tempAETNode<span class="token operator">-</span><span class="token operator">></span>yTop<span class="token operator">=</span>currentETNode<span class="token operator">-</span><span class="token operator">></span>yTop<span class="token punctuation">;</span>
              tempAETNode<span class="token operator">-</span><span class="token operator">></span>xIntersection<span class="token operator">=</span>currentETNode<span class="token operator">-</span><span class="token operator">></span>xBottom<span class="token punctuation">;</span>
              tempAETNode<span class="token operator">-</span><span class="token operator">></span>delta<span class="token operator">=</span>currentETNode<span class="token operator">-</span><span class="token operator">></span>delta<span class="token punctuation">;</span>

              AETListNode<span class="token operator">*</span> currentAETNode<span class="token operator">=</span>aet<span class="token punctuation">.</span>first<span class="token punctuation">;</span>
              <span class="token keyword">while</span><span class="token punctuation">(</span>currentAETNode<span class="token operator">-</span><span class="token operator">></span>nextEdge<span class="token operator">!=</span>NULL <span class="token operator">&amp;&amp;</span> tempAETNode<span class="token operator">-</span><span class="token operator">></span>xIntersection<span class="token operator">>=</span>currentAETNode<span class="token operator">-</span><span class="token operator">></span>nextEdge<span class="token operator">-</span><span class="token operator">></span>xIntersection<span class="token punctuation">)</span><span class="token punctuation">{</span>
                  currentAETNode<span class="token operator">=</span>currentAETNode<span class="token operator">-</span><span class="token operator">></span>nextEdge<span class="token punctuation">;</span>
              <span class="token punctuation">}</span>
              <span class="token comment" spellcheck="true">//插入新边（新结点）</span>
              tempAETNode<span class="token operator">-</span><span class="token operator">></span>nextEdge<span class="token operator">=</span>currentAETNode<span class="token operator">-</span><span class="token operator">></span>nextEdge<span class="token punctuation">;</span>
              currentAETNode<span class="token operator">-</span><span class="token operator">></span>nextEdge<span class="token operator">=</span>tempAETNode<span class="token punctuation">;</span>

              currentETNode<span class="token operator">=</span>currentETNode<span class="token operator">-</span><span class="token operator">></span>nextEdge<span class="token punctuation">;</span>
          <span class="token punctuation">}</span>
          AETListNode<span class="token operator">*</span> currentAETNode<span class="token operator">=</span>aet<span class="token punctuation">.</span>first<span class="token punctuation">;</span>
          <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>currentAETNode<span class="token operator">-</span><span class="token operator">></span>nextEdge<span class="token operator">!=</span>NULL<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
              currentAETNode<span class="token operator">=</span>currentAETNode<span class="token operator">-</span><span class="token operator">></span>nextEdge<span class="token punctuation">;</span>
              <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">%</span><span class="token number">2</span><span class="token operator">==</span><span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>
                  <span class="token keyword">int</span> xStart<span class="token operator">=</span><span class="token keyword">int</span><span class="token punctuation">(</span>currentAETNode<span class="token operator">-</span><span class="token operator">></span>xIntersection<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
                  <span class="token keyword">int</span> xEnd<span class="token operator">=</span><span class="token keyword">int</span><span class="token punctuation">(</span>currentAETNode<span class="token operator">-</span><span class="token operator">></span>nextEdge<span class="token operator">-</span><span class="token operator">></span>xIntersection<span class="token punctuation">)</span><span class="token punctuation">;</span>
                  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token operator">=</span>xStart<span class="token punctuation">;</span>x<span class="token operator">&lt;=</span>xEnd<span class="token punctuation">;</span>x<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                      <span class="token function">glVertex2d</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
                  <span class="token punctuation">}</span>
              <span class="token punctuation">}</span>
          <span class="token punctuation">}</span>
          y<span class="token operator">++</span><span class="token punctuation">;</span>
          currentAETNode<span class="token operator">=</span>aet<span class="token punctuation">.</span>first<span class="token punctuation">;</span>
          <span class="token keyword">while</span><span class="token punctuation">(</span>currentAETNode<span class="token operator">-</span><span class="token operator">></span>nextEdge<span class="token operator">!=</span>NULL<span class="token punctuation">)</span><span class="token punctuation">{</span>
              <span class="token keyword">if</span><span class="token punctuation">(</span>currentAETNode<span class="token operator">-</span><span class="token operator">></span>nextEdge<span class="token operator">-</span><span class="token operator">></span>yTop<span class="token operator">==</span>y<span class="token punctuation">)</span><span class="token punctuation">{</span>
                  currentAETNode<span class="token operator">-</span><span class="token operator">></span>nextEdge<span class="token operator">=</span>currentAETNode<span class="token operator">-</span><span class="token operator">></span>nextEdge<span class="token operator">-</span><span class="token operator">></span>nextEdge<span class="token punctuation">;</span>
              <span class="token punctuation">}</span>
              <span class="token keyword">else</span><span class="token punctuation">{</span>
                  currentAETNode<span class="token operator">=</span>currentAETNode<span class="token operator">-</span><span class="token operator">></span>nextEdge<span class="token punctuation">;</span>
                  currentAETNode<span class="token operator">-</span><span class="token operator">></span>xIntersection<span class="token operator">+</span><span class="token operator">=</span>currentAETNode<span class="token operator">-</span><span class="token operator">></span>delta<span class="token punctuation">;</span>
              <span class="token punctuation">}</span>
          <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">void</span> <span class="token function">Draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token function">gluOrtho2D</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">700</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">600</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">glClearColor</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">glClear</span><span class="token punctuation">(</span>GL_COLOR_BUFFER_BIT<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">glBegin</span><span class="token punctuation">(</span>GL_POINTS<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">glColor3ub</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">Scan</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">glEnd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">glFlush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">void</span> <span class="token function">mydisplay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token function">Draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token function">glutInitWindowSize</span><span class="token punctuation">(</span><span class="token number">400</span><span class="token punctuation">,</span><span class="token number">600</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">glutCreateWindow</span><span class="token punctuation">(</span><span class="token string">"扫描转换多边形"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">glutDisplayFunc</span><span class="token punctuation">(</span>mydisplay<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">glutMainLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<p>&nbsp;</p>
<hr>
<p>在扫描线算法中用到了交点（相邻扫描线与多边形某一条边的交点）之间的连续性，即同一条边上相邻交点是有固定代数联系的。也就是说扫描线算法是从多边形的轮廓下手的，先找出多边形轮廓上的点，再去填充这些轮廓点之间的像素点。那么能不能直接从多边形内部的点下手呢？毕竟多边形内部的点连续性更明显啊：多边形内部的点通常它周围的点都会在多边形里。下面的这个算法就是利用了这点。</p>
<p><font size="4" color="red">扫描转换填充多边形：种子填充法</font><br>种子填充法是利用了多边形内部点的连续性。有两种填充方式：</p>
<ul>
<li>边界填充：首先用一种颜色（取名边界色）画出多边形轮廓，再从多边形内部任意一点开始，查看它的周围像素点（一般是上下左右）<strong>是否是边界色或者已填充色</strong>，如果都不是，则说明该点是多边形内部且暂时没有被描色的点，接下来给该点描色即可。一般采用递归的方式，让每个已描色的点都去重复上诉过程。</li>
<li><p>内点填充：依然是首先用一种不同于背景色的颜色，画出多边形轮廓，再从多边形内部任意一点开始，查看它的周围像素点（一般是上下左右）<strong>是否是背景色</strong>，如果是则说明该点是多边形内部且暂时没有被描色的点，接下来用一种不同于背景色的颜色给该点描色即可。同样采用递归的方式，让每个以描色的点都去重复上诉过程。</p>
<p>使用内点填充画五角星的代码如下：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp">    <span class="token preprocessor property">#include&lt;math.h></span>
    <span class="token preprocessor property">#include&lt;gl/glut.h></span>
    <span class="token preprocessor property">#include&lt;iostream></span>
    <span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

    <span class="token preprocessor property">#<span class="token directive keyword">define</span> PI 3.14</span>

    <span class="token comment" spellcheck="true">//读像素颜色</span>
    unsigned <span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">GetPixel</span><span class="token punctuation">(</span><span class="token keyword">float</span> x<span class="token punctuation">,</span><span class="token keyword">float</span> y<span class="token punctuation">)</span><span class="token punctuation">{</span>
      unsigned <span class="token keyword">char</span><span class="token operator">*</span> color<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">unsigned</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token function">glReadPixels</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span>GL_RGB<span class="token punctuation">,</span>GL_BYTE<span class="token punctuation">,</span>color<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//调用opengl函数读取像素颜色</span>
      <span class="token keyword">return</span> color<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">//写像素颜色</span>
    <span class="token keyword">void</span> <span class="token function">SetPixel</span><span class="token punctuation">(</span><span class="token keyword">float</span> x<span class="token punctuation">,</span><span class="token keyword">float</span> y<span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">*</span> BoundaryColor<span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token function">glBegin</span><span class="token punctuation">(</span>GL_POINTS<span class="token punctuation">)</span><span class="token punctuation">;</span>    
      <span class="token function">glColor3ub</span><span class="token punctuation">(</span>BoundaryColor<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>BoundaryColor<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>BoundaryColor<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">glVertex2f</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">glEnd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">glFlush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">//内点填充（递归）</span>
    <span class="token comment" spellcheck="true">//参数BoundaryColor为边界色或者填充色，二者等色</span>
    <span class="token keyword">void</span> <span class="token function">FloodFill</span><span class="token punctuation">(</span><span class="token keyword">float</span> x<span class="token punctuation">,</span><span class="token keyword">float</span> y<span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">*</span> BoundaryColor<span class="token punctuation">)</span><span class="token punctuation">{</span>
      unsigned <span class="token keyword">char</span><span class="token operator">*</span> color<span class="token operator">=</span><span class="token function">GetPixel</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment" spellcheck="true">//像素颜色是否等于原背景色:绿色，如果是则填为边界色</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>color<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token operator">&amp;&amp;</span>color<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">127</span><span class="token operator">&amp;&amp;</span>color<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
          <span class="token function">SetPixel</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">,</span>BoundaryColor<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token function">FloodFill</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>BoundaryColor<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token function">FloodFill</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token number">-1</span><span class="token punctuation">,</span>BoundaryColor<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token function">FloodFill</span><span class="token punctuation">(</span>x<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>y<span class="token punctuation">,</span>BoundaryColor<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token function">FloodFill</span><span class="token punctuation">(</span>x<span class="token number">-1</span><span class="token punctuation">,</span>y<span class="token punctuation">,</span>BoundaryColor<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">//填充五角星</span>
    <span class="token keyword">void</span> <span class="token function">FillPentagram</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token keyword">int</span><span class="token operator">*</span> BoundaryColor<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//设置边界色/已填充色</span>
      BoundaryColor<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">255</span><span class="token punctuation">;</span>
      BoundaryColor<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
      BoundaryColor<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
      <span class="token function">glColor3ub</span><span class="token punctuation">(</span>BoundaryColor<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>BoundaryColor<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>BoundaryColor<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment" spellcheck="true">//指定一个种子坐标</span>
      <span class="token keyword">float</span> x0<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
      <span class="token keyword">float</span> y0<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span>
      <span class="token keyword">float</span> theta<span class="token punctuation">;</span>
      <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
          <span class="token comment" spellcheck="true">//旋转种子点，每次36度</span>
          theta<span class="token operator">=</span><span class="token number">0.2</span><span class="token operator">*</span>PI<span class="token operator">*</span>i<span class="token punctuation">;</span>
          <span class="token keyword">float</span> x<span class="token operator">=</span><span class="token function">cos</span><span class="token punctuation">(</span>theta<span class="token punctuation">)</span><span class="token operator">*</span>x0<span class="token operator">-</span><span class="token function">sin</span><span class="token punctuation">(</span>theta<span class="token punctuation">)</span><span class="token operator">*</span>y0<span class="token operator">+</span><span class="token number">300</span><span class="token punctuation">;</span>
          <span class="token keyword">float</span> y<span class="token operator">=</span><span class="token function">sin</span><span class="token punctuation">(</span>theta<span class="token punctuation">)</span><span class="token operator">*</span>x0<span class="token operator">+</span><span class="token function">cos</span><span class="token punctuation">(</span>theta<span class="token punctuation">)</span><span class="token operator">*</span>y0<span class="token operator">+</span><span class="token number">300</span><span class="token punctuation">;</span>
          <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">%</span><span class="token number">2</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
              BoundaryColor<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">255</span><span class="token punctuation">;</span>
          <span class="token punctuation">}</span>
          <span class="token keyword">else</span><span class="token punctuation">{</span>
              BoundaryColor<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">127</span><span class="token punctuation">;</span>
          <span class="token punctuation">}</span>
          <span class="token function">FloodFill</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">,</span>BoundaryColor<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">//画五角星轮廓</span>
    <span class="token keyword">void</span> <span class="token function">DrawPentagramOutline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token keyword">float</span> R<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//五角星外圆半径</span>
      <span class="token keyword">float</span> r<span class="token operator">=</span>R<span class="token operator">*</span><span class="token number">0.415f</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//五角星内圆半径</span>
      <span class="token keyword">float</span> point<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token keyword">float</span> point_original<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
      point_original<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">300</span><span class="token punctuation">;</span>
      point_original<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">300</span><span class="token punctuation">;</span>

      <span class="token function">glBegin</span><span class="token punctuation">(</span>GL_LINE_LOOP<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token function">glColor3ub</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
              <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">%</span><span class="token number">2</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                  point<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span>r<span class="token operator">*</span><span class="token function">cos</span><span class="token punctuation">(</span><span class="token number">0.2</span><span class="token operator">*</span>i<span class="token operator">*</span>PI<span class="token punctuation">)</span><span class="token punctuation">;</span>
                  point<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>r<span class="token operator">*</span><span class="token function">sin</span><span class="token punctuation">(</span><span class="token number">0.2</span><span class="token operator">*</span>i<span class="token operator">*</span>PI<span class="token punctuation">)</span><span class="token punctuation">;</span>
              <span class="token punctuation">}</span>
              <span class="token keyword">else</span><span class="token punctuation">{</span>
                  point<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span>R<span class="token operator">*</span><span class="token function">cos</span><span class="token punctuation">(</span><span class="token number">0.2</span><span class="token operator">*</span>i<span class="token operator">*</span>PI<span class="token punctuation">)</span><span class="token punctuation">;</span>
                  point<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>R<span class="token operator">*</span><span class="token function">sin</span><span class="token punctuation">(</span><span class="token number">0.2</span><span class="token operator">*</span>i<span class="token operator">*</span>PI<span class="token punctuation">)</span><span class="token punctuation">;</span>
              <span class="token punctuation">}</span>
          <span class="token punctuation">}</span>
          <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
              <span class="token function">glVertex2d</span><span class="token punctuation">(</span>point_original<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span>point<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>point_original<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>point<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token punctuation">}</span>
      <span class="token function">glEnd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">glBegin</span><span class="token punctuation">(</span>GL_LINES<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token function">glColor3ub</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
              <span class="token function">glVertex2d</span><span class="token punctuation">(</span>point_original<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span>point<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>point_original<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>point<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
              <span class="token function">glVertex2d</span><span class="token punctuation">(</span>point_original<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>point_original<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token punctuation">}</span>
      <span class="token function">glEnd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">glFlush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">void</span> <span class="token function">mydisplay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token function">glClearColor</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">glClear</span><span class="token punctuation">(</span>GL_COLOR_BUFFER_BIT<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">glMatrixMode</span><span class="token punctuation">(</span>GL_PROJECTION<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">glLoadIdentity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">gluOrtho2D</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">500</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">600</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">DrawPentagramOutline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">FillPentagram</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token function">glutInitWindowSize</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">,</span><span class="token number">600</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">glutCreateWindow</span><span class="token punctuation">(</span><span class="token string">"种子填充"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">glutDisplayFunc</span><span class="token punctuation">(</span>mydisplay<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">glutMainLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>效果如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147876876527.png" alt=""></p>
</li>
</ul>
<p>可以看出，无论哪种方法，其实都需要先画出多边形轮廓的点阵信息，再根据屏幕上像素点的颜色来进行填充，所以其实是点阵到点阵的转换，已经不是严格意义上的扫描转换了。但是那些事先的轮廓点阵信息一般都是由参数形式转换而来，所以才把种子填充勉强地归为扫描转换。<br>&nbsp;</p>
<hr>
<p>到此，已经介绍完了画基本填充图元的扫描转换法。下面是另一个画法：填充法。</p>
<p><font size="5" color="orange">画填充图形：填充法</font><br>扫描转换法是把图形的参数形式转换为点阵形式，再进行显示。但是并不是每一幅图形都能用参数表示出来啊~~比如相机照出来的照片，要用参数这种数学形式表示出照片这种复杂图形估计有点难度！那就没有参数形式，只有点阵形式了，比如要在计算机上显示一幅照片，就得需要这幅照片的点阵形式，这幅照片的点阵形式是什么？当然是每一个像素点的颜色啊，所以如果知道图形每一个像素点的颜色值，则交给计算机按颜色值逐像素点描色，即可在电脑上画出这张照片。</p>
<p>所以填充法就是：按照事先知道的图形像素点颜色值，在计算机上逐点描色，从而画出图形。</p>
<p>至于怎么事先知道一幅图形的所有像素点颜色值，就得靠其它方法了，比如数码摄像机会通过电子传感器把光学影像转换成电子数据，再传输给计算机。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Mathjax简介及其语法]]></title>
      <url>/2016/10/27/Mathjax%E8%AF%AD%E6%B3%95/</url>
      <content type="html"><![CDATA[<p><font size="5" color="orange">Mathjax简介</font><br><a id="more"></a><br>Mathjax是一款运行在浏览器中的开源数学符号渲染引擎，使用Mathjax可以方便地在浏览器中显示数学公式，不需要使用图片。目前，Mathjax可以解析LateX、MathML和ASCIIMathML的标记语言。几乎支持所有的主流浏览器。<br>&nbsp; </p>
<hr>
<p><font size="5" color="orange">Mathjax语法</font></p>
<p><font size="4" color="red">Mathjax公式排版方式</font><br>Mathjax公式排版有两种方式：inline和displayed。inline方式是把公式内嵌（使用<code>$...$</code>），例如<code>$f(x)=3 \times x$</code>，$f(x)=3 \times x$这是一个inline公式；而displayed是公式独立成段（使用<code>$$...$$</code>），例如<code>$$f(x)=3 \times x$$</code>，$$f(x)=3 \times x$$是一个displayed公式。</p>
<blockquote>
<p>右键点击公式，可查看公式代码、设置显示效果和渲染模式（点击打开的公式代码没有包含\$，自己在写公式时加上即可）。<br>两个独立成段的displayed公式之间必须以空行分开，否则显示不出来。即应该是下面这样：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">\$\$<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>\$\$

\$\$<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>\$\$
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</blockquote>
<p><font size="4" color="red">公式中的希腊字母</font><br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147764777424.png" alt=""></p>
<p><font size="4" color="red">公式中的上标下标</font><br>上标使用^，下标使用_。例如x_i^2是：$x_i^2$。<br>【注】：</p>
<ul>
<li>10^10得到的是$10^10$，而10^{10}才是$10^{10}$。</li>
<li>x^5^6会报错，因为有二义性，必须使用大括号来加以界定，如：{x^5}^6：${x^5}^6$ 或者x^{5^6}：$x^{5^6}$。</li>
</ul>
<p><font size="4" color="red">公式中的括号</font></p>
<ul>
<li>小括号与方括号：小括号还是原始的()，方括号也是原始的[]。如(2+3)[4+4]：$(2+3)[4+4]$</li>
<li>大括号：{}由于被用来界定分组（如上文中的10^{10}），所以大括号需要用{和}来表示，也可以使用\lbrace和\rbrace来表示。如{a*b}：${a*b}$，\lbrace a*b \rbrace：$\lbrace a*b \rbrace$。</li>
<li>尖括号：使用\langle和\rangle表示。如\langle x \rangle：$\langle x \rangle$。</li>
<li>向上取整：使用\lceil和\rceil表示。如\lceil x \rceil：$\lceil x \rceil$。</li>
<li>向下取整：使用\lfloor和\rfloor表示。如\lfloor x \rfloor：$\lfloor x \rfloor$。</li>
<li>不可见括号：使用.表示。</li>
</ul>
<p>【注】：这些括号都是不会随着公式大小进行缩放的。如果需要括号大小自适应公式大小，可以在相应的左括号前面加上/left，右括号前面加上/right。如下所示：<br>$$\lbrace \sum_{i=0}^n i^2 \rbrace \tag{1}$$</p>
<p>$$\left\lbrace \sum_{i=0}^n i^2 \right\rbrace \tag{2}$$</p>
<p>公式2的括号就是经过缩放的（右键点击公式能看到公式源码）。</p>
<p><font size="4" color="red">公式中的求和与积分</font><br>求和符号使用\sum来表示，用下标_来表示求和下限，用上标^来表示求和上限。如\sum_1^n：$\sum_1^n$。</p>
<p>积分符号使用\int来表示，同样用上下标表示积分的上下限。如\int_1^\infty：$\int_1^\infty$。</p>
<p>与此类似的符号还有：二重积分\iint：$\iint$，连乘\prod：$\prod$，并\bigcup：$\bigcup$，交\bigcap：$\bigcap$。</p>
<p><font size="4" color="red">公式中的分数</font><br>分数有两种表示方式：</p>
<ul>
<li>使用\frac ab来表示，\frac作用于其后的两个组a、b，结果为$\frac ab$。如果分子或分母不是单个字符，使用{}进行分组即可（也就是用大括号括起来）。</li>
<li>使用a \over b来分隔分子分母。如a+1 \over b+1：$a+1 \over b+1$。</li>
</ul>
<p><font size="4" color="red">公式中的根号</font><br>根号使用\sqrt[]{}来表示。如\sqrt[4]{\frac xy}：$\sqrt[4]{\frac xy}$。</p>
<p><font size="4" color="red">公式中的三角函数</font><br>使用\sin来表示正弦函数，如$\sin x$。其他三角函数类似。</p>
<p><font size="4" color="red">公式中的特殊符号</font></p>
<ul>
<li>求极限符号：使用\lim_{x \to y}表示。如$\lim_{1 \to \infty}$。</li>
<li><p>比较运算符：</p>
<ul>
<li>小于$\lt$：\lt。</li>
<li>大于$gt$：\gt</li>
<li>小于等于$\le$：\le。</li>
<li>大于等于$\ge$：\ge。</li>
</ul>
<p>可以在这些运算符前面加上\not，如\not \gt：$\not \gt$。</p>
</li>
<li><p>常见计算运算符：</p>
<ul>
<li>加$+$：直接在公式中使用+即可。</li>
<li>减$-$：直接在公式中使用-即可。</li>
<li>乘$\times$：\times。</li>
<li>除$\div$：\div。</li>
<li>加减$\pm$：\pm。</li>
<li>减加$\mp$：\mp。</li>
<li>点乘$\cdot$：\cdot。如x \cdot y：$x \cdot y$。</li>
</ul>
</li>
<li><p>集合运算符：</p>
<ul>
<li>并$\cup$：\cup</li>
<li>交$\cap$：\cap</li>
<li>舍$\setminus$：\setminus</li>
<li>包含于$\subset$：\subset</li>
<li>真包含于$\subseteq$：\subseteq</li>
<li>非真包含于$\subsetneq$：\subsetneq</li>
<li>包含$\supset$：\supset</li>
<li>属于$\in$：\in</li>
<li>不属于$\notin$：\notin</li>
<li>空集$\varnothing$：\varnothing </li>
</ul>
</li>
<li>排列使用$n+1 \choose 2k$：使用a \choose y或者\binom ab来表示。</li>
<li>箭头：\to：$\to$，\rightarrow：$\rightarrow$，\leftarrow：$\leftarrow$，\Rightarrow：$\Rightarrow$，\Leftarrow：$\Leftarrow$，\mapsto：$\mapsto$。</li>
<li>逻辑运算符：\land：$\land$， \lor：$\lor$， \lnot：$\lnot$， \forall：$\forall$，\exists：$\exists$，\top：$\top$，\bot：$\bot$，\vdash：$\vdash$， \vDash：$\vDash$。</li>
<li>模运算符：\pmod。如b \pmod n：$b\ pmod n$。</li>
<li>省略号：\cdots位置居中：$\cdots$；\ldots位置稍低：$\ldots$。</li>
<li>\star：$\star$，\ast：$\ast$，\oplus：$\oplus$，\circ：$\circ$，\bullet：$\bullet$，\approx：$\approx$，\sim：$\sim$，\cong：$\cong$，\equiv：$\equiv$，\prec：$\prec$，\infty：$\infty$，\nabla：$\nabla$，\partial：$\partial$。</li>
</ul>
<p>【注】：使用<a href="http://detexify.kirelabs.org/classify.html" target="_blank" rel="external">Detexify</a>，可以在它的网页上画出你想要的符号，Detexify会给出相似的符号及其公式代码。但是不能保证它给出的符号可以在Mathjax中使用，可以参考<a href="http://docs.mathjax.org/en/latest/tex.html#supported-latex-commands" target="_blank" rel="external">supported-latex-commands</a>确定MathJax是否支持此符号。</p>
<p><font size="4" color="red">公式中的空格</font><br>因为Mathjax通过内部策略自己管理公式内部的空间，因此a   b的显示结果依然是：$a   b$。想要在ab之间加入间隙，可以使用\,、\;、\quad、\qquad等，间隙依次增加，如$a\,b$、$a\;b$、$a \quad b$、$a \qquad b$。</p>
<p><font size="4" color="red">公式中的顶部符号</font><br>对于单字符\hat：$\hat x$，多字符\widehat：$\widehat {xy}$。类似的还有：\overline：$\overline {xyz}$、\vec：$\vec x$、\overrightarrow：$\overrightarrow x$、\dot：$\dot x$、\ddot：$\ddot x$。</p>
<p><font size="4" color="red">公式中的表格</font><br>使用<code>$$\begin{array}{列样式}...\end{array}$$</code>这样的样式来创建表格。</p>
<ul>
<li>列样式可以是c（居中）、l（左对齐）、r（右对齐）。</li>
<li>每行之间使用\\来分隔（本来是\，但是在markdown中第一个\被解释为转义字符，所以需要\\），每列之间使用&amp;来分隔。</li>
<li>在列样式中写入|可表示一条竖线，在每行前面加上\hline可在本行前加入一条直线。</li>
</ul>
<p>例如：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp">$$
\begin<span class="token punctuation">{</span>array<span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token operator">|</span>c<span class="token operator">|</span>l<span class="token operator">|</span>c<span class="token operator">|</span>r<span class="token operator">|</span><span class="token punctuation">}</span>
\hline
n <span class="token operator">&amp;</span> Left <span class="token operator">&amp;</span> Center <span class="token operator">&amp;</span> Right \\\\
\hline
<span class="token number">1</span> <span class="token operator">&amp;</span> <span class="token number">0.24</span> <span class="token operator">&amp;</span> <span class="token number">1</span> <span class="token operator">&amp;</span> <span class="token number">125</span> \\\\
\hline
<span class="token number">2</span> <span class="token operator">&amp;</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;</span> <span class="token number">189</span> <span class="token operator">&amp;</span> <span class="token operator">-</span><span class="token number">8</span> \\\\
\hline
<span class="token number">3</span> <span class="token operator">&amp;</span> <span class="token operator">-</span><span class="token number">20</span> <span class="token operator">&amp;</span> <span class="token number">2000</span> <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token operator">+</span>10i \\\\
\hline
\end<span class="token punctuation">{</span>array<span class="token punctuation">}</span>
$$
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>效果：<br>$$<br>\begin{array}{|c|l|c|r|}<br>\hline<br>n &amp; Left &amp; Center &amp; Right \\<br>\hline<br>1 &amp; 0.24 &amp; 1 &amp; 125 \\<br>\hline<br>2 &amp; -1 &amp; 189 &amp; -8 \\<br>\hline<br>3 &amp; -20 &amp; 2000 &amp; 1+10i \\<br>\hline<br>\end{array}<br>$$</p>
<p><font size="4" color="red">公式中的矩阵</font><br>使用<code>$$\begin{matrix}...\end{matrix}$$</code>这样的形式来表示矩阵。矩阵的每行之间依然使用\\来分隔，列之间依然使用&amp;来分隔。<br>例如：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp">$$
\begin<span class="token punctuation">{</span>matrix<span class="token punctuation">}</span>
<span class="token number">1</span> <span class="token operator">&amp;</span> x <span class="token operator">&amp;</span> x<span class="token operator">^</span><span class="token number">2</span> \\\\
<span class="token number">1</span> <span class="token operator">&amp;</span> y <span class="token operator">&amp;</span> y<span class="token operator">^</span><span class="token number">2</span> \\\\
<span class="token number">1</span> <span class="token operator">&amp;</span> z <span class="token operator">&amp;</span> z<span class="token operator">^</span><span class="token number">2</span> \\\\
\end<span class="token punctuation">{</span>matrix<span class="token punctuation">}</span>
$$
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>效果：<br>$$<br>\begin{matrix}<br>1 &amp; x &amp; x^2 \\<br>1 &amp; y &amp; y^2 \\<br>1 &amp; z &amp; z^2 \\<br>\end{matrix}<br>$$</p>
<ul>
<li>给矩阵加括号：<ul>
<li>可以用前文中提到的括号再配以\left和\right。</li>
<li>也可以使用特殊的matrix，即替换<code>\begin{matrix}...\end{matrix}</code>中的matrix为pmatrix、bmatrix、Bmatrix、vmatrix、Vmatrix。<br>如pmatrix：$\begin{pmatrix} 1 &amp; 2 \\ 3 &amp; 4\\ \end{pmatrix}$、bmatrix：&amp;\begin{bmatrix} 1 &amp; 2 \\ 3 &amp; 4\\ \end{bmatrix}$、Bmatrix：$\begin{Bmatrix} 1 &amp; 2 \\ 3 &amp; 4\\ \end{Bmatrix}$、<br>vmatrix：$\begin{vmatrix} 1 &amp; 2 \\ 3 &amp; 4\\ \end{vmatrix}$、<br>Vmatrix：$\begin{Vmatrix} 1 &amp; 2 \\ 3 &amp; 4\\ \end{Vmatrix}$。</li>
</ul>
</li>
<li>矩阵中的省略元素：<br>可以使用\cdots：$\cdots$、\ddots：$\ddots$、\vdots：$\vdots$来表示矩阵中的省略元素。例如：<br>$$<br>\begin{pmatrix}<br>1 &amp; a_1 &amp; a_1^2 &amp; \cdots &amp; a_1^n \\<br>1 &amp; a_2 &amp; a_2^2 &amp; \cdots &amp; a_2^n \\<br>\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\<br>1 &amp; a_m &amp; a_m^2 &amp; \cdots &amp; a_m^n \\<br>\end{pmatrix}<br>$$</li>
<li>增广矩阵的表示：<br>增广矩阵需要使用前面的array来实现，而matrix办不到了。例如：<pre class="line-numbers language-csharp"><code class="language-csharp">$$ 
\left <span class="token punctuation">[</span>
\begin<span class="token punctuation">{</span>array<span class="token punctuation">}</span><span class="token punctuation">{</span>cc<span class="token operator">|</span>c<span class="token punctuation">}</span>
<span class="token number">1</span> <span class="token operator">&amp;</span> <span class="token number">2</span> <span class="token operator">&amp;</span> <span class="token number">3</span> \\\\
<span class="token number">4</span> <span class="token operator">&amp;</span> <span class="token number">5</span> <span class="token operator">&amp;</span> <span class="token number">6</span> \\\\
\end<span class="token punctuation">{</span>array<span class="token punctuation">}</span>
\right <span class="token punctuation">]</span>
$$
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
效果：<br>$$<br>\left [<br>\begin{array}{cc|c}<br>1 &amp; 2 &amp; 3 \\<br>4 &amp; 5 &amp; 6 \\<br>\end{array}<br>\right ]<br>$$<font size="4" color="red">公式对齐</font><br>有时候可能需要一系列的公式中等号对齐，例如：<br>$$<br>\begin{align}<br>\sqrt{37} &amp; = \sqrt{\frac{73^2-1}{12^2}} \\<br>&amp; = \sqrt{\frac{73^2}{12^2}\cdot\frac{73^2-1}{73^2}} \\<br>&amp; = \sqrt{\frac{73^2}{12^2}}\sqrt{\frac{73^2-1}{73^2}} \\<br>&amp; = \frac{73}{12}\sqrt{1 - \frac{1}{73^2}} \\<br>&amp; \approx \frac{73}{12}\left(1 - \frac{1}{2\cdot73^2}\right)<br>\end{align}<br>$$<br>这需要使用形如<code>\begin{align}...\end{align}</code>的格式，其中需要使用&amp;来指明需要对齐的位置（右键可查看上诉公式的代码）。<br><font size="4" color="red">分类表达式</font><br>可使用形如<code>\begin{cases}...\end{cases}</code>的格式。其中使用\来分类，可使用&amp;指明需要对齐的位置。例如：<br>$$<br>f(n) =<br>\begin{cases}<br>n/2,  &amp; \text{if $n$ is even} \\<br>3n+1, &amp; \text{if $n$ is odd}  \\<br>\end{cases}<br>$$<br><font size="4" color="red">方程组</font></li>
</ul>
<ol>
<li>可以使用<code>\begin{array}...\end{array}</code>与<code>\left{ ... \right.</code>，配合表示方程组。例如：<br>$$<br>\left\{<br>\begin{array}{c}<br>a_1x+b_1y+c_1z=d_1 \\<br>a_2x+b_2y+c_2z=d_2 \\<br>a_3x+b_3y+c_3z=d_3 \\<br>\end{array}<br>\right.<br>$$</li>
<li>也可以使用<code>\begin{cases}...\end{cases}</code>。例如：<br>$$<br>\begin{cases}<br>a_1x+b_1y+c_1z=d_1 \\<br>a_2x+b_2y+c_2z=d_2 \\<br>a_3x+b_3y+c_3z=d_3 \\<br>\end{cases}<br>$$</li>
</ol>
<p>&nbsp;</p>
<hr>
<p>【注】：本文主要参考<a href="http://mlworks.cn/posts/introduction-to-mathjax-and-latex-expression/" target="_blank" rel="external">《Mathjax与LaTex公式简介》</a>一文，更多详细内容请参考此文。</p>
]]></content>
      
        <categories>
            
            <category> 博客配置 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Mathjax语法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[计算机图形显示系统]]></title>
      <url>/2016/10/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E6%98%BE%E7%A4%BA%E7%B3%BB%E7%BB%9F/</url>
      <content type="html"><![CDATA[<p>在揭开计算机图形显示系统的面纱之前，我们先来看看我们再熟悉不过的显示器吧。<br><a id="more"></a></p>
<p><font size="5" color="orange">显示器</font><br>如今的显示器大致分为两类（按器件的发光性质）：</p>
<ul>
<li>阴极射线管CRT（Cathode Ray Cube）：<br>优点：亮度高、对比度好、色彩鲜艳<br>缺点：体积大、笨重</li>
<li>平板型显示器：液晶、等离子<br>优点：器件薄，适合携带<br>缺点：亮度和对比度相对较低、色彩不够鲜艳，价格偏高</li>
</ul>
<p>两种显示器如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721603468.png" alt=""></p>
<hr>
<p>接下来分别看看这两种显示器。</p>
<p><font size="5" color="orange">CRT（Cathode Ray Cube）显示器</font></p>
<p><font size="4" color="red">CRT是怎么显示图形的呢？</font><br>CRT是一种真空器件，利用内部电磁场产生高速的、经过聚集的电子束，偏转到屏幕的不同位置，轰击屏幕表面的荧光材料，从而产生可见的图形。</p>
<p><font size="4" color="red">CRT由哪些东西组成？</font><br>CRT主要由电子枪、聚焦系统、加速电极、偏转系统、荧光屏组成。如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721603526.png" alt=""><br>（其实其中的电极、磁场、电场、偏转系统在高中物理就学过~在此就不赘述了）</p>
<p>但是我们现在经常见到的都是彩色电视，也就是彩色CRT（指的是大头电视，不是液晶电视~），那么CRT是怎么显示彩色的呢？</p>
<p><font size="4" color="red">CRT是怎么显示彩色像素点的？</font><br>常用的有两种方法：射线穿透法、影孔板法。</p>
<ul>
<li>射线穿透法：<br>原理：屏幕表面的荧光材料有两层：红色荧光涂层（发红光）和绿色荧光涂层（发绿光），电子束轰击穿透荧光层的深浅，决定了最后所产生的颜色。如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721603579.png" alt=""><br>使用射线穿透法的CRT成本低，但是只能产生有限几种颜色。主要用于画线显示器。</li>
<li>影孔板法：<ul>
<li>原理：<br>屏幕表面其实有三层，最内层是影孔板，中间层才是荧光涂层，最外层是屏幕玻璃。其中影孔板上有很多个小孔，每个小孔对应后面荧光涂层上的三个荧光点（呈三角形排列），所以每个小孔其实也是对应一个像素点（即三个荧光点）。如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721603629.png" alt=""><br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721603677.png" alt=""><br>在影孔板的内侧有三支电子枪，对应红、绿、蓝三种基色，电子枪、影孔板中的一个小孔和荧光点在一条直线上（如下图所示）。通过调节各电子枪发生的电子数目，就可以控制三个荧光点产生的三种色光强度。我们知道，三种基色的不同比例混合可以产生多种颜色，如此便达到了彩色的效果。（如果每支电子枪发出的电子束的强度有256个等级，则显示器能同时显示256*256*256=16M种颜色，称为真彩系统。）<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721603729.png" alt=""></li>
</ul>
</li>
</ul>
<p>【注】：三基色通常是RGB（红绿蓝），多用于硬件设备，如摄像机、扫描仪、投影仪等。还有一种三基色是CMY（蓝绿cyan、品红magenta、黄yellow），常用于彩色打印。CMY与RGB具有互补关系，即R=1-C、G=1-M、B=1-Y。</p>
<hr>
<p>平板型显示器这里主要介绍液晶显示器。</p>
<p><font size="5" color="orange">液晶显示器LCD（Liquid Crystal Display）</font><br>我们先来看看什么是液晶。</p>
<p><font size="4" color="red">什么是液晶？</font><br>液晶是一种液体和固体之间的特殊物质，它具有液体的流态性质和固体的光学性质。当液晶分子的某种排列状态，在电场作用下变为另一种排列状态时，液晶的光学性质会随之改变。</p>
<p>液晶分子受到电压影响时，会改变其分子排列状态，于是可以让摄入的光线产生偏转现象，从而改变光的强弱。如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721603788.png" alt=""><br>液晶亮度的控制原理如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721603843.png" alt=""><br>那么到底是怎么显示彩色的呢？</p>
<p><font size="4" color="red">液晶LCD是怎么显示彩色像素点的</font><br>从上面可以看到，液晶可以改变光的强度，这就类似影孔板法中电子束的强度，在LCD中其实也和影孔板法一样，存在三基色，通过不同的光强产生不同强度的三种色光，再组合就能得到各种各样的颜色。只是荧光涂层和三基色的实现方式不同于影孔板法罢了，原理都是一样的。<br>影孔板法通过在阴极上调节电压来控制电子束的强度，从而控制三基色的强度，达到彩色效果，而LCD是通过液晶分子在电压下的不同排列方式来控制光强，从而控制三基色的强度，达到彩色效果。想要了解的更详细，可以看<a href="http://www.cnblogs.com/armlinux/archive/2012/02/14/2396764.html" target="_blank" rel="external">这篇文章</a>哦！</p>
<p><font size="5" color="orange">LCD显示器和CRT显示器的比较</font></p>
<ul>
<li>相同点：<br>都是通过单个发光元素（像素）来显示图形或文字。</li>
<li>不同点：<ul>
<li>LCD体积小，厚度薄，重量轻，耗能少，无辐射</li>
<li>CRT显示亮度高，色彩鲜艳，分辨率高，但是体积较大</li>
</ul>
</li>
</ul>
<p>【注】：分辨率是CRT在水平或竖直方向单位长度上能识别的最大像素个数，单位通常为dpi（dots per inch）。在假定屏幕尺寸一定的情况下，也可用整个屏幕所能容纳的像素个数描述，如640<em>480，1024</em>768，1280*1024等等。分辨率越高显示的图形就越精细。</p>
<hr>
<p>到此，我们搞清了显示器的原理。是时候来看看我们的主题了：计算机图形显示系统。</p>
<p><font size="5" color="orange">计算机图形显示系统</font><br>先来看看显示系统由哪些东西组成。</p>
<p><font size="4" color="orange">显示系统由哪些东西组成？</font><br>主要组成部分是：显示器、视频控制器、显示缓冲器。</p>
<ul>
<li>视频控制器：控制显示设备（有的含图形加速处理器GPU），通过访问帧缓存来刷新屏幕</li>
<li>显示缓冲器：可以在内存或显示控制器中，帧缓存存放在显示缓冲器中</li>
</ul>
<p>如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/1477216039.png" alt=""><br>视频控制器就是从系统存储器（显示缓冲器）的帧缓存中取出一帧要显示的内容（一些绘图命令），然后由视频控制器来显示数据对应的图形。</p>
<hr>
<p>视频控制器以不同的方式显示计算机图形，可把显示系统分为两类：随机扫描显示系统、光栅扫描显示系统。</p>
<p><font size="5" color="orange">随机扫描显示系统</font></p>
<p><font size="4" color="red">什么是随机扫描？</font><br>电子束可以<strong>随意移动</strong>，只扫描荧屏上要显示的部分像素。对应的显示器为画线设备。</p>
<p><font size="4" color="red">随机扫描显示系统主要靠哪些东西来实现（逻辑部件）？</font></p>
<ul>
<li>刷新存储器（Refreshing Buffer）：帧缓存所在的地方</li>
<li>显示处理器（DPU：Display Processing Unit）：解释执行绘图命令，驱动电子枪绘图</li>
<li>CRT</li>
</ul>
<p><font size="4" color="red">随机扫描显示是怎么实现的（显示原理）？</font><br>应用程序发出绘图命令，这些绘图命令被解析成为显示处理器可以接受的命令格式，存储在刷新储存器中。刷新存储器中的所有绘图命令组成一个显示文件，交由显示处理器DPU解释执行，驱动电子枪在屏幕上绘图。如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/14772160395.png" alt=""><br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721604001.png" alt=""></p>
<hr>
<p><font size="5" color="orange">光栅扫描显示系统</font></p>
<p><font size="4" color="red">什么是光栅扫描？</font><br>电子束按<strong>固定</strong>的扫面线和扫描顺序从左到右、自上而下进行扫描。<br>【注】：</p>
<ul>
<li>扫描线：一条水平线</li>
<li>帧：一次扫描生成的图像</li>
<li>水平回扫期：水平线间的回扫期</li>
<li>垂直回扫期：帧间的回扫期（从上到下的扫描期）</li>
<li>分辨率：电子束按固定的扫描顺序扫描N条扫描线，每条扫描线有M个像素，则M*N为显示器的分辨率。</li>
</ul>
<p><font size="4" color="red">光栅扫描过程图示</font><br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721604056.png" alt=""></p>
<p><font size="4" color="red">光栅扫描显示系统主要靠哪些东西来实现（逻辑部件）</font><br>光栅扫描显示系统的主要逻辑部件是：帧缓冲存储器、视频控制器、显示处理器、显示器（CRT、液晶）。如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721604117.png" alt=""><br>下面分别来了解一下这些部件：</p>
<ul>
<li>帧缓冲存储器：<br>简称帧缓存，是显存中的部分存储单元。用于存储屏幕上的颜色值，所以帧缓存中的存储单元与屏幕上的像素一一对应（总数也是相同的），帧缓存中存储单元的数值决定了对应屏幕像素的颜色，存储单元的位数自然也就决定了屏幕像素颜色有多少种。如黑白显示系统的帧缓存存储单元位数就应该是1位。对于真彩色系统应该是每种基色有8位，所以真彩色的帧缓存存储单元位数应该是24位，显示系统最多可显示2^24种颜色<br>若分辨率为M*N、颜色个数为K，则帧缓存大小V&gt;=M*N*[log2K]（向上取整）<br>【注：】<ul>
<li>目前PC机的显存容量一般都在256M以上，但是对于1024*1024的真彩色系统需要的缓存大小只有：1024*1024*log2(2^24)/8=3M字节，为何显存容量远大于真彩色需要的存储容量呢？这是因为显存不止包括像素的颜色信息，还包括深度缓存、纹理内存等等。</li>
</ul>
</li>
<li>视频控制器：<br>负责解释执行帧缓存中的绘图命令，驱动电子枪在荧光屏上绘图，实现刷新。<br>具体工作过程如下：<br>刷新周期开始，依扫描次序依次取出帧缓存单元的数值，放入像素值寄存器，列对应的地址寄存器的地址加1，如此重复，直到该扫描线上的最后一个元素，转下一行，列地址置0，行地址加1。<br>其逻辑结构如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721604166.png" alt=""></li>
<li>显示处理器（GPU）：<br>用于代替CPU完成部分图形处理功能，如扫描转换、几何变换、裁剪、光栅操作、纹理映射等等。</li>
</ul>
<p><font size="4" color="red">光栅扫描显示系统的优缺点</font></p>
<ul>
<li>优点：<br>成本低、容易绘制填充图形、色彩丰富、刷新频率一定（与图形的复杂程度无关）、易于修改图形（其实就是修改绘图命令）</li>
<li>缺点：<br>需要扫描转换，这样复杂图形计算量会比较大；会产生混淆（走样）。<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721604335.png" alt=""></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 计算机图形学 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 图形显示系统 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[图形学概述]]></title>
      <url>/2016/10/18/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E6%A6%82%E8%BF%B0/</url>
      <content type="html"><![CDATA[<p><font size="5" color="orange">什么是计算机图形学？</font><br><a id="more"></a></p>
<ul>
<li>ISO定义：通过计算机将数据转换为图形，并在专门的显示设备上进行显示，而计算机图形学就是研究其中的原理、方法和技术的学科。</li>
<li>IEEE定义：Computer graphics is the art or science of producing graphical images with the aid of computer。</li>
<li>说白了，计算机图形学就是应用计算机技术进行图形的生成、处理和输出。</li>
</ul>
<p>那么什么是图形呢？图形有哪些特征吗？</p>
<hr>
<p><font size="5" color="orange">什么是图形？</font><br>凡是能在人的视觉系统中产生视觉映像的客观对象都是图形，在计算机中是指可以用计算机生成、显示、存储、处理并输出的对象。<br>【注】：图形也可以是完全虚构的物体（如假想中的天堂）。</p>
<ul>
<li>图形的基本要素<ul>
<li>几何要素：如点、线、多边形、多面体等。主要用于刻画对象的轮廓、形状。</li>
</ul>
</li>
<li>非几何要素：如颜色、纹理等。主要用于刻画物体的颜色、材质等等。</li>
</ul>
<p>那么在计算机中图形是以何种方式显示的呢？</p>
<hr>
<p><font size="5" color="orange">计算机图形的表示方法？</font><br>首先要明白，计算机肯定都是通过一个一个的像素点的颜色来显示图形的。但是对于要显示的图形，根据记录其像素点的方式不同，计算机图形的表示方法分为点阵法和参数法。</p>
<p><font size="4" color="red">点阵法</font><br>记录图形中的所有像素点（包括轮廓和其内部、外部的所有点，也就是带背景的图形），显示时按行按列依次快速显示出每个像素点，就能看到完整的一幅图形。<br>其实以这种方式表示的图形通常称为图像（image）。</p>
<p><font size="4" color="red">参数法</font><br>只记录图形的的形状参数（方程或表达式的系数、线段的端点坐标等）、属性参数（颜色、线型等），显示时通过计算来确定哪些像素点应该位于图形上，再根据属性参数绘制出相应的点，最后便能形成完整的图形（如圆可以通过圆心坐标、半径和颜色来表示）。<br>以这种方式表示的通常才称为图形（graphics）。</p>
<p>不难看出，点阵法表示的计算机图形数据量很大，不需要复杂的计算；而参数法表示的计算机图形数据量很小，显示时需要复杂的计算。更多比较，请看下图：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721544394.png" alt=""></p>
<p>搞清了什么是图形和计算机图形学，那么计算机图形学究竟是研究哪些东西呢？</p>
<hr>
<p><font size="5" color="orange">计算机图形的研究内容</font></p>
<ul>
<li>图形系统（硬件、软件、标准化）。</li>
<li>基本图形生成。比如如何显示点、线段、多边形、圆等几何图形。</li>
<li>图形处理。比如几何变换（图形动起来）、投影变化（如何显示三维图形）、真实感图形（关照、阴影等）。</li>
<li>物体造型（建模）。比如实体表示、曲线曲面、真实感等等。</li>
</ul>
<hr>
<p>下面来看一看图形学的发展历史吧！</p>
<p><font size="5" color="orange">计算机图形学的发展史</font><br>分三个方向来回顾这段历史：学科发展历程、硬件发展历程、软件以软件标准的发展历程（该部分略，可问度娘）。</p>
<p><font size="4" color="red">学科发展历程</font></p>
<ol>
<li>20世纪50年代，计算机图形学诞生。1950年，第一台图形显示器诞生，当时是作为麻省理工旋风1号计算机的附件。CRT的出现为计算机生成并显示图形提供了可能。而后MIT（麻省理工）林肯实验室，在Whirlwind上开发SAGE空中防御系统，通过光笔在屏幕上指点实现与系统交互。标志着交互式图形技术诞生。</li>
<li>20世纪60年代，计算机图形学这一门学科被确立。1962年，MIT林肯实验室，Ivan E.Sutherland在他的博士论文中首次提出”Computer Graphics”一词。从此，Sutherland被称为计算机图形学之父。</li>
<li>1962年，雷洛汽车公司的工程师Pierre Bezier提出Bezier曲线、曲面的理论。</li>
<li>1964年，MIT的Steven A.Coons教授提出了超限插值的新思想，通过插值四条任意的边界曲线来构造曲面。</li>
<li>19实际70年代，光栅图形学迅速发展。区域填充、裁剪、消隐等基本图形概念及其相应算法纷纷诞生。</li>
<li>在真实感图形学上，1970年，Bouknight提出了第一个光反射模型；1971年，Gourand提出”漫反射+插值”的思想，被称为Gourand明暗处理。1975年，Phong提出了著名的简单关照模型-Phong模型。</li>
<li>19世纪80年代，计算机图形学开始实用化。大量图形应用软件出现，但是图形硬件设备却是十分昂贵。<br>8 .19世纪90年代，计算机图形学被广泛应用。多用于多媒体技术、人工智能、科学计算可视化、虚拟现实、三维造型技术等领域。而且硬件集成化也大幅度提高：GPU出现。</li>
</ol>
<p><font size="4" color="red">硬件发展历程</font></p>
<ul>
<li>图形显示设备的发展<ol>
<li>20世纪60年代中期，主要是画线显示器，需要刷新。具有较高的分辨率和对比度，良好的动态性能。但设备昂贵。</li>
<li>20世纪60年代后期，主要是存储管式显示器，许需要刷新。价格较低，但是不具有动态修改图形的功能，不适合交互式。</li>
<li>20世纪70年代初，主要是刷新式光栅扫描器。以点阵形式表示图形，使用专用的缓冲区存放点阵，由视频控制器负责刷新扫描。大大推动了交互式图形技术的发展。</li>
<li>20世纪90年代至今，主要是液晶和等离子显示器，和一些新的显示设备（如立体显示器）。</li>
</ol>
</li>
<li>图形输入设备的发展<ol>
<li>控制开关、穿孔纸等。</li>
<li>键盘。</li>
<li>二维定位设备。如鼠标、光笔、触摸屏、语音、操纵杆等。</li>
<li>三维输入设备。如空间球、数据手套、用户手势和表情等（将来）。</li>
<li>用户思维（将来）。</li>
</ol>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 计算机图形学 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 图形学概述 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OpenGL1：OpenGL概述及环境配置]]></title>
      <url>/2016/10/18/OpenGL1%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<p><font size="5" color="orange">OpenGL简介</font><br><a id="more"></a><br>OpenGL是一个功能强大的图形库，提供了很多操作图形和图片的API（Application Programming Interface），用户可以用它很方便地开发所需要的有多种特殊视觉（如光照、透明、纹理、阴影）的三维图形。<br>OpenGL库的实际开发者通常是各大显卡厂商。Khronos Group公开提供了所有OpenGL的规范文档，可以从<a href="https://www.opengl.org/registry/doc/glspec33.core.20100311.withchanges.pdf" target="_blank" rel="external">这里</a>看到OpenGL3.3规范文档。<br>OpenGL具有很好的跨平台性，2012年8月已经更新到4.3版本。</p>
<p><font size="4" color="red">OpenGL组成</font><br>OpenGL主要由OpenGL基本函数库、OpenGL实用函数工具包、WGL库（OpenGL的Windows扩展库）</p>
<ul>
<li>OpenGL的基本函数库：主要包括三个：OpenGL核心库、OpenGL实用库、OpenGL辅助库。<ul>
<li>OpenGL核心库（GL）<br>这部分函数常用于常规的、核心的图形处理，是OpenGL的核心部分；包含300多个函数，函数名前缀都是”gl”。</li>
<li>OpenGL实用库（GLU）（Utility）<br>这部分函数通过调用核心库的函数，为开发者提供相对简单的用法，实现一些较为复杂的操作。如绘制茶壶等简单形体。包含大约50个函数，函数名前缀都是”glu”。</li>
<li>OpenGL辅助库（GLAUX）（Auxiliary）<br>这部分函数提供窗口管理、输入输出处理以及绘制一些简单的三维物体，包含约30个函数，函数名前缀都是”aux”。</li>
</ul>
</li>
<li>OpenGL实用函数工具包（GLUT：OpenGL Utility Toolkit）：由Mark Kilgard开发。主要提供窗口系统操作功能，如创建窗口、鼠标和键盘输入、菜单、事件驱动等等。包含大约30个函数，函数名前缀都是glut。<br>【注】：glut中的窗口管理函数不依赖于操作系统，可以在所有的OpenGL平台上运行。</li>
<li>WGL库：OpenGL对窗口系统的扩展<ul>
<li>用于连接OpenGL和Windows，在Windows平台上设置OpenGL环境</li>
<li>并不是所有函数前缀都是”wgl”</li>
<li>只能在Windows上运行</li>
</ul>
</li>
</ul>
<p><font size="4" color="red">OpenGL主要功能</font></p>
<ul>
<li>基本几何形状<br>绘制点、线段、多边形、Bezier曲线、简单形体等。</li>
<li>属性<br>设置颜色、线型（实、虚等）…</li>
<li>变换<br>几何变换：平移、旋转、缩放；<br>投影变换：正投影、透视投影</li>
<li>交互<br>键盘和鼠标</li>
</ul>
<p>&nbsp;  </p>
<hr>
<p><font size="5" color="orange">OpenGL的两种开发模式</font><br>OpenGL的两种开发模式是：快速模式和core-profile（核心模式）。</p>
<p>在OpenGL3.2版本以前，都是使用快速模式，也叫fixed function pipeline，固定函数输送管道，顾名思义，快速模式是一种简单易用的绘图方式，容易使用容易理解，但是效率低下，而且大多数功能都被封装了，开发者难以获得更多的图形控制权。所以从3.2版本开始，快速模式不建议被使用了，出现了core-profile（核心模式），它是OpenGL规范的一部分，移除了所有过时的不建议使用的功能。当使用core-profile模式时，OpenGL会强制让我们使用现代函数；如果使用了过时的或不建议的函数，是会报错的。</p>
<p>使用core-profile，需要开发者真正懂得OpenGL，而且还要掌握图形编程，难度是提高了，但是却提供了更高的灵活性和效率，还能让我们更好的理解图形编程。由于之后版本的OpenGL都是以3.3为基础的，核心机理并没有变化，而且大多数开发情况下都需要支持较低的显卡，低显卡可能不支持最新版的OpenGL，所以我们也使用OpenGL3.3版本了。<br>&nbsp;  </p>
<hr>
<p><font size="5" color="orange">OpenGL特性：支持扩展</font><br>OpenGL是支持扩展的。如果显卡厂商在某个时候推出了一个新技术或渲染优化，   那么图形开发者就可以通过扩展来直接使用该新技术，而不需要等待新版本的OpenGL发布。事实上，当一个扩展被证明很流行或很有用时，它就会变成未来OpenGL的一部分。</p>
<p>一般使用扩展的代码如下：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">if</span><span class="token punctuation">(</span>GL_ARB_extension_name<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//GL_ARB_扩展名</span>
<span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//执行硬件支持的新特性</span>
<span class="token punctuation">}</span>
<span class="token keyword">else</span>
<span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//不支持该扩展，使用老办法</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>&nbsp;  </p>
<hr>
<p><font size="5" color="orange">OpenGL的本质</font><br>OpenGL本身其实是个大状态机，也就是说它定义了一大堆OpenGL该做何操作的变量。</p>
<p>OpenGL的状态通常称为OpenGL环境（context）。我们通常都是设置一些选项，操作一些缓冲，来改变它们的状态（即环境），然后使用当前环境做渲染。</p>
<p>使用OpenGL时，会遇到多种<strong>状态改变函数</strong>，这些函数会改变环境；还会遇到多种<strong>状态使用函数</strong>，这些函数是基于当前状态来执行一些操作。<br>&nbsp;  </p>
<hr>
<p><strong>OpenGL的库是用C写的</strong>，所以OpenGL无法表示诸如对象这些在更高级语言中才有东西。于是OpenGL开发了几种自己特有的抽象概念，对象就是其中一个。</p>
<p><font size="5" color="orange">OpenGL中的对象</font><br>OpenGL的对象是一些可选项（即变量）的集合，是OpenGL状态的一部分。那么OpenGL中的对象怎么定义和使用呢？</p>
<p>OpenGL中定义对象的流程大致如下：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token comment" spellcheck="true">//OpenGL的状态</span>
<span class="token keyword">struct</span> OpenGL_Context
<span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">object</span><span class="token operator">*</span> object_Window_Target<span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//创建对象</span>
GLuint objectId <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token function">glGenObject</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>objectId<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//把对象绑定到目标上</span>
<span class="token function">glBindObject</span><span class="token punctuation">(</span>GL_WINDOW_TARGET<span class="token punctuation">,</span> objectId<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//为当前绑定到GL_WINDOW_TARGET的对象设置选项</span>
<span class="token function">glSetObjectOption</span><span class="token punctuation">(</span>GL_WINDOW_TARGET<span class="token punctuation">,</span> GL_OPTION_WINDOW_WIDTH<span class="token punctuation">,</span> <span class="token number">800</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">glSetObjectOption</span><span class="token punctuation">(</span>GL_WINDOW_TARGET<span class="token punctuation">,</span> GL_OPTION_WINDOW_HEIGHT<span class="token punctuation">,</span> <span class="token number">600</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//把目标绑定的对象恢复为默认（解绑）</span>
<span class="token function">glBindObject</span><span class="token punctuation">(</span>GL_WINDOW_TARGET<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面的代码是在OpenGL中会经常遇到的工作流。通过glGenObject函数创建一个对象，保存到后台内存中，并且用一个无符号整数来表示这个对象，相当于是给这个对象起了个名字（对象id，就像人的身份证号），然后把这个名字（整数）存入变量objectId中。接着用glBindObject方法把对象绑定到一个目标上（代码中是把目标定为了GL_WINDOW_TARGET）。再下一步就是设置目标的选项（这些设置会被保存到对象中），最后把目标绑定的对象id设置为0，即解绑对象。至此，便完成了对一个对象的属性设置。</p>
<p>【注】：</p>
<ul>
<li>上面的代码只是在描述OpenGL的操作原理，并不是OpenGL中的实际函数，只是伪码。</li>
<li>当使用OpenGL时，建议使用OpenGL定义的自由类型。在写float时在前面加GL；int、char、bool等等同样处理。应为不同的操作系统可能对于各自的类型有不同的内存布局，而OpenGL的GL自有类型的内存布局是跨平台的。所以使用OpenGL的自有类型可以保证我们的应用可以跨平台。</li>
</ul>
<p>好像还有点懵，这个对象有何意义？打个比方，上面对对象的定义流程就好像是：拿出来一张纸，先给它编个号（对应创建对象），说这是第一张纸，然后拿这张纸去找到一个橡皮泥（对应绑定目标），说我要把这个橡皮泥变成什么什么样，然后在纸上画出梦想中的橡皮泥（设置选项），橡皮泥捏好了以后，就用不上这张纸了（解绑），但是还可以根据这张纸（对象）再去捏出很多一模一样的橡皮泥（目标）啊！不用再去找张纸画画了，这就是对象的好处。<br>&nbsp;  </p>
<hr>
<p>下面来看看，OpenGL环境应该咋配置。先看VC++6.0下的：</p>
<p><font size="5" color="orange">VC6.0下的OpenGL环境配置</font></p>
<p><font size="4" color="red">使用OpenGL辅助库GLAUX时的环境配置：</font></p>
<ol>
<li>打开工程，工程 → 设置 → 连接 → 分类选输入 → 在对象/库模块文本框中加上opengl32.lib glu32.lib glaux.lib（注意用空格分开） → 确定。如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721615911.png" alt=""></li>
<li>Windows平台下的源文件需要加上以下头文件：<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token preprocessor property">#include &lt;window.h></span>
<span class="token preprocessor property">#include &lt;GL/gl.h></span>
<span class="token preprocessor property">#include &lt;GL/glu.h></span>
<span class="token preprocessor property">#include &lt;GL/glaux.h></span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
一般还需要：<code>#include &lt;stdio.h&gt;、#include &lt;stdlib.h&gt;、#include &lt;math.h&gt;</code></li>
</ol>
<p><font size="4" color="red">使用OpenGL实用函数工具包GLUT时的环境配置：</font></p>
<ol>
<li>文件拷贝（这三个文件百度很容易找到）：<br>头文件glut.h拷贝到：\VC6.0安装目录\VC98\Include\GL目录下<br>连接库glut32.lib拷贝到：\VC6.0安装目录\VC98\Lib目录下<br>运行库glut32.dll拷贝到：C:\Windows\SysWOW64目录下（这时64位系统下的，如果是32位系统应该拷贝到：C:\Windows\System32）</li>
<li>打开工程，工程 → 设置 → 连接 → 分类选输入 → 在对象/库模块文本框中加上opengl32.lib glu32.lib glut32.lib（注意用空格分开） → 确定。如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721615963.png" alt=""></li>
<li>在源文件里加上头文件：<code>#include &lt;GL/glut.h&gt;</code></li>
</ol>
<p>【注】：OpenGL不需要单独下载安装，因为OpenGL是跟着驱动走的，只要装了显卡驱动，一般都会有OpenGL的。<br>&nbsp;  </p>
<hr>
<p>但是原生的OpenGL不支持窗口管理、跨平台等功能，所以就有了很多热心人写了工具来支持这些功能，比如glut、glfw等等。 它们都是一些函数库，这些库免去了所有跨平台的问题，同时也提供了窗口、OpenGL环境等渲染所需的功能。比较流行的库主要有GLUT、SDL、SFML、GLFW。但是glut太老了，最后一个版本都是90年代的。这里我们主要用GLFW。</p>
<p><font size="5" color="orange">GLFW</font><br>GLFW（OpenGL For Window）是一个轻量级的、开源的、跨平台的library，是一个跨平台的OpenGL应用框架，支持OpenGL和 OpenGL ES，用于管理窗口、读取输入、处理事件等，并且可以给我们创建一个OpenGL环境。</p>
<p>下面将介绍GLFW的构建过程。</p>
<p><font size="5" color="orange">构建GLFW</font></p>
<p><font size="4" color="orange">下载GLFW源文件</font><br>GLFW可以从<a href="http://www.glfw.org/download.html" target="_blank" rel="external">官网</a>下载。当然是可以直接上面已经编译好的二进制文件，但是反正它有源码了，我们自己来编译一把，体验多多。而且使用源码编译出来的glwf库，可以完美适应自己的CPU/OS，编译好的二进制库就不一定了，所以先下载源码把（如果是下载编译好的二进制文件，尽量下32位的，64位可能会有很诡异的错误）。</p>
<p>但是从源码编译也有一个问题：不是所有人的IDE（ Integrated Development  Environment）都是相同的，这就意味着用自己的IDE编译出来的库或其他文件可能别人并不能用，项目整合时会出现不兼容。比如有的用VS，有的用XCode，在VS上面写的项目要与和在XCode上面写的项目进行整合，但是IDE不同，很多项目文件会不兼容，比较原始的办法就是把VS上的源文件一个一个复制到XCode上，再在XCode上编译（或者相反），如果工程很大源文件很多，这样做是很要命的。而CMake可以根据源文件和一些简单的配置信息，生成对应OS下的IDE的项目文件，比如可以在用CMake把VS下的源文件直接整体编译为XCode项目，然后就可以直接和别人的XCode项目进行整合，还是很节省效率的。</p>
<p><font size="4">CMake</font><br>CMake是一个可以根据源文件生成多个IDE下的项目/解决方案的工具（CMake可以从这里<a href="https://cmake.org/download/" target="_blank" rel="external">下载</a>），我用的是Win32-x86 Installer。</p>
<p>安装完成后进入\bin文件夹选择cmake-gui.exe，再分别选择源码文件夹和用于生成项目的目标文件夹（需要自己新建一个文件夹），如下图：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147912521589.png" alt=""><br>点击Configure按钮，CMake会要求选择目标IDE环境（即想要生成哪种IDE下的项目/解决方案），由于我用的是VS2015，所以选择了VS 14 2015，如下图：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147912561803.png" alt=""><br>点击finish，  当出现configuring done后，点击generate，出现generating done以后，在新建的build文件夹内就可以看到生成的项目文件了。我的文件夹如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147912612555.png" alt=""></p>
<p><font size="4" color="red">编译</font><br>但是这些项目文件中还没有Debug文件夹，无法拿到我们进行OpenGL编程所需要的库文件，那么打开GLFW.sln编译一下把，在VS编辑器菜单上点击生成/生成解决方案（Build/Build Solution），然后编译好的库glfw3.lib就会出现在build/src/Debug文件夹内了。接下来把这个库链接到项目上，就可以进行OpenGL编程了。</p>
<p><font size="4" color="red">链接</font><br>在链接到项目之前，得让IDE能够找到该库文件在哪里。新建一个将要写入OpenGL代码的VS项目，建好后在‘解决方案资源管理器’中右键项目名称，点击属性，在VC++目录（VC++ Directories）中点击包含目录（Include Directories），添加glfw源码的include文件夹。再点击库目录（Library Directories），添加glfw3.lib。现在VS能找到所需要的文件了。我添加的如下图（我是把包括后面glew要用到的文件一起放在文件夹内的，然后直接添加的文件夹。当然也可以向上面说的一个文件一个文件地添加）：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/14791284794.png" alt=""></p>
<p>接下来是链接。还是在属性里点击链接器（Linker）/输入（Input），在附加依赖项（Additional Dependencies）中添加上glfw3.lib，当然还需要把OpenGL也链接上，添加opengl32.lib（只要有显卡驱动一般都会有opengl，opengl32.lib是安装VS时自带的）。如下图：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/1479128480.png" alt=""><br>&nbsp; </p>
<hr>
<p>下面就可以在项目中使用OpenGL的函数了。其实OpenGL只是一种标准/规范，具体怎么实现要看驱动怎么来实现这种显卡支持规范（通俗点说就是提供接口函数），由于存在着很多不同版本的OpenGL驱动，不能够在编译的时候（compile-time）就确定静态链接哪个OpenGL函数，需要在运行时（run-time）指定所需要的函数地址，然后把地址存储在函数指针中以备后用（有点像先声明后定义）。在Windows中类似如下代码段：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token comment" spellcheck="true">//定义函数原型</span>
typedef <span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span>GL_GENBUFFERS<span class="token punctuation">)</span><span class="token punctuation">(</span>GLsizei<span class="token punctuation">,</span> GLuint<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//寻找函数并分配给它一个函数指针</span>
GL_GENBUFFERS glGenBuffers <span class="token operator">=</span> <span class="token punctuation">(</span>GL_GENBUFFERS<span class="token punctuation">)</span><span class="token function">wglGetProcAddress</span><span class="token punctuation">(</span><span class="token string">"glGenBuffers"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//现在可以正常使用OpenGL函数了</span>
GLuint buffer<span class="token punctuation">;</span>
<span class="token function">glGenBuffers</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如你所见，想使用一个OpenGL函数太麻烦了，每个函数都得先被声明。不过为了解决这个问题，一个工具GLEW应运而生。<br>&nbsp;</p>
<hr>
<p><font size="5">GLEW</font><br>GLEW（OpenGL Extension Wrangler Library）是一个跨平台的C++扩展库，基于OpenGL图形接口。由于目前Windows只支持OpenGL1.1的函数，但是现在OpenGL都已反正到4了，要使用这些OpenGL的高级特性，就必须下载最新的扩展，除此之外，不同的显卡公司，也会发布一些只有自家显卡才能支持的扩展函数。如果我们想要使用这些函数，就不得不去寻找最新的glext.h（glext.h使我们可以调用常见的更高版本的OpenGL函数，但是必须在源文件中包含此头文件，并将显卡驱动更新到最新版，glext.h可以在<a href="http://blog.csdn.net/epluguo/article/details/19302003?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">这里</a>找到，不保证最新，也有可能会有些函数接口找不到）。但是有了GLEW扩展库，就再也不用担心找不到这些函数的接口了，因为GLEW能自动识别你的平台所能支持的全部OpenGL高级扩展函数。也就是说，只要包含一个glew.h头文件，就能使用gl、glu、glext、wgl、glx的全部函数。并且GLEW支持目前流行的各种操作系统。当然了，我们之前得问题也迎刃而解了，可以直接使用函数，不用先声明了。下面来看看GLWF环境的搭建。<br>&nbsp; </p>
<hr>
<p><font size="5" color="orange">构建GLEW</font><br>由于GLEW是一个库，所以我们还是需要把它的库文件和头文件链接到我们的项目中。GLEW可以从中<a href="http://glew.sourceforge.net/index.html" target="_blank" rel="external">这里</a>下载。当然还是可以和前面GLFW一样从源码编译出lib库文件。这里我直接下载编译好的二进制文件Binaries了。下载好后找到<code>\glew-2.0.0-win32\glew-2.0.0\lib\Release\Win32</code>路径下的glew32s.lib文件，把这个文件添加到项目属性的库目录里，再把<code>\glew-2.0.0-win32\glew-2.0.0</code>路径下的include文件夹添加到项目属性的包含目录里（我是把这里glew和之前glfw的库文件和头文件放在了两个新建文件夹下：一个Libs文件夹、一个Includes文件夹，再把这两个文件夹添加到项目属性的相应目录里。人懒省事~。可以参考前面GLFW标题后链接标题下的第一张图。）</p>
<p>这里使用的是GLEW的静态库，即glew32s.lib。而且GLWF3默认也是被编译为静态库的。</p>
<p>如果使用GLEW的静态库，必须在包含GLEW之前定义一个预处理变量GLEW_STATIC。如下：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token preprocessor property">#DEFINE GLEW_STATIC</span>
<span class="token preprocessor property">#include &lt;GL/glew.h></span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>如果想要使用GLEW的动态库，需要移除对GLEW_STATIC的定义，而且需要把.dll复制到二进制代码所在的文件夹里。<br>&nbsp; </p>
<hr>
<p><font size="5" color="orange">测试环境是否构建成功<font><br>在自己新建的并且构建好环境的项目中，写入如下代码：</font></font></p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token comment" spellcheck="true">// GLEW</span>
<span class="token preprocessor property">#<span class="token directive keyword">define</span> GLEW_STATIC</span>
<span class="token preprocessor property">#include &lt;GL/glew.h></span>

<span class="token comment" spellcheck="true">// GLFW</span>
<span class="token preprocessor property">#include &lt;GLFW/glfw3.h></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">glfwInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">glfwWindowHint</span><span class="token punctuation">(</span>GLFW_CONTEXT_VERSION_MAJOR<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">glfwWindowHint</span><span class="token punctuation">(</span>GLFW_CONTEXT_VERSION_MINOR<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">glfwWindowHint</span><span class="token punctuation">(</span>GLFW_OPENGL_PROFILE<span class="token punctuation">,</span> GLFW_OPENGL_CORE_PROFILE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">glfwWindowHint</span><span class="token punctuation">(</span>GLFW_RESIZABLE<span class="token punctuation">,</span> GL_FALSE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
如果出现了很多未定义引用错误，就是还没有构建成功了<span class="token operator">~</span>。
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>【注】：</p>
<ul>
<li>静态链接库是会在编译的时候整合到我们的二进制文件中，这样做的好处是不必保持跟踪这额外的文件，只需要发布单独的二进制文件。缺点是最后的可执行文件会变得更大，而且当一个库有一个更新的版本时需要重新编译整个应用程序。</li>
<li>动态链接库就是.dll或.so文件，库的代码是与我们的二进制代码分开存在的，它可以使最终的可执行文件更小，更新的时候也更容易，不足之处是必须在最终的应用程序中发布dll文件。<br>&nbsp; </li>
</ul>
<hr>
<p>参考文献：<a href="https://learnopengl.com/" target="_blank" rel="external">LearnOpenGL</a></p>
]]></content>
      
        <categories>
            
            <category> OpenGL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OpenGL配置 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[进程的描述与控制]]></title>
      <url>/2016/10/14/%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8F%8F%E8%BF%B0%E4%B8%8E%E6%8E%A7%E5%88%B6/</url>
      <content type="html"><![CDATA[<p><font size="5" color="orange">程序的并发执行</font><br><a id="more"></a><br>程序的并发执行：宏观上，用户看到多个程序同时执行，向前不间断地推进；微观上，任意时刻一个CPU上只能有一个程序在执行。<br>程序不加控制地并发执行的结果可能不是唯一的，举个例子：</p>
<ul>
<li>ex：counter是全局变量，初值为0，现进程p1和进程p2都对counter加1：<pre class="line-numbers language-csharp"><code class="language-csharp">进程p1：<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>counter<span class="token operator">=</span>counter<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
进程p2：<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>counter<span class="token operator">=</span>counter<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
但是我们知道这只是高级语言的程序语句，计算机却是逐指令进行执行的，所以还需要把上诉高级语言转换成编译后的基本指令序列：（其中r1和r2是两个通用寄存器）<pre class="line-numbers language-csharp"><code class="language-csharp">进程p1：
r1<span class="token operator">=</span>counter<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//将counter对应内存的数据送寄存器r1</span>
r1<span class="token operator">=</span>r1<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//累加1</span>
counter<span class="token punctuation">:</span><span class="token operator">=</span>r1<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//将r1中的累加结果送往counter对应的内存中</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-csharp"><code class="language-csharp">进程p2：
r2<span class="token operator">=</span>counter<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//将counter对应内存的数据送寄存器r1</span>
r2<span class="token operator">=</span>r2<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//累加1</span>
counter<span class="token punctuation">:</span><span class="token operator">=</span>r2<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//将r1中的累加结果送往counter对应的内存中</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
当进程p1和进程p2逐指令并发执行时，若指令执行顺序如下：<pre class="line-numbers language-csharp"><code class="language-csharp">r1<span class="token operator">=</span>counter<span class="token punctuation">;</span>
r1<span class="token operator">=</span>r1<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>  
r2<span class="token operator">=</span>counter<span class="token punctuation">;</span> 
r2<span class="token operator">=</span>r2<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> 
counter<span class="token punctuation">:</span><span class="token operator">=</span>r2<span class="token punctuation">;</span>
counter<span class="token punctuation">:</span><span class="token operator">=</span>r1<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
则执行后的结果是counter等于1，显然这不是我们想要的结果，原因就在于程序的并发执行上。<br>若指令顺序如下：<pre class="line-numbers language-csharp"><code class="language-csharp">r1<span class="token operator">=</span>counter<span class="token punctuation">;</span>
r1<span class="token operator">=</span>r1<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>  
counter<span class="token punctuation">:</span><span class="token operator">=</span>r1<span class="token punctuation">;</span>
r2<span class="token operator">=</span>counter<span class="token punctuation">;</span> 
r2<span class="token operator">=</span>r2<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> 
counter<span class="token punctuation">:</span><span class="token operator">=</span>r2<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
则执行后的结果是counter等于2。而程序并发执行时，两个程序的指令谁先执行谁后执行是不确定的，也就造成了程序并发执行时结果的不唯一性。</li>
</ul>
<hr>
<p><font size="5" color="orange">进程的描述</font><br>因为并发执行的程序可能是同一个程序在不同数据集合上的执行，也可能是不同的程序在不同的数据集合上的执行，它们共享系统资源，所以在并发执行中，仅仅用程序来作为描述单位是不够的，还应该加上程序的数据集合。所以，进程破壳出生了。</p>
<p><font size="4" color="red">什么是进程</font></p>
<ul>
<li>简单的定义：进程是程序在一个数据集合上的运行过程。</li>
<li>详细的定义：进程是由正文段、用户数据段、系统数据段共同组成的一个执行环境（正文段存放被执行的机器指令；用户数据段存放进程在执行时直接进行操作的所有数据；系统数据段存放程序的运行环境，是进程实体最重要的一部分）。</li>
</ul>
<p><font size="4" color="red">进程和程序的比较</font></p>
<ul>
<li>程序是静态的，进程是动态的 。程序是一组二进制代码，而进程对应着程序执行的过程，程序执行过程中运行环境是不断变化的。</li>
<li>几个进程能并发地执行相同的程序代码，同一个进程也能顺序地执行几个程序（进程和程序是多对多的关系）。</li>
</ul>
<p><font size="4" color="red">进程控制块PCB</font><br>操作系统中那么多进程，用什么来唯一标识呢？答案是<strong>进程控制块</strong>（PCB，Process Control Block），一种操作系统管理进程所使用的数据结构。<br>进程控制块用于描述进程及控制进程运行所需的全部信息。每个进程都有PCB，它是操作系统感知进程存在的唯一标志。</p>
<p>那么进程控制块PCB中包含哪些内容呢？</p>
<ul>
<li>进程标识符信息PID（Process Identifier）<br>PCB之所以能够唯一标识某个进程，就是依赖于PCB中的进程标识符，它用于唯一标识一个进程。当然出于其它一些方面的性能考虑，PCB中同时存有本进程的标识符、其父进程的标识符、子进程的标识符。</li>
<li>处理机状态信息<br>所有进程共享处理机CPU，当一个进程需要被暂停执行，交出CPU使用权时，需要把当前进程CPU寄存器的值保存到内存中（即PCB中）（保存现场），以防止被覆盖，以便该进程再次获得CPU时，能从内存（PCB）中加载寄存器的值，恢复进程上次被暂停时的CPU环境，使进程能够从上次被中断处继续执行。<br>那么需要保存的CPU状态信息有哪些呢？<ul>
<li>通用寄存器。用户程序可以访问的寄存器，用于暂存信息。</li>
<li>指令计数器。里面存放了CPU要访问的<strong>下一条指令</strong>的地址。</li>
<li>程序状态字PSW。里面含有状态信息，如条件码、执行方式、中断屏蔽标志灯。</li>
<li>用户栈指针。每个用户进程都有一个或多个与之相关的系统栈，用于存放过程和系统调用参数及调用地址。栈指针指向该栈的栈顶。</li>
</ul>
</li>
<li>进程调度信息<ul>
<li>进程状态信息</li>
<li>进程优先级</li>
<li>进程调度所需的其他信息</li>
<li>事件</li>
</ul>
</li>
<li>进程控制信息<ul>
<li>程序和数据的地址</li>
<li>进程同步和通信机制</li>
<li>资源清单</li>
<li>链接指针</li>
</ul>
</li>
</ul>
<p><font size="4" color="red">进程的组织方式</font><br>系统中那么多进程，它们是如何联系在一起的呢？也就是说操作系统是通过怎样的方式把它们聚在一块的？<br>我们先来想想，需要把所有进程拿出来连在一起吗？这当然是很不划算的，因为有的进程是很大的，而且在地址空间上不一定连续，这样做会有很大的时间空间上的开销。上面讲了进程控制块PCB可以唯一标识一个进程，所以把PCB组织在一起就够了。</p>
<ul>
<li>链接方式<br>把系统中具有相同状态的进程的PCB用其中的链接字链接成一个队列，如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721600366.png" alt=""></li>
<li>索引方式<br>系统根据所有进程的状态，建立几张索引表，索引表的每一个表项指向一个PCB的物理块，如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721600412.png" alt=""></li>
</ul>
<p><font size="4" color="red">进程的三种基本状态</font></p>
<ul>
<li>就绪状态<br>就绪状态是进程一旦获得CPU就可以投入运行的状态。把多个处于就绪状态的进程组织在一起，形成一个或多个就绪队列。</li>
<li>执行状态<br>执行状态是进程获得CPU正在运行的状态。（单CPU系统中，任意时刻只会有一个进程处于执行状态）</li>
<li>阻塞状态<br>阻塞状态是进程由于<strong>等待资源或由于某个事件的发生而暂停执行</strong>的状态。把多个处于阻塞状态的进程组织在一起，形成一个或多个阻塞队列。</li>
</ul>
<p>【注】：新创建进程的状态一般被设置为就绪状态</p>
<p>三种基本状态之间的转换关系如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721600462.png" alt=""></p>
<hr>
<p><font size="5" color="orange">进程的控制</font></p>
<p><font size="4" color="red">进程的创建</font><br>创建新进程包括在主存中为进程分配地址空间、建立操作系统用于管理进程的数据结构（如进程控制块）等操作。<br>在Linux系统中，除了0号进程（swapper进程）外的其他进程都是由其父进程创建的。<br>调用创建新进程的系统调用来创建进程的一般步骤为：</p>
<ol>
<li>申请空白PCB</li>
<li>为新进程分配资源</li>
<li>初始化进程控制块</li>
<li>将新进程插入就绪队列</li>
</ol>
<p>Linux2.6.11中创建进程的常用系统调用有fork()。</p>
<p><font size="4" color="red">进程的阻塞</font><br>进程阻塞的简化过程大致如下：</p>
<ol>
<li>暂停进程的执行，将进程的状态改为阻塞状态</li>
<li>将进程插入相应的阻塞队列</li>
<li>转进程调度程序。重新进程进程调度</li>
</ol>
<p><font size="4" color="red">进程的唤醒</font><br>进程唤醒的简化过程大致如下：</p>
<ol>
<li>将进程从阻塞队列中移除</li>
<li>将进程状态由阻塞状态改为就绪状态</li>
<li>将进程插入就绪队列</li>
</ol>
<p><font size="4" color="red">进程的终止</font><br>进程终止的简化工程大致如下：</p>
<ol>
<li>从进程PCB中读进程状态</li>
<li>若进程正在执行状态，则终止进程的执行</li>
<li>若进程有子孙进程，则在大多数情况下需要终止其子孙进程</li>
<li>释放资源</li>
<li>将终止进程的PCB移出（从相应的PCB组织方式中移除）</li>
</ol>
<p>【注】：如果一个进程终止，它的所有子进程也被终止，这称为级联终止，通常是由操作系统进行的。在Unix系统中，如果父进程终止，那么其他所有子进程会把init进程作为它们新的父进程。</p>
<hr>
<p><font size="5" color="orange">线程（Thread）</font></p>
<p><font size="4" color="red">要线程何用？</font><br>由于进程所占的空间太大，并且独享它占有的所有资源，在进程创建、撤销、切换时，都有较大的时空开销，会降低并发程度。所以，引入了线程。让线程作为独立调度和分配的单位，线程不独立占有资源（少量基本资源还是要独占的，如程序计数器、寄存器组、栈等），而是与其他线程共享同一进程的资源，减小了系统时空开销，提高了操作系统的并发程度。</p>
<p><font size="4" color="red">什么是线程</font><br>线程只是比进程更小的执行单位，是被系统独立调度和分派的基本单位。线程和进程及其相似，包括状态、分类、调度切换等等都和进程是一样的。所以不再赘述。<br>【注】：</p>
<ul>
<li>CPU只能感知到内核级线程的存在，而感知不到用户级线程的存在。所以：<ul>
<li>对于用户级线程，CPU的调度单位还是进程；而对于内核级线程，CPU的调度单位是线程</li>
<li>当用户级线程被阻塞时，对应的整个用户级进程也会被阻塞；而内核级线程被阻塞时，对应的内核级进程不会被阻塞，OS内核可以去调度同一个内核级进程内的其他内核级线程</li>
<li>内核级线程进行系统调用只阻塞该线程，而用户级线程进行系统调用要阻塞线程所属的进程</li>
<li>内核级线程的CPU时间以线程为单位进行分配，每个线程独享一个CPU时间片；而用户级线程的CPU时间以进程为单位进行分配，同一进程里的多个线程共享一个CPU时间片</li>
</ul>
</li>
<li>由于用户级线程的调度与切换不需要OS内核的参与，所以用户级线程切换比较快；而内核级线程在调度和切换时需要进行用户态/内核态的切换，所以内核级线程切换比较慢</li>
<li>线程控制块TCB采用链接方式来组织，没有PCB的索引方式</li>
<li>进程之间的通信必须采用OS提供的进程间通信机制，而同一进程中的各线程间可以通过直接读写全局变量来进行通信，无需操作系统的参与</li>
<li>由于一个进程内的多个线程共享资源，所以一个线程对资源的任何修改，都会影响到同一个进程中的其他线程的执行环境。所以，需要对各种线程的活动进行同步，保证多个线程以互斥的方式访问临界资源，使它们互不干扰。如本文开头的加法例子，如果不对共享的临界资源counter加以访问控制，任由线程随意并发执行，则可能会导致错误结果。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 操作系统 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 进程的描述与控制 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[操作系统内核（中断、时钟管理、系统调用）]]></title>
      <url>/2016/10/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8/</url>
      <content type="html"><![CDATA[<p>操作系统内核是指大多数操作系统的核心部分，是把一些执行频率高的模块常驻内存，它是计算机硬件的第一次扩充。<br><a id="more"></a><br>操作系统内核一般包括下述功能：</p>
<ul>
<li>支撑功能。包括中断处理、时钟管理、原语操作（也叫原子操作，是一组在执行过程中不能被中断的操作）等。</li>
<li>资源管理功能。包括进程管理、存储器管理、设备管理等。</li>
</ul>
<hr>
<p><font size="5" color="orange">中断</font></p>
<p><font size="4" color="red">中断是什么？</font><br>中断时改变处理器指令执行顺序的一种事件。该事件与CPU芯片内外部硬件电路产生的电信号相对应。<br>计算机在执行程序的过程中，若出现中断，计算机将停止现行程序的运行，转向对这些中断事件的处理，处理结束后返回被中断处，继续向下执行。</p>
<p><font size="4" color="red">为何需要中断？</font><br>引入中断机制前，当在CPU上执行的程序遇到I/O时，CPU采取反复轮询的方式检测本次I/O是否结束，在轮询的过程中CPU不能完成任何更有效的工作，这是对CPU相当大的浪费。引入中断机制后，一个正在执行的进程p1请求I/O后，CPU启动这次的I/O，然后CPU可以先去执行其他进程（而不用去轮询I/O是否结束），当I/O完成后，通过中断机制使CPU获得进程I/O结束的信息，转中断处理，处理完毕后返回到原来进程p1断点处，继续向后执行。<br>可以看到，在p1进程的I/O过程中，CPU不用去轮询I/O是否结束，而可以转去并行执行其他的进程，这无疑很大程度上减少了CPU的浪费。</p>
<p><font size="4" color="red">中断类型</font><br>中断分为同步中断（也叫内部中断或异常）和异步中断（也叫外部中断）。</p>
<p><font size="4" color="red">同步中断（（程序）内部中断或异常）</font><br>同步中断是当指令执行时由CPU控制单元产生的。之所以称为同步中断，是因为只有在一条<strong>指令终止执行后</strong>CPU才会发出中断，如除法错误、调试、溢出、浮点出错等。</p>
<p><font size="4" color="red">异步中断（外部中断）</font><br>异步中断是由其他硬件设备<strong>依照CPU时钟信号</strong>随机产生的。<br>外部中断又可以分为外部可屏蔽中断和外部不可屏蔽中断。</p>
<ul>
<li>外部可屏蔽中断。这种中断是由I/O设备产生的。有两种方式可以屏蔽中断：一时在Intel80X86的CPU上，把EFLAGS寄存器的IF标志置0，表示关中断，此时CPU忽略所有可屏蔽中断；二是通过对PIC编程来禁止IRQ，即可以告诉PIC停止对给定的IRQ线发布中断。</li>
<li>外部不可屏蔽中断。这种中断是由紧急事件引起的，如硬件故障。</li>
</ul>
<p><font size="4" color="red"> 引起中断的原因有哪些呢？</font></p>
<ul>
<li>人为设置中断。在程序中认为设置中断。</li>
<li>程序性事故。如计算中出现除数为0等情况。</li>
<li>硬件故障。</li>
<li>I/O设备。I/O设备启动后，一旦其准备就绪或完成一次输入/输出，便向CPU发出中断请求。</li>
<li>外部中断。如用户通过键盘来中断现行程序。</li>
</ul>
<p><font size="4" color="red">中断响应有哪些条件吗？</font><br>对于可屏蔽中断，开中断是响应中断的前提。例如，在Intel80X86 CPU上，EFLAGS寄存器的IF标志置1时表示开中断。</p>
<p><font size="4" color="red">什么时候响应中断呢？</font><br>前面我们知道，内部中断是发生在指令执行完毕之后，外部中断是发生在CPU时钟信号之后，而对于外部中断，CPU每<strong>执行完一条指令</strong>都会检测是否有外部中断信号到来。若有则转中断处理。</p>
<p><font size="4" color="red">单重外部中断的处理过程</font><br>CPU在反复执行指令的过程中，每执行完一条指令，都会去检测是否有外部中断信号到来。如果检测到有中断信号，则转中断处理过程。</p>
<ol>
<li>保护断点。把当前要执行的下一条指令的地址保存到内存中，以便中断返回时能把这个地址恢复到程序计数器PC中，使被中断的程序从断点处开始继续执行。</li>
<li>关中断，转中断处理程序，在<strong>中断处理程序中保护现场</strong>。也就是把相关的硬件上下文信息（中断返回恢复被中断程序的执行时，需要写回CPU寄存器的值）保存到内存中。</li>
<li>根据中断向量到中断向量表中找到中断例程的入口地址。</li>
<li>执行中断例程，完成本次中断处理工作。</li>
<li>恢复现场，开中断，CPU返回断点处继续执行被中断的程序。</li>
</ol>
<p><font size="4" color="red">怎么找到中断服务子例程？</font></p>
<ul>
<li>中断向量（中断类型号）<br>中断向量是对不同的中断源到来的信号编号，是一个无符号整数（0~255）。<br>不可屏蔽中断和异常的中断向量是固定的，而可屏蔽中断的向量可以通过对中断控制器编程来改变。<br>可屏蔽中断控制器的IRQ线是从0开始按顺序编号的，因此，第一条IRQ线通常表示成IRQ0。与IRQn关联的Intel缺省向量是n+32。通过向中断控制器端口发布合适的指令可以修改IRQ和向量之间的映射。</li>
<li>中断描述符表（Interrupt Descriptor Table,IDT，又叫中断向量表）<br>它是一个系统表，每一个中断或异常都在表中有唯一对应的表项，其中存有与中断或异常处理子例程入口地址相关的信息。<br>在Linux里，IDT的每个表项占8个字节（64位）。IDT表的起始地址由操作系统执行lidt汇编指令并存放在idtr CPU寄存器中。</li>
</ul>
<p>中断子例程的入口地址相关信息在内存中的地址=idtr中的起始地址 + 8 x 中断向量的值。</p>
<hr>
<p><font size="5" color="orange">时钟管理</font></p>
<p><font size="4" color="red">时钟有何用</font><br>时钟是计算机系统的脉搏，很多计算机的活动都是由定时器测量来驱动的。计算机中当前时间显示功能、即时通讯等与时间相关的软件都需要时钟机制的支持。<br>比如要编译一个很大的工程文件，不可能每次编译都去重新编译所有源文件，而是只编译修改过的那些源程序。判断方法是看a.c最后生成时间是否晚于a.obj的生成时间。</p>
<p><font size="4" color="red">计算机系统中的时钟机制</font><br>计算机系统中其实有两种时钟：RTC（Real-Time Clock）时钟和OS时钟。<br>RTC时钟也叫CMOS时钟，是一块时钟芯片，靠电池供电，为计算机提供计时标准，是最原始、最底层的时间数据。<br>OS时钟是产生于PC机主板上的定时/计数芯片，在开机时有效，由操作系统控制。<br>计算机开机加电后，操作系统通过BIOS获取当前RTC时钟的值，来作为系统的初始时间。操作系统初始化后启用自己的时钟硬件（可编程间隔定时器PIT，Programmable Interval Timer）。PIT按照一定的频率产生时钟中断，来告诉内核又一个时间间隔过去了。<br>RCT时钟和OS时钟关系如下图所示：</p>
<p><font size="4" color="red">OS时钟机制</font><br>OS系统时钟主要有两个作用：</p>
<ul>
<li>保存当前日期和时间，便于用户程序可以通过系统调用获取当前时间，同时也可以由内核把当前时间作为文件和网络包的时间戳</li>
<li>维持定时器，用来告诉内核或用户程序某一时间间隔已经过去了</li>
</ul>
<p>OS时钟依靠时钟硬件（可编程间隔定时器）和时钟软件（时钟中断处理程序）来实现。下面简单介绍一下它俩：</p>
<ul>
<li>可编程间隔定时器PIT（OS时钟硬件）<br>主要有晶振、计数器、保持寄存器三部分构成。如下图所示：<br>晶振按固定频率产生脉冲，每产生一次脉冲计数器值减1，当计数器值减到0时，产生一次时钟中断信号，再把保持寄存器的值送往计数器，使其恢复初始值。这样，PIT就每隔一定时间产生一次时钟信号了。</li>
<li>时钟中断处理程序（OS时钟软件）<br>也叫时钟驱动程序。PIT每产生一次时钟中断信号，OS内核都要执行时钟中断处理程序，来完成如下功能<ul>
<li>维护日期、时间</li>
<li>递减时间片并检查是否为0，防止进程运行超时</li>
<li>对CPU的使用情况记账</li>
<li>递减报警计数器</li>
</ul>
</li>
</ul>
<p>【注】：Linux OS时钟的时间基准是1970.1.1的凌晨0点</p>
<hr>
<p><font size="5" color="orange">系统调用</font></p>
<p><font size="4" color="red">什么是系统调用？</font><br>操作系统内核中有一些预先定义好的模块，系统调用就是让用户程序去调用这些内核模块的接口。如C语言的getpid()函数实际上是调用了在内核态运行的系统调用sysgetpid()，来获得进程标识符。可以看出，系统调用和一般函数调用还是挺像的。</p>
<p><font size="4" color="red">系统调用和一般函数调用的区别？</font><br>先来看看用户态和核心态的概念：<br>当一个进程在用户空间执行时，该进程便处在用户态；当一个进程在具有执行系统核心代码的权利时，该进程便处于核心态。<br>那么系统调用和一般函数调用的区别是什么呢？</p>
<ul>
<li>系统调用运行在核心态，一般函数运行在用户态</li>
<li>用户态进程执行系统调用时（调用前进程处于用户态，调用时进程处于核心态，调用后进程处于用户态），当前进程会被中断，由系统去找到相应的系统调用子程序，并且在核心态下执行，而一般函数调用是不需要中断处理的。</li>
</ul>
<p><font size="4" color="red">Linux中的一些系统调用</font></p>
<ul>
<li>fork：创建一个新进程</li>
<li>clone：按指定条件创建子进程</li>
<li>execve：运行可执行文件</li>
<li>exit：中止进程</li>
<li>getpgid：获取进程组标识号</li>
<li>open：打开文件</li>
<li>creat：创建新文件</li>
<li>close：关键文件描述字</li>
<li>read：读文件</li>
<li>write：写文件</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 操作系统 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OS内核 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[BIOS和微机操作系统的启动过程]]></title>
      <url>/2016/10/09/BIOS/</url>
      <content type="html"><![CDATA[<p><font size="5" color="orange">什么是BIOS？</font><br><a id="more"></a><br>BIOS，Basic Input Output System基本输入输出系统，是最接近硬件的软件之一，是固化在计算机主板上的ROM芯片中的一组程序，直接对计算机系统中的输入输出设备进行硬件级的控制，为其他软件程序与硬件设备之间建立连接提供了基础，包含基本的中断服务程序、系统设置程序、加电自检程序和系统启动自举程序。<br>BIOS程序是计算机开机加电后第一个开始执行的程序，完成硬件检测及基本的设置功能，故BIOS为操作系统及其他自启动程序的开发和加载提供了接口，是计算机系统中最基础的系统软件。</p>
<hr>
<p><font size="5" color="orange">BIOS的住处：BIOS芯片</font><br>上面已经介绍过，BIOS程序被固化在ROM芯片中，所以保存BIOS程序的ROM加上其配套的电路就构成了BIOS芯片。<br>BIOS芯片通常是一块32针的双列直插式长方形或正方形集成电路，表面贴有“BIOS”字样的标签，如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721617506.png" alt=""><br>BIOS芯片根据其ROM存储器特点的不同，分为EPROM和EEPROM两种类型。</p>
<ul>
<li>EPROM（Erasure Program Read Only Memory）可擦除可编程只读存储器，其芯片中央有一个透明的小窗口，通过这个小窗口可以使用紫外线光将芯片上保存的信息擦除掉（所以当不需要擦除时，就需要一块不透明的标签将已保存了信息的EPROM芯片的紫外线窗口封住）。在向EPROM写入内容时，必须先用紫外线擦除器将EPROM中的信息清除掉，即将EPROM中的每个信息存储比特单元都变成“1”状态。</li>
<li>EEPROM（Electricity Erasure Program Read Only Memory）电可擦除可编程只读存储器，在通常情况下，EEPROM也是只读的，当需要写入内容时，只要在指定的引脚上加一个高电压即可快速写入和擦除。<ul>
<li>另外还有一种EEPROM就是现在主板上常见的FLASHROM（闪速存储器，闪存），其读写速度更快更可靠，而且使用单电压进行读写和编程，为便携式设备的在线操作提供了极大的便利，所以广泛应用在计算机主板上。</li>
</ul>
</li>
</ul>
<p>通常，在Intel486以及486以下档次计算机中使用的BIOS芯片基本上采用的是EPROM芯片，而586及以上档次计算机中使用的基本上都是EEPROM。</p>
<hr>
<p><font size="5" color="orange">BIOS程序的组成</font><br>前面已经介绍过，BIOS程序包括中断服务程序、系统设置程序、加电自检程序、系统启动自举程序。下面来看看这几种程序的详细介绍。</p>
<p><font size="4" color="red">BIOS中断服务程序</font></p>
<ul>
<li>什么是中断？<br>中断是改变处理器执行指令顺序的一种事件，这样的事件与CPU芯片内外部硬件电路产生的电信号相对应。<br>中断发生时，计算机停止现行程序的运行，转向对这些中断事件的处理，处理结束后再返回到现行程序的中断处，继续往下执行。</li>
<li>在哪里对中断事件进行处理的？<br>CPU对中断的处理是转到中断服务程序来进行的</li>
<li>什么是中断服务程序？<br>中断服务程序是系统开发者针对某种中断事件事先编写好的处理程序，并且把他们保存在内存的某个地址空间里。</li>
<li>那么怎么根据中断源找到相对应的中断服务程序呢？<br>中断源在向CPU进行中断请求时，会告诉CPU一个中断类型号（在x86系统中是0~255之间的整数），每个中断类型号都会对应一个中断服务程序。那么怎么根据中断类型好去找它命中注定的中断服务程序呢？其实所有中断服务程序的入口地址（起始地址）都被保存在中断向量表（一维连续的一段内存空间）中，中断向量表的每一个表项的长度都是固定一样的。所以让中断类型号和中断向量表的表项依次一一对应不就行了嘛？根据中断类型 x 中断向量表项长度 + 中断向量表起始地址，就可以找到对应的表项了，然后再从里面取出中断服务程序的起始地址，跳转到该地址，就可以执行中断服务程序进行中断处理了。</li>
<li>BIOS包含哪些中断服务程序呢？<br>显示服务程序（INT 10h）、直接磁盘服务程序（INT 13h）、键盘服务（INT 16h）等等。</li>
</ul>
<p>这些BIOS中断服务程序可以为微型计算机软件和硬件之间提供可编程接口，是软件和硬件的中间桥梁。DOS、Windows等操作系统对软盘、硬盘、光驱与键盘、显示器等外围设备的管理就是建立在系统BIOS的基础上的。当然，程序员还可以直接调用BIOS中断服务程序。</p>
<p><font size="4" color="red">BIOS系统设置程序</font><br>如果你给自己的电脑装过操作系统，会知道<br>当开机后狂按某个（F2、F12等等）按键时，会进入一些设置界面，这里其实就是一些BIOS系统设置。<br>微型计算机中各部分组建的配置参数是放在一块可读写的COMSRAM芯片（简称CMON）中的，它保存着系统CPU、软/硬盘驱动器、显示器、键盘等部件的配置信息。微机关闭电源后，系统通过一块后备电池向CMOS供电以保持其中的信息。如果CMOS中关于微机部件的配置信息不正确，会导致系统性能降低和零部件不能识别，从而导致一系列的软硬件故障。<br>在BIOS芯片中装有一个系统设置程序，用来设置CMOS中的各种参数。增加了新的部件或者要进行系统安装或升级时，一般都需要进行BIOS设置。<br>【注】：</p>
<ul>
<li>BIOS设置和CMOS设置的区别<br>CMOS是微机主板上一块特殊的CMOSRAM芯片，是存放系统参数的地方；而BIOS是一组程序，存储在主板上的EPROM或EEPROM芯片中。也就是说，通过BIOS中的系统设置程序其实是对CMOS参数进行设置。</li>
</ul>
<p><font size="4" color="red">POST加电自检程序</font><br>为了保证计算机正常启动，微机在接通电源后，系统有一个对内部各个设备进行检查的过程，该过程是由一个通常称之为POST（Power On Self Test，加电自检）的程序来完成的。完整的POST自检过程包括了CPU、640K基本内存、1M以上的扩展内存、ROM、主板、CMOS存储器、串口、并口、显示卡、硬盘及键盘的测试。自检过程中如果发现有问题，系统将会给出提示信息或鸣笛警告。</p>
<p><font size="4" color="red">BIOS系统启动自举程序</font><br>在自己装操作系统的过程里，想想是不是有一步是让设置磁盘的优先级，如果优先级最高的是U盘，则接下来系统就会进入U盘里的操作系统映像，用U盘来装操作系统了。而这个查找优先级最高的硬盘驱动器并装载操作系统的过程，就是BIOS系统启动自举程序来完成的。<br>BIOS系统启动自举程序的作用是在完成POST自检后，按照系统CMOS设置中的启动顺序搜寻硬盘驱动器及CDROM、网络服务器等有效的启动驱动器，读入操作系统引导程序，开始逐步完成操作系统内核的加载和初始化，完成系统的启动。</p>
<hr>
<p><font size="5" color="orange">BIOS的基本功能</font><br>从上诉对BIOS程序组成部分介绍，可以看出BIOS的基本功能有如下：</p>
<ul>
<li>在微机启动过程中的自检及初始化。</li>
<li>提供程序服务处理。如磁盘读写、键盘读取、将文件输出到答应及等等。</li>
<li>提供硬件中断处理。</li>
</ul>
<hr>
<p><font size="5" color="orange">微机启动的过程</font></p>
<ol>
<li>当按下电源开关后，电源开始向主板和其他设备供电。但是此时电压并不稳定，主板会认为电压并没有达到CMOS中所要求的电压，就会向CPU发出RESET信号（复位信号），当电压到大符合要求的稳定值时撤销复位信号，然后CPU立刻从基本内存的BIOS段读取一条跳转指令，跳转到BIOS的启动代码处，开始执行BIOS程序。</li>
<li>执行BIOS启动程序会进行加电自检POST。这个过程进行得很快，主要是检测关键设备（如电源、CPU芯片、BIOS芯片、基本内存等电路是否存在，供电情况是否良好等），如果发现了问题，系统喇叭会发出警报声音（更具警报声的长短和次数可以知道出现了什么问题）。</li>
<li>如果自检通过，系统BIOS会查找显卡BIOS，找到后会调用显卡BIOS的初始化代码，此时屏幕上会显示显卡的相关信息。</li>
<li>显卡检测成功后会进行其他设备的测试，通过测试后系统BIOS重新执行代码，并显示启动画面，将相关信息显示在屏幕上，然后进行内存测试，最后是短暂出现系统BIOS设置的提示信息，此时按下相应按键，可以对系统BIOS进行需要的设置，完成后系统会重新启动。</li>
<li>然后系统会检测系统的标准硬件（如硬盘、光驱、串行和并行接口等），检测完成后会接着检测即插即用设备，如果有的话就为该设备分配中断、DMA通道、I/O端口等资源，至此所有的设备都已经检测完了。</li>
<li>上面的检测都顺利完成后，BIOS会按照用户指定的设备顺序，依次从设备中找启动程序，以完成系统启动（如果首先是硬盘启动，则BIOS会检查硬盘的0面0磁道1扇区，若发现该扇区以0xAA55结束，则BIOS认为它是引导扇区。一旦发现引导扇区，BIOS会执行程序将其装入到内存地址0000：7c00处，然后跳转到该地址处执行这段引导程序代码，开始加载操作系统，BIOS将系统的控制权交给操作系统）。</li>
</ol>
<p>简化的微机启动过程如下（结合我们平时的开机过程来理解）：<br><strong>按下电源开关，电源供电 → CPU通过基本内存的BIOS段，找到BIOS程序起始地址，执行BIOS程序 → BIOS进行POST加电自检 → 检测和初始化显卡，在屏幕上显示相关信息 → 内存测试 → 出现BIOS设置的提示信息 → 检测硬盘、串并行接口等标准硬件 → 检测U盘等即插即用设备并为其分配资源 → 按照设备启动顺序加载操作系统 → 将系统控制权交给操作系统</strong>。</p>
<hr>
<p>【注】：<br>当硬盘的多个分区中同时存在多个操作系统时，每个分区都会有自己的引导扇区，那么操作系统怎么知道应该加载哪个扇区呢？操作系统会先去执行0面0磁道0扇区的主引导扇区的代码，判断当前被激活的分区，然后加载激活分区的引导扇区，从而加载该激活分区的操作系统。</p>
]]></content>
      
        <categories>
            
            <category> 操作系统 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> BIOS和微机启动过程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[操作系统概述]]></title>
      <url>/2016/10/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</url>
      <content type="html"><![CDATA[<p><font size="5" color="orange">什么是操作系统</font><br>操作系统（Operating System，OS）是一种复杂的系统软件，它提供计算机用户与计算机硬件之间的接口，并管理计算机软件和硬件资源。操作系统本身并不向用户提供功能，但是它为应用程序的运行提供平台，并使应用程序的编程变得简单、容易。<br><a id="more"></a></p>
<ul>
<li>接口：两个不同组成部分的交界面。在计算机领域，接口分为硬件接口（如USB接口、串口、并口）和软件接口（如C语言中的函数调用printf()）。</li>
<li>操作系统必须要实现的两个功能：<ul>
<li>与硬件部分相互作用，为包含在硬件平台上所有的<strong>低层可编程部件</strong>提供服务</li>
<li>为运行在计算机系统上的应用程序提供执行环境</li>
</ul>
</li>
</ul>
<p><font size="5" color="orange">操作系统的发展</font></p>
<ol>
<li><font size="4" color="red">无操作系统</font><br>第一代计算机（1945-1955年）使用电子管作为主要的电子器件，用插件板上的硬连线或穿孔卡片表示程序，没有存储程序的内存，也就自然没有操作系统（因为操作系统是需要常驻内存的）。<br>比如1946年诞生于宾夕法尼亚大学的第一台电子计算机ENIAC，它的每一个用户程序进入计算机和退出计算机系统都需要人工干预，计算机无法自动完成程序的加载和卸载，所以整个计算机系统处于“运行—因等待人工操作而暂停—运行”这样一种不能自动连续工作的状态。由于CPU长时间等待人工操作，造成CPU资源的严重浪费。</li>
<li><font size="4" color="red">单道批处理系统</font><br>第二代计算机（1955-1965年）使用的主要电子器件是晶体管，开始使用磁性存储设备，内、外存容量增加，出现了早期的单道批处理系统。<br>单道批处理系统中有早期的操作系统（也叫监视程序）常驻内存，能够连续自动地读取磁带中的用户程序，但是内存中只能驻留一道用户作业，CPU和内存资源被用户作业独占。但是当程序执行到输入输出操作时，由于不需要CPU干预，并且内存中又只有一个程序在运行，所以CPU便空闲下来了，造成CPU的浪费。</li>
<li><font size="4" color="red">多道程序系统</font><br>为了解决上述问题，多道程序系统的最初想法是将内存分成几个部分，每一部分存放不同的作业，当一个作业等待输入输出操作时，另一个作业可以使用CPU；任何时刻，当一个作业运行完毕，操作系统会自动从外存读出另一个作业，装入空闲的内存区域运行。<br>早期的多道程序系统不具有交互功能，称为多道批处理系统。</li>
<li><font size="4" color="red">微机操作系统</font><br>随着个人电脑的出现，微机操作系统应运而生。第一个微机操作系统是Intel的CP/M（Control Program for Microcomputer）（后由Digital Research重写，使之适用于多种微机），在微机操作系统市场风行了5年，称为最著名的8位机操作系统。<br>20世纪80年代初，IBM进军个人电脑市场时，想要Digital Research为IBM的个人电脑编写16位操作系统，但是遭到了拒绝。可怜，这对Digital Research真的是一场肠子都悔青的商业决策。与此同时，另一位著名的商业天才风生水起，Gates从计算机制造商Seattle Computer Products手里购买了DOS（Disk Operating System），然后向IBM提供整套的DOS和BASIC。后来升级成MS-DOS（Microsoft Disk Operating System）。商业天才盖茨采取将MS-DOS与硬件捆绑销售的策略，站在蓝色巨人IBM的肩上，使MS-DOS成为微机操作系统的主流。<br>后来受苹果Macintosh（麦金塔）的影响（很可能是抄袭~），1985年微软开始构建Windows操作系统，使之成为微机操作系统的主流（如今的微机操作系统还有Linux、Chrome OS、OS X等）。</li>
<li><font size="4" color="red">实时操作系统</font><br>随着计算机在机器人、航空航天、自动化控制等领域的应用，出现了各种实时系统。实时操作系统是支持实时计算的系统。实时计算是指计算的正确性不仅依赖于系统计算的逻辑结果，还依赖于产生这个结果的时间。<br>应用于实时系统中的操作系统称为实时操作系统（实时系统也可以不使用操作系统）。</li>
</ol>
<p>【注】：</p>
<ul>
<li>单道批处理系统具有自动性、顺序性（将外存中的作业顺序装入内存运行）、单道性的特点，而多道批处理系统具有多道性、无序性（同时驻留在内存中的作业，其被调度的顺序和执行的进度无法预知）、调度性（多道程序系统必须具有作业调度和进程调度功能）。</li>
<li>分时系统运行多个用户通过终端同时使用计算机（通过类似时间片轮转的方法来实现），并且具有交互性，用户可以通过终端与系统进行广泛的人机对话。</li>
</ul>
<p><font size="5" color="orange">操作系统的特征</font></p>
<ul>
<li><font size="4" color="red">并发</font><br>并发是指两个或多个事件在同一<strong>时间间隔</strong>内发生。而并行是指多个事件在同一<strong>时刻</strong>发生。</li>
<li><font size="4" color="red">共享</font><br>系统中的资源可供内存中多个并发执行的进程共同使用。分为互斥共享和同时共享。<ul>
<li>互斥共享：任意时刻一种资源只能被一个进程访问，当一个进程访问该互斥资源时，其他进程必须等待，直到资源被进程访问完毕，释放访问权。</li>
<li>同时共享：<strong>从宏观上看</strong>，资源可以被多个进程同时访问。例如对磁盘的访问，虽然在任意时刻只能有一个程序访问某个磁盘，但是多个程序可以在短时间内轮流访问该磁盘，就造成了在宏观上同时共享某资源的假象。</li>
</ul>
</li>
<li><font size="4" color="red">虚拟</font><br>虚拟是指通过某种技术把一个物理实体变成若干逻辑上的对应物。例如虚拟CPU、虚拟内存、虚拟打印机，都是操作系统通过某种技术把少量的物理资源变成比物理资源多的逻辑资源。</li>
<li><font size="4" color="red">异步</font><br>异步是指进程以不可预知的速度向前推进。</li>
</ul>
<p><font size="5" color="orange">操作系统的功能</font></p>
<ul>
<li><font size="4" color="red">存储器管理</font><br>存储器管理的主要任务是为多道程序的运行提供良好的环境，方便用户使用存储器，提高存储器的利用率，以及能从逻辑上扩充内存。存储器管理主要有内存分配、内存保护、地址映射、内存扩充等。<ul>
<li>内存分配：<br>为每道程序分配内存空间，使它们“各得其所”，提高存储器的利用率，以减小不可用的内存空间，允许正在运行的程序申请附加的内存空间，以适应程序和数据动态增长的需要。主要有静态内存分配方式（实现分配好并且不再变化）和动态内存分配方式 （运行过程中根据进程的请求分配内存，内存中分区的大小和数量都是动态变化的）。</li>
<li>内存保护<br>确保每道用户程序都在自己的内存空间中运行，互不干扰。可以采用界限存储器存放允许程序访问的地址区间的上限和下限值来实现内存保护。</li>
<li>地址映射<br>在CPU之心改程序过程中访问内存时，把程序中的逻辑地址转换为物理地址（内存地址）。</li>
<li>内存扩充<br>借助虚拟存储技术，从逻辑上扩充内存容量，使系统能够提供比物理内存大的容量。需要有请求调入功能（指令或数据不在内存时请求调入内存）和置换功能（请求调入时若内存空间不够，则要将内存中的一部分换出到外存，再调入当前需要的内若）。</li>
</ul>
</li>
<li><font size="4" color="red">进程管理</font><br>主要包括进程控制、进程同步、进程通信、进程调度等。进程控制功能完成对进程的创建、撤销、唤醒、阻塞等；进程同步功能完成多个进程（以及线程）运行的互斥与协调；进程通信功能用来实现进程之间的信息交换；进程调度功能是从进程的就绪队列中选出一个进程，把处理机分配给它，并为它设置运行现场，使其投入运行。</li>
<li><font size="4" color="red">设备管理</font><br>主要完成用户的I/O请求，为用户分配I/O设备。</li>
<li><font size="4" color="red">文件管理</font><br>主要是对文件存储空间的管理、目录管理、文件读写管理和存取控制。</li>
<li><font size="4" color="red">提供用户接口</font><br>为了方便用户使用操作系统，操作系统向用户提供了用户与操作系统之间的接口。向最终用户提供命令行和图形接口，向程序员提供高级语言和操作系统之间的接口—“系统调用”。<br>系统调用是操作系统实现的具有某种功能的程序模块。应用程序可以通过系统调用的接口，来使用操作系统实现的功能，获得操作系统内核的服务。</li>
</ul>
<p><font size="5" color="orange">操作系统的体系结构</font><br>简单的监控程序模型、单体结构模型、层次结构模型、客户/服务器模型与微内核结构、动态可扩展结构模型</p>
]]></content>
      
        <categories>
            
            <category> 操作系统 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 操作系统概述 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[网游流畅基础：帧同步游戏开发]]></title>
      <url>/2016/09/18/%E5%B8%A7%E5%90%8C%E6%AD%A5/</url>
      <content type="html"><![CDATA[<p>在现代多人游戏中，多个客户端之间的通讯，主要是同步多方状态。为了同步多方状态，主要有两个技术：<br><a id="more"></a></p>
<ol>
<li>状态同步<br>客户端发送游戏动作到服务器，服务器收到后，计算游戏行为的结果，然后以广播的方式下发游戏中各种状态，客户端收到状态后再根据状态显示内容。在回合制游戏中，大多都是这种方式</li>
<li>帧同步<br>也是客户端发送游戏动作到服务器，服务器收到后并不计算游戏行为结果，只是转发所有客户端的动作（或者不需要服务器，客户端之间直接通过P2P技术发送游戏动作）。然后客户端根据收到的所有游戏动作来做游戏运算和显示。早期的IPX（Internetwork Parket Exchange Protocol，互联网数据包交换协议）网络游戏就是这种帧同步的方式，比如红色警戒、星际争霸和大量的支持网络连线双打的游戏机模拟器。</li>
</ol>
<hr>
<p><font size="5" color="orange">什么时候用状态同步，什么时候用帧同步？</font><br>状态同步主要是依靠服务器来计算游戏状态，然后下发到客户端，而帧同步主要是依靠客户端自己来做游戏运算，服务器仅仅是做一个转发，甚至不需要服务器，客户端之间可以通过P2P方式来转发数据。</p>
<p>由于帧同步只是转发游戏行为，而不是游戏状态，所以要广播的数据量比状态同步要小很多，比较适合游戏行为非常频繁的动作类游戏，比如飞行射击、FPS（First Person Shooting Game，第一人称射击类游戏）、RTS（Real Time Strategy Game，即时战略游戏）这些游戏。因为这些游戏中的对象特别多，比如满屏的子弹，如果使用状态同步，那么服务器要广播的数据就很大了，但是如果用帧同步，则仅仅需要广播与玩家角色有关的动作即可，像在射击游戏中其余的满屏的子弹（这些都是有机器控制的，不是玩家控制的）都不需要广播数据了。这个时候帧同步的优势很明显。</p>
<p>反过来，如果游戏里有大量的玩家，那么帧同步和状态同步的差异就不明显了，因为与每一个玩家相关的动作都需要做广播。而且状态同步由于是在服务器上进行游戏运算，安全性会更高，比较容易防止外挂。</p>
<hr>
<p><font size="5" color="orange">帧同步机制</font><br>帧同步最重要的基础概念：<strong>相同的输入+相同的时机=相同的显示</strong><br>意思是每个客户端在同一时间收到的，来自网络中多个客户端的操作是一样的，就能够达到同步效果。</p>
<p>由于在同步中每个客户端的运算要绝对一致，所以不能依赖本地时间、本地随机数等等类似的操作，而应该是以来自网络的操作数据为主。所以，在游戏客户端引擎中的本地Update就不能再在每帧画面渲染前被调用了，因为它是依赖本地时间的。Update总不能省掉吧？因为它是游戏逻辑更新的主循环，没有它游戏就没法动了。既然Update是必须的，那么什么时候调用它才能保证同步呢？</p>
<p>在一般的帧同步系统中，会有一个Relay Server负责广播所有客户端的数据，并且由于每个客户端不能依靠本地时间来驱动Update，只能依靠来自网络的数据。所以，Relay Server会每隔一定时间向所有客户端下发“网络帧”，当有玩家有输入的时候，把玩家的游戏操作数据填入到网络帧数据包中，再进行广播，如果没有玩家输入，则发送空（大部分是空的）的网络帧。当每个客户端收到网络帧的时候，就会调用一个UpdateByNet()函数来进行游戏更新。（UpdateByNet其实干的是和Update差不多的事，只是受驱动的对象变了，Update受本地CPU驱动，UpdateByNet受网络驱动。而且帧同步中Update函数依然存在，也会受CPU驱动执行，不过其中的大部分内容都挪到了UpdateByNet中，所以Update的更新不再会产生游戏逻辑的更新，UpdateByNet才会）。</p>
<p>显然网络帧的速度要比本地CPU帧速度慢很多，帧率会很低。那么怎么保证游戏流畅度呢？</p>
<hr>
<p><font size="5" color="orange">帧同步中如何保证游戏流畅</font></p>
<ul>
<li>Delay Server每一个网络帧广播的数据应该要足够小，最好在一个 MTU（Max Transmission Unit ）以下，这样才能有效降低网络延迟。</li>
<li>为了让Delay Server每次广播的数据量小，一般要求每次客户端发送的数据应该小于128字节</li>
<li>一个减少客户端发送数据长度的方法就是：自己写序列化函数。一般的面向对象语言都带有把对象序列化和反序列化的功能，但是编程语言的默认序列化功能，为了实现一些高级功能（比如反射），会把很多游戏逻辑所不必要的数据也序列化了（比如对象类名、属性名）。所以我们可以自己针对特定的对象来编写序列化函数，来减少多余的数据，甚至能合并和裁剪一些数据项，以最小化数据长度。<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721530598.png" alt=""></li>
<li>另一个减少客户端发送数据长度的方法是：用整数代替浮点数。比如在游戏中所使用的位置数据，大多是浮点数，占了8个字节，其实往往我们并不需要这么高的精确度，所以可以考虑把浮点数变成整数，整数只占了4个字节，少了一倍的数据量。最简单的方法是把浮点数乘以1000或100然后取整（客户端接收到以后可以除以1000或100来还原，这样在保证整数的同时还能有一定的精确度）。</li>
<li>还有一个减少客户端发送数据长度的必要方法是：只有当客户端收到网络下行帧以后才发送一次上行的玩家操作，而不是每一个渲染帧（本地Update）都去发送。</li>
<li>玩家的网络可能会出现临时拥堵（网络抖动），也有可能中途会有玩家加进来，甚至游戏录像等等都会导致客户端收到一堆“过去时间”里的网络帧，无法即时处理。这时就要求玩家恢复正常状态后，要有处理这一堆网络数据的能力。最简单的办法就是加速播放（快进或者叫拉帧）：客户端收到网络帧处理完游戏逻辑后，在同一个渲染帧（本地Update）内，马上重复接收下一个网络帧（而不再是直到下一次Delay Server广播时才再次接收网络帧），然后又立即处理。这样往往能在一个渲染帧的时间内，加速赶上服务器广播的最新游戏进度（赶上其他正常玩家的当前游戏状态）。<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/14772153066.png" alt=""><br>但是也有副作用，如果客户端积累的包太多（比如游戏已经开始10分钟，新玩家中途加入），客户端会因为在一个渲染帧内疯狂下载积累的帧同步包和快进运算，导致本地客户端长时间卡住。所以有时候会限制一个渲染帧内快进的次数，保证用户还是能看到活动的画面（虽然动的比较快但也总比一直静止好啊！）。如果帧同步包实在是太多，要快进的进度很多，那么就要采用“快照”技术了。</li>
<li>客户端在快进时，每个渲染帧会接收很多网络帧，因为每收到一个网络帧都会发送一次玩家操作数据，这回导致Delay Server广播的数据量很大，造成网络延迟。所以当某个客户端在快进时，应该禁止输入玩家输入，那么每次收到网络帧后由于没有玩家输入就不会再进行数据发送了。</li>
<li>为了提高实时性，一般使用UDP，而不是TCP，但是使用UDP又会带来丢包、乱序。所以，一般会采用冗余的方式，每个网络帧数据包其实还包含了过去2帧的数据，也就是说每次发3帧数据来对抗丢包，3个包里只要有一个包没丢就不会影响游戏。</li>
<li>Delay Server上还会保存大量的客户端上传的数据，如果客户端发现丢包或者乱序，就会发起一次“下载”请求，从 Delay Server上重新下载丢失或乱序的帧数据包（这可能会使用TCP）。</li>
<li><p><font size="4" color="red">通过牺牲某些不重要的特性来提高游戏流畅度</font></p>
<ul>
<li>牺牲<strong>一致性</strong>来交换流畅度。虽然帧同步的目标就是所有客户端都看到一致的显示，但是游戏内容很多，有一部分内容是可以容忍不一致的，飞机大战中，满屏的子弹是由机器控制的，加上子弹本身存在的时间也很短，所以这些子弹在不同的客户端上是可以不一致的；又比如几个玩家一起打电脑控制的怪物，玩家关心的是怪物被打死，而不会太在意其他玩家的出招是不是在自己电脑上滞后了几秒。这种情况下，就可以把可以容忍不一致的那部分游戏逻辑，从网络帧的UpdateByNet拿出到本地渲染帧的Update里。这样就算网络有些卡，但还是有很多东西是不会卡住的（与玩家有关的逻辑更新还是应该受网络帧驱动，不然就失去了同步的效果）。</li>
<li><p>牺牲<strong>实时性</strong>来交换流畅度。一般我们是希望玩家有输入后，从客户端把操作数据发出去，然后在收到下一个网络帧时就能立即得到响应。但是网络是不稳定的，什么时候能收到下一个网络帧是不确定的，如果网络快点，客户端响应得就快，网络慢点，客户端响应得就慢，这会造成同样的操作出现一会快一会慢的效果，像在跑酷游戏中，如果主角一会向前跑得蜗牛似的，一会又向前跑得很快，这是很诡异的。解决办法就是：<strong>收到网络帧数据包后，并不立即响应和处理，而是放入客户端的网络帧缓冲区内，客户端每隔一定时间从缓冲区中取出一个网络帧进行运算</strong>。当网络速度快时，会有比较多的网络帧被存放到缓冲区中，网络速度慢时，可能一段时间内都没有网络帧进入缓冲区，但是客户端依旧可以从缓冲区中取出网络帧（这些网络帧是在网络快时被缓存下来的），因为客户端从缓冲区取网络帧的频率是固定的，所以对数据的运算是匀速的，对游戏逻辑的更新也就匀速了。虽然在网络快时没有得到立即响应，牺牲了实时性，但是同时却换来了游戏的流畅性，平滑了对那些一会快一会慢的网络帧数据包的响应（其实原理类似于传输语音业务，可参考<a href="http://www.w2bc.com/Article/60507" target="_blank" rel="external">这篇文章</a>）。</p>
<p>这种做法会让玩家感觉到一个固定的延迟：输入操作后，隔一定时间才会有反应。但起码这种延迟是可以固定的，是玩家可以预测的，方便玩家操作。（这个操作的感觉就好像玩家有了一定的”惯性”一样，按下跑并不会立刻跑，松开跑不会立刻停，但这个惯性的时间是固定的）</p>
</li>
<li><p>牺牲<strong>公平性</strong>来交换流畅度。这个特性和一致性的根源一致，玩家不希望对方因为网络好，电脑运行速度快就比自己先看到游戏的运行结果，比如在格斗对打游戏和RTS游戏里这是很不公平的。为了让网络、硬件不同的玩家能够公平游戏，经常会使用一种叫”锁步”的策略：每个客户端都定时（每N个渲染帧）发送一个网络帧到服务器，即使玩家没有任何操作也像心跳一样发送空数据帧，每个客户端要收到其他所有客户端的心跳帧才能开始一次逻辑运算和更新。这就是让所有客户端相互等待，如果有玩家卡了，其它客户端都能知道，然后让玩家停止输入来等待对方玩家恢复网络。</p>
<p>这种做法其实是牺牲流畅度的，一旦有玩家掉线了，其他所有玩家都会受到影响。为了减少这种对流畅度的影响，锁步的时候可以少锁一点，对方的”心跳帧”缺了若干帧（比如几秒）自己这里都还是能正常更新，能不公平地玩一会，如果这段时间内还是没有补齐所缺的”心跳帧”，才宣布锁住游戏等待对方玩家恢复网络。这就是通过牺牲公平性来叫交换流畅度。甚至在一些非PVP（玩家对战）的帧同步游戏中都不太需要这个公平性，因为不是和对方玩家实时对战的，并不关注对方是不是比自己先看到结果。</p>
</li>
</ul>
</li>
</ul>
<hr>
<p><font size="5" color="orange">移动网络帧同步中自定义的UDP</font></p>
<ul>
<li><p><font size="4" color="red">为何要使用UDP而不是TCP呢？</font></p>
<ul>
<li>TCP的慢启动算法不适合移动网络，移动网络信号时好时坏，使用慢启动会使数据包的发送速率经常在很低的段位，导致数据不能及时快速地到达对端</li>
<li>拥塞避免算法不适合移动网络主要原因是其考虑到网络的公平性及收敛性，并且AIMD 算法会使实时性大受影响，延迟明显提升</li>
<li>还有TCP协议用于重传的RTO的指数变化及拥塞算法的实现Nagle的缓存等，都是TCP并不太适合高实时性要求的游戏玩法的原因</li>
<li>实验表明，在弱网络环境下，UDP的RTT几乎不受影响，而TCP的RTT波动比较大，特别是受丢包率影响比较明显</li>
</ul>
</li>
<li><p><font size="4" color="red">基于UDP的FSP协议栈</font><br>由于UDP是不可靠的，所以需要DIY自己的UDP。于是基于UDP实现一个自定义的协议栈，称为FSP（FrameSyncProtocol）。<br>FSP的基本原理其实就是仿照TCP的ACK/SEQ重传机制，并且使用冗余重传，来实现传输的可靠性。使用冗余重传的好处是简化了麻烦的时序问题，并且收到的每个包都是顺序的。在网络拥塞时带宽利用率优于TCP，但流量会略微增加一些（好像也无法调节网络拥塞，因为它去除了TCP的拥塞控制机制，可能对于时好时坏的移动网络是比较适合的，因为网络不大会一直很差）。FSP图示如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721530516.png" alt=""></p>
<ol>
<li>客户端发Action1，服务器未收到</li>
<li>客户端新增Action2，发送给服务器的包同时包含Action1和Action2，并且seq=2</li>
<li>服务器确认并发送给客户端ACK=2的包</li>
<li>客户端由于某些原因（可能是网络延迟）未收到服务器ACK=2的确认包，新增Action3后，客户端则把Action1、Action2、Action3一起发送给服务器，并且seq=3</li>
<li>客户端收到了ACK=2的确认包，则把队列中的Action1、Action2删除，新增Action4后，把队列中的Action3、Action4一起发送给服务器，并且seq=4</li>
</ol>
<p>实际上线测试中，FSP在弱网络环境下表现也是不错的</p>
</li>
</ul>
<hr>
<p>更多详细介绍，请看<a href="http://gad.qq.com/article/detail/7169916" target="_blank" rel="external">这篇文章</a></p>
]]></content>
      
        <categories>
            
            <category> 游戏开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 帧同步 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[数据结构与算法之查找]]></title>
      <url>/2016/09/17/%E6%9F%A5%E6%89%BE/</url>
      <content type="html"><![CDATA[<p><font size="5" color="orange">先来看几个概念</font><br><a id="more"></a></p>
<ul>
<li>查找分为静态查找和动态查找。静态查找是只做查找操作，而动态查找是在查找过程中同时进行插入或删除。</li>
<li>查找算法主要分为：</li>
</ul>
<hr>
<p><font size="5" color="orange">顺序表查找</font><br>顺序表查找就是按序从头找到尾，找到为止。时间复杂度为O(n)</p>
<hr>
<p><font size="5" color="orange">有序表查找</font></p>
<ul>
<li><font size="4" color="red">折半查找</font><br>核心思想：<strong>每次查找线性有序表(假定从小到大有序)的中间位置的记录，如果给定值小于中间记录，则在左半区查找；如果给定值大于中间记录，则在右半区查找</strong>。<br>要求查找表是有序的顺序存储的线性表。<br>代码如下：</li>
<li><font size="4" color="red">插值查找</font><br>核心思想：<strong>插值查找是折半查找的改良版，每次不再是查找正中间位置的元素，而是根据元素内容在最小值到最大值之间的比例，来查找区间里同比例的那个位置上的元素</strong>。插值计算公式如下：mid=low+(key-a[low])/(a[high]-a[low])*(high-low)。<br>同折半查找一样，要求查找表示有序的顺序存储的线性表，而且需要表内元素值分布比较均匀，这样查找效率才会比较高。<br>代码如下：</li>
<li><p><font size="4" color="red">斐波那契查找(黄金分割法查找)</font><br>斐波那契数列有如下定义：F(n)=F(n-1)+F(n-2)，该数列越往后相邻的两个数值的比例越接近于黄金比例0.618。<br>核心思想：<strong>斐波那契查找也是折半查找的改良版，每次不再是查找正中间的位置，而是先把查找序列补全成为刚好比自身长度大的斐波那契数的长度(在序列后面补序列的最后一个元素值)，再去查找序列中位置等于前一个斐波那契数上的元素</strong>。如下图：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/14772161357.png" alt=""><br>代码如下：</p>
<p>斐波那契查找最大的优点就是它只有加减法，没有除法，这在海量数据中运算时，还是有不小的性能提升。</p>
</li>
</ul>
<hr>
<p><font size="5" color="orange">线性索引查找</font><br>就像房间里面的n多东西，一样一样去找是非费劲的，也很难对他们去排序，即使排了序还要花大把时间去维护这个序列。如果我们一个小本子，里面记录着每一样东西它在房间里的位置，那找起来就相当方便了。这就是索引。<br>每个索引项至少要包含记录的关键字和记录存储的位置。上面的例子里，每件物品相当于一个记录，它有各种属性，名字就相当于它的关键字，能唯一确定它，在房间里的位置就相当于记录的存储位置。<br>线性索引表就是索引项组成的线性结构，基于线性索引表的查找就是线性索引查找。有三种重要的线性索引：稠密索引、分块索引、倒排索引。</p>
<ul>
<li><font size="4" color="red">稠密索引</font><br>稠密索引是指每一条记录都对应一个索引项。为了让索引表也可以排序，我们可以用数字来替换关键字，比如用数字去替换名字。在下图中表现为关键码：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721613624.png" alt=""><br>但是稠密索引有个很致命的缺点，当记录量很大时，比如上亿，就需要和记录量一样多的索引项，这需要反复地去访问磁盘，查找性能反而会下降。</li>
<li><font size="4" color="red">分块索引</font><br>将大量的记录分成若干块，快内无序，块间有序，再让每块对应一个索引项，这就是分块索引(快内再有序的话代价太大)。<br>在块数和快内记录数相等时，分块索引的平均查找长度最短，即性能达到最好。</li>
<li><font size="4" color="red">倒排索引</font><br>在前面的例子中，如果我想知道哪些东西是红色的，是需要一个物体一个物体地去查看它的所有属性，看看有没有红色这一项吗？或者说我想知道在n多篇文章里，哪几篇出现了hello这个单词，哪几篇出现了world这个单词，是需要一篇文章一篇文章去找吗？这样太费时了！如果我们有一张表，左侧是红色，右侧红色对应的物体，或者左侧是单词，右侧是单词出现的文章，根据这张表是不是能快很多？<br>由于这是根据记录的属性去查找记录，所以称为倒排索引。</li>
</ul>
<hr>
<p><font size="5" color="orange">二叉排序树</font><br>想要查找效率高，就应当让数据有序，但是如果采用线性顺序存储，又降低了插入和删除记录的效率。有没有什么办法能让查找、插入、删除的效率都高呢？二叉排序树可以做到。二叉排序树也叫做二叉搜索树。</p>
<p><strong>二叉排序树：左子树上所有结点值小于根结点，右子树上所有结点值大于根结点</strong>。</p>
<ul>
<li><font size="4" color="red">二叉排序树的插入和创建</font><br>现在有一堆记录{62，88，58，47，35，73，51，99，37，93}，把第一个数据作为根节点，后面每插入一个数据，先从根节点开始，小于则向左走，一直到某个结点的左儿子为空时插入，大于则向右走，一直到某个结点的右儿子为空时插入（在每个结点处都要判断是向左还是向右走）。最终构造出如下图的树：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721613677.png" alt=""><br>先把62作为根结点，接下来是88，比62大往右走，发现62结点的右儿子为空，则插入到这个位置；接下来是58，比62小往左走，发现62结点的左儿子为空，则插入；再接下来是47，比62小往左走，发现62结点的左儿子不为空，继续向左走，比58小往左走，发现58的左儿子为空，则插入；……<br>对这棵排序二叉树作中序遍历后，就能得到有序序列：{35，37，47，51，58，62，73，88，93，99}。<br>代码见后面。</li>
<li><font size="4" color="red">二叉排序树的查找</font><br>从根结点开始，小于则向左找，大于则向右找。一样的用递归实现，很简单。代码见后面。</li>
<li><font size="4" color="red">二叉排序树的删除</font><br>二叉排序树的删除分为4种情况：<ul>
<li>要删除结点为叶子结点，直接删除即可。</li>
<li>要删除结点的右子树为空，则只需要把左子树接上来即可，得到的依然是一棵排序二叉树。如下图：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/14772161373.png" alt=""></li>
<li>要删除结点的左子树为空，与上一个类似，只需要把右子树接上来即可。</li>
<li>要删除结点的左右子树都不为空，如下图：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/14772161378.png" alt=""><br>这就不能简单地把左子树或右子树接上就可以了，这样做可能就不再是一棵排序二叉树了。仔细观察，其实有37结点和48结点可以代替47结点，而它俩又恰好是47结点中序排列的前驱和后继，其中前驱肯定没有右子树，后继肯定没有左子树（由中序决定的）。比如把37结点的数据移到47结点的位置，再由35结点的右子树去接管37结点的左子树。<br>注意，如果上图中35结点(待删除结点的左儿子)没有右子树，则待删除结点47的直接前驱就应该是35结点，这时候就需要47的左子树去接管35的左子树了。所以这里应该分两种情况讨论，一种是待删除结点的前驱结点不是它的左儿子，另一种是待删除结点的前驱结点就是它的左儿子。<br>代码如下：<br>可以看出，查找某个元素的次数，等于该元素在二叉排序树中的层数。也就是说，二叉排序树的查找性能取决于二叉排序树的形状，深度太大，性能会很低。所以我们希望二叉排序树是平衡的，即它的深度与完全二叉树相同，均为[logn]+1（以2为底，向下取整）。那么查找的时间复杂度将变为O(logn)。</li>
</ul>
</li>
</ul>
<hr>
<p><font size="5" color="orange">平衡二叉树</font></p>
<ul>
<li>平衡二叉树：一种每个结点的左右子树高度差不会超过1的二叉排序树。</li>
<li>平衡因子BF：结点的左子树深度减右子树深度的值。对于平衡二叉树的BF。</li>
<li>最小不平衡子树：其根节点距离插入结点最近，且平衡因子绝对值大于1<br>应该只有三种取值：1，0，-1。非平衡二叉树的BF就多了去了。</li>
<li><font size="4" color="red">平衡二叉树的创建：</font><br>平衡二叉树只是在创建排序二叉树的基础上，每添加一个结点都去递归检查插入结点后树是不是长高了，然后去改变自己的平衡因子，如果打破了平衡（平衡因子绝对值大于1）则作相应的旋转处理（BF为2则把对应的最小不平衡子树右旋，BF为-2则把对应的最小不平衡子树左旋），重新达到平衡状态，并修改平衡因子。<br>插入节点时由于非平衡所带来的旋转处理分为以下4种：<ul>
<li>左左（给结点的左子树插入一个左孩子）：<br>分为以下两种：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721613829.png" alt=""><br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721613879.png" alt=""><br>这俩其实是一样的，都是把BF为2的分支旋转成BF为1的结点的右子树，再把BF为1的结点的原先的右子树改为BF为2的结点的左子树。</li>
<li>右右<br>分为以下两种：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721613929.png" alt=""><br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721613978.png" alt=""><br>这俩其实也是一样的，都是把BF为-2的分支旋转成BF为-1的结点的左子树，再把BF为-1的结点的原先的左子树改为BF为-2的结点的右子树。</li>
<li>左右<br>分为以下三种：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721614032.png" alt=""><br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721614139.png" alt=""><br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721614195.png" alt=""><br>这三其实也是一样的，先把不平衡分支下BF符号相反的结点（下图中BF为-1的结点2）进行左旋，结果旋转成了左左类型，后续处理和左左一致。</li>
<li>右左<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721614252.png" alt=""><br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721614313.png" alt=""><br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721614368.png" alt=""></li>
</ul>
</li>
</ul>
<hr>
<p><font size="5" color="orange">多路查找树</font><br>我们前面讲的树结构都只能一个结点存储一个元素，在元素非常多的时候，就会使得树的度非常大或者树的深度非常大，这样会造成频繁地访问外存（因为所访问的树结点很可能并不是顺序存储的），导致性能很低。所以，我们需要打破一个结点只存储一个元素的限制，于是就有了多路查找树。</p>
<p><strong>多路查找树：每个结点可以存储多个元素，且孩子不止于两个</strong></p>
<ul>
<li><font size="4" color="red">2-3树</font><br>2-3树同时具有以下特点：<ul>
<li>每个结点具有两个孩子（称为2结点）或者三个孩子（称为3结点）</li>
<li>每个2结点包含一个元素和两个孩子（或没有孩子），其左子树的元素小于该2结点的元素，其右子树的元素大于该2结点的元素</li>
<li>每个3结点包含两个元素和三个孩子（或没有孩子），其左子树的元素小于3结点中的较小元素，其中子树的元素介于3结点的两个元素之间，其右子树的元素大于3结点中的较大元素</li>
<li>2-3树的所有叶子都在同一层上</li>
</ul>
</li>
<li><font size="4" color="red">2-3-4树</font><br>2-3-4树是2-3树的扩展，增加了一个四结点，所以相比2-3树增加了以下特点：<ul>
<li>每个结点可以是2结点或者3结点或者4结点</li>
<li>每个4结点包含三个元素和4个孩子（或没有孩子），其左子树的元素小于4结点中的最小元素；第二子树的元素大于4结点的最小元素，小于4结点的第二元素；第三子树的元素大于4结点的第二元素，小于4结点的最大元素；右子树的元素大于4结点的最大元素</li>
</ul>
</li>
<li><font size="4" color="red">B树</font><br>B树是一种平衡的多路查找树，2-3树和2-3-4树都是B树的特例。结点最大的孩子数目称为B树的阶。<br>B树具有如下特点（其阶数为m）：<ul>
<li>如果<strong>根结点</strong>不是叶结点，则至少有两棵子树</li>
<li>每个<strong>非根的分支结点</strong>都有超过(m/2-1)（向下取整）个元素和m/2个孩子（孩子比元素个数多1）</li>
<li>每个叶子结点都有超过(m/2-1)个元素</li>
<li>所有叶子结点位于同一层</li>
<li>每个结点的各个子树所包含的元素的值都介于结点中孩子对应的相邻元素值之间（结点中孩子和元素相间存放，最左孩子的左边元素看作无穷小，最右孩子的右边看作无穷大）</li>
</ul>
</li>
<li><p><font size="4" color="red">B+树</font><br>虽然使用B树访问多个关键字（元素）时，由于一个结点可以存储多个关键字，会减少访问外存的次数，但是如果是访问多个结点，则需要从根结点开始去遍历树，遍历过程中的很多结点可能并不在一个内存页面上，也就是说访问B树的多个结点时，还是要频繁地访问外存。<br>而B+树则是应文件系统所需而产生的一种B树的变形树，严格来说，B+树已经不能算作树了。<br>m阶B+树和m阶B树的区别：</p>
<ul>
<li>有n棵子树的结点中包含n个关键字</li>
<li>所有分支结点可以看成是索引，分子结点中仅含有其子树中的最大（或最小）关键字</li>
<li>所有叶子结点按关键字大小从小到大链接在一起</li>
<li>所有的叶子结点加在一起一定包含了树中的全部关键字，以及指向这些关键字记录的指针</li>
<li>即使在分支结点中已经找到了要查找的关键字，但它也只是用来索引的，不能提供实际记录的访问，因为只有叶子结点中才存储着关键字对应记录的实际指针，还是需要到达包含此关键字的叶子结点才行。</li>
</ul>
<p>那么使用B+树为什么能减少外存访问次数呢？<br>因为B+树中的所有叶子结点是按大小链接在一起的，当需要访问多个结点时，可以从B+树最左端的叶子结点出发，不经过分支结点，而是沿着指向向<br>下一个叶子结点的指针就可以遍历所有的关键字，这样就省去了从根结点开始遍历所需要访问的诸多分支结点，访问的结点少了，访问外存的次数当然就少了。</p>
<p>由于所有叶子结点包含了所有关键字，且是按关键字从小到大链接在一起的，所以B+树特别适合带有范围的查找。</p>
</li>
</ul>
<hr>
<p><font size="5" color="orange">散列表查找</font><br>之前的查找都是先有关键字，然后去表中挨个查找，再根据顺序存储位置的计算方法找到关键字记录对应的内存地址。那么能不能直接根据关键字，不用去表中一个一个地比较就能知道对应记录的内存地址呢？？？<br>可以发现，关键字和内存地址是一对映射关系，如果知道它们之间是怎么映射的，不就可以直接通过关键字找到内存地址吗？也就是如下形式：<br>                                            存储位置=f(关键字)<br>所以在存储的时候，我们就可以按照关系f来存储，查找的时候也按照关系f来查找。</p>
<p>这就是<strong>散列技术：在记录的存储位置和它的关键字之间确定一个对应关系f，使得每一个关键字key对应一个存储位置f(key)</strong>。对应关系f称为散列函数或哈希函数。使用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间称为散列表或哈希表。（散列技术既是存储方法，也是对应的查找方法）。</p>
<p>但是散列技术也有很多缺点：</p>
<ol>
<li>同样的关键字对应很多记录时，不适合用散列技术。因为函数本身可以多个x对应一个y，但不能一个x对应多个y。</li>
<li>散列表不适合范围查找，比如查找一个公司18~50岁的员工，在散列技术中是没法进行这种范围查找的。</li>
<li>散列查找也不能获得记录的排序，而且像最大值、最小值等都无法通过散列查找知道。</li>
<li>散列技术还可能出现冲突，因为在散列函数中有可能会有多个x对应一个y的情况，即多个关键字通过散列函数算出来的是同一个存储地址（这多个关键字称为同义词），但是多个关键字对应的记录明显是多个不同的记录，总不能把这多个记录都存储到一个地址中把，这会产生数据覆盖的，造成后续查找错误，找不到关键字对应的正确记录。</li>
</ol>
<p>散列技术的冲突其实是由散列函数造成的，如果构造出来的散列函数只能一个x对应一个y，那当然是不会产生冲突了。同时散列函数还不能太复杂，不然计算散列函数就得花费大量时间，反而查找性能不好。所以在散列技术中如何构造散列函数f是一个关键点。</p>
<ul>
<li><p><font size="4" color="red">散列函数的构造方法</font></p>
<ul>
<li>直接定址法：<br>取关键字的某个线性函数值作为散列地址，即：f(key)=a x key+b（a、b为常数）。<br>直接定址法的优点是简单、均匀，也不会产生冲突，但是需要事先知道关键字的分布情况，因为关键字如果分布比较稀疏，就会造成散列地址很分散，可能在不同的内存页面上，导致频繁换页，性能降低。所以直接定址法只适合查找表小且连续的情况，实际中并不常用。</li>
<li>数字分析法：<br>数字分析法是抽取关键字的一部分来计算散列地址，这在散列函数中常常用到。<br>数字分析法适合处理关键字位数比较大的情况，而且如果事先知道关键字的分布且关键字中的若干位分布较均匀，就可以考虑使用数字分析法。</li>
<li>平方取中法<br>比如关键字是1234，它的平方是1522756，再抽取中间三位227来作为散列地址。这就是平方取中法。<br>平方取中法比较适合不知道关键字分布，而且关键字位数又不是很大的情况。</li>
<li>折叠法<br>折叠法是将关键字从左到右分割成位数相等的几部分（最后一部分位数不够就不够了，不管它），然后将这几部分叠加求和，并且根据散列表表长，取后几位作为散列地址。<br>比如关键字是9876543210，散列表表长为3位，将关键字分为4组：987|654|321|0，然后将它们叠加求和987+654+321+0=1962，再拿出后3位962作为散列地址。<br>折叠法适合不知道关键字分布，而且关键字位数比较多的情况。</li>
<li><p>除留余数法<br>此方法为最常用的散列函数构造方法。除留余数法就是把关键字除以某个数，取余数作为散列地址，即：f(key)=key % p<br>很显然，除留余数法是会产生冲突的，它的关键就在于选择合适的p。</p>
<p>经验表明，p应该选为小于或等于散列表长度（最好接近表长）的最小质数或不包含20以下的质因子的合数。</p>
</li>
<li>随机数法<br>随机数法就是取关键字的随机函数值作为它的散列地址，即f(key)=random(key)。<br>随机数法适合关键字长度不等的情况。</li>
</ul>
</li>
<li><p><font size="4" color="red">处理散列冲突的方法</font><br>虽然可以通过构造好的散列函数来减少冲突的发生，但是冲突总还是有的，几乎不可避免。那么应该有一些处理散列冲突的方法。</p>
<ul>
<li>开放地址法<br>就像你要去买一套房子，发现它已经被人买走了，怎么办？找别的房子呗！这就是<strong>开放地址法：发生冲突后，去寻找下一个空的地址</strong>。只要散列表足够大，空的散列地址总是能找到的。<br>那么以何种方式去找下一个空的地址呢？<ul>
<li>开放定址法之线性探测法<br>发生冲突后，一个一个往后顺序查找空的地址，即：<br> fi(key)=(f(key)+di) % p   （di=1，2，3…..p-1）<br>但是使用线性探测法，很可能会出现本来不是同义词却要争夺一个地址的情况，这种现象称为<strong>堆积</strong>。</li>
<li>开放定址法之二次探测法<br>发生冲突后，以平方跳跃的方式往前或者往后查找空的地址，即<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721614417.png" alt=""><br>使用平方是为了不让关键字算出来的散列地址都聚集在某一块区域，减少堆积现象。</li>
<li>开放地址法之随机探测法<br>发生冲突后，随机地去查找空的地址，即：<br>fi(key)=(f(key)+di) % p    （di是一个随机数列）</li>
</ul>
</li>
<li>再散列函数法<br>当发生冲突时，换个散列函数来计算散列地址。<br>这种方法不会产生堆积，但是也相应地增加了计算时间。</li>
<li>链地址法<br>发生冲突后，把同义词的记录链接到上一个同义词的后面，构成一个单链表，称之为同义词子表，而散列表中只存储所有同义词子表的头指针（有些类似于之前介绍过的树中的孩子表示法）<br>链地址法适合处理可能会造成很多冲突的散列函数，因为它提供了绝对不会出现找不到地址的保障。但是同时，也带来了查找时需要遍历单链表的性能消耗。</li>
<li>公共溢出区法<br>发生冲突后，把冲突的关键字放到一个公共的溢出区（顺序存储表）里去。查找时，先根据关键字和散列函数计算出来的地址去查找，如果关键字不匹配，则到再溢出区里去顺序查找关键字。<br>公共溢出区法适合冲突数据很少的情况，因为在溢出区里顺序查找关键字也是比较费时的。冲突数据很少时，公共溢出区法对查找性能来说是非常高的。</li>
</ul>
</li>
<li><p><font size="4" color="red">影响散列查找性能的因素</font></p>
<ul>
<li>散列函数是否均匀，即散列函数下发生冲突的可能性是否小</li>
<li>处理冲突的方法。比如线性探测法处理冲突有可能会产生堆积现象，显然性能就没有二次探测法好。</li>
<li>散列表的装填因子。<br>装填因子=填入表中的记录个数/散列表长度。<br>显然，装填因子越大，散列表中的空闲地址就越少，产生冲突的可能性就越大。所以通常把散列表的空间设置得记录集合大。无论记录集合有多大，都总可以选择一个合适的装填因子以便将平均查找长度限定在一个范围之内，这个时候查找的时间复杂度就是O(1)了。不过这是以牺牲空间为代价的，典型的用空间换时间。</li>
</ul>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 数据结构 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 查找 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[递归与尾递归]]></title>
      <url>/2016/09/16/%E5%B0%BE%E9%80%92%E5%BD%92/</url>
      <content type="html"><![CDATA[<p>递归：在函数或者方法里调用自身，且有明确的递归结束条件。<br><a id="more"></a></p>
<hr>
<p>下面来看一个基本递归（一般意义下的递归）<br>问题：计算n!<br>计算公式为：n!=nx(n-1)x(n-2)……2x1<br>递归公式为：<img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721542273.png" alt=""><br>代码如下：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">Recursion</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//0的阶乘也等于1</span>
        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token keyword">return</span> n <span class="token operator">*</span> <span class="token function">Recursion</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在上面的每一次递归中，都需要在栈中开辟一块新的空间，用来保存当前方法的参数、局部变量、返回地址等等，便于后面递归返回时能够回溯到正确的位置和状态。如果递归深度太大，栈中就会保存大量的递归之前的数据，可能会造成栈溢出。</p>
<hr>
<p>下面再来看一下尾递归<br>问题还是：计算n!<br>代码如下：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token comment" spellcheck="true">//调用时currentValue传入1</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">Recursion</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> currentValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> currentValue<span class="token punctuation">;</span>
    <span class="token keyword">else</span> 
        <span class="token keyword">return</span> <span class="token function">Recursion</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> n <span class="token operator">*</span> currentValue<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>比较上诉两份代码，可以看到第一份代码的递归调用是在倒数第二步进行的（先递归调用再做乘法），而第二份代码的递归调用是在最后一步进行的。<br>所以，顾名思义，<strong>尾递归：对函数自身的递归调用在函数体的最后一步</strong></p>
<p>还有更有意思的，由于尾递归是在最后一步调用的自身，所以在调用返回后应该就直接退出调用函数了（因为它已经是函数体最后一步了），也就是说返回到函数体的哪个位置（返回地址）不需要了，递归到最后一层时直接退出，不再需要回溯了。而且调用函数的参数、局部变量等等也不会再用到，那么就没有必要在尾递归调用的时候在栈中开辟新的空间去存储调用之前的状态信息了。很多编译器会自动识别并这样优化尾递归（部分高级语言不支持）。这样，尾递归就带来了性能上的很大提升。</p>
<p>在第一份基本递归的代码中，由于递归调用是在倒数第二步进行的，再递归返回后还需要与方法的参数n相乘，这样就不得不在栈中开辟一块新的空间，来存储调用之前的参数n、返回地址等等。如果不开辟新的空间，下次进入递归的函数内部时，由于递归函数本身就有参数、局部变量等等，就有可能把递归调用之前的n给覆写了，导致递归返回时，跟它相乘的n不是正确的n，导致结果错误。</p>
<p>可以看到在尾递归中，不仅需要把递归调用放在最后一步，还需要设置一个参数用来保存或计算调用之前的计算结果，如第二份尾递归代码中的currentValue。其实由于尾递归没了回溯，所以它的过程还是很类似迭代的。</p>
<p>【注】：<br>可以看出，这种优化其实不止于尾递归，对于所有尾调用（在函数体最后一步调用别的函数）其实都是有这种优化的。尾递归是尾调用的一种。</p>
]]></content>
      
        <categories>
            
            <category> 数据结构 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 尾递归 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[数据结构与算法之图之拓扑排序]]></title>
      <url>/2016/09/09/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<p><font size="4" color="orange">先来看几个概念：</font><br><a id="more"></a></p>
<ul>
<li>AOV网：在表示一个工程的有向图中，用顶点表示活动，用弧表示活动之间的优先关系，这样的用有向图顶点表示活动的网，称为<strong>AOV(Activity On Vertex)网</strong></li>
<li>AOV网中不能存在回路。因为某个活动要以自己完工作为先决条件，是不可能的，也就是某个活动不可能优先于自己</li>
<li>拓扑序列：在有向图的所有顶点组成的序列中，任意弧尾顶点都排在弧头顶点之前的序列</li>
<li>拓扑排序：对一个有向图构造拓扑序列的过程。一个AOV网的拓扑序列不是唯一的。</li>
</ul>
<hr>
<p><font size="4" color="orange">拓扑排序算法</font></p>
<ul>
<li>由于是要找一个任意弧尾顶点都在弧头顶点之前的序列，所以我们可以从入度为0的顶点出发，那么怎么找到下一个顶点呢？看定义，任意弧尾顶点在弧头顶点之前，也就是说需要保证我们找到的下一个顶点不会称为之前顶点的弧头(经过1段或n段有向弧称为弧头)。怎么保证？我们切断所有从之前顶点出去的弧(以之前顶点作为弧尾的有向弧)不就ok了。所以：<br>核心思想：<strong>从AOV网中选择一个入度为0的顶点，输出并删去它以及从它出去的弧(该顶点时弧尾)，重复上述步骤，直到输出全部顶点或AOV网中不存在入度为0的顶点为止</strong>。</li>
<li><p>由于需要删除顶点，所以用邻接表要比邻接矩阵方便。因为对数组的删除操作效率并不高，有很多元素需要移位。还有我们需要查找入度为0的点，所以需要给邻接表中顶点结点增加一个数据成员InDegree，标识顶点的入度数。为了避免每次都去遍历所有顶点查找入度为0的顶点，我们需要一个栈，用来存储一开始入度就为0的顶点和删除有向弧过程中入度变为0的顶点。<br>综上，需要用到的数据结构：邻接表+栈。其中邻接表的顶点类结构如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721572839.png" alt=""></p>
</li>
<li><p>代码如下：</p>
</li>
</ul>
<hr>
<p>未完待续</p>
]]></content>
      
        <categories>
            
            <category> 数据结构 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 拓扑排序 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[数据结构与算法之改进排序]]></title>
      <url>/2016/09/03/%E6%94%B9%E8%BF%9B%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<p>排序算法主要分为7类：冒泡排序、简单选择排序、直接插入排序(这三种属于简单算法)、希尔排序、堆排序、归并排序、快速排序(这四种属于改进算法)<br><a id="more"></a></p>
<hr>
<p><font size="5" color="orange">希尔排序</font><br>希尔排序是直接插入排序的升级版。对于直接插入排序，原序列中待排序的元素还是比较多。每次插入时需要很多次后移操作(因为序列较长时一般后移距离也长)，有没有什么办法能够减少后移的距离呢？很容易想到的是，把原序列分组，在每一组内进行直接插入排序，由于每一组序列长度较小，再插入时移动的次数也就自然少了。<br>但是有一个问题，对{9，1，2，5，7，4，8，6，3，5}分成五组：{9，1}，{2，5}，{7，4}，{8，6}，{3，5}，即使每一分组都排好序后再合并：{1，9，2，5，4，7，6，8，3，5}，得到的这个序列依旧是杂乱无章的，如下图：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/14772159135.png" alt=""><br>并没有大体上让小的元素往前走，让大的元素往后走，对下一次的直接排序几乎没有多大帮助。原因在于分组时，元素间隔太小，交换位置时，只能和附近的元素交换，如果把元素间隔设大一点，就能够和较远的元素交换位置，这就增大了小元素大幅度往前走，大元素大幅度往后走的几率。但是通常仅有一次排序是不够的，需要缩小间隔再直接插入排序多次（第一次间隔gap=n/2，后面几次的间隔减半gap=gap/2，直到gap==1。直接插入排序相当于gap=1时的希尔排序）。如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/14772159142.png" alt=""><br>希尔排序的核心：<strong>按间隔分组直接插入排序，再缩小间隔分组直接插入排序，直到间隔等于1</strong><br>代码如下：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">ShellSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> gap <span class="token operator">=</span> array<span class="token punctuation">.</span>Length <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//多次分组直接插入排序，直到gap=1</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> gap <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">;</span> gap <span class="token operator">/</span><span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>Length <span class="token operator">-</span> gap<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>i <span class="token operator">+</span> gap<span class="token punctuation">]</span> <span class="token operator">&lt;</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">int</span> temp <span class="token operator">=</span> array<span class="token punctuation">[</span>i <span class="token operator">+</span> gap<span class="token punctuation">]</span><span class="token punctuation">;</span>
                <span class="token keyword">int</span> j<span class="token punctuation">;</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> temp<span class="token punctuation">;</span> j <span class="token operator">-</span><span class="token operator">=</span> gap<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    array<span class="token punctuation">[</span>j <span class="token operator">+</span> gap<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                array<span class="token punctuation">[</span>j <span class="token operator">+</span> gap<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>【注】：</p>
<ul>
<li>由于希尔排序比直接插入排序减少了移动距离(移动次序)，所以希尔排序的效率比直接插入排序高，也就自然比简单选择排序和冒泡排序性能好了。进过分析希尔排序的平均时间复杂度是O(nlogn)。</li>
<li>由于希尔排序是将元素跳跃式分组，插入元素时也是跳跃式插入，如上图中第一轮排序里两个5在排序前后的次序发生了变化，所以希尔排序是不稳定排序。</li>
<li>大量研究表明，当间隔序列为<img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721591476.png" alt=""><br>时，可以获得不错的效果。但是最后一个增量值必须等于1。</li>
</ul>
<hr>
<p><font size="5" color="orange">堆排序</font><br>堆排序是对简单选择排序的一种改进。来看几个定义：</p>
<ul>
<li>堆是一棵<strong>完全二叉树</strong>，满足一下特性：所有结点比它的子结点大（大顶堆）或者所有结点比它的子结点小（小顶堆）。</li>
<li>堆可以用层序遍历的次序存入到数组中</li>
</ul>
<p><strong>把待排序的序列建成一个大顶堆的方法：</strong><br>先把待排序的序列按照层序构建成一棵完全二叉树，再从下往上、从右到左，将每个非叶结点与其左右子结点的较大值互换，直到比它的左右儿子都大为止。</p>
<p>比如有一个待排序序列：{50，10，90，30，70，40，80，60，20}，先按层序构建成完全二叉树，如下图：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721591531.png" alt=""><br>接下来从下往上，从右到左的第一个非叶结点是30，将它与左右儿子的较大者60互换，结果如下图：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721591581.png" alt=""><br>接着从下往上，从右到左的第二个非叶结点是10，将它与左右儿子的较大者70互换，结果如下图：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721591637.png" alt=""><br>再接下来从下往上，从右到左的第三个非叶结点是90，因为它本身就比它的左右儿子都大，所以不用互换了。<br>再接下来从下往上，从右到左的第四个非叶结点是50，将它与左右儿子的较大者90互换，因为要一直换到比左右儿子都大为止，所以把50、90互换之后，50还要和它的左右儿子的较大者80互换，结果如下图：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721591688.png" alt=""><br>到此，整个大顶堆就构建完成了。那么如何利用这个大顶堆来排序呢？</p>
<p><strong>利用大顶堆来排序的方法：</strong><br>把根结点元素与还未排序的最后一个元素交换位置（层序下的最后一个未排序元素），再把交换后的根结点与其左右孩子的较大者交换，直到比它的左右孩子都大。重复，直到所有结点都排序完成。</p>
<p>对上面的大顶堆排序的过程如下：<br>先把根结点90和待排序的最后一个元素20交换位置，结果如下图：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721591734.png" alt=""><br>再把20和它的左右儿子的较大者交换位置，直到比它的左右儿子都大，结果如下图：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721591805.png" alt=""><br>这样最大的元素90就被放到了数组的最后一个位置，是不是有点像选出了最大的元素然后把它放到最后的位置？？？所以从这里可以看出堆排序是简单选择排序的改进版。<br>接下来把根结点80和待排序的最后一个元素30交换位置，结果如下图：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721591858.png" alt=""><br>再把30和它的左右儿子的较大者交换位置，直到比它的左右儿子都大，结果如下图：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721591909.png" alt=""><br>后面的变化完全类似，不再赘述，如下图：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721591965.png" alt=""><br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721592021.png" alt=""><br>至此，便完成了堆排序的过程。<br>经过分析，堆排序的时间复杂度为O(nlogn)（堆排序对原始序列的排序状态并不敏感，所以堆排序的最好、最坏和平均时间复杂度都为O(nlogn)），空间复杂度为O(1)。但是由于它的交换是跳跃式的（不是和相邻的元素交换），所以堆排序也是一种不稳定排序。<br>【注】：</p>
<ul>
<li>由于构建堆的时候需要很多次比较，所以它并不适合待排序序列个数较少的情况，因为得不偿失嘛！</li>
</ul>
<p>代码如下：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>
using namespace std;

void HeapSort(int array[], int length);
int main()
{
    int array[] = { 65535,1,6,9,7,2,5,0,3,1 };
    int length = sizeof(array) / sizeof(int);
    HeapSort(array, length-1);

    for (int i = 1; i < length; i++) {
        cout << array[i] << ' ';
    }

    int key;
    cin >> key;
    return 0;
}

int GreaterRoot(int array[], int i, int length);
void HeapSort(int array[], int length) {  //数组从1开始存数
    //构建大顶堆
    for (int i = length / 2; i >= 1; i--) {
        int j = GreaterRoot(array, i, length);
        while (j != 0) {  //一直向下调整到比它的子结点都大
            j = GreaterRoot(array, j, length);
        }
    }
    //对大顶堆排序
    for (int i = length; i >= 2; i--) {
        //第一个位置和右下角最后一个未排序位置互换
        int temp;
        temp = array[1];
        array[1] = array[i];
        array[i] = temp;
        //将调到第一个位置的元素和它的子结点一直向下比较，直到重新调整为大顶堆
        int j = GreaterRoot(array, 1, i - 1);
        while (j != 0) {
            j = GreaterRoot(array, j, i - 1);
        }
    }
}

//如果该结点已经比子结点都大，则返回0，否则返回跟它交换的那个子结点的编号
int GreaterRoot(int array[], int i, int length) {
    if (i * 2 > length)   //叶节点
        return 0;
    if (array[i] > array[2 * i] && (2 * i + 1 > length || array[i] > array[2 * i + 1])) { //只有左儿子，但是比左二子大，或者有右儿子但是比左右儿子都大
        return 0;
    }

    if (2 * i + 1 > length || array[2 * i] > array[2 * i + 1]) {  //和子结点的较大者交换
        int temp;
        temp = array[i];
        array[i] = array[2 * i];
        array[2 * i] = temp;
        return 2 * i;
    }
    else {
        int temp;
        temp = array[i];
        array[i] = array[2 * i + 1];
        array[2 * i + 1] = temp;
        return 2 * i + 1;
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<hr>
<p><font size="5" color="orange">归并排序</font><br>归并排序很简单，归并在数据结构中定义是将两个或者两个以上的有序表组合成一个新的有序表。2路归并排序就是每两个一组进行排序，再归并（合起来并同时排序），再每两个一组进行排序，再归并，直到不能再归并为止（或者得到的有序序列长度等于原始待排序序列长度为止）。如下图所示：<br>迭代图示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721592075.png" alt=""><br>递归图示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721592208.png" alt=""><br>归并排序可以用递归来实现，也可以用迭代（非递归）来实现。<br>归并排序的递归代码如下：<br>归并排序的迭代代码如下：</p>
<hr>
<p><font size="5" color="orange">快速排序</font><br>希尔排序是直接插入排序的升级版，属于插入排序类，堆排序是简单选择排序的升级版，属于选择排序类，而快速排序是冒泡排序的升级版，属于交换排序类。</p>
<p>快速排序的核心思想：<strong>随机选择一个基准数，把小于基准数的元素移到基准数左边，把大于等于基准数的元素移到基准数右边。再分别对左右两边的元素重新选择基准数，重复上诉过程，直到排序结束（从小到大排序）</strong>。</p>
<p>快速排序的具体方法（这里介绍两种：哨兵换岗法、挖坑填数法）</p>
<ul>
<li><p><strong>哨兵换岗法：</strong><br>随机选择一个基准数（一般选择待排序序列最左边的数），开始时左哨兵指向序列头，右哨兵指向序列尾。右哨兵先向左移动，直到找一个小于基准数的数，然后左哨兵向右移动，直到找到一个大于基准数的数，然后两哨兵换岗（两哨兵所在的元素交换位置，这样小的就到左边了，大的就到右边了）。重复上诉过程直到右哨兵和左哨兵相遇，再把相遇的数和基准数交换位置。这样一次排序后，比基准数小的全在它的左边，比基准数大的全在它的右边，再分别对左右两边进行上诉排序，直到排序完成（一看就是递归）。</p>
<p>例如要对{6，1，2，7，9，3，4，5，10，8}这个序列进行排序：</p>
<ul>
<li>假定选择6作为基准数，设置左哨兵i和右哨兵j，如下图：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721592267.png" alt=""></li>
<li>然后右哨兵j向左走找到比6小的数5，左哨兵i向右走找到比6大的数7，交换5和7，如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721592322.png" alt=""></li>
<li>接着右哨兵继续向左走找到比6小的数4，左哨兵向右走找到比6大的数9，交换4和9，如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/14772159238.png" alt=""></li>
<li>然后右哨兵继续向左走找到比6小的数3，左哨兵向右走去找比6大的数，结果遇到右哨兵了，把左右哨兵所在的数3和基准数交换。到此第一轮排序结束了。如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721592443.png" alt=""></li>
<li>再对6左边的序列{3，1，2，5，4}进行上诉排序，以3为新的基准数得到的序列应该是：{2，1，3，5，4}，这样比3小的都在3左边，比3大的都在3右边。再对序列{2，1}和{5，4}进行排序，最后得到的序列应该是：{1，2，3，4，5，6，9，7，10，8}，对6右边的序列{9，7，10，8}也是同样的排序方式，最终得到的序列是：{1，2，3，4，5，6，7，8，9，10}</li>
</ul>
<p>代码如下：</p>
</li>
<li><p><strong>挖坑填数法：</strong><br>随机选择一个基准数（一般选择待排序序列最左边的数），将基准数所在的位置看作第一个坑，从右往左找第一个小于基准数的数，把它挪到坑里去（这个数原先所在的位置就形成了一个新的坑），再从左往右找第一个大于基准数的数，把它挪到新坑里去。重复上诉过程直到左右相遇，再把基准数挪到最后一个坑里去。样一次排序后，比基准数小的全在它的左边，比基准数大的全在它的右边，再分别对左右两边进行上诉排序，直到排序完成（从小到大排序。而且其实也是有哨兵的，不过为了突出挖坑，下面的图示没有画出哨兵）。</p>
<p>例如要对{6，1，2，7，9，3，4，5，10，8}这个序列进行排序：</p>
<ul>
<li>假定选择6作为基准数，则6所在的位置就是第一个坑，如下图：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/14772159264.png" alt=""></li>
<li>从右往左找到小于基准数6的数5，把它挪到坑里，结果如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721592689.png" alt=""></li>
<li>再从左往右找到大于基准数6的数7，把它挪到坑里，结果如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/14772159274.png" alt=""></li>
<li>接下来继续从右往左找到小于基准数6的数4，把它坑里，如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721592787.png" alt=""><br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/14772159284.png" alt=""></li>
<li>再从左往右找到大于基准数6的数9，把它挪到坑里，结果如下图：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721592895.png" alt=""></li>
<li>接着继续从右向左找到小于基准数6的数3，把它挪到坑里，如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721592954.png" alt=""><br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721593007.png" alt=""></li>
<li>再从左往右去找大于基准数6的数，结果发现左右相遇了，这时到第一轮排序的最后一步了，把基准数挪到坑里，结果如下图：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721593055.png" alt=""></li>
</ul>
<p>到此，快速排序的挖坑填数法的第一轮排序就结束了，接下来再对基准数左右两边的序列重复上诉排序过程就ok了。<br>代码如下：</p>
<p>从排序过程和代码都可以看出，挖坑填数法其实是哨兵换岗法的改进版，挖坑填数法一样存在左右哨兵，但是明显交换次数少了（交换时的赋值语句少了）。</p>
</li>
</ul>
<p>快速排序的时间性能取决于快速排序递归的深度，当选择的基准数恰好接近待排序序列的中间值时，例如在哨兵换岗法中选择的基准数6恰好就接近序列中间值，此时快速排序的性能较好，时间复杂度为O(nlogn)，空间复杂度为O(logn)；但是如果待排序的序列恰好是已经有序或基本有序的，如序列{1，2，3，4，5，6，7，8，9，10}或者{10，9，8，7，6，5，4，3，2，1}，此时快速排序的深度就为n-1，性能较差，时间复杂度为O(n^2)，空间复杂度为O(n)。平均情况，快速排序的时间复杂度为O(nlogn)，空间复杂度为O(logn)。</p>
<p><strong>对快速排序的优化：</strong></p>
<ol>
<li>优化选取基准数<br>每次选择待排序序列的第一个元素作为基准数，就很有可能选中的数值太大或者太小，造成快速排序性能太低，对怎么选择基准数有以下几种方法：<ul>
<li>不再是每次选待排序序列的第一个元素作为基准数，而是随机选取一个。其实对于无序的序列来说，这种随机选取和选择第一个元素是一个意思，并不能起到优化作用，还会增加随机数生成器本身带来的开销</li>
<li>三数取中。随机取三个数，选择大小在中间的那个数，来作为快速排序的基准数。为了避免随机数带来的消耗，实际上取序列左端、右端、中间位置的三个数即可。因为这和随机是一个效果嘛。从概率上来说，取到的三个数均为序列中最小或者最大数的可能性是很小的，所以三个数中的中间数接近序列的中间数的可能性就提高了。</li>
<li>九数取中。和三数取中是一个意思，在数组中分三次取样，每次选出各组的中间数，再在这三个中数种选出一个中数作为基准数。九数取中一般用于序列长度比较大的情况下，以保证取出的基准数比较接近序列的中值。</li>
</ul>
</li>
<li>减少交换次数。在哨兵换岗法中，右哨兵和左哨兵找出的数要互相交换位置，这种swap交换需要三个赋值语句，其实可以减少。而挖坑填数法正好是哨兵换岗法的这种优化，把要调到前面或者后面的数填到坑里就行，不一定要正好调换两个哨兵的位置，只要保证把小的大致往前放，把大的大致往后放就行。比如右哨兵找到了一个比基准数小的数，左哨兵找到了一个比基准数大的数，这时候其实不需要交换左右哨兵，只需要把右哨兵填到前面的坑里（基准数那个位置），再把左哨兵填到后面的坑里（原右哨兵空出来的位置），这样就大致保证了“把小的往前挪，把大的往后挪”的原则，同时减少了交换次数（在下图中可以看到只有两次赋值，而不是三次），如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/14772159251.png" alt=""></li>
<li>小数组时使用直接插入排序（直接插入排序是简单排序中性能最好的）。对于序列元素较少时，使用快速排序反而不如直接插入排序，因为快速排序用到了递归操作，在数据量大时，相比于快排的优势递归带来的开销可以忽略，但数据量小时就无法忽略了。所以对快排的优化，可以在待排序序列长度递归到很小时，就不再继续用快排进行排序了，而换成直接插入排序。一般递归到待排序序列长度小于7（有时是50）时，改为使用直接插入排序。伪码如下：<pre class="line-numbers language-csharp"><code class="language-csharp"> <span class="token keyword">const</span> <span class="token keyword">int</span> Length_InsertSort <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">;</span>
 <span class="token keyword">void</span> <span class="token function">QuickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">,</span><span class="token keyword">int</span> low<span class="token punctuation">,</span><span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token punctuation">{</span>
     <span class="token keyword">int</span> pivot<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//基准数在序列中的位置</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">></span> Length_InsertSort<span class="token punctuation">)</span><span class="token punctuation">{</span>
         <span class="token comment" spellcheck="true">//递归待排序序列长度大于7时用快速排序</span>
         pivot <span class="token operator">=</span> <span class="token function">Partition</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//把array[low..high]一分为二，小的在左边，大的在右边，返回基准数所在的位置</span>
         <span class="token function">QuickSort</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> low<span class="token punctuation">,</span> pivot <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//对基准数左边的序列递归排序</span>
         <span class="token function">QuickSort</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> pivot <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//对基准数右边的序列递归排序</span>
     <span class="token punctuation">}</span>
     <span class="token keyword">else</span> <span class="token punctuation">{</span>
         <span class="token comment" spellcheck="true">//递归待排序序列长度小于等于7时用直接插入排序</span>
         <span class="token function">InsertSort</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>减少递归调用的次数。在上述代码中，第一个递归调用和第二个递归调用做的都是相同的Partition操作，其实可以把它俩合成一个。伪码如下：<pre class="line-numbers language-csharp"><code class="language-csharp"> <span class="token keyword">const</span> <span class="token keyword">int</span> Length_InsertSort <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">;</span>
 <span class="token keyword">void</span> <span class="token function">QuickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">,</span><span class="token keyword">int</span> low<span class="token punctuation">,</span><span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token punctuation">{</span>
     <span class="token keyword">int</span> pivot<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//基准数在序列中的位置</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">></span> Length_InsertSort<span class="token punctuation">)</span><span class="token punctuation">{</span>
         <span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;</span> high<span class="token punctuation">)</span>
         <span class="token punctuation">{</span>
             <span class="token comment" spellcheck="true">//递归待排序序列长度大于7时用快速排序</span>
             pivot <span class="token operator">=</span> <span class="token function">Partition</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//把array[low..high]一分为二，小的在左边，大的在右边，返回基准数所在的位置</span>
             <span class="token function">QuickSort</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> low<span class="token punctuation">,</span> pivot <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
             low <span class="token operator">=</span> pivot <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
         <span class="token punctuation">}</span>
     <span class="token punctuation">}</span>
     <span class="token keyword">else</span>
     <span class="token punctuation">{</span>
         <span class="token comment" spellcheck="true">//递归待排序序列长度小于等于7时用快速排序</span>
         <span class="token function">InsertSort</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
将<code>low=pivot+1</code>后，再循环来一次<code>pivot = Partition(array, low, high);</code>，其实就是<code>pivot = Partition(array, pivot+1, high);</code>，与<code>QuickSort(array, pivot + 1, high);</code>是同样的效果，因为QuickSort本来做的就是Partition操作。但是使用循环减少了一个递归调用，从而减少了堆栈带来的开销，提高了性能。</li>
</ol>
<hr>
<p><font size="5" color="orange">7种排序算法的时间复杂度和空间复杂度的比较</font><br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721592573.png" alt=""></p>
]]></content>
      
        <categories>
            
            <category> 数据结构 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 改进排序 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[数据结构与算法之简单排序]]></title>
      <url>/2016/09/03/%E7%AE%80%E5%8D%95%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<p>排序：将一组记录序列变成，在一组关键字的非递减(或非递增)排列下的映射记录序列。<br><a id="more"></a><br>比如下面这4个人的总分成绩为：<br>令狐冲 753，郭靖 573，杨过 682，张无忌 753<br>按照总分成绩这组关键字的非递减排列{573，682，753，753}，那么排序后的记录应该是：郭靖 573，杨过 682，令狐冲 753，张无忌 753<br>所以排序的依据是关键字之间的大小关系。</p>
<hr>
<p>排序的稳定性：当关键字相等时，如果排序前后对应记录的先后次序没有发生变化，则是稳定排序，如果变化了则是不稳定排序。如上面的例子有两个相等的关键字753，排序前令狐冲记录在张无忌记录前面，若排序后令狐冲记录还是在张无忌记录前面，则是稳定排序；若排序后令狐冲记录跑到了张无忌记录后面，则是不稳定排序。如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/14772158907.png" alt=""></p>
<hr>
<p>排序算法主要分为7类：冒泡排序、简单选择排序、直接插入排序(这三种属于简单算法)、希尔排序、堆排序、归并排序、快速排序(这四种属于改进算法)</p>
<p><font size="4" color="orange">冒泡排序</font><br>冒泡排序是一种交换排序，核心思想是：两两比较，符合大小关系则交换，将最小的元素浮到最上面(非递减排序)</p>
<ul>
<li>冒泡排序初级版<br>如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721589126.png" alt=""><br>先让数组中第一个元素依次和后面的元素作比较，如果小于则交换位置，交换位置后依然是让第一个元素继续和后面的元素作比较，直到比到数组中最后一个元素为止。这样第一轮完了以后最小的元素(数字1)就浮到了最上面。<br>然后让数组中的第二个元素依次和后面的元素作比较，如果小于则交换位置。这样第二轮完了以后最小的元素(数字2)就浮到了次上面。<br>以此类推，9个元素8轮比较后，就完成了整个排序。<br>代码如下：<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">BubbleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">//i既表示比较多少轮，也表示数组下标，所以得从0开始</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>Length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token comment" spellcheck="true">//j表示数组下标</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>Length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
              <span class="token keyword">int</span> temp <span class="token operator">=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
              array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
              array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
          <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>正宗的冒泡排序<br>上面的初级版其实效率是很低的，一个数字浮上去了却对其它数字没有任何帮助，比如在第二轮里2虽然浮上去了，却把3沉下来了。我们希望能够找到一种算法能够让2浮上去的同时，不会把3沉那么多下来。仔细观察会发现，初级版冒泡是把当前元素和与之比较的元素作交换，这两个元素有可能位置相差很远，就很有可能会让数值较小的元素一下大幅度沉底，比如上面第二轮的最后一次交换，让仅仅比2小的3一下子就沉底了。<br>那么能不能缩短每次交换的元素的距离呢？也就是缩短相比较的两个元素的距离。这就是正宗的冒泡排序：<strong>每次只比较相邻的两个元素的大小</strong>。不过它是从数组后面往前面比的，因为要冒泡把最小(或最大)的元素浮上去嘛。如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721589189.png" alt=""><br>先让数组最后一个元素和倒数第二个元素比较，如果小于则交换位置，再让倒数第二个元素和倒数第三个元素作比较，以此类推。因为每次比较的结果都是较小的元素在上面，所以一轮完成后就能把最小的元素浮到最上面去。以此类推，9个元素8轮比较后，就完成了排序。可以看到在把1浮到最上面的同时，也把2浮上去了很多，这相比初级版的冒泡会减少很多交换次数。<br>代码如下：<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">BubbleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">//i既表示比较多少轮，也表示数组下标，所以得从0开始</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>Length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> array<span class="token punctuation">.</span>Length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">></span> i<span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> array<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//注意这里和冒泡初级版的差别</span>
              <span class="token keyword">int</span> temp <span class="token operator">=</span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
              array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
              array<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
          <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>冒泡排序升级版<br>正宗的冒泡排序也只是比初级版的冒泡减少了交换次数而已，那么有没有可能减少比较次数呢？如下面的情况：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721589249.png" alt=""><br>第一轮交换完，最小元素浮到最上面以后，下面的序列就已经有序了，那么其实后面的比较都不用了。但是在正宗的冒泡算法里，后面的比较还是要继续的。为了减少这种无用的比较，我们可以设置一个bool变量，标识这一轮比较有没有数据交换，如果没有，则说明后面的元素已经有序了，不用再比较了。<br>代码如下：<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">BubbleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">//标识后面的元素是否已经有序</span>
  <span class="token keyword">bool</span> ordered <span class="token operator">=</span> <span class="token keyword">false</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">//i既表示比较多少轮，也表示数组下标，所以得从0开始</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">!</span>ordered <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>Length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      ordered <span class="token operator">=</span> <span class="token keyword">true</span><span class="token punctuation">;</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> array<span class="token punctuation">.</span>Length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">></span> i<span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> array<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
              <span class="token keyword">int</span> temp <span class="token operator">=</span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
              array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
              array<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
              ordered <span class="token operator">=</span> <span class="token keyword">false</span><span class="token punctuation">;</span>
          <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<hr>
<p><font size="4" color="orange">简单选择排序</font><br>冒泡排序还是存在着很多次的位置交换，有没有可能直接找到某个元素应该所处的位置，然后只交换一次就可以了呢？选择排序就是这样的。<br>简单选择排序的核心思想：<strong>在每一轮排序中找出最小的元素，把它放到该轮次对应的位置上去</strong>。如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721589296.png" alt=""><br>在第一轮排序中，找到最小的元素是1，将它与数组中第一个元素交换位置<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721589346.png" alt=""><br>在第二轮排序中，在剩下的元素中找到的最小元素是2，将它与数组中第二个元素交换位置<br>以此类推…<br>代码如下：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">SimpleSelectSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//i既表示比较多少轮，也表示数组下标，所以得从0开始</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>Length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> minIndex <span class="token operator">=</span> i<span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>Length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> array<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                minIndex <span class="token operator">=</span> j<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>minIndex <span class="token operator">!=</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">int</span> temp <span class="token operator">=</span> array<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>
            array<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>由于简单选择排序每一轮最多只有一次交换数据，不像冒泡排序那样频繁地交换位置，所以简单选择排序的性能要略优于冒泡排序。</p>
<p><font size="4" color="orange">直接插入排序</font><br>直接插入排序的核心：<strong>一开始把数组的第一个元素看作是一个有序序列，接着在每一轮排序中把轮次对应的元素插入到该有序序列(数组的前i个元素就是该有序序列)中去</strong>。如下图所示(箭头表示接下来这一轮排序中将要后移的元素)：<br>有一组待排序的序列如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721589397.png" alt=""><br>把第一个元素9看作是一个有序序列：{9}<br>在第一轮排序中，要将元素1插入到有序序列{9}(数组前1个元素)中，先将有序序列中大于1的所有元素右移一位，左边会多出一个空位(如下图中的残缺方块)，再把1插入到空位中去。结果如下图：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721589444.png" alt=""><br>在第二轮排序中，要将元素5插入到有序序列{1，9}(数组前两个元素)中，先将有序序列中大于5的所有元素右移一位，会出现一个空位(如下图中的残缺方块)，再把5插入到空位中去。结果如下图：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721589497.png" alt=""><br>在第三轮排序中，要将元素8插入到有序序列{1，5，9}(数组前三个元素)中，先将有序序列中大于8的所有元素右移一位，出现空位，再把8插入到空位中去。结果如下图：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721589544.png" alt=""><br>在第四轮排序中，要将元素3插入到有序序列{1，5，8，9}中，需要先将有序序列中所有大于3的元素右移一位，出现空位，再把3插入到空位中去。结果如下图：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721589591.png" alt=""><br>一次类推，9个元素8轮插入后，将完成整个排序。<br>【如果要插入元素的左边没有比它大的元素，则让这个要插入的元素什么也不做，保留在原地】<br>代码如下：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">StraightInsertSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>Length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//如果要插入元素小于左边有序序列最大值，则让有序序列中所有比它大的元素右移一位</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">int</span> temp <span class="token operator">=</span> array<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//保存要插入元素的值，因为在右移过程中会覆盖这个元素</span>
            <span class="token keyword">int</span> j<span class="token punctuation">;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> temp<span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                array<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment" spellcheck="true">//把要插入元素插入到移出来的空位中去</span>
            array<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>因为插入排序是向有序序列中插入新元素的，所以比较次数会比简单选择排序少，且每一轮排序都只是把大于的元素往后移再插入一个元素而已，所以直接插入排序要比简单选择排序和冒泡排序的性能好一些。</p>
]]></content>
      
        <categories>
            
            <category> 数据结构 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 简单排序 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[数据结构与算法之关键路径]]></title>
      <url>/2016/09/01/%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/</url>
      <content type="html"><![CDATA[<p>先来看几个概念和式子：<br><a id="more"></a><br>关键路径：从源点到汇点具有最大长度的路径<br>关键活动：关键路径上的活动<br>事件：带权图中的顶点<br>活动：带权图中的边<br>事件(顶点)Vi的最早发生时间VE：源点到顶点的最长距离<br>事件(顶点)Vi的最晚发生时间VL：工期-结点到汇点的最长距离<br>活动的最早开始时间AE：对应有向边的起点的最早发生时间<br>活动的最晚开始时间AL：对应有向边的终点的最晚发生时间-该有向边的权值<br>关键活动：AE=AL的活动(边)</p>
<p>求关键路径的步骤：</p>
<ol>
<li>从源点开始，向后求出每一个结点的最长路径（也就是AE），直到汇点为止（到某个顶点有多个路径值时取最大值）。</li>
<li>从汇点开始反推，向前求出每一个结点的【工期-汇点到结点的最长路径】，即AL，直到源点为止（到某个结点有多个路径值是取最小值）。</li>
<li>取出上面两步中AE=AL的点，由它们构成的路径就是关键路径。</li>
</ol>
<p>【注】：</p>
<ul>
<li>求源点到结点的最长路径或者汇点到结点的最长路径，都可以根据已经求出的点作为跳板来计算，这一点和<a href="http://popperelay.com/2016/09/01/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/" target="_blank" rel="external">《最短路径》</a>有点像</li>
<li>图的关键路径不唯一，有多条关键路径时，需要同时提高这些关键路径上的活动的速度，才能缩短工期。</li>
</ul>
<p>举例如下，求下面这幅图的关键路径：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148937126897.png" alt=""><br>先从源点开始，算出每个结点的最长路径AE；再从汇点开始，算出每个路径的AL。结果如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148937126934.png" alt=""><br>取出AE和AL相等的结点V0、V2、V3、V4、V7、V8、V9。所以关键路径如下图：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148937126977.png" alt=""></p>
<hr>
<p>未完待续</p>
]]></content>
      
        <categories>
            
            <category> 数据结构 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 关键路径 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[数据结构与算法之图之最短路径]]></title>
      <url>/2016/09/01/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</url>
      <content type="html"><![CDATA[<p>最短路径：两顶点之间权值之和最小的路径<br><a id="more"></a><br>寻找带权图(网图)中两点之间最短路径的算法主要有两种：迪杰斯特拉(Dijkstra)算法、弗洛伊德(Floyd)算法</p>
<hr>
<font size="4" color="orange">迪杰斯特拉(Dijkstra)算法</font><br>迪杰斯特拉算法的核心思想：在每个顶点处，都会去存储它到周围点的路径长度。每次找出未知结点中到源点路径最短的结点，看其周围的结点是否会通过它得到比以前更短的路径长度，若是，则更新对应结点的最短路径长度和其前驱结点。<br>如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148932661037.png" alt=""><br>要求源点V0到终点V8的最短路径，根据迪杰斯特拉算法需要先求得到中间所有顶点的最短路径：<br>1. 先将V0加入已知顶点序列，V0到V0的最短距离自然是0，前驱结点就设为它自己吧：0，它周围点V1的当前最短路径就变为1，前驱结点为0；V2的当前最短路径变为5，前驱结点为0.如下图所示（空的地方路径都是无穷大，不可达）：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148932660766.png" alt=""><br>2. 然后找出未知结点中当前路径长度最短的，为V1，把它加入已知结点序列，以V1为跳板的话，V2的路径长度就变为了4（V1的最短路径加上V1到V2的长度），比之前存储的5要短，所以把V2的当前最短路径变为4，前驱结点变为1；V3的当前最短路径变为8，前驱结点变为1；V4的当前最短路径变为6，前驱结点为1.如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148932660805.png" alt=""><br>3. 然后找出未知结点中当前路径长度最短的，为V2，把它加入已知顶点序列，以V2为跳板的话，V4的路径长度变为5，比之前的6要短，所以把V4的当前最短路径变为5，前驱结点变为2；V5的当前最短路径变为11，前驱结点变为2.如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148932660833.png" alt=""><br>4. 然后继续找出未知结点中当前路径长度最短的，为V4，把它加入已知顶点序列，以V4为跳板的话，V3的路径长度变为7，比之前的8要短，所以把V4的当前最短路径变为7，前驱结点变为4；同样V5比之前也短了，当前最短路径变为8，前驱结点变为4；V6、V7的当前最短路径分别变为11和14，前驱结点变为4。如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148932660866.png" alt=""><br>5. 然后继续找出未知结点中当前路径长度最短的，为V3，把它加入已知顶点序列，以V3为跳板的话，V6的路径长度变为9，比之前的11要短，所以把V6的当前最短路径变为9，前驱结点变为3。如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148932660897.png" alt=""><br>6. 然后继续找出未知结点中当前路径长度最短的，为V5，把它加入已知顶点序列，以V5位跳板的话，V7的路径长度变为13，比之前的14要短，所以把V7的当前路径长度变为13，前驱结点变为5。如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148932660931.png" alt=""><br>7. 然后找出最短的V6，把它加入已知顶点序列，以V6为跳板，V7的路径长度变为11，比之前的13要短，所以把V7的当前最短路径变为11，前驱结点变为6；V8的当前最短路径变为16，前驱结点变为6。如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148932660964.png" alt=""><br>8. 然后找出最短的V7，把它加入已知顶点序列，以V7位跳板，V8的路径长度变为15，比之前的16要短，所以把V8的当前最短路径变为15，前驱结点变为7。如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148932660999.png" alt=""><br>9. 然后找出最短的V8，把它加入已知顶点序列，现在图中的所有顶点都在已知顶点序列中了，终止循环。<br><br>V8的最短路径就是一个一个地回溯前驱结点：V8的前驱结点是6，V6的前驱结点是3，V3的前驱结点是4，V4的前驱结点是1，V1的前驱结点是0。所以最短路径是：V0 → V1 → V4 → V3 → V6 → V8。<br>迪杰斯特拉算法求最短路径的代码如下：<br><br>迪杰斯特拉算法求某两点之间的最短路径的时间复杂度为O(n^2)，求所有顶点到所有顶点之间最短路径的时间复杂度为O(n^3)。<br><em>*</em><br><font size="4" color="orange">弗洛伊德(Floyd)算法</font>

<hr>
<p>未完待续</p>
]]></content>
      
        <categories>
            
            <category> 数据结构 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 最短路径 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[数据结构与算法之图之最小生成树]]></title>
      <url>/2016/09/01/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
      <content type="html"><![CDATA[<p>看下面这个实际问题：<br><a id="more"></a><br>假设你是电信的工程师，需要为下面的9个村庄架设网线，村庄位置如下图所示。边上的数字表示村庄之间的距离。要求以最小的成本使这9个村庄的网线互通，应该怎么办？<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721569563.png" alt=""><br>最小成本，自然是需要连线的公里数最小。因为只需要9个村庄网线互通，不要求直接可达，所以设计路线至少应该是一颗生成树，9个结点，只铺设8条线路即可。但是图的生成树有很多个，我们需要代价最小的那棵生成树，即最小生成树。<br>要根据图找出这棵最小生成树，有两种算法：普里姆(Prim)算法、克鲁斯卡尔(Kruskal)算法。</p>
<hr>
<p><font size="5" color="orange">普里姆(Prim)算法</font><br>算法规则：</p>
<ol>
<li>设置一个已知顶点序列和一个生成树边序列。</li>
<li>先随机找一个顶点，把这个顶点加入已知顶点序列中</li>
<li>找出已知顶点和图中剩余顶点(未知顶点)之间权值最小的边，把这个边加入到生成树边序列中，并且把这条边上的那个未知顶点加入到已知顶点序列中</li>
<li>重复步骤3，直到已知顶点序列已经包含了图中所有的顶点为止</li>
</ol>
<p><strong>Prim算法核心：从已知顶点到未知顶点中找出最小边（权值最小）</strong><br>按Prim算法找出的最小生成树如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721569616.png" alt=""><br>代码如下：</p>
<p>普里姆(Prim)算法的时间复杂度为O(n^2)。</p>
<hr>
<p><font size="5" color="orange">克鲁斯卡尔(Kruskal)算法</font><br>算法规则：</p>
<ol>
<li>设置最小生成树的一个顶点序列和一个边序列。先确定图中的所有顶点，全部存放到最小生成树的顶点序列中，边序列还是空的</li>
<li>找出原图中除去最小生成树边序列以外的权值最小的边，如果这条边的两个顶点在现有最小生成树的不同连通子图上(也就是加入这条边后不会在现有生成树中形成回路)，则加入到最小生成树的边序列中</li>
<li>重复第2步，直到现有最小生成树的所有边都在同一连通子图上(只有一个连通分量)</li>
</ol>
<p><strong>Kruskal算法核心：从剩下的边中找出不会构成回路的最小边（权值最小）</strong><br>按Kruskal算法找出的最小生成树如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721569664.png" alt=""><br>代码如下：</p>
<p>克鲁斯卡尔(Kruskal)算法的时间复杂度为O(eloge)。其中e是图的边数</p>
<hr>
<p><font size="5" color="orange">普里姆(Prim)算法和克鲁斯卡尔(Kruskal)算法的比较：</font></p>
<ol>
<li>普里姆算法是从结点入手的，找出已知结点和未知结点之间权值最小的边；克鲁斯卡尔算法是从边入手的，其最小生成树中的所有结点已经事先确定好，再去找不会构成回路的权值最小的边</li>
<li>普里姆算法在边数非常多的情况下，比如稠密图，效率会比克鲁斯卡尔算法高；而在边数比较少时，例如稀疏图，克鲁斯卡尔算法的效率比普里姆算法高</li>
</ol>
<hr>
<p>未完待续</p>
]]></content>
      
        <categories>
            
            <category> 数据结构 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 最小生成树 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[数据结构与算法之图]]></title>
      <url>/2016/09/01/%E5%9B%BE/</url>
      <content type="html"><![CDATA[<p><font size="4" color="orange">先来看几个图的概念和特性</font><br><a id="more"></a></p>
<ul>
<li>图：由顶点的有穷非空集合和顶点之间边的集合组成</li>
<li>完全图：图中任意两个顶点之间都存在可直接到达对方的边。分为无向完全图和有向完全图，其中无向完全图有n(n-1)/2条边，有向完全图有n(n-1)条边</li>
<li>稀疏图：边数很少的图，反之为稠密图</li>
<li>简单路径：路径的顶点序列中不存在重复的顶点</li>
<li>连通图：任意两点之间都有路径可达(不需要直接可达)的<strong>无向图</strong></li>
<li>强连通图：任意两点之间都有路径可达的<strong>有向图</strong></li>
<li>连通分量：非连通无向图中的极大连通子图(顶点数最大)叫做连通分量</li>
<li>强连通分量：非强连通有向图的极大强连通子图叫做强连通分量</li>
<li>连通图的生成树：连通图的极小连通子图。有n个顶点时，只有n-1条边，随便加哪两个顶点之间的边都将构成环，而生成树里是没有环的。</li>
<li>网：带权图称为网</li>
</ul>
<hr>
<p><font size="4" color="orange">图的存储结构</font><br>由于图的结构比较复杂，任意两点之间都可能存在联系，难以用元素在内存中的物理位置来表示元素之间的关系，也就是图不可能用简单的顺序存储结构来表示。前辈们给我们提供了图的5种存储结构：</p>
<ul>
<li><p>图的邻接矩阵存储方式：<br>将图的点和边分开存储，用一个一维数组加一个二维数组来表示图。一维数组存储图中的顶点信息，二维数组(邻接矩阵)存储图中边或弧的信息。<br>当然，边数组不仅可以存储0,1这两个数字，如果是带权图(网)，边数组中还能存储对应边的权值。不过这时需要指定一个比较大的数来标识图中不存在的边，如代码中的Infinity。如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721576173.png" alt=""><br>我们可以通过给顶点数组和边数组输入数据，来创建邻接矩阵图。当然，由于是数组，需要先输入要创建的图的顶点数numVertexs和边数numEdges。代码如下：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">class</span> <span class="token class-name">AdjacencyMatrixGrpah</span>
<span class="token punctuation">{</span>
  <span class="token keyword">int</span> numVertexs<span class="token punctuation">;</span>
  <span class="token keyword">int</span> numEdges<span class="token punctuation">;</span>
  <span class="token keyword">object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> Vertexs<span class="token punctuation">;</span>
  <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">,</span><span class="token punctuation">]</span> EdgesMatrix<span class="token punctuation">;</span>

  <span class="token comment" spellcheck="true">//Infinity标识图中不存在的边</span>
  <span class="token keyword">const</span> <span class="token keyword">int</span> Infinity <span class="token operator">=</span> <span class="token number">66535</span><span class="token punctuation">;</span>

  <span class="token comment" spellcheck="true">//建立邻接矩阵图</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">CreateGraph</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      numVertexs <span class="token operator">=</span> Convert<span class="token punctuation">.</span><span class="token function">ToInt32</span><span class="token punctuation">(</span>Console<span class="token punctuation">.</span><span class="token function">ReadLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      numEdges <span class="token operator">=</span> Convert<span class="token punctuation">.</span><span class="token function">ToInt32</span><span class="token punctuation">(</span>Console<span class="token punctuation">.</span><span class="token function">ReadLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      Vertexs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">object</span><span class="token punctuation">[</span>numVertexs<span class="token punctuation">]</span><span class="token punctuation">;</span>
      EdgesMatrix <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>numVertexs<span class="token punctuation">,</span>numVertexs<span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token comment" spellcheck="true">//建立顶点数组</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numVertexs<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          Vertexs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> Console<span class="token punctuation">.</span><span class="token function">ReadLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token comment" spellcheck="true">//初始化边数组(邻接矩阵)</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numVertexs<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> numVertexs<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
              EdgesMatrix<span class="token punctuation">[</span>i<span class="token punctuation">,</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Infinity<span class="token punctuation">;</span>
          <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
      <span class="token comment" spellcheck="true">//将图中的带权边存储到邻接矩阵中</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> numEdges<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">int</span> i <span class="token operator">=</span> Convert<span class="token punctuation">.</span><span class="token function">ToInt32</span><span class="token punctuation">(</span>Console<span class="token punctuation">.</span><span class="token function">ReadLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token keyword">int</span> j <span class="token operator">=</span> Convert<span class="token punctuation">.</span><span class="token function">ToInt32</span><span class="token punctuation">(</span>Console<span class="token punctuation">.</span><span class="token function">ReadLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token keyword">int</span> weight <span class="token operator">=</span> Convert<span class="token punctuation">.</span><span class="token function">ToInt32</span><span class="token punctuation">(</span>Console<span class="token punctuation">.</span><span class="token function">ReadLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          EdgesMatrix<span class="token punctuation">[</span>i<span class="token punctuation">,</span> j<span class="token punctuation">]</span> <span class="token operator">=</span> weight<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>【注】：</p>
<ul>
<li>上面代码是针对有向图的，如果是无向图，只需要把<code>EdgesMatrix[i, j] = weight;</code>改为<code>EdgesMatrix[i, j] = EdgesMatrix[j, i] = weight;</code>，因为无向图的邻接矩阵是一个对称矩阵。</li>
<li>在邻接矩阵主对角线上的元素，即顶点到自身的边，我也是设置为Infinity的，并非像上图中那样主对角线上的元素都为0</li>
</ul>
</li>
<li><p>图的邻接表存储方式：<br>可以看到在图的邻接矩阵存储方式中，还有很多没有用到的空间，尤其是在稀疏图中，将会浪费很多存储空间。所以我们考虑用链表替换邻接矩阵中的每一行，减少空间浪费。但是图中每个结点的出度不一样，不方便把每个结点的邻接结点引用都存储的自身结点中，其实可以用类似树中的孩子表示法，把结点的所有邻接结点都用链表连起来。这就是图的邻接表存储方式，如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721576244.png" alt=""><br>需要的数据结构有：顶点类+邻接结点类+图(类)<br>顶点类由两个数据成员组成：顶点数据、第一个邻接结点的引用<br>邻接结点类由三个数据成员：邻接结点在数组中的下标、权值、下一个邻接结点的引用<br>图(类)的数据成员主要是：顶点类数组<br>代码如下：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">VertexNode</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">object</span> Data<span class="token punctuation">;</span>
  <span class="token keyword">public</span> AdjacencyNode FirstAdjacencyNode<span class="token punctuation">;</span>

  <span class="token keyword">public</span> <span class="token function">VertexNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      Data <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
      FirstAdjacencyNode <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">public</span> <span class="token function">VertexNode</span><span class="token punctuation">(</span><span class="token keyword">object</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      Data <span class="token operator">=</span> data<span class="token punctuation">;</span>
      FirstAdjacencyNode <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">//邻接结点类</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AdjacencyNode</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">int</span> NodeIndex<span class="token punctuation">;</span>
  <span class="token keyword">public</span> <span class="token keyword">int</span> Weight<span class="token punctuation">;</span>
  <span class="token keyword">public</span> AdjacencyNode NextAdjacencyNode<span class="token punctuation">;</span>

  <span class="token keyword">const</span> <span class="token keyword">int</span> Infinity <span class="token operator">=</span> <span class="token number">65535</span><span class="token punctuation">;</span>

  <span class="token keyword">public</span> <span class="token function">AdjacencyNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      NodeIndex <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
      Weight <span class="token operator">=</span> Infinity<span class="token punctuation">;</span>
      NextAdjacencyNode <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">public</span> <span class="token function">AdjacencyNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span><span class="token keyword">int</span> weight<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      NodeIndex <span class="token operator">=</span> index<span class="token punctuation">;</span>
      Weight <span class="token operator">=</span> weight<span class="token punctuation">;</span>
      NextAdjacencyNode <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">//邻接表图类</span>
<span class="token keyword">class</span> <span class="token class-name">AdjacencyListGraph</span>
<span class="token punctuation">{</span>
  <span class="token keyword">private</span> VertexNode<span class="token punctuation">[</span><span class="token punctuation">]</span> Vertexs<span class="token punctuation">;</span>
  <span class="token keyword">int</span> numVertexs<span class="token punctuation">;</span>
  <span class="token keyword">int</span> numEdges<span class="token punctuation">;</span>

  <span class="token comment" spellcheck="true">//建立邻接表图</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">CreateGraph</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      numVertexs <span class="token operator">=</span> Convert<span class="token punctuation">.</span><span class="token function">ToInt32</span><span class="token punctuation">(</span>Console<span class="token punctuation">.</span><span class="token function">ReadLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      numEdges <span class="token operator">=</span> Convert<span class="token punctuation">.</span><span class="token function">ToInt32</span><span class="token punctuation">(</span>Console<span class="token punctuation">.</span><span class="token function">ReadLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      Vertexs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VertexNode</span><span class="token punctuation">[</span>numVertexs<span class="token punctuation">]</span><span class="token punctuation">;</span>

      <span class="token comment" spellcheck="true">//建立顶点数组</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numVertexs<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">object</span> data <span class="token operator">=</span> Console<span class="token punctuation">.</span><span class="token function">ReadLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          Vertexs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VertexNode</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token comment" spellcheck="true">//建立顶点的邻接结点链表(边表)</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> numEdges<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">int</span> i <span class="token operator">=</span> Convert<span class="token punctuation">.</span><span class="token function">ToInt32</span><span class="token punctuation">(</span>Console<span class="token punctuation">.</span><span class="token function">ReadLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token keyword">int</span> j <span class="token operator">=</span> Convert<span class="token punctuation">.</span><span class="token function">ToInt32</span><span class="token punctuation">(</span>Console<span class="token punctuation">.</span><span class="token function">ReadLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token keyword">int</span> weight <span class="token operator">=</span> Convert<span class="token punctuation">.</span><span class="token function">ToInt32</span><span class="token punctuation">(</span>Console<span class="token punctuation">.</span><span class="token function">ReadLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

          AdjacencyNode newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AdjacencyNode</span><span class="token punctuation">(</span>j<span class="token punctuation">,</span> weight<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token comment" spellcheck="true">//头插法</span>
          newNode<span class="token punctuation">.</span>NextAdjacencyNode <span class="token operator">=</span> Vertexs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>FirstAdjacencyNode<span class="token punctuation">;</span>
          Vertexs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>FirstAdjacencyNode <span class="token operator">=</span> newNode<span class="token punctuation">;</span>

          <span class="token comment" spellcheck="true">//无向图还要同时对另一个顶点对称操作，有向图就不需要下面的代码了</span>
          AdjacencyNode newNode1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AdjacencyNode</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> weight<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token comment" spellcheck="true">//头插法</span>
          newNode1<span class="token punctuation">.</span>NextAdjacencyNode <span class="token operator">=</span> Vertexs<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>FirstAdjacencyNode<span class="token punctuation">;</span>
          Vertexs<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>FirstAdjacencyNode <span class="token operator">=</span> newNode1<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> 
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>图的十字链表存储方式</li>
<li>图的邻接多重表存储方式</li>
<li>图的边集数组存储方式</li>
</ul>
<hr>
<p><font size="4" color="orange">图的遍历</font><br>图的遍历：从图中某一顶点出发访遍图中其余顶点，且要求每个顶点仅被访问一次。分为深度优先遍历DFS(depth first search)和广度优先遍历BFS(breadth first search)。</p>
<ul>
<li>深度优先遍历DFS<br>先来看下面这个图<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721576302.png" alt=""><br>任意选择一个顶点，比如A点，现在开始想象在走这个迷宫，给自己定一个原则：没有碰到重复顶点时，就始终向右手边走，碰到了重复顶点则回退到上一个顶点处，再选择除开重复顶点外的最右手边的路(最右边没被访问过的邻接结点)，如果在某个顶点处所有的路都走过了(所有的邻接结点都被访问过了)，则回退到上一个顶点处。重复上述操作，一直到回退到起点A，这时就能保证连通图中的所有结点都被访问到了，且只被访问了一次(发现是重复结点的那一步不算)。<br>上图的访问过程如下：在A出一直沿着右手边走到F处，再向右走发现A被访问过了，回退到F，再访问F处除了A的最右手边结点G，在G点去访问B，发现B已经访问过了，回退到G，再去访问D，发现D已经访问过了，又回退到G，再访问H，在H点去访问D、E，发现D、E都已经访问过了，按原路回退到上一个访问过的结点G，也没有未被访问过的邻接点，再回退到F，同样没有未被访问过的结点，再回退到E，再回退到D，发现I是没有被访问过的，则去访问I，在I处没有未被访问过的邻接点，回退到D，再回退到C，回退到B，回退到A。此时回到了起点，则访问结束。<br>不难发现，这个访问过程其实就是一棵二叉树的前序遍历过程，如下图：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721576357.png" alt=""><br>所以，对图的深度优先遍历DFS，其实就是类似对树的前序遍历。<br>注意，上述过程是针对一个连通图来说的，如果不是连通图，则需要把图中每一个顶点作为起点，都来一次深度优先遍历DFS，这样就能保证非连通图也能访问到所有结点了。<br>对邻接矩阵图的深度优先遍历DFS的代码如下(还未上机验证过)：<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token comment" spellcheck="true">//标识每一个节点是否被访问过</span>
<span class="token keyword">bool</span><span class="token punctuation">[</span><span class="token punctuation">]</span> Visited<span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">DFSTraverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Visited <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">bool</span><span class="token punctuation">[</span>numVertexs<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numVertexs<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      Visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">false</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">DFS</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">//深度优先遍历DFS</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">DFS</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">true</span><span class="token punctuation">;</span>
  Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>Vertexs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> numVertexs<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>EdgesMatrix<span class="token punctuation">[</span>i<span class="token punctuation">,</span> j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> Visited<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token keyword">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token function">DFS</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
对邻接表图的深度优先遍历DFS的代码如下(还未上机验证过)：<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token comment" spellcheck="true">//标识每一个节点是否被访问过</span>
<span class="token keyword">bool</span><span class="token punctuation">[</span><span class="token punctuation">]</span> Visited<span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">DFSTraverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  Visited <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">bool</span><span class="token punctuation">[</span>numVertexs<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numVertexs<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
      Visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">false</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">DFS</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">//深度优先遍历DFS</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">DFS</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  Visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">true</span><span class="token punctuation">;</span>
  Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>Vertexs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>Data<span class="token punctuation">)</span><span class="token punctuation">;</span>
  AdjacencyNode current <span class="token operator">=</span> Vertexs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>FirstAdjacencyNode<span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>current <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>Visited<span class="token punctuation">[</span>current<span class="token punctuation">.</span>NodeIndex<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token keyword">false</span><span class="token punctuation">)</span>
      <span class="token punctuation">{</span>
          <span class="token function">DFS</span><span class="token punctuation">(</span>current<span class="token punctuation">.</span>NodeIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      current <span class="token operator">=</span> current<span class="token punctuation">.</span>NextAdjacencyNode<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>广度优先遍历BFS<br>深度优先遍历类似于树的前序遍历，其实广度优先遍历BFS类似于树的层序遍历。需要先把图调整称为层次分明一点的图。如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721576482.png" alt=""><br>由于是层序遍历，所以是需要借助队列的，如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721576547.png" alt=""><ol>
<li>先让图中的任意一个结点入队列</li>
<li>让队头的结点出队列，同时让与此结点相连的其他结点入队列</li>
<li>重复第2步，直到队列为空。<br>广度优先遍历BFS的代码如下：</li>
</ol>
</li>
</ul>
<hr>
<p>未完待续</p>
]]></content>
      
        <categories>
            
            <category> 数据结构 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 图 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[数据结构与算法之二叉树]]></title>
      <url>/2016/09/01/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      <content type="html"><![CDATA[<p><font size="4" color="orange">先来看几个二叉树的特点和概念：</font><br><a id="more"></a></p>
<ul>
<li>二叉树：<ul>
<li>二叉树的左子树和右子树是有顺序的，是有序树。</li>
<li>任意一颗二叉树的：叶子数=2度结点数+1</li>
</ul>
</li>
<li>满二叉树：每个分支结点都有左儿子和右儿子，且所有叶子结点位于同一层。如下图：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721608568.png" alt=""></li>
<li>完全二叉树：按层序编号后，对应结点编号和满二叉树完全相同(完全二叉树的结点数&lt;=满二叉树的结点数)。如下图：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/14772160862.png" alt=""><ul>
<li>所以，判断某二叉树是否是完全二叉树的方法：看着树的示意图，按照完全二叉树的结构逐层按顺序编号，如果编号出现空挡，则不是完全二叉树。</li>
<li>同样结点的二叉树，完全二叉树的深度最小</li>
<li>具有n个结点的完全二叉树的深度为：<img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721608663.png" alt=""></li>
<li>对具有n个结点的完全二叉树【前提条件是2i和2i+1均小于n】：<br>左孩子跟双亲满足关系：2i&lt;=&gt;i<br>右孩子跟双亲满足关系：2i+1&lt;=&gt;i</li>
</ul>
</li>
</ul>
<hr>
<p><font size="4" color="orange">顺序二叉树</font><br>任何一颗二叉树的顺序存储都是按其对应的完全二叉树的编号来的，当出现大量空挡(比如右倾斜树)时，会浪费很多存储空间，所以顺序存储一般只用于完全二叉树。<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721608712.png" alt=""></p>
<hr>
<p><font size="4" color="orange">链表二叉树</font></p>
<ul>
<li>链表二叉树的数据结构：结点类+树(类)<br>结点类由三个数据成员组成：结点数据、左儿子、右儿子<br>树(类)主要由一个数据成员组成：根结点</li>
<li>建立二叉树<br>要建立一颗二叉树，这棵二叉树应该是已经确定好的，而且需要事先知道该二叉树的前序序列(或中序序列、后序序列)。并且为了确认每一个结点是否有左右孩子，需要将原二叉树进行扩展，也就是将每个二叉树结点内的空指针用一个虚结点代替(假定虚结点数据为#)，得到一颗扩展二叉树。由扩展二叉树得到的前序序列称为完全前序序列。如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721608763.png" alt=""><br>上图的完全前序序列为：AB#D##C##，输入已知的完全前序序列，便能通过<code>CreateBinaryTree()</code>函数来建立该二叉树。代码见后面。</li>
<li>遍历二叉树<br>二叉树的遍历是从根节点开始的。按照根结点访问次序的不同，分为三种遍历方式：前序遍历、中序遍历、后序遍历，另外还有一种层序遍历。<ul>
<li>前序遍历：先根再左再右<br>遍历规则：若结点为空，则返回，否则先访问根结点，再访问左子树，再访问右子树。如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721608816.png" alt=""><br>遍历的顺序(前序序列)为：ABDGHCEIF</li>
<li>中序遍历：先左再根再右<br>遍历规则：若结点为空，则返回，否则先访问左子树，再访问根结点，再访问右子树。如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721608869.png" alt=""><br>遍历的顺序(中序序列)为：GDHBAEICF</li>
<li>后序遍历：先左再右再根<br>遍历规则：若结点为空，则返回，否则先访问根结点，再访问左子树，再访问右子树。如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721608928.png" alt=""><br>遍历的顺序(后序序列)为：GHDBIEFCA</li>
<li>层序遍历：按层从左到右访问结点<br>如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721608989.png" alt=""><br>遍历的顺序(层序序列)为：ABCDEFGHI</li>
</ul>
</li>
</ul>
<p>上面得到的各种遍历序列可以用来创建二叉树，当然也可以根据各种遍历方法来遍历已经创建好的二叉树，前序、中序、后序遍历的代码见后面。</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BinaryTreeNode</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">object</span> Data<span class="token punctuation">;</span>
    <span class="token keyword">public</span> BinaryTreeNode LeftChild<span class="token punctuation">;</span>
    <span class="token keyword">public</span> BinaryTreeNode RightChild<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token function">BinaryTreeNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Data <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        LeftChild <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        RightChild <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token function">BinaryTreeNode</span><span class="token punctuation">(</span><span class="token keyword">object</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Data <span class="token operator">=</span> data<span class="token punctuation">;</span>
        LeftChild <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        RightChild <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">BinaryTree</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> BinaryTreeNode root<span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">//按前序序列建立二叉树(中序、后序建立的代码类似)</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">CreateBinaryTree</span><span class="token punctuation">(</span><span class="token keyword">ref</span> BinaryTreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">object</span> data<span class="token punctuation">;</span>
        data<span class="token operator">=</span>Console<span class="token punctuation">.</span><span class="token function">ReadLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>data<span class="token punctuation">.</span><span class="token function">Equals</span><span class="token punctuation">(</span><span class="token string">"#"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            root <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BinaryTreeNode</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">CreateBinaryTree</span><span class="token punctuation">(</span><span class="token keyword">ref</span> root<span class="token punctuation">.</span>LeftChild<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">CreateBinaryTree</span><span class="token punctuation">(</span><span class="token keyword">ref</span> root<span class="token punctuation">.</span>RightChild<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">//前序遍历二叉树(中序、后序遍历的代码类似）</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">PreOrderTraverse</span><span class="token punctuation">(</span>BinaryTreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        Console<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>Data<span class="token operator">+</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">PreOrderTraverse</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>LeftChild<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">PreOrderTraverse</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>RightChild<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">//中序遍历二叉树</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">InOrderTraverse</span><span class="token punctuation">(</span>BinaryTreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token function">InOrderTraverse</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>LeftChild<span class="token punctuation">)</span><span class="token punctuation">;</span>
        Console<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>Data <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">InOrderTraverse</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>RightChild<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">//后序遍历二叉树</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">PostOrderTraverse</span><span class="token punctuation">(</span>BinaryTreeNode root<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token function">PostOrderTraverse</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>LeftChild<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">PostOrderTraverse</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>RightChild<span class="token punctuation">)</span><span class="token punctuation">;</span>
        Console<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>Data <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<hr>
<p><font size="4" color="orange">二叉树前序、中序、后序序列的推导</font></p>
<ul>
<li>小技巧：推导一棵树的前序、中序、后序序列时，可以想着对应的递归代码来推导，不容易出错。</li>
<li>已知前序序列和中序序列，推导后序序列：<br>把握两个关键点：前序、后序序列用于确定树或子树的根结点是谁，而中序序列用于确定哪些结点位于根节点左边，哪些结点位于根节点右边。<br>如：已知一颗二叉树前序序列为ABCDEF，中序序列为CBAEDF，求后序序列：<ol>
<li>根据前序序列ABCDEF可知，结点A为树的根结点(最前面的是根结点)，再由中序序列CBAEDF可知结点CB位于A的左边，结点EDF位于A的右边。如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721608989.png" alt=""></li>
<li>由前序序列中的BC可知，在BC子树中，B是根结点(最前面的是根节点)。又由中序序列的CB可知C应该位于B的左边。如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721609085.png" alt=""></li>
<li>由前序序列的DEF可知，在DEF子树中，D是根结点(最前面的是根结点)。又由中序序列的EDF可知E位于D的左边，F位于D的右边。如下图：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721609136.png" alt=""></li>
</ol>
</li>
<li>已知后序序列和中序序列，推导前序序列：<br>唯一的不同之处在于：如上面的第1、2、3步，在前序序列(先根再左再右)中，最前面的是根节点，而在后序序列(先左再右再根)中最后的才是根结点。</li>
<li>已知前序序列和后序序列，是无法唯一确定一颗二叉树的。原因很简单，因为没有中序序列，无法确定哪些结点位于根结点左边，哪些结点位于根结点右边。</li>
<li>【注】：不画出二叉树也可以很快推导对应序列。<strong>关键点在于：由前序或后序来确定根结点，由中序来确定哪些结点位于根结点左边，哪些结点位于根结点右边</strong>。如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147728182152.jpg" alt=""></li>
</ul>
<hr>
<p><font size="4" color="orange">线索二叉树</font></p>
<ul>
<li>在扩展二叉树里面，我们就已经看到一颗二叉树里其实还留有很多空引用(指针)，主要来源于叶子结点和单分支结点(1度结点)。</li>
<li>在链表二叉树里面，我们只能直接知道结点的左右儿子是谁，而如果要知道某个结点在对应序列中的前驱和后继是谁，就必须得重新遍历一次。</li>
<li>其实可以考虑把那些空引用用来存储结点的前驱和后继。更巧的是，一颗二叉树中的空引用数目和所有结点的前驱后继总数刚好相等。</li>
</ul>
<p>我们把这种指向前驱和后继的引用称为线索，加上线索的二叉树便成了线索二叉树。所以线索化的实质就是将链表二叉树中的空引用利用起来，去指向结点的前驱和后继。如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721609189.png" alt=""><br>将该二叉树线索化后：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/148930902158.png" alt=""><br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721609243.png" alt=""><br>仔细观察会发现线索化后的二叉树其实就是一个双向链表，如下图：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721609297.png" alt=""><br>既然是双向链表，那么可以给它加上一个头结点，方便我们既可以从第一个结点沿着后继进行遍历，也可以从最后一个结点沿着前驱进行遍历。</p>
<p>还有一个问题，原来的空引用变成了前驱和后继，那么怎么和原来那些指向左右儿子的非空引用区别开来呢？这时我们需要两个标志位，来分别标识两个引用到底是指向左右儿子还是作为前驱后继：ltag为0时表示指向结点的左儿子，为1时表示指向结点的前驱；rtag为0时表示指向结点的右儿子，为1时表示指向结点的后继。如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721609351.png" alt=""><br>线索二叉树的数据结构：<br>和二叉树的数据结构类似，只是结点类增加了两个数据成员：ltag、rtag。</p>
<p>可以在前序遍历的过程中就实现线索化。<br>由于线索二叉树其实是一个双向链表，所以可以按照链表的遍历方式来遍历线索二叉树了，省去了递归的大量开销。代码中的<code>CluePreOrderTraverse()</code>函数其实是模拟了二叉树的前序遍历，先一直向左，再向右，利用RightChild访问到下一个序列结点。可参考线索二叉树标题下的第一幅图（有后继的那幅图）。<br>部分代码如下：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">class</span> <span class="token class-name">ClueBinaryTreeNode</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">object</span> Data<span class="token punctuation">;</span>
    <span class="token keyword">public</span> ClueBinaryTreeNode LeftChild<span class="token punctuation">;</span>
    <span class="token keyword">public</span> ClueBinaryTreeNode RightChild<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> LeftTag<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> RightTag<span class="token punctuation">;</span>

    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">ClueBinaryTree</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> ClueBinaryTreeNode first<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//全局变量，指向刚刚访问过的结点</span>
    ClueBinaryTreeNode pre<span class="token punctuation">;</span>


    <span class="token keyword">public</span> <span class="token function">ClueBinaryTree</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        first <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClueBinaryTreeNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">//前序遍历过程中实现线索化</span>
    <span class="token keyword">void</span> <span class="token function">PreOrderTraverse</span><span class="token punctuation">(</span>ClueBinaryTreeNode root<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//设置当前结点的前驱</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>LeftChild <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            root<span class="token punctuation">.</span>LeftTag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
            root<span class="token punctuation">.</span>LeftChild <span class="token operator">=</span> pre<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">//设置前驱结点的后继为当前结点</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>pre<span class="token punctuation">.</span>RightChild <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            pre<span class="token punctuation">.</span>RightTag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
            pre<span class="token punctuation">.</span>RightChild <span class="token operator">=</span> root<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        pre <span class="token operator">=</span> root<span class="token punctuation">;</span>
        <span class="token function">PreOrderTraverse</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>LeftChild<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">PreOrderTraverse</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>RightChild<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">//用双向链表的方式来遍历线索二叉树</span>
    <span class="token keyword">void</span> <span class="token function">CluePreOrderTraverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        ClueBinaryTreeNode current<span class="token punctuation">;</span>
        current <span class="token operator">=</span> first<span class="token punctuation">.</span>LeftChild<span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>current <span class="token operator">!=</span> first<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>current<span class="token punctuation">.</span>LeftTag <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                current <span class="token operator">=</span> current<span class="token punctuation">.</span>LeftChild<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>current<span class="token punctuation">.</span>Data<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>current<span class="token punctuation">.</span>RightTag <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> current<span class="token punctuation">.</span>RightChild <span class="token operator">!=</span> first<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                current <span class="token operator">=</span> current<span class="token punctuation">.</span>RightChild<span class="token punctuation">;</span>
                Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>current<span class="token punctuation">.</span>Data<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            current <span class="token operator">=</span> current<span class="token punctuation">.</span>RightChild<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<hr>
<p><font size="4" color="orange">树、森林与二叉树的转换</font></p>
<ul>
<li>树转换为二叉树<ol>
<li>兄弟加线：在所有兄弟之间加一条连线</li>
<li>非长子去线：对树中每个结点，只保留它与第一个孩子结点的连线，删除它与其他孩子结点之间的连线</li>
<li>层次调整：以树和子树的根结点为轴心，将整棵树顺时针旋转一定的角度，使之结构层次分明。【注意第一个孩子是二叉树结点的左孩子，兄弟转换过来的孩子是结点的右孩子】<br>如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721609411.png" alt=""></li>
</ol>
</li>
<li><p>森林转换为二叉树：每棵树的根结点依次作为右兄弟</p>
<ol>
<li>把每个树转换为二叉树</li>
<li>把后一棵二叉树的根结点作为右孩子连到前一棵二叉树的根结点上。再调整层成层次分明的二叉树</li>
</ol>
<p>如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721609473.png" alt=""></p>
</li>
<li><p>二叉树转换为树</p>
<ol>
<li>加线：二叉树及其所有子树的根结点与它的长子的右孩子加线</li>
<li>去线：删除<strong>原</strong>二叉树中所有结点与其右孩子结点的连线</li>
<li>层次调整，使其结构层次分明</li>
</ol>
<p>如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/14772160953.png" alt=""></p>
</li>
<li><p>二叉树转换为森林(森林到二叉树的逆转换)</p>
<ol>
<li>首先要判断一棵二叉树能否转换成森林，需要看二叉树的根结点是否有右孩子，如果有则删掉与右孩子的连线。一直进行下去，直到分离的所有二叉树根结点与右孩子的连线都删除为止</li>
<li>将每棵分离的二叉树转换为树</li>
</ol>
<p>如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721609594.png" alt=""></p>
</li>
</ul>
<hr>
<p><font size="4" color="orange">二叉树的应用之哈夫曼树</font><br>树的带权路径长度WPL：树中所有叶子结点的权值乘以路径长度的和。<br>带权路径长度WPL最小的二叉树称为哈夫曼树。哈夫曼树又称带权最优二叉树。</p>
<ul>
<li>求解哈夫曼树的方法：</li>
</ul>
<ol>
<li>把所有带权值得叶子节点排成一个序列</li>
<li>取出权值最小的两个加起来，作为新结点，加入到序列中(取出的两个结点报废)，并在对应哈夫曼树的结构图作为取出的两个结点的双亲结点</li>
<li>重复第二步，直到序列中不再有结点为止</li>
</ol>
<p>假设六个字母的频率为A 27，B 8，C 15，D 15，E 30，F 5，则由它们构成的哈夫曼树如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721609648.png" alt=""><br>规定哈夫曼树的左分支代表0，右分支代表1，则从叶子结点到根结点的01序列就是对应字符的<strong>哈夫曼编码</strong>。</p>
]]></content>
      
        <categories>
            
            <category> 数据结构 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C#常用容器]]></title>
      <url>/2016/08/30/C#%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8/</url>
      <content type="html"><![CDATA[<p>C#常用容器如下：<br><a id="more"></a></p>
<ul>
<li>T[]：静态数组，连续内存，可快速地随机访问和遍历</li>
<li>List<t>：可变大小，固定类型，连续内存，可快速地随机访问和遍历</t></li>
<li>ArrayList：可变大小，泛型容器，但是性能开销大</li>
<li>LinkedList/LinkedListNode：双向链表，可快速地随机插入删除</li>
<li>Dictionary<key,value>：散列字典，快速查找，但是性能开销大</key,value></li>
<li>HashSet<key>：单项散列表，快速查找，但是性能开销大(优于Dictionary)</key></li>
<li>Queue：队列，快速入队出队</li>
<li>Stack：栈 </li>
</ul>
]]></content>
      
        <categories>
            
            <category> C#语法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C#容器 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[数据结构与算法之树]]></title>
      <url>/2016/08/30/%E6%A0%91/</url>
      <content type="html"><![CDATA[<p>树：任意一颗树或其子树都只有一个根节点，且子树之间互不相交。<br><a id="more"></a><br>节点的度：结点拥有的子树数目，或者说结点的直接子节点的数目。<br>树的度：树中所有结点的度的最大值。</p>
<p><strong>树的存储结构</strong></p>
<hr>
<ol>
<li><p>双亲表示法<br>为了让每一个结点都能很快地找到它的双亲结点，我们可以给每一个结点附加一个双亲结点引用，指向该结点的双亲结点。伪码如下：</p>
<pre><code>public class ParentNode {
    public object Data;
    public ParentNode Parent;

    public ParentNode() {
    }
}
class ParentTree {
    private ParentNode root;

    public ParentTree() {
    }
    ...
}
</code></pre><p>但是如果某结点想要找到它的子节点是谁，用上面的存储结构就得把整个树重新遍历一次。可以考虑给每个结点再增加一个长子(最左孩子)结点引用。如果结点还想要知道自己的兄弟是谁，可以考虑再给每个结点增加一个右兄弟结点引用。当然，如何设计要看具体情况，适度够用就好，要避免过度设计。<br>【注】：<br>树的双亲表示法用数组也很好实现，只需要把Parent引用改为双亲节点在数组中的位置(数组下标)即可。</p>
</li>
<li><p>孩子表示法<br>孩子表示法是从结点的n个孩子来看问题的。首先想到的表示方法应该是：把每个结点的所有孩子引用都在结点中存储起来，如下图：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721585304.png" alt=""><br>但是树的每个结点的孩子个数可能不一样，那结点到底该准备多少个孩子引用呢？一种方法是：让孩子引用个数等于树的度，但是这样会浪费很多引用的存储空间，因为很可能某些结点并没有那么多孩子。第二种方法是：让每个结点孩子引用的个数等于该结点的度，可是仔细考虑，虽然这种方法节省了存储空间，但是由于每个结点的引用个数不同，也就是每个结点的存储结构不一样，这会给遍历、查找、删除等等操作带来很大的运算开销，时间复杂度会很高。<br>其实问题的根源出在：为何一定要把所有孩子引用都存储到双亲结点中呢？上面的方法相当于在结点中开辟了一个数组，用来存储孩子引用，但是每个结点的这个数组大小是不一样的，相当于是需要一个动态变化的数组。而这恰巧是数组的弊端，一般数组的大小初始化后都是固定不变的，而解决数组这个弊端的方法就是用链表：把数组中的元素(结点的所有孩子)用链表连起来，这样就不用考虑结点到底该用多少个存储单元来放置孩子引用了。图示如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/14772158535.png" alt=""><br>不过总不能让这些结点及其链表都独立存在吧，需要用一个数组把这些节点存储起来就ok，每个节点跟着一个孩子链表，如下图：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721585404.png" alt=""><br>上图就是孩子表示法。</p>
<ul>
<li>树的孩子表示法的数据结构：表头结点类+孩子结点类+树(类)。</li>
<li>表头结点类由两个数据成员组成：结点数据+孩子结点引用(长子)</li>
<li>孩子结点类也由两个数据成员组成：结点的数组下标+孩子结点引用(指向该孩子结点的右兄弟)</li>
<li>树(类)主要由一个数据成员组成：表头结点数组</li>
</ul>
<p>伪码如下：</p>
<pre><code>public class ArrayNode {
    public object Data;
    public ChildNode FirstChild;

    public ArrayNode() {
    }
}

public class ChildNode {
    public int index;
    public ChildNode RightBrother;

    public ChildNode() {
    }
}

class ChildTree {
    ArrayNode[] Headers;

    public ChildTree() {
    }
    ...
}
</code></pre><p>如果结点还想知道它的双亲是谁，可以在表头结点中再加一个数据成员：双亲结点的数组下标，标识该结点的双亲结点是谁。这种表示结构叫孩子双亲表示法</p>
</li>
<li><p>孩子兄弟表示法：<br>孩子兄弟表示法是从结点的孩子和兄弟来看问题的。在孩子表示法中，是把一个结点的所有孩子都存储在一个链表中，也就是一个孩子和这个孩子的兄弟都在一个链表中。因为每一个孩子其实也是一个结点，而且它的右兄弟是唯一的，所以其实也可以把右兄弟引用搬到结点中去，作为结点的数据成员。这样就省去了给每个结点建立一个子链表的操作。图示如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721585457.png" alt=""><br>这棵树用孩子兄弟表示法如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721585511.png" alt=""><br>其实仔细看，上面的表示结构其实是一颗二叉树。所以，孩子兄弟表示法的最大好处在于它能够把一个复杂的树变成一颗二叉树。</p>
<ul>
<li>树的孩子兄弟表示法的数据结构：结点类+树(类)</li>
<li>结点类由三个数据成员组成：结点数据+孩子结点引用(指向结点的第一个孩子)+右兄弟结点引用</li>
<li>树(类)主要由一个数据成员组成：树根结点</li>
</ul>
<p>伪码如下：</p>
<pre><code>public class ChildBrotherNode {
    public object Data;
    ChildBrotherNode FirstChild;
    ChildBrotherNode RightBrother;

    public ChildBrotherNode() {
    }
}

class ChildBrotherTree {
    ChildBrotherNode root;

    public ChildBrotherTree() {
    }
    ...
}
</code></pre></li>
</ol>
<hr>
<p>二叉树请看另一篇博文<a href="http://popperelay.com/2016/09/01/%E4%BA%8C%E5%8F%89%E6%A0%91/" target="_blank" rel="external">《数据结构与算法之二叉树》</a></p>
]]></content>
      
        <categories>
            
            <category> 数据结构 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 树 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[数据结构与算法之队列]]></title>
      <url>/2016/08/28/%E9%98%9F%E5%88%97/</url>
      <content type="html"><![CDATA[<p>队列：只允许在一端进行插入操作，在另一端进行删除操作的线性表。允许插入的一端称为队尾，允许删除的一端称为队头。<br><a id="more"></a></p>
<p><strong>顺序队列</strong></p>
<hr>
<p>最简单的顺序队列：<br>由数组构成，入队时在数组元素尾部插入新元素，出队时移去数组下标为0的元素，同时其他数组元素向前移动一个位置。就像一群人在买票，前面的人离开，后面的人就会全部向前一步，补上空位。图示如下：<br>入队列：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721611234.png" alt=""><br>出队列：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721611281.png" alt=""><br>C#的容器已经实现了这个在尾部插入数据、在头部删除数据并且自动补位的功能，用C#容器实现的队列代码如下(由于C#自带实现队头队尾的插入删除，所以不需要队头队尾节点的引用)：</p>
<pre><code>class SequenceQueue
{
    private ArrayList Data;

    public SequenceQueue() {
        Data = new ArrayList();
    }
    //入队列
    public void EnQueue(object data) {
        Data.Add(data);
    }
    //出队列
    public void DeQueue(ref object data) {
        data = Data[0];
        Data.RemoveAt(0);
    }
    //查找队列第i个元素
    public object Find(int i) {
        return Data[i];
    }
    //清除队列
    public void Clear() {
        Data.Clear();
    }
    //队列元素个数
    public int Count() {
        return Data.Count;
    }
}
</code></pre><p><strong>循环队列</strong></p>
<hr>
<p>但是上面的队列实现方式有个性能缺陷：出队列时所有元素都要移位。所以我们可以设置一个队头和队尾的引用(指针)，出队列时直接把队头引用处的结点移除，入队列时直接把元素添加到队尾引用所在的节点，而其他元素不用动，只是在入队列和出队列时修改队头引用或者队尾引用即可。<br>所以，队头引用front指向队头元素，队尾引用rear指向队尾元素的下一个位置(方便下次入队时直接添加到该位置)。<br>但是，这种方式存在下图的尴尬(针对固定容量的队列，非ArrayList这种大小可变的容器)：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721611333.png" alt=""><br>若再在rear位置入队插入新元素，则会溢出，但是明显数组前面还有空位，是可以插入新元素的。就像坐公交，前面有空位置肯定是要去座的。为了让新元素能够按次序插入到前面的空位里去，应该把队列的首尾连起来，形成循环队列，这样新元素插入到前面的空位就水到渠成了。<br>还有一个问题，如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721611379.png" alt=""><br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721611433.png" alt=""><br>如上图所示，队列空和队列满的条件都是front==rear，为了区分他俩，我们人为设定：数组中只剩下一个空闲单元时，就认为队列已经满了。即敲定队列空的条件为：front==rear，队列满的条件为(rear+1)%QueueSize==front。如下图所示：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721611485.png" alt=""><br>综上，循环队列数据结构：数据成员：数组、队头引用front、队尾引用rear，方法成员：入队、出队等。代码如下：</p>
<pre><code>class RoundQueue
{
    private Object[] Data;
    private int front;
    private int rear;

    private int QueueSize;

    public RoundQueue() {
        QueueSize = 3;
        front = 0;
        rear = 0; 
        Data = new object[QueueSize];
    }
    //入队列
    public void EnQueue(object data) {
        //如果队列满，则不能再入队列
        if ((rear + 1) % QueueSize == front)
            return;
        Data[rear] = data;
        rear = (rear + 1) % QueueSize;
    }
    //出队列
    public void DeQueue(ref object data) {
        //如果队列空，则不能再出队列
        if (rear == front)
            return;
        data = Data[front];
        front = (front + 1) % QueueSize;
    }
    //队列中元素个数
    public int Count() {
        return (rear - front + QueueSize) % QueueSize;
    }
}
</code></pre><p><strong>优先队列</strong></p>
<hr>
<p>优先队列不再是每次移除队头的结点元素，而是每次出队优先级最高的结点。严格来说，它已经不算是一个队列。<br>对于优先队列，需要给每一个结点都加上一个表示优先级的数据成员，可以把结点单独写成一个类，如下：</p>
<pre><code>class PriorQueueNode{
    public object Data;
    public int Priority;
}
</code></pre><p>优先队列可以继承普通的顺序队列或者循环队列，但是需要重载出队列函数，伪码如下：</p>
<pre><code>public override object DeQueue(){
    //找出优先队列里优先级最大的结点
    for(;;){
    }
    //移除优先级最大的结点
    Remove();
}
</code></pre><p><strong>链队列</strong></p>
<hr>
<p>因为顺序队列的存储空间有限且大小是固定的，插入时会有溢出，所以我们需要链队列。<br>由于链队列需要在表头(队头)删除结点，删除结点需要知道该结点的前一个结点是谁，为了统一第一个结点和中间结点，需要给链队列加上一个头结点。<br>链队列的队头引用front其实就是指向头结点，是固定不动的，队尾引用rear是一直指向表中的最后一个结点(最后一个结点有Next成员，所以rear不需要指向最后一个结点的下一个位置)。代码如下：</p>
<pre><code>public class Node{
    public object Data;
    public Node Next;

    public Node() {
        Data = null;
        Next = null;
    }
    public Node(Object data) {
        Data = data;
        Next = null;
    }
}
class LinkQueue
{
    protected Node header;
    protected Node front;
    protected Node rear;

    public LinkQueue() {
        header = new Node();
        front = header;
        rear = header;
    }
    //入队列
    public void EnQueue(object data) {
        Node newNode = new Node(data);
        rear.Next = newNode;
        rear = newNode;
    }
    //出队列，队头引用front是不动的，一直指向头结点
    public void DeQueue(ref object data) {
        //队列空，则不再出队列
        if (front == rear)
            return;
        //队头结点(头结点)的下一个结点就是队尾结点(表中只有一个元素了),则出队列后让队尾引用重新指向头结点
        if (front.Next == rear)
            rear = header;
        data = front.Next.Data;
        front.Next = front.Next.Next;
    }
}
</code></pre><p>【注】：</p>
<ul>
<li>可以确定队列容量的情况下，建议使用循环队列，如果队列长度不能确定或者需要动态变化时，则需要用链队列</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 数据结构 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 队列 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[链表中什么时候需要用到头结点]]></title>
      <url>/2016/08/28/%E5%A4%B4%E7%BB%93%E7%82%B9/</url>
      <content type="html"><![CDATA[<p><strong>链表中什么时候需要用到头结点：</strong><br><a id="more"></a></p>
<hr>
<ul>
<li>需要统一对第一个结点和中间结点的操作 ，这时需要加上头结点</li>
<li>链接的方向(引用/指针指向的方向)是从表头指向表尾时，这时需要加上头结点，因为需要对开始节点初始化内存以后，才能使用Node.Next。不可能在插入结点的函数里去指定第一个插入的结点是表头结点，因为这样会增加复杂度，每次都要判断插入的结点会不会是表里的第一个节点</li>
<li>存在对链表的第一个结点的删除操作时，这时需要加上头结点。就像队列，出队列时需要删除表中第一个结点，如果链接方向是从表头指向表尾，虽然node=node.next就可以从容器中删除第一个结点，但是从第二条看，初始化时还是需要头结点的。</li>
<li>因为在栈里只存在对表尾结点的插入删除，不涉及中间结点，也不涉及对第一个结点的删除(栈中只有一个结点时，该结点也可以被看作是表尾结点来处理)，所以从原理上栈是可以不要头结点的，所有栈采用了从表尾指向表头的链接方式。而队列中存在对第一个结点的删除操作，所以是需要头结点作为辅助的。</li>
</ul>
<hr>
<p>链接方向从表头指向表尾(比如队列)：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721583543.png" alt=""><br>链接方向从表尾指向表头(比如栈)<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721583493.png" alt=""><br>【头结点：链表头部不存放数据的一个结点，是有真实内存的，不同于结点引用、头指针等等，头结点存在的意义在于降低程序/时间复杂度】</p>
]]></content>
      
        <categories>
            
            <category> 数据结构 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 头结点 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[数据结构与算法之栈]]></title>
      <url>/2016/08/26/%E6%A0%88/</url>
      <content type="html"><![CDATA[<p>栈：只允许在表尾(栈顶)进行插入和删除操作的的线性表。<br><a id="more"></a></p>
<p><strong>顺序栈</strong></p>
<hr>
<p>顺序栈是由数组+栈顶引用(指针)构成的。<br>由于是数组，所以下标较小的那一端作为固定的栈底。程序员习惯数字从0开始，所以当栈中存在一个元素时，栈顶引用top等于0，所以栈空时top=-1。</p>
<pre><code>class SequenceStack
{
    private ArrayList Data;
    private int Top;

    public SequenceStack() {
        Data = new ArrayList();
        Top = -1;
    }
    //进栈
    public void Push(object data) {
        Top++;
        Data.Add(data);
    }
    //出栈
    public void Pop(ref object data) {
        if (Top == -1) {
            return;
        }
        data = Data[Top];
        Top--;
    }
    //栈中元素数量
    public int Count() {
        return Data.Count;
    }
    //清空栈
    public void Clear() {
        Data.Clear();
        Top = -1;
    }
} 
</code></pre><p>【注】：</p>
<ul>
<li>上述代码用的是C#语言，如果用C++就不能再用ArrayList了，应该指定数组容量：Data[MaxSize]，且push操作还要在函数内加上数组是否越界的判断</li>
<li>实际问题中尽量使用List代替ArrayList，因为ArrayList性能开销大，可参考博客《<a href="https://popperelay.github.io/2016/08/30/C-%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8/" target="_blank" rel="external">C#常用容器</a>》</li>
</ul>
<p><strong>两顺序栈共享空间</strong></p>
<hr>
<ul>
<li>因为实际情况中，有可能出现一个栈已经满了，而另一个栈还有很多存储空间的情形。这时可以把两个栈合并成一个栈：它有两个栈底，一个栈底为数组的始端(下标最小处)，一个栈底为数组的末端(下标最大处)。这样由于两个栈底在数组的两端，所以对这两个栈进栈时，就会向数组的中间靠拢。</li>
<li>栈满就是两个栈见面之时，即Top1+1==Top2为栈满</li>
<li>Push和Pop操作时都要传入一个stackNumber参数，表示是对栈1还是栈2操作</li>
<li><p>适用情况：两个栈数据类型相同，且一个栈增长时另一个栈在缩短。</p>
<pre><code>class ShareStack
{
  Object[] Data;
  int Top1;
  int Top2;
  int MaxSize = 50;

  public ShareStack() {
      Data = new object[MaxSize];
      Top1 = -1;
      Top2 = MaxSize;
  }
  public void Push(Object data,int stackNumber) {
      //栈满就不能再push新元素了
      if (Top1 + 1 == Top2) {
          return;
      }
      if (stackNumber == 1){
          Top1++;
          Data[Top1] = data;
      }
      else if (stackNumber == 2) {
          Top2--;
          Data[Top2] = data;
      }
  }
  public void Pop(ref object data,int stackNumber) {
      if (stackNumber == 1){
          //栈1空则栈1不能再pop
          if (Top1 == -1)
              return;
          data = Data[Top1];
          Top1--;
      }
      else if (stackNumber == 2) {
          //栈2空则栈2不能再pop
          if (Top2 == MaxSize)
              return;
          data = Data[Top2];
          Top2++;
      }
  }
}
</code></pre></li>
</ul>
<p><strong>链栈</strong></p>
<hr>
<p>链栈其实就是对单链表的改造，由于链栈只在栈顶(表尾)插入删除，不会对链表中间结点有插入删除操作，所以链栈不再需要头结点。但是需要一个栈顶节点的引用(指针)</p>
<pre><code>public class Node {
    public Object Data;
    public Node Next;

    public Node() {
        Data = null;
        Next = null;
    }
    public Node(Object data) {
        Data = data;
        Next = null;
    }
} 
class LinkStack
{
    protected Node Top;

    public LinkStack(){
        Top = null;
    }
    //进栈
    public void Push(object data) {
        Node newNode = new Node(data);
        newNode.Next = Top;
        Top = newNode;
    }
    //出栈
    public void Pop(ref object data) {
        //栈空则不再出栈
        if (Top == null)
            return;
        data = Top.Data;
        Top = Top.Next;
    }
}
</code></pre><p><strong>栈的应用——递归之斐波那契数列</strong></p>
<hr>
<p>形如：0，1，1，2，3，5，8，13……，它除了第一项是0和第二项是1以外，其余每项都是其前两项的和，这个数列被称为斐波那契数列。用数学函数定义如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721538711.png" alt=""><br>不用递归输出斐波那契数列前40项，代码如下：</p>
<pre><code>static void Main(string[] args)
{
    int[] a = new int[40];
    a[0] = 0;
    a[1] = 1;
    Console.WriteLine(a[0]);
    Console.WriteLine(a[1]);
    for (int i = 2; i &lt; 40; i++) {
      a[i] = a[i - 1] + a[i - 2];
      Console.WriteLine(a[i]);
    }
    Console.ReadKey();
}
</code></pre><p>用递归输出斐波那契数列前40项，代码如下：</p>
<pre><code>static void Main(string[] args)
{
    for (int i = 0; i &lt; 40; i++) {
        Console.WriteLine(FBNQ(i));
    }
        Console.ReadKey();
}
static int FBNQ(int i) {
    if (i == 0)
        return 0;
    if (i == 1)
        return 1;
    return FBNQ(i - 1) + FBNQ(i - 2);
}
</code></pre><p>而编译器是用栈来实现递归的。在向下递归阶段，对于每一层递归，函数的局部变量、参数值以及返回地址都被压入栈中，在向上回溯阶段，位于栈顶的局部变量、参数值和返回地址被弹出，用于返回调用层次中执行代码的其余部分，也就是恢复了被调用时的状态。<br>【注】：</p>
<ul>
<li>每个递归定义必须至少有一个递归终止的条件，即不再是调用自身而是返回一个具体的值退出</li>
<li>大量的递归调用会建立函数的副本，会消耗大量的时间和内存。而像第一种代码这种迭代是不需要反复调用函数和占用额外内存的</li>
</ul>
<p><strong>栈的应用——四则运算表达式求值</strong></p>
<hr>
<p>为了方便计算机运算，需要把人们习惯的中缀表达式利用栈转化为计算机更容易处理的后缀表达式，计算机在后缀表达式的基础上再利用栈计算出最后的结果。所以分为两步：中缀转后缀表达式(逆波兰式)、后缀表达式计算结果</p>
<ul>
<li>中缀转后缀表达式<br>“9+(3-1)x3+10/2”，这是中缀表达式，而”9 3 1-3*+10 2/+”，这是它的后缀表达式。<br>中缀转后缀表达式的方法：<br>从左到右遍历中缀表达式的每个数字和符号，遇到数字则输出，作为后缀表达式的一部分，遇到符号，则判读当前符号与栈顶符号的优先级，若大于则进栈，否则使栈顶符号出栈，直到当前符号优先级大于栈顶符号优先级，再把当前符号进栈。重复上述操作一直到遍历完且栈空为止(即输出了最终的后缀表达式)<br>核心思想：遍历的当前符号的优先级大于栈顶符号优先级则进栈，否则出栈<br>图示如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/14772153876.png" alt=""><br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721538815.png" alt=""><br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/14772153887.png" alt=""><br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/14772153892.png" alt=""><br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721539038.png" alt=""></li>
<li>后缀表达式计算结果<br>从左到右遍历后缀表达式的每个数字和符号，遇到数字则进栈，遇到符号则让栈顶的两个数字出栈并进行运算，再将运算结果进栈。重复上述操作一直到栈空<br>核心思想：数字进栈，遇到符号则让数字出栈运算，运算结果再进栈<br>图示如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721539089.png" alt=""><br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721539149.png" alt=""><br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721539199.png" alt=""><br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721539248.png" alt=""><br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721539326.png" alt=""></li>
</ul>
<p>【注】：</p>
<ul>
<li>中缀转后缀表达式是符号进栈，而后缀表达式计算结果是数字进栈</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 数据结构 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[数据结构与算法之链表]]></title>
      <url>/2016/08/24/%E9%93%BE%E8%A1%A8/</url>
      <content type="html"><![CDATA[<p>由于数组的删除、插入是很费时的，所以我们需要链表。<br><a id="more"></a></p>
<hr>
<p>链表的数据结构：节点类+链表类</p>
<ul>
<li><p>节点类：表示链表中的节点，由两个数据成员组成：节点数据Data，指向表内下一节点的引用Link</p>
<pre><code>public class Node {
  public Object Data;
  public Node Next;

  public Node() {
      Data = null;
      Next = null;
  }
  public Node(Object theData) {
      Data = theData;
      Next = null;
  }
}
</code></pre></li>
<li><p>链表类：表示链表中节点之间的链接。数据成员只有一个头节点(如果要用到尾插法，则还需要一个尾节点)，类方法包括：构造函数、链表创建(分为头插法和尾插法)、查找、插入、删除、遍历</p>
<pre><code>class LinkedList
{
  protected Node header;
  protected Node tailer;

  public LinkedList() {
      header = new Node();
      tailer = header;
  }
  //头插法创建单链表(非整表创建)
  public void InsertHead(Object theData) {
      Node newNode = new Node(theData);
      newNode.Next = header.Next;
      header.Next = newNode;
  }
  //尾插法创建单链表(非整表创建)
  public void InsertTail(Object theData) {
      Node newNode = new Node(theData);
      tailer.Next = newNode;
      tailer = newNode;
  }
  //查找
  public Node Find(Object theData) {
      Node current = header.Next;
      while (current != null &amp;&amp; !current.Data.Equals(theData)) {
          current = current.Next;
      }
      return current;
  }
  //插入(在指定内容(theData)的节点后插入新节点)
  public void Insert(Object theData,Object newData) {
      Node current = header.Next;
      while (current != null &amp;&amp; !current.Data.Equals(theData)) {
          current = current.Next;
      }
      //以上的代码和Find方法一致
      if (current != null) {
          Node newNode = new Node(newData);
          newNode.Next = current.Next;
          current.Next = newNode;
      }
  }
  //删除(删除指定内容的节点)
  public void Remove(Object theData) {
      Node current = header.Next;
      Node previous = header.Next;
      while (current != null &amp;&amp; !current.Data.Equals(theData)) {
          previous = current;
          current = current.Next;
      }
      //以上代码和Find方法类似
      if (current != null) {
          previous.Next = current.Next;
      }
  }
  //遍历
  public void ShowList() {
      Node current = header.Next;
      while (current != null) {
          Console.WriteLine(current.Data);
          current = current.Next;
      }
  }       
}
</code></pre><p>注：</p>
</li>
<li>其中的头插法和尾插法都只是向链表中插入了一个节点，如果需要插入多个节点，多次调用即可。这是非整表创建的一种方式，如果需要整表创建，可在LinkedList类中加入如下代码：<pre><code>  //头插法整表创建
  public void CreateListHead(int n) {
      for (int i = 0; i &lt; n; i++) {
          Object data;
          data=Console.ReadLine();
          InsertHead(data);
      }
  }
  //尾插法整表创建
  public void CreateListTail(int n) {
      for (int i = 0; i &lt; n; i++) {
          object data;
          data = Console.ReadLine();
          InsertTail(data);
      }
  }
</code></pre></li>
<li>在代码中节点的数据类型是Object，而在实际问题中最好换成相应的数据类型，否则像<code>list.InsertTail(1);</code>等等传入数值时，将会发生多次装箱拆箱过程，浪费资源</li>
</ul>
<hr>
<p><strong>循环链表</strong><br>循环链表只是把单链表作些许改动：</p>
<ul>
<li>尾节点不再是指向null，而是指向头节点header</li>
<li>判断循环结束的条件不再是current是否为null，而是current不等于头节点header</li>
<li>为了让查找头节点和尾节点的时间复杂度都为O(1)，需要保留一个尾节点的引用(如上述代码中的tailer)，如下图：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721597924.png" alt=""></li>
<li>使用尾节点引用还可以方便地将两个链表链接成一个表：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721597983.png" alt=""><br>将上面两个循环链表合并成一个链表，如下：<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721598048.png" alt=""><br>合并的代码如下：<pre><code>headerA = rearA-&gt;next;  //保存A表的头节点,即图中1
rearA-&gt;next = rearB-&gt;next-&gt;next; //将A表的尾节点的Link指向B表的第一个节点(非B表头节点),即图中2
rearB-&gt;next = headerA; //将B表的尾节点的Link指向A表的头节点,即图中3
</code></pre></li>
</ul>
<hr>
<p><strong>双向链表</strong><br>双向链表在单链表上做出的改动：</p>
<ul>
<li><p>节点类增加一个数据成员prior，指向该结点的前驱结点。代码如下：</p>
<pre><code>public class Node {
  public Object Data;
  public Node next;
  public Node prior;  //双向链表新增的数据成员

  public Node() {
      Data = null;
      next = null;
      prior = null;
  }
  public Node(Object theData) {
      Data = theData;
      next = null;
      prior = null;
  }
}
</code></pre></li>
<li><p>插入结点时要不仅要考虑next，还要考虑prior<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721597816.png" alt=""><br>对应代码如下：(顺序很重要)     </p>
<pre><code>s-&gt;prior = p;
s-&gt;next = p-&gt;next;
p-&gt;next-&gt;prior = s;
p-&gt;next = s;
</code></pre></li>
<li><p>删除结点时也要考虑到prior<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721597869.png" alt=""><br>对应代码如下：</p>
<pre><code>p-&gt;prior-&gt;next = p-&gt;next;
p-&gt;next-&gt;prior = p-&gt;prior;
</code></pre></li>
</ul>
<hr>
<p><strong>链表中头结点存在的意义：</strong></p>
<ul>
<li>如果没有头结点，那么对链表的第一个节点和中间节点的插入删除操作就是不一样的，需要把第一个结点分开来处理，而有了头结点以后，原来的第一个结点和中间结点都变成了中间结点，不用再分开处理。加入头结点后对链表中的所有结点操作就变得一致了。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 数据结构 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C#语法之测试程序时间花费]]></title>
      <url>/2016/08/24/%E6%B5%8B%E8%AF%95%E7%A8%8B%E5%BA%8F%E6%97%B6%E9%97%B4/</url>
      <content type="html"><![CDATA[<p>不多说，直接上代码<br><a id="more"></a><br>    using System;<br>    using System.Diagnostics;</p>
<pre><code>namespace timeTest
{
    class Program
    {
        static void Main(string[] args){
            int[] nums = new int[100000];
            TimeSpan duration;
            BuildArray(nums);
            duration = Process.GetCurrentProcess().TotalProcessorTime;
            Console.WriteLine(&quot;Time: &quot;+duration.TotalSeconds);
            Console.ReadKey();
        }
        static void BuildArray(int[] arr){
            for (int i = 0; i &lt;= 99999; i++) {
                arr[i] = i;
            }      
        }
    }
}
</code></pre><ul>
<li>测试的是程序当前进程的处理器时间，不会包括控制台输出等进程所花费的时间</li>
<li>使用Process类需要<code>using System.Diagnostics;</code></li>
<li>TimeSpan类：表示一个时间间隔</li>
</ul>
]]></content>
      
        <categories>
            
            <category> C#语法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> timeTest </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[给博客添加多说评论]]></title>
      <url>/2016/08/23/%E8%AE%BE%E7%BD%AE%E5%A4%9A%E8%AF%B4%E8%AF%84%E8%AE%BA/</url>
      <content type="html"><![CDATA[<p><strong>Hexo+Github博客添加多说评论</strong><br><a id="more"></a></p>
<hr>
<ol>
<li>在<a href="http://duoshuo.com/" target="_blank" rel="external">多说官网</a> 点击我要安装，创建自己的多说域名，其中<a href="http://xxx.duoshuo.com" target="_blank" rel="external">http://xxx.duoshuo.com</a> 中的xxx就是自己的duoshuo_shortname</li>
<li>打开 <code>主题路径\_config.yml</code>，修改(\增加)duoshuo_shortname为<code>duoshuo_shortname: xxx</code>(xxx参考第一步，注意:后面有一个空格)</li>
<li>打开<code>主题路径\layout\_partial\comment.ejs</code>(不同主题路径可能不一样)，将<section></section>之间的代码替换为如下：<pre><code>&lt;h2 class=&quot;title&quot;&gt;&lt;%= __(&#39;comment&#39;) %&gt;&lt;/h2&gt;
&lt;% if(theme.duoshuo_shortname) { %&gt;
&lt;!-- 多说评论框 start --&gt;
  &lt;div class=&quot;ds-thread&quot; data-thread-key=&quot;&lt;%- page.path %&gt;&quot; data-title=&quot;&lt;%- page.title %&gt;&quot; data-url=&quot;&lt;%- page.permalink %&gt;&quot;&gt;&lt;/div&gt;
 &lt;!-- 多说评论框 end --&gt;
 &lt;!-- 多说公共JS代码 start (一个网页只需插入一次) --&gt;
 &lt;script type=&quot;text/javascript&quot;&gt;
 var duoshuoQuery = {short_name:&quot;duoshuo_shortname&quot;};   &lt;!-- 替换这里的duoshuo_shortname为第一步的xxx --&gt;
     (function() {
         var ds = document.createElement(&#39;script&#39;);
         ds.type = &#39;text/javascript&#39;;ds.async = true;
         ds.src = (document.location.protocol == &#39;https:&#39; ? &#39;https:&#39; : &#39;http:&#39;) + &#39;//static.duoshuo.com/embed.unstable.js&#39;;
         ds.charset = &#39;UTF-8&#39;;
         (document.getElementsByTagName(&#39;head&#39;)[0] 
          || document.getElementsByTagName(&#39;body&#39;)[0]).appendChild(ds);
     })();
     &lt;/script&gt;
 &lt;!-- 多说公共JS代码 end --&gt; 
        &lt;% } else if(config.disqus_shortname) { %&gt;
&lt;div id=&quot;disqus_thread&quot;&gt;
 &lt;noscript&gt;Please enable JavaScript to view the &lt;a href=&quot;//disqus.com/?ref_noscript&quot;&gt;comments powered by Disqus.&lt;/a&gt;&lt;/noscript&gt;
&lt;/div&gt;
&lt;% } %&gt;
</code></pre></li>
<li>重新部署到github即可。打开博客文章便能看到多说评论框了。</li>
</ol>
<p>【注：博主用的主题是transparent，在<a href="https://github.com/hexojs/hexo/wiki/Themes" target="_blank" rel="external">github主题官网</a>就能找到，其它主题可能配置方法不太一样，但大多数都大同小异】</p>
]]></content>
      
        <categories>
            
            <category> 博客配置 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 多说 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MarkDown的简单语法规则]]></title>
      <url>/2016/08/22/MarkDown%E8%AF%AD%E6%B3%95/</url>
      <content type="html"><![CDATA[<p><code>&lt;font size=&quot;5&quot; color=&quot;orange&quot;&gt;标题&lt;/font&gt;</code><br><a id="more"></a><br>### 标题2<br>###### 标题3<br>有序列表(嵌套时需要在序号前加空格)：<br>1. a<br>2. 阿斯顿<br> &nbsp;a. 阿斯顿<br> &nbsp;b. 阿达<br>3. 阿达<br>4. 阿斯顿</p>
<p>无序列表：<br>- 撒旦<br>- 阿斯顿<br>- 阿达</p>
<p>链接<br>[百度](<a href="http://baidu.com" target="_blank" rel="external">http://baidu.com</a>)<br>图片<br>![](<a href="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721517339.jpg" target="_blank" rel="external">http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721517339.jpg</a>)<br>引用<br>> 黄河远上白云间<br>> 一片孤城万仞山</p>
<p>分割线<br>***<br>*斜体*<br>**粗体**</p>
<p>表格(表格前要空一行，多一个|就会多一个单元格，其中冒号表示对齐方式)</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">
ad <span class="token operator">|</span> asd<span class="token operator">|</span> ad
<span class="token operator">:</span><span class="token operator">-</span> <span class="token operator">|</span> <span class="token operator">:</span><span class="token operator">-</span><span class="token operator">:</span> <span class="token operator">|</span> <span class="token operator">-</span><span class="token operator">:</span>
h <span class="token operator">|</span> j <span class="token operator">|</span> k
<span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2</span> <span class="token operator">|</span> <span class="token number">3</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码框(行)<br>`void fun(){<br>     destroy();<br>}`</p>
<p>代码框(段落),如下格式(或每一行代码前面加4个空格，且代码段前有空行)<br>```csharp<br>void fun(){<br>    destroy();<br>}<br>```</p>
<p>## 公式<br><code>$$J\_\alpha(x)=\sum _{m=0}^\infty \frac{(-1)^ m}{m! \, \Gamma (m + \alpha + 1)}{\left({\frac{x}{2}}\right)}^{2 m + \alpha }$$</code></p>
<p>***<br><code>&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=&quot;YellowGreen&quot;&gt;文本框背景色&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</code></p>
<p><strong>##所展示的效果如下</strong></p>
<hr>
<p><font size="5" color="orange">标题</font></p>
<h3 id="标题2"><a href="#标题2" class="headerlink" title="标题2"></a>标题2</h3><h6 id="标题3"><a href="#标题3" class="headerlink" title="标题3"></a>标题3</h6><p>有序列表：</p>
<ol>
<li>a</li>
<li>阿斯顿<br>a. 阿斯顿<br>b. 阿达</li>
<li>阿达</li>
<li>阿斯顿</li>
</ol>
<p>无序列表：</p>
<ul>
<li>撒旦</li>
<li>阿斯顿</li>
<li>阿达</li>
</ul>
<p>链接<br><a href="http://baidu.com" target="_blank" rel="external">百度</a><br>图片<br><img src="http://cfwjm.img48.wal8.com/img48/559974_20161023165829/147721517339.jpg" alt=""><br>引用</p>
<blockquote>
<p>黄河远上白云间<br>一片孤城万仞山</p>
</blockquote>
<p>分割线</p>
<hr>
<p><em>斜体</em><br><strong>粗体</strong></p>
<p>表格(表格前要空一行，多一个|就会多一个单元格)</p>
<table>
<thead>
<tr>
<th style="text-align:left">ad</th>
<th style="text-align:center">asd</th>
<th style="text-align:right">ad</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">h</td>
<td style="text-align:center">j</td>
<td style="text-align:right">k</td>
</tr>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:center">2</td>
<td style="text-align:right">3</td>
</tr>
</tbody>
</table>
<p>代码框(行)<br><code>void fun(){ 
     destroy();
}</code><br>代码框(段落),如下格式(或每一行代码前面加4个空格，且代码段前有空行)</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> 
<span class="token function">estroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><p>$$J_\alpha(x)=\sum _{m=0}^\infty \frac{(-1)^ m}{m! \, \Gamma (m + \alpha + 1)}{\left({\frac{x}{2}}\right)}^{2 m + \alpha }$$</p>
<hr>
<table><tr><td bgcolor="Olive">文本框背景色</td></tr></table>]]></content>
      
        <categories>
            
            <category> 博客配置 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MarkDown </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
